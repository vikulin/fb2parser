<?xml version="1.0" encoding="UTF-8"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink">
    <description>
        <title-info><genre>science</genre><author><first-name>Bruce</first-name><last-name>Eckel</last-name></author><book-title>Thinking In Java 4th Edition</book-title><lang>en-US</lang></title-info>
<document-info><author><first-name>Bruce</first-name><last-name>Eckel</last-name></author><program-used>ABBYY FineReader 12</program-used><date>130851714715330000</date><src-ocr>ABBYY FineReader 12</src-ocr><id>{A0298AEA-08BB-4AD3-8D65-1B3D6A8D877D}</id><version>1</version></document-info>
</description>
<body>
<section>
<p>Thinking</p>
<p>in</p>
<p>Java</p>
<p>Fourth Edition</p>
<p>Bruce Eckel</p>
<p>President, MindView, Inc. <a l:href="http://blog.teochew.cn/">teochew</a></p>
<section>
<title>
<p>Comments from readers:</p></title><empty-line/>
<p>Thinking In Java should be read cover to cover by every Java programmer, then kept close at hand for frequent reference. The exercises are challenging, and the chapter on Collections is superb! Not only did this book help me to pass the Sun Certified Java Programmer exam; it’s also the first book I turn to whenever I have a Java question. Jim Pleger, Loudoun County (Virginia) Government</p>
<p>Much better than any other Java book I’ve seen. Make that “by an order of magnitude”... very complete, with excellent right-to-the-point examples and intelligent, not dumbed-down, explanations ... In contrast to many other Java books I found it to be unusually mature, consistent, intellectually honest, well-written and precise. IMHO, an ideal book for studying Java. Anatoly Vorobey, Technion University, Haifa, Israel</p>
<p>One of the absolutely best programming tutorials I’ve seen for any language. Joakim Ziegler, FIX sysop</p>
<p>Thank you for your wonderful, wonderful book on Java. Dr. Gavin Pillay, Registrar, King Edward VIII Hospital, South Africa</p>
<p>Thank you again for your awesome book. I was really floundering (being a non-C programmer), but your book has brought me up to speed as fast as I could read it. It’s really cool to be able to understand the underlying principles and concepts from the start, rather than having to try to build that conceptual model through trial and error. Hopefully I will be able to attend your seminar in the not-too-distant future. Randall R. Hawley, Automation Technician, Eli Lilly &amp; Co.</p>
<p>The best computer book writing I have seen. Tom Holland</p>
<p>This is one of the best books I’ve read about a programming language... The best book ever written on Java. Ravindra Pai, Oracle Corporation, SUNOS product line</p>
<p>This is the best book on Java that I have ever found! You have done a great job. Your depth is amazing. I will be purchasing the book when it is published. I have been learning Java since October 96. I have read a few books, and consider yours a “MUST READ.” These past few months we have been focused on a product written entirely in Java. Your book has helped solidify topics I was shaky on and has expanded my knowledge base. I have even used some of your explanations as information in interviewing contractors to help our team. I have found how much Java knowledge they have by asking them about things I have learned from reading your book (e.g., the difference between arrays and Vectors). Your book is great!</p>
<p>Steve Wilkinson, Senior Staff Specialist, MCI Telecommunications</p>
<p>Great book. Best book on Java I have seen so far. Jeff Sinclair, Software Engineer, Kestral Computing</p>
<p>Thank you for Thinking in Java. It’s time someone went beyond mere language description to a thoughtful, penetrating analytic tutorial that doesn’t kowtow to The Manufacturers. I’ve read almost all the others—only yours and Patrick Winston’s have found a place in my heart. I’m already recommending it to customers. Thanks again. Richard Brooks, Java Consultant, Sun Professional Services, Dallas</p>
<p>Bruce, your book is wonderful! Your explanations are clear and direct. Through your fantastic book I have gained a tremendous amount of Java knowledge. The exercises are also FANTASTIC and do an excellent job reinforcing the ideas explained throughout the chapters. I look forward to reading more books written by you. Thank you for the tremendous service that you are providing by writing such great books. My code will be much better after reading</p>
<p>Thinking in Java. I thank you and I’m sure any programmers who will have to maintain my code are also grateful to you. Yvonne Watkins, Java Artisan, Discover Technologies, Inc.</p>
<p>Other books cover the WHAT of Java (describing the syntax and the libraries) or the HOW of Java (practical programming examples). Thinking in Java is the only book I know that explains the WHY of Java; why it was designed the way it was, why it works the way it does, why it sometimes doesn’t work, why it’s better than C++, why it’s not. Although it also does a good job of teaching the what and how of the language, Thinking in Java is definitely the thinking person’s choice in a Java book. Robert S. Stephenson</p>
<p>Thanks for writing a great book. The more I read it the better I like it. My students like it, too. Chuck Iverson</p>
<p>I just want to commend you for your work on Thinking in Java. It is people like you that dignify the future of the Internet and I just want to thank you for your effort. It is very much appreciated. Patrick Barrell, Network Officer Mamco, QAF Mfg. Inc.</p>
<p>I really, really appreciate your enthusiasm and your work. I download every revision of your online books and am looking into languages and exploring what I would never have dared (C#, C++, Python, and Ruby, as a side effect). I have at least 15 other Java books (I needed 3 to make both JavaScript and PHP viable!) and subscriptions to Dr. Dobbs, JavaPro, JDJ, JavaWorld, etc., as a result of my pursuit of Java (and Enterprise Java) and certification but I still keep your book in higher esteem. It truly is a thinking man’s book. I subscribe to your newsletter and hope to one day sit down and solve some of the problems you extend for the solutions guides for you (I’ll buy the guides!) in appreciation. But in the meantime, thanks a lot. Joshua Long, <a l:href="http://www.starbuxman.com">www.starbuxman.com</a></p>
<p>Most of the Java books out there are fine for a start, and most just have beginning stuff and a lot of the same examples. Yours is by far the best advanced thinking book I’ve seen. Please publish it soon! ... I also bought Thinking in C++just because I was so impressed with Thinking in Java. George Laframboise, LightWorx Technology Consulting, Inc.</p>
<p>I wrote to you earlier about my favorable impressions regarding your Thinking in C++ (a book that stands prominently on my shelf here at work). And today I’ve been able to delve into Java with your e-book in my virtual hand, and I must say (in my best Chevy Chase from Modern Problems), “I like it!” Very informative and explanatory, without reading like a dry textbook. You cover the most important yet the least covered concepts of Java development: the whys. Sean Brady</p>
<p>I develop in both Java and C++, and both of your books have been lifesavers for me. If I am stumped about a particular concept, I know that I can count on your books to a) explain the thought to me clearly and b) have solid examples that pertain to what I am trying to accomplish. I have yet to find another author that I continually whole-heartedly recommend to anyone who is willing to listen. Josh Asbury, А<sup>Л</sup>3 Software Consulting, Cincinnati, Ohio</p>
<p>Your examples are clear and easy to understand. You took care of many important details of Java that can’t be found easily in the weak Java documentation. And you don’t waste the reader’s time with the basic facts a programmer already knows. Kai Engert, Innovative Software, Germany</p>
<p>I’m a great fan of your Thinking in C++ and have recommended it to associates. As I go through the electronic version of your Java book, I’m finding that you’ve retained the same high level of writing. Thank you! Peter R. Neuwald</p>
<p>VERY well-written Java book...I think you’ve done a GREAT job on it. As the leader of a Chicagoarea Java special interest group, I’ve favorably mentioned your book and Web site several times at our recent meetings. I would like to use Thinking in Java as the basis for a part of each monthly SIG meeting, in which we review and discuss each chapter in succession. Mark Ertes</p>
<p>By the way, printed TIJ2 in Russian is still selling great, and remains bestseller. Learning Java became synonym of reading TIJ2, isn’t that nice? Ivan Porty, translator and publisher of Thinking in Java 2nd Edition in Russian</p>
<p>I really appreciate your work and your book is good. I recommend it here to our users and Ph.D. students. Hugues Leroy // Irisa-Inria Rennes France, Head of Scientific Computing and Industrial Tranfert</p>
<p>OK, I’ve only read about 40 pages of Thinking in Java, but I’ve already found it to be the most clearly written and presented programming book I’ve come across...and I’m a writer, myself, so I am probably a little critical. I have Thinking in C++ on order and can’t wait to crack it—I’m fairly new to programming and am hitting learning curves head-on everywhere. So this is just a quick note to say thanks for your excellent work. I had begun to burn a little low on enthusiasm from slogging through the mucky, murky prose of most computer books— even ones that came with glowing recommendations. I feel a whole lot better now. Glenn Becker, Educational Theatre Association</p>
<p>Thank you for making your wonderful book available. I have found it immensely useful in finally understanding what I experienced as confusing in Java and C++. Reading your book has been very satisfying. Felix Bizaoui, Twin Oaks Industries, Louisa, Va.</p>
<p>I must congratulate you on an excellent book. I decided to have a look at Thinking in Java based on my experience with Thinking in C++, and I was not disappointed. Jaco van der Merwe, Software Specialist, DataFusion Systems Ltd, Stellenbosch, South Africa</p>
<p>This has to be one of the best Java books I’ve seen. E.F. Pritchard, Senior Software Engineer, Cambridge Animation Systems Ltd., United Kingdom</p>
<p>Your book makes all the other Java books I’ve read or flipped through seem doubly useless and insulting. Brett Porter, Senior Programmer, Art &amp; Logic</p>
<p>I have been reading your book for a week or two and compared to the books I have read earlier on Java, your book seems to have given me a great start. I have recommended this book to a lot of my friends and they have rated it excellent. Please accept my congratulations for coming out with an excellent book. Rama Krishna Bhupathi, Software Engineer, TCSI Corporation, San Jose</p>
<p>Just wanted to say what a “brilliant” piece of work your book is. I’ve been using it as a major reference for in-house Java work. I find that the table of contents is just right for quickly locating the section that is required. It’s also nice to see a book that is not just a rehash of the API nor treats the programmer like a dummy. Grant Sayer, Java Components Group Leader, Ceedata Systems Pty Ltd, Australia</p>
<p>Wow! A readable, in-depth Java book. There are a lot of poor (and admittedly a couple of good) Java books out there, but from what I’ve seen yours is definitely one of the best. John Root, Web Developer, Department of Social Security, London</p>
<p>I’ve just started Thinking in Java. I expect it to be very good because I really liked Thinking in C++ (which I read as an experienced C++ programmer, trying to stay ahead of the curve)</p>
<p>... You are a wonderful author. Kevin K. Lewis, Technologist, ObjectSpace, Inc.</p>
<p>I think it’s a great book. I learned all I know about Java from this book. Thank you for making it available for free over the Internet. If you wouldn’t have I’d know nothing about</p>
<p>Java at all. But the best thing is that your book isn’t a commercial brochure for Java. It also shows the bad sides of Java. YOU have done a great job here. Frederik Fix, Belgium</p>
<p>I have been hooked to your books all the time. A couple of years ago, when I wanted to start with C++, it was C++ Inside &amp; Out which took me around the fascinating world of C++. It helped me in getting better opportunities in life. Now, in pursuit of more knowledge and when I wanted to learn Java, I bumped into Thinking in Java—no doubts in my mind as to whether I need some other book. Just fantastic. It is more like rediscovering myself as I get along with the book. It is just a month since I started with Java, and heartfelt thanks to you, I am understanding it better now. Anand Kumar S., Software Engineer, Computervision, India</p>
<p>Your book stands out as an excellent general introduction. Peter Robinson, University of Cambridge Computer Laboratory</p>
<p>It’s by far the best material I have come across to help me learn Java and I just want you to know how lucky I feel to have found it. THANKS! Chuck Peterson, Product Leader, Internet Product Line, IVIS International</p>
<p>The book is great. It’s the third book on Java I’ve started and I’m about two-thirds of the way through it now. I plan to finish this one. I found out about it because it is used in some internal classes at Lucent Technologies and a friend told me the book was on the Net. Good work. Jerry Nowlin, MTS, Lucent Technologies</p>
<p>Of the six or so Java books I’ve accumulated to date, your Thinking in Java is by far the best and clearest. Michael Van Waas, Ph.D., President, TMR Associates</p>
<p>I just want to say thanks for Thinking in Java. What a wonderful book you’ve made here! Not to mention downloadable for free! As a student I find your books invaluable (I have a copy of C++ Inside Out, another great book about C++), because they not only teach me the how-to, but also the whys, which are of course very important in building a strong foundation in languages such as C++ or Java. I have quite a lot of friends here who love programming just as I do, and I’ve told them about your books. They think it’s great! Thanks again! By the way, I’m Indonesian and I live in Java. Ray Frederick Djajadinata, Student at Trisakti University, Jakarta</p>
<p>The mere fact that you have made this work free over the Net puts me into shock. I thought I’d let you know how much I appreciate and respect what you’re doing. Shane LeBouthillier, Computer Engineering student, University of Alberta, Canada</p>
<p>I have to tell you how much I look forward to reading your monthly column. As a newbie to the world of object oriented programming, I appreciate the time and thoughtfulness that you give to even the most elementary topic. I have downloaded your book, but you can bet that I will purchase the hard copy when it is published. Thanks for all of your help. Dan Cashmer, B. C. Ziegler &amp; Co.</p>
<p>Just want to congratulate you on a job well done. First I stumbled upon the PDF version of Thinking in Java. Even before I finished reading it, I ran to the store and found Thinking in C++. Now, I have been in the computer business for over eight years, as a consultant, software engineer, teacher/trainer, and recently as self-employed, so I’d like to think that I have seen enough (not “have seen it all,” mind you, but enough). However, these books cause my girlfriend to call me a ”geek.” Not that I have anything against the concept—it is just that I thought this phase was well beyond me. But I find myself truly enjoying both books, like no other computer book I have touched or bought so far. Excellent writing style, very nice introduction of every new topic, and lots of wisdom in the books. Well done. Simon Goland, <a l:href="mailto:simonsez@smartt.com">simonsez@smartt.com</a>, Simon Says Consulting, Inc.</p>
<p>I must say that your Thinking in Java is great! That is exactly the kind of documentation I was looking for. Especially the sections about good and poor software design using Java. Dirk Duehr, Lexikon Verlag, Bertelsmann AG, Germany</p>
<p>Thank you for writing two great books (Thinking in C++, Thinking in Java). You have helped me immensely in my progression to object oriented programming. Donald Lawson, DCL Enterprises</p>
<p>Thank you for taking the time to write a really helpful book on Java. If teaching makes you understand something, by now you must be pretty pleased with yourself. Dominic Turner, GEAC Support</p>
<p>It’s the best Java book I have ever read—and I read some. Jean-Yves MENGANT, Chief Software Architect NAT-SYSTEM, Paris, France</p>
<p>Thinking in Java gives the best coverage and explanation. Very easy to read, and I mean the code fragments as well. Ron Chan, Ph.D., Expert Choice, Inc., Pittsburgh, Pa.</p>
<p>Your book is great. I have read lots of programming books and your book still adds insights to programming in my mind. Ningjian Wang, Information System Engineer, The Vanguard Group</p>
<p>Thinking in Java is an excellent and readable book. I recommend it to all my students. Dr. Paul Gorman, Department of Computer Science, University of Otago, Dunedin, New Zealand</p>
<p>With your book, I have now understood what object oriented programming means. ... I believe that Java is much more straightforward and often even easier than Perl. Torsten Romer, Orange Denmark</p>
<p>You make it possible for the proverbial free lunch to exist, not just a soup kitchen type of lunch but a gourmet delight for those who appreciate good software and books about it. Jose Suriol, Scylax Corporation</p>
<p>Thanks for the opportunity of watching this book grow into a masterpiece! IT IS THE BEST book on the subject that I’ve read or browsed. Jeff Lapchinsky, Programmer, Net Results Technologies</p>
<p>Your book is concise, accessible and a joy to read. Keith Ritchie, Java Research &amp; Development Team, KL Group Inc.</p>
<p>It truly is the best book I’ve read on Java! Daniel Eng</p>
<p>The best book I have seen on Java! Rich Hoffarth, Senior Architect, West Group</p>
<p>Thank you for a wonderful book. I’m having a lot of fun going through the chapters. Fred Trimble, Actium Corporation</p>
<p>You have mastered the art of slowly and successfully making us grasp the details. You make learning VERY easy and satisfying. Thank you for a truly wonderful tutorial. Rajesh Rau, Software Consultant</p>
<p>Thinking in Java rocks the free world! Miko O’Sullivan, President, Idocs Inc.</p>
<p>About Thinking in C+ +</p>
<p>Winner of the 1995 Software Development Magazine Jolt Award for Best Book of the Year</p>
<p>“This book is a tremendous achievement. You owe it to yourself to have a copy on your shelf. The chapter on iostreams is the most comprehensive and understandable treatment of that subject I’ve seen to date.”</p>
<p>Al Stevens</p>
<p>Contributing Editor, Doctor Dobbs Journal</p>
<p>“Eckel’s book is the only one to so clearly explain how to rethink program construction for object orientation. That the book is also an excellent tutorial on the ins and outs of C++ is an added bonus.”</p>
<p>Andrew Binstock Editor, Unix Review</p>
<p>“Bruce continues to amaze me with his insight into C++, and Thinking in C++ is his best collection of ideas yet. If you want clear answers to difficult questions about C++, buy this outstanding book.”</p>
<p>Gary Entsminger Author, The Tao of Objects</p>
<p>“Thinking in C++ patiently and methodically explores the issues of when and how to use inlines, references, operator overloading, inheritance, and dynamic objects, as well as advanced topics such as the proper use of templates, exceptions and multiple inheritance. The entire effort is woven in a fabric that includes Eckel’s own philosophy of object and program design. A must for every C++ developer’s bookshelf, Thinking in C++ is the one C++ book you must have if you’re doing serious development with C++.”</p>
<p>Richard Hale Shaw Contributing Editor, PC Magazine</p>
<p>Thinking</p>
<p>in</p>
<p>Java</p>
<subtitle>Fourth Edition</subtitle>
<p>Bruce Eckel</p>
<subtitle>President, MindView, Inc.</subtitle><image l:href="#image1.jpg"/>
<p>Upper Saddle River, NJ • Boston • Indianapolis • San Francisco New York • Toronto • Montreal • London • Munich • Paris Madrid • Capetown • Sydney • Tokyo • Singapore • Mexico City</p>
<p>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book, and the publisher was aware of a trademark claim, the designations have been printed with initial capital letters or in all capitals.</p>
<p>Java is a trademark of Sun Microsystems, Inc. Windows 95, Windows NT, Windows 2000, and Windows XP are trademarks of Microsoft Corporation. All other product names and company names mentioned herein are the property of their respective owners.</p>
<p>The author and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.</p>
<p>The publisher offers excellent discounts on this book when ordered in quantity for bulk purchases or special sales, which may include custom covers and/or content particular to your business, training goals, marketing focus, and branding interests. For more information, please contact:</p>
<p>U.S. Corporate and Government Sales (800) 382-3419</p>
<p><a l:href="mailto:corpsales@pearsontechgroup.com">corpsales@pearsontechgroup.com</a></p>
<p>For sales outside the U.S., please contact:</p>
<p>International Sales <a l:href="mailto:international@pearsoned.com">international@pearsoned.com</a></p>
<p>Visit us on the Web: <a l:href="http://www.prenhallprofessional.com">www.prenhallprofessional.com</a></p>
<p>Cover design and interior design by Daniel Will-Harris, <a l:href="http://www.Will-Harris.com">www.Will-Harris.com</a> Library of Congress Cataloging-in-Publication Data:</p>
<p>Eckel, Bruce.</p>
<p>Thinking in Java / Bruce Eckel.—4th ed. p. cm.</p>
<p>Includes bibliographical references and index.</p>
<p>ISBN 0-13-187248-6 (pbk. : alk. paper)</p>
<p>1. Java (Computer program language) I. Title.</p>
<p>QA76.73.J38E25 2006 005.13’3—dc22</p>
<p>2005036339</p>
<p>Copyright © 2006 by Bruce Eckel, President, MindView, Inc.</p>
<p>All rights reserved. Printed in the United States of America. This publication is protected by copyright, and permission must be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, recording, or likewise. For information regarding permissions, write to:</p>
<p>Pearson Education, Inc.</p>
<p>Rights and Contracts Department One Lake Street Upper Saddle River, NJ 07458 Fax: (201) 236-3290</p>
<p>ISBN 0-13-187248-6</p>
<p>Text printed in the United States on recycled paper at Courier in Stoughton, Massachusetts.</p>
<p>First printing, January 2006</p>
<table>
<tr><th>www. mindview. net</th></tr>
<tr><td><image l:href="#image2.jpg"/></td>
</tr>
</table>
<p>Seminars and Consulting</p><image l:href="#image3.jpg"/>
<p>Bruce Eckel and his associates are available for training in:</p>
<p>•    Object-oriented design</p>
<p>•    Java</p>
<p>•    Design patterns Consulting:</p>
<p>•    Starting your OO design process</p>
<p>•    Design reviews</p>
<p>•    Code reviews</p>
<p>•    Problem analysis</p>
<p>Public seminars are periodically held on various topics for individuals and small-staff training; check the calendar and seminar section at <a l:href="http://www.MindView.net">www.MindView.net</a> for more information.</p><image l:href="#image4.jpg"/>
<p>Dedication</p>
<p>To Dawn</p>
</section>
</section>
<section>
<title>
<p>Overview</p></title><empty-line/>
<table>
<tr><td>Preface</td><td>1</td></tr>
<tr><td>Introduction</td><td>9</td></tr>
<tr><td>Introduction to Objects</td><td>15</td></tr>
<tr><td>Everything Is an Object</td><td>41</td></tr>
<tr><td>Operators</td><td>63</td></tr>
<tr><td>Controlling Execution</td><td>93</td></tr>
<tr><td>Initialization &amp; Cleanup</td><td>107</td></tr>
<tr><td>Access Control</td><td>145</td></tr>
<tr><td>Reusing Classes</td><td>165</td></tr>
<tr><td>Polymorphism</td><td>193</td></tr>
<tr><td>Interfaces</td><td>219</td></tr>
<tr><td>Inner Classes</td><td>243</td></tr>
<tr><td>Holding Your Objects</td><td>275</td></tr>
<tr><td>Error Handling with Exceptions</td><td>313</td></tr>
<tr><td>Strings</td><td>355</td></tr>
<tr><td>Type Information</td><td>393</td></tr>
<tr><td>Generics</td><td>439</td></tr>
<tr><td>Arrays</td><td>535</td></tr>
<tr><td>Containers in Depth</td><td>567</td></tr>
<tr><td>I/O</td><td>647</td></tr>
<tr><td>Enumerated Types</td><td>725</td></tr>
<tr><td>Annotations</td><td>761</td></tr>
<tr><td>Concurrency</td><td>797</td></tr>
<tr><td>Graphical User Interfaces</td><td>933</td></tr>
<tr><td>A: Supplements</td><td>1035</td></tr>
<tr><td>B: Resources</td><td>1039</td></tr>
<tr><td>Index</td><td>1045</td></tr>
</table>
</section>
<section>
<title>
<p>What&apos;s Inside</p></title><empty-line/>
<p>Auto increment and</p>
<p>Building</p>
<p>Making a Collection</p>
</section>
<section>
<title>
<p>Preface</p></title><empty-line/>
<p>I originally approached Java as “just another programming language,” which in many senses it is.</p>
<p>But as time passed and I studied it more deeply, I began to see that the fundamental intent of this language was different from other languages I had seen up to that point.</p>
<p>Programming is about managing complexity: the complexity of the problem you want to solve, laid upon the complexity of the machine in which it is solved. Because of this complexity, most of our programming projects fail. And yet, of all the programming languages of which I am aware, almost none have gone all out and decided that their main design goal would be to conquer the complexity of developing and maintaining programs.<a l:href="#bookmark0" type="note"><sup>1</sup></a><sup></sup> Of course, many language design decisions were made with complexity in mind, but at some point there were always other issues that were considered essential to be added into the mix. Inevitably, those other issues are what cause programmers to eventually “hit the wall” with that language. For example, C++ had to be backwards-compatible with C (to allow easy migration for C programmers), as well as efficient. Those are both very useful goals and account for much of the success of C++, but they also expose extra complexity that prevents some projects from being finished (certainly, you can blame programmers and management, but if a language can help by catching your mistakes, why shouldn’t it?). As another example, Visual BASIC (VB) was tied to BASIC, which wasn’t really designed to be an extensible language, so all the extensions piled upon VB have produced some truly unmaintainable syntax. Perl is backwards-compatible with awk, sed, grep, and other Unix tools it was meant to replace, and as a result it is often accused of producing “write-only code” (that is, after a while you can’t read it). On the other hand, C++, VB, Perl, and other languages like Smalltalk had some of their design efforts focused on the issue of complexity and as a result are remarkably successful in solving certain types of problems.</p>
<p>What has impressed me most as I have come to understand Java is that somewhere in the mix of Sun’s design objectives, it seems that there was a goal of reducing complexity/or the programmer. As if to say, “We care about reducing the time and difficulty of producing robust code.” In the early days, this goal resulted in code that didn’t run very fast (although this has improved over time), but it has indeed produced amazing reductions in development time-half or less of the time that it takes to create an equivalent C++ program. This result alone can save incredible amounts of time and money, but Java doesn’t stop there. It goes on to wrap many of the complex tasks that have become important, such as multithreading and network programming, in language features or libraries that can at times make those tasks easy. And finally, it tackles some really big complexity problems: cross-platform programs, dynamic code changes, and even security, each of which can fit on your complexity spectrum anywhere from “impediment” to “show-stopper.” So despite the performance problems that we’ve seen, the promise of Java is tremendous: It can make us significantly more productive programmers.</p>
<p>In all ways-creating the programs, working in teams, building user interfaces to communicate with the user, running the programs on different types of machines, and easily writing programs that communicate across the Internet-Java increases the communication bandwidth between people.</p>
<p>I think that the results of the communication revolution may not be seen from the effects of moving large quantities of bits around. We shall see the true revolution because we will all communicate with each other more easily: one-on-one, but also in groups and as a planet.</p>
<p>I’ve heard it suggested that the next revolution is the formation of a kind of global mind that results from enough people and enough interconnectedness. Java may or may not be the tool that foments that revolution, but at least the possibility has made me feel like I’m doing something meaningful by attempting to teach the language.</p>
<section>
<title>
<p>Java SE5 and SE6</p></title><empty-line/>
<p>This edition of the book benefits greatly from the improvements made to the Java language in what Sun originally called JDK 1.5, and then later changed to JDK5 or J2SE5, then finally they dropped the outdated “2” and changed it to Java SE5. Many of the Java SE5 language changes were designed to improve the experience of the programmer. As you shall see, the Java language designers did not completely succeed at this task, but in general they made large steps in the right direction.</p>
<p>One of the important goals of this edition is to completely absorb the improvements of Java SE5/6, and to introduce and use them throughout this book. This means that this edition takes the somewhat bold step of being “Java SE5/6-only,” and much of the code in the book will not compile with earlier versions of Java; the build system will complain and stop if you try. However, I think the benefits are worth the risk.</p>
<p>If you are somehow fettered to earlier versions of Java, I have covered the bases by providing free downloads of previous editions of this book via <a l:href="http://www.MindView.net">www.MindView.net</a>. For various reasons, I have decided not to provide the current edition of the book in free electronic form, but only the prior editions.</p>
<subtitle>Java SE6</subtitle>
<p>This book was a monumental, time-consuming project, and before it was published, Java SE6 (code-named mustang) appeared in beta form. Although there were a few minor changes in Java SE6 that improved some of the examples in the book, for the most part the focus of Java SE6 did not affect the content of this book; the features were primarily speed improvements and library features that were outside the purview of this text.</p>
<p>The code in this book was successfully tested with a release candidate of Java SE6, so I do not expect any changes that will affect the content of this book. If there are any important changes by the time Java SE6 is officially released, these will be reflected in the book’s source code, which is downloadable from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>The cover indicates that this book is for “Java SE5/6,” which means “written for Java SE5 and the very significant changes that version introduced into the language, but is equally applicable to Java SE6.”</p>
</section>
<section>
<title>
<p>The 4<sup>th</sup> edition</p></title><empty-line/>
<p>The satisfaction of doing a new edition of a book is in getting things “right,” according to what I have learned since the last edition came out. Often these insights are in the nature of the saying “A learning experience is what you get when you don’t get what you want,” and my opportunity is to fix something embarrassing or simply tedious. Just as often, creating the next edition produces fascinating new ideas, and the embarrassment is far outweighed by the delight of discovery and the ability to express ideas in a better form than what I have previously achieved.</p>
<p>There is also the challenge that whispers in the back of my brain, that of making the book something that owners of previous editions will want to buy. This presses me to improve, rewrite and reorganize everything that I can, to make the book a new and valuable experience for dedicated readers.</p>
<subtitle>Changes</subtitle>
<p>The CD-ROM that has traditionally been packaged as part of this book is not part of this edition. The essential part of that Cd, the Thinking in C multimedia seminar (created for MindView by Chuck Allison), is now available as a downloadable Flash presentation. The goal of that seminar is to prepare those who are not familiar enough with C syntax to understand the material presented in this book. Although two of the chapters in this book give decent introductory syntax coverage, they may not be enough for people without an adequate background, and Thinking in C is intended to help those people get to the necessary level.</p>
<p>The Concurrency chapter (formerly called “Multithreading”) has been completely rewritten to match the major changes in the Java SE5 concurrency libraries, but it still gives you a basic foundation in the core ideas of concurrency. Without that core, it’s hard to understand more complex issues of threading. I spent many months working on this, immersed in that netherworld called “concurrency,” and in the end the chapter is something that not only provides a basic foundation but also ventures into more advanced territory.</p>
<p>There is a new chapter on every significant new Java SE5 language feature, and the other new features have been woven into modifications made to the existing material. Because of my continuing study of design patterns, more patterns have been introduced throughout the book as well.</p>
<p>The book has undergone significant reorganization. Much of this has come from the teaching process together with a realization that, perhaps, my perception of what a “chapter” was could stand some rethought. I have tended towards an unconsidered belief that a topic had to be “big enough” to justify being a chapter. But especially while teaching design patterns, I find that seminar attendees do best if I introduce a single pattern and then we immediately do an exercise, even if it means I only speak for a brief time (I discovered that this pace was also more enjoyable for me as a teacher). So in this version of the book I’ve tried to break chapters up by topic, and not worry about the resulting length of the chapters. I think it has been an improvement.</p>
<p>I have also come to realize the importance of code testing. Without a built-in test framework with tests that are run every time you do a build of your system, you have no way of knowing if your code is reliable or not. To accomplish this in the book, I created a test framework to display and validate the output of each program. (The framework was written in Python; you can find it in the downloadable code for this book at <a l:href="http://www.MindView.net">www.MindView.net</a>.) Testing in general is covered in the supplement you will find at <a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a>, which introduces what I now believe are fundamental skills that all programmers should have in their basic toolkit.</p>
<p>In addition, I’ve gone over every single example in the book and asked myself, “Why did I do it this way?” In most cases I have done some modification and improvement, both to make the examples more consistent within themselves and also to demonstrate what I consider to be best practices in Java coding (at least, within the limitations of an introductory text).</p>
<p>Many of the existing examples have had very significant redesign and reimplementation. Examples that no longer made sense to me were removed, and new examples have been added.</p>
<p>Readers have made many, many wonderful comments about the first three editions of this book, which has naturally been very pleasant for me. However, every now and then, someone will have complaints, and for some reason one complaint that comes up periodically is “The book is too big.” In my mind it is faint damnation indeed if “too many pages” is your only gripe. (One is reminded of the Emperor of Austria’s complaint about Mozart’s work: “Too many notes!” Not that I am in any way trying to compare myself to Mozart.) In addition, I can only assume that such a complaint comes from someone who is yet to be acquainted with the vastness of the Java language itself and has not seen the rest of the books on the subject. Despite this, one of the things I have attempted to do in this edition is trim out the portions that have become obsolete, or at least nonessential. In general, I’ve tried to go over everything, remove what is no longer necessary, include changes, and improve everything I could. I feel comfortable removing portions because the original material remains on the Web site (<a l:href="http://www.MindView.net">www.MindView.net</a>), in the form of the freely downloadable 1<sup>st</sup> through 3<sup>rd </sup>editions of the book, and in the downloadable supplements for this book.</p>
<p>For those of you who still can’t stand the size of the book, I do apologize. Believe it or not, I have worked hard to keep the size down.</p>
</section>
<section>
<title>
<p>Note on the cover design</p></title><empty-line/>
<p>The cover of Thinking in Java is inspired by the American Arts &amp; Crafts Movement that began near the turn of the century and reached its zenith between 1900 and 1920. It began in England as a reaction to both the machine production of the Industrial Revolution and the highly ornamental style of the Victorian era. Arts &amp; Crafts emphasized spare design, the forms of nature as seen in the art nouveau movement, hand-crafting, and the importance of the individual craftsperson, and yet it did not eschew the use of modern tools. There are many echoes with the situation we have today: the turn of the century, the evolution from the raw beginnings of the computer revolution to something more refined and meaningful, and the emphasis on software craftsmanship rather than just manufacturing code.</p>
<p>I see Java in this same way: as an attempt to elevate the programmer away from an operating system mechanic and toward being a “software craftsman.”</p>
<p>Both the author and the book/cover designer (who have been friends since childhood) find inspiration in this movement, and both own furniture, lamps, and other pieces that are either original or inspired by this period.</p>
<p>The other theme in this cover suggests a collection box that a naturalist might use to display the insect specimens that he or she has preserved. These insects are objects that are placed within the box objects. The box objects are themselves placed within the “cover object,” which illustrates the fundamental concept of aggregation in object-oriented programming. Of course, a programmer cannot help but make the association with “bugs,” and here the bugs have been captured and presumably killed in a specimen jar, and finally confined within a small display box, as if to imply Java’s ability to find, display, and subdue bugs (which is truly one of its most powerful attributes).</p>
<p>In this edition, I created the watercolor painting that you see as the cover background.</p>
</section>
<section>
<title>
<p>Acknowledgements</p></title><empty-line/>
<p>First, thanks to associates who have worked with me to give seminars, provide consulting, and develop teaching projects: Dave Bartlett, Bill Venners, Chuck Allison, Jeremy Meyer, and Jamie King. I appreciate your patience as I continue to try to develop the best model for independent folks like us to work together.</p>
<p>Recently, no doubt because of the Internet, I have become associated with a surprisingly large number of people who assist me in my endeavors, usually working from their own home offices. In the past, I would have had to pay for a pretty big office space to accommodate all these folks, but because of the Net, FedEx, and the telephone, I’m able to benefit from their help without the extra costs. In my attempts to learn to “play well with others,” you have all been very helpful, and I hope to continue learning how to make my own work better through the efforts of others. Paula Steuer has been invaluable in taking over my haphazard business practices and making them sane (thanks for prodding me when I don’t want to do something, Paula). Jonathan Wilcox, Esq., has sifted through my corporate structure and turned over every possible rock that might hide scorpions, and frog-marched us through the process of putting everything straight, legally. Thanks for your care and persistence. Sharlynn Cobaugh has made herself an expert in sound processing and an essential part of creating the multimedia training experiences, as well as tackling other problems. Thanks for your perseverance when faced with intractable computer problems. The folks at Amaio in Prague have helped me out with several projects. Daniel Will-Harris was the original work-by-Internet inspiration, and he is of course fundamental to all my graphic design solutions.</p>
<p>Over the years, through his conferences and workshops, Gerald Weinberg has become my unofficial coach and mentor, for which I thank him.</p>
<p>Ervin Varga was exceptionally helpful with technical corrections on the 4<sup>th</sup> edition—although other people helped on various chapters and examples, Ervin was my primary technical reviewer for the book, and he also took on the task of rewriting the solution guide for the 4<sup>th </sup>edition. Ervin found errors and made improvements to the book that were invaluable additions to this text. His thoroughness and attention to detail are amazing, and he’s far and away the best technical reader I’ve ever had. Thanks, Ervin.</p>
<p>My weblog on Bill Venners’ <a l:href="http://www.Artima.com">www.Artima.com</a> has been a source of assistance when I’ve needed to bounce ideas around. Thanks to the readers that have helped me clarify concepts by submitting comments, including James Watson, Howard Lovatt, Michael Barker, and others, in particular those who helped with generics.</p>
<p>Thanks to Mark Welsh for his continuing assistance.</p>
<p>Evan Cofsky continues to be very supportive by knowing off the top of his head all the arcane details of setting up and maintaining Linux-based Web servers, and keeping the MindView server tuned and secure.</p>
<p>A special thanks to my new friend, coffee, who generated nearly boundless enthusiasm for this project. Camp4 Coffee in Crested Butte, Colorado, has become the standard hangout when people have come up to take MindView seminars, and during seminar breaks it is the best catering I’ve ever had. Thanks to my buddy Al Smith for creating it and making it such a great place, and for being such an interesting and entertaining part of the Crested Butte experience. And to all the Camp4 barristas who so cheerfully dole out beverages.</p>
<p>Thanks to the folks at Prentice Hall for continuing to give me what I want, putting up with all my special requirements, and for going out of their way to make things run smoothly for me.</p>
<p>Certain tools have proved invaluable during my development process and I am very grateful to the creators every time I use these. Cygwin (<a l:href="http://www.cygwin.com">www.cygwin.com</a>) has solved innumerable problems for me that Windows can’t/won’t and I become more attached to it each day (if I only had this 15 years ago when my brain was still hard-wired with Gnu Emacs). IBM’s Eclipse (<a l:href="http://www.eclipse.org">www.eclipse.org</a>) is a truly wonderful contribution to the development community, and I expect</p>
<p>to see great things from it as it continues to evolve (how did IBM become hip? I must have missed a memo). JetBrains IntelliJ Idea continues to forge creative new paths in development tools. <a l:href="#bookmark1" type="note"><sup>2</sup></a><sup></sup> configuring it to my particular needs. I’ve also found Slava Pestov’s JEdit and plug-ins to be helpful at times (<a l:href="http://www.jedit.org">www.jedit.org</a>) and it’s quite a reasonable beginner’s editor for seminars.</p>
<p>And of course, if I don’t say it enough everywhere else, I use Python (<a l:href="http://www.Python.org">www.Python.org</a>) constantly to solve problems, the brainchild of my buddy Guido Van Rossum and the gang of goofy geniuses with whom I spent a few great days sprinting (Tim Peters, I’ve now framed that mouse you borrowed, officially named the “TimBotMouse”). You guys need to find healthier places to eat lunch. (Also, thanks to the entire Python community, an amazing bunch of people.)</p>
<p>Lots of people sent in corrections and I am indebted to them all, but particular thanks go to (for the 1<sup>st</sup> edition): Kevin Raulerson (found tons of great bugs), Bob Resendes (simply incredible), John Pinto, Joe Dante, Joe Sharp (all three were fabulous), David Combs (many grammar and clarification corrections), Dr. Robert Stephenson, John Cook, Franklin Chen, Zev Griner, David Karr, Leander A. Stroschein, Steve Clark, Charles A. Lee, Austin Maher, Dennis P. Roth, Roque Oliveira, Douglas Dunn, Dejan Ristic, Neil Galarneau, David B. Malkovsky, Steve Wilkinson, and a host of others. Prof. Ir. Marc Meurrens put in a great deal of effort to publicize and make the electronic version of the 1<sup>st</sup> edition of the book available in Europe.</p>
<p>Thanks to those who helped me rewrite the examples to use the Swing library (for the 2<sup>nd </sup>edition), and for other assistance: Jon Shvarts, Thomas Kirsch, Rahim Adatia, Rajesh Jain, Ravi Manthena, Banu Rajamani, Jens Brandt, Nitin Shivaram, Malcolm Davis, and everyone who expressed support.</p>
<p>In the 4<sup>th</sup> edition, Chris Grindstaff was very helpful during the development of the SWT section, and Sean Neville wrote the first draft of the Flex section for me.</p>
<p>Kraig Brockschmidt and Gen Kiyooka have been some of the smart technical people in my life who have become friends and have also been both influential and unusual in that they do yoga and practice other forms of spiritual enhancement, which I find quite inspirational and instructional.</p>
<p>It’s not that much of a surprise to me that understanding Delphi helped me understand Java, since there are many concepts and language design decisions in common. My Delphi friends provided assistance by helping me gain insight into that marvelous programming environment. They are Marco Cantu (another Italian—perhaps being steeped in Latin gives one aptitude for programming languages?), Neil Rubenking (who used to do the yoga/vegetarian/Zen thing until he discovered computers), and of course Zack Urlocker (the original Delphi product manager), a long-time pal whom I’ve traveled the world with. We’re all indebted to the brilliance of Anders Hejlsberg, who continues to toil away at C# (which, as you’ll learn in this book, was a major inspiration for Java SE5).</p>
<p>My friend Richard Hale Shaw’s insights and support have been very helpful (and Kim’s, too). Richard and I spent many months giving seminars together and trying to work out the perfect learning experience for the attendees.</p>
<p>The book design, cover design, and cover photo were created by my friend Daniel Will-Harris, noted author and designer (<a l:href="http://www.WUl-Harris.com">www.WUl-Harris.com</a>), who used to play with rub-on letters in</p>
<p>junior high school while he awaited the invention of computers and desktop publishing, and complained of me mumbling over my algebra problems. However, I produced the camera-ready pages myself, so the typesetting errors are mine. Microsoft® Word XP for Windows was used to write the book and to create camera-ready pages in Adobe Acrobat; the book was created directly from the Acrobat PDF files. As a tribute to the electronic age, I happened to be overseas when I produced the final versions of the 1<sup>st</sup> and 2<sup>nd</sup> editions of the book—the 1<sup>st </sup>edition was sent from Cape Town, South Africa, and the 2<sup>nd</sup> edition was posted from Prague.</p>
<p>The 3<sup>rd</sup> and 4<sup>th</sup> came from Crested Butte, Colorado. The body typeface is Georgia and the headlines are in Verdana. The cover typeface is ITC Rennie Mackintosh.</p>
<p>A special thanks to all my teachers and all my students (who are my teachers as well).</p>
<p>Molly the cat often sat in my lap while I worked on this edition, and thus offered her own kind of warm, furry support.</p>
<p>The supporting cast of friends includes, but is not limited to: Patty Gast (Masseuse extraordinaire), Andrew Binstock, Steve Sinofsky, JD Hildebrandt, Tom Keffer, Brian McElhinney, Brinkley Barr, Bill Gates at Midnight Engineering Magazine, Larry Constantine and Lucy Lockwood, Gene Wang, Dave Mayer, David Intersimone, Chris and Laura Strand, the Almquists, Brad Jerbic, Marilyn Cvitanic, Mark Mabry, the Robbins families, the Moelter families (and the McMillans), Michael Wilk, Dave Stoner, the Cranstons, Larry Fogg, Mike Sequeira, Gary Entsminger, Kevin and Sonda Donovan, Joe Lordi, Dave and Brenda Bartlett, Patti Gast, Blake, Annette &amp; Jade, the Rentschlers, the Sudeks, Dick, Patty, and Lee Eckel, Lynn and Todd, and their families. And of course, Mom and Dad.</p>
</section>
</section>
<section>
<title>
<p>Introduction</p></title><empty-line/>
<p>“He gave man speech, and speech created thought, Which is the measure of the Universe”—Prometheus Unbound, Shelley</p>
<p>Human beings ... are very much at the mercy of the particular language which has become the medium of expression for their society. It is quite an illusion to imagine that one adjusts to reality essentially without the use of language and that language is merely an incidental means of solving specific problems of communication and reflection. The fact of the matter is that the “real world” is to a large extent unconsciously built up on the language habits of the group.</p>
<p>The Status of Linguistics as a Science, 1929, Edward Sapir</p>
<p>Like any human language, Java provides a way to express concepts. If successful, this medium of expression will be significantly easier and more flexible than the alternatives as problems grow larger and more complex.</p>
<p>You can’t look at Java as just a collection of features—some of the features make no sense in isolation. You can use the sum of the parts only if you are thinking about design, not simply coding. And to understand Java in this way, you must understand the problems with the language and with programming in general. This book discusses programming problems, why they are problems, and the approach Java has taken to solve them. Thus, the set of features that I explain in each chapter are based on the way I see a particular type of problem being solved with the language. In this way I hope to move you, a little at a time, to the point where the Java mindset becomes your native tongue.</p>
<p>Throughout, I’ll be taking the attitude that you want to build a model in your head that allows you to develop a deep understanding of the language; if you encounter a puzzle, you’ll feed it to your model and deduce the answer.</p>
<section>
<title>
<p>Prerequisites</p></title><empty-line/>
<p>This book assumes that you have some programming familiarity: You understand that a program is a collection of statements, the idea of a subroutine/function/macro, control statements such as “if’ and looping constructs such as “while,” etc. However, you might have learned this in many places, such as programming with a macro language or working with a tool like Perl. As long as you’ve programmed to the point where you feel comfortable with the basic ideas of programming, you’ll be able to work through this book. Of course, the book will be easier for C programmers and more so for C++ programmers, but don’t count yourself out if you’re not experienced with those languages—however, come willing to work hard. Also, the Thinking in C multimedia seminar that you can download from <a l:href="http://www.MindView.net">www.MindView.net</a> will bring you up to speed in the fundamentals necessary to learn Java. However, I will be introducing the concepts of object-oriented programming (OOP) and Java’s basic control mechanisms.</p>
<p>Although references may be made to C and C++ language features, these are not intended to be insider comments, but instead to help all programmers put Java in perspective with those languages, from which, after all, Java is descended. I will attempt to make these references simple and to explain anything that I think a non-C/C++ programmer would not be familiar with.</p>
</section>
<section>
<title>
<p>Learning Java</p></title><empty-line/>
<p>At about the same time that my first book, Using C++ (Osborne/McGraw-Hill, 1989), came out, I began teaching that language. Teaching programming ideas has become my profession; I’ve seen nodding heads, blank faces, and puzzled expressions in audiences all over the world since 1987. As I began giving in-house training with smaller groups of people, I discovered something during the exercises. Even those people who were smiling and nodding were confused about many issues. I found out, by creating and chairing the C++ track at the Software Development Conference for a number of years (and later creating and chairing the Java track), that I and other speakers tended to give the typical audience too many topics too quickly. So eventually, through both variety in the audience level and the way that I presented the material, I would end up losing some portion of the audience. Maybe it’s asking too much, but because I am one of those people resistant to traditional lecturing (and for most people, I believe, such resistance results from boredom), I wanted to try to keep everyone up to speed.</p>
<p>For a time, I was creating a number of different presentations in fairly short order. Thus, I ended up learning by experiment and iteration (a technique that also works well in program design). Eventually, I developed a course using everything I had learned from my teaching experience. My company, MindView, Inc., now gives this as the public and in-house Thinking in Java seminar; this is our main introductory seminar that provides the foundation for our more advanced seminars. You can find details at <a l:href="http://www.MindView.net">www.MindView.net</a>. (The introductory seminar is also available as the Hands-On Java CD ROM. Information is available at the same Web site.)</p>
<p>The feedback that I get from each seminar helps me change and refocus the material until I think it works well as a teaching medium. But this book isn’t just seminar notes; I tried to pack as much information as I could within these pages, and structured it to draw you through into the next subject. More than anything, the book is designed to serve the solitary reader who is struggling with a new programming language.</p>
</section>
<section>
<title>
<p>Goals</p></title><empty-line/>
<p>Like my previous book, Thinking in C++, this book was designed with one thing in mind: the way people learn a language. When I think of a chapter in the book, I think in terms of what makes a good lesson during a seminar. Seminar audience feedback helped me understand the difficult parts that needed illumination. In the areas where I got ambitious and included too many features all at once, I came to know-through the process of presenting the material— that if you include a lot of new features, you need to explain them all, and this easily compounds the student’s confusion.</p>
<p>Each chapter tries to teach a single feature, or a small group of associated features, without relying on concepts that haven’t been introduced yet. That way you can digest each piece in the context of your current knowledge before moving on.</p>
<p>My goals in this book are to:</p>
<p>1.    Present the material one simple step at a time so that you can easily digest each idea before moving on. Carefully sequence the presentation of features so that you’re exposed to a topic before you see it in use. Of course, this isn’t always possible; in those situations, a brief introductory description is given.</p>
<p>2.    Use examples that are as simple and short as possible. This sometimes prevents me from tackling “real world” problems, but I’ve found that beginners are usually happier when they can understand every detail of an example rather than being impressed by</p>
<p>the scope of the problem it solves. Also, there’s a severe limit to the amount of code that can be absorbed in a classroom situation. For this I will no doubt receive criticism for using “toy examples,” but I’m willing to accept that in favor of producing something pedagogically useful.</p>
<p>3.    Give you what I think is important for you to understand about the language, rather than everything that I know. I believe there is an information importance hierarchy, and that there are some facts that 95 percent of programmers will never need to know-details that just confuse people and increase their perception of the complexity of the language. To take an example from C, if you memorize the operator precedence table (I never did), you can write clever code. But if you need to think about it, it will also confuse the reader/maintainer of that code. So forget about precedence, and use parentheses when things aren’t clear.</p>
<p>4.    Keep each section focused enough so that the lecture time-and the time between exercise periods-is small. Not only does this keep the audience’s minds more active and involved during a hands-on seminar, but it gives the reader a greater sense of accomplishment.</p>
<p>5.    Provide you with a solid foundation so that you can understand the issues well enough to move on to more difficult coursework and books.</p>
</section>
<section>
<title>
<p>Teaching from this book</p></title><empty-line/>
<p>The original edition of this book evolved from a one-week seminar which was, when Java was in its infancy, enough time to cover the language. As Java grew and continued to encompass more and more features and libraries, I stubbornly tried to teach it all in one week. At one point, a customer asked me to teach “just the fundamentals,” and in doing so I discovered that trying to cram everything into a single week had become painful for both myself and for seminarians. Java was no longer a “simple” language that could be taught in a week.</p>
<p>That experience and realization drove much of the reorganization of this book, which is now designed to support a two-week seminar or a two-term college course. The introductory portion ends with the Error Handling with Exceptions chapter, but you may also want to supplement this with an introduction to JDBC, Servlets and JSPs. This provides a foundation course, and is the core of the Hands-On Java CD ROM. The remainder of the book comprises an intermediatelevel course, and is the material covered in the Intermediate Thinking in Java CD ROM. Both of these CD ROMs are for sale at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>Contact Prentice-Hall at <a l:href="http://www.prenhallprofessional.com">www.prenhallprofessional.com</a> for information about professor support materials for this book.</p>
</section>
<section>
<title>
<p>JDK HTML documentation</p></title><empty-line/>
<p>The Java language and libraries from Sun Microsystems (a free download from <a l:href="http://java.sun.com">http://java.sun.com</a>) come with documentation in electronic form, readable using a Web browser. Many books published on Java have duplicated this documentation. So you either already have it or you can download it, and unless necessary, this book will not repeat that documentation, because it’s usually much faster if you find the class descriptions with your Web browser than if you look them up in a book (and the online documentation is probably more upto-date). You’ll simply be referred to “the JDK documentation.” This book will provide extra descriptions of the classes only when it’s necessary to supplement that documentation so you can understand a particular example.</p>
</section>
<section>
<title>
<p>Exercises</p></title><empty-line/>
<p>I’ve discovered that simple exercises are exceptionally useful to complete a student’s understanding during a seminar, so you’ll find a set at the end of each chapter.</p>
<p>Most exercises are designed to be easy enough that they can be finished in a reasonable amount of time in a classroom situation while the instructor observes, making sure that all the students are absorbing the material. Some are more challenging, but none present major challenges.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
<section>
<title>
<p>Foundations for Java</p></title><empty-line/>
<p>Another bonus with this edition is the free multimedia seminar that you can download from <a l:href="http://www.MindView.net">www.MindView.net</a>. This is the Thinking in C seminar that gives you an introduction to the C syntax, operators, and functions that Java syntax is based upon. In previous editions of the book this was in the Foundations for Java CD that was packaged with the book, but now the seminar may be freely downloaded.</p>
<p>I originally commissioned Chuck Allison to create Thinking in C as a standalone product, but decided to include it with the 2<sup>nd</sup> edition of Thinking in C++ and 2<sup>nd</sup> and 3<sup>rd</sup> editions of Thinking in Java because of the consistent experience of having people come to seminars without an adequate background in basic C syntax. The thinking apparently goes “I’m a smart programmer and I don’t want to learn C, but rather C++ or Java, so I’ll just skip C and go directly to C++/Java.” After arriving at the seminar, it slowly dawns on folks that the prerequisite of understanding C syntax is there for a very good reason.</p>
<p>Technologies have changed, and it made more sense to rework Thinking in C as a downloadable Flash presentation rather than including it as a CD. By providing this seminar online, I can ensure that everyone can begin with adequate preparation.</p>
<p>The Thinking in C seminar also allows the book to appeal to a wider audience. Even though the Operators and Controlling Execution chapters do cover the fundamental parts of Java that come from C, the online seminar is a gentler introduction, and assumes even less about the student’s programming background than does the book.</p>
</section>
<section>
<title>
<p>Source code</p></title><empty-line/>
<p>All the source code for this book is available as copyrighted freeware, distributed as a single package, by visiting the Web site <a l:href="http://www.MindView.net">www.MindView.net</a>. To make sure that you get the most current version, this is the official code distribution site. You may distribute the code in classroom and other educational situations.</p>
<p>The primary goal of the copyright is to ensure that the source of the code is properly cited, and to prevent you from republishing the code in print media without permission. (As long as the source is cited, using examples from the book in most media is generally not a problem.)</p>
<p>In each source-code file you will find a reference to the following copyright notice:</p>
<p>//:! Copyright.txt This computer source code is Copyright ©2006 MindView, Inc. AH Rights Reserved.</p>
<p>Permission to use, copy, modify, and distribute this computer source code (Source Code) and its documentation without fee and without a written agreement for the purposes set forth below is hereby granted, provided that the above copyright notice, this paragraph and the following five numbered paragraphs appear in all copies.</p>
<p>1.    Permission is granted to compile the Source Code and to include the compiled code, in executable format only, in personal and commercial software programs.</p>
<p>2.    Permission is granted to use the Source Code without modification in classroom situations, including in presentation materials, provided that the book &quot;Thinking in Java&quot; is cited as the origin.</p>
<p>3.    Permission to incorporate the Source Code into printed media may be obtained by contacting:</p>
<p>MindView, Inc. 5343 Valle Vista La Mesa, California 91941 <a l:href="mailto:Wayne@MindView.net">Wayne@MindView.net</a></p>
<p>4.    The Source Code and documentation are copyrighted by MindView, Inc. The Source code is provided without express or implied warranty of any kind, including any implied warranty of merchantability, fitness for a particular purpose or non-infringement. MindView, Inc. does not warrant that the operation of any program that includes the Source Code will be uninterrupted or error-free. MindView, Inc. makes no representation about the suitability of the Source Code or of any software that includes the Source Code for any purpose. The entire risk as to the quality and performance of any program that includes the Source Code is with the user of the Source Code. The user understands that the Source Code was developed for research and instructional purposes and is advised not to rely exclusively for any reason on the Source Code or any program that includes the Source Code. Should the Source Code or any resulting software prove defective, the user assumes the cost of all necessary servicing, repair, or correction.</p>
<p>5.    IN NO EVENT SHALL MINDVIEW, INC., OR ITS PUBLISHER BE LIABLE TO ANY PARTY UNDER ANY LEGAL THEORY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS, OR FOR PERSONAL INJURIES, ARISING OUT OF THE USE OF THIS SOURCE CODE AND ITS DOCUMENTATION, OR ARISING OUT OF THE INABILITY TO USE ANY RESULTING PROGRAM, EVEN IF MINDVIEW, INC., OR ITS PUBLISHER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. MINDVIEW, INC. SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOURCE CODE AND DOCUMENTATION PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, WITHOUT ANY ACCOMPANYING SERVICES FROM MINDVIEW, INC., AND MINDVIEW, INC. HAS NO</p>
<p>OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.</p>
<p>Please note that MindView, Inc. maintains a Web site which is the sole distribution point for electronic copies of the Source Code, <a l:href="http://www.MindView.net">http://www.MindView.net</a> (and official mirror sites), where it is freely available under the terms stated above.</p>
<p>If you think you’ve found an error in the Source Code, please submit a correction using the feedback system that you will find at <a l:href="http://www.MindView.net">http://www.MindView.net</a>. ///:~</p>
<p>You may use the code in your projects and in the classroom (including your presentation materials) as long as the copyright notice that appears in each source file is retained.</p>
<subtitle>Coding standards</subtitle>
<p>In the text of this book, identifiers (methods, variables, and class names) are set in bold. Most keywords are also set in bold, except for those keywords that are used so much that the bolding can become tedious, such as “class.”</p>
<p>I use a particular coding style for the examples in this book. As much as possible, this follows the style that Sun itself uses in virtually all of the code you will find at its site (see <a l:href="http://java.sun.com/docs/codeconv/index.htmT">http://java.sun.com/docs/codeconv/index.htmT</a>), and seems to be supported by most Java development environments. If you’ve read my other works, you’ll also notice that Sun’s coding style coincides with mine—this pleases me, although I had nothing (that I know of) to do with it. The subject of formatting style is good for hours of hot debate, so I’ll just say I’m not trying to dictate correct style via my examples; I have my own motivation for using the style that I do. Because Java is a free-form programming language, you can continue to use whatever style you’re comfortable with. One solution to the coding style issue is to use a tool like Jalopy (<a l:href="http://www.triemax.com">www.triemax.com</a>), which assisted me in developing this book, to change formatting to that which suits you.</p>
<p>The code files printed in the book are tested with an automated system, and should all work without compiler errors.</p>
<p>This book focuses on and is tested with Java SE5/6. If you need to learn about earlier releases of the language that are not covered in this edition, the 1<sup>st</sup> through 3<sup>rd</sup> editions of the book are freely downloadable at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
<section>
<title>
<p>Errors</p></title><empty-line/>
<p>No matter how many tools a writer uses to detect errors, some always creep in and these often leap off the page for a fresh reader. If you discover anything you believe to be an error, please use the link you will find for this book at <a l:href="http://www.MindView.net">www.MindView.net</a> to submit the error along with your suggested correction. Your help is appreciated.</p>
</section>
</section>
<section>
<title>
<p>Introduction to Objects</p></title><empty-line/>
<p>“We cut nature up, organize it into concepts, and ascribe significances as we do, largely because we are parties to an agreement that holds throughout our speech community and is codified in the patterns of our language ... we cannot talk at all except by subscribing to the organization and classification of data which the agreement decrees.” Benjamin Lee Whorf (1897-1941)</p>
<p>The genesis of the computer revolution was in a machine. The genesis of our programming languages thus tends to look like that machine.</p>
<p>But computers are not so much machines as they are mind amplification tools (“bicycles for the mind,” as Steve Jobs is fond of saying) and a different kind of expressive medium. As a result, the tools are beginning to look less like machines and more like parts of our minds, and also like other forms of expression such as writing, painting, sculpture, animation, and filmmaking. Object-oriented programming (OOP) is part of this movement toward using the computer as an expressive medium.</p>
<p>This chapter will introduce you to the basic concepts of OOP, including an overview of development methods. This chapter, and this book, assumes that you have some programming experience, although not necessarily in C. If you think you need more preparation in programming before tackling this book, you should work through the Thinking in C multimedia seminar, downloadable from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>This chapter is background and supplementary material. Many people do not feel comfortable wading into object-oriented programming without understanding the big picture first. Thus, there are many concepts that are introduced here to give you a solid overview of OOP. However, other people may not get the big picture concepts until they’ve seen some of the mechanics first; these people may become bogged down and lost without some code to get their hands on. If you’re part of this latter group and are eager to get to the specifics of the language, feel free to jump past this chapter-skipping it at this point will not prevent you from writing programs or learning the language. However, you will want to come back here eventually to fill in your knowledge so you can understand why objects are important and how to design with them.</p>
<section>
<title>
<p>The progress of abstraction</p></title><empty-line/>
<p>All programming languages provide abstractions. It can be argued that the complexity of the problems you’re able to solve is directly related to the kind and quality of abstraction. By “kind” I mean, “What is it that you are abstracting?” Assembly language is a small abstraction of the underlying machine. Many so-called “imperative” languages that followed (such as FORTRAN, BASIC, and C) were abstractions of assembly language. These languages are big improvements over assembly language, but their primary abstraction still requires you to think in terms of the structure of the computer rather than the structure of the problem you are trying to solve. The programmer must establish the association between the machine model (in the “solution space,” which is the place where you’re implementing that solution, such as a computer) and the model of the problem that is actually being solved (in the “problem space,” which is the place where the problem exists, such as a business). The effort required to perform this mapping, and the fact that it is extrinsic to the programming language, produces programs that are difficult to write and expensive to maintain, and as a side effect created the entire “programming methods” industry.</p>
<p>The alternative to modeling the machine is to model the problem you’re trying to solve. Early languages such as LISP and APL chose particular views of the world (“All problems are ultimately lists” or “All problems are algorithmic,” respectively). Prolog casts all problems into chains of decisions. Languages have been created for constraint-based programming and for programming exclusively by manipulating graphical symbols. (The latter proved to be too restrictive.) Each of these approaches may be a good solution to the particular class of problem they’re designed to solve, but when you step outside of that domain they become awkward.</p>
<p>The object-oriented approach goes a step further by providing tools for the programmer to represent elements in the problem space. This representation is general enough that the programmer is not constrained to any particular type of problem. We refer to the elements in the problem space and their representations in the solution space as “objects.” (You will also need other objects that don’t have problem-space analogs.) The idea is that the program is allowed to adapt itself to the lingo of the problem by adding new types of objects, so when you read the code describing the solution, you’re reading words that also express the problem. This is a more flexible and powerful language abstraction than what we’ve had before.<a l:href="#bookmark2" type="note"><sup>3</sup></a><sup></sup> Thus, OOP allows you to describe the problem in terms of the problem, rather than in terms of the computer where the solution will run. There’s still a connection back to the computer: Each object looks quite a bit like a little computer—it has a state, and it has operations that you can ask it to perform. However, this doesn’t seem like such a bad analogy to objects in the real world—they all have characteristics and behaviors.</p>
<p>Alan Kay summarized five basic characteristics of Smalltalk, the first successful object-oriented language and one of the languages upon which Java is based. These characteristics represent a pure approach to object-oriented programming:</p>
<p>1.    Everything is an object. Think of an object as a fancy variable; it stores data, but you can “make requests” to that object, asking it to perform operations on itself. In theory, you can take any conceptual component in the problem you’re trying to solve (dogs, buildings, services, etc.) and represent it as an object in your program.</p>
<p>2.    A program is a bunch of objects telling each other what to do by sending messages. To make a request of an object, you “send a message” to that object. More concretely, you can think of a message as a request to call a method that belongs to a particular object.</p>
<p>3.    Each object has its own memory made up of other objects. Put</p>
<p>another way, you create a new kind of object by making a package containing existing objects. Thus, you can build complexity into a program while hiding it behind the simplicity of objects.</p>
<p>4.    Every object has a type. Using the parlance, each object is an instance of a class, in which “class” is synonymous with “type.” The most important distinguishing characteristic of a class is “What messages can you send to it?”</p>
<p>5.    All objects of a particular type can receive the same messages. This is actually a loaded statement, as you will see later. Because an object of type “circle” is also an object of type “shape,” a circle is guaranteed to accept shape messages. This means you can write code that talks to shapes and automatically handle anything that fits the description of a shape. This substitutability is one of the powerful concepts in OOP.</p>
<p>Booch offers an even more succinct description of an object:</p>
<p>An object has state, behavior and identity.</p>
<p>This means that an object can have internal data (which gives it state), methods (to produce behavior), and each object can be uniquely distinguished from every other object—to put this in a concrete sense, each object has a unique address in memory.<a l:href="#bookmark3" type="note"><sup>4</sup></a><sup></sup></p>
</section>
<section>
<title>
<p>An object has an interface</p></title><empty-line/>
<p>Aristotle was probably the first to begin a careful study of the concept of type; he spoke of “the class of fishes and the class of birds.” The idea that all objects, while being unique, are also part of a class of objects that have characteristics and behaviors in common was used directly in the first object-oriented language, Simula-67, with its fundamental keyword class that introduces a new type into a program.</p>
<p>Simula, as its name implies, was created for developing simulations such as the classic “bank teller problem.” In this, you have numerous tellers, customers, accounts, transactions, and units of money—a lot of “objects.” Objects that are identical except for their state during a program’s execution are grouped together into “classes of objects,” and that’s where the keyword class came from. Creating abstract data types (classes) is a fundamental concept in object-oriented programming. Abstract data types work almost exactly like built-in types: You can create variables of a type (called objects or instances in object-oriented parlance) and manipulate those variables (called sending messages or requests; you send a message and the object figures out what to do with it). The members (elements) of each class share some commonality: Every account has a balance, every teller can accept a deposit, etc. At the same time, each member has its own state: Each account has a different balance, each teller has a name. Thus, the tellers, customers, accounts, transactions, etc., can each be represented with a unique entity in the computer program. This entity is the object, and each object belongs to a particular class that defines its characteristics and behaviors.</p>
<p>So, although what we really do in object-oriented programming is create new data types, virtually all object-oriented programming languages use the “class” keyword. When you see the word “type” think “class” and vice versa.<a l:href="#bookmark4" type="note"><sup>5</sup></a><sup></sup></p>
<p>Since a class describes a set of objects that have identical characteristics (data elements) and behaviors (functionality), a class is really a data type because a floating point number, for example, also has a set of characteristics and behaviors. The difference is that a programmer defines a class to fit a problem rather than being forced to use an existing data type that was designed to represent a unit of storage in a machine. You extend the programming language by adding new data types specific to your needs. The programming system welcomes the new classes and gives them all the care and type checking that it gives to built-in types.</p>
<p>The object-oriented approach is not limited to building simulations. Whether or not you agree that any program is a simulation of the system you’re designing, the use of OOP techniques can easily reduce a large set of problems to a simple solution.</p>
<p>Once a class is established, you can make as many objects of that class as you like, and then manipulate those objects as if they are the elements that exist in the problem you are trying to solve. Indeed, one of the challenges of object-oriented programming is to create a one-to-one mapping between the elements in the problem space and objects in the solution space.</p>
<p>But how do you get an object to do useful work for you? There needs to be a way to make a request of the object so that it will do something, such as complete a transaction, draw something on the screen, or turn on a switch. And each object can satisfy only certain requests. The requests you can make of an object are defined by its interface, and the type is what determines the interface. A simple example might be a representation of a light bulb:</p><image l:href="#image5.jpg"/>
<p>lt.on();</p>
<p>The interface determines the requests that you can make for a particular object. However, there must be code somewhere to satisfy that request. This, along with the hidden data, comprises the implementation. From a procedural programming standpoint, it’s not that complicated. A type has a method associated with each possible request, and when you make a particular request to an object, that method is called. This process is usually summarized by saying that you “send a message” (make a request) to an object, and the object figures out what to do with that message (it executes code).</p>
<p>Here, the name of the type/class is Light, the name of this particular Light object is lt, and the requests that you can make of a Light object are to turn it on, turn it off, make it brighter, or make it dimmer. You create a Light object by defining a “reference” (lt) for that object and calling new to request a new object of that type. To send a message to the object, you state the name of the object and connect it to the message request with a period (dot). From the standpoint of the user of a predefined class, that’s pretty much all there is to programming with objects.</p>
<p>The preceding diagram follows the format of the Unified Modeling Language (UML). Each class is represented by a box, with the type name in the top portion of the box, any data members that you care to describe in the middle portion of the box, and the methods (the functions that belong to this object, which receive any messages you send to that object) in the bottom portion of the box. Often, only the name of the class and the public methods are shown in UML design diagrams, so the middle portion is not shown, as in this case. If you’re interested only in the class name, then the bottom portion doesn’t need to be shown, either.</p>
</section>
<section>
<title>
<p>An object provides services</p></title><empty-line/>
<p>While you’re trying to develop or understand a program design, one of the best ways to think about objects is as “service providers.” Your program itself will provide services to the user, and it will accomplish this by using the services offered by other objects. Your goal is to produce (or even better, locate in existing code libraries) a set of objects that provide the ideal services to solve your problem.</p>
<p>A way to start doing this is to ask, “If I could magically pull them out of a hat, what objects would solve my problem right away?” For example, suppose you are creating a bookkeeping program. You might imagine some objects that contain pre-defined bookkeeping input screens, another set of objects that perform bookkeeping calculations, and an object that handles printing of checks and invoices on all different kinds of printers. Maybe some of these objects already exist, and for the ones that don’t, what would they look like? What services would those objects provide, and what objects would they need to fulfill their obligations? If you keep doing this, you will eventually reach a point where you can say either, “That object seems simple enough to sit down and write” or “I’m sure that object must exist already.” This is a reasonable way to decompose a problem into a set of objects.</p>
<p>Thinking of an object as a service provider has an additional benefit: It helps to improve the cohesiveness of the object. High cohesion is a fundamental quality of software design: It means that the various aspects of a software component (such as an object, although this could also apply to a method or a library of objects) “fit together” well. One problem people have when designing objects is cramming too much functionality into one object. For example, in your check printing module, you may decide you need an object that knows all about formatting and printing. You’ll probably discover that this is too much for one object, and that what you need is three or more objects. One object might be a catalog of all the possible check layouts, which can be queried for information about how to print a check. One object or set of objects can be a generic printing interface that knows all about different kinds of printers (but nothing about bookkeeping—this one is a candidate for buying rather than writing yourself). And a third object could use the services of the other two to accomplish the task. Thus, each object has a cohesive set of services it offers. In a good object-oriented design, each object does one thing well, but doesn’t try to do too much. This not only allows the discovery of objects that might be purchased (the printer interface object), but it also produces new objects that might be reused somewhere else (the catalog of check layouts).</p>
<p>Treating objects as service providers is a great simplifying tool. This is useful not only during the design process, but also when someone else is trying to understand your code or reuse an object. If they can see the value of the object based on what service it provides, it makes it much easier to fit it into the design.</p>
</section>
<section>
<title>
<p>The hidden implementation</p></title><empty-line/>
<p>It is helpful to break up the playing field into class creators (those who create new data types) and client programmers<a l:href="#bookmark5" type="note"><sup>6</sup></a><sup></sup> (the class consumers who use the data types in their applications). The goal of the client programmer is to collect a toolbox full of classes to use for rapid application development. The goal of the class creator is to build a class that exposes only what’s necessary to the client programmer and keeps everything else hidden. Why? Because if it’s hidden, the client programmer can’t access it, which means that the class creator can change the hidden portion at will without worrying about the impact on anyone else. The hidden portion usually represents the tender insides of an object that could easily be corrupted by a careless or uninformed client programmer, so hiding the implementation reduces program bugs.</p>
<p>In any relationship it’s important to have boundaries that are respected by all parties involved. When you create a library, you establish a relationship with the client programmer, who is also a programmer, but one who is putting together an application by using your library, possibly to build a bigger library. If all the members of a class are available to everyone, then the client programmer can do anything with that class and there’s no way to enforce rules. Even though you might really prefer that the client programmer not directly manipulate some of the members of your class, without access control there’s no way to prevent it. Everything’s naked to the world.</p>
<p>So the first reason for access control is to keep client programmers’ hands off portions they shouldn’t touch-parts that are necessary for the internal operation of the data type but not part of the interface that users need in order to solve their particular problems. This is actually a service to client programmers because they can easily see what’s important to them and what they can ignore.</p>
<p>The second reason for access control is to allow the library designer to change the internal workings of the class without worrying about how it will affect the client programmer. For example, you might implement a particular class in a simple fashion to ease development, and then later discover that you need to rewrite it in order to make it run faster. If the interface and implementation are clearly separated and protected, you can accomplish this easily.</p>
<p>Java uses three explicit keywords to set the boundaries in a class: public, private, and protected. These access specifiers determine who can use the definitions that follow. public means the following element is available to everyone. The private keyword, on the other hand, means that no one can access that element except you, the creator of the type, inside methods of that type. private is a brick wall between you and the client programmer. Someone who tries to access a private member will get a compile-time error. The protected keyword acts like private, with the exception that an inheriting class has access to protected members, but not private members. Inheritance will be introduced shortly.</p>
<p>Java also has a “default” access, which comes into play if you don’t use one of the aforementioned specifiers. This is usually called package access because classes can access the members of other classes in the same package (library component), but outside of the package those same members appear to be private.</p>
</section>
<section>
<title>
<p>Reusing the implementation</p></title><empty-line/>
<p>Once a class has been created and tested, it should (ideally) represent a useful unit of code. It turns out that this reusability is not nearly so easy to achieve as many would hope; it takes experience and insight to produce a reusable object design. But once you have such a design, it begs to be reused. Code reuse is one of the greatest advantages that object-oriented programming languages provide.</p>
<p>The simplest way to reuse a class is to just use an object of that class directly, but you can also place an object of that class inside a new class. We call this “creating a member object.” Your new class can be made up of any number and type of other objects, in any combination that you need to achieve the functionality desired in your new class. Because you are composing a new class from existing classes, this concept is called composition (if the composition happens dynamically, it’s usually called aggregation). Composition is often referred to as a “has-a” relationship, as in “A car has an engine.”</p><image l:href="#image6.jpg"/>
<p>(This UML diagram indicates composition with the filled diamond, which states there is one car. I will typically use a simpler form: just a line, without the diamond, to indicate an association.<a l:href="#bookmark6" type="note"><sup>7</sup></a><sup></sup>)</p>
<p>Composition comes with a great deal of flexibility. The member objects of your new class are typically private, making them inaccessible to the client programmers who are using the class. This allows you to change those members without disturbing existing client code. You can also change the member objects at run time, to dynamically change the behavior of your program. Inheritance, which is described next, does not have this flexibility since the compiler must place compile-time restrictions on classes created with inheritance.</p>
<p>Because inheritance is so important in object-oriented programming, it is often highly emphasized, and the new programmer can get the idea that inheritance should be used everywhere. This can result in awkward and overly complicated designs. Instead, you should first look to composition when creating new classes, since it is simpler and more flexible. If you take this approach, your designs will be cleaner. Once you’ve had some experience, it will be reasonably obvious when you need inheritance.</p>
</section>
<section>
<title>
<p>Inheritance</p></title><empty-line/>
<p>By itself, the idea of an object is a convenient tool. It allows you to package data and functionality together by concept, so you can represent an appropriate problem-space idea rather than being forced to use the idioms of the underlying machine. These concepts are expressed as fundamental units in the programming language by using the class keyword.</p>
<p>It seems a pity, however, to go to all the trouble to create a class and then be forced to create a brand new one that might have similar functionality. It’s nicer if we can take the existing class, clone it, and then make additions and modifications to the clone. This is effectively what you get with inheritance, with the exception that if the original class (called the base class or superclass or parent class) is changed, the modified “clone” (called the derived class or inherited class or subclass or child class) also reflects those changes.</p><image l:href="#image7.jpg"/>
<p>(The arrow in this UML diagram points from the derived class to the base class. As you will see, there is commonly more than one derived class.)</p>
<p>A type does more than describe the constraints on a set of objects; it also has a relationship with other types. Two types can have characteristics and behaviors in common, but one type may contain more characteristics than another and may also handle more messages (or handle them differently). Inheritance expresses this similarity between types by using the concept of base types and derived types. A base type contains all of the characteristics and behaviors that are shared among the types derived from it. You create a base type to represent the core of your ideas about some objects in your system. From the base type, you derive other types to express the different ways that this core can be realized.</p>
<p>For example, a trash-recycling machine sorts pieces of trash. The base type is “trash”, and each piece of trash has a weight, a value, and so on, and can be shredded, melted, or decomposed. From this, more specific types of trash are derived that may have additional characteristics (a bottle has a color) or behaviors (an aluminum can may be crushed, a steel can is magnetic). In addition, some behaviors may be different (the value of paper depends on its type and condition). Using inheritance, you can build a type hierarchy that expresses the problem you’re trying to solve in terms of its types.</p>
<p>A second example is the classic “shape” example, perhaps used in a computer-aided design system or game simulation. The base type is “shape,” and each shape has a size, a color, a position, and so on. Each shape can be drawn, erased, moved, colored, etc. From this, specific types of shapes are derived (inherited)-circle, square, triangle, and so on—each of which may have additional characteristics and behaviors. Certain shapes can be flipped, for example. Some behaviors may be different, such as when you want to calculate the area of a shape. The type hierarchy embodies both the similarities and differences between the shapes.</p><image l:href="#image8.jpg"/>
<p>Casting the solution in the same terms as the problem is very useful because you don’t need a lot of intermediate models to get from a description of the problem to a description of the solution. With objects, the type hierarchy is the primary model, so you go directly from the description of the system in the real world to the description of the system in code. Indeed, one of the difficulties people have with object-oriented design is that it’s too simple to get from the beginning to the end. A mind trained to look for complex solutions can initially be stumped by this simplicity.</p>
<p>When you inherit from an existing type, you create a new type. This new type contains not only all the members of the existing type (although the private ones are hidden away and inaccessible), but more importantly it duplicates the interface of the base class. That is, all the messages you can send to objects of the base class you can also send to objects of the derived class. Since we know the type of a class by the messages we can send to it, this means that the derived class is the same type as the base class. In the previous example, “A circle is a shape.” This type equivalence via inheritance is one of the fundamental gateways in understanding the meaning of object-oriented programming.</p>
<p>Since both the base class and derived class have the same fundamental interface, there must be some implementation to go along with that interface. That is, there must be some code to execute when an object receives a particular message. If you simply inherit a class and don’t</p>
<p>do anything else, the methods from the base-class interface come right along into the derived class. That means objects of the derived class have not only the same type, they also have the same behavior, which isn’t particularly interesting.</p>
<p>You have two ways to differentiate your new derived class from the original base class. The first is quite straightforward: You simply add brand new methods to the derived class. These new methods are not part of the base-class interface. This means that the base class simply didn’t do as much as you wanted it to, so you added more methods. This simple and primitive use for inheritance is, at times, the perfect solution to your problem. However, you should look closely for the possibility that your base class might also need these additional methods. This process of discovery and iteration of your design happens regularly in object-oriented programming.</p><image l:href="#image9.jpg"/>
<p>Although inheritance may sometimes imply (especially in Java, where the keyword for inheritance is extends) that you are going to add new methods to the interface, that’s not necessarily true. The second and more important way to differentiate your new class is to change the behavior of an existing base-class method. This is referred to as overriding that method.</p><image l:href="#image10.jpg"/>
<p>To override a method, you simply create a new definition for the method in the derived class. You’re saying, “I’m using the same interface method here, but I want it to do something different for my new type.”</p>
<subtitle>Is-a vs. is-like-a relationships</subtitle>
<p>There’s a certain debate that can occur about inheritance: Should inheritance override only baseclass methods (and not add new methods that aren’t in the base class)? This would mean that the derived class is exactly the same type as the base class since it has exactly the same interface. As a result, you can exactly substitute an object of the derived class for an object of the base class. This can be thought of as pure substitution, and it’s often referred to as the substitution principle. In a sense, this is the ideal way to treat inheritance. We often refer to the relationship between the base class and derived classes in this case as an is-a relationship, because you can say, “A circle is a shape.” A test for inheritance is to determine whether you can state the is-a relationship about the classes and have it make sense.</p>
<p>There are times when you must add new interface elements to a derived type, thus extending the interface. The new type can still be substituted for the base type, but the substitution isn’t perfect because your new methods are not accessible from the base type. This can be described as an islike-a relationship (my term). The new type has the interface of the old type but it also contains other methods, so you can’t really say it’s exactly the same. For example, consider an air conditioner. Suppose your house is wired with all the controls for cooling; that is, it has an interface that allows you to control cooling. Imagine that the air conditioner breaks down and you replace it with a heat pump, which can both heat and cool. The heat pump is-like-an air conditioner, but it can do more. Because the control system of your house is designed only to control cooling, it is restricted to communication with the cooling part of the new object. The interface of the new object has been extended, and the existing system doesn’t know about anything except the original interface.</p><image l:href="#image11.jpg"/>
<p>Of course, once you see this design it becomes clear that the base class “cooling system” is not general enough, and should be renamed to “temperature control system” so that it can also include heating—at which point the substitution principle will work. However, this diagram is an example of what can happen with design in the real world.</p>
<p>When you see the substitution principle it’s easy to feel like this approach (pure substitution) is the only way to do things, and in fact it is nice if your design works out that way. But you’ll find that there are times when it’s equally clear that you must add new methods to the interface of a derived class. With inspection both cases should be reasonably obvious.</p>
</section>
<section>
<title>
<p>Interchangeable objects with polymorphism</p></title><empty-line/>
<p>When dealing with type hierarchies, you often want to treat an object not as the specific type that it is, but instead as its base type. This allows you to write code that doesn’t depend on specific types. In the shape example, methods manipulate generic shapes, unconcerned about whether they’re circles, squares, triangles, or some shape that hasn’t even been defined yet. All shapes can be drawn, erased, and moved, so these methods simply send a message to a shape object; they don’t worry about how the object copes with the message.</p>
<p>Such code is unaffected by the addition of new types, and adding new types is the most common way to extend an object-oriented program to handle new situations. For example, you can derive a new subtype of shape called pentagon without modifying the methods that deal only with generic shapes. This ability to easily extend a design by deriving new subtypes is one of the essential ways to encapsulate change. This greatly improves designs while reducing the cost of software maintenance.</p>
<p>There’s a problem, however, with attempting to treat derived-type objects as their generic base types (circles as shapes, bicycles as vehicles, cormorants as birds, etc.). If a method is going to tell a generic shape to draw itself, or a generic vehicle to steer, or a generic bird to move, the compiler cannot know at compile time precisely what piece of code will be executed. That’s the whole point—when the message is sent, the programmer doesn’t want to know what piece of code will be executed; the draw method can be applied equally to a circle, a square, or a triangle, and the object will execute the proper code depending on its specific <sup>t</sup>yp<sup>e</sup>.</p>
<p>If you don’t have to know what piece of code will be executed, then when you add a new subtype, the code it executes can be different without requiring changes to the method that calls it. Therefore, the compiler cannot know precisely what piece of code is executed, so what does it do?</p>
<p>For example, in the following diagram the BirdController object just works with generic Bird objects and does not know what exact type they are. This is convenient from BirdController’s perspective because it doesn’t have to write special code to determine the exact type of Bird it’s working with or that Bird’s behavior. So how does it happen that, when move( ) is called while ignoring the specific type of Bird, the right behavior will occur (a Goose walks, flies, or swims, and a Penguin walks or swims)?</p><image l:href="#image12.jpg"/>
<p>The answer is the primary twist in object-oriented programming: The compiler cannot make a function call in the traditional sense. The function call generated by a non-OOP compiler causes what is called early binding, a term you may not have heard before because you’ve never thought about it any other way. It means the compiler generates a call to a specific function name, and the runtime system resolves this call to the absolute address of the code to be executed. In OOP, the program cannot determine the address of the code until run time, so some other scheme is necessary when a message is sent to a generic object.</p>
<p>To solve the problem, object-oriented languages use the concept of late binding. When you send a message to an object, the code being called isn’t determined until run time. The compiler does ensure that the method exists and performs type checking on the arguments and return value, but it doesn’t know the exact code to execute.</p>
<p>To perform late binding, Java uses a special bit of code in lieu of the absolute call. This code calculates the address of the method body, using information stored in the object (this process is covered in great detail in the Polymorphism chapter). Thus, each object can behave differently according to the contents of that special bit of code. When you send a message to an object, the object actually does figure out what to do with that message.</p>
<p>In some languages you must explicitly state that you want a method to have the flexibility of latebinding properties (C++ uses the virtual keyword to do this). In these languages, by default, methods are not dynamically bound. In Java, dynamic binding is the default behavior and you don’t need to remember to add any extra keywords in order to get polymorphism.</p>
<p>Consider the shape example. The family of classes (all based on the same uniform interface) was diagrammed earlier in this chapter. To demonstrate polymorphism, we want to write a single piece of code that ignores the specific details of type and talks only to the base class. That code is decoupled from type-specific information and thus is simpler to write and easier to understand. And, if a new type—a Hexagon, for example—is added through inheritance, the code you write will work just as well for the new type of Shape as it did on the existing types. Thus, the program is extensible.</p>
<p>If you write a method in Java (as you will soon learn how to do):</p>
<p>void doSomething(Shape shape) { shape.erase();</p>
<p>// ...</p>
<p>shape.draw();</p>
<p>}</p>
<p>This method speaks to any Shape, so it is independent of the specific type of object that it’s drawing and erasing. If some other part of the program uses the doSomething( ) method:</p>
<p>Circle circle = new CircleQ;</p>
<p>Triangle triangle = new Triangle();</p>
<p>Line line= new Line(); doSomething(circle); doSomething(triangle); doSomething(line);</p>
<p>The calls to doSomething( ) automatically work correctly, regardless of the exact type of the object.</p>
<p>This is a rather amazing trick. Consider the line: doSomething(circle);</p>
<p>What’s happening here is that a Circle is being passed into a method that’s expecting a Shape. Since a Circle is a Shape it can be treated as one by doSomething( ). That is, any message that doSomething( ) can send to a Shape, a Circle can accept. So it is a completely safe and logical thing to do.</p>
<p>We call this process of treating a derived type as though it were its base type upcasting. The name cast is used in the sense of casting into a mold and the up comes from the way the inheritance diagram is typically arranged, with the base type at the top and the derived classes fanning out downward. Thus, casting to a base type is moving up the inheritance diagram: “upcasting.”</p><image l:href="#image13.jpg"/>
<p>An object-oriented program contains some upcasting somewhere, because that’s how you decouple yourself from knowing about the exact type you’re working with. Look at the code in doSomething( ):</p>
<p>shape.erase();</p>
<p>// ...</p>
<p>shape.draw();</p>
<p>Notice that it doesn’t say, “If you’re a Circle, do this, if you’re a Square, do that, etc.” If you write that kind of code, which checks for all the possible types that a Shape can actually be, it’s messy and you need to change it every time you add a new kind of Shape. Here, you just say, “You’re a shape, I know you can erase( ) and draw( ) yourself, do it, and take care of the details correctly.”</p>
<p>What’s impressive about the code in doSomething( ) is that, somehow, the right thing happens. Calling draw( ) for Circle causes different code to be executed than when calling draw( ) for a Square or a Line, but when the draw( ) message is sent to an anonymous Shape, the correct behavior occurs based on the actual type of the Shape. This is amazing because, as mentioned earlier, when the Java compiler is compiling the code for doSomething( ), it cannot know exactly what types it is dealing with. So ordinarily, you’d expect it to end up calling the version of erase( ) and draw( ) for the base class Shape, and not for the specific Circle, Square, or Line. And yet the right thing happens because of polymorphism. The compiler and runtime system handle the details; all you need to know right now is that it does happen, and more importantly, how to design with it. When you send a message to an object, the object will do the right thing, even when upcasting is involved.</p>
</section>
<section>
<title>
<p>The singly rooted hierarchy</p></title><empty-line/>
<p>One of the issues in OOP that has become especially prominent since the introduction of C++ is whether all classes should ultimately be inherited from a single base class. In Java (as with virtually all other OOP languages except for C++) the answer is yes, and the name of this ultimate base class is simply Object. It turns out that the benefits of the singly rooted hierarchy are many.</p>
<p>All objects in a singly rooted hierarchy have an interface in common, so they are all ultimately the same fundamental type. The alternative (provided by C++) is that you don’t know that everything is the same basic type. From a backward-compatibility standpoint this fits the model of C better and can be thought of as less restrictive, but when you want to do full-on objectoriented programming you must then build your own hierarchy to provide the same convenience that’s built into other OOP languages. And in any new class library you acquire, some other incompatible interface will be used. It requires effort (and possibly multiple inheritance) to work the new interface into your design. Is the extra “flexibility” of C++ worth it? If you need it—if you have a large investment in C—it’s quite valuable. If you’re starting from scratch, other alternatives such as Java can often be more productive.</p>
<p>All objects in a singly rooted hierarchy can be guaranteed to have certain functionality. You know you can perform certain basic operations on every object in your system. All objects can easily be created on the heap, and argument passing is greatly simplified.</p>
<p>A singly rooted hierarchy makes it much easier to implement a garbage collector, which is one of the fundamental improvements of Java over C++. And since information about the type of an object is guaranteed to be in all objects, you’ll never end up with an object whose type you cannot determine. This is especially important with system-level operations, such as exception handling, and to allow greater flexibility in programming.</p>
</section>
<section>
<title>
<p>Containers</p></title><empty-line/>
<p>In general, you don’t know how many objects you’re going to need to solve a particular problem, or how long they will last. You also don’t know how to store those objects. How can you know how much space to create if that information isn’t known until run time?</p>
<p>The solution to most problems in object-oriented design seems flippant: You create another type of object. The new type of object that solves this particular problem holds references to other objects. Of course, you can do the same thing with an array, which is available in most languages. But this new object, generally called a container (also called a collection, but the Java library uses that term in a different sense so this book will use “container”), will expand itself whenever necessary to accommodate everything you place inside it. So you don’t need to know how many objects you’re going to hold in a container. Just create a container object and let it take care of the details.</p>
<p>Fortunately, a good OOP language comes with a set of containers as part of the package. In C++, it’s part of the Standard C++ Library and is often called the Standard Template Library (STL). Smalltalk has a very complete set of containers. Java also has numerous containers in its standard library. In some libraries, one or two generic containers is considered good enough for all needs, and in others (Java, for example) the library has different types of containers for different needs: several different kinds of List classes (to hold sequences), Maps (also known as associative arrays, to associate objects with other objects), Sets (to hold one of each type of object), and more components such as queues, trees, stacks, etc.</p>
<p>From a design standpoint, all you really want is a container that can be manipulated to solve your problem. If a single type of container satisfied all of your needs, there’d be no reason to have different kinds. There are two reasons that you need a choice of containers. First, containers provide different types of interfaces and external behavior. A stack has a different interface and behavior than a queue, which is different from a set or a list. One of these might provide a more flexible solution to your problem than the other. Second, different containers have different efficiencies for certain operations. For example, there are two basic types of List: ArrayList and LinkedList. Both are simple sequences that can have identical interfaces and external behaviors. But certain operations can have significantly different costs. Randomly accessing elements in an ArrayList is a constant-time operation; it takes the same amount of time regardless of the element you select. However, in a LinkedList it is expensive to move through the list to randomly select an element, and it takes longer to find an element that is farther down the list. On the other hand, if you want to insert an element in the middle of a sequence, it’s cheaper in a LinkedList than in an ArrayList. These and other operations have different efficiencies depending on the underlying structure of the sequence. You might start building your program with a LinkedList and, when tuning for performance, change to an ArrayList. Because of the abstraction via the interface List, you can change from one to the other with minimal impact on your code.</p>
<subtitle>Parameterized types (generics)</subtitle>
<p>Before Java SE5, containers held the one universal type in Java: Object. The singly rooted hierarchy means that everything is an Object, so a container that holds Objects can hold anything.<a l:href="#bookmark7" type="note"><sup>8</sup></a><sup></sup> This made containers easy to reuse.</p>
<p>To use such a container, you simply add object references to it and later ask for them back. But, since the container held only Objects, when you added an object reference into the container it was upcast to Object, thus losing its character. When fetching it back, you got an Object reference, and not a reference to the type that you put in. So how do you turn it back into something that has the specific type of the object that you put into the container?</p>
<p>Here, the cast is used again, but this time you’re not casting up the inheritance hierarchy to a more general type. Instead, you cast down the hierarchy to a more specific type. This manner of casting is called downcasting. With upcasting, you know, for example, that a Circle is a type of Shape so it’s safe to upcast, but you don’t know that an Object is necessarily a</p>
<p>Circle or a Shape so it’s hardly safe to downcast unless you know exactly what you’re dealing with.</p>
<p>It’s not completely dangerous, however, because if you downcast to the wrong thing you’ll get a runtime error called an exception, which will be described shortly. When you fetch object references from a container, though, you must have some way to remember exactly what they are so you can perform a proper downcast.</p>
<p>Downcasting and the runtime checks require extra time for the running program and extra effort from the programmer. Wouldn’t it make sense to somehow create the container so that it knows the types that it holds, eliminating the need for the downcast and a possible mistake? The solution is called a parameterized type mechanism. A parameterized type is a class that the compiler can automatically customize to work with particular types. For example, with a parameterized container, the compiler could customize that container so that it would accept only Shapes and fetch only Shapes.</p>
<p>One of the big changes in Java SE5 is the addition of parameterized types, called generics in Java. You’ll recognize the use of generics by the angle brackets with types inside; for example, an ArrayList that holds Shape can be created like this:</p>
<p>ArrayList&lt;Shape&gt; shapes = new ArrayList&lt;Shape&gt;();</p>
<p>There have also been changes to many of the standard library components in order to take advantage of generics. As you will see, generics have an impact on much of the code in this book.</p>
</section>
<section>
<title>
<p>Object creation &amp; lifetime</p></title><empty-line/>
<p>One critical issue when working with objects is the way they are created and destroyed. Each object requires resources, most notably memory, in order to exist. When an object is no longer needed it must be cleaned up so that these resources are released for reuse. In simple programming situations the question of how an object is cleaned up doesn’t seem too challenging: You create the object, use it for as long as it’s needed, and then it should be destroyed. However, it’s not hard to encounter situations that are more complex.</p>
<p>Suppose, for example, you are designing a system to manage air traffic for an airport. (The same model might also work for managing crates in a warehouse, or a video rental system, or a kennel for boarding pets.) At first it seems simple: Make a container to hold airplanes, then create a new airplane and place it in the container for each airplane that enters the air-traffic-control zone. For cleanup, simply clean up the appropriate airplane object when a plane leaves the zone.</p>
<p>But perhaps you have some other system to record data about the planes; perhaps data that doesn’t require such immediate attention as the main controller function. Maybe it’s a record of the flight plans of all the small planes that leave the airport. So you have a second container of small planes, and whenever you create a plane object you also put it in this second container if it’s a small plane. Then some background process performs operations on the objects in this container during idle moments.</p>
<p>Now the problem is more difficult: How can you possibly know when to destroy the objects? When you’re done with the object, some other part of the system might not be. This same problem can arise in a number of other situations, and in programming systems (such as C++) in which you must explicitly delete an object when you’re done with it this can become quite complex.</p>
<p>Where is the data for an object and how is the lifetime of the object controlled? C++ takes the approach that control of efficiency is the most important issue, so it gives the programmer a choice. For maximum runtime speed, the storage and lifetime can be determined while the program is being written, by placing the objects on the stack (these are sometimes called automatic or scoped variables) or in the static storage area. This places a priority on the speed of storage allocation and release, and this control can be very valuable in some situations. However, you sacrifice flexibility because you must know the exact quantity, lifetime, and type of objects while you’re writing the program. If you are trying to solve a more general problem such as computer-aided design, warehouse management, or air-traffic control, this is too restrictive.</p>
<p>The second approach is to create objects dynamically in a pool of memory called the heap. In this approach, you don’t know until run time how many objects you need, what their lifetime is, or what their exact type is. Those are determined at the spur of the moment while the program is running. If you need a new object, you simply make it on the heap at the point that you need it. Because the storage is managed dynamically, at run time, the amount of time required to allocate storage on the heap can be noticeably longer than the time to create storage on the stack. Creating storage on the stack is often a single assembly instruction to move the stack pointer down and another to move it back up. The time to create heap storage depends on the design of the storage mechanism.</p>
<p>The dynamic approach makes the generally logical assumption that objects tend to be complicated, so the extra overhead of finding storage and releasing that storage will not have an important impact on the creation of an object. In addition, the greater flexibility is essential to solve the general programming problem.</p>
<p>Java uses dynamic memory allocation, exclusively.<a l:href="#bookmark8" type="note"><sup>9</sup></a><sup></sup> Every time you want to create an object, you use the new operator to build a dynamic instance of that object.</p>
<p>There’s another issue, however, and that’s the lifetime of an object. With languages that allow objects to be created on the stack, the compiler determines how long the object lasts and can automatically destroy it. However, if you create it on the heap the compiler has no knowledge of its lifetime. In a language like C++, you must determine programmatically when to destroy the object, which can lead to memory leaks if you don’t do it correctly (and this is a common problem in C++ programs). Java provides a feature called a garbage collector that automatically discovers when an object is no longer in use and destroys it. A garbage collector is much more convenient because it reduces the number of issues that you must track and the code you must write. More importantly, the garbage collector provides a much higher level of insurance against the insidious problem of memory leaks, which has brought many a C++ project to its knees.</p>
<p>With Java, the garbage collector is designed to take care of the problem of releasing the memory (although this doesn’t include other aspects of cleaning up an object). The garbage collector “knows” when an object is no longer in use, and it then automatically releases the memory for that object. This, combined with the fact that all objects are inherited from the single root class Object and that you can create objects only one way—on the heap-makes the process of programming in Java much simpler than programming in C++. You have far fewer decisions to make and hurdles to overcome.</p>
</section>
<section>
<title>
<p>Exception handling: dealing with errors</p></title><empty-line/>
<p>Ever since the beginning of programming languages, error handling has been a particularly difficult issue. Because it’s so hard to design a good error-handling scheme, many languages simply ignore the issue, passing the problem on to library designers who come up with halfway measures that work in many situations but that can easily be circumvented, generally by just ignoring them. A major problem with most error-handling schemes is that they rely on programmer vigilance in following an agreed-upon convention that is not enforced by the language. If the programmer is not vigilant—often the case if they are in a hurry—these schemes can easily be forgotten.</p>
<p>Exception handling wires error handling directly into the programming language and sometimes even the operating system. An exception is an object that is “thrown” from the site of the error and can be “caught” by an appropriate exception handler designed to handle that particular type of error. It’s as if exception handling is a different, parallel path of execution that can be taken when things go wrong. And because it uses a separate execution path, it doesn’t need to interfere with your normally executing code. This tends to make that code simpler to write because you aren’t constantly forced to check for errors. In addition, a thrown exception is unlike an error value that’s returned from a method or a flag that’s set by a method in order to indicate an error condition—these can be ignored. An exception cannot be ignored, so it’s guaranteed to be dealt with at some point. Finally, exceptions provide a way to reliably recover from a bad situation. Instead of just exiting the program, you are often able to set things right and restore execution, which produces much more robust programs.</p>
<p>Java’s exception handling stands out among programming languages, because in Java, exception handling was wired in from the beginning and you’re forced to use it. It is the single acceptable way to report errors. If you don’t write your code to properly handle exceptions, you’ll get a compile-time error message. This guaranteed consistency can sometimes make error handling much easier.</p>
<p>It’s worth noting that exception handling isn’t an object-oriented feature, although in object-oriented languages the exception is normally represented by an object. Exception handling existed before object-oriented languages.</p>
</section>
<section>
<title>
<p>Concurrent programming</p></title><empty-line/>
<p>A fundamental concept in computer programming is the idea of handling more than one task at a time. Many programming problems require that the program stop what it’s doing, deal with some other problem, and then return to the main process. The solution has been approached in many ways. Initially, programmers with low-level knowledge of the machine wrote interrupt service routines, and the suspension of the main process was initiated through a hardware interrupt. Although this worked well, it was difficult and non-portable, so it made moving a program to a new type of machine slow and expensive.</p>
<p>Sometimes, interrupts are necessary for handling time-critical tasks, but there’s a large class of problems in which you’re simply trying to partition the problem into separately running pieces (tasks) so that the whole program can be more responsive. Within a program, these separately running pieces are called threads, and the general concept is called concurrency.</p>
<p>A common example of concurrency is the user interface. By using tasks, a user can press a button and get a quick response rather than being forced to wait until the program finishes its current task.</p>
<p>Ordinarily, tasks are just a way to allocate the time of a single processor. But if the operating system supports multiple processors, each task can be assigned to a different processor, and they can truly run in parallel. One of the convenient features of concurrency at the language level is that the programmer doesn’t need to worry about whether there are many processors or just one. The program is logically divided into tasks, and if the machine has more than one processor, then the program runs faster, without any special adjustments.</p>
<p>All this makes concurrency sound pretty simple. There is a catch: shared resources. If you have more than one task running that’s expecting to access the same resource, you have a problem. For example, two processes can’t simultaneously send information to a printer. To solve the problem, resources that can be shared, such as the printer, must be locked while they are being used. So a task locks a resource, completes its task, and then releases the lock so that someone else can use the resource.</p>
<p>Java’s concurrency is built into the language, and Java SE5 has added significant additional library support.</p>
</section>
<section>
<title>
<p>Java and the Internet</p></title><empty-line/>
<p>If Java is, in fact, yet another computer programming language, you may question why it is so important and why it is being promoted as a revolutionary step in computer programming. The answer isn’t immediately obvious if you’re coming from a traditional programming perspective. Although Java is very useful for solving traditional standalone programming problems, it is also important because it solves programming problems for the World Wide Web.</p>
<subtitle>What is the Web?</subtitle>
<p>The Web can seem a bit of a mystery at first, with all this talk of “surfing,” “presence,” and “home pages.” It’s helpful to step back and see what it really is, but to do this you must understand client/server systems, another aspect of computing that’s full of confusing issues.</p>
<p>Client/server computing</p>
<p>The primary idea of a client/server system is that you have a central repository of information— some kind of data, usually in a database—that you want to distribute on demand to some set of people or machines. A key to the client/server concept is that the repository of information is centrally located so that it can be changed and so that those changes will propagate out to the information consumers. Taken together, the information repository, the software that distributes the information, and the machine(s) where the information and software reside are called “the server.” The software that resides on the consumer machine, communicates with the server, fetches the information, processes it, and then displays it on the consumer machine is called the client.</p>
<p>The basic concept of client/server computing, then, is not so complicated. The problems arise because you have a single server trying to serve many clients at once. Generally, a database management system is involved, so the designer “balances” the layout of data into tables for optimal use. In addition, systems often allow a client to insert new information into a server. This means you must ensure that one client’s new data doesn’t walk over another client’s new data, or that data isn’t lost in the process of adding it to the database (this is called transaction processing). As client software changes, it must be built, debugged, and installed on the client machines, which turns out to be more complicated and expensive than you might think. It’s especially problematic to support multiple types of computers and operating systems. Finally, there’s the all-important performance issue: You might have hundreds of clients making requests of your server at any moment, so a small delay can be critical. To minimize latency, programmers work hard to offload processing tasks, often to the client machine, but sometimes to other machines at the server site, using so-called middleware. (Middleware is also used to improve maintainability.)</p>
<p>The simple idea of distributing information has so many layers of complexity that the whole problem can seem hopelessly enigmatic. And yet it’s crucial: Client/server computing accounts for roughly half of all programming activities. It’s responsible for everything from taking orders and credit-card transactions to the distribution of any kind of data—stock market, scientific, government, you name it. What we’ve come up with in the past is individual solutions to individual problems, inventing a new solution each time. These were hard to create and hard to use, and the user had to learn a new interface for each one. The entire client/server problem needed to be solved in a big way.</p>
<p>The Web as a giant server</p>
<p>The Web is actually one giant client/server system. It’s a bit worse than that, since you have all the servers and clients coexisting on a single network at once. You don’t need to know that, because all you care about is connecting to and interacting with one server at a time (even though you might be hopping around the world in your search for the correct server).</p>
<p>Initially it was a simple one-way process. You made a request of a server and it handed you a file, which your machine’s browser software (i.e., the client) would interpret by formatting onto your local machine. But in short order people began wanting to do more than just deliver pages from a server. They wanted full client/server capability so that the client could feed information back to the server, for example, to do database lookups on the server, to add new information to the server, or to place an order (which requires special security measures). These are the changes we’ve been seeing in the development of the Web.</p>
<p>The Web browser was a big step forward: the concept that one piece of information can be displayed on any type of computer without change. However, the original browsers were still rather primitive and rapidly bogged down by the demands placed on them. They weren’t particularly interactive, and tended to clog up both the server and the Internet because whenever you needed to do something that required programming you had to send information back to the server to be processed. It could take many seconds or minutes to find out you had misspelled something in your request. Since the browser was just a viewer it couldn’t perform even the simplest computing tasks. (On the other hand, it was safe, because it couldn’t execute any programs on your local machine that might contain bugs or viruses.)</p>
<p>To solve this problem, different approaches have been taken. To begin with, graphics standards have been enhanced to allow better animation and video within browsers. The remainder of the problem can be solved only by incorporating the ability to run programs on the client end, under the browser. This is called client-side programming.</p>
<subtitle>Client-side programming</subtitle>
<p>The Web’s initial server-browser design provided for interactive content, but the interactivity was completely provided by the server. The server produced static pages for the client browser, which would simply interpret and display them. Basic HyperText Markup Language (HTML) contains simple mechanisms for data gathering: text-entry boxes, check boxes, radio boxes, lists and dropdown lists, as well as a button that could only be programmed to reset the data on the form or “submit” the data on the form back to the server. This submission passes through the Common Gateway Interface (CGI) provided on all Web servers. The text within the submission tells CGI what to do with it. The most common action is to run a program located on the server in a directory that’s typically called “cgi-bin.” (If you watch the address window at the top of your browser when you push a button on a Web page, you can sometimes see “cgi-bin” within all the gobbledygook there.) These programs can be written in most languages. Perl has been a common choice because it is designed for text manipulation and is interpreted, so it can be installed on any server regardless of processor or operating system. However, Python (<a l:href="http://www.Python.org">www.Python.org</a>) has been making inroads because of its greater power and simplicity.</p>
<p>Many powerful Web sites today are built strictly on CGI, and you can in fact do nearly anything with CGI. However, Web sites built on CGI programs can rapidly become overly complicated to maintain, and there is also the problem of response time. The response of a CGI program depends on how much data must be sent, as well as the load on both the server and the Internet. (On top of this, starting a CGI program tends to be slow.) The initial designers of the Web did not foresee how rapidly this bandwidth would be exhausted for the kinds of applications people developed. For example, any sort of dynamic graphing is nearly impossible to perform with consistency because a Graphics Interchange Format (GIF) file must be created and moved from the server to the client for each version of the graph. In addition, you’ve no doubt experienced the process of data validation for a Web input form. You press the submit button on a page; the data is shipped back to the server; the server starts a CGI program that discovers an error, formats an HTML page informing you of the error, and then sends the page back to you; you must then back up a page and try again. Not only is this slow, it’s inelegant.</p>
<p>The solution is client-side programming. Most desktop computers that run Web browsers are powerful engines capable of doing vast work, and with the original static HTML approach they are sitting there, just idly waiting for the server to dish up the next page. Client-side programming means that the Web browser is harnessed to do whatever work it can, and the result for the user is a much speedier and more interactive experience at your Web site.</p>
<p>The problem with discussions of client-side programming is that they aren’t very different from discussions of programming in general. The parameters are almost the same, but the platform is different; a Web browser is like a limited operating system. In the end, you must still program, and this accounts for the dizzying array of problems and solutions produced by client-side programming. The rest of this section provides an overview of the issues and approaches in client-side programming.</p>
<p>Plug-ins</p>
<p>One of the most significant steps forward in client-side programming is the development of the plug-in. This is a way for a programmer to add new functionality to the browser by downloading a piece of code that plugs itself into the appropriate spot in the browser. It tells the browser, “From now on you can perform this new activity.” (You need to download the plug-in only once.) Some fast and powerful behavior is added to browsers via plug-ins, but writing a plug-in is not a trivial task, and isn’t something you’d want to do as part of the process of building a particular site. The value of the plug-in for client-side programming is that it allows an expert programmer to develop extensions and add those extensions to a browser without the permission of the browser manufacturer. Thus, plug-ins provide a “back door” that allows the creation of new client-side programming languages (although not all languages are implemented as plug-ins).</p>
<p>Scripting languages</p>
<p>Plug-ins resulted in the development of browser scripting languages. With a scripting language, you embed the source code for your client-side program directly into the HTML page, and the plug-in that interprets that language is automatically activated while the HTML page is being displayed. Scripting languages tend to be reasonably easy to understand and, because they are simply text that is part of an HTML page, they load very quickly as part of the single server hit required to procure that page. The trade-off is that your code is exposed for everyone to see (and steal). Generally, however, you aren’t doing amazingly sophisticated things with scripting languages, so this is not too much of a hardship.</p>
<p>One scripting language that you can expect a Web browser to support without a plug-in is JavaScript (this has only a passing resemblance to Java and you’ll have to climb an additional learning curve to use it. It was named that way just to grab some of Java’s marketing momentum). Unfortunately, most Web browsers originally implemented JavaScript in a different way from the other Web browsers, and even from other versions of themselves. The standardization of JavaScript in the form of ECMAScript has helped, but it has taken a long time for the various browsers to catch up (and it didn’t help that Microsoft was pushing its own agenda in the form of VBScript, which also had vague similarities to JavaScript). In general, you must program in a kind of least-common-denominator form of JavaScript in order to be able to run on all browsers. Dealing with errors and debugging JavaScript can only be described as a mess. As proof of its difficulty, only recently has anyone created a truly complex piece of JavaScript (Google, in GMail), and that required excessive dedication and expertise.</p>
<p>This points out that the scripting languages used inside Web browsers are really intended to solve specific types of problems, primarily the creation of richer and more interactive graphical user interfaces (GUIs). However, a scripting language might solve 80 percent of the problems encountered in client-side programming. Your problems might very well fit completely within that 80 percent, and since scripting languages can allow easier and faster development, you should probably consider a scripting language before looking at a more involved solution such as Java programming.</p>
<p>Java</p>
<p>If a scripting language can solve 80 percent of the client-side programming problems, what about the other 20 percent—the “really hard stuff’? Java is a popular solution for this. Not only is it a powerful programming language built to be secure, cross-platform, and international, but Java is being continually extended to provide language features and libraries that elegantly handle problems that are difficult in traditional programming languages, such as concurrency, database access, network programming, and distributed computing. Java allows client-side programming via the applet and with Java Web Start.</p>
<p>An applet is a mini-program that will run only under a Web browser. The applet is downloaded automatically as part of a Web page (just as, for example, a graphic is automatically downloaded). When the applet is activated, it executes a program. This is part of its beauty—it provides you with a way to automatically distribute the client software from the server at the time the user needs the client software, and no sooner. The user gets the latest version of the client software without fail and without difficult reinstallation. Because of the way Java is designed, the programmer needs to create only a single program, and that program automatically works with all computers that have browsers with built-in Java interpreters. (This safely includes the vast majority of machines.) Since Java is a full-fledged programming language, you can do as much work as possible on the client before and after making requests of the server. For example, you won’t need to send a request form across the Internet to discover that you’ve gotten a date or some other parameter wrong, and your client computer can quickly do the work of plotting data instead of waiting for the server to make a plot and ship a graphic image back to you. Not only do you get the immediate win of speed and responsiveness, but the general network traffic and load on servers can be reduced, preventing the entire Internet from slowing down.</p>
<p>Alternatives</p>
<p>To be honest, Java applets have not particularly lived up to their initial fanfare. When Java first appeared, what everyone seemed most excited about was applets, because these would finally allow serious client-side programmability, to increase responsiveness and decrease bandwidth requirements for Internet-based applications. People envisioned vast possibilities.</p>
<p>Indeed, you can find some very clever applets on the Web. But the overwhelming move to applets never happened. The biggest problem was probably that the 10 MB download necessary to install the Java Runtime Environment (JRE) was too scary for the average user. The fact that Microsoft chose not to include the JRE with Internet Explorer may have sealed its fate. In any event, Java applets didn’t happen on a large scale.</p>
<p>Nonetheless, applets and Java Web Start applications are still valuable in some situations. Anytime you have control over user machines, for example within a corporation, it is reasonable to distribute and update client applications using these technologies, and this can save considerable time, effort, and money, especially if you need to do frequent updates.</p>
<p>In the Graphical User Interfaces chapter, we will look at one promising new technology, Macromedia’s Flex, which allows you to create Flash-based applet-equivalents. Because the Flash Player is available on upwards of 98 percent of all Web browsers (including Windows, Linux and the Mac) it can be considered an accepted standard. Installing or upgrading the Flash Player is quick and easy. The ActionScript language is based on ECMAScript so it is reasonably familiar, but Flex allows you to program without worrying about browser specifics—thus it is far more attractive than JavaScript. For client-side programming, this is an alternative worth considering.</p>
<p>.NET and C#</p>
<p>For a while, the main competitor to Java applets was Microsoft’s ActiveX, although that required that the client be running Windows. Since then, Microsoft has produced a full competitor to Java in the form of the .NET platform and the C# programming language. The .NET platform is roughly the same as the Java Virtual Machine (JVM; the software platform on which Java programs execute) and Java libraries, and C# bears unmistakable similarities to Java. This is certainly the best work that Microsoft has done in the arena of programming languages and programming environments. Of course, they had the considerable advantage of being able to see what worked well and what didn’t work so well in Java, and build upon that, but build they have. This is the first time since its inception that Java has had any real competition. As a result, the Java designers at Sun have taken a hard look at C# and why programmers might want to move to it, and have responded by making fundamental improvements to Java in Java SE5.</p>
<p>Currently, the main vulnerability and important question concerning .NET is whether Microsoft will allow it to be completely ported to other platforms. They claim there’s no problem doing this, and the Mono project (<a l:href="http://www.go-mono.com">www.go-mono.com</a>) has a partial implementation of .NET working on Linux, but until the implementation is complete and Microsoft has not decided to squash any part of it, .NET as a cross-platform solution is still a risky bet.</p>
<p>Internet vs. intranet</p>
<p>The Web is the most general solution to the client/server problem, so it makes sense to use the same technology to solve a subset of the problem, in particular the classic client/server problem within a company. With traditional client/server approaches you have the problem of multiple types of client computers, as well as the difficulty of installing new client software, both of which are handily solved with Web browsers and client-side programming. When Web technology is used for an information network that is restricted to a particular company, it is referred to as an intranet. Intranets provide much greater security than the Internet, since you can physically control access to the servers within your company. In terms of training, it seems that once people understand the general concept of a browser it’s much easier for them to deal with differences in the way pages and applets look, so the learning curve for new kinds of systems seems to be reduced.</p>
<p>The security problem brings us to one of the divisions that seems to be automatically forming in the world of client-side programming. If your program is running on the Internet, you don’t know what platform it will be working under, and you want to be extra careful that you don’t disseminate buggy code. You need something cross-platform and secure, like a scripting language or Java.</p>
<p>If you’re running on an intranet, you might have a different set of constraints. It’s not uncommon that your machines could all be Intel/Windows platforms. On an intranet, you’re responsible for the quality of your own code and can repair bugs when they’re discovered. In addition, you might already have a body of legacy code that you’ve been using in a more traditional client/server approach, whereby you must physically install client programs every time you do an upgrade. The time wasted in installing upgrades is the most compelling reason to move to browsers, because upgrades are invisible and automatic (Java Web Start is also a solution to this problem). If you are involved in such an intranet, the most sensible approach to take is the shortest path that allows you to use your existing code base, rather than trying to recode your programs in a new language.</p>
<p>When faced with this bewildering array of solutions to the client-side programming problem, the best plan of attack is a cost-benefit analysis. Consider the constraints of your problem and what would be the shortest path to your solution. Since client-side programming is still programming, it’s always a good idea to take the fastest development approach for your particular situation. This is an aggressive stance to prepare for inevitable encounters with the problems of program development.</p>
<subtitle>Server-side programming</subtitle>
<p>This whole discussion has ignored the issue of server-side programming, which is arguably where Java has had its greatest success. What happens when you make a request of a server? Most of the time the request is simply “Send me this file.” Your browser then interprets the file in some appropriate fashion: as an HTML page, a graphic image, a Java applet, a script program, etc.</p>
<p>A more complicated request to a server generally involves a database transaction. A common scenario involves a request for a complex database search, which the server then formats into an HTML page and sends to you as the result. (Of course, if the client has more intelligence via Java or a scripting language, the raw data can be sent and formatted at the client end, which will be faster and less load on the server.) Or you might want to register your name in a database when you join a group or place an order, which will involve changes to that database. These database requests must be processed via some code on the server side, which is generally referred to as server-side programming. Traditionally, server-side programming has been performed using Perl, Python, C++, or some other language to create CGI programs, but more sophisticated systems have since appeared. These include Java-based Web servers that allow you to perform all your server-side programming in Java by writing what are called servlets. Servlets and their offspring, JSPs, are two of the most compelling reasons that companies that develop Web sites are moving to Java, especially because they eliminate the problems of dealing with differently abled browsers. Server-side programming topics are covered in Thinking in Enterprise Java at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>Despite all this talk about Java on the Internet, it is a general-purpose programming language that can solve the kinds of problems that you can solve with other languages. Here, Java’s strength is not only in its portability, but also its programmability, its robustness, its large, standard library and the numerous third-party libraries that are available and that continue to be developed.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>You know what a procedural program looks like: data definitions and function calls. To find the meaning of such a program, you must work at it, looking through the function calls and low-level concepts to create a model in your mind. This is the reason we need intermediate representations when designing procedural programs—by themselves, these programs tend to be confusing because the terms of expression are oriented more toward the computer than to the problem you’re solving.</p>
<p>Because OOP adds many new concepts on top of what you find in a procedural language, your natural assumption may be that the resulting Java program will be far more complicated than the equivalent procedural program. Here, you’ll be pleasantly surprised: A well-written Java program is generally far simpler and much easier to understand than a procedural program. What you’ll see are the definitions of the objects that represent concepts in your problem space (rather than the issues of the computer representation) and messages sent to those objects to represent the activities in that space. One of the delights of object-oriented programming is that, with a well-designed program, it’s easy to understand the code by reading it. Usually, there’s a lot less code as well, because many of your problems will be solved by reusing existing library code.</p>
<p>OOP and Java may not be for everyone. It’s important to evaluate your own needs and decide whether Java will optimally satisfy those needs, or if you might be better off with another programming system (including the one you’re currently using). If you know that your needs will be very specialized for the foreseeable future and if you have specific constraints that may not be satisfied by Java, then you owe it to yourself to investigate the alternatives (in particular, I recommend looking at Python; see <a l:href="http://www.Python.org">www.Python.org</a>). If you still choose Java as your language, you’ll at least understand what the options were and have a clear vision of why you took that direction.</p>
</section>
</section>
<section>
<title>
<p>Everything Is an Object</p></title><empty-line/>
<p>“If we spoke a different language, we would perceive a somewhat different world.”</p>
<p>Ludwig Wittgenstein (1889-1951)</p>
<p>Although it is based on C++, Java is more of a “pure” object-oriented language.</p>
<p>Both C++ and Java are hybrid languages, but in Java the designers felt that the hybridization was not as important as it was in C++. A hybrid language allows multiple programming styles; the reason C++ is hybrid is to support backward compatibility with the C language. Because C++ is a superset of the C language, it includes many of that language’s undesirable features, which can make some aspects of C++ overly complicated.</p>
<p>The Java language assumes that you want to do only object-oriented programming. This means that before you can begin you must shift your mindset into an object-oriented world (unless it’s already there). The benefit of this initial effort is the ability to program in a language that is simpler to learn and to use than many other OOP languages. In this chapter you’ll see the basic components of a Java program and learn that (almost) everything in Java is an object.</p>
<section>
<title>
<p>You manipulate objects with references</p></title><empty-line/>
<p>Each programming language has its own means of manipulating elements in memory. Sometimes the programmer must be constantly aware of what type of manipulation is going on. Are you manipulating the element directly, or are you dealing with some kind of indirect representation (a pointer in C or C++) that must be treated with a special syntax?</p>
<p>All this is simplified in Java. You treat everything as an object, using a single consistent syntax. Although you treat everything as an object, the identifier you manipulate is actually a “reference” to an object.<a l:href="#bookmark9" type="note"><sup>10</sup></a><sup></sup> You might imagine a television (the object) and a remote control (the reference). As long as you’re holding this reference, you have a connection to the television, but when someone says, “Change the channel” or “Lower the volume,” what you’re manipulating is the reference, which in turn modifies the object. If you want to move around the room and still control the television, you take the remote/reference with you, not the television.</p>
<p>Also, the remote control can stand on its own, with no television. That is, just because you have a reference doesn’t mean there’s necessarily an object connected to it. So if you want to hold a word or sentence, you create a String reference:</p>
<p>String s;</p>
<p>But here you’ve created only the reference, not an object. If you decided to send a message to s at this point, you’ll get an error because s isn’t actually attached to anything (there’s no television). A safer practice, then, is always to initialize a reference when you create it:</p>
<p>String s = &quot;asdf&quot;;</p>
<p>However, this uses a special Java feature: Strings can be initialized with quoted text. Normally, you must use a more general type of initialization for objects.</p>
</section>
<section>
<title>
<p>You must create all the objects</p></title><empty-line/>
<p>When you create a reference, you want to connect it with a new object. You do so, in general, with the new operator. The keyword new says, “Make me a new one of these objects.” So in the preceding example, you can say:</p>
<p>String s = new String(&quot;asdf&quot;);</p>
<p>Not only does this mean “Make me a new String,” but it also gives information about how to make the String by supplying an initial character string.</p>
<p>Of course, Java comes with a plethora of ready-made types in addition to String. What’s more important is that you can create your own types. In fact, creating new types is the fundamental activity in Java programming, and it’s what you’ll be learning about in the rest of this book.</p>
<subtitle>Where storage lives</subtitle>
<p>It’s useful to visualize some aspects of how things are laid out while the program is running— in particular how memory is arranged. There are five different places to store data:</p>
<p>1.    Registers. This is the fastest storage because it exists in a place different from that of other storage: inside the processor. However, the number of registers is severely limited, so registers are allocated as they are needed. You don’t have direct control, nor do you see any evidence in your programs that registers even exist (C &amp; C++, on the other hand, allow you to suggest register allocation to the compiler).</p>
<p>2.    The stack. This lives in the general random-access memory (RAM) area, but has direct support from the processor via its stack pointer. The stack pointer is moved down to create new memory and moved up to release that memory. This is an extremely fast and efficient way to allocate storage, second only to registers. The Java system must know, while it is creating the program, the exact lifetime of all the items that are stored on the stack. This constraint places limits on the flexibility of your programs, so while some Java storage exists on the stack—in particular, object references—Java objects themselves are not placed on the stack.</p>
<p>3.    The heap. This is a general-purpose pool of memory (also in the RAM area) where all Java objects live. The nice thing about the heap is that, unlike the stack, the compiler doesn’t need to know how long that storage must stay on the heap. Thus, there’s a great deal of flexibility in using storage on the heap. Whenever you need an object, you simply write the code to create it by using new, and the storage is allocated on the heap when that code is executed. Of course there’s a price you pay for this flexibility: It may take more time to allocate and clean up heap storage than stack storage (if you even could create objects on the stack in Java, as you can in C++).</p>
<p>4.    Constant storage. Constant values are often placed directly in the program code, which is safe since they can never change. Sometimes constants are cordoned off by themselves so that they can be optionally placed in read-only memory (ROM), in embedded systems.<sup>2</sup></p>
<p>5.    Non-RAM storage. If data lives completely outside a program, it can exist while the program is not running, outside the control of the program. The two primary examples of this are streamed objects, in which objects are turned into streams of bytes, generally to be sent to another machine, and persistent objects, in which the objects are placed on disk so they will hold their state even when the program is terminated. The trick with these types of storage is turning the objects into something that can exist on the other medium, and yet can be resurrected into a regular RAM-based object when necessary. Java provides support for lightweight persistence, and mechanisms such as JDBC and Hibernate provide more sophisticated support for storing and retrieving object information in databases.</p>
<subtitle>Special case: primitive types</subtitle>
<p>One group of types, which you’ll use quite often in your programming, gets special treatment. You can think of these as “primitive” types. The reason for the special treatment is that to create an object with new—especially a small, simple variable—isn’t very efficient, because new places objects on the heap. For these types Java falls back on the approach taken by C and C++. That is, instead of creating the variable by using new, an “automatic” variable is created that is not a reference. The variable holds the value directly, and it’s placed on the stack, so it’s much more efficient.</p>
<p>Java determines the size of each primitive type. These sizes don’t change from one machine architecture to another as they do in most languages. This size invariance is one reason Java programs are more portable than programs in most other languages.</p>
<table>
<tr><td>Primitive<sup>t</sup>yp<sup>e</sup></td><td>Size</td><td>Minimum</td><td>Maximum</td><td>Wrapper type</td></tr>
<tr><td>boolean</td><td>—</td><td>—</td><td>—</td><td>Boolean</td></tr>
<tr><td>char</td><td>16 bits</td><td>Unicode 0</td><td>Unicode 2<sup>16</sup>- 1</td><td>Character</td></tr>
<tr><td>byte</td><td>8 bits</td><td>-128</td><td>+127</td><td>Byte</td></tr>
<tr><td>short</td><td>16 bits</td><td><sub>-</sub>215</td><td>+2<sup>15</sup>-1</td><td>Short</td></tr>
<tr><td>int</td><td>32 bits</td><td>-2<sup>31</sup></td><td>+2<sup>31</sup>-1</td><td>Integer</td></tr>
<tr><td>long</td><td>64 bits</td><td><sub>-</sub>263</td><td>+2<sup>63</sup>-1</td><td>Long</td></tr>
<tr><td>float</td><td>32 bits</td><td>IEEE754</td><td>IEEE754</td><td>Float</td></tr>
<tr><td>double</td><td>64 bits</td><td>IEEE754</td><td>IEEE754</td><td>Double</td></tr>
<tr><td>void</td><td>—</td><td>—</td><td>—</td><td>Void</td></tr>
<tr><td colspan="5"><sup>2</sup> An example of this is the string pool. All literal strings and string-valued constant expressions are interned automatically and put into special static storage.</td></tr>
</table>
<p>All numeric types are signed, so don’t look for unsigned types.</p>
<p>The size of the boolean type is not explicitly specified; it is only defined to be able to take the literal values true or false.</p>
<p>The “wrapper” classes for the primitive data types allow you to make a non-primitive object on the heap to represent that primitive type. For example:</p>
<p>char c = ‘x’;</p>
<p>Character ch = new Character(c);</p>
<p>Or you could also use:</p>
<p>Character ch = new Character(‘x’);</p>
<p>Java SE5 autoboxing will automatically convert from a primitive to a wrapper type: Character ch = ‘x’; and back: char c = ch;</p>
<p>The reasons for wrapping primitives will be shown in a later chapter.</p>
<p>High-precision numbers</p>
<p>Java includes two classes for performing high-precision arithmetic: BigInteger and BigDecimal. Although these approximately fit into the same category as the “wrapper” classes, neither one has a primitive analogue.</p>
<p>Both classes have methods that provide analogues for the operations that you perform on primitive types. That is, you can do anything with a BigInteger or BigDecimal that you can with an int or float, it’s just that you must use method calls instead of operators. Also, since there’s more involved, the operations will be slower. You’re exchanging speed for accuracy.</p>
<p>BigInteger supports arbitrary-precision integers. This means that you can accurately represent integral values of any size without losing any information during operations.</p>
<p>BigDecimal is for arbitrary-precision fixed-point numbers; you can use these for accurate monetary calculations, for example.</p>
<p>Consult the JDK documentation for details about the constructors and methods you can call for these two classes.</p>
<subtitle>Arrays in Java</subtitle>
<p>Virtually all programming languages support some kind of arrays. Using arrays in C and C++ is perilous because those arrays are only blocks of memory. If a program accesses the array outside of its memory block or uses the memory before initialization (common programming errors), there will be unpredictable results.</p>
<p>One of the primary goals of Java is safety, so many of the problems that plague programmers in C and C++ are not repeated in Java. A Java array is guaranteed to be initialized and cannot be accessed outside of its range. The range checking comes at the price of having a small amount of memory overhead on each array as well as verifying the index at run time, but the assumption is that the safety and increased productivity are worth the expense (and Java can sometimes optimize these operations).</p>
<p>When you create an array of objects, you are really creating an array of references, and each of those references is automatically initialized to a special value with its own keyword: null. When Java sees null, it recognizes that the reference in question isn’t pointing to an object. You must assign an object to each reference before you use it, and if you try to use a reference that’s still null, the problem will be reported at run time. Thus, typical array errors are prevented in Java.</p>
<p>You can also create an array of primitives. Again, the compiler guarantees initialization because it zeroes the memory for that array.</p>
<p>Arrays will be covered in detail in later chapters.</p>
</section>
<section>
<title>
<p>You never need to destroy an object</p></title><empty-line/>
<p>In most programming languages, the concept of the lifetime of a variable occupies a significant portion of the programming effort. How long does the variable last? If you are supposed to destroy it, when should you? Confusion over variable lifetimes can lead to a lot of bugs, and this section shows how Java greatly simplifies the issue by doing all the cleanup work for you.</p>
<subtitle>Scoping</subtitle>
<p>Most procedural languages have the concept of scope. This determines both the visibility and lifetime of the names defined within that scope. In C, C++, and Java, scope is determined by the placement of curly braces {}. So for example:</p>
<p>{</p>
<p>int x = 12;</p>
<p>// Only x available</p>
<p>{</p>
<p>int q = 96;</p>
<p>// Both x &amp; q available</p>
<p>}</p>
<p>// Only x available // q is &quot;out of scope&quot;</p>
<p>}</p>
<p>A variable defined within a scope is available only to the end of that scope.</p>
<p>Any text after a ‘//’ to the end of a line is a comment.</p>
<p>Indentation makes Java code easier to read. Since Java is a free-form language, the extra spaces, tabs, and carriage returns do not affect the resulting program.</p>
<p>You cannot do the following, even though it is legal in C and C++:</p>
<p>{</p>
<p>int x = 12;</p>
<p>{</p>
<p>}</p>
<p>}</p>
<p>The compiler will announce that the variable x has already been defined. Thus the C and C++ ability to “hide” a variable in a larger scope is not allowed, because the Java designers thought that it led to confusing programs.</p>
<subtitle>Scope of objects</subtitle>
<p>Java objects do not have the same lifetimes as primitives. When you create a Java object using new, it hangs around past the end of the scope. Thus if you use:</p>
<p>{</p>
<p>String s = new String(&quot;a string&quot;);</p>
<p>} // End of scope</p>
<p>the reference s vanishes at the end of the scope. However, the String object that s was pointing to is still occupying memory. In this bit of code, there is no way to access the object after the end of the scope, because the only reference to it is out of scope. In later chapters you’ll see how the reference to the object can be passed around and duplicated during the course of a program.</p>
<p>It turns out that because objects created with new stay around for as long as you want them, a whole slew of C++ programming problems simply vanish in Java. In C++ you must not only make sure that the objects stay around for as long as you need them, you must also destroy the objects when you’re done with them.</p>
<p>That brings up an interesting question. If Java leaves the objects lying around, what keeps them from filling up memory and halting your program? This is exactly the kind of problem that would occur in C++. This is where a bit of magic happens. Java has a garbage collector, which looks at all the objects that were created with new and figures out which ones are not being referenced anymore. Then it releases the memory for those objects, so the memory can be used for new objects. This means that you never need to worry about reclaiming memory yourself. You simply create objects, and when you no longer need them, they will go away by themselves. This eliminates a certain class of programming problem: the so-called “memory leak,” in which a programmer forgets to release memory.</p>
</section>
<section>
<title>
<p>Creating new data types: class</p></title><empty-line/>
<p>If everything is an object, what determines how a particular class of object looks and behaves? Put another way, what establishes the type of an object? You might expect there to be a keyword called “type,” and that certainly would have made sense. Historically, however, most objectoriented languages have used the keyword class to mean “I’m about to tell you what a new type of object looks like.” The class keyword (which is so common that it will not usually be boldfaced throughout this book) is followed by the name of the new type. For example:</p>
<p>class ATypeName { /* Class body goes here */ }</p>
<p>This introduces a new type, although the class body consists only of a comment (the stars and slashes and what is inside, which will be discussed later in this chapter), so there is not too much that you can do with it. However, you can create an object of this type using new:</p>
<p>ATypeName a = new ATypeName();</p>
<p>But you cannot tell it to do much of anything (that is, you cannot send it any interesting messages) until you define some methods for it.</p>
<subtitle>Fields and methods</subtitle>
<p>When you define a class (and all you do in Java is define classes, make objects of those classes, and send messages to those objects), you can put two types of elements in your class: fields (sometimes called data members), and methods (sometimes called member functions). A field is an object of any type that you can talk to via its reference, or a primitive type. If it is a reference to an object, you must initialize that reference to connect it to an actual object (using new, as seen earlier).</p>
<p>Each object keeps its own storage for its fields; ordinary fields are not shared among objects. Here is an example of a class with some fields:</p>
<p>class DataOnly { int i; double d; boolean b;</p>
<p>}</p>
<p>This class doesn’t do anything except hold data. But you can create an object like this: DataOnly data = new DataOnly();</p>
<p>You can assign values to the fields, but you must first know how to refer to a member of an object. This is accomplished by stating the name of the object reference, followed by a period (dot), followed by the name of the member inside the object:</p>
<p>objectReference.member</p>
<p>For example:</p>
<p>data.i = 47; data.d = 1.1; data.b = false;</p>
<p>It is also possible that your object might contain other objects that contain data you’d like to modify. For this, you just keep “connecting the dots.” For example:</p>
<p>myPlane.leftTank.capacity = 100;</p>
<p>The DataOnly class cannot do much of anything except hold data, because it has no methods. To understand how those work, you must first understand arguments and return values, which will be described shortly.</p>
<p>Default values for primitive members</p>
<p>When a primitive data type is a member of a class, it is guaranteed to get a default value if you do not initialize it:</p>
<table>
<tr><td>Primitive type</td><td>Default</td></tr>
<tr><td>boolean</td><td>false</td></tr>
<tr><td>char</td><td>‘\u0000’ (null)</td></tr>
</table>
<table>
<tr><td>Primitive type</td><td>Default</td></tr>
<tr><td>byte</td><td>(byte)0</td></tr>
<tr><td>short</td><td>(short)0</td></tr>
<tr><td>int</td><td>0</td></tr>
<tr><td>long</td><td>0L</td></tr>
<tr><td>float</td><td>0.0f</td></tr>
<tr><td>double</td><td>0.0d</td></tr>
</table>
<p>The default values are only what Java guarantees when the variable is used as a member of a class. This ensures that member variables of primitive types will always be initialized (something C++ doesn’t do), reducing a source of bugs. However, this initial value may not be correct or even legal for the program you are writing. It’s best to always explicitly initialize your variables.</p>
<p>This guarantee doesn’t apply to local variables—those that are not fields of a class. Thus, if within a method definition you have:</p>
<p>int x;</p>
<p>Then x will get some arbitrary value (as in C and C++); it will not automatically be initialized to zero. You are responsible for assigning an appropriate value before you use x. If you forget, Java definitely improves on C++: You get a compile-time error telling you the variable might not have been initialized. (Many C++ compilers will warn you about uninitialized variables, but in Java these are errors.)</p>
</section>
<section>
<title>
<p>Methods, arguments, and return values</p></title><empty-line/>
<p>In many languages (like C and C++), the term Junction is used to describe a named subroutine. The term that is more commonly used in Java is method, as in “a way to do something.” If you want, you can continue thinking in terms of functions. It’s really only a syntactic difference, but this book follows the common Java usage of the term “method.”</p>
<p>Methods in Java determine the messages an object can receive. The fundamental parts of a method are the name, the arguments, the return type, and the body. Here is the basic form:</p>
<p>ReturnType methodName( /* Argument list */ ) {</p>
<p>/* Method body */</p>
<p>}</p>
<p>The return type describes the value that comes back from the method after you call it. The argument list gives the types and names for the information that you want to pass into the method. The method name and argument list (which is called the signature of the method) uniquely identify that method.</p>
<p>Methods in Java can be created only as part of a class. A method can be called only for an object,<a l:href="#bookmark10" type="note"><sup>11</sup></a><sup></sup> and that object must be able to perform that method call. If you try to call the wrong method for an object, you’ll get an error message at compile time. You call a method for an object by naming the object followed by a period (dot), followed by the name of the method and its argument list, like this: objectName.methodName(arg1, arg2, arg3);</p>
<p>For example, suppose you have a method f( ) that takes no arguments and returns a value of type int. Then, if you have an object called a for which f( ) can be called, you can say this:</p>
<p>int x = a.f();</p>
<p>The type of the return value must be compatible with the type of x. This act of calling a method is commonly referred to as sending a message to an object. In the preceding example, the message is f( ) and the object is a. Object-oriented programming is often summarized as simply “sending messages to objects.”</p>
<subtitle>The argument list</subtitle>
<p>The method argument list specifies what information you pass into the method. As you might guess, this information—like everything else in Java—takes the form of objects. So, what you must specify in the argument list are the types of the objects to pass in and the name to use for each one. As in any situation in Java where you seem to be handing objects around, you are actually passing references.4 The type of the reference must be correct, however. If the argument is supposed to be a String, you must pass in a String or the compiler will give an error. Consider a method that takes a String as its argument. Here is the definition, which must be placed within a class definition for it to be compiled:</p>
<p>int storage(String s) { return s.tengthQ * 2;</p>
<p>}</p>
<p>This method tells you how many bytes are required to hold the information in a particular String. (The size of each char in a String is 16 bits, or two bytes, to support Unicode characters.) The argument is of type String and is called s. Once s is passed into the method, you can treat it just like any other object. (You can send messages to it.) Here, the length( ) method is called, which is one of the methods for Strings; it returns the number of characters in a string.</p>
<p>You can also see the use of the return keyword, which does two things. First, it means “Leave the method, I’m done.” Second, if the method produces a value, that value is placed right after the return statement. In this case, the return value is produced by evaluating the expression s.length( ) * 2.</p>
<p>You can return any type you want, but if you don’t want to return anything at all, you do so by indicating that the method returns void. Here are some examples:</p>
<p>boolean flag() { return true; } double naturalLogBase() { return 2.718; } void nothing() { return; } void nothing2() {}</p>
<p>When the return type is void, then the return keyword is used only to exit the method, and is therefore unnecessary when you reach the end of the method. You can return from a method at any point, but if you’ve given a non-void return type, then the compiler will force you (with error messages) to return the appropriate type of value regardless of where you return.</p>
<p>At this point, it can look like a program is just a bunch of objects with methods that take other objects as arguments and send messages to those other objects. That is indeed much of what goes on, but in the following chapter you’ll learn how to do the detailed low-level work by making decisions within a method. For this chapter, sending messages will suffice.</p>
</section>
<section>
<title>
<p>Building a Java program</p></title><empty-line/>
<p>There are several other issues you must understand before seeing your first Java program.</p>
<subtitle>Name visibility</subtitle>
<p>A problem in any programming language is the control of names. If you use a name in one module of the program, and another programmer uses the same name in another module, how do you distinguish one name from another and prevent the two names from “clashing”? In C this is a particular problem because a program is often an unmanageable sea of names. C++ classes (on which Java classes are based) nest functions within classes so they cannot clash with function names nested within other classes. However, C++ still allows global data and global functions, so clashing is still possible. To solve this problem, C++ introduced namespaces using additional keywords.</p>
<p>Java was able to avoid all of this by taking a fresh approach. To produce an unambiguous name for a library, the Java creators want you to use your Internet domain name in reverse since domain names are guaranteed to be unique. Since my domain name is MindView.net, my utility library of foibles would be named</p>
<p>net.mindview.utility.foibles. After your reversed domain name, the dots are intended to represent subdirectories.</p>
<p>In Java 1.0 and Java 1.1 the domain extensions com, edu, org, net, etc., were capitalized by convention, so the library would appear: NET.mindview.utility.foibles. Partway through the development of Java 2, however, it was discovered that this caused problems, so now the entire package name is lowercase.</p>
<p>This mechanism means that all of your files automatically live in their own namespaces, and each class within a file must have a unique identifier—the language prevents name clashes for you.</p>
<subtitle>Using other components</subtitle>
<p>Whenever you want to use a predefined class in your program, the compiler must know how to locate it. Of course, the class might already exist in the same source-code file that it’s being called from. In that case, you simply use the class—even if the class doesn’t get defined until later in the file (Java eliminates the so-called “forward referencing” problem).</p>
<p>What about a class that exists in some other file? You might think that the compiler should be smart enough to simply go and find it, but there is a problem. Imagine that you want to use a class with a particular name, but more than one definition for that class exists (presumably these are different definitions). Or worse, imagine that you’re writing a program, and as you’re building it you add a new class to your library that conflicts with the name of an existing class.</p>
<p>To solve this problem, you must eliminate all potential ambiguities. This is accomplished by telling the Java compiler exactly what classes you want by using the import keyword. import tells the compiler to bring in a package, which is a library of classes. (In other languages, a library could consist of functions and data as well as classes, but remember that all code in Java must be written inside a class.)</p>
<p>Most of the time you’ll be using components from the standard Java libraries that come with your compiler. With these, you don’t need to worry about long, reversed domain names; you just say, for example:</p>
<p>import java.util.ArrayList;</p>
<p>to tell the compiler that you want to use Java’s ArrayList class. However, util contains a number of classes, and you might want to use several of them without declaring them all explicitly. This is easily accomplished by using ‘*’ to indicate a wild card:</p>
<p>import java.util.*;</p>
<p>It is more common to import a collection of classes in this manner than to import classes individually.</p>
<subtitle>The static keyword</subtitle>
<p>Ordinarily, when you create a class you are describing how objects of that class look and how they will behave. You don’t actually get an object until you create one using new, and at that point storage is allocated and methods become available.</p>
<p>There are two situations in which this approach is not sufficient. One is if you want to have only a single piece of storage for a particular field, regardless of how many objects of that class are created, or even if no objects are created. The other is if you need a method that isn’t associated with any particular object of this class. That is, you need a method that you can call even if no objects are created.</p>
<p>You can achieve both of these effects with the static keyword. When you say something is static, it means that particular field or method is not tied to any particular object instance of that class. So even if you’ve never created an object of that class you can call a static method or access a static field. With ordinary, non-static fields and methods, you must create an object and use that object to access the field or method, since non-static fields and methods must know the particular object they are working with.<a l:href="#bookmark11" type="note"><sup>12</sup></a><sup></sup></p>
<p>Some object-oriented languages use the terms class data and class methods, meaning that the data and methods exist only for the class as a whole, and not for any particular objects of the class. Sometimes the Java literature uses these terms too.</p>
<p>To make a field or method static, you simply place the keyword before the definition. For example, the following produces a static field and initializes it:</p>
<p>class StaticTest { static int i = 47;</p>
<p>}</p>
<p>Now even if you make two StaticTest objects, there will still be only one piece of storage for StaticTest.i. Both objects will share the same i. Consider:</p>
<p>StaticTest st1 = new StaticTest();</p>
<p>StaticTest st2 = new StaticTest();</p>
<p>At this point, both sti.i and st2.i have the same value of 47 since they refer to the same piece of memory.</p>
<p>There are two ways to refer to a static variable. As the preceding example indicates, you can name it via an object, by saying, for example, st2.i. You can also refer to it directly through its class name, something you cannot do with a non-static member.</p>
<p>StaticTest.i++;</p>
<p>The ++ operator adds one to the variable. At this point, both sti.i and st2.i will have the value 48.</p>
<p>Using the class name is the preferred way to refer to a static variable. Not only does it emphasize that variable’s static nature, but in some cases it gives the compiler better opportunities for optimization.</p>
<p>Similar logic applies to static methods. You can refer to a static method either through an object as you can with any method, or with the special additional syntax ClassName.method( ). You define a static method in a similar way:</p>
<p>class Incrementable {</p>
<p>static void increment() { StaticTest.i++; }</p>
<p>}</p>
<p>You can see that the Incrementable method increment( ) increments the static data i using the ++ operator. You can call increment( ) in the typical way, through an object:</p>
<p>Incrementable sf = new Incrementable(); sf.increment();</p>
<p>Or, because increment( ) is a static method, you can call it directly through its class: Incrementable.increment();</p>
<p>Although static, when applied to a field, definitely changes the way the data is created (one for each class versus the non-static one for each object), when applied to a method it’s not so dramatic. An important use of static for methods is to allow you to call that method without creating an object. This is essential, as you will see, in defining the main( ) method that is the entry point for running an application.</p>
</section>
<section>
<title>
<p>Your first Java program</p></title><empty-line/>
<p>Finally, here’s the first complete program. It starts by printing a string, and then the date, using the Date class from the Java standard library.</p>
<p>// HelloDate.java import java.util.*; public class HelloDate {</p>
<p>{</p>
<p>public static void main(String[] args) System.out.println(&quot;Hello, it&apos;s: &quot;); System.out.println(new Date());</p>
<p>}</p>
<p>}</p>
<p>At the beginning of each program file, you must place any necessary import statements to bring in extra classes you’ll need for the code in that file. Note that I say “extra”. That’s because there’s a certain library of classes that are automatically brought into every Java file: java.lang. Start up your Web browser and look at the documentation from Sun. (If you haven’t downloaded the JDK documentation from <a l:href="http://java.sun.com">http://java.sun.com</a>, do so now.<a l:href="#bookmark12" type="note"><sup>13</sup></a><sup></sup> Note that this documentation doesn’t come packed with the JDK; you must do a separate download to get it.) If you look at the list of the packages, you’ll see all the different class libraries that come with Java. Select java.lang. This will bring up a list of all the classes that are part of that library. Since java.lang is implicitly included in every Java code file, these classes are automatically available. There’s no Date class listed in java.lang, which means you must import another library to use that. If you don’t know the library where a particular class is, or if you want to see all of the classes, you can select “Tree” in the Java documentation. Now you can find every single class that comes with Java. Then you can use the browser’s “find” function to find Date. When you do you’ll see it listed as java.util.Date, which lets you know that it’s in the util library and that you must import java.util.* in order to use Date.</p>
<p>If you go back to the beginning, select java.lang and then System, you’ll see that the System class has several fields, and if you select out, you’ll discover that it’s a static PrintStream object. Since it’s static, you don’t need to create anything with new. The out object is always there, and you can just use it. What you can do with this out object is determined by its type: PrintStream. Conveniently, PrintStream is shown in the description as a hyperlink, so if you click on that, you’ll see a list of all the methods you can call for PrintStream. There are quite a few, and these will be covered later in the book. For now all we’re interested in is println( ), which in effect means “Print what I’m giving you out to the console and end with a newline.” Thus, in any Java program you write you can write something like this:</p>
<p>System.out.println(&quot;A String of things&quot;); whenever you want to display information to the console.</p>
<p>The name of the class is the same as the name of the file. When you’re creating a standalone program such as this one, one of the classes in the file must have the same name as the file. (The compiler complains if you don’t do this.) That class must contain a method called main( ) with this signature and return type:</p>
<p>public static void main(String[] args) {</p>
<p>The public keyword means that the method is available to the outside world (described in detail in the Access Control chapter). The argument to main( ) is an array of String objects. The args won’t be used in this program, but the Java compiler insists that they be there because they hold the arguments from the command line.</p>
<p>The line that prints the date is quite interesting:</p>
<p>System.out.println(new Date());</p>
<p>The argument is a Date object that is being created just to send its value (which is automatically converted to a String) to println( ). As soon as this statement is finished, that Date is unnecessary, and the garbage collector can come along and get it anytime. We don’t need to worry about cleaning it up.</p>
<p>When you look at the JDK documentation from <a l:href="http://java.sun.com">http://java.sun.com</a>, you will see that System has many other methods that allow you to produce interesting effects (one of Java’s most powerful assets is its large set of standard libraries). For example:</p>
<p>//: object/ShowProperties.java</p>
<p>public class ShowProperties {</p>
<p>public static void main(String[] args) { System.getProperties().list(System.out); System.out.println(System.getProperty(&quot;user.name&quot;)); System.out.println(</p>
<p>System.getProperty(&quot;java.library.path&quot;));</p>
<p>}</p>
<p>} ///:~</p>
<p>The first line in main( ) displays all of the “properties” from the system where you are running the program, so it gives you environment information. The list( ) method sends the results to its argument, System.out. You will see later in the book that you can send the results elsewhere, to a file, for example. You can also ask for a specific property—in this case, the user name and java.library.path. (The unusual comments at the beginning and end will be explained a little later.)</p>
<subtitle>Compiling and running</subtitle>
<p>To compile and run this program, and all the other programs in this book, you must first have a Java programming environment. There are a number of third-party development environments, but in this book I will assume that you are using the Java Developer’s Kit (JDK) from Sun, which is free. If you are using another development system,<a l:href="#bookmark13" type="note"><sup>14</sup></a><sup></sup> you will need to look in the documentation for that system to determine how to compile and run programs.</p>
<p>Get on the Internet and go to <a l:href="http://java.sun.com">http://java.sun.com</a>. There you will find information and links that will lead you through the process of downloading and installing the JDK for your particular platform.</p>
<p>Once the JDK is installed, and you’ve set up your computer’s path information so that it will find javac and java, download and unpack the source code for this book (you can find it at <a l:href="http://www.MindView.net">www.MindView.net</a>). This will create a subdirectory for each chapter in this book. Move to the subdirectory named objects and type:</p>
<p>javac HelloDate.java</p>
<p>This command should produce no response. If you get any kind of an error message, it means you haven’t installed the JDK properly and you need to investigate those problems.</p>
<p>On the other hand, if you just get your command prompt back, you can type:</p>
<p>java HelloDate</p>
<p>and you’ll get the message and the date as output.</p>
<p>This is the process you can use to compile and run each of the programs in this book. However, you will see that the source code for this book also has a file called build.xml in each chapter, and this contains “Ant” commands for automatically building the files for that chapter. Buildfiles and Ant (including where to download it) are described more fully in the supplement you will find at <a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a>, but once you have Ant installed (from <a l:href="http://jakarta.apache.org/ant">http://jakarta.apache.org/ant</a>) you can just type ‘ant’ at the command prompt to compile and run the programs in each chapter. If you haven’t installed Ant yet, you can just type the javac and java commands by hand.</p>
</section>
<section>
<title>
<p>Comments and embedded documentation</p></title><empty-line/>
<p>There are two types of comments in Java. The first is the traditional C-style comment that was inherited by C++. These comments begin with a /* and continue, possibly across many lines, until a */. Note that many programmers will begin each line of a continued comment with a *, so you’ll often see:</p>
<p>/* This is a comment</p>
<p>*    that continues</p>
<p>*    across lines</p>
<p>*/</p>
<p>Remember, however, that everything inside the /* and */ is ignored, so there’s no difference in saying:</p>
<p>/* This is a comment that continues across lines */</p>
<p>The second form of comment comes from C++. It is the single-line comment, which starts with a // and continues until the end of the line. This type of comment is convenient and commonly used because it’s easy. You don’t need to hunt on the keyboard to find / and then * (instead, you just press the same key twice), and you don’t need to close the comment. So you will often see:</p>
<p>// This is a one-line comment</p>
<subtitle>Comment documentation</subtitle>
<p>Possibly the biggest problem with documenting code has been maintaining that documentation. If the documentation and the code are separate, it becomes tedious to change the documentation every time you change the code. The solution seems simple: Link the code to the documentation. The easiest way to do this is to put everything in the same file. To complete the picture, however, you need a special comment syntax to mark the documentation and a tool to extract those comments and put them in a useful form. This is what Java has done.</p>
<p>The tool to extract the comments is called Javadoc, and it is part of the JDK installation. It uses some of the technology from the Java compiler to look for special comment tags that you put in your programs. It not only extracts the information marked by these tags, but it also pulls out the class name or method name that adjoins the comment. This way you can get away with the minimal amount of work to generate decent program documentation.</p>
<p>The output of Javadoc is an HTML file that you can view with your Web browser. Thus, Javadoc allows you to create and maintain a single source file and automatically generate useful documentation. Because of Javadoc, you have a straightforward standard for creating documentation, so you can expect or even demand documentation with all Java libraries.</p>
<p>In addition, you can write your own Javadoc handlers, called doclets, if you want to perform special operations on the information processed by Javadoc (to produce output in a different format, for example). Doclets are introduced in the supplement at <a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a>.</p>
<p>What follows is only an introduction and overview of the basics of Javadoc. A thorough description can be found in the JDK documentation. When you unpack the documentation, look in the “tooldocs” subdirectory (or follow the “tooldocs” link).</p>
<subtitle>Syntax</subtitle>
<p>All of the Javadoc commands occur only within /** comments. The comments end with */ as usual. There are two primary ways to use Javadoc: Embed HTML or use “doc tags.” Standalone doc tags are commands that start with an ‘@’ and are placed at the beginning of a comment line. (A leading ‘*’, however, is ignored.) Inline doc tags can appear anywhere within a Javadoc comment and also start with an ‘@’ but are surrounded by curly braces.</p>
<p>There are three “types” of comment documentation, which correspond to the element the comment precedes: class, field, or method. That is, a class comment appears right before the definition of a class, a field comment appears right in front of the definition of a field, and a method comment appears right in front of the definition of a method. As a simple example:</p>
<p>//: object/Documentationl.java /** A class comment */ public class Documentationl {</p>
<p>/** A field comment */ public int i;</p>
<p>/** A method comment */ public void f() {}</p>
<p>} ///:~</p>
<p>Note that Javadoc will process comment documentation for only public and protected members. Comments for private and package-access members (see the Access Control chapter) are ignored, and you’ll see no output. (However, you can use the -private flag to include private members as well.) This makes sense, since only public and protected members are available outside the file, which is the client programmer’s perspective.</p>
<p>The output for the preceding code is an HTML file that has the same standard format as all the rest of the Java documentation, so users will be comfortable with the format and can easily navigate your classes. It’s worth entering the preceding code, sending it through Javadoc, and viewing the resulting HTML file to see the results.</p>
<subtitle>Embedded HTML</subtitle>
<p>Javadoc passes HTML commands through to the generated HTML document. This allows you full use of HTML; however, the primary motive is to let you format code, such as:</p>
<p>//: object/Documentation2.java</p>
<p>/**</p>
<p>*    &lt;pre&gt;</p>
<p>*    System.out.println(new Date());</p>
<p>*    &lt;/pre&gt;</p>
<p>*/</p>
<p>///:~</p>
<p>You can also use HTML just as you would in any other Web document to format the regular text in your descriptions:</p>
<p>//: object/Documentation3.java</p>
<p>/**</p>
<p>*    You can &lt;em&gt;even&lt;/em&gt; insert a list:</p>
<p>*    &lt;ol&gt;</p>
<p>*    &lt;li&gt; Item one</p>
<p>*    &lt;li&gt; Item two</p>
<p>*    &lt;li&gt; Item three</p>
<p>*    &lt;/ol&gt;</p>
<p>*/</p>
<p>///:~</p>
<p>Note that within the documentation comment, asterisks at the beginning of a line are thrown away by Javadoc, along with leading spaces. Javadoc reformats everything so that it conforms to the standard documentation appearance. Don’t use headings such as &lt;hi&gt; or &lt;hr&gt; as embedded HTML, because Javadoc inserts its own headings and yours will interfere with them.</p>
<p>All types of comment documentation-class, field, and method-can support embedded HTML.</p>
<subtitle>Some example tags</subtitle>
<p>Here are some of the Javadoc tags available for code documentation. Before trying to do anything serious using Javadoc, you should consult the Javadoc reference in the JDK documentation to learn all the different ways that you can use Javadoc.</p>
<p>@see</p>
<p>This tag allows you to refer to the documentation in other classes. Javadoc will generate HTML with the @see tags hyperlinked to the other documentation. The forms are:</p>
<p>@see classname</p>
<p>@see fully-qualified-classname</p>
<p>@see fully-qualified-classname#method-name</p>
<p>Each one adds a hyperlinked “See Also” entry to the generated documentation. Javadoc will not check the hyperlinks you give it to make sure they are valid.</p>
<p>{@link package.class#member label}</p>
<p>Very similar to @see, except that it can be used inline and uses the label as the hyperlink text rather than “See Also.”</p>
<p>{@docRoot}</p>
<p>Produces the relative path to the documentation root directory. Useful for explicit hyperlinking to pages in the documentation tree.</p>
<p>{@inheritDoc}</p>
<p>Inherits the documentation from the nearest base class of this class into the current doc comment.</p>
<p>@version</p>
<p>This is of the form:</p>
<p>@version version-information</p>
<p>in which version-information is any significant information you see fit to include. When the - version flag is placed on the Javadoc command line, the version information will be called out specially in the generated HTML documentation.</p>
<p>@author</p>
<p>This is of the form:</p>
<p>@author author-information</p>
<p>in which author-information is, presumably, your name, but it could also include your email address or any other appropriate information. When the -author flag is placed on the Javadoc command line, the author information will be called out specially in the generated HTML documentation.</p>
<p>You can have multiple author tags for a list of authors, but they must be placed consecutively. All the author information will be lumped together into a single paragraph in the generated HTML.</p>
<p>@since</p>
<p>This tag allows you to indicate the version of this code that began using a particular feature. You’ll see it appearing in the HTML Java documentation to indicate what version of the JDK is used.</p>
<p>@param</p>
<p>This is used for method documentation, and is of the form:</p>
<p>@param parameter-name description</p>
<p>in which parameter-name is the identifier in the method parameter list, and description is text that can continue on subsequent lines. The description is considered finished when a new documentation tag is encountered. You can have any number of these, presumably one for each parameter.</p>
<p>@return</p>
<p>This is used for method documentation, and looks like this:</p>
<p>@return description</p>
<p>in which description gives you the meaning of the return value. It can continue on subsequent lines.</p>
<p>@throws</p>
<p>Exceptions will be demonstrated in the Error Handling with Exceptions chapter. Briefly, they are objects that can be “thrown” out of a method if that method fails. Although only one exception object can emerge when you call a method, a particular method might produce any number of different types of exceptions, all of which need descriptions. So the form for the exception tag is:</p>
<p>@throws fully-qualified-class-name description</p>
<p>in which fuUy-qualified-dass-name gives an unambiguous name of an exception class that’s defined somewhere, and description (which can continue on subsequent lines) tells you why this particular type of exception can emerge from the method call.</p>
<p>@deprecated</p>
<p>This is used to indicate features that were superseded by an improved feature. The deprecated tag is a suggestion that you no longer use this particular feature, since sometime in the future it is likely to be removed. A method that is marked @deprecated causes the compiler to issue a warning if it is used. In Java SE5, the @deprecated Javadoc tag has been superseded by the @Deprecated annotation (you’ll learn about these in the Annotations chapter).</p>
<subtitle>Documentation example</subtitle>
<p>Here is the first Java program again, this time with documentation comments added:</p>
<p>//: object/HelloDate.java import java.util.*;</p>
<p>/** The first Thinking in Java example program.</p>
<p>*    Displays a string and today’s date.</p>
<p>*    @author Bruce Eckel</p>
<p>*    @author <a l:href="http://www.MindView.net">www.MindView.net</a></p>
<p>*    @version 4.0 */</p>
<p>public class HelloDate {</p>
<p>/** Entry point to class &amp; application.</p>
<p>*    @param args array of string arguments</p>
<p>*    @throws exceptions No exceptions thrown</p>
<p>*/</p>
<p>public static void main(String[] args) {</p>
<p>System.out.println(&quot;Hello, it’s: &quot;);</p>
<p>System.out.println(new Date());</p>
<p>}</p>
<p>} /* Output: (55% match)</p>
<p>Hello, it’s:</p>
<p>Wed Oct 05 14:39:36 MDT 2005 *///:~</p>
<p>The first line of the file uses my own technique of putting a ‘//:’ as a special marker for the comment line containing the source file name. That line contains the path information to the file (object indicates this chapter) followed by the file name. The last line also finishes with a comment, and this one (‘///:~’) indicates the end of the source code listing, which allows it to be automatically updated into the text of this book after being checked with a compiler and executed.</p>
<p>The /* Output: tag indicates the beginning of the output that will be generated by this file.</p>
<p>In this form, it can be automatically tested to verify its accuracy. In this case, the (55% match) indicates to the testing system that the output will be fairly different from one run to the next so it should only expect a 55 percent correlation with the output shown here. Most examples in this book that produce output will contain the output in this commented form, so you can see the output and know that it is correct.</p>
</section>
<section>
<title>
<p>Coding style</p></title><empty-line/>
<p>The style described in the Code Conventions for the Java Programming Language<a l:href="#bookmark14" type="note"><sup>15</sup></a><sup></sup> is to capitalize the first letter of a class name. If the class name consists of several words, they are run together (that is, you don’t use underscores to separate the names), and the first letter of each embedded word is capitalized, such as:</p>
<p>class AUTheColorsOfTheRainbow { // ...</p>
<p>This is sometimes called “camel-casing.” For almost everything else—methods, fields (member variables), and object reference names—the accepted style is just as it is for classes except that the first letter of the identifier is lowercase. For example:</p>
<p>class AllTheColorsOfTheRainbow { int anIntegerRepresentingColors; void changeTheHueOfTheColor(int newHue) {</p>
<p>// ...</p>
<p>}</p>
<p>// ...</p>
<p>}</p>
<p>The user must also type all these long names, so be merciful.</p>
<p>The Java code you will see in the Sun libraries also follows the placement of open-and-close curly braces that you see used in this book.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>The goal of this chapter is just enough Java to understand how to write a simple program. You’ve also gotten an overview of the language and some of its basic ideas. However, the examples so far have all been of the form “Do this, then do that, then do something else.” The next two chapters will introduce the basic operators used in Java programming, and then show you how to control the flow of your program.</p>
</section>
<section>
<title>
<p>Exercises</p></title><empty-line/>
<p>Normally, exercises will be distributed throughout the chapters, but in this chapter you were learning how to write basic programs so all the exercises were delayed until the end.</p>
<p>The number in parentheses after each exercise number is an indicator of how difficult the exercise is, in a ranking from 1-10.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>Exercise 1: (2) Create a class containing an int and a char that are not initialized, and print their values to verify that Java performs default initialization.</p>
<p>Exercise 2: (1) Following the HelloDate.java example in this chapter, create a “hello, world” program that simply displays that statement. You need only a single method in your class (the “main” one that gets executed when the program starts). Remember to make it static and to include the argument list, even though you don’t use the argument list. Compile the program with javac and run it using java. If you are using a different development environment than the JDK, learn how to compile and run programs in that environment.</p>
<p>Exercise 3: (1) Find the code fragments involving ATypeName and turn them into a program that compiles and runs.</p>
<p>Exercise 4: (1) Turn the DataOnly code fragments into a program that compiles and runs.</p>
<p>Exercise 5: (1) Modify the previous exercise so that the values of the data in DataOnly are assigned to and printed in main( ).</p>
<p>Exercise 6: (2) Write a program that includes and calls the storage( ) method defined as a code fragment in this chapter.</p>
<p>Exercise 7: (1) Turn the Incrementable code fragments into a working program.</p>
<p>Exercise 8: (3) Write a program that demonstrates that, no matter how many objects you create of a particular class, there is only one instance of a particular static field in that class.</p>
<p>Exercise 9: (2) Write a program that demonstrates that autoboxing works for all the primitive types and their wrappers.</p>
<p>Exercise 10: (2) Write a program that prints three arguments taken from the command line. To do this, you’ll need to index into the command-line array of Strings.</p>
<p>Exercise 11: (1) Turn the AllTheColorsOfTheRainbow example into a program that compiles and runs.</p>
<p>Exercise 12: (2) Find the code for the second version of HelloDate.java, which is the simple comment documentation example. Execute Javadoc on the file and view the results with your Web browser.</p>
<p>Exercise 13: (1) Run Documentatiorn.java, Documentation2.java, and Documentation3.java through Javadoc. Verify the resulting documentation with your Web browser.</p>
<p>Exercise 14: (1) Add an HTML list of items to the documentation in the previous exercise.</p>
<p>Exercise 15: (1) Take the program in Exercise 2 and add comment documentation to it. Extract this comment documentation into an HTML file using Javadoc and view it with your Web browser.</p>
<p>Exercise 16: (1) In the Initialization &amp; Cleanup chapter, locate the Overloading.java example and add Javadoc documentation. Extract this comment documentation into an HTML file using Javadoc and view it with your Web browser.</p>
</section>
</section>
<section>
<title>
<p>Operators</p></title><empty-line/>
<p>At the lowest level, data in Java is manipulated using operators.</p>
<p>Because Java was inherited from C++, most of these operators will be familiar to C and C++ programmers. Java has also added some improvements and simplifications.</p>
<p>If you’re familiar with C or C++ syntax, you can skim through this chapter and the next, looking for places where Java is different from those languages. However, if you find yourself floundering a bit in these two chapters, make sure you go through the multimedia seminar Thinking in C, freely downloadable from <a l:href="http://www.MindView.net">www.MindView.net</a>. It contains audio lectures, slides, exercises, and solutions specifically designed to bring you up to speed with the fundamentals necessary to learn Java.</p>
<section>
<title>
<p>Simpler print statements</p></title><empty-line/>
<p>In the previous chapter, you were introduced to the Java print statement: System.out.println(&quot;Rather a lot to type&quot;);</p>
<p>You may observe that this is not only a lot to type (and thus many redundant tendon hits), but also rather noisy to read. Most languages before and after Java have taken a much simpler approach to such a commonly used statement.</p>
<p>The Access Control chapter introduces the concept of the static import that was added to Java SE5, and creates a tiny library to simplify writing print statements. However, you don’t need to know those details in order to begin using that library. We can rewrite the program from the last chapter using this new library:</p>
<p>//: operators/HelloDate.java import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class HelloDate {</p>
<p>public static void main(String[] args) { print(&quot;Hello, it&apos;s: &quot;); print(new Date());</p>
<p>}</p>
<p>} /* Output: (55% match)</p>
<p>Hello, it&apos;s:</p>
<p>Wed Oct 05 14:39:05 MDT 2005 *///:~</p>
<p>The results are much cleaner. Notice the insertion of the static keyword in the second import statement.</p>
<p>In order to use this library, you must download this book’s code package from <a l:href="http://www.MindView.net">www.MindView.net</a> or one of its mirrors. Unzip the code tree and add the root directory of that code tree to your computer’s CLASSPATH environment variable. (You’ll eventually get a full introduction to the classpath, but you might as well get used to struggling with it early. Alas, it is one of the more common battles you will have with Java.)</p>
<p>Although the use of net.mindview.utiLPrint nicely simplifies most code, it is not justifiable everywhere. If there are only a small number of print statements in a program, I forego the import and write out the full System.out.println( ).</p>
<p>Exercise 1: (1) Write a program that uses the “short” and normal form of print statement.</p>
</section>
<section>
<title>
<p>Using Java operators</p></title><empty-line/>
<p>An operator takes one or more arguments and produces a new value. The arguments are in a different form than ordinary method calls, but the effect is the same. Addition and unary plus (+), subtraction and unary minus (-), multiplication (*), division (/), and assignment (=) all work much the same in any programming language.</p>
<p>All operators produce a value from their operands. In addition, some operators change the value of an operand. This is called a side effect. The most common use for operators that modify their operands is to generate the side effect, but you should keep in mind that the value produced is available for your use, just as in operators without side effects.</p>
<p>Almost all operators work only with primitives. The exceptions are ‘=‘, ‘==‘ and ‘!=‘, which work with all objects (and are a point of confusion for objects). In addition, the String class supports ‘+’ and ‘+=‘.</p>
</section>
<section>
<title>
<p>Precedence</p></title><empty-line/>
<p>Operator precedence defines how an expression evaluates when several operators are present. Java has specific rules that determine the order of evaluation. The easiest one to remember is that multiplication and division happen before addition and subtraction. Programmers often forget the other precedence rules, so you should use parentheses to make the order of evaluation explicit. For example, look at statements (1) and (2):</p>
<p>//: operators/Precedence.java</p>
<p>public class Precedence {</p>
<p>public static void main(String[] args) { int x = 1, y = 2, z = 3; int a = x + y - 2/2 + z;    // (1)</p>
<p>int b = x + (y - 2)/(2 + z);    // (2)</p>
<p>System.out.println(&quot;a = &quot; + a + &quot; b = &quot; + b);</p>
<p>}</p>
<p>} /* Output: a = 5 b = 1 *///:~</p>
<p>These statements look roughly the same, but from the output you can see that they have very different meanings which depend on the use of parentheses.</p>
<p>Notice that the System.out.println( ) statement involves the ‘+’ operator. In this context, ‘+’ means “string concatenation” and, if necessary, “string conversion.” When the compiler sees a String followed by a ‘+’ followed by a non-String, it attempts to convert the nonString into a String. As you can see from the output, it successfully converts from int into String for a and b.</p>
</section>
<section>
<title>
<p>Assignment</p></title><empty-line/>
<p>Assignment is performed with the operator =. It means “Take the value of the right-hand side (often called the rvalue) and copy it into the left-hand side (often called the lvalue)”. An rvalue is any constant, variable, or expression that produces a value, but an lvalue must be a distinct, named variable. (That is, there must be a physical space to store the value.) For instance, you can assign a constant value to a variable:</p>
<p>a = 4;</p>
<p>but you cannot assign anything to a constant value—it cannot be an lvalue. (You can’t say 4 = a;.)</p>
<p>Assignment of primitives is quite straightforward. Since the primitive holds the actual value and not a reference to an object, when you assign primitives, you copy the contents from one place to another. For example, if you say a = b for primitives, then the contents of b are copied into a. If you then go on to modify a, b is naturally unaffected by this modification. As a programmer, this is what you can expect for most situations.</p>
<p>When you assign objects, however, things change. Whenever you manipulate an object, what you’re manipulating is the reference, so when you assign “from one object to another,” you’re actually copying a reference from one place to another. This means that if you say c = d for objects, you end up with both c and d pointing to the object that, originally, only d pointed to. Here’s an example that demonstrates this behavior:</p>
<p>//: operators/Assignment.java // Assignment with objects is a bit tricky. import static net.mindview.util.Print.*;</p>
<p>class Tank { int level;</p>
<p>}</p>
<p>public class Assignment {</p>
<p>public static void main(String[] args) {</p>
<p>Tank t1 = new Tank();</p>
<p>Tank t2 = new Tank(); t1.level = 9; t2.level = 47;</p>
<p>print(&quot;1: t1.level: &quot; + t1.level +</p>
<p>&quot;, t2.level: &quot; + t2.level); t1 = t2;</p>
<p>print(&quot;2: t1.level: &quot; + t1.level +</p>
<p>&quot;, t2.level: &quot; + t2.level); t1.level = 27;</p>
<p>print(&quot;3: t1.level: &quot; + t1.level +</p>
<p>&quot;, t2.level: &quot; + t2.level);</p>
<table>
<tr><th colspan="7">}</th></tr>
<tr><td>}</td><td>/*</td><td>Output:</td><td></td><td></td><td></td><td></td></tr>
<tr><td>1</td><td>: t1</td><td>.level:</td><td>9,</td><td>t2.</td><td>level:</td><td>47</td></tr>
<tr><td>2</td><td>: t1</td><td>.level:</td><td>47</td><td>t2</td><td>.level</td><td>47</td></tr>
<tr><td>3</td><td>: t1</td><td>.level:</td><td>27</td><td>t2</td><td>.level</td><td>27</td></tr>
<tr><td><sub>*</sub></td><td>///:</td><td>~</td><td></td><td></td><td></td><td></td></tr>
</table>
<p>The Tank class is simple, and two instances (ti and t2) are created within main( ). The level field within each Tank is given a different value, and then t2 is assigned to ti, and ti is changed. In many programming languages you expect ti and t2 to be independent at all times, but because you’ve assigned a reference, changing the ti object appears to change the t2 object as well! This is because both ti and t2 contain the same reference, which is pointing to the same object. (The original reference that was in ti, that pointed to the object holding a value of 9, was overwritten during the assignment and effectively lost; its object will be cleaned up by the garbage collector.)</p>
<p>This phenomenon is often called aliasing, and it’s a fundamental way that Java works with objects. But what if you don’t want aliasing to occur in this case? You could forego the assignment and say:</p>
<p>ti.level = t2.1evel;</p>
<p>This retains the two separate objects instead of discarding one and tying ti and t2 to the same object. You’ll soon realize that manipulating the fields within objects is messy and goes against good object-oriented design principles. This is a nontrivial topic, so you should keep in mind that assignment for objects can add surprises.</p>
<p>Exercise 2: (1) Create a class containing a float and use it to demonstrate aliasing.</p>
<subtitle>Aliasing during method calls</subtitle>
<p>Aliasing will also occur when you pass an object into a method: //: operators/PassObject.java</p>
<p>// Passing objects to methods may not be</p>
<p>// what you’re used to.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Letter { char c;</p>
<p>}</p>
<table>
<tr><th colspan="4">public class PassObject { static void f(Letter y) {</th></tr>
<tr><td>y.c =</td><td>z’</td><td>;</td><td></td></tr>
<tr><td>}</td><td></td><td></td><td></td></tr>
<tr><td>public st</td><td>at</td><td>ic voi</td><td>id main(St</td></tr>
<tr><td>Letter</td><td>x</td><td>= new</td><td>Letter();</td></tr>
<tr><td>x.c = ‘</td><td>a’</td><td>;</td><td></td></tr>
<tr><td>print(&quot;</td><td>1:</td><td>x.c:</td><td>&quot; + x.c);</td></tr>
<tr><td>f(x);</td><td></td><td></td><td></td></tr>
<tr><td>print(&quot;</td><td>2:</td><td>x.c:</td><td>&quot; + x.c);</td></tr>
</table>
<p>{</p>
<p>}</p>
<p>} /* Output: 1: x.c: a 2: x.c: z *///:~</p>
<p>In many programming languages, the method f( ) would appear to be making a copy of its argument Letter y inside the scope of the method. But once again a reference is being passed, so the line</p>
<p>y.c = ‘z’;</p>
<p>is actually changing the object outside of f( ).</p>
<p>Aliasing and its solution is a complex issue which is covered in one of the online supplements for this book. However, you should be aware of it at this point so you can watch for pitfalls.</p>
<p>Exercise 3: (1) Create a class containing a float and use it to demonstrate aliasing during method calls.</p>
</section>
<section>
<title>
<p>Mathematical operators</p></title><empty-line/>
<p>The basic mathematical operators are the same as the ones available in most programming languages: addition (+), subtraction (-), division (/), multiplication (*) and modulus (%, which produces the remainder from integer division). Integer division truncates, rather than rounds, the result.</p>
<p>Java also uses the shorthand notation from C/C++ that performs an operation and an assignment at the same time. This is denoted by an operator followed by an equal sign, and is consistent with all the operators in the language (whenever it makes sense). For example, to add 4 to the variable x and assign the result to x, use: x += 4.</p>
<p>This example shows the use of the mathematical operators:</p>
<p>//: operators/MathOps.java</p>
<p>// Demonstrates the mathematical operators.</p>
<p>import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class MathOps {</p>
<p>public static void main(String[] args) {</p>
<p>// Create a seeded random number generator:</p>
<p>Random rand = new Random(47); int i, j, k;</p>
<p>// Choose value from 1 to 100: j = rand.nextInt(100) + 1;</p>
<table>
<tr><td>print(&quot;j : &quot; +</td><td>j);</td></tr>
<tr><td colspan="2">k = rand.nextInt(100) +</td></tr>
<tr><td>print(&quot;k : &quot; + i = j + k;</td><td>k);</td></tr>
<tr><td>print(&quot;j + k : i = j - k;</td><td>&quot; + i);</td></tr>
<tr><td>print(&quot;j - k : i = k / j;</td><td>&quot; + i);</td></tr>
<tr><td>print(&quot;k / j : i = k * j;</td><td>&quot; + i);</td></tr>
<tr><td>print(&quot;k * j : i = k % j;</td><td>&quot; + i);</td></tr>
<tr><td>print(&quot;k % j : j %= k;</td><td>&quot; + i);</td></tr>
<tr><td>print(&quot;j %= k :</td><td>: &quot; + j);</td></tr>
</table>
<p>// Floating-point number tests:</p>
<p>float u, v, w; // Applies to doubles, too</p>
<p>v = rand.nextFloat();</p>
<p>print(&quot;v : &quot; + v);</p>
<p>w = rand.nextFloat();</p>
<p>print(&quot;w : &quot; + w);</p>
<p>u = v + w;</p>
<p>print(&quot;v + w : &quot; + u); u = v - w;</p>
<p>print(&quot;v - w : &quot; + u); u = v * w;</p>
<p>print(&quot;v * w : &quot; + u); u = v / w;</p>
<p>print(&quot;v / w : &quot; + u);</p>
<p>// The following also works for char,</p>
<p>// byte, short, int, long, and double:</p>
<p>}</p>
<table>
<tr><td>u += v;</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>print(&quot;</td><td>u</td><td>+=</td><td>v :</td><td>&quot; +</td><td>u</td></tr>
<tr><td>u -= v;</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>print(&quot;</td><td>u</td><td>-=</td><td>v :</td><td>&quot; +</td><td>u</td></tr>
<tr><td>u *= v;</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>print(&quot;</td><td>u</td><td>* =</td><td>v :</td><td>&quot; +</td><td>u</td></tr>
<tr><td>u /= v;</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>print(&quot;</td><td>u</td><td>/=</td><td>v :</td><td>&quot; +</td><td>u</td></tr>
</table>
<table>
<tr><td>}</td><td>/*</td><td colspan="2">Output:</td></tr>
<tr><td>j</td><td></td><td>59</td><td></td></tr>
<tr><td>k</td><td></td><td>56</td><td></td></tr>
<tr><td>j</td><td>+</td><td>k :</td><td>115</td></tr>
<tr><td>j</td><td>-</td><td>k :</td><td>3</td></tr>
<tr><td>k</td><td>/</td><td>j</td><td>0</td></tr>
<tr><td>k</td><td>*</td><td>j</td><td>3304</td></tr>
<tr><td>k</td><td>%</td><td>j</td><td>56</td></tr>
<tr><td><sup>j</sup></td><td>%=</td><td>k</td><td>: 3</td></tr>
<tr><td>v</td><td></td><td colspan="2">0.5309454</td></tr>
<tr><td>w</td><td></td><td colspan="2">0.0534122</td></tr>
<tr><td>v</td><td>+</td><td>w :</td><td>0.5843576</td></tr>
<tr><td>v</td><td>-</td><td>w :</td><td>0.47753322</td></tr>
<tr><td>v</td><td>*</td><td>w :</td><td>0.028358962</td></tr>
<tr><td>v</td><td>/</td><td>w :</td><td>9.940527</td></tr>
<tr><td>u</td><td>+=</td><td>v</td><td>: 10.471473</td></tr>
<tr><td>u</td><td>- =</td><td>v</td><td>: 9.940527</td></tr>
<tr><td>u</td><td>* =</td><td>v</td><td>: 5.2778773</td></tr>
<tr><td>u</td><td>/ =</td><td>v</td><td>: 9.940527</td></tr>
<tr><td>*</td><td>///</td><td>:~</td><td></td></tr>
</table>
<p>To generate numbers, the program first creates a Random object. If you create a Random object with no arguments, Java uses the current time as a seed for the random number generator, and will thus produce different output for each execution of the program.</p>
<p>However, in the examples in this book, it is important that the output shown at the end of the examples be as consistent as possible, so that this output can be verified with external tools. By providing a seed (an initialization value for the random number generator that will always produce the same sequence for a particular seed value) when creating the Random object, the same random numbers will be generated each time the program is executed, so the output is verifiable.<a l:href="#bookmark15" type="note"><sup>16</sup></a><sup></sup> To generate more varying output, feel free to remove the seed in the examples in the book.</p>
<p>The program generates a number of different types of random numbers with the Random object simply by calling the methods nextInt( ) and nextFloat( ) (you can also call nextLong( ) or nextDouble( )). The argument to nextInt( ) sets the upper bound on the generated number. The lower bound is zero, which we don’t want because of the possibility of a divide-by-zero, so the result is offset by one.</p>
<p>Exercise 4: (2) Write a program that calculates velocity using a constant distance and a constant time.</p>
<subtitle>Unary minus and plus operators</subtitle>
<p>The unary minus (-) and unary plus (+) are the same operators as binary minus and plus.</p>
<p>The compiler figures out which use is intended by the way you write the expression. For instance, the statement -a;</p>
<p>x</p>
<p>has an obvious meaning. The compiler is able to figure out: x = a * -b;</p>
<p>but the reader might get confused, so it is sometimes clearer to say: x = a * (-b);</p>
<p>Unary minus inverts the sign on the data. Unary plus provides symmetry with unary minus, although it doesn’t have any effect.</p>
</section>
<section>
<title>
<p>Auto increment and decrement</p></title><empty-line/>
<p>Java, like C, has a number of shortcuts. Shortcuts can make code much easier to type, and either easier or harder to read.</p>
<p>Two of the nicer shortcuts are the increment and decrement operators (often referred to as the auto-increment and auto-decrement operators). The decrement operator is -- and means “decrease by one unit.” The increment operator is ++ and means “increase by one unit.” If a is an int, for example, the expression ++a is equivalent to (a = a + 1). Increment and decrement operators not only modify the variable, but also produce the value of the variable as a result.</p>
<p>There are two versions of each type of operator, often called the prefix and postfix versions. Preincrement means the ++ operator appears before the variable, and post-increment means the ++ operator appears after the variable. Similarly, pre-decrement means the -operator appears before the variable, and post-decrement means the -- operator appears after the variable. For pre-increment and pre-decrement (i.e., ++a or --a), the operation is performed and the value is produced. For post-increment and post-decrement (i.e., a++ or a--), the value is produced, then the operation is performed. As an example: //: operators/AutoInc.java // Demonstrates the ++ and -- operators. import static net.mindview.util.Print.*;</p>
<p>public class AutoInc {</p>
<table>
<tr><td colspan="2">void + i)</td><td colspan="2">main(Str;</td><td rowspan="5">ng[] args) {Pre-incrementPost-incrementPre-decrementPost-decrement</td></tr>
<tr><td>11</td><td>+</td><td>++i);</td><td>//</td></tr>
<tr><td>II+</td><td>+i)</td><td>i++);;</td><td>//</td></tr>
<tr><td>II</td><td>+</td><td>--i);</td><td>//</td></tr>
<tr><td>II+</td><td>+i)</td><td>i--); ;</td><td>//</td></tr>
</table>
<p>public static int i = 1; print(&quot;i : print(&quot;++i print(&quot;i++ print(&quot;i : print(&quot;--i print(&quot;i--print(&quot;i :</p>
<p>}</p>
<p>} /* Output: i : 1 ++i : 2 i++ : 2 i : 3 --i : 2 i-- : 2 i : 1 *///:~</p>
<p>You can see that for the prefix form, you get the value after the operation has been performed, but with the postfix form, you get the value before the operation is performed. These are the only operators, other than those involving assignment, that have side effects— they change the operand rather than using just its value.</p>
<p>The increment operator is one explanation for the name C++, implying “one step beyond C.” In an early Java speech, Bill Joy (one of the Java creators), said that “Java=C++--” (C plus plus minus minus), suggesting that Java is C++ with the unnecessary hard parts removed, and therefore a much simpler language. As you progress in this book, you’ll see that many parts are simpler, and yet in other ways Java isn’t much easier than C++.</p>
</section>
<section>
<title>
<p>Relational operators</p></title><empty-line/>
<p>Relational operators generate a boolean result. They evaluate the relationship between the values of the operands. A relational expression produces true if the relationship is true, and false if the relationship is untrue. The relational operators are less than (&lt;), greater than (&gt;), less than or equal to (&lt;=), greater than or equal to (&gt;=), equivalent (==) and not equivalent (!=). Equivalence and nonequivalence work with all primitives, but the other comparisons won’t work with type boolean. Because boolean values can only be true or false, “greater than” and “less than” doesn’t make sense.</p>
<subtitle>Testing object equivalence</subtitle>
<p>The relational operators == and != also work with all objects, but their meaning often confuses the first-time Java programmer. Here’s an example:</p>
<p>//: operators/Equivalence.java</p>
<p>public class Equivalence {</p>
<p>public static void main(String[] args) {</p>
<p>Integer n1 = new Integer(47);</p>
<p>Integer n2 = new Integer(47);</p>
<p>System.out.println(n1 == n2);</p>
<p>System.out.println(n1 != n2);</p>
<p>}</p>
<p>} /* Output:</p>
<p>false</p>
<p>true</p>
<p>*///:~</p>
<p>The statement System.out.println(n1 == n2) will print the result of the boolean comparison within it. Surely the output should be “true” and then “false,” since both Integer objects are the same. But while the contents of the objects are the same, the references are not the same. The operators == and != compare object references, so the output is actually “false” and then “true.” Naturally, this surprises people at first.</p>
<p>What if you want to compare the actual contents of an object for equivalence? You must use the special method equals( ) that exists for all objects (not primitives, which work fine with = = and !=). Here’s how it’s used:</p>
<p>//: operators/EqualsMethod.java</p>
<p>public class EqualsMethod {</p>
<p>public static void main(String[] args) {</p>
<p>Integer n1 = new Integer(47);</p>
<p>Integer n2 = new Integer(47);</p>
<p>System.out.println(n1.equals(n2));</p>
<p>} /* Output:</p>
<p>true</p>
<p>*///:~</p>
<p>The result is now what you expect. Ah, but it’s not as simple as that. If you create your own class, like this:</p>
<p>//: operators/EqualsMethod2.java</p>
<p>// Default equals() does not compare contents.</p>
<p>class Value { int i;</p>
<p>}</p>
<p>public class EqualsMethod2 {</p>
<p>public static void main(String[] args) {</p>
<p>Value v1 = new Value();</p>
<p>Value v2 = new Value(); vl.i = v2.i = 100;</p>
<p>System.out.println(v1.equals(v2));</p>
<p>}</p>
<p>} /* Output:</p>
<p>false</p>
<p>*///:~ things are confusing again: The result is false. This is because the default behavior of equals( ) is to compare references. So unless you override equals( ) in your new class you won’t get the desired behavior. Unfortunately, you won’t learn about overriding until the Reusing Classes chapter and about the proper way to define equals( ) until the Containers in Depth chapter, but being aware of the way equals( ) behaves might save you some grief in the meantime.</p>
<p>Most of the Java library classes implement equals( ) so that it compares the contents of objects instead of their references.</p>
<p>Exercise 5: (2) Create a class called Dog containing two Strings: name and says. In main( ), create two dog objects with names “spot” (who says, “Ruff!”) and “scruffy” (who says, “Wurf!”). Then display their names and what they say.</p>
<p>Exercise 6: (3) Following Exercise 5, create a new Dog reference and assign it to spot’s object. Test for comparison using == and equals( ) for all references.</p>
</section>
<section>
<title>
<p>Logical operators</p></title><empty-line/>
<p>Each of the logical operators AND (&amp;&amp;), OR (||) and NOT (!) produces a boolean value of true or false based on the logical relationship of its arguments. This example uses the relational and logical operators:</p>
<p>//: operators/Bool.java // Relational and logical operators. import java.util.*;</p>
<p>import static net.mindview.util.Print.*; public class Bool {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47); int i = rand.nextInt(100);</p>
<p>//! print(&quot;!i is &quot; + !i);</p>
<p>print(&quot;(i &lt; 10) &amp;&amp; (j &lt; 10) is &quot;</p>
<p>+ ((i &lt; 10) &amp;&amp; (j &lt; 10)) ); print(&quot;(i &lt; 10) || (j &lt; 10) is &quot;</p>
<p>+ ((i &lt; 10) || (j &lt; 10)) );</p>
<p>}</p>
<p>} /* Output: i = 58 j = 55</p>
<p>i &gt; j is true i &lt; j is false i    &gt;=    j    is    true</p>
<p>i    &lt;=    j    is    false</p>
<p>i    ==    j    is    false</p>
<p>i    !=    j    is    true</p>
<p>(i &lt; 10) &amp;&amp; (j &lt; 10) is false (i &lt; 10) || (j &lt; 10) is false *///:~</p>
<p>You can apply AND, OR, or NOT to boolean values only. You can’t use a non-boolean as if it were a boolean in a logical expression as you can in C and C++. You can see the failed attempts at doing this commented out with a ‘//!’ (this comment syntax enables automatic removal of comments to facilitate testing). The subsequent expressions, however, produce boolean values using relational comparisons, then use logical operations on the results.</p>
<p>Note that a boolean value is automatically converted to an appropriate text form if it is used where a String is expected.</p>
<p>You can replace the definition for int in the preceding program with any other primitive data type except boolean. Be aware, however, that the comparison of floating point numbers is very strict. A number that is the tiniest fraction different from another number is still “not equal.” A number that is the tiniest bit above zero is still nonzero.</p>
<p>Exercise 7: (3) Write a program that simulates coin-flipping.</p>
<subtitle>Short-circuiting</subtitle>
<p>When dealing with logical operators, you run into a phenomenon called “short-circuiting.” This means that the expression will be evaluated only until the truth or falsehood of the entire expression can be unambiguously determined. As a result, the latter parts of a logical expression might not be evaluated. Here’s an example that demonstrates short-circuiting:</p>
<p>//: operators/ShortCircuit.java // Demonstrates short-circuiting behavior // with logical operators. import static net.mindview.util.Print.*;</p>
<p>public class ShortCircuit {</p>
<p>static boolean test1(int val) { print(&quot;test1(&quot; + val + &quot;)&quot;); print(&quot;result: &quot; + (val &lt; 1)); return val &lt; 1;</p>
<p>}</p>
<p>static boolean test2(int val) { print(&quot;test2(&quot; + val + &quot;)&quot;); print(&quot;result: &quot; + (val &lt; 2)); return val &lt; 2;</p>
<p>}</p>
<p>static boolean test3(int val) { print(&quot;test3(&quot; + val + &quot;)&quot;); print(&quot;result: &quot; + (val &lt; 3)); return val &lt; 3;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>boolean b = test1(0) &amp;&amp; test2(2) &amp;&amp; test3(2); print(&quot;expression is &quot; + b);</p>
<p>}</p>
<p>} /* Output: test1(0) result: true test2(2) result: false expression is false *///:~</p>
<p>Each test performs a comparison against the argument and returns true or false. It also prints information to show you that it’s being called. The tests are used in the expression:</p>
<p>test1(0) &amp;&amp; test2(2) &amp;&amp; test3(2)</p>
<p>You might naturally think that all three tests would be executed, but the output shows otherwise. The first test produced a true result, so the expression evaluation continues. However, the second test produced a false result. Since this means that the whole expression must be false, why continue evaluating the rest of the expression? It might be expensive. The reason for shortcircuiting, in fact, is that you can get a potential performance increase if all the parts of a logical expression do not need to be evaluated.</p>
</section>
<section>
<title>
<p>Literals</p></title><empty-line/>
<p>Ordinarily, when you insert a literal value into a program, the compiler knows exactly what type to make it. Sometimes, however, the type is ambiguous. When this happens, you must guide the compiler by adding some extra information in the form of characters associated with the literal value. The following code shows these characters:</p>
<p>//: operators/Literals.java</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Literals {</p>
<p>public static void main(String[] args) { int i1 = 0x2f; // Hexadecimal (lowercase) print(&quot;i1: &quot; + Integer.toBinaryString(i1)); int i2 = 0X2F; // Hexadecimal (uppercase) print(&quot;i2: &quot; + Integer.toBinaryString(i2)); int i3 = 0177; // Octal (leading zero) print(&quot;i3: &quot; + Integer.toBinaryString(i3)); char c = 0xffff; // max char hex value</p>
<p>print(&quot;c: &quot; + Integer.toBinaryString(c)); byte b = 0x7f; // max byte hex value print(&quot;b: &quot; + Integer.toBinaryString(b)); short s = 0x7fff; // max short hex value print(&quot;s: &quot; + Integer.toBinaryString(s)); long n1 = 200L; // long suffix</p>
<p>long n2 = 200l; // long suffix (but can be confusing) long n3 = 200; float f1 = 1;</p>
<p>float f2 = 1F; // float suffix float f3 = 1f; // float suffix double d1 = 1d; // double suffix double d2 = 1D; // double suffix // (Hex and Octal also work with long)</p>
<p>}</p>
<p>} /* Output:</p>
<p>i1: 101111</p>
<p>i2: 101111</p>
<p>i3: 1111111</p>
<p>c: 1111111111111111</p>
<p>b: 1111111</p>
<p>s: 111111111111111</p>
<p>*///:~</p>
<p>A trailing character after a literal value establishes its type. Uppercase or lowercase L means long (however, using a lowercase l is confusing because it can look like the number one). Uppercase or lowercase F means float. Uppercase or lowercase D means double.</p>
<p>Hexadecimal (base 16), which works with all the integral data types, is denoted by a leading 0x or 0X followed by 0-9 or a-f either in uppercase or lowercase. If you try to initialize a variable with a value bigger than it can hold (regardless of the numerical form of the value), the compiler will give you an error message. Notice in the preceding code the maximum possible hexadecimal values for char, byte, and short. If you exceed these, the compiler will automatically make the value an int and tell you that you need a narrowing cast for the assignment (casts are defined later in this chapter). You’ll know you’ve stepped over the line.</p>
<p>Octal (base 8) is denoted by a leading zero in the number and digits from 0-7.</p>
<p>There is no literal representation for binary numbers in C, C++, or Java. However, when working with hexadecimal and octal notation, it’s useful to display the binary form of the results. This is easily accomplished with the static toBinaryString( ) methods from the Integer and Long classes. Notice that when passing smaller types to Integer.toBinaryString( ), the type is automatically converted to an int.</p>
<p>Exercise 8: (2) Show that hex and octal notations work with long values. Use Long.toBinaryString( ) to display the results.</p>
<subtitle>Exponential notation</subtitle>
<p>Exponents use a notation that I’ve always found rather dismaying:</p>
<p>//: operators/Exponents.java // &quot;e&quot; means &quot;10 to the power.&quot;</p>
<p>public class Exponents {</p>
<p>public static void main(String[] args) {</p>
<p>// Uppercase and lowercase ‘e’ are the same: float expFloat = 1.39e-43f; expFloat = 1.39E-43f;</p>
<p>System.out.println(expFloat); double expDouble = 47e47d; // ‘d’ is optional double expDouble2 = 47e47; // Automatically double System.out.println(expDouble);</p>
<p>}</p>
<p>} /* Output:</p>
<p>1.39E-43</p>
<p>4.7E48</p>
<p>*///:~</p>
<p>In science and engineering, ‘e’ refers to the base of natural logarithms, approximately 2.718. (A more precise double value is available in Java as Math.E.) This is used in exponentiation expressions such as 1.39 x e<sup>-43</sup>, which means 1.39 x 2.718&quot;<sup>43</sup>. However, when the FORTRAN programming language was invented, they decided that e would mean “ten to the power”, which is an odd decision because FORTRAN was designed for science and engineering, and one would think its designers would be sensitive about introducing such an ambiguity.<a l:href="#bookmark16" type="note"><sup>17</sup></a><sup></sup> At any rate, this custom was followed in C, C++ and now Java. So if you’re used to thinking in terms of e as the base of natural logarithms, you must do a mental translation when you see an expression such as 1.39 e-43f in Java; it means 1.39 x 10&quot;<sup>43</sup>.</p>
<p>Note that you don’t need to use the trailing character when the compiler can figure out the appropriate type. With</p>
<p>long n3 = 200;</p>
<p>there’s no ambiguity, so an L after the 200 would be superfluous. However, with float f4 = 1e-43f; // 10 to the power</p>
<p>the compiler normally takes exponential numbers as doubles, so without the trailing f, it will give you an error telling you that you must use a cast to convert double to float.</p>
<p>Exercise 9: (1) Display the largest and smallest numbers for both float and double exponential notation.</p>
</section>
<section>
<title>
<p>Bitwise operators</p></title><empty-line/>
<p>The bitwise operators allow you to manipulate individual bits in an integral primitive data type. Bitwise operators perform Boolean algebra on the corresponding bits in the two arguments to produce the result.</p>
<p>The bitwise operators come from C’s low-level orientation, where you often manipulate hardware directly and must set the bits in hardware registers. Java was originally designed to be embedded in TV set-top boxes, so this low-level orientation still made sense. However, you probably won’t use the bitwise operators much.</p>
<p>The bitwise AND operator (&amp;) produces a one in the output bit if both input bits are one; otherwise, it produces a zero. The bitwise OR operator (|) produces a one in the output bit if either input bit is a one and produces a zero only if both input bits are zero. The bitwise EXCLUSIVE OR, or XOR (<sup>A</sup>), produces a one in the output bit if one or the other input bit is a one, but not both. The bitwise NOT (~, also called the ones complement operator) is a unary operator; it takes only one argument. (All other bitwise operators are binary operators.) Bitwise NOT produces the opposite of the input bit—a one if the input bit is zero, a zero if the input bit is one.</p>
<p>The bitwise operators and logical operators use the same characters, so it is helpful to have a mnemonic device to help you remember the meanings: Because bits are “small”, there is only one character in the bitwise operators.</p>
<p>Bitwise operators can be combined with the = sign to unite the operation and assignment: &amp;=, |= and <sup>A</sup> = are all legitimate. (Since ~ is a unary operator, it cannot be combined with the = sign.)</p>
<p>The boolean type is treated as a one-bit value, so it is somewhat different. You can perform a bitwise AND, OR, and XOR, but you can’t perform a bitwise NOT (presumably to prevent confusion with the logical NOT). For booleans, the bitwise operators have the same effect as the logical operators except that they do not short circuit. Also, bitwise operations on booleans include an XOR logical operator that is not included under the list of “logical” operators. You cannot use booleans in shift expressions, which are described next.</p>
<p>Exercise 10: (3) Write a program with two constant values, one with alternating binary ones and zeroes, with a zero in the least-significant digit, and the second, also alternating, with a one in the least-significant digit (hint: It’s easiest to use hexadecimal constants for this). Take these two values and combine them in all possible ways using the bitwise operators, and display the results using Integer.toBinaryString( ).</p>
</section>
<section>
<title>
<p>Shift operators</p></title><empty-line/>
<p>The shift operators also manipulate bits. They can be used solely with primitive, integral types. The left-shift operator (&lt;&lt;) produces the operand to the left of the operator after it has been shifted to the left by the number of bits specified to the right of the operator (inserting zeroes at the lower-order bits). The signed right-shift operator (&gt;&gt;) produces the operand to the left of the operator after it has been shifted to the right by the number of bits specified to the right of the operator. The signed right shift &gt;&gt; uses sign extension: If the value is positive, zeroes are inserted at the higher-order bits; if the value is negative, ones are inserted at the higher-order bits. Java has also added the unsigned right shift &gt;&gt;&gt;, which uses zero extension: Regardless of the sign, zeroes are inserted at the higher-order bits. This operator does not exist in C or C++.</p>
<p>If you shift a char, byte, or short, it will be promoted to int before the shift takes place, and the result will be an int. Only the five low-order bits of the right-hand side will be used. This prevents you from shifting more than the number of bits in an int. If you’re operating on a long, you’ll get a long result. Only the six low-order bits of the right-hand side will be used, so you can’t shift more than the number of bits in a long.</p>
<p>Shifts can be combined with the equal sign (&lt;&lt;= or &gt;&gt;= or &gt;&gt;&gt;=). The lvalue is replaced by the lvalue shifted by the rvalue. There is a problem, however, with the unsigned right shift combined with assignment. If you use it with byte or short, you don’t get the correct results. Instead, these are promoted to int and right shifted, but then truncated as they are assigned back into their variables, so you get -1 in those cases. The following example demonstrates this: //: operators/URShift.java</p>
<p>// Test of unsigned right shift.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class URShift {</p>
<p>public static void main(String[] args) { int i = -1;</p>
<p>print(Integer.toBinaryString(i)); i &gt;&gt;&gt;= 10;</p>
<p>print(Integer.toBinaryString(i)); long l = -1;</p>
<p>print(Long.toBinaryString(l)); l &gt;&gt;&gt;= 10;</p>
<p>print(Long.toBinaryString(l)); short s = -1;</p>
<p>print(Integer.toBinaryString(s)); s &gt;&gt;&gt;= 10;</p>
<p>print(Integer.toBinaryString(s)); byte b = -1;</p>
<p>print(Integer.toBinaryString(b)); b &gt;&gt;&gt;= 10;</p>
<p>print(Integer.toBinaryString(b)); b = -1;</p>
<p>print(Integer.toBinaryString(b));</p>
<p>print(Integer.toBinaryString(b&gt;&gt;&gt;10));</p>
<p>}</p>
<p>} /* Output:</p>
<p>11111111111111111111111111111111</p>
<p>1111111111111111111111</p>
<p>1111111111111111111111111111111111111111111111111111111111111111</p>
<p>111111111111111111111111111111111111111111111111111111</p>
<p>11111111111111111111111111111111</p>
<p>11111111111111111111111111111111</p>
<p>11111111111111111111111111111111</p>
<p>11111111111111111111111111111111</p>
<p>11111111111111111111111111111111</p>
<p>1111111111111111111111</p>
<p>*///:~</p>
<p>In the last shift, the resulting value is not assigned back into b, but is printed directly, so the correct behavior occurs.</p>
<p>Here’s an example that demonstrates the use of all the operators involving bits:</p>
<p>//: operators/BitManipulation.java // Using the bitwise operators. import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class BitManipulation {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47); int i = rand.nextInt(); int j = rand.nextInt(); printBinaryInt(&quot;-1&quot;, -1); printBinaryInt(&quot;+1&quot;, +1); int maxpos = 2147483647; printBinaryInt(&quot;maxpos&quot;, maxpos); int maxneg = -2147483648; printBinaryInt(&quot;maxneg&quot;, maxneg); printBinaryInt(&quot;i&quot;, i); printBinaryInt(&quot;~i&quot;, ~i);</p>
<p>printBinaryInt(&quot;-i&quot;, -i); printBinaryInt(&quot;j&quot;, j); printBinaryInt(&quot;i &amp; j&quot;, i &amp; j); printBinaryInt(&quot;i | j&quot;, i | j); printBinaryInt(&quot;i <sup>A</sup> j&quot;, i <sup>A</sup> j); printBinaryInt(&quot;i &lt;&lt; 5&quot;, i &lt;&lt; 5); printBinaryInt(&quot;i &gt;&gt; 5&quot;, i &gt;&gt; 5); printBinaryInt(&quot;(~i) &gt;&gt; 5&quot;, (~i) &gt;&gt; 5); printBinaryInt(&quot;i &gt;&gt;&gt; 5&quot;, i &gt;&gt;&gt; 5); printBinaryInt(&quot;(~i) &gt;&gt;&gt; 5&quot;, (~i) &gt;&gt;&gt; 5);</p>
<p>long 1 = rand.nextLong(); long m = rand.nextLong(); printBinaryLong(&quot;-1L&quot;, -1L); printBinaryLong(&quot;+1L&quot;, +1l); long 11 = 9223372036854775807L; printBinaryLong(&quot;maxpos&quot;, 11); long 11n = -9223372036854775808L; printBinaryLong(&quot;maxneg&quot;, 11n); printBinaryLong(&quot;1&quot;, 1); printBinaryLong(&quot;~1&quot;, ~1); printBinaryLong(&quot;-1&quot;, -1); printBinaryLong(&quot;m&quot;, m); printBinaryLong(&quot;1 &amp; m&quot;, 1 &amp; m); printBinaryLong(&quot;1 | m&quot;, 1 | m); printBinaryLong(&quot;1 a m&quot;, 1 a m); printBinaryLong(&quot;1 &lt;&lt; 5&quot;, 1 &lt;&lt; 5); printBinaryLong(&quot;1 &gt;&gt; 5&quot;, 1 &gt;&gt; 5); printBinaryLong(&quot;(~1) &gt;&gt; 5&quot;, (~1) &gt;&gt; 5); printBinaryLong(&quot;1 &gt;&gt;&gt; 5&quot;, 1 &gt;&gt;&gt; 5); printBinaryLong(&quot;(~1) &gt;&gt;&gt; 5&quot;, (~1) &gt;&gt;&gt; 5);</p>
<p>}</p>
<p>static void printBinaryInt(String s, int i) { print(s + &quot;, int: &quot; + i + &quot;, binary:\n &quot; + Integer.toBinaryString(i));</p>
<p>}</p>
<p>static void printBinaryLong(String s, 1ong 1) { print(s + &quot;, 1ong: &quot; + 1 + &quot;, binary:\n &quot; + Long.toBinaryString(1));</p>
<p>}</p>
<p>} /* Output:</p>
<p>-1, int: -1, binary:</p>
<p>11111111111111111111111111111111 +1, int: 1, binary:</p>
<p>1</p>
<p>maxpos, int: 2147483647, binary: 1111111111111111111111111111111 maxneg, int: -2147483648, binary: 10000000000000000000000000000000</p>
<p>i,    int: -1172028779, binary: 10111010001001000100001010010101</p>
<p>~i, int: 1172028778, binary:</p>
<p>1000101110110111011110101101010 -i, int: 1172028779, binary:</p>
<p>1000101110110111011110101101011</p>
<p>j,    int: 1717241110, binary: 1100110010110110000010100010110</p>
<p>i &amp; j, int: 570425364, binary: 100010000000000000000000010100 i | j, int: -25213033, binary:</p>
<p>11111110011111110100011110010111 i a j, int: -595638397, binary:</p>
<p>11011100011111110100011110000011</p>
<p>i &lt;&lt; 5, int: 1149784736, binary: 1000100100010000101001010100000 i &gt;&gt; 5, int: -36625900, binary:</p>
<p>11111101110100010010001000010100 (~i) &gt;&gt; 5, int: 36625899, binary: 10001011101101110111101011 i &gt;&gt;&gt; 5, int: 97591828, binary: 101110100010010001000010100 (~i) &gt;&gt;&gt; 5, int: 36625899, binary: 10001011101101110111101011</p>
<p>*///:~</p>
<p>The two methods at the end, printBinaryInt( ) and printBinaryLong( ), take an int or a long, respectively, and print it out in binary format along with a descriptive string. As well as demonstrating the effect of all the bitwise operators for int and long, this example also shows the minimum, maximum, +1, and -1 values for int and long so you can see what they look like. Note that the high bit represents the sign: o means positive and 1 means negative. The output for the int portion is displayed above.</p>
<p>The binary representation of the numbers is referred to as signed twos complement.</p>
<p>Exercise 11: (3) Start with a number that has a binary one in the most significant position (hint: Use a hexadecimal constant). Using the signed right-shift operator, right shift it all the way through all of its binary positions, each time displaying the result using Integer.toBinaryString( ).</p>
<p>Exercise 12: (3) Start with a number that is all binary ones. Left shift it, then use the unsigned right-shift operator to right shift through all of its binary positions, each time displaying the result using Integer.toBinaryString( ).</p>
<p>Exercise 13: (1) Write a method that displays char values in binary form. Demonstrate it using several different characters.</p>
</section>
<section>
<title>
<p>Ternary if-else operator</p></title><empty-line/>
<p>The ternary operator, also called the conditional operator, is unusual because it has three operands. It is truly an operator because it produces a value, unlike the ordinary if-else statement that you’ll see in the next section of this chapter. The expression is of the form:</p>
<p>boolean-exp ? value0 : value1</p>
<p>If boolean-exp evaluates to true, value0 is evaluated, and its result becomes the value produced by the operator. If boolean-exp is false, value1 is evaluated and its result becomes the value produced by the operator.</p>
<p>Of course, you could use an ordinary if-else statement (described later), but the ternary operator is much terser. Although C (where this operator originated) prides itself on being a terse language, and the ternary operator might have been introduced partly for efficiency, you should be somewhat wary of using it on an everyday basis—it’s easy to produce unreadable code.</p>
<p>The conditional operator is different from if-else because it produces a value. Here’s an example comparing the two:</p>
<p>//: operators/TernaryIfElse.java import static net.mindview.util.Print.*;</p>
<p>public class TernarylfElse {</p>
<p>static int ternary(int i) {</p>
<p>return i &lt; 10 ? i * 100 : i * 10;</p>
<p>}</p>
<p>static int standardIfElse(int i) { if(i &lt; 10)</p>
<p>return i * 100; else</p>
<p>return i * 10;</p>
<p>}</p>
<p>public static void main(String[] args) { print(ternary(9)); print(ternary(10)); print(standardIfElse(9)); print(standardIfElse(10));</p>
<p>}</p>
<p>} /* Output:</p>
<p>900</p>
<p>100</p>
<p>900</p>
<p>100</p>
<p>*///:~</p>
<p>You can see that this code in ternary( ) is more compact than what you’d need to write without the ternary operator, in standardIfElse( ). However, standardIfElse( ) is easier to understand, and doesn’t require a lot more typing. So be sure to ponder your reasons when choosing the ternary operator—it’s generally warranted when you’re setting a variable to one of two values.</p>
</section>
<section>
<title>
<p>String operator + and + =</p></title><empty-line/>
<p>There’s one special usage of an operator in Java: The + and += operators can be used to concatenate strings, as you’ve already seen. It seems a natural use of these operators even though it doesn’t fit with the traditional way that they are used.</p>
<p>This capability seemed like a good idea in C++, so operator overloading was added to C++ to allow the C++ programmer to add meanings to almost any operator. Unfortunately, operator overloading combined with some of the other restrictions in C++ turns out to be a fairly complicated feature for programmers to design into their classes. Although operator overloading would have been much simpler to implement in Java than it was in C++ (as has been demonstrated in the C# language, which does have straightforward operator overloading), this feature was still considered too complex, so Java programmers cannot implement their own overloaded operators like C++ and C# programmers can.</p>
<p>The use of the String operators has some interesting behavior. If an expression begins with a String, then all operands that follow must be Strings (remember that the compiler automatically turns a double-quoted sequence of characters into a String):</p>
<p>//: operators/StringOperators.java import static net.mindview.util.Print.*;</p>
<p>public class StringOperators {</p>
<p>public static void main(String[] args) { int x = 0, y = 1, z = 2;</p>
<p>String s = &quot;x, y, z &quot;; print(s + x + y + z);</p>
<p>print(x + &quot; &quot; + s); // Converts x to a String</p>
<p>= &quot;; // Concatenation operator y + z));</p>
<p>s += &quot;(summed) print(s + (x + print(&quot;&quot; + x);</p>
<p>// Shorthand for Integer.toString()</p>
<table>
<tr><td>} /*</td><td colspan="2">Output:</td><td rowspan="6">3</td></tr>
<tr><td>x, y,</td><td>z</td><td>012</td></tr>
<tr><td>0 x,</td><td>y,</td><td>z</td></tr>
<tr><td>x, y,</td><td>z</td><td>(summed)</td></tr>
<tr><td>0</td><td></td><td></td></tr>
<tr><td>*///:</td><td>~</td><td></td></tr>
</table>
<p>Note that the output from the first print statement is ‘012’ instead of just ‘3’, which is what you’d get if it was summing the integers. This is because the Java compiler converts x, y, and z into their String representations and concatenates those strings, instead of adding them together first. The second print statement converts the leading variable into a String, so the string conversion does not depend on what comes first. Finally, you see the use of the += operator to append a string to s, and the use of parentheses to control the order of evaluation of the expression so that the ints are actually summed before they are displayed.</p>
<p>Notice the last example in main( ): you will sometimes see an empty String followed by a + and a primitive as a way to perform the conversion without calling the more cumbersome explicit method (Integer.toString( ), in this case).</p>
</section>
<section>
<title>
<p>Common pitfalls when using operators</p></title><empty-line/>
<p>One of the pitfalls when using operators is attempting to leave out the parentheses when you are even the least bit uncertain about how an expression will evaluate. This is still true in Java.</p>
<p>An extremely common error in C and C++ looks like this:</p>
<p>while(x = y) {</p>
<p>// ____</p>
<p>}</p>
<p>The programmer was clearly trying to test for equivalence (==) rather than do an assignment. In C and C++ the result of this assignment will always be true if y is nonzero, and you’ll probably get an infinite loop. In Java, the result of this expression is not a boolean, but the compiler expects a boolean and won’t convert from an int, so it will conveniently give you a compile-time error and catch the problem before you ever try to run the program. So the pitfall never happens in Java. (The only time you won’t get a compiletime error is when x and y are boolean, in which case x = y is a legal expression, and in the preceding example, probably an error.)</p>
<p>A similar problem in C and C++ is using bitwise AND and OR instead of the logical versions. Bitwise AND and OR use one of the characters (&amp; or |) while logical AND and OR use two (&amp;&amp; and ||). Just as with = and ==, it’s easy to type just one character instead of two. In Java, the compiler again prevents this, because it won’t let you cavalierly use one type where it doesn’t belong.</p>
</section>
<section>
<title>
<p>Casting operators</p></title><empty-line/>
<p>The word cast is used in the sense of “casting into a mold.” Java will automatically change one type of data into another when appropriate. For instance, if you assign an integral value to a floating point variable, the compiler will automatically convert the int to a float. Casting</p>
<p>allows you to make this type conversion explicit, or to force it when it wouldn’t normally happen.</p>
<p>To perform a cast, put the desired data type inside parentheses to the left of any value. You can see this in the following example:</p>
<p>//: operators/Casting.java</p>
<p>public class Casting {</p>
<p>public static void main(String[] args) { int i = 200; long Ing = (long)i;</p>
<p>Ing = i; // &quot;Widening,&quot; so cast not really required long lng2 = (long)200; lng2 = 200;</p>
<p>// A &quot;narrowing conversion&quot;: i = (int)lng2; // Cast required</p>
<p>}</p>
<p>} ///:~</p>
<p>As you can see, it’s possible to perform a cast on a numeric value as well as on a variable. Notice that you can introduce superfluous casts; for example, the compiler will automatically promote an int value to a long when necessary. However, you are allowed to use superfluous casts to make a point or to clarify your code. In other situations, a cast may be essential just to get the code to compile.</p>
<p>In C and C++, casting can cause some headaches. In Java, casting is safe, with the exception that when you perform a so-called narrowing conversion (that is, when you go from a data type that can hold more information to one that doesn’t hold as much), you run the risk of losing information. Here the compiler forces you to use a cast, in effect saying, “This can be a dangerous thing to do—if you want me to do it anyway you must make the cast explicit.” With a widening conversion an explicit cast is not needed, because the new type will more than hold the information from the old type so that no information is ever lost.</p>
<p>Java allows you to cast any primitive type to any other primitive type, except for boolean, which doesn’t allow any casting at all. Class types do not allow casting. To convert one to the other, there must be special methods. (You’ll find out later in this book that objects can be cast within a family of types; an Oak can be cast to a Tree and vice versa, but not to a foreign type such as a Rock.)</p>
<subtitle>Truncation and rounding</subtitle>
<p>When you are performing narrowing conversions, you must pay attention to issues of truncation and rounding. For example, if you cast from a floating point value to an integral value, what does Java do? For example, if you have the value 29.7 and you cast it to an int, is the resulting value 30 or 29? The answer to this can be seen in this example:</p>
<p>//: operators/CastingNumbers.java // What happens when you cast a float // or double to an integral value? import static net.mindview.util.Print.*;</p>
<p>public class CastingNumbers {</p>
<p>public static void main(String[] args) { double above = 0.7, below = 0.4; float fabove = 0.7f, fbelow = 0.4f; print(&quot;(int)above: &quot; + (int)above); print(&quot;(int)below: &quot; + (int)below); print(&quot;(int)fabove: &quot; + (int)fabove);</p>
<p>}</p>
<p>} /* Output: (int)above: 0 (int)below: 0 (int)fabove: 0 (int)fbelow: 0 *///:~</p>
<p>So the answer is that casting from a float or double to an integral value always truncates the number. If instead you want the result to be rounded, use the round( ) methods in java.lang.Math:</p>
<p>//: operators/RoundingNumbers.java // Rounding floats and doubles. import static net.mindview.util.Print.*;</p>
<p>public class RoundingNumbers {</p>
<p>public static void main(String[] args) { double above = 0.7, below = 0.4; float fabove = 0.7f, fbelow = 0.4f; print(&quot;Math.round(above): &quot; + Math.round(above)); print(&quot;Math.round(below): &quot; + Math.round(below)); print(&quot;Math.round(fabove): &quot; + Math.round(fabove)); print(&quot;Math.round(fbelow): &quot; + Math.round(fbelow));</p>
<p>}</p>
<p>} /* Output:</p>
<p>Math.round(above): 1 Math.round(below): 0 Math.round(fabove): 1 Math.round(fbelow): 0 *///:~</p>
<p>Since the round( ) is part of java.lang, you don’t need an extra import to use it.</p>
<subtitle>Promotion</subtitle>
<p>You’ll discover that if you perform any mathematical or bitwise operations on primitive data types that are smaller than an int (that is, char, byte, or short), those values will be promoted to int before performing the operations, and the resulting value will be of type int. So if you want to assign back into the smaller type, you must use a cast. (And, since you’re assigning back into a smaller type, you might be losing information.) In general, the largest data type in an expression is the one that determines the size of the result of that expression; if you multiply a float and a double, the result will be double; if you add an int and a long, the result will be long.</p>
</section>
<section>
<title>
<p>Java has no &quot;sizeof&quot;</p></title><empty-line/>
<p>In C and C++, the sizeof( ) operator tells you the number of bytes allocated for data items. The most compelling reason for sizeof( ) in C and C++ is for portability. Different data types might be different sizes on different machines, so the programmer must discover how big those types are when performing operations that are sensitive to size. For example, one computer might store integers in 32 bits, whereas another might store integers as 16 bits. Programs could store larger values in integers on the first machine. As you might imagine, portability is a huge headache for C and C++ programmers.</p>
<p>Java does not need a sizeof( ) operator for this purpose, because all the data types are the same size on all machines. You do not need to think about portability on this level—it is designed into the language.</p>
</section>
<section>
<title>
<p>A compendium of operators</p></title><empty-line/>
<p>The following example shows which primitive data types can be used with particular operators. Basically, it is the same example repeated over and over, but using different primitive data types. The file will compile without error because the lines that fail are commented out with a //!.</p>
<p>//: operators/AHOps.java</p>
<p>// Tests all the operators on all the primitive data types // to show which ones are accepted by the Java compiler.</p>
<p>public class AllOps {</p>
<p>// To accept the results of a boolean test:</p>
<p>void f(boolean b) {}</p>
<p>void boolTest(boolean x, boolean y) {</p>
<p>// Arithmetic operators:</p>
<p>//! x = x * y;</p>
<p>//! x = x / y;</p>
<p>//! x = x % y;</p>
<p>//! x = x + y;</p>
<p>//! x = x - y;</p>
<p>//! x++;</p>
<p>//! x--;</p>
<p>//!    x    =    +y;</p>
<p>//!    x    =    -y;</p>
<p>// Relational and logical:</p>
<p>//! f(x &gt; y);</p>
<p>//! f(x &gt;= y);</p>
<p>//! f(x &lt; y);</p>
<p>//! f(x &lt;= y); f(x == y); f(x != y); f(!y);</p>
<p>x = x &amp;&amp; y; x = x || y;</p>
<p>// Bitwise operators:</p>
<p>//! x = x &gt;&gt;&gt; 1;</p>
<p>// Compound assignment:</p>
<p>//! x += y;</p>
<p>//! x -= y;</p>
<p>//! x *= y;</p>
<p>//! x /= y;</p>
<p>//! x %= y;</p>
<p>//! x &lt;&lt;= 1;</p>
<p>//! x &gt;&gt;= 1;</p>
<p>//! x &gt;&gt;&gt;= 1; x &amp;= y; x a= y;</p>
<p>x |= y;</p>
<p>// Casting:</p>
<p>//! char c = (char)x;</p>
<p>//! byte b = (byte)x;</p>
<p>//! short s = (short)x;</p>
<p>//! int i = (int)x;</p>
<p>//! long 1 = (long)x;</p>
<p>//! float f = (float)x;</p>
<p>//! double d = (double)x;</p>
<p>}</p>
<p>void charTest(char x, char y) { // Arithmetic operators: x = (char)(x * y); x = (char)(x / y); x = (char)(x % y); x = (char)(x + y); x = (char)(x - y); x++; x--;</p>
<p>x = (char)+y; x = (char)-y;</p>
<p>// Relational and logical:</p>
<p>f(x &gt; y);</p>
<p>f(x &gt;= y);</p>
<p>f(x &lt; y);</p>
<p>f(x &lt;= y);</p>
<p>f(x == y);</p>
<p>f(x != y);</p>
<p>//! f(!x);</p>
<p>//! f(x &amp;&amp; y);</p>
<p>//! f(x || y);</p>
<p>// Bitwise operators: x= (char)~y; x = (char)(x &amp; y); x = (char)(x | y); x = (char)(x <sup>A</sup> y); x = (char)(x &lt;&lt; 1); x = (char)(x &gt;&gt; l); x = (char)(x &gt;&gt;&gt; 1);</p>
<p>// Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y; x &lt;&lt;= 1; x &gt;&gt;= 1; x &gt;&gt;&gt;= 1; x &amp;= y; x a= y;</p>
<p>x |= y;</p>
<p>// Casting:</p>
<p>//! boolean bl = (boolean)x;</p>
<p>byte b = (byte)x;</p>
<p>short s = (short)x;</p>
<p>int i = (int)x;</p>
<p>long l = (long)x;</p>
<p>float f = (float)x;</p>
<p>double d = (double)x;</p>
<p>}</p>
<p>void byteTest(byte x, byte y) { // Arithmetic operators: x = (byte)(x* y); x = (byte)(x / y); x = (byte)(x % y);</p>
<p>x = (byte)(x + y); x = (byte)(x - y); x++; x--;</p>
<p>x = (byte)+ y; x = (byte)- y;</p>
<p>// Relational and logical:</p>
<p>f(x &gt; y);</p>
<p>f(x &gt;= y);</p>
<p>f(x &lt; y);</p>
<p>f(x &lt;= y);</p>
<p>f(x == y);</p>
<p>f(x != y);</p>
<p>//! f(!x);</p>
<p>//! f(x &amp;&amp; y);</p>
<p>//! f(x || y);</p>
<p>// Bitwise operators: x = (byte)~y; x = (byte)(x &amp; y); x = (byte)(x | y); x = (byte)(x <sup>A</sup> y); x = (byte)(x &lt;&lt; 1); x = (byte)(x &gt;&gt; 1); x = (byte)(x &gt;&gt;&gt; 1);</p>
<p>// Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y; x &lt;&lt;= 1; x &gt;&gt;= 1; x &gt;&gt;&gt;= 1; x &amp;= y; x a= y;</p>
<p>x |= y;</p>
<p>// Casting:</p>
<p>//! boolean bl = (boolean)x;</p>
<p>char c = (char)x;</p>
<p>short s = (short)x;</p>
<p>int i = (int)x;</p>
<p>long l = (long)x;</p>
<p>float f = (float)x;</p>
<p>double d = (double)x;</p>
<p>}</p>
<p>void shortTest(short x, short y) { // Arithmetic operators: x = (short)(x * y); x = (short)(x / y); x = (short)(x % y); x = (short)(x + y); x = (short)(x - y); x++; x--;</p>
<p>x = (short)+y; x = (short)-y;</p>
<p>// Relational and logical:</p>
<p>f(x &gt; y);</p>
<p>f(x &gt;= y);</p>
<p>f(x &lt; y);</p>
<p>f(x &lt;= y);</p>
<p>f(x == y);</p>
<p>f(x != y);</p>
<p>//! f(!x);</p>
<p>//! f(x &amp;&amp; y);</p>
<p>//! f(x || y);</p>
<p>// Bitwise operators: x = (short)~y; x = (short)(x &amp; y); x = (short)(x | y); x = (short)(x <sup>A</sup> y); x = (short)(x &lt;&lt; 1); x = (short)(x &gt;&gt; l); x = (short)(x &gt;&gt;&gt; 1);</p>
<p>// Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y; x &lt;&lt;= 1; x &gt;&gt;= 1; x &gt;&gt;&gt;= 1; x &amp;= y; x a= y;</p>
<p>x |= y;</p>
<p>// Casting:</p>
<p>//! boolean bl = (boolean)x;</p>
<p>char c = (char)x;</p>
<p>byte b = (byte)x;</p>
<p>int i = (int)x;</p>
<p>long l = (long)x;</p>
<p>float f = (float)x;</p>
<p>double d = (double)x;</p>
<p>}</p>
<p>void intTest(int x, int y) {</p>
<p>// Arithmetic operators: x = x * y; x = x / y; x = x % y; x = x + y; x = x - y; x++; x--; x = +y; x = -y;</p>
<p>// Relational and logical:</p>
<p>f(x &gt; y);</p>
<p>f(x &gt;= y);</p>
<p>f(x &lt; y);</p>
<p>f(x &lt;= y);</p>
<p>f(x == y);</p>
<p>f(x != y);</p>
<p>//! f(!x);</p>
<p>//! f(x &amp;&amp; y);</p>
<p>//! f(x || y);</p>
<p>// Bitwise operators: x = ~y; x = x &amp; y; x = x | y; x = x A y; x = x &lt;&lt; 1; x = x &gt;&gt; 1; x = x &gt;&gt;&gt; 1;</p>
<p>// Compound assignment: x += y;</p>
<p>x -= y; x *= y; x /= y; x %= y; x &lt;&lt;= 1; x &gt;&gt;= 1; x &gt;&gt;&gt;= 1; x &amp;= y; x <sup>A</sup>= y; x |= y;</p>
<p>// Casting:</p>
<p>//! boolean bl = (boolean)x;</p>
<p>char c = (char)x;</p>
<p>byte b = (byte)x;</p>
<p>short s = (short)x;</p>
<p>long l = (long)x;</p>
<p>float f = (float)x;</p>
<p>double d = (double)x;</p>
<p>}</p>
<p>void longTest(long x, long y) { // Arithmetic operators: x = x * y; x = x / y; x = x % y; x = x + y; x = x - y; x++; x--; x = +y; x = -y;</p>
<p>// Relational and logical:</p>
<p>f(x &gt; y);</p>
<p>f(x &gt;= y);</p>
<p>f(x &lt; y);</p>
<p>f(x &lt;= y);</p>
<p>f(x == y);</p>
<p>f(x != y);</p>
<p>//! f(!x);</p>
<p>//! f(x &amp;&amp; y);</p>
<p>//! f(x || y);</p>
<p>// Bitwise operators: x = ~y; x = x &amp; y; x = x | y; x = x A y; x = x &lt;&lt; 1; x = x &gt;&gt; 1; x = x &gt;&gt;&gt; 1;</p>
<p>// Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y; x &lt;&lt;= 1; x &gt;&gt;= 1; x &gt;&gt;&gt;= 1; x &amp;= y; x a= y;</p>
<p>x |= y;</p>
<p>// Casting:</p>
<p>//! boolean bl = (boolean)x; char c = (char)x;</p>
<p>byte b = (byte)x; short s = (short)x; int i = (int)x; float f = (float)x; double d = (double)x;</p>
<p>}</p>
<p>void floatTest(float x, float y) {</p>
<p>// Arithmetic operators:</p>
<p>x = x * y;</p>
<p>x = x / y;</p>
<p>x = x % y;</p>
<p>x = x + y;</p>
<p>x = x - y;</p>
<p>x++;</p>
<p>x--;</p>
<p>x = +y;</p>
<p>x = -y;</p>
<p>// Relational and logical:</p>
<p>f(x &gt; y);</p>
<p>f(x &gt;= y);</p>
<p>f(x &lt; y);</p>
<p>f(x &lt;= y);</p>
<p>f(x == y);</p>
<p>f(x != y);</p>
<p>//! f(!x);</p>
<p>//! f(x &amp;&amp; y);</p>
<p>//! f(x || y);</p>
<p>// Bitwise operators:</p>
<p>//! x = ~y;</p>
<p>//! x = x &amp; y;</p>
<p>//! x = x | y;</p>
<p>//! x = x <sup>A</sup> y;</p>
<p>//! x = x &lt;&lt; 1;</p>
<p>//! x = x &gt;&gt; 1;</p>
<p>//! x = x &gt;&gt;&gt; 1;</p>
<p>// Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y;</p>
<p>//! x &lt;&lt;= 1;</p>
<p>//! x &gt;&gt;= 1;</p>
<p>//! x &gt;&gt;&gt;= 1;</p>
<p>//! x &amp;= y;</p>
<p>//! x a= y;</p>
<p>//! x |= y;</p>
<p>// Casting:</p>
<p>//! boolean bl = (boolean)x;</p>
<p>char c = (char)x;</p>
<p>byte b = (byte)x;</p>
<p>short s = (short)x;</p>
<p>int i = (int)x;</p>
<p>long l = (long)x;</p>
<p>double d = (double)x;</p>
<p>}</p>
<p>void doubleTest(double x, double y) { // Arithmetic operators: x = x * y; x = x / y; x = x % y; x = x + y; x = x - y;</p>
<p>x++; x--; x = +y; x = -y;</p>
<p>// Relational and logical:</p>
<p>f(x &gt; y);</p>
<p>f(x &gt;= y);</p>
<p>f(x &lt; y);</p>
<p>f(x &lt;= y);</p>
<p>f(x == y);</p>
<p>f(x != y);</p>
<p>//! f(!x);</p>
<p>//! f(x &amp;&amp; y);</p>
<p>//! f(x || y);</p>
<p>// Bitwise operators:</p>
<p>//! x = x &lt;&lt; 1;</p>
<p>//! x = x &gt;&gt; 1;</p>
<p>//! x = x &gt;&gt;&gt; 1;</p>
<p>// Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y;</p>
<p>//! x &lt;&lt;= 1;</p>
<p>//! x &gt;&gt;= 1;</p>
<p>//! x &gt;&gt;&gt;= 1;</p>
<p>//! x &amp;= y;</p>
<p>//! x a= y;</p>
<p>//! x |= y;</p>
<p>// Casting:</p>
<p>//! boolean bl = (boolean)x;</p>
<p>char c = (char)x;</p>
<p>byte b = (byte)x;</p>
<p>short s = (short)x;</p>
<p>int i = (int)x;</p>
<p>long l = (long)x;</p>
<p>float f = (float)x;</p>
<p>}</p>
<p>} ///:~</p>
<p>Note that boolean is quite limited. You can assign to it the values true and false, and you can test it for truth or falsehood, but you cannot add booleans or perform any other type of operation on them.</p>
<p>In char, byte, and short, you can see the effect of promotion with the arithmetic operators. Each arithmetic operation on any of those types produces an int result, which must be explicitly cast back to the original type (a narrowing conversion that might lose information) to assign back to that type. With int values, however, you do not need to cast, because everything is already an int. Don’t be lulled into thinking everything is safe, though. If you multiply two ints that are big enough, you’ll overflow the result. The following example demonstrates this:</p>
<p>//: operators/Overflow.java // Surprise! Java lets you overflow.</p>
<p>public class Overflow {</p>
<p>public static void main(String[] args) {</p>
<p>int big = Integer.MAX_VALUE; System.out.println(&quot;big = &quot; + big); int bigger = big * 4;</p>
<p>System.out.println(&quot;bigger = &quot; + bigger);</p>
<p>}</p>
<p>} /* Output: big = 2147483647 bigger = -4 *///:~</p>
<p>You get no errors or warnings from the compiler, and no exceptions at run time. Java is good, but it’s not that good.</p>
<p>Compound assignments do not require casts for char, byte, or short, even though they are performing promotions that have the same results as the direct arithmetic operations. On the other hand, the lack of the cast certainly simplifies the code.</p>
<p>You can see that, with the exception of boolean, any primitive type can be cast to any other primitive type. Again, you must be aware of the effect of a narrowing conversion when casting to a smaller type; otherwise, you might unknowingly lose information during the cast.</p>
<p>Exercise 14: (3) Write a method that takes two String arguments and uses all the boolean comparisons to compare the two Strings and print the results. For the == and !=, also perform the equals( ) test. In main( ), call your method with some different String objects.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>If you’ve had experience with any languages that use C-like syntax, you can see that the operators in Java are so similar that there is virtually no learning curve. If you found this chapter challenging, make sure you view the multimedia presentation Thinking in C, available at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Controlling Execution</p></title><empty-line/>
<p>Like a sentient creature, a program must manipulate its world and make choices during execution. In Java you make choices with execution control statements.</p>
<p>Java uses all of C’s execution control statements, so if you’ve programmed with C or C++, then most of what you see will be familiar. Most procedural programming languages have some kind of control statements, and there is often overlap among languages. In Java, the keywords include if-else, while, do-while, for, return, break, and a selection statement called switch. Java does not, however, support the much-maligned goto (which can still be the most expedient way to solve certain types of problems). You can still do a goto-like jump, but it is much more constrained than a typical goto.</p>
<p>true and false</p>
<p>All conditional statements use the truth or falsehood of a conditional expression to determine the execution path. An example of a conditional expression is a == b. This uses the conditional operator == to see if the value of a is equivalent to the value of b. The expression returns true or false. Any of the relational operators you’ve seen in the previous chapter can be used to produce a conditional statement. Note that Java doesn’t allow you to use a number as a boolean, even though it’s allowed in C and C++ (where truth is nonzero and falsehood is zero). If you want to use a non-boolean in a boolean test, such as if(a), you must first convert it to a boolean value by using a conditional expression, such as if(a != 0).</p>
<p>if-else</p>
<p>The if-else statement is the most basic way to control program flow. The else is optional, so you can use if in two forms:</p>
<p>if(Boolean-expression)</p>
<p>statement</p>
<p>or</p>
<p>if(Boolean-expression)</p>
<p>statement</p>
<p>else</p>
<p>statement</p>
<p>The Boolean-expression must produce a boolean result. The statement is either a simple statement terminated by a semicolon, or a compound statement, which is a group of simple statements enclosed in braces. Whenever the word “statement’ is used, it always implies that the statement can be simple or compound.</p>
<p>As an example of if-else, here is a test( ) method that will tell you whether a guess is above, below, or equivalent to a target number:</p>
<p>//: control/IfElse.java</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class IfElse {</p>
<p>static int result = 0;</p>
<p>static void test(int testval, int target) { if(testval &gt; target) result = +1;</p>
<p>else if(testval &lt; target) result = -1; else</p>
<p>result = 0; // Match</p>
<p>}</p>
<p>public static void main(String[] args) { test(10, 5); print(result); test(5, 10); print(result); test(5, 5); print(result);</p>
<p>}</p>
<p>} /* Output:</p>
<p>1</p>
<p>-1</p>
<p>0</p>
<p>*///:~</p>
<p>In the middle of test( ), you’ll also see an “else if,” which is not a new keyword but just an else followed by a new if statement.</p>
<p>Although Java, like C and C++ before it, is a “free-form” language, it is conventional to indent the body of a control flow statement so the reader can easily determine where it begins and ends.</p>
<section>
<title>
<p>Iteration</p></title><empty-line/>
<p>Looping is controlled by while, do-while and for, which are sometimes classified as iteration statements. A statement repeats until the controlling Boolean-expression evaluates to false. The form for a while loop is:</p>
<p>while(Boolean-expression)</p>
<p>statement</p>
<p>The Boolean-expression is evaluated once at the beginning of the loop and again before each further iteration of the statement.</p>
<p>Here’s a simple example that generates random numbers until a particular condition is met:</p>
<p>//: control/WhileTest.java // Demonstrates the while loop.</p>
<p>public class WhileTest {</p>
<p>static boolean condition() {</p>
<p>boolean result = Math.random() &lt; 0.99;</p>
<p>System.out.print(result + &quot;, &quot;); return result;</p>
<p>}</p>
<p>public static void main(String[] args) { while(condition())</p>
<p>System.out.println(&quot;Inside ‘while’&quot;);</p>
<p>System.out.println(&quot;Exited ‘while’&quot;);</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>The condition( ) method uses the static method random( ) in the Math library, which generates a double value between 0 and 1. (It includes 0, but not 1.) The result value comes from the comparison operator &lt;, which produces a boolean result. If you print a boolean value, you automatically get the appropriate string “true” or “false.” The conditional expression for the while says: “repeat the statements in the body as long as condition( ) returns true.”</p>
<p>do-while</p>
<p>The form for do-while is do</p>
<p>statement</p>
<p>while(Boolean-expression);</p>
<p>The sole difference between while and do-while is that the statement of the do-while always executes at least once, even if the expression evaluates to false the first time. In a while, if the conditional is false the first time the statement never executes. In practice, do-while is less common than while.</p>
<p>for</p>
<p>A for loop is perhaps the most commonly used form of iteration. This loop performs initialization before the first iteration. Then it performs conditional testing and, at the end of each iteration, some form of “stepping.” The form of the for loop is:</p>
<p>for(initialization; Boolean-expression; step) statement</p>
<p>Any of the expressions initialization, Boolean-expression or step can be empty. The expression is tested before each iteration, and as soon as it evaluates to false, execution will continue at the line following the for statement. At the end of each loop, the step executes.</p>
<p>for loops are usually used for “counting” tasks:</p>
<p>//: control/ListCharacters.java // Demonstrates &quot;for&quot; loop by listing // all the lowercase ASCII letters.</p>
<p>public class ListCharacters {</p>
<p>public static void main(String[] args) { for(char c = 0; c &lt; 128; c++) if(Character.isLowerCase(c))</p>
<p>System.out.println(&quot;value: &quot; + (int)c +</p>
<p>&quot; character: &quot; + c);</p>
<p>}</p>
<p>} /* Output: value: 97 character: a value: 98 character: b value: 99 character: c value: 100 character: d value: 101 character: e value: 102 character: f value: 103 character: g value: 104 character: h value: 105 character: i value: 106 character: j</p>
<p>Note that the variable c is defined at the point where it is used, inside the control expression of the for loop, rather than at the beginning of main( ). The scope of c is the statement controlled by the for.</p>
<p>This program also uses the java.lang.Character “wrapper” class, which not only wraps the primitive char type in an object, but also provides other utilities. Here, the static isLowerCase( ) method is used to detect whether the character in question is a lowercase letter.</p>
<p>Traditional procedural languages like C require that all variables be defined at the beginning of a block so that when the compiler creates a block, it can allocate space for those variables. In Java and C++, you can spread your variable declarations throughout the block, defining them at the point that you need them. This allows a more natural coding style and makes code easier to understand.</p>
<p>Exercise 1: (1) Write a program that prints values from 1 to 100.</p>
<p>Exercise 2: (2) Write a program that generates 25 random int values. For each value, use an if-else statement to classify it as greater than, less than, or equal to a second randomly generated value.</p>
<p>Exercise 3: (1) Modify Exercise 2 so that your code is surrounded by an “infinite” while loop. It will then run until you interrupt it from the keyboard (typically by pressing Control-C).</p>
<p>Exercise 4: (3) Write a program that uses two nested for loops and the modulus operator (%) to detect and print prime numbers (integral numbers that are not evenly divisible by any other numbers except for themselves and 1).</p>
<p>Exercise 5: (4) Repeat Exercise 10 from the previous chapter, using the ternary operator and a bitwise test to display the ones and zeroes, instead of Integer.toBinaryString( ).</p>
<subtitle>The comma operator</subtitle>
<p>Earlier in this chapter I stated that the comma operator (not the comma separator, which is used to separate definitions and method arguments) has only one use in Java: in the control expression of a for loop. In both the initialization and step portions of the control expression, you can have a number of statements separated by commas, and those statements will be evaluated sequentially.</p>
<p>Using the comma operator, you can define multiple variables within a for statement, but they must be of the same type:</p>
<p>//: control/CommaOperator.java</p>
<p>public class CommaOperator {</p>
<p>public static void main(String[] args) {</p>
<p>for(int i = 1, j = i + 10; i &lt; 5; i++, j = i * 2) { System.out.println(&quot;i = &quot; + i + &quot; j = &quot; + j);</p>
<p>}</p>
<p>}</p>
<p>} /* Output: i = 1 j = 11 i = 2 j = 4 i = 3 j = 6 i = 4 j = 8 *///:~</p>
<p>The int definition in the for statement covers both i and j. The initialization portion can have any number of definitions of one type. The ability to define variables in a control expression is limited to the for loop. You cannot use this approach with any of the other selection or iteration statements.</p>
<p>You can see that in both the initialization and step portions, the statements are evaluated in sequential order.</p>
</section>
<section>
<title>
<p>Foreach syntax</p></title><empty-line/>
<p>Java SE5 introduces a new and more succinct for syntax, for use with arrays and containers (you’ll learn more about these in the Arrays and Containers in Depth chapter). This is often called the foreach syntax, and it means that you don’t have to create an int to count through a sequence of items—the foreach produces each item for you, automatically.</p>
<p>For example, suppose you have an array of float and you’d like to select each element in that array:</p>
<p>//: control/ForEachFloat.java import java.util.*;</p>
<p>public class ForEachFloat {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47); float f[] = new float[10]; for(int i = 0; i &lt; 10; i++) f[i] = rand.nextFloat(); for(float x : f)</p>
<p>System.out.println(x);</p>
<p>}</p>
<p>} /* Output:</p>
<p>0.72711575</p>
<p>0.39982635</p>
<p>0.5309454</p>
<p>0.0534122</p>
<p>0.16020656</p>
<p>0.57799757</p>
<p>0.18847865</p>
<p>0.4170137</p>
<p>0.51660204</p>
<p>0.73734957</p>
<p>*///:~</p>
<p>The array is populated using the old for loop, because it must be accessed with an index. You can see the foreach syntax in the line:</p>
<p>for(float x : f) {</p>
<p>This defines a variable x of type float and sequentially assigns each element of f to x.</p>
<p>Any method that returns an array is a candidate for use with foreach. For example, the String class has a method toCharArray( ) that returns an array of char, so you can easily iterate through the characters in a string: //: control/ForEachString.java</p>
<p>public class ForEachString {</p>
<p>public static void main(String[] args) {</p>
<p>for(char c : &quot;An African Swallow&quot;.toCharArray() ) System.out.print(c + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>A n A f r i c a n S w a l l o w *///:~</p>
<p>As you’ll see in the Holding Your Objects chapter, foreach will also work with any object that is Iterable.</p>
<p>Many for statements involve stepping through a sequence of integral values, like this: for(int i = 0; i &lt; 100; i++)</p>
<p>For these, the foreach syntax won’t work unless you want to create an array of int first. To simplify this task, I’ve created a method called range( ) in net.mindview.util.Range that automatically generates the appropriate array. My intent is for range( ) to be used as a static import: //: control/ForEachlnt.java</p>
<p>import static net.mindview.util.Range.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Fo public static for(int i : printnb(i print(); for(int i : printnb(i print(); for(int i : printnb(i print();</p>
<p>rEachInt {</p>
<p>void main(String[] args) { range(10)) // 0..9 + &quot; &quot;);</p>
<p>range(5, 10)) // 5..9 + &quot; &quot;);</p>
<p>range(5, 20, 3)) // 5..20 step 3 + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>0 1 2 3 4 5 6 7 8 9 5 6 7 8 9 5 8 11 14 17</p>
<p>*///:~</p>
<p>The range( ) method has been overloaded, which means the same method name can be used with different argument lists (you’ll learn about overloading soon). The first overloaded form of range( ) just starts at zero and produces values up to but not including the top end of the range. The second form starts at the first value and goes until one less than the second, and the third form has a step value so it increases by that value. range( ) is a very simple version of what’s called a generator, which you’ll see later in the book.</p>
<p>Note that although range( ) allows the use of the foreach syntax in more places, and thus arguably increases readability, it is a little less efficient, so if you are tuning for performance you may want to use a profiler, which is a tool that measures the performance of your code.</p>
<p>You’ll note the use of printnb( ) in addition to print( ). The printnb( ) method does not emit a newline, so it allows you to output a line in pieces.</p>
<p>The foreach syntax not only saves time when typing in code. More importantly, it is far easier to read and says what you are trying to do (get each element of the array) rather than giving the details of how you are doing it (“I’m creating this index so I can use it to select each of the array elements.”). The foreach syntax will be used whenever possible in this book.</p>
<p>return</p>
<p>Several keywords represent unconditional branching, which simply means that the branch happens without any test. These include return, break, continue, and a way to jump to a labeled statement which is similar to the goto in other languages.</p>
<p>The return keyword has two purposes: It specifies what value a method will return (if it doesn’t have a void return value) and it causes the current method to exit, returning that value. The preceding test( ) method can be rewritten to take advantage of this:</p>
<p>//: control/IfElse2.java</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class IfElse2 {</p>
<p>static int test(int testval, int target) { if(testval &gt; target) return +1;</p>
<p>else if(testval &lt; target) return -1; else</p>
<p>return 0; // Match</p>
<p>}</p>
<p>public static void main(String[] args) { print(test(10, 5)); print(test(5, 10)); print(test(5, 5));</p>
<p>}</p>
<p>} /* Output:</p>
<p>1</p>
<p>-1</p>
<p>0</p>
<p>*///:~</p>
<p>There’s no need for else, because the method will not continue after executing a return.</p>
<p>If you do not have a return statement in a method that returns void, there’s an implicit return at the end of that method, so it’s not always necessary to include a return statement. However, if your method states it will return anything other than void, you must ensure every code path will return a value.</p>
<p>Exercise 6: (2) Modify the two test( ) methods in the previous two programs so that they take two extra arguments, begin and end, and so that testval is tested to see if it is within the range between (and including) begin and end.</p>
<p>break and continue</p>
<p>You can also control the flow of the loop inside the body of any of the iteration statements by using break and continue. break quits the loop without executing the rest of the statements in the loop. continue stops the execution of the current iteration and goes back to the beginning of the loop to begin the next iteration.</p>
<p>//: control/BreakAndContinue.java // Demonstrates break and continue keywords. import static net.mindview.util.Range.*;</p>
<p>public class BreakAndContinue {</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 100; i++) {</p>
<p>if(i == 74) break; // Out of for loop if(i % 9 != 0) continue; // Next iteration System.out.print(i + &quot; &quot;);</p>
<p>}</p>
<p>System.out.println();</p>
<p>// Using foreach: for(int i : range(100)) {</p>
<p>if(i == 74) break; // Out of for loop if(i % 9 != 0) continue; // Next iteration System.out.print(i + &quot; &quot;);</p>
<p>}</p>
<p>System.out.println(); int i = 0;</p>
<p>// An &quot;infinite loop&quot;: while(true) { i++;</p>
<p>int j = i * 27;</p>
<p>if(j == 1269) break; // Out of loop if(i % 10 != 0) continue; // Top of loop System.out.print(i + &quot; &quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>0 9 18 27 36 45 54 63 72 0 9 18 27 36 45 54 63 72 10 20 30 40 *///:~</p>
<p>In the for loop, the value of i never gets to 100 because the break statement breaks out of the loop when i is 74. Normally, you’d use a break like this only if you didn’t know when the terminating condition was going to occur. The continue statement causes execution to go back to the top of the iteration loop (thus incrementing i) whenever i is not evenly divisible by 9. When it is, the value is printed.</p>
<p>The second for loop shows the use of foreach, and that it produces the same results.</p>
<p>Finally, you see an “infinite” while loop that would, in theory, continue forever. However, inside the loop there is a break statement that will break out of the loop. In addition, you’ll see that the continue statement moves control back to the top of the loop without completing anything after that continue statement. (Thus printing happens in the second loop only when the value of i is divisible by 10.) In the output, the value 0 is printed, because 0 % 9 produces 0.</p>
<p>A second form of the infinite loop is for(;;). The compiler treats both while(true) and for(;;) in the same way, so whichever one you use is a matter of programming taste.</p>
<p>Exercise 7: (1) Modify Exercise 1 so that the program exits by using the break keyword at value 99. Try using return instead.</p>
</section>
<section>
<title>
<p>The infamous &quot;goto&quot;</p></title><empty-line/>
<p>The goto keyword has been present in programming languages from the beginning. Indeed, goto was the genesis of program control in assembly language: “If condition A, then jump here; otherwise, jump there.” If you read the assembly code that is ultimately generated by virtually any compiler, you’ll see that program control contains many jumps (the Java compiler produces its own “assembly code,” but this code is run by the Java Virtual Machine rather than directly on a hardware CPU).</p>
<p>A goto is a jump at the source-code level, and that’s what brought it into disrepute. If a program will always jump from one point to another, isn’t there some way to reorganize the code so the flow of control is not so jumpy? goto fell into true disfavor with the publication of the famous “Goto considered harmful” paper by Edsger Dijkstra, and since then goto-bashing has been a popular sport, with advocates of the cast-out keyword scurrying for cover.</p>
<p>As is typical in situations like this, the middle ground is the most fruitful. The problem is not the use of goto, but the overuse of goto; in rare situations goto is actually the best way to structure control flow.</p>
<p>Although goto is a reserved word in Java, it is not used in the language; Java has no goto. However, it does have something that looks a bit like a jump tied in with the break and continue keywords. It’s not a jump but rather a way to break out of an iteration statement. The reason it’s often thrown in with discussions of goto is because it uses the same mechanism: a label.</p>
<p>A label is an identifier followed by a colon, like this: labeU:</p>
<p>The only place a label is useful in Java is right before an iteration statement. And that means right before—it does no good to put any other statement between the label and the iteration. And the sole reason to put a label before an iteration is if you’re going to nest another iteration or a switch (which you’ll learn about shortly) inside it. That’s because the break and continue keywords will normally interrupt only the current loop, but when used with a label, they’ll interrupt the loops up to where the label exists:</p>
<p>label1:</p>
<p>outer-iteration { inner-iteration {</p>
<p>//...</p>
<p>break; // (1)</p>
<p>//...</p>
<p>continue; // (2)</p>
<p>//...</p>
<p>continue label1; // (3)</p>
<p>//...</p>
<p>break label1; // (4)</p>
<p>}</p>
<p>}</p>
<p>In (1), the break breaks out of the inner iteration and you end up in the outer iteration. In (2), the continue moves back to the beginning of the inner iteration. But in (3), the continue label1 breaks out of the inner iteration and the outer iteration, all the way back to label1. Then it does in fact continue the iteration, but starting at the outer iteration. In (4), the break label1 also breaks all the way out to label1, but it does not reenter the iteration. It actually does break out of both iterations.</p>
<p>//: control/LabeledFor.java</p>
<p>// For loops with &quot;labeled break&quot; and &quot;labeled continue.&quot; import static net.mindview.util.Print.*;</p>
<p>public class LabeledFor {</p>
<p>public static void main(String[] args) { int i = 0;</p>
<p>outer: // Can’t have statements here for(; true ;) { // infinite loop</p>
<p>inner: // Can’t have statements here for(; i &lt; 10; i++) { print(&quot;i = &quot; + i); if(i == 2) { print(&quot;continue&quot;); continue;</p>
<p>}</p>
<p>if(i == 3) { print(&quot;break&quot;); i++; // Otherwise i never // gets incremented. break;</p>
<p>}</p>
<p>if(i == 7) {</p>
<p>print(&quot;continue outer&quot;); i++; // Otherwise i never // gets incremented. continue outer;</p>
<p>}</p>
<p>if(i == 8) {</p>
<p>print(&quot;break outer&quot;); break outer;</p>
<p>}</p>
<p>for(int k = 0; k &lt; 5; k++) { if(k == 3) {</p>
<p>print(&quot;continue inner&quot;); continue inner;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Can’t break or continue to labels here</p>
<p>}</p>
<p>} /* Output: i = 0</p>
<p>continue inner i = 1</p>
<p>continue inner i = 2 continue i = 3 break i = 4</p>
<p>continue inner i = 5</p>
<p>continue inner i = 6</p>
<p>continue inner i = 7</p>
<p>continue outer i = 8</p>
<p>break outer</p>
<p>Note that break breaks out of the for loop, and that the increment expression doesn’t occur until the end of the pass through the for loop. Since break skips the increment expression, the increment is performed directly in the case of i == 3. The continue outer statement in the case of i == 7 also goes to the top of the loop and also skips the increment, so it too is incremented directly.</p>
<p>If not for the break outer statement, there would be no way to get out of the outer loop from within an inner loop, since break by itself can break out of only the innermost loop. (The same is true for continue.)</p>
<p>Of course, in the cases where breaking out of a loop will also exit the method, you can simply use a return.</p>
<p>Here is a demonstration of labeled break and continue statements with while loops:</p>
<p>//: control/LabeledWhile.java</p>
<p>// While loops with &quot;labeled break&quot; and &quot;labeled continue.&quot; import static net.mindview.util.Print.*;</p>
<p>public class LabeledWhile {</p>
<p>public static void main(String[] args) { int i = 0; outer:</p>
<p>while(true) {</p>
<p>print(&quot;Outer while loop&quot;); while(true) { i++;</p>
<p>print(&quot;i = &quot; + i); if(i == 1) {</p>
<p>print(&quot;continue&quot;);</p>
<p>continue;</p>
<p>}</p>
<p>if(i == 3) {</p>
<p>print(&quot;continue outer&quot;); continue outer;</p>
<p>}</p>
<p>if(i == 5) { print(&quot;break&quot;); break;</p>
<p>}</p>
<p>if(i == 7) {</p>
<p>print(&quot;break outer&quot;); break outer;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Outer while loop i = 1 continue i = 2 i = 3</p>
<p>continue outer Outer while loop i = 4 i = 5 break</p>
<p>Outer while loop</p>
<p>i = 6 i = 7</p>
<p>break outer *///:~</p>
<p>The same rules hold true for while:</p>
<p>1.    A plain continue goes to the top of the innermost loop and continues.</p>
<p>2.    A labeled continue goes to the label and reenters the loop right after that label.</p>
<p>3.    A break “drops out of the bottom” of the loop.</p>
<p>4.    A labeled break drops out of the bottom of the end of the loop denoted by the label.</p>
<p>It’s important to remember that the only reason to use labels in Java is when you have nested loops and you want to break or continue through more than one nested level.</p>
<p>In Dijkstra’s “Goto considered harmful” paper, what he specifically objected to was the labels, not the goto. He observed that the number of bugs seems to increase with the number of labels in a program, and that labels and gotos make programs difficult to analyze. Note that Java labels don’t suffer from this problem, since they are constrained in their placement and can’t be used to transfer control in an ad hoc manner. It’s also interesting to note that this is a case where a language feature is made more useful by restricting the power of the statement.</p>
</section>
<section>
<title>
<p>switch</p></title><empty-line/>
<p>The switch is sometimes called a selection statement. The switch statement selects from among pieces of code based on the value of an integral expression. Its general form is:</p>
<table>
<tr><th colspan="4">switch(integral-selector) {</th></tr>
<tr><td>case</td><td>integral-value1</td><td>statement;</td><td>break</td></tr>
<tr><td>case</td><td>integral-value2</td><td>statement;</td><td>break</td></tr>
<tr><td>case</td><td>integral-value3</td><td>statement;</td><td>break</td></tr>
<tr><td>case</td><td>integral-value4</td><td>statement;</td><td>break</td></tr>
<tr><td>case // .</td><td>integral-value5</td><td>statement;</td><td>break</td></tr>
<tr><td colspan="2">default: statement;</td><td></td><td></td></tr>
</table>
<p>}</p>
<p>Integral-selector is an expression that produces an integral value. The switch compares the result of integral-selector to each integral-value. If it finds a match, the corresponding statement (a single statement or multiple statements; braces are not required) executes. If no match occurs, the default statement executes.</p>
<p>You will notice in the preceding definition that each case ends with a break, which causes execution to jump to the end of the switch body. This is the conventional way to build a switch statement, but the break is optional. If it is missing, the code for the following case statements executes until a break is encountered. Although you don’t usually want this kind of behavior, it can be useful to an experienced programmer. Note that the last statement, following the default, doesn’t have a break because the execution just falls through to where the break would have taken it anyway. You could put a break at the end of the default statement with no harm if you considered it important for style’s sake.</p>
<p>The switch statement is a clean way to implement multiway selection (i.e., selecting from among a number of different execution paths), but it requires a selector that evaluates to an integral value, such as int or char. If you want to use, for example, a string or a floating point number as a selector, it won’t work in a switch statement. For non-integral types, you must use a series of if statements. At the end of the next chapter, you’ll see that Java SE5’s new enum feature helps ease this restriction, as enums are designed to work nicely with switch.</p>
<p>Here’s an example that creates letters randomly and determines whether they’re vowels or consonants:</p>
<p>//: control/VowelsAndConsonants.java // Demonstrates the switch statement. import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class VowelsAndConsonants {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47); for(int i = 0; i &lt; 100; i++) { int c = rand.nextInt(26) + ‘a’;</p>
<table>
<tr><td>}</td><td colspan="2">/* Output:</td><td></td><td></td></tr>
<tr><td>y,</td><td>121</td><td>Sometimes</td><td>a</td><td>vowel</td></tr>
<tr><td>n,</td><td>110</td><td>consonant</td><td></td><td></td></tr>
<tr><td>z,</td><td>122</td><td>consonant</td><td></td><td></td></tr>
<tr><td>b,</td><td>98:</td><td>consonant</td><td></td><td></td></tr>
<tr><td>r,</td><td>114</td><td>consonant</td><td></td><td></td></tr>
<tr><td>n,</td><td>110</td><td>consonant</td><td></td><td></td></tr>
<tr><td>y,</td><td>121</td><td>Sometimes</td><td>a</td><td>vowel</td></tr>
<tr><td>g,</td><td>103</td><td>consonant</td><td></td><td></td></tr>
<tr><td>c,</td><td>99:</td><td>consonant</td><td></td><td></td></tr>
<tr><td>f,</td><td>102</td><td>consonant</td><td></td><td></td></tr>
<tr><td>o,</td><td>111</td><td>vowel</td><td></td><td></td></tr>
<tr><td>w,</td><td>119</td><td>Sometimes</td><td>a</td><td>vowel</td></tr>
<tr><td>z,</td><td>122</td><td>consonant</td><td></td><td></td></tr>
<tr><td colspan="5">*///:~</td></tr>
</table>
<table>
<tr><th colspan="4">printnb((char)c + &quot;, &quot; + c + &quot;: &quot;); switch(c) {</th></tr>
<tr><td>case</td><td>‘a’</td><td></td><td></td></tr>
<tr><td>case</td><td>‘e’</td><td></td><td></td></tr>
<tr><td>case</td><td>‘i’</td><td></td><td></td></tr>
<tr><td>case</td><td>‘o’:</td><td></td><td></td></tr>
<tr><td>case</td><td>‘u’</td><td>print(</td><td>vowel&quot;);</td></tr>
<tr><td></td><td></td><td>break;</td><td></td></tr>
<tr><td>case</td><td>‘y’</td><td></td><td></td></tr>
<tr><td>case</td><td>‘w’</td><td>print(</td><td>Sometimes a vowel&quot;)</td></tr>
<tr><td></td><td></td><td>break;</td><td></td></tr>
<tr><td colspan="2">default:</td><td>print(</td><td>consonant&quot;);</td></tr>
</table>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Since Random.nextInt(26) generates a value between o and 26, you need only add an offset of ‘a’ to produce the lowercase letters. The single-quoted characters in the case statements also produce integral values that are used for comparison.</p>
<p>Notice how the cases can be “stacked” on top of each other to provide multiple matches for a particular piece of code. You should also be aware that it’s essential to put the break statement at the end of a particular case; otherwise, control will simply drop through and continue processing on the next case.</p>
<p>In the statement: int c = rand.nextInt(26) + ‘a’;</p>
<p>Random.nextInt( ) produces a random int value from o to 25, which is added to the value of ‘a’. This means that ‘a’ is automatically converted to an int to perform the addition.</p>
<p>In order to print c as a character, it must be cast to char; otherwise, you’ll produce integral output.</p>
<p>Exercise 8: (2) Create a switch statement that prints a message for each case, and put the switch inside a for loop that tries each case. Put a break after each case and test it, then remove the breaks and see what happens.</p>
<p>Exercise 9: (4) A Fibonacci sequence is the sequence of numbers 1, 1, 2, 3, 5, 8, 13, 21, 34, and so on, where each number (from the third on) is the sum of the previous two. Create a method that takes an integer as an argument and displays that many Fibonacci numbers starting from the beginning, e.g., If you run java Fibonacci 5 (where Fibonacci is the name of the class) the output will be: 1, 1, 2, 3, 5.</p>
<p>Exercise 10: (5) A vampire number has an even number of digits and is formed by multiplying a pair of numbers containing half the number of digits of the result. The digits are taken from the original number in any order. Pairs of trailing zeroes are not allowed. Examples include:</p>
<p>1260 = 21 * 60 1827 = 21 * 87 2187 = 27 * 81</p>
<p>Write a program that finds all the 4-digit vampire numbers. (Suggested by Dan Forhan.)</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>This chapter concludes the study of fundamental features that appear in most programming languages: calculation, operator precedence, type casting, and selection and iteration. Now you’re ready to begin taking steps that move you closer to the world of object-oriented programming. The next chapter will cover the important issues of initialization and cleanup of objects, followed in the subsequent chapter by the essential concept of implementation hiding.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Initialization &amp; Cleanup</p></title><empty-line/>
<p>As the computer revolution progresses, “unsafe” programming has become one of the major culprits that makes programming expensive.</p>
<p>Two of these safety issues are initialization and cleanup. Many C bugs occur when the programmer forgets to initialize a variable. This is especially true with libraries when users don’t know how to initialize a library component, or even that they must. Cleanup is a special problem because it’s easy to forget about an element when you’re done with it, since it no longer concerns you. Thus, the resources used by that element are retained and you can easily end up running out of resources (most notably, memory).</p>
<p>C++ introduced the concept of a constructor, a special method automatically called when an object is created. Java also adopted the constructor, and in addition has a garbage collector that automatically releases memory resources when they’re no longer being used. This chapter examines the issues of initialization and cleanup, and their support in Java.</p>
<section>
<title>
<p>Guaranteed initialization with the constructor</p></title><empty-line/>
<p>You can imagine creating a method called initialize( ) for every class you write. The name is a hint that it should be called before using the object. Unfortunately, this means the user must remember to call that method. In Java, the class designer can guarantee initialization of every object by providing a constructor. If a class has a constructor, Java automatically calls that constructor when an object is created, before users can even get their hands on it. So initialization is guaranteed.</p>
<p>The next challenge is what to name this method. There are two issues. The first is that any name you use could clash with a name you might like to use as a member in the class. The second is that because the compiler is responsible for calling the constructor, it must always know which method to call. The C++ solution seems the easiest and most logical, so it’s also used in Java: The name of the constructor is the same as the name of the class. It makes sense that such a method will be called automatically during initialization.</p>
<p>Here’s a simple class with a constructor:</p>
<p>//: initialization/SimpleConstructor.java // Demonstration of a simple constructor.</p>
<p>class Rock {</p>
<p>Rock() { // This is the constructor System.out.print(&quot;Rock &quot;);</p>
<p>}</p>
<p>}</p>
<p>public class SimpleConstructor {</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 10; i++) new Rock();</p>
<p>} /* Output:</p>
<p>Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock *///:~</p>
<p>Now, when an object is created: new Rock();</p>
<p>storage is allocated and the constructor is called. It is guaranteed that the object will be properly initialized before you can get your hands on it.</p>
<p>Note that the coding style of making the first letter of all methods lowercase does not apply to constructors, since the name of the constructor must match the name of the class exactly.</p>
<p>A constructor that takes no arguments is called the default constructor. The Java documents typically use the term no-arg constructor, but “default constructor” has been in use for many years before Java appeared, so I will tend to use that. But like any method, the constructor can also have arguments to allow you to specify how an object is created. The preceding example can easily be changed so the constructor takes an argument:</p>
<p>//: initialization/SimpleConstructor2.java // Constructors can have arguments.</p>
<p>class Rock2 {</p>
<p>Rock2(int i) {</p>
<p>System.out.print(&quot;Rock &quot; + i + &quot; &quot;);</p>
<p>}</p>
<p>}</p>
<p>public class SimpleConstructor2 {</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 8; i++) new Rock2(i);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Rock 0 Rock 1 Rock 2 Rock 3 Rock 4 Rock 5 Rock 6 Rock 7 *///:~</p>
<p>Constructor arguments provide you with a way to provide parameters for the initialization of an object. For example, if the class Tree has a constructor that takes a single integer argument denoting the height of the tree, you create a Tree object like this:</p>
<p>Tree t = new Tree(12); // 12-foot tree</p>
<p>If Tree(int) is your only constructor, then the compiler won’t let you create a Tree object any other way.</p>
<p>Constructors eliminate a large class of problems and make the code easier to read. In the preceding code fragment, for example, you don’t see an explicit call to some initialize( ) method that is conceptually separate from creation. In Java, creation and initialization are unified concepts—you can’t have one without the other.</p>
<p>The constructor is an unusual type of method because it has no return value. This is distinctly different from a void return value, in which the method returns nothing but you still have the option to make it return something else. Constructors return nothing and you don’t have an option (the new expression does return a reference to the newly created object, but the constructor itself has no return value). If there were a return value, and if you could select your own, the compiler would somehow need to know what to do with that return value.</p>
<p>Exercise 1: (1) Create a class containing an uninitialized String reference. Demonstrate that this reference is initialized by Java to null.</p>
<p>Exercise 2: (2) Create a class with a String field that is initialized at the point of definition, and another one that is initialized by the constructor. What is the difference between the two approaches?</p>
</section>
<section>
<title>
<p>Method overloading</p></title><empty-line/>
<p>One of the important features in any programming language is the use of names. When you create an object, you give a name to a region of storage. A method is a name for an action.</p>
<p>You refer to all objects and methods by using names. Well-chosen names create a system that is easier for people to understand and change. It’s a lot like writing prose—the goal is to communicate with your readers.</p>
<p>A problem arises when mapping the concept of nuance in human language onto a programming language. Often, the same word expresses a number of different meanings—it’s overloaded. This is useful, especially when it comes to trivial differences. You say, “Wash the shirt,” “Wash the car,” and “Wash the dog.” It would be silly to be forced to say, “shirtWash the shirt,” “carWash the car,” and “dogWash the dog” just so the listener doesn’t need to make any distinction about the action performed. Most human languages are redundant, so even if you miss a few words, you can still determine the meaning. You don’t need unique identifiers—you can deduce meaning from context.</p>
<p>Most programming languages (C in particular) require you to have a unique identifier for each method (often called functions in those languages). So you could not have one function called print( ) for printing integers and another called print( ) for printing floats—each function requires a unique name.</p>
<p>In Java (and C++), another factor forces the overloading of method names: the constructor. Because the constructor’s name is predetermined by the name of the class, there can be only one constructor name. But what if you want to create an object in more than one way? For example, suppose you build a class that can initialize itself in a standard way or by reading information from a file. You need two constructors, the default constructor and one that takes a String as an argument, which is the name of the file from which to initialize the object. Both are constructors, so they must have the same name—the name of the class. Thus, method overloading is essential to allow the same method name to be used with different argument types. And although method overloading is a must for constructors, it’s a general convenience and can be used with any method.</p>
<p>Here’s an example that shows both overloaded constructors and overloaded methods:</p>
<p>//: initialization/Overloading.java // Demonstration of both constructor // and ordinary method overloading. import static net.mindview.util.Print.*;</p>
<p>class Tree { int height;</p>
<p>Tree() {</p>
<p>print(&quot;Planting a seedling&quot;); height = 0;</p>
<p>}</p>
<p>Tree(int initialHeight) { height = initialHeight; print(&quot;Creating new Tree that is &quot; + height + &quot; feet tall&quot;);</p>
<p>void info() {</p>
<p>print(&quot;Tree is &quot; + height + &quot; feet tall&quot;);</p>
<p>}</p>
<p>void info(String s) {</p>
<p>print(s + &quot;: Tree is &quot; + height + &quot; feet tall&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class Overloading {</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 5; i++) {</p>
<p>Tree t = new Tree(i); t.info();</p>
<p>t.info(&quot;overloaded method&quot;);</p>
<p>}</p>
<p>// Overloaded constructor: new Tree();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Creating new Tree that is 0 feet tall Tree is 0 feet tall</p>
<p>overloaded method: Tree is 0 feet tall Creating new Tree that is 1 feet tall Tree is 1 feet tall</p>
<p>overloaded method: Tree is 1 feet tall Creating new Tree that is 2 feet tall Tree is 2 feet tall</p>
<p>overloaded method: Tree is 2 feet tall Creating new Tree that is 3 feet tall Tree is 3 feet tall</p>
<p>overloaded method: Tree is 3 feet tall Creating new Tree that is 4 feet tall Tree is 4 feet tall</p>
<p>overloaded method: Tree is 4 feet tall</p>
<p>Planting a seedling</p>
<p>*///:~</p>
<p>A Tree object can be created either as a seedling, with no argument, or as a plant grown in a nursery, with an existing height. To support this, there is a default constructor, and one that takes the existing height.</p>
<p>You might also want to call the info( ) method in more than one way. For example, if you have an extra message you want printed, you can use info(String), and info( ) if you have nothing more to say. It would seem strange to give two separate names to what is obviously the same concept. Fortunately, method overloading allows you to use the same name for both.</p>
<subtitle>Distinguishing overloaded methods</subtitle>
<p>If the methods have the same name, how can Java know which method you mean? There’s a simple rule: Each overloaded method must take a unique list of argument types.</p>
<p>If you think about this for a second, it makes sense. How else could a programmer tell the difference between two methods that have the same name, other than by the types of their arguments?</p>
<p>Even differences in the ordering of arguments are sufficient to distinguish two methods, although you don’t normally want to take this approach because it produces difficult-to-maintain code:</p>
<p>public class OverloadingOrder {</p>
<p>static void f(String s, int i) {</p>
<p>print(&quot;String: &quot; + s + &quot;, int: &quot; + i);</p>
<p>}</p>
<p>static void f(int i, String s) {</p>
<p>print(&quot;int: &quot; + i + &quot;, String: &quot; + s);</p>
<p>}</p>
<p>public static void main(String[] args) { f(&quot;String first&quot;, 11); f(99, &quot;Int first&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>String: String first, int: 11 int: 99, String: Int first *///:~</p>
<p>The two f( ) methods have identical arguments, but the order is different, and that’s what makes them distinct.</p>
<subtitle>Overloading with primitives</subtitle>
<p>A primitive can be automatically promoted from a smaller type to a larger one, and this can be slightly confusing in combination with overloading. The following example demonstrates what happens when a primitive is handed to an overloaded method:</p>
<p>//: initialization/PrimitiveOverloading.java // Promotion of primitives and overloading. import static net.mindview.util.Print.*;</p>
<p>public class PrimitiveOverloading {</p>
<p>void f1(char x) { printnb(&quot;f1(char) &quot;); } void f1(byte x) { printnb(&quot;f1(byte) &quot;); } void f1(short x) { printnb(&quot;f1(short) &quot;); } void f1(int x) { printnb(&quot;f1(int) &quot;); } void f1(long x) { printnb(&quot;f1(long) &quot;); } void f1(float x) { printnb(&quot;f1(float) &quot;); } void f1(double x) { printnb(&quot;f1(double) &quot;); }</p>
<p>void f2(byte x) { printnb(&quot;f2(byte) &quot;); } void f2(short x) { printnb(&quot;f2(short) &quot;); } void f2(int x) { printnb(&quot;f2(int) &quot;); } void f2(long x) { printnb(&quot;f2(long) &quot;); } void f2(float x) { printnb(&quot;f2(float) &quot;); } void f2(double x) { printnb(&quot;f2(double) &quot;); }</p>
<p>void f3(short x) { printnb(&quot;f3(short) &quot;); } void f3(int x) { printnb(&quot;f3(int) &quot;); } void f3(long x) { printnb(&quot;f3(long) &quot;); } void f3(float x) { printnb(&quot;f3(float) &quot;); } void f3(double x) { printnb(&quot;f3(double) &quot;); }</p>
<p>void f4(int x) { printnb(&quot;f4(int) &quot;); } void f4(long x) { printnb(&quot;f4(long) &quot;); } void f4(float x) { printnb(&quot;f4(float) &quot;); } void f4(double x) { printnb(&quot;f4(double) &quot;); }</p>
<p>void f5(long x) { printnb(&quot;f5(long) &quot;); }</p>
<p>void f5(float x) { printnb(<sup>M</sup>f5(float) &quot;); } void f5(double x) { printnb(&quot;f5(double) &quot;); }</p>
<p>void f6(float x) { printnb(&quot;f6(float) &quot;); } void f6(double x) { printnb(&quot;f6(double) &quot;); }</p>
<p>void f7(double x) { printnb(&quot;f7(double) &quot;); }</p>
<p>void testConstVal() { printnb(&quot;5: &quot;);</p>
<p>f1(5);f2(5);f3(5);f4(5);f5(5);f6(5);f7(5); print();</p>
<p>}</p>
<p>void testChar() { char x = ‘x’; printnb(&quot;char: &quot;);</p>
<p>f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</p>
<p>}</p>
<p>void testByte() { byte x = 0; printnb(&quot;byte: &quot;);</p>
<p>f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</p>
<p>}</p>
<p>void testShort() { short x = 0; printnb(&quot;short: &quot;);</p>
<p>f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</p>
<p>}</p>
<p>void testInt() { int x = 0; printnb(&quot;int: &quot;);</p>
<p>f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</p>
<p>}</p>
<p>void testLong() { long x = 0; printnb(&quot;long: &quot;);</p>
<p>f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</p>
<p>}</p>
<p>void testFloat() { float x = 0; printnb(&quot;float: &quot;);</p>
<p>f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</p>
<p>}</p>
<p>void testDouble() { double x = 0; printnb(&quot;double: &quot;);</p>
<p>f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>PrimitiveOverloading p = new PrimitiveOverloading(); p.testConstVal(); p.testChar(); p.testByte(); p.testShort(); p.testInt(); p.testLong(); p.testFloat(); p.testDouble();</p>
<p>}</p>
<p>} /* Output:</p>
<p>5: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) char: f1(char) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) byte: f1(byte) f2(byte) f3(short) f4(int) f5(long) f6(float) f7(double) short: fl(short) f2(short) f3(short) f4(int) f5(long) f6(float) f7(double)</p>
<p>int: fl(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) long: fl(long) f2(long) f3(long) f4(long) f5(long) f6(float) f7(double) float: fl(float) f2(float) f3(float) f4(float) f5(float) f6(float) f7(double)</p>
<p>double: fl(double) f2(double) f3(double) f4(double) f5(double) f6(double) f7(double)</p>
<p>*///:~</p>
<p>You can see that the constant value 5 is treated as an int, so if an overloaded method is available that takes an int, it is used. In all other cases, if you have a data type that is smaller than the argument in the method, that data type is promoted. char produces a slightly different effect, since if it doesn’t find an exact char match, it is promoted to int.</p>
<p>What happens if your argument is bigger than the argument expected by the overloaded method? A modification of the preceding program gives the answer:</p>
<table>
<tr><th colspan="5">//: initialization/Demotion.java // Demotion of primitives and overloading.</th></tr>
<tr><td>import</td><td>static net.</td><td>mindview.util.Print</td><td>*;</td><td></td></tr>
<tr><td>public</td><td colspan="2">class Demotion {</td><td></td><td></td></tr>
<tr><td>void</td><td>fl(char x)</td><td>{ print(&quot;fl(char)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>fl(byte x)</td><td>{ print(&quot;fl(byte)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>fl(short x)</td><td>{ print(&quot;fl(short)</td><td>&quot;);</td><td>}</td></tr>
<tr><td>void</td><td>fl(int x) {</td><td>print(&quot;fl(int)&quot;);</td><td>}</td><td></td></tr>
<tr><td>void</td><td>fl(long x)</td><td>{ print(&quot;fl(long)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>fl(float x)</td><td>{ print(&quot;fl(float)</td><td>&quot;);</td><td>}</td></tr>
<tr><td>void</td><td colspan="3">fl(double x) { print(&quot;fl(double)&quot;)</td><td>; }</td></tr>
<tr><td>void</td><td>f2(char x)</td><td>{ print(&quot;f2(char)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f2(byte x)</td><td>{ print(&quot;f2(byte)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f2(short x)</td><td>{ print(&quot;f2(short)</td><td>&quot;);</td><td>}</td></tr>
<tr><td>void</td><td>f2(int x) {</td><td>print(&quot;f2(int)&quot;);</td><td>}</td><td></td></tr>
<tr><td>void</td><td>f2(long x)</td><td>{ print(&quot;f2(long)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f2(float x)</td><td>{ print(&quot;f2(float)</td><td>&quot;);</td><td>}</td></tr>
<tr><td>void</td><td>f3(char x)</td><td>{ print(&quot;f3(char)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f3(byte x)</td><td>{ print(&quot;f3(byte)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f3(short x)</td><td>{ print(&quot;f3(short)</td><td>&quot;);</td><td>}</td></tr>
<tr><td>void</td><td>f3(int x) {</td><td>print(&quot;f3(int)&quot;);</td><td>}</td><td></td></tr>
<tr><td>void</td><td>f3(long x)</td><td>{ print(&quot;f3(long)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f4(char x)</td><td>{ print(&quot;f4(char)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f4(byte x)</td><td>{ print(&quot;f4(byte)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f4(short x)</td><td>{ print(&quot;f4(short)</td><td>&quot;);</td><td>}</td></tr>
<tr><td>void</td><td>f4(int x) {</td><td>print(&quot;f4(int)&quot;);</td><td>}</td><td></td></tr>
<tr><td>void</td><td>f5(char x)</td><td>{ print(&quot;f5(char)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f5(byte x)</td><td>{ print(&quot;f5(byte)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f5(short x)</td><td>{ print(&quot;f5(short)</td><td>&quot;);</td><td>}</td></tr>
<tr><td>void</td><td>f6(char x)</td><td>{ print(&quot;f6(char)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f6(byte x)</td><td>{ print(&quot;f6(byte)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td>f7(char x)</td><td>{ print(&quot;f7(char)&quot;)</td><td>; }</td><td></td></tr>
<tr><td>void</td><td colspan="2">testDouble() {</td><td></td><td></td></tr>
<tr><td colspan="5">double x = 0;print(&quot;double argument:&quot;); fl(x);f2((float)x);f3((long)x);f4((int)x);</td></tr>
</table>
<p>f5((short)x);f6((byte)x);f7((char)x);</p>
<p>public static void main(String[] args) Demotion p = new Demotion(); p.testDouble();</p>
<p>{</p>
<p>}</p>
<p>} /* Output:</p>
<p>double argument:</p>
<p>f1(double)</p>
<p>f2(float)</p>
<p>f3(long)</p>
<p>f4(int)</p>
<p>f5(short)</p>
<p>f6(byte)</p>
<p>f7(char)</p>
<p>*///:~</p>
<p>Here, the methods take narrower primitive values. If your argument is wider, then you must perform a narrowing conversion with a cast. If you don’t do this, the compiler will issue an error message.</p>
<subtitle>Overloading on return values</subtitle>
<p>It is common to wonder, “Why only class names and method argument lists? Why not distinguish between methods based on their return values?” For example, these two methods, which have the same name and arguments, are easily distinguished from each other:</p>
<p>void f() {}</p>
<p>int f() { return 1; }</p>
<p>This might work fine as long as the compiler could unequivocally determine the meaning from the context, as in int x = f( ). However, you can also call a method and ignore the return value. This is often referred to as calling a method for its side effect, since you don’t care about the return value, but instead want the other effects of the method call. So if you call the method this way:</p>
<p>f();</p>
<p>how can Java determine which f( ) should be called? And how could someone reading the code see it? Because of this sort of problem, you cannot use return value types to distinguish overloaded methods.</p>
</section>
<section>
<title>
<p>Default constructors</p></title><empty-line/>
<p>As mentioned previously, a default constructor (a.k.a. a “no-arg” constructor) is one without arguments that is used to create a “default object.” If you create a class that has no constructors, the compiler will automatically create a default constructor for you. For example:</p>
<p>//: initialization/DefaultConstructor.java class Bird {}</p>
<p>public class DefaultConstructor {</p>
<p>public static void main(String[] args) {</p>
<p>Bird b = new Bird(); // Default!</p>
<p>} ///:~</p>
<p>The expression new Bird()</p>
<p>creates a new object and calls the default constructor, even though one was not explicitly defined. Without it, you would have no method to call to build the object. However, if you define any constructors (with or without arguments), the compiler will not synthesize one for you:</p>
<p>//: initialization/NoSynthesis.java</p>
<p>class Bird2 {</p>
<p>Bird2(int i) {}</p>
<p>Bird2(double d) {}</p>
<p>}</p>
<p>public class NoSynthesis {</p>
<p>public static void main(String[] args) {</p>
<p>//! Bird2 b = new Bird2(); // No default Bird2 b2 = new Bird2(1);</p>
<p>Bird2 b3 = new Bird2(1.0);</p>
<p>}</p>
<p>} ///:~</p>
<p>If you say: new Bird2()</p>
<p>the compiler will complain that it cannot find a constructor that matches. When you don’t put in any constructors, it’s as if the compiler says, “You are bound to need some constructor, so let me make one for you.” But if you write a constructor, the compiler says, “You’ve written a constructor so you know what you’re doing; if you didn’t put in a default it’s because you meant to leave it out.”</p>
<p>Exercise 3: (1) Create a class with a default constructor (one that takes no arguments) that prints a message. Create an object of this class.</p>
<p>Exercise 4: (1) Add an overloaded constructor to the previous exercise that takes a String argument and prints it along with your message.</p>
<p>Exercise 5: (2) Create a class called Dog with an overloaded bark( ) method. This method should be overloaded based on various primitive data types, and print different types of barking, howling, etc., depending on which overloaded version is called. Write a main( ) that calls all the different versions.</p>
<p>Exercise 6: (1) Modify the previous exercise so that two of the overloaded methods have two arguments (of two different types), but in reversed order relative to each other. Verify that this works.</p>
<p>Exercise 7: (1) Create a class without a constructor, and then create an object of that class in main( ) to verify that the default constructor is automatically synthesized.</p>
</section>
<section>
<title>
<p>The this keyword</p></title><empty-line/>
<p>If you have two objects of the same type called a and b, you might wonder how it is that you can call a method peel( ) for both those objects:</p>
<p>//: initialization/BananaPeel.java</p>
<p>class Banana { void peel(int i) { /* ... */ } }</p>
<p>public class BananaPeel {</p>
<p>public static void main(String[] args) {</p>
<p>Banana a = new Banana(), b = new Banana();</p>
<p>a. peel(1);</p>
<p>b. peel(2);</p>
<p>}</p>
<p>} ///:~</p>
<p>If there’s only one method called peel( ), how can that method know whether it’s being called for the object a or b?</p>
<p>To allow you to write the code in a convenient object-oriented syntax in which you “send a message to an object,” the compiler does some undercover work for you. There’s a secret first argument passed to the method peel( ), and that argument is the reference to the object that’s being manipulated. So the two method calls become something like:</p>
<p>Banana.peel(a, 1);</p>
<p>Banana.peel(b, 2);</p>
<p>This is internal and you can’t write these expressions and get the compiler to accept them, but it gives you an idea of what’s happening.</p>
<p>Suppose you’re inside a method and you’d like to get the reference to the current object.</p>
<p>Since that reference is passed secretly by the compiler, there’s no identifier for it. However, for this purpose there’s a keyword: this. The this keyword—which can be used only inside a non-static method—produces the reference to the object that the method has been called for. You can treat the reference just like any other object reference. Keep in mind that if you’re calling a method of your class from within another method of your class, you don’t need to use this. You simply call the method. The current this reference is automatically used for the other method. Thus you can say:</p>
<p>//: initialization/Apricot.java public class Apricot { void pick() { /* ... */ } void pit() { pick(); /* ... */ }</p>
<p>} ///:~</p>
<p>Inside pit( ), you could say this.pick( ) but there’s no need to.<a l:href="#bookmark17" type="note"><sup>18</sup></a><sup></sup> The compiler does it for you automatically. The this keyword is used only for those special cases in which you need to explicitly use the reference to the current object. For example, it’s often used in return statements when you want to return the reference to the current object:</p>
<p>//: initialization/Leaf.java // Simple use of the &quot;this&quot; keyword.</p>
<p>public class Leaf { int i = 0;</p>
<p>Leaf increment() { i++;</p>
<p>return this;</p>
<p>}</p>
<p>void print() {</p>
<p>System.out.println(&quot;i = &quot; + i);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Leaf x = new Leaf();</p>
<p>x.increment().increment().increment().print();</p>
<p>}</p>
<p>} /* Output: i = 3 *///:~</p>
<p>Because increment( ) returns the reference to the current object via the this keyword, multiple operations can easily be performed on the same object.</p>
<p>The this keyword is also useful for passing the current object to another method:</p>
<p>//: initialization/PassingThis.java</p>
<p>class Person {</p>
<p>public void eat(Apple apple) {</p>
<p>Apple peeled = apple.getPeeled();</p>
<p>System.out.println(&quot;Yummy&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Peeler {</p>
<p>static Apple peel(Apple apple) {</p>
<p>// ... remove peel return apple; // Peeled</p>
<p>}</p>
<p>}</p>
<p>class Apple {</p>
<p>Apple getPeeled() { return Peeler.peel(this); }</p>
<p>}</p>
<p>public class PassingThis {</p>
<p>public static void main(String[] args) { new Person().eat(new Apple());</p>
<p>}</p>
<p>} /* Output:</p>
<p>Yummy</p>
<p>*///:~</p>
<p>Apple needs to call Peeler.peel( ), which is a foreign utility method that performs an operation that, for some reason, needs to be external to Apple (perhaps the external method can be applied across many different classes, and you don’t want to repeat the code). To pass itself to the foreign method, it must use this.</p>
<p>Exercise 8: (1) Create a class with two methods. Within the first method, call the second method twice: the first time without using this, and the second time using this—just to see it working; you should not use this form in practice.</p>
<subtitle>Calling constructors from constructors</subtitle>
<p>When you write several constructors for a class, there are times when you’d like to call one constructor from another to avoid duplicating code. You can make such a call by using the this keyword.</p>
<p>Normally, when you say this, it is in the sense of “this object” or “the current object,” and by itself it produces the reference to the current object. In a constructor, the this keyword takes on a different meaning when you give it an argument list. It makes an explicit call to the constructor that matches that argument list. Thus you have a straightforward way to call other constructors:</p>
<p>//: initialization/Flower.java // Calling constructors with &quot;this&quot; import static net.mindview.util.Print.*;</p>
<p>public class Flower { int petalCount = 0;</p>
<p>String s = &quot;initial value&quot;;</p>
<p>Flower(int petals) { petalCount = petals;</p>
<p>print(&quot;Constructor w/ int arg only, petalCount= &quot;</p>
<p>+ petalCount);</p>
<p>}</p>
<p>Flower(String ss) {</p>
<p>print(&quot;Constructor w/ String arg only, s = &quot; + ss); s = ss;</p>
<p>}</p>
<p>Flower(String s, this(petals);</p>
<p>//! this(s) this.s = s</p>
<p>//</p>
<p>//</p>
<p>int petals) {</p>
<p>Can’t call two! Another use of</p>
<p>this&quot;</p>
<p>print(&quot;String &amp; int args&quot;);</p>
<p>}</p>
<p>Flower() {</p>
<p>this(&quot;hi&quot;, 47);</p>
<p>print(&quot;default constructor (no args)&quot;);</p>
<p>}</p>
<p>void printPetalCount() {</p>
<p>//! this(11); // Not inside non-constructor! print(&quot;petalCount = &quot; + petalCount + &quot; s</p>
<p>}</p>
<p>public static void main(String[] args) { Flower x = new Flower(); x.printPetalCount();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Constructor w/ int arg only, petalCount= 47 String &amp; int args default constructor (no args) petalCount = 47 s = hi *///:~</p>
<p>&quot;+</p>
<p>s);</p>
<p>The constructor Flower(String s, int petals) shows that, while you can call one constructor using this, you cannot call two. In addition, the constructor call must be the first thing you do, or you’ll get a compiler error message.</p>
<p>This example also shows another way you’ll see this used. Since the name of the argument s and the name of the member data s are the same, there’s an ambiguity. You can resolve it</p>
<p>using this.s, to say that you’re referring to the member data. You’ll often see this form used in Java code, and it’s used in numerous places in this book.</p>
<p>In printPetalCount( ) you can see that the compiler won’t let you call a constructor from inside any method other than a constructor.</p>
<p>Exercise 9: (1) Create a class with two (overloaded) constructors. Using this, call the second constructor inside the first one.</p>
<subtitle>The meaning of static</subtitle>
<p>With the this keyword in mind, you can more fully understand what it means to make a method static. It means that there is no this for that particular method. You cannot call non-static methods from inside static methods<a l:href="#bookmark18" type="note"><sup>19</sup></a><sup></sup> (although the reverse is possible), and you can call a static method for the class itself, without any object. In fact, that’s primarily what a static method is for. It’s as if you’re creating the equivalent of a global method. However, global methods are not permitted in Java, and putting the static method inside a class allows it access to other static methods and to static fields.</p>
<p>Some people argue that static methods are not object-oriented, since they do have the semantics of a global method; with a static method, you don’t send a message to an object, since there’s no this. This is probably a fair argument, and if you find yourself using a lot of static methods, you should probably rethink your strategy. However, statics are pragmatic, and there are times when you genuinely need them, so whether or not they are “proper OOP” should be left to the theoreticians.</p>
</section>
<section>
<title>
<p>Cleanup: finalization and garbage collection</p></title><empty-line/>
<p>Programmers know about the importance of initialization, but often forget the importance of cleanup. After all, who needs to clean up an int? But with libraries, simply “letting go” of an object once you’re done with it is not always safe. Of course, Java has the garbage collector to reclaim the memory of objects that are no longer used. Now consider an unusual case: Suppose your object allocates “special” memory without using new. The garbage collector only knows how to release memory allocated with new, so it won’t know how to release the object’s “special” memory. To handle this case, Java provides a method called finalize( ) that you can define for your class. Here’s how it’s supposed to work. When the garbage collector is ready to release the storage used for your object, it will first call finalize( ), and only on the next garbage-collection pass will it reclaim the object’s memory. So if you choose to use finalize( ), it gives you the ability to perform some important cleanup at the time of garbage collection.</p>
<p>This is a potential programming pitfall because some programmers, especially C++ programmers, might initially mistake finalize( ) for the destructor in C++, which is a function that is always called when an object is destroyed. It is important to distinguish between C++ and Java here, because in C++, objects always get destroyed (in a bug-free program), whereas in Java, objects do not always get garbage collected. Or, put another way:</p>
<p>1. Your objects might not get garbage collected.</p>
<p>2. Garbage collection is not destruction.</p>
<p>If you remember this, you will stay out of trouble. What it means is that if there is some activity that must be performed before you no longer need an object, you must perform that activity yourself. Java has no destructor or similar concept, so you must create an ordinary method to perform this cleanup. For example, suppose that in the process of creating your object, it draws itself on the screen. If you don’t explicitly erase its image from the screen, it might never get cleaned up. If you put some kind of erasing functionality inside finalize( ), then if an object is garbage collected and finalize( ) is called (and there’s no guarantee this will happen), then the image will first be removed from the screen, but if it isn’t, the image will remain.</p>
<p>You might find that the storage for an object never gets released because your program never nears the point of running out of storage. If your program completes and the garbage collector never gets around to releasing the storage for any of your objects, that storage will be returned to the operating system en masse as the program exits. This is a good thing, because garbage collection has some overhead, and if you never do it, you never incur that expense.</p>
<subtitle>What is finalize() for?</subtitle>
<p>So, if you should not use finalize( ) as a general-purpose cleanup method, what good is it?</p>
<p>A third point to remember is:</p>
<p>3. Garbage collection is only about memory.</p>
<p>That is, the sole reason for the existence of the garbage collector is to recover memory that your program is no longer using. So any activity that is associated with garbage collection, most notably your finalize( ) method, must also be only about memory and its deallocation.</p>
<p>Does this mean that if your object contains other objects, finalize( ) should explicitly release those objects? Well, no—the garbage collector takes care of the release of all object memory regardless of how the object is created. It turns out that the need for finalize( ) is limited to special cases in which your object can allocate storage in some way other than creating an object. But, you might observe, everything in Java is an object, so how can this be?</p>
<p>It would seem that finalize( ) is in place because of the possibility that you’ll do something Clike by allocating memory using a mechanism other than the normal one in Java. This can happen primarily through native methods, which are a way to call non-Java code from Java. (Native methods are covered in Appendix B in the electronic 2<sup>nd</sup> edition of this book, available at <a l:href="http://www.MindView.net">www.MindView.net</a>.) C and C++ are the only languages currently supported by native methods, but since they can call subprograms in other languages, you can effectively call anything. Inside the non-Java code, C’s malloc( ) family of functions might be called to allocate storage, and unless you call free( ), that storage will not be released, causing a memory leak. Of course, free( ) is a C and C++ function, so you’d need to call it in a native method inside your finalize( ).</p>
<p>After reading this, you probably get the idea that you won’t use finalize( ) much.<a l:href="#bookmark19" type="note"><sup>20</sup></a><sup></sup> You’re correct; it is not the appropriate place for normal cleanup to occur. So where should normal cleanup be performed?</p>
<subtitle>You must perform cleanup</subtitle>
<p>To clean up an object, the user of that object must call a cleanup method at the point the cleanup is desired. This sounds pretty straightforward, but it collides a bit with the C++ concept of the destructor. In C++, all objects are destroyed. Or rather, all objects should be destroyed. If the C++ object is created as a local (i.e., on the stack—not possible in Java), then the destruction happens at the closing curly brace of the scope in which the object was created. If the object was created using new (like in Java), the destructor is called when the programmer calls the C++ operator delete (which doesn’t exist in Java). If the C++ programmer forgets to call delete, the destructor is never called, and you have a memory leak, plus the other parts of the object never get cleaned up. This kind of bug can be very difficult to track down, and is one of the compelling reasons to move from C++ to Java.</p>
<p>In contrast, Java doesn’t allow you to create local objects—you must always use new. But in Java, there’s no “delete” for releasing the object, because the garbage collector releases the storage for you. So from a simplistic standpoint, you could say that because of garbage collection, Java has no destructor. You’ll see as this book progresses, however, that the presence of a garbage collector does not remove the need for or the utility of destructors. (And you should never call finalize( ) directly, so that’s not a solution.) If you want some kind of cleanup performed other than storage release, you must still explicitly call an appropriate method in Java, which is the equivalent of a C++ destructor without the convenience.</p>
<p>Remember that neither garbage collection nor finalization is guaranteed. If the JVM isn’t close to running out of memory, then it might not waste time recovering memory through garbage collection.</p>
<subtitle>The termination condition</subtitle>
<p>In general, you can’t rely on finalize( ) being called, and you must create separate “cleanup” methods and call them explicitly. So it appears that finalize( ) is only useful for obscure memory cleanup that most programmers will never use. However, there is an interesting use of finalize( ) that does not rely on it being called every time. This is the verification of the termination condition<a l:href="#bookmark20" type="note"><sup>21</sup></a><sup></sup> of an object.</p>
<p>At the point that you’re no longer interested in an object—when it’s ready to be cleaned up— that object should be in a state whereby its memory can be safely released. For example, if the object represents an open file, that file should be closed by the programmer before the object is garbage collected. If any portions of the object are not properly cleaned up, then you have a bug in your program that can be very difficult to find. finalize( ) can be used to eventually discover this condition, even if it isn’t always called. If one of the finalizations happens to reveal the bug, then you discover the problem, which is all you really care about.</p>
<p>Here’s a simple example of how you might use it:</p>
<p>//: initialization/TerminationCondition.java // Using finalize() to detect an object that // hasn’t been properly cleaned up.</p>
<p>class Book {</p>
<p>boolean checkedOut = false;</p>
<p>Book(boolean checkout) { checkedOut = checkOut;</p>
<p>}</p>
<p>void checkIn() { checkedOut = false;</p>
<p>}</p>
<p>protected void finalize() { if(checkedOut)</p>
<p>System.out.println(&quot;Error: checked out&quot;);</p>
<p>// Normally, you’ll also do this:</p>
<p>// super.finalize(); // Call the base-class version</p>
<p>}</p>
<p>}</p>
<p>{</p>
<p>args) {</p>
<p>to clean up: finalization:</p>
<p>public class TerminationCondition public static void main(String[] Book novel = new Book(true);</p>
<p>// Proper cleanup: novel.checkIn();</p>
<p>// Drop the reference, forget new Book(true);</p>
<p>// Force garbage collection &amp; System.gc();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Error: checked out *///:~</p>
<p>The termination condition is that all Book objects are supposed to be checked in before they are garbage collected, but in main( ), a programmer error doesn’t check in one of the books. Without finalize( ) to verify the termination condition, this can be a difficult bug to find.</p>
<p>Note that System.gc( ) is used to force finalization. But even if it isn’t, it’s highly probable that the errant Book will eventually be discovered through repeated executions of the program (assuming the program allocates enough storage to cause the garbage collector to execute).</p>
<p>You should generally assume that the base-class version of finalize( ) will also be doing something important, and call it using super, as you can see in Book.finalize( ). In this case, it is commented out because it requires exception handling, which we haven’t covered yet.</p>
<p>Exercise 10: (2) Create a class with a finalize( ) method that prints a message. In main( ), create an object of your class. Explain the behavior of your program.</p>
<p>Exercise 11: (4) Modify the previous exercise so that your finalize( ) will always be called.</p>
<p>Exercise 12: (4) Create a class called Tank that can be filled and emptied, and has a termination condition that it must be empty when the object is cleaned up. Write a finalize( ) that verifies this termination condition. In main( ), test the possible scenarios that can occur when your Tank is used.</p>
<subtitle>How a garbage collector works</subtitle>
<p>If you come from a programming language where allocating objects on the heap is expensive, you may naturally assume that Java’s scheme of allocating everything (except primitives) on the heap is also expensive. However, it turns out that the garbage collector can have a significant impact on increasing the speed of object creation. This might sound a bit odd at first—that storage release affects storage allocation—but it’s the way some JVMs work, and it means that allocating storage for heap objects in Java can be nearly as fast as creating storage on the stack in other languages.</p>
<p>For example, you can think of the C++ heap as a yard where each object stakes out its own piece of turf. This real estate can become abandoned sometime later and must be reused. In some JVMs, the Java heap is quite different; it’s more like a conveyor belt that moves forward every time you allocate a new object. This means that object storage allocation is remarkably rapid. The “heap pointer” is simply moved forward into virgin territory, so it’s effectively the same as C++’s stack allocation. (Of course, there’s a little extra overhead for bookkeeping, but it’s nothing like searching for storage.)</p>
<p>You might observe that the heap isn’t in fact a conveyor belt, and if you treat it that way, you’ll start paging memory-moving it on and off disk, so that you can appear to have more memory than you actually do. Paging significantly impacts performance. Eventually, after you create enough objects, you’ll run out of memory. The trick is that the garbage collector steps in, and while it collects the garbage it compacts all the objects in the heap so that you’ve effectively moved the “heap pointer” closer to the beginning of the conveyor belt and farther away from a page fault. The garbage collector rearranges things and makes it possible for the high-speed, infinite-free-heap model to be used while allocating storage.</p>
<p>To understand garbage collection in Java, it’s helpful learn how garbage-collection schemes work in other systems. A simple but slow garbage-collection technique is called reference counting. This means that each object contains a reference counter, and every time a reference is attached to that object, the reference count is increased. Every time a reference goes out of scope or is set to null, the reference count is decreased. Thus, managing reference counts is a small but constant overhead that happens throughout the lifetime of your program. The garbage collector moves through the entire list of objects, and when it finds one with a reference count of zero it releases that storage (however, reference counting schemes often release an object as soon as the count goes to zero). The one drawback is that if objects circularly refer to each other they can have nonzero reference counts while still being garbage. Locating such self-referential groups requires significant extra work for the garbage collector. Reference counting is commonly used to explain one kind of garbage collection, but it doesn’t seem to be used in any JVM implementations.</p>
<p>In faster schemes, garbage collection is not based on reference counting. Instead, it is based on the idea that any non-dead object must ultimately be traceable back to a reference that lives either on the stack or in static storage. The chain might go through several layers of objects. Thus, if you start in the stack and in the static storage area and walk through all the references, you’ll find all the live objects. For each reference that you find, you must trace into the object that it points to and then follow all the references in that object, tracing into the objects they point to, etc., until you’ve moved through the entire Web that originated with the reference on the stack or in static storage. Each object that you move through must still be alive. Note that there is no problem with detached self-referential groups-these are simply not found, and are therefore automatically garbage.</p>
<p>In the approach described here, the JVM uses an adaptive garbage-collection scheme, and what it does with the live objects that it locates depends on the variant currently being used. One of these variants is stop-and-copy. This means that-for reasons that will become apparent-the program is first stopped (this is not a background collection scheme). Then, each live object is copied from one heap to another, leaving behind all the garbage. In addition, as the objects are copied into the new heap, they are packed end-to-end, thus compacting the new heap (and allowing new storage to simply be reeled off the end as previously described).</p>
<p>Of course, when an object is moved from one place to another, all references that point at the object must be changed. The reference that goes from the heap or the static storage area to the object can be changed right away, but there can be other references pointing to this object that will be encountered later during the “walk.” These are fixed up as they are found (you could imagine a table that maps old addresses to new ones).</p>
<p>There are two issues that make these so-called “copy collectors” inefficient. The first is the idea that you have two heaps and you slosh all the memory back and forth between these two separate heaps, maintaining twice as much memory as you actually need. Some JVMs deal with this by allocating the heap in chunks as needed and simply copying from one chunk to another.</p>
<p>The second issue is the copying process itself. Once your program becomes stable, it might be generating little or no garbage. Despite that, a copy collector will still copy all the memory from one place to another, which is wasteful. To prevent this, some JVMs detect that no new garbage is being generated and switch to a different scheme (this is the “adaptive” part). This other scheme is called mark-and-sweep, and it’s what earlier versions of Sun’s JVM used all the time. For general use, mark-and-sweep is fairly slow, but when you know you’re generating little or no garbage, it’s fast.</p>
<p>Mark-and-sweep follows the same logic of starting from the stack and static storage, and tracing through all the references to find live objects. However, each time it finds a live object, that object is marked by setting a flag in it, but the object isn’t collected yet. Only when the marking process is finished does the sweep occur. During the sweep, the dead objects are released. However, no copying happens, so if the collector chooses to compact a fragmented heap, it does so by shuffling objects around.</p>
<p>“Stop-and-copy” refers to the idea that this type of garbage collection is not done in the background; instead, the program is stopped while the garbage collection occurs. In the Sun literature you’ll find many references to garbage collection as a low-priority background process, but it turns out that the garbage collection was not implemented that way in earlier versions of the Sun JVM. Instead, the Sun garbage collector stopped the program when memory got low. Mark-and-sweep also requires that the program be stopped.</p>
<p>As previously mentioned, in the JVM described here memory is allocated in big blocks. If you allocate a large object, it gets its own block. Strict stop-and-copy requires copying every live object from the source heap to a new heap before you can free the old one, which translates to lots of memory. With blocks, the garbage collection can typically copy objects to dead blocks as it collects. Each block has a generation count to keep track of whether it’s alive. In the normal case, only the blocks created since the last garbage collection are compacted; all other blocks get their generation count bumped if they have been referenced from somewhere. This handles the normal case of lots of short-lived temporary objects. Periodically, a full sweep is made-large objects are still not copied (they just get their generation count bumped), and blocks containing small objects are copied and compacted. The JVM monitors the efficiency of garbage collection and if it becomes a waste of time because all objects are long-lived, then it switches to mark-andsweep. Similarly, the JVM keeps track of how successful mark-and-sweep is, and if the heap starts to become fragmented, it switches back to stop-and-copy. This is where the “adaptive” part comes in, so you end up with a mouthful: “Adaptive generational stop-and-copy mark-andsweep.”</p>
<p>There are a number of additional speedups possible in a JVM. An especially important one involves the operation of the loader and what is called a just-in-time (JIT) compiler. A JIT compiler partially or fully converts a program into native machine code so that it doesn’t need to be interpreted by the JVM and thus runs much faster. When a class must be loaded (typically, the first time you want to create an object of that class), the .class file is located, and the bytecodes for that class are brought into memory. At this point, one approach is to simply JIT compile all the code, but this has two drawbacks: It takes a little more time, which, compounded throughout the life of the program, can add up; and it increases the size of the executable (bytecodes are significantly more compact than expanded JIT code), and this might cause paging, which definitely slows down a program. An alternative approach is lazy evaluation, which means that the code is not JIT compiled until necessary. Thus, code that never gets executed might never be JIT compiled. The Java HotSpot technologies in recent JDKs take a similar approach by increasingly optimizing a piece of code each time it is executed, so the more the code is executed, the faster it gets.</p>
</section>
<section>
<title>
<p>Member initialization</p></title><empty-line/>
<p>Java goes out of its way to guarantee that variables are properly initialized before they are used. In the case of a method’s local variables, this guarantee comes in the form of a compiletime error. So if you say:</p>
<p>void f() { int i;</p>
<p>i++; // Error -- i not initialized</p>
<p>}</p>
<p>you’ll get an error message that says that i might not have been initialized. Of course, the compiler could have given i a default value, but an uninitialized local variable is probably a programmer error, and a default value would have covered that up. Forcing the programmer to provide an initialization value is more likely to catch a bug.</p>
<p>If a primitive is a field in a class, however, things are a bit different. As you saw in the Everything Is an Object chapter, each primitive field of a class is guaranteed to get an initial value. Here’s a program that verifies this, and shows the values:</p>
<p>//: initialization/InitialValues.java // Shows default initial values. import static net.mindview.util.Print.*;</p>
<p>public class InitialValues { boolean t; char c; byte b; short s; int i; long l; float f; double d;</p>
<p>InitialValues reference; void printInitialValues() {</p>
<p>print(&quot;Data type    Initial value&quot;);</p>
<table>
<tr><td>print(&quot;boolean</td><td>&quot; +</td><td>t);</td><td></td></tr>
<tr><td>print(&quot;char</td><td colspan="2">[&quot; + c</td><td>+ &quot;]&quot;);</td></tr>
<tr><td>print(&quot;byte</td><td>&quot; +</td><td>b)</td><td></td></tr>
<tr><td>print(&quot;short</td><td>&quot; +</td><td>s);</td><td></td></tr>
<tr><td>print(&quot;int</td><td>&quot; +</td><td>i);</td><td></td></tr>
<tr><td>print(&quot;long</td><td>&quot; +</td><td>l);</td><td></td></tr>
<tr><td>print(&quot;float</td><td>&quot; +</td><td>f)</td><td></td></tr>
<tr><td>print(&quot;double</td><td>&quot; +</td><td>d);</td><td></td></tr>
<tr><td>print(&quot;reference</td><td>&quot; +</td><td colspan="2">reference)</td></tr>
</table>
<p>}</p>
<p>public static void main(String[] args) { InitialValues iv = new InitialValues(); iv.printInitialValues();</p>
<p>/* You could also say:</p>
<p>new InitialValues().printInitialValues();</p>
<p>*/</p>
<p>}</p>
<p>} /* Output:</p>
<p>Data type    Initial value</p>
<table>
<tr><td>boolean</td><td>false</td></tr>
<tr><td>char</td><td>[ ]</td></tr>
<tr><td>byte</td><td>0</td></tr>
<tr><td>short</td><td>0</td></tr>
<tr><td>int</td><td>0</td></tr>
<tr><td>long</td><td>0</td></tr>
<tr><td>float</td><td>0.0</td></tr>
<tr><td>double</td><td>0.0</td></tr>
<tr><td>reference</td><td>null</td></tr>
<tr><td>*///:~</td><td></td></tr>
</table>
<p>You can see that even though the values are not specified, they automatically get initialized (the char value is a zero, which prints as a space). So at least there’s no threat of working with uninitialized variables.</p>
<p>When you define an object reference inside a class without initializing it to a new object, that reference is given a special value of null.</p>
<subtitle>Specifying initialization</subtitle>
<p>What happens if you want to give a variable an initial value? One direct way to do this is simply to assign the value at the point you define the variable in the class. (Notice you cannot do this in C++, although C++ novices always try.) Here the field definitions in class InitialValues are changed to provide initial values:</p>
<p>//: initialization/InitialValues2.java // Providing explicit initial values.</p>
<p>public class InitialValues2 { boolean bool = true; char ch = ‘x’; byte b = 47; short s = 0xff; int i = 999; long lng = 1; float f = 3.14f; double d = 3.14159;</p>
<p>} ///:~</p>
<p>You can also initialize non-primitive objects in this same way. If Depth is a class, you can create a variable and initialize it like so:</p>
<p>//: initialization/Measurement.java class Depth {}</p>
<p>public class Measurement {</p>
<p>Depth d = new Depth();</p>
<p>// ...</p>
<p>} ///:~</p>
<p>If you haven’t given d an initial value and you try to use it anyway, you’ll get a runtime error called an exception (covered in the Error Handling with Exceptions chapter).</p>
<p>You can even call a method to provide an initialization value:</p>
<p>//: initialization/Methodlnit.java public class MethodInit { int i = f(); int f() { return 11; }</p>
<p>4</p>
<p>This method can have arguments, of course, but those arguments cannot be other class members that haven’t been initialized yet. Thus, you can do this:</p>
<p>//: initialization/MethodInit2.java public class MethodInit2 { int i = f(); int j = g(i); int f() { return 11; } int g(int n) { return n * 10; }</p>
<p>} ///:~</p>
<p>But you cannot do this:</p>
<p>//: initialization/MethodInit3.java public class MethodInit3 {</p>
<p>//! int j = g(i); // Illegal forward reference</p>
<p>int i = f();</p>
<p>int f() { return 11; }</p>
<p>int g(int n) { return n * 10; }</p>
<p>} ///:~</p>
<p>This is one place in which the compiler, appropriately, does complain about forward referencing, since this has to do with the order of initialization and not the way the program is compiled.</p>
<p>This approach to initialization is simple and straightforward. It has the limitation that every object of type InitialValues will get these same initialization values. Sometimes this is exactly what you need, but at other times you need more flexibility.</p>
</section>
<section>
<title>
<p>Constructor initialization</p></title><empty-line/>
<p>The constructor can be used to perform initialization, and this gives you greater flexibility in your programming because you can call methods and perform actions at run time to determine the initial values. There’s one thing to keep in mind, however: You aren’t precluding the automatic initialization, which happens before the constructor is entered. So, for example, if you say:</p>
<p>//: initialization/Counter.java public class Counter { int i;</p>
<p>Counter() { i = 7; }</p>
<p>// ...</p>
<p>} ///:~</p>
<p>then i will first be initialized to 0, then to 7. This is true with all the primitive types and with object references, including those that are given explicit initialization at the point of definition. For this reason, the compiler doesn’t try to force you to initialize elements in the constructor at any particular place, or before they are used-initialization is already guaranteed.</p>
<subtitle>Order of initialization</subtitle>
<p>Within a class, the order of initialization is determined by the order that the variables are defined within the class. The variable definitions may be scattered throughout and in</p>
<p>between method definitions, but the variables are initialized before any methods can be called—even the constructor. For example:</p>
<p>//: initialization/OrderOflnitialization.java // Demonstrates initialization order. import static net.mindview.util.Print.*;</p>
<p>// When the constructor is called to create a // Window object, you’ll see a message: class Window {</p>
<p>Window(int marker) { print(&quot;Window(&quot; + marker + &quot;)&quot;); }</p>
<p>}</p>
<p>class House {</p>
<p>Window w1 = new Window(1); // Before constructor House() {</p>
<p>// Show that we’re in the constructor: print(&quot;House()&quot;);</p>
<p>w3 = new Window(33); // Reinitialize w3</p>
<p>}</p>
<p>Window w2 = new Window(2); // After constructor void f() { print(&quot;f()&quot;); }</p>
<p>Window w3 = new Window(3); // At end</p>
<p>}</p>
<p>public class OrderOfInitialization {</p>
<p>public static void main(String[] args) {</p>
<p>House h = new House();</p>
<p>h.f(); // Shows that construction is done</p>
<p>}</p>
<p>} /* Output:</p>
<p>Window(1)</p>
<p>Window(2)</p>
<p>Window(3)</p>
<p>House()</p>
<p>Window(33)</p>
<p>f()</p>
<p>*///:~</p>
<p>In House, the definitions of the Window objects are intentionally scattered about to prove that they’ll all get initialized before the constructor is entered or anything else can happen. In addition, w3 is reinitialized inside the constructor.</p>
<p>From the output, you can see that the w3 reference gets initialized twice: once before and once during the constructor call. (The first object is dropped, so it can be garbage collected later.) This might not seem efficient at first, but it guarantees proper initialization—what would happen if an overloaded constructor were defined that did not initialize w3 and there wasn’t a “default” initialization for w3 in its definition?</p>
<subtitle>static data initialization</subtitle>
<p>There’s only a single piece of storage for a static, regardless of how many objects are created. You can’t apply the static keyword to local variables, so it only applies to fields. If a field is a static primitive and you don’t initialize it, it gets the standard initial value for its type. If it’s a reference to an object, the default initialization value is null.</p>
<p>If you want to place initialization at the point of definition, it looks the same as for nonstatics.</p>
<p>To see when the static storage gets initialized, here’s an example:</p>
<p>//: initialization/StaticInitialization.java // Specifying initial values in a class definition. import static net.mindview.util.Print.*;</p>
<p>class Bowl {</p>
<p>Bowl(int marker) {</p>
<p>print(&quot;Bowl(&quot; + marker + &quot;)&quot;);</p>
<p>}</p>
<p>void f1(int marker) {</p>
<p>print(&quot;f1(&quot; + marker + &quot;)&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Table {</p>
<p>static Bowl bowll = new Bowl(1);</p>
<p>Table() {</p>
<p>print(&quot;Table()&quot;);</p>
<p>bowl2.f1(1);</p>
<p>}</p>
<p>void f2(int marker) {</p>
<p>print(&quot;f2(&quot; + marker + &quot;)&quot;);</p>
<p>}</p>
<p>static Bowl bowl2 = new Bowl(2);</p>
<p>}</p>
<p>class Cupboard {</p>
<p>Bowl bowl3 = new Bowl(3);</p>
<p>static Bowl bowl4 = new Bowl(4);</p>
<p>Cupboard() {</p>
<p>print(&quot;Cupboard()&quot;);</p>
<p>bowl4.f1(2);</p>
<p>}</p>
<p>void f3(int marker) {</p>
<p>print(&quot;f3(&quot; + marker + &quot;)&quot;);</p>
<p>}</p>
<p>static Bowl bowl5 = new Bowl(5);</p>
<p>}</p>
<p>public class StaticInitialization {</p>
<p>public static void main(String[] args) { print(&quot;Creating new Cupboard() in main&quot;); new Cupboard();</p>
<p>print(&quot;Creating new Cupboard() in main&quot;);</p>
<p>new Cupboard();</p>
<p>table.f2(1);</p>
<p>cupboard.f3(1);</p>
<p>}</p>
<p>static Table table = new Table();</p>
<p>static Cupboard cupboard = new Cupboard();</p>
<p>} /* Output:</p>
<p>Bowl(1)</p>
<p>Bowl(2)</p>
<p>Table()</p>
<p>f1(1)</p>
<p>Bowl(4)</p>
<p>Bowl(5)</p>
<p>Bowl(3)</p>
<p>Cupboard()</p>
<p>f1(2)</p>
<p>Creating new Cupboard() in main Bowl(3)</p>
<p>Cupboard()</p>
<p>f1(2)</p>
<p>Cupboard()</p>
<p>in main</p>
<p>Creating new</p>
<p>Bowl(3)</p>
<p>Cupboard()</p>
<p>f1(2)</p>
<p>f2(1)</p>
<p>f3(1)</p>
<p>*///:~</p>
<p>Bowl allows you to view the creation of a class, and Table and Cupboard have static members of Bowl scattered through their class definitions. Note that Cupboard creates a non-static Bowl bowl3 prior to the static definitions.</p>
<p>From the output, you can see that the static initialization occurs only if it’s necessary. If you don’t create a Table object and you never refer to Table.bowl1 or Table.bowl2, the static Bowl bowl1 and bowl2 will never be created. They are initialized only when the first Table object is created (or the first static access occurs). After that, the static objects are not reinitialized.</p>
<p>The order of initialization is statics first, if they haven’t already been initialized by a previous object creation, and then the non-static objects. You can see the evidence of this in the output. To execute main( ) (a static method), the StaticInitialization class must be loaded, and its static fields table and cupboard are then initialized, which causes those classes to be loaded, and since they both contain static Bowl objects, Bowl is then loaded. Thus, all the classes in this particular program get loaded before main( ) starts. This is usually not the case, because in typical programs you won’t have everything linked together by statics as you do in this example.</p>
<p>To summarize the process of creating an object, consider a class called Dog:</p>
<p>1.    Even though it doesn’t explicitly use the static keyword, the constructor is actually a static method. So the first time an object of type Dog is created, or the first time a static method or static field of class Dog is accessed, the Java interpreter must locate Dog.class, which it does by searching through the classpath.</p>
<p>2.    As Dog.class is loaded (creating a Class object, which you’ll learn about later), all of its static initializers are run. Thus, static initialization takes place only once, as the Class object is loaded for the first time.</p>
<p>3.    When you create a new Dog( ), the construction process for a Dog object first allocates enough storage for a Dog object on the heap.</p>
<p>4.    This storage is wiped to zero, automatically setting all the primitives in that Dog object to their default values (zero for numbers and the equivalent for boolean and char) and the references to null.</p>
<p>5.    Any initializations that occur at the point of field definition are executed.</p>
<p>6.    Constructors are executed. As you shall see in the Reusing Classes chapter, this might actually involve a fair amount of activity, especially when inheritance is involved.</p>
<subtitle>Explicit static initialization</subtitle>
<p>Java allows you to group other static initializations inside a special “static clause” (sometimes called a static block) in a class. It looks like this:</p>
<p>//: initialization/Spoon.java public class Spoon { static int i; static { i = 47;</p>
<p>}</p>
<p>} ///:~</p>
<p>It appears to be a method, but it’s just the static keyword followed by a block of code. This code, like other static initializations, is executed only once: the first time you make an object of that class or the first time you access a static member of that class (even if you never make an object of that class). For example:</p>
<p>//: initialization/ExplicitStatic.java</p>
<p>// Explicit static initialization with the &quot;static&quot; clause. import static net.mindview.util.Print.*;</p>
<p>class Cup {</p>
<p>Cup(int marker) {</p>
<p>print(&quot;Cup(&quot; + marker + &quot;)&quot;);</p>
<p>}</p>
<p>void f(int marker) {</p>
<p>print(&quot;f(&quot; + marker + &quot;)&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Cups {</p>
<p>static Cup cupl; static Cup cup2; static {</p>
<p>cupl = new Cup(l); cup2 = new Cup(2);</p>
<p>}</p>
<p>Cups() {</p>
<p>print(&quot;Cups()&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class ExplicitStatic {</p>
<p>public static void main(String[] args) { print(&quot;Inside main()&quot;);</p>
<p>Cups.cup1.f(99); // (1)</p>
<p>}</p>
<p>// static Cups cupsl = new Cups(); // (2)</p>
<p>// static Cups cups2 = new Cups(); // (2)</p>
<p>} /* Output:</p>
<p>Inside main()</p>
<p>Cup(l)</p>
<p>Cup(2)</p>
<p>f(99)</p>
<p>*///:~</p>
<p>The static initializers for Cups run when either the access of the static object cupl occurs on the line marked (l), or if line (l) is commented out and the lines marked (2) are uncommented. If both (1) and (2) are commented out, the static initialization for Cups never occurs, as you can see from the output. Also, it doesn’t matter if one or both of the lines marked (2) are uncommented; the static initialization only occurs once.</p>
<p>Exercise 13: (1) Verify the statements in the previous paragraph.</p>
<p>Exercise 14: (1) Create a class with a static String field that is initialized at the point of definition, and another one that is initialized by the static block. Add a static method that prints both fields and demonstrates that they are both initialized before they are used.</p>
<subtitle>Non-static instance initialization</subtitle>
<p>Java provides a similar syntax, called instance initialization, for initializing non-static variables for each object. Here’s an example:</p>
<p>//: initialization/Mugs.java // Java &quot;Instance Initialization.&quot; import static net.mindview.util.Print.*;</p>
<p>class Mug {</p>
<p>Mug(int marker) {</p>
<p>print(&quot;Mug(&quot; + marker + &quot;)&quot;);</p>
<p>}</p>
<p>void f(int marker) {</p>
<p>print(&quot;f(&quot; + marker + &quot;)&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class Mugs {</p>
<p>Mug mugl;</p>
<p>Mug mug2;</p>
<p>{</p>
<p>mugl = new Mug(l); mug2 = new Mug(2); print(&quot;mug1 &amp; mug2 initialized&quot;);</p>
<p>}</p>
<p>Mugs() {</p>
<p>print(&quot;Mugs()&quot;);</p>
<p>}</p>
<p>Mugs(int i) {</p>
<p>print(&quot;Mugs(int)&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { print(&quot;Inside main()&quot;); new Mugs();</p>
<p>print(&quot;new Mugs() completed&quot;); new Mugs(l);</p>
<p>print(&quot;new Mugs(l) completed&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Inside main()</p>
<p>Mug(l)</p>
<p>Mug(2)</p>
<p>mugl &amp; mug2 initialized Mugs()</p>
<p>new Mugs() completed Mug(l)</p>
<p>Mug(2)</p>
<p>mugl &amp; mug2 initialized Mugs(int)</p>
<p>new Mugs(l) completed *///:~</p>
<p>You can see that the instance initialization clause:</p>
<p>{</p>
<p>mugl = new Mug(1); mug2 = new Mug(2); print(&quot;mug1 &amp; mug2 initialized&quot;);</p>
<p>looks exactly like the static initialization clause except for the missing static keyword. This syntax is necessary to support the initialization of anonymous inner classes (see the Inner Classes chapter), but it also allows you to guarantee that certain operations occur regardless of which explicit constructor is called. From the output, you can see that the instance initialization clause is executed before either one of the constructors.</p>
<p>Exercise 15: (1) Create a class with a String that is initialized using instance initialization.</p>
</section>
<section>
<title>
<p>Array initialization</p></title><empty-line/>
<p>An array is simply a sequence of either objects or primitives that are all the same type and are packaged together under one identifier name. Arrays are defined and used with the square-brackets indexing operator [ ]. To define an array reference, you simply follow your type name with empty square brackets:</p>
<p>int[] al;</p>
<p>You can also put the square brackets after the identifier to produce exactly the same meaning:</p>
<p>int a1[];</p>
<p>This conforms to expectations from C and C++ programmers. The former style, however, is probably a more sensible syntax, since it says that the type is “an int array.” That style will be used in this book.</p>
<p>The compiler doesn’t allow you to tell it how big the array is. This brings us back to that issue of “references.” All that you have at this point is a reference to an array (you’ve allocated enough storage for that reference), and there’s been no space allocated for the array object itself. To create storage for the array, you must write an initialization expression. For arrays, initialization can appear anywhere in your code, but you can also use a special kind of initialization expression that must occur at the point where the array is created. This special initialization is a set of values surrounded by curly braces. The storage allocation (the equivalent of using new) is taken care of by the compiler in this case. For example:</p>
<p>int[] al = { 1, 2, 3, 4, 5 };</p>
<p>So why would you ever define an array reference without an array? int[] a2;</p>
<p>Well, it’s possible to assign one array to another in Java, so you can say: a2 = a1;</p>
<p>What you’re really doing is copying a reference, as demonstrated here:</p>
<p>//: initialization/ArraysOfPrimitives.java import static net.mindview.util.Print.*;</p>
<p>public class ArraysOfPrimitives {</p>
<p>public static void main(String[] args) { int[] a1 = { 1, 2, 3, 4, 5 }; int[] a2; a2 = a1;</p>
<p>for(int i = 0; i &lt; a2.length; i++) a2[i] = a2[i] + 1; for(int i = 0; i &lt; a1.length; i++) print(&quot;a1[&quot; + i + &quot;] = &quot; + a1[i]);</p>
<p>}</p>
<p>} /* Output: a1[0] = 2 a1[1] = 3 a1[2] = 4 a1[3] = 5 a1[4] = 6 *///:~</p>
<p>You can see that ai is given an initialization value but a2 is not; a2 is assigned later—in this case, to another array. Since a2 and ai are then aliased to the same array, the changes made via a2 are seen in ai.</p>
<p>All arrays have an intrinsic member (whether they’re arrays of objects or arrays of primitives) that you can query—but not change—to tell you how many elements there are in the array. This member is length. Since arrays in Java, like C and C++, start counting from element zero, the largest element you can index is length - 1. If you go out of bounds, C and C++ quietly accept this and allow you to stomp all over your memory, which is the source of many infamous bugs. However, Java protects you against such problems by causing a runtime error (an exception) if you step out of bounds.<a l:href="#bookmark21" type="note"><sup>22</sup></a><sup></sup></p>
<p>What if you don’t know how many elements you’re going to need in your array while you’re writing the program? You simply use new to create the elements in the array. Here, new works even though it’s creating an array of primitives (new won’t create a non-array primitive):</p>
<p>//: initialization/ArrayNew.java // Creating arrays with new. import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ArrayNew {</p>
<p>public static void main(String[] args) { int[] a;</p>
<p>Random rand = new Random(47); a = new int[rand.nextInt(20)]; print(&quot;length of a = &quot; + a.length); print(Arrays.toString(a));</p>
<p>}</p>
<p>} /* Output: length of a = 18</p>
<p>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</p>
<p>*///:~</p>
<p>The size of the array is chosen at random by using the Random.nextInt( ) method, which produces a value between zero and that of its argument. Because of the randomness, it’s clear that array creation is actually happening at run time. In addition, the output of this program shows that array elements of primitive types are automatically initialized to “empty” values. (For numerics and char, this is zero, and for boolean, it’s false.)</p>
<p>The Arrays.toString( ) method, which is part of the standard java.util library, produces a printable version of a one-dimensional array.</p>
<p>Of course, in this case the array could also have been defined and initialized in the same statement:</p>
<p>int[] a = new int[rand.nextInt(20)];</p>
<p>This is the preferred way to do it, if you can.</p>
<p>If you create a non-primitive array, you create an array of references. Consider the wrapper type Integer, which is a class and not a primitive:</p>
<p>//: initialization/ArrayClassObj.java // Creating an array of nonprimitive objects. import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ArrayClassObj {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47);</p>
<p>Integer[] a = new Integer[rand.nextInt(20)]; print(&quot;length of a = &quot; + a.length); for(int i = 0; i &lt; a.length; i++)</p>
<p>a[i] = rand.nextInt(500); // Autoboxing print(Arrays.toString(a));</p>
<p>}</p>
<p>} /* Output: (Sample) length of a = 18</p>
<p>[55, 193, 361, 461, 429, 368, 200, 22, 207, 288, 128, 51, 89, 309, 278, 498, 361, 20]</p>
<p>*///:~</p>
<p>Here, even after new is called to create the array:</p>
<p>Integer[] a = new Integer[rand.nextInt(20)];</p>
<p>it’s only an array of references, and the initialization is not complete until the reference itself is initialized by creating a new Integer object (via autoboxing, in this case):</p>
<p>a[i] = rand.nextInt(500);</p>
<p>If you forget to create the object, however, you’ll get an exception at run time when you try to use the empty array location.</p>
<p>It’s also possible to initialize arrays of objects by using the curly brace-enclosed list. There are two forms:</p>
<p>//: initialization/ArrayInit.java // Array initialization. import java.util.*;</p>
<p>public class ArrayInit {</p>
<p>public static void main(String[] args) {</p>
<p>Integer[] a = {</p>
<p>new Integer(l), new Integer(2),</p>
<p>3, // Autoboxing</p>
<p>};</p>
<p>Integer[] b = new Integer[]{ new Integer(l), new Integer(2),</p>
<p>3, // Autoboxing</p>
<p>};</p>
<p>System.out.println(Arrays.toString(a));</p>
<p>System.out.println(Arrays.toString(b));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[l, 2, 3]</p>
<p>[l, 2, 3]</p>
<p>*///:~</p>
<p>In both cases, the final comma in the list of initializers is optional. (This feature makes for easier maintenance of long lists.)</p>
<p>Although the first form is useful, it’s more limited because it can only be used at the point where the array is defined. You can use the second and third forms anywhere, even inside a method call. For example, you could create an array of String objects to pass to the main( ) of another method, to provide alternate command-line arguments to that main( ):</p>
<p>//: initialization/DynamicArray.java // Array initialization.</p>
<p>public class DynamicArray {</p>
<p>public static void main(String[] args) {</p>
<p>Other.main(new String[]{ &quot;fiddle&quot;, &quot;de&quot;, &quot;dum&quot; });</p>
<p>}</p>
<p>}</p>
<p>class Other {</p>
<p>public static void main(String[] args) { for(String s : args)</p>
<p>System.out.print(s + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output: fiddle de dum *///:~</p>
<p>The array created for the argument of Other.main( ) is created at the point of the method call, so you can even provide alternate arguments at the time of the call.</p>
<p>Exercise 16: (1) Create an array of String objects and assign a String to each element. Print the array by using a for loop.</p>
<p>Exercise 17: (2) Create a class with a constructor that takes a String argument. During construction, print the argument. Create an array of object references to this class, but don’t actually create objects to assign into the array. When you run the program, notice whether the initialization messages from the constructor calls are printed.</p>
<p>Exercise 18: (1) Complete the previous exercise by creating objects to attach to the array of references.</p>
<subtitle>Variable argument lists</subtitle>
<p>The second form provides a convenient syntax to create and call methods that can produce an effect similar to C’s variable argument lists (known as “varargs” in C). These can include unknown quantities of arguments as well as unknown types. Since all classes are ultimately inherited from the common root class Object (a subject you will learn more about as this book progresses), you can create a method that takes an array of Object and call it like this:</p>
<p>//: initialization/VarArgs.java</p>
<p>// Using array syntax to create variable argument lists. class A {}</p>
<p>public class VarArgs {</p>
<p>static void printArray(Object[] args) { for(Object obj : args)</p>
<p>System.out.print(obj + &quot; &quot;);</p>
<p>System.out.println();</p>
<p>}</p>
<p>public static void main(String[] args) { printArray(new Object[]{</p>
<p>new Integer(47), new Float(3.14), new Double(11.11)</p>
<p>});</p>
<p>printArray(new Object[]{&quot;one&quot;, &quot;two&quot;, &quot;three&quot; }); printArray(new Object[]{new A(), new A(), new A()});</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>47 3.14 11.11 one two three</p>
<p>A@1a46e30 A@3e25a5 A@19821f *///:~</p>
<p>You can see that print( ) takes an array of Object, then steps through the array using the foreach syntax and prints each one. The standard Java library classes produce sensible output, but the objects of the classes created here print the class name, followed by an ‘@’ sign and hexadecimal digits. Thus, the default behavior (if you don’t define a toString( ) method for your class, which will be described later in the book) is to print the class name and the address of the object.</p>
<p>You may see pre-Java SE5 code written like the above in order to produce variable argument lists. In Java SE5, however, this long-requested feature was finally added, so you can now use ellipses to define a variable argument list, as you can see in printArray( ):</p>
<p>//: initialization/NewVarArgs.java</p>
<p>// Using array syntax to create variable argument lists.</p>
<p>public class NewVarArgs {</p>
<p>static void printArray(Object... args) { for(Object obj : args)</p>
<p>System.out.print(obj + &quot; &quot;);</p>
<p>System.out.println();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>// Can take individual elements: printArray(new Integer(47), new Float(3.14), new Double(11.11)); printArray(47, 3.14F, 11.11); printArray(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;); printArray(new A(), new A(), new A());</p>
<p>// Or an array:</p>
<p>printArray((Object[])new Integer[]{ 1, 2, 3, 4 }); printArray(); // Empty list is OK</p>
<p>} /* Output: (75% match)</p>
<p>47 3.14 11.11 47 3.14 11.11 one two three</p>
<p>A@1bab50a A@c3c749 A@150bd4d 1 2 3 4 *///:~</p>
<p>With varargs, you no longer have to explicitly write out the array syntax—the compiler will actually fill it in for you when you specify varargs. You’re still getting an array, which is why print( ) is able to use foreach to iterate through the array. However, it’s more than just an automatic conversion from a list of elements to an array. Notice the second-to-last line in the program, where an array of Integer (created using autoboxing) is cast to an Object array (to remove a compiler warning) and passed to printArray( ). Clearly, the compiler sees that this is already an array and performs no conversion on it. So if you have a group of items you can pass them in as a list, and if you already have an array it will accept that as the variable argument list.</p>
<p>The last line of the program shows that it’s possible to pass zero arguments to a vararg list. This is helpful when you have optional trailing arguments:</p>
<p>//: initialization/OptionalTrailingArguments.java</p>
<p>public class OptionalTrailingArguments {</p>
<p>static void f(int required, String... trailing) { System.out.print(&quot;required: &quot; + required + &quot; &quot;); for(String s : trailing)</p>
<p>System.out.print(s + &quot; &quot;);</p>
<p>System.out.println();</p>
<p>}</p>
<p>public static void main(String[] args) { f(1, &quot;one&quot;); f(2, &quot;two&quot;, &quot;three&quot;); f(0);</p>
<p>}</p>
<p>} /* Output: required: 1 one required: 2 two three required: 0 *///:~</p>
<p>This also shows how you can use varargs with a specified type other than Object. Here, all the varargs must be String objects. It’s possible to use any type of argument in varargs, including a primitive type. The following example also shows that the vararg list becomes an array, and if there’s nothing in the list it’s an array of size zero:</p>
<p>//: initialization/VarargType.java</p>
<p>public class VarargType {</p>
<p>static void f(Character... args) {</p>
<p>System.out.print(args.getClass());</p>
<p>System.out.println(&quot; length &quot; + args.length);</p>
<p>}</p>
<p>static void g(int... args) {</p>
<p>System.out.print(args.getClass());</p>
<p>System.out.println(&quot; length &quot; + args.length);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>f(‘a&apos;);</p>
<p>f();</p>
<p>g(i);</p>
<p>g();</p>
<p>System.out.println(<sup>M</sup>int[]: &quot; + new int[0].getClass());</p>
<p>}</p>
<p>} /* Output:</p>
<p>class [Ljava.lang.Character; length 1 class [Ljava.lang.Character; length 0 class [I length 1 class [I length 0 int[]: class [I *///:~</p>
<p>The getClass( ) method is part of Object, and will be explored fully in the Type Information chapter. It produces the class of an object, and when you print this class, you see an encoded string representing the class type. The leading ‘[‘ indicates that this is an array of the type that follows. The ‘I’ is for a primitive int; to double-check, I created an array of int in the last line and printed its type. This verifies that using varargs does not depend on autoboxing, but that it actually uses the primitive types.</p>
<p>Varargs do work in harmony with autoboxing, however. For example:</p>
<p>//: initialization/AutoboxingVarargs.java</p>
<p>public class AutoboxingVarargs {</p>
<p>public static void f(Integer... args) { for(Integer i : args)</p>
<p>System.out.print(i + &quot; &quot;);</p>
<p>System.out.println();</p>
<p>}</p>
<p>public static void main(String[] args) { f(new Integer(l), new Integer(2)); f(4, 5, 6, 7, 8, 9); f(10, new Integer(ll), 12);</p>
<p>}</p>
<p>} /* Output:</p>
<p>1 2</p>
<p>4 5 6 7 8 9 10 11 12 *///:~</p>
<p>Notice that you can mix the types together in a single argument list, and autoboxing selectively promotes the int arguments to Integer.</p>
<p>Varargs complicate the process of overloading, although it seems safe enough at first: //: initialization/OverloadingVarargs.java</p>
<p>public class OverloadingVarargs { static void f(Character... args) {</p>
<p>System.out.print(&quot;first&quot;); for(Character c : args)</p>
<p>System.out.print(&quot; &quot; + c);</p>
<p>System.out.println();</p>
<p>}</p>
<p>static void f(Integer... args) {</p>
<p>System.out.print(&quot;second&quot;); for(Integer i : args)</p>
<p>System.out.print(&quot; &quot; + i);</p>
<p>System.out.println();</p>
<p>static void f(Long... args) { System.out.println(&quot;third&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { f(‘a’, ‘b’, ‘c’); f(1); f(2, 1); f(0);</p>
<p>f(0L);</p>
<p>//! f(); // Won’t compile -- ambiguous</p>
<p>}</p>
<p>} /* Output: first a b c second 1 second 2 1 second 0 third *///:~</p>
<p>In each case, the compiler is using autoboxing to match the overloaded method, and it calls the most specifically matching method.</p>
<p>But when you call f( ) without arguments, it has no way of knowing which one to call. Although this error is understandable, it will probably surprise the client programmer.</p>
<p>You might try solving the problem by adding a non-vararg argument to one of the methods:</p>
<p>//: initialization/OverloadingVarargs2.java // {CompileTimeError} (Won’t compile)</p>
<p>public class OverloadingVarargs2 {</p>
<p>static void f(float i, Character... args) { System.out.println(&quot;first&quot;);</p>
<p>}</p>
<p>static void f(Character... args) {</p>
<p>System.out.print(&quot;second&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { f(1, ‘a’); f(‘a’, ‘b’);</p>
<p>}</p>
<p>} ///:~</p>
<p>The {CompileTimeError} comment tag excludes the file from this book’s Ant build. If you compile it by hand you’ll see the error message:</p>
<p>reference to f is ambiguous, both method fffloatjava.lang.Character...) in OverloadingVarargs2 and method f(java.lang.Character...) in OverloadingVarargs2 match</p>
<p>If you give both methods a non-vararg argument, it works:</p>
<p>//: initialization/OverloadingVarargs3.java</p>
<p>public class OverloadingVarargs3 {</p>
<p>static void f(float i, Character... args) { System.out.println(&quot;first&quot;);</p>
<p>}</p>
<p>static void f(char c, Character... args) {</p>
<p>System.out.println(&quot;second&quot;);</p>
<p>public static void main(String[] args) { f(1, ‘a&apos;); f(‘a&apos;, ‘b&apos;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>first</p>
<p>second</p>
<p>*///:~</p>
<p>You should generally only use a variable argument list on one version of an overloaded method. Or consider not doing it at all.</p>
<p>Exercise 19: (2) Write a method that takes a vararg String array. Verify that you can pass either a comma-separated list of Strings or a String[] into this method.</p>
<p>Exercise 20: (1) Create a main( ) that uses varargs instead of the ordinary main( ) syntax. Print all the elements in the resulting args array. Test it with various numbers of command-line arguments.</p>
</section>
<section>
<title>
<p>Enumerated types</p></title><empty-line/>
<p>An apparently small addition in Java SE5 is the enum keyword, which makes your life much easier when you need to group together and use a set of enumerated types. In the past you would have created a set of constant integral values, but these do not naturally restrict themselves to your set and thus are riskier and more difficult to use. Enumerated types are a common enough need that C, C++, and a number of other languages have always had them. Before Java SE5, Java programmers were forced to know a lot and be quite careful when they wanted to properly produce the enum effect. Now Java has enum, too, and it’s much more full-featured than what you find in C/C++. Here’s a simple example:</p>
<p>//: initialization/Spiciness.java</p>
<p>public enum Spiciness {</p>
<p>NOT, MILD, MEDIUM, HOT, FLAMING } ///:~</p>
<p>This creates an enumerated type called Spiciness with five named values. Because the instances of enumerated types are constants, they are in all capital letters by convention (if there are multiple words in a name, they are separated by underscores).</p>
<p>To use an enum, you create a reference of that type and assign it to an instance:</p>
<p>//: initialization/SimpleEnumUse.java</p>
<p>public class SimpleEnumUse {</p>
<p>public static void main(String[] args) {</p>
<p>Spiciness howHot = Spiciness.MEDIUM;</p>
<p>System.out.println(howHot);</p>
<p>}</p>
<p>} /* Output:</p>
<p>MEDIUM</p>
<p>*///:~</p>
<p>The compiler automatically adds useful features when you create an enum. For example, it creates a toString( ) so that you can easily display the name of an enum instance, which is how the print statement above produced its output. The compiler also creates an ordinal( )</p>
<p>method to indicate the declaration order of a particular enum constant, and a static values( ) method that produces an array of values of the enum constants in the order that they were declared:</p>
<p>//: initialization/EnumOrder.java</p>
<p>public class EnumOrder {</p>
<p>public static void main(String[] args) { for(Spiciness s : Spiciness.values())</p>
<p>System.out.println(s + &quot;, ordinal &quot; + s.ordinal());</p>
<p>}</p>
<p>} /* Output:</p>
<p>NOT, ordinal 0 MILD, ordinal 1 MEDIUM, ordinal 2 HOT, ordinal 3 FLAMING, ordinal 4 *///:~</p>
<p>Although enums appear to be a new data type, the keyword only produces some compiler behavior while generating a class for the enum, so in many ways you can treat an enum as if it were any other class. In fact, enums are classes and have their own methods.</p>
<p>An especially nice feature is the way that enums can be used inside switch statements:</p>
<p>//: initialization/Burrito.java</p>
<p>public class Burrito {</p>
<p>Spiciness degree;</p>
<p>public Burrito(Spiciness degree) { this.degree = degree;} public void describe() {</p>
<p>System.out.print(&quot;This burrito is &quot;); switch(degree) {</p>
<p>case NOT:    System.out.println(&quot;not spicy at all.&quot;);</p>
<p>break;</p>
<p>case MILD:</p>
<p>case MEDIUM: System.out.println(&quot;a little hot.&quot;); break;</p>
<p>case HOT: case FLAMING:</p>
<p>default:    System.out.println(&quot;maybe too hot.&quot;);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Burrito</p>
<p>plain = new Burrito(Spiciness.NOT), greenChile = new Burrito(Spiciness.MEDIUM), jalapeno = new Burrito(Spiciness.HOT); plain.describe(); greenChile.describe(); jalapeno.describe();</p>
<p>}</p>
<p>} /* Output:</p>
<p>This burrito is not spicy at all.</p>
<p>This burrito is a little hot.</p>
<p>This burrito is maybe too hot.</p>
<p>*///:~</p>
<p>Since a switch is intended to select from a limited set of possibilities, it’s an ideal match for an enum. Notice how the enum names can produce a much clearer indication of what the program means to do.</p>
<p>In general you can use an enum as if it were another way to create a data type, and then just put the results to work. That’s the point, so you don’t have to think too hard about them. Before the introduction of enum in Java SE5, you had to go to a lot of effort to make an equivalent enumerated type that was safe to use.</p>
<p>This is enough for you to understand and use basic enums, but we’ll look more deeply at them later in the book—they have their own chapter: Enumerated Types.</p>
<p>Exercise 21: (1) Create an enum of the least-valuable six types of paper currency. Loop through the values( ) and print each value and its ordinal( ).</p>
<p>Exercise 22: (2) Write a switch statement for the enum in the previous example. For each case, output a description of that particular currency.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>This seemingly elaborate mechanism for initialization, the constructor, should give you a strong hint about the critical importance placed on initialization in the language. As Bjarne Stroustrup, the inventor of C++, was designing that language, one of the first observations he made about productivity in C was that improper initialization of variables causes a significant portion of programming problems. These kinds of bugs are hard to find, and similar issues apply to improper cleanup. Because constructors allow you to guarantee proper initialization and cleanup (the compiler will not allow an object to be created without the proper constructor calls), you get complete control and safety.</p>
<p>In C++, destruction is quite important because objects created with new must be explicitly destroyed. In Java, the garbage collector automatically releases the memory for all objects, so the equivalent cleanup method in Java isn’t necessary much of the time (but when it is, you must do it yourself). In cases where you don’t need destructor-like behavior, Java’s garbage collector greatly simplifies programming and adds much-needed safety in managing memory. Some garbage collectors can even clean up other resources like graphics and file handles. However, the garbage collector does add a runtime cost, the expense of which is difficult to put into perspective because of the historical slowness of Java interpreters. Although Java has had significant performance increases over time, the speed problem has taken its toll on the adoption of the language for certain types of programming problems.</p>
<p>Because of the guarantee that all objects will be constructed, there’s actually more to the constructor than what is shown here. In particular, when you create new classes using either composition or inheritance, the guarantee of construction also holds, and some additional syntax is necessary to support this. You’ll learn about composition, inheritance, and how they affect constructors in future chapters.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Access Control</p></title><empty-line/>
<p>Access control (or implementation hiding) is about “not getting it right the first time.”</p>
<p>All good writers—including those who write software-know that a piece of work isn’t good until it’s been rewritten, often many times. If you leave a piece of code in a drawer for a while and come back to it, you may see a much better way to do it. This is one of the prime motivations for refactoring, which rewrites working code in order to make it more readable, understandable, and thus maintainable.<a l:href="#bookmark22" type="note"><sup>23</sup></a><sup></sup></p>
<p>There is a tension, however, in this desire to change and improve your code. There are often consumers (client programmers) who rely on some aspect of your code staying the same. So you want to change it; they want it to stay the same. Thus a primary consideration in object-oriented design is to “separate the things that change from the things that stay the same.”</p>
<p>This is particularly important for libraries. Consumers of that library must rely on the part they use, and know that they won’t need to rewrite code if a new version of the library comes out. On the flip side, the library creator must have the freedom to make modifications and improvements with the certainty that the client code won’t be affected by those changes.</p>
<p>This can be achieved through convention. For example, the library programmer must agree not to remove existing methods when modifying a class in the library, since that would break the client programmer’s code. The reverse situation is thornier, however. In the case of a field, how can the library creator know which fields have been accessed by client programmers? This is also true with methods that are only part of the implementation of a class, and not meant to be used directly by the client programmer. What if the library creator wants to rip out an old implementation and put in a new one? Changing any of those members might break a client programmer’s code. Thus the library creator is in a strait jacket and can’t change anything.</p>
<p>To solve this problem, Java provides access specifiers to allow the library creator to say what is available to the client programmer and what is not. The levels of access control from “most access” to “least access” are public, protected, package access (which has no keyword), and private. From the previous paragraph you might think that, as a library designer, you’ll want to keep everything as “private” as possible, and expose only the methods that you want the client programmer to use. This is exactly right, even though it’s often counterintuitive for people who program in other languages (especially C) and who are used to accessing everything without restriction. By the end of this chapter you should be convinced of the value of access control in Java.</p>
<p>The concept of a library of components and the control over who can access the components of that library is not complete, however. There’s still the question of how the components are bundled together into a cohesive library unit. This is controlled with the package keyword in Java, and the access specifiers are affected by whether a class is in the same package or in a separate package. So to begin this chapter, you’ll learn how library components are placed into packages. Then you’ll be able to understand the complete meaning of the access specifiers.</p>
<section>
<title>
<p>package: the library unit</p></title><empty-line/>
<p>A package contains a group of classes, organized together under a single namespace.</p>
<p>For example, there’s a utility library that’s part of the standard Java distribution, organized under the namespace java.util. One of the classes in java.util is called ArrayList. One way to use an ArrayList is to specify the full name java.util.ArrayList.</p>
<p>//: access/FullQualification.java</p>
<p>public class FullQualification {</p>
<p>public static void main(String[] args) {</p>
<p>java.util.ArrayList list = new java.util.ArrayList();</p>
<p>}</p>
<p>} ///:~</p>
<p>This rapidly becomes tedious, so you’ll probably want to use the import keyword instead. If you want to import a single class, you can name that class in the import statement:</p>
<p>//: access/SingleImport.java import java.util.ArrayList;</p>
<p>public class SingleImport {</p>
<p>public static void main(String[] args) {</p>
<p>ArrayList list = new java.util.ArrayList();</p>
<p>}</p>
<p>} ///:~</p>
<p>Now you can use ArrayList with no qualification. However, none of the other classes in java.util are available. To import everything, you simply use the ‘*’ as you’ve been seeing in the rest of the examples in this book:</p>
<p>import java.util.*;</p>
<p>The reason for all this importing is to provide a mechanism to manage namespaces. The names of all your class members are insulated from each other. A method f( ) inside a class A will not clash with an f( ) that has the same signature in class B. But what about the class names? Suppose you create a Stack class that is installed on a machine that already has a Stack class that’s written by someone else? This potential clashing of names is why it’s important to have complete control over the namespaces in Java, and to create a unique identifier combination for each class.</p>
<p>Most of the examples thus far in this book have existed in a single file and have been designed for local use, so they haven’t bothered with package names. These examples have actually been in packages: the “unnamed” or default package. This is certainly an option, and for simplicity’s sake this approach will be used whenever possible throughout the rest of this book. However, if you’re planning to create libraries or programs that are friendly to other Java programs on the same machine, you must think about preventing class name clashes.</p>
<p>When you create a source-code file for Java, it’s commonly called a compilation unit (sometimes a translation unit). Each compilation unit must have a name ending in .java, and inside the compilation unit there can be a public class that must have the same name as the file (including capitalization, but excluding the .java file name extension). There can be only one public class in each compilation unit; otherwise, the compiler will complain. If there are additional classes in that compilation unit, they are hidden from the world outside that package because they’re not public, and they comprise “support” classes for the main public class.</p>
<subtitle>Code organization</subtitle>
<p>When you compile a .java file, you get an output file for each class in the .java file. Each output file has the name of a class in the .java file, but with an extension of .class. Thus you can end up with quite a few .class files from a small number of .java files. If you’ve programmed with a compiled language, you might be used to the compiler spitting out an intermediate form (usually an “obj” file) that is then packaged together with others of its kind using a linker (to create an executable file) or a librarian (to create a library). That’s not how Java works. A working program is a bunch of .class files, which can be packaged and compressed into a Java ARchive (JAR) file (using Java’s jar archiver). The Java interpreter is responsible for finding, loading, and interpreting<a l:href="#bookmark23" type="note"><sup>24</sup></a><sup></sup> these files.</p>
<p>A library is a group of these class files. Each source file usually has a public class and any number of non-public classes, so there’s one public component for each source file. If you want to say that all these components (each in its own separate .java and .class files) belong together, that’s where the package keyword comes in.</p>
<p>If you use a package statement, it must appear as the first non-comment in the file. When you say:</p>
<p>package access;</p>
<p>you’re stating that this compilation unit is part of a library named access. Put another way, you’re saying that the public class name within this compilation unit is under the umbrella of the name access, and anyone who wants to use that name must either fully specify the name or use the import keyword in combination with access, using the choices given previously. (Note that the convention for Java package names is to use all lowercase letters, even for intermediate words.)</p>
<p>For example, suppose the name of the file is MyClass.java. This means there can be one and only one public class in that file, and the name of that class must be MyClass (including the capitalization):</p>
<p>//: access/mypackage/MyClass.java package access.mypackage;</p>
<p>public class MyClass {</p>
<p>// ...</p>
<p>} ///:~</p>
<p>Now, if someone wants to use MyClass or, for that matter, any of the other public classes in access, they must use the import keyword to make the name or names in access available. The alternative is to give the fully qualified name:</p>
<p>//: access/QualifiedMyClass.java</p>
<p>public class QualifiedMyClass {</p>
<p>public static void main(String[] args) { access.mypackage.MyClass m = new access.mypackage.MyClass();</p>
<p>}</p>
<p>} ///:~</p>
<p>The import keyword can make this much cleaner:</p>
<p>//: access/ImportedMyClass.java import access.mypackage.*;</p>
<p>public class ImportedMyClass {</p>
<p>public static void main(String[] args) {</p>
<p>MyClass m = new MyClass();</p>
<p>}</p>
<p>} ///:~</p>
<p>It’s worth keeping in mind that what the package and import keywords allow you to do, as a library designer, is to divide up the single global namespace so you won’t have clashing names, no matter how many people get on the Internet and start writing classes in Java.</p>
<subtitle>Creating unique package names</subtitle>
<p>You might observe that, since a package never really gets “packaged” into a single file, a package can be made up of many .class files, and things could get a bit cluttered. To prevent this, a logical thing to do is to place all the .class files for a particular package into a single directory; that is, use the hierarchical file structure of the operating system to your advantage. This is one way that Java references the problem of clutter; you’ll see the other way later when the jar utility is introduced.</p>
<p>Collecting the package files into a single subdirectory solves two other problems: creating unique package names, and finding those classes that might be buried in a directory structure someplace. This is accomplished by encoding the path of the location of the .class file into the name of the package. By convention, the first part of the package name is the reversed Internet domain name of the creator of the class. Since Internet domain names are guaranteed to be unique, if you follow this convention, your package name will be unique and you’ll never have a name clash. (That is, until you lose the domain name to someone else who starts writing Java code with the same path names as you did.) Of course, if you don’t have your own domain name, then you must fabricate an unlikely combination (such as your first and last name) to create unique package names. If you’ve decided to start publishing Java code, it’s worth the relatively small effort to get a domain name.</p>
<p>The second part of this trick is resolving the package name into a directory on your machine, so that when the Java program runs and it needs to load the .class file, it can locate the directory where the .class file resides.</p>
<p>The Java interpreter proceeds as follows. First, it finds the environment variable CLASSPATH<a l:href="#bookmark24" type="note"><sup>25</sup></a><sup></sup> (set via the operating system, and sometimes by the installation program that installs Java or a Java-based tool on your machine). CLASSPATH contains one or more directories that are used as roots in a search for .class files. Starting at that root, the interpreter will take the package name and replace each dot with a slash to generate a path name off of the CLASSPATH root (so package foo.bar.baz becomes foo\bar\baz or foo/bar/baz or possibly something else, depending on your operating system). This is then concatenated to the various entries in the CLASSPATH. That’s where it looks for the .class file with the name corresponding to the class you’re trying to create. (It also searches some standard directories relative to where the Java interpreter resides.)</p>
<p>To understand this, consider my domain name, which is MindView.net. By reversing this and making it all lowercase, net.mindview establishes my unique global name for my classes. (The com, edu, org, etc., extensions were formerly capitalized in Java packages, but this was changed in Java 2 so the entire package name is lowercase.) I can further subdivide this by deciding that I want to create a library named simple, so I’ll end up with a package name:</p>
<p>package net.mindview.simple;</p>
<p>Now this package name can be used as an umbrella namespace for the following two files:</p>
<p>//: net/mindview/simple/Vector.java // Creating a package. package net.mindview.simple;</p>
<p>public class Vector { public Vector() {</p>
<p>System.out.println(&quot;net.mindview.simple.Vector&quot;);</p>
<p>}</p>
<p>} ///:~</p>
<p>As mentioned before, the package statement must be the first non-comment code in the file. The second file looks much the same:</p>
<p>//: net/mindview/simple/List.java // Creating a package. package net.mindview.simple;</p>
<p>public class List { public List() {</p>
<p>System.out.println(&quot;net.mindview.simple.List&quot;);</p>
<p>}</p>
<p>} ///:~</p>
<p>Both of these files are placed in the subdirectory on my system: C:\DOC\JavaT\net\mindview\simple</p>
<p>(Notice that the first comment line in every file in this book establishes the directory location of that file in the source-code tree—this is used by the automatic code-extraction tool for this book.)</p>
<p>If you walk back through this path, you can see the package name net.mindview.simple, but what about the first portion of the path? That’s taken care of by the CLASSPATH environment variable, which is, on my machine:</p>
<p>CLASSPATH=.;D:\JAVA\LIB;C:\DOC\JavaT</p>
<p>You can see that the CLASSPATH can contain a number of alternative search paths.</p>
<p>There’s a variation when using JAR files, however. You must put the actual name of the JAR file in the classpath, not just the path where it’s located. So for a JAR named grape.jar your classpath would include:</p>
<p>CLASSPATH=.;D:\JAVA\LIB;C:\flavors\grape.jar</p>
<p>Once the classpath is set up properly, the following file can be placed in any directory:</p>
<p>//: access/LibTest.java // Uses the library. import net.mindview.simple.*;</p>
<p>public class LibTest {</p>
<p>public static void main(String[] args) { Vector v = new Vector();</p>
<p>List l = new List();</p>
<p>}</p>
<p>} /* Output:</p>
<p>net.mindview.simple.Vector</p>
<p>net.mindview.simple.List</p>
<p>*///:~</p>
<p>When the compiler encounters the import statement for the simple library, it begins searching at the directories specified by CLASSPATH, looking for subdirectory net/mindview/simple, then seeking the compiled files of the appropriate names (Vector.class for Vector, and List.class for List). Note that both the classes and the desired methods in Vector and List must be public.</p>
<p>Setting the CLASSPATH has been such a trial for beginning Java users (it was for me, when I started) that Sun made the JDK in later versions of Java a bit smarter. You’ll find that when you install it, even if you don’t set the CLASSPATH, you’ll be able to compile and run basic Java programs. To compile and run the source-code package for this book (available at <a l:href="http://www.MindView.net">www.MindView.net</a>), however, you will need to add the base directory of the book’s code tree to your CLASSPATH.</p>
<p>Exercise 1: (1) Create a class in a package. Create an instance of your class outside of that package.</p>
<p>Collisions</p>
<p>What happens if two libraries are imported via ‘*’ and they include the same names? For example, suppose a program does this:</p>
<p>import net.mindview.simple.*; import java.util.*;</p>
<p>Since java.util.* also contains a Vector class, this causes a potential collision. However, as long as you don’t write the code that actually causes the collision, everything is OK—this is good, because otherwise you might end up doing a lot of typing to prevent collisions that would never happen.</p>
<p>The collision does occur if you now try to make a Vector:</p>
<p>Vector v = new Vector();</p>
<p>Which Vector class does this refer to? The compiler can’t know, and the reader can’t know either. So the compiler complains and forces you to be explicit. If I want the standard Java Vector, for example, I must say:</p>
<p>java.util.Vector v = new java.util.Vector();</p>
<p>Since this (along with the CLASSPATH) completely specifies the location of that Vector, there’s no need for the import java.util.* statement unless I’m using something else from java.util.</p>
<p>Alternatively, you can use the single-class import form to prevent clashes—as long as you don’t use both colliding names in the same program (in which case you must fall back to fully specifying the names).</p>
<p>Exercise 2: (1) Take the code fragments in this section and turn them into a program, and verify that collisions do in fact occur.</p>
<subtitle>A custom tool library</subtitle>
<p>With this knowledge, you can now create your own libraries of tools to reduce or eliminate duplicate code. Consider, for example, the alias we’ve been using for</p>
<p>System.out.println( ), to reduce typing. This can be part of a class called Print so that you end up with a readable static import:</p>
<p>//: net/mindview/util/Print.java // Print methods that can be used without // qualifiers, using Java SE5 static imports: package net.mindview.util; import java.io.*;</p>
<p>public class Print {</p>
<p>// Print with a newline:</p>
<p>public static void print(Object obj) {</p>
<p>System.out.println(obj);</p>
<p>}</p>
<p>// Print a newline by itself: public static void print() {</p>
<p>System.out.println();</p>
<p>}</p>
<p>// Print with no line break:</p>
<p>public static void printnb(Object obj) {</p>
<p>System.out.print(obj);</p>
<p>}</p>
<p>// The new Java SE5 printf() (from C): public static PrintStream printf(String format, Object... args) { return System.out.printf(format, args);</p>
<p>}</p>
<p>} ///:~</p>
<p>You can use the printing shorthand to print anything, either with a newline (print( )) or without a newline (printnb( )).</p>
<p>You can guess that the location of this file must be in a directory that starts at one of the CLASSPATH locations, then continues into net/mindview. After compiling, the static print( ) and printnb( ) methods can be used anywhere on your system with an import static statement:</p>
<p>//: access/PrintTest.java</p>
<p>// Uses the static printing methods in Print.java. import static net.mindview.util.Print.*;</p>
<p>public class PrintTest {</p>
<p>public static void main(String[] args) { print(&quot;Available from now on!&quot;); print(l00); print(100L); print(3.14159);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Available from now on!</p>
<p>100</p>
<p>100</p>
<p>3.14159</p>
<p>A second component of this library can be the range( ) methods, introduced in the Controlling Execution chapter, that allow the use of the foreach syntax for simple integer sequences:</p>
<p>//: net/mindview/util/Range.java</p>
<p>// Array creation methods that can be used without // qualifiers, using Java SE5 static imports: package net.mindview.util;</p>
<p>public class Range {</p>
<p>// Produce a sequence [0..n) public static int[] range(int n) { int[] result = new int[n]; for(int i = 0; i &lt; n; i++) result[i] = i; return result;</p>
<p>}</p>
<p>// Produce a sequence [start..end) public static int[] range(int start, int end) { int sz = end - start; int[] result = new int[sz]; for(int i = 0; i &lt; sz; i++) result[i] = start + i; return result;</p>
<p>}</p>
<p>// Produce a sequence [start..end) incrementing by step public static int[] range(int start, int end, int step) { int sz = (end - start)/step; int[] result = new int[sz]; for(int i = 0; i &lt; sz; i++)</p>
<p>result[i] = start + (i * step); return result;</p>
<p>}</p>
<p>} ///:~</p>
<p>From now on, whenever you come up with a useful new utility, you can add it to your own library. You’ll see more components added to the net.mindview.util library throughout the book.</p>
<subtitle>Using imports to change behavior</subtitle>
<p>A feature that is missing from Java is C’s conditional compilation, which allows you to change a switch and get different behavior without changing any other code. The reason such a feature was left out of Java is probably because it is most often used in C to solve crossplatform issues: Different portions of the code are compiled depending on the target platform. Since Java is intended to be automatically cross-platform, such a feature should not be necessary.</p>
<p>However, there are other valuable uses for conditional compilation. A very common use is for debugging code. The debugging features are enabled during development and disabled in the shipping product. You can accomplish this by changing the package that’s imported in order to change the code used in your program from the debug version to the production version. This technique can be used for any kind of conditional code.</p>
<p>Exercise 3: (2) Create two packages: debug and debugoff, containing an identical class with a debug( ) method. The first version displays its String argument to the console, the</p>
<p>second does nothing. Use a static import line to import the class into a test program, and demonstrate the conditional compilation effect.</p>
<subtitle>Package caveat</subtitle>
<p>It’s worth remembering that anytime you create a package, you implicitly specify a directory structure when you give the package a name. The package must live in the directory indicated by its name, which must be a directory that is searchable starting from the CLASSPATH. Experimenting with the package keyword can be a bit frustrating at first, because unless you adhere to the package-name to directory-path rule, you’ll get a lot of mysterious runtime messages about not being able to find a particular class, even if that class is sitting there in the same directory. If you get a message like this, try commenting out the package statement, and if it runs, you’ll know where the problem lies.</p>
<p>Note that compiled code is often placed in a different directory than source code, but the path to the compiled code must still be found by the JVM using the CLASSPATH.</p>
</section>
<section>
<title>
<p>Java access specifiers</p></title><empty-line/>
<p>The Java access specifiers public, protected, and private are placed in front of each definition for each member in your class, whether it’s a field or a method. Each access specifier only controls the access for that particular definition.</p>
<p>If you don’t provide an access specifier, it means “package access.” So one way or another, everything has some kind of access control. In the following sections, you’ll learn about the various types of access.</p>
<subtitle>Package access</subtitle>
<p>All the examples before this chapter used no access specifiers. The default access has no keyword, but it is commonly referred to as package access (and sometimes “friendly”). It means that all the other classes in the current package have access to that member, but to all the classes outside of this package, the member appears to be private. Since a compilation unit—a file-can belong only to a single package, all the classes within a single compilation unit are automatically available to each other via package access.</p>
<p>Package access allows you to group related classes together in a package so that they can easily interact with each other. When you put classes together in a package, thus granting mutual access to their package-access members, you “own” the code in that package. It makes sense that only code that you own should have package access to other code that you own. You could say that package access gives a meaning or a reason for grouping classes together in a package. In many languages the way you organize your definitions in files can be arbitrary, but in Java you’re compelled to organize them in a sensible fashion. In addition, you’ll probably want to exclude classes that shouldn’t have access to the classes being defined in the current package.</p>
<p>The class controls the code that has access to its members. Code from another package can’t just come around and say, “Hi, I’m a friend of Bob’s!” and expect to be shown the protected, package-access, and private members of Bob. The only way to grant access to a member is to: <a l:href="#bookmark25" type="note"><sup>26</sup></a><sup></sup></p>
<p>2.    Give the member package access by leaving off any access specifier, and put the other classes in the same package. Then the other classes in that package can access the member.</p>
<p>3.    As you’ll see in the Reusing Classes chapter, when inheritance is introduced, an inherited class can access a protected member as well as a public member (but not private members). It can access package-access members only if the two classes are in the same package. But don’t worry about inheritance and protected right now.</p>
<p>4.    Provide “accessor/mutator” methods (also known as “get/set” methods) that read and change the value. This is the most civilized approach in terms of OOP, and it is fundamental to JavaBeans, as you’ll see in the Graphical User Interfaces chapter.</p>
<subtitle>public: interface access</subtitle>
<p>When you use the public keyword, it means that the member declaration that immediately follows public is available to everyone, in particular to the client programmer who uses the library. Suppose you define a package dessert containing the following compilation unit:</p>
<p>//: access/dessert/Cookie.java // Creates a library. package access.dessert;</p>
<p>public class Cookie { public Cookie() {</p>
<p>System.out.println(&quot;Cookie constructor&quot;);</p>
<p>}</p>
<p>void bite() { System.out.println(&quot;bite&quot;); }</p>
<p>} ///:~</p>
<p>Remember, the class file produced by Cookie.java must reside in a subdirectory called dessert, in a directory under access (indicating the Access Control chapter of this book) that must be under one of the CLASSPATH directories. Don’t make the mistake of thinking that Java will always look at the current directory as one of the starting points for searching. If you don’t have a ‘.’ as one of the paths in your CLASSPATH, Java won’t look there.</p>
<p>Now if you create a program that uses Cookie:</p>
<p>//: access/Dinner.java // Uses the library. import access.dessert.*;</p>
<p>public class Dinner {</p>
<p>public static void main(String[] args) {</p>
<p>Cookie x = new Cookie();</p>
<p>//! x.bite(); // Can’t access</p>
<p>}</p>
<p>} /* Output:</p>
<p>Cookie constructor *///:~</p>
<p>you can create a Cookie object, since its constructor is public and the class is public. (We’ll look more at the concept of a public class later.) However, the bite( ) member is inaccessible inside Dinner.java since bite( ) provides access only within package dessert, so the compiler prevents you from using it.</p>
<p>The default package</p>
<p>You might be surprised to discover that the following code compiles, even though it would appear that it breaks the rules:</p>
<p>//: access/Cake.java</p>
<p>// Accesses a class in a separate compilation unit. class Cake {</p>
<p>public static void main(String[] args) {</p>
<p>Pie x = new Pie(); x.f();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Pie.f()</p>
<p>*///:~</p>
<p>In a second file in the same directory:</p>
<p>//: access/Pie.java // The other class.</p>
<p>class Pie {</p>
<p>void f() { System.out.println(&quot;Pie.f()&quot;); }</p>
<p>} ///:~</p>
<p>You might initially view these as completely foreign files, and yet Cake is able to create a Pie object and call its f( ) method. (Note that you must have ‘.’ in your CLASSPATH in order for the files to compile.) You’d typically think that Pie and f( ) have package access and are therefore not available to Cake. They do have package access—that part is correct. The reason that they are available in Cake.java is because they are in the same directory and have no explicit package name. Java treats files like this as implicitly part of the “default package” for that directory, and thus they provide package access to all the other files in that directory.</p>
<subtitle>private: you can&apos;t touch that!</subtitle>
<p>The private keyword means that no one can access that member except the class that contains that member, inside methods of that class. Other classes in the same package cannot access private members, so it’s as if you’re even insulating the class against yourself. On the other hand, it’s not unlikely that a package might be created by several people collaborating together, so private allows you to freely change that member without concern that it will affect another class in the same package.</p>
<p>The default package access often provides an adequate amount of hiding; remember, a packageaccess member is inaccessible to the client programmer using the class. This is nice, since the default access is the one that you normally use (and the one that you’ll get if you forget to add any access control). Thus, you’ll typically think about access for the members that you explicitly want to make public for the client programmer, and as a result, you might initially think that you won’t use the private keyword very often, since it’s tolerable to get away without it. However, it turns out that the consistent use of private is very important, especially where multithreading is concerned. (As you’ll see in the Concurrency chapter.)</p>
<p>Here’s an example of the use of private:</p>
<p>//: access/IceCream.java // Demonstrates &quot;private&quot; keyword.</p>
<p>class Sundae {</p>
<p>private Sundae() {} static Sundae makeASundae() { return new Sundae();</p>
<p>}</p>
<p>}</p>
<p>public class IceCream {</p>
<p>public static void main(String[] args) {</p>
<p>//! Sundae x = new Sundae();</p>
<p>Sundae x = Sundae.makeASundae();</p>
<p>}</p>
<p>} ///:~</p>
<p>This shows an example in which private comes in handy: You might want to control how an object is created and prevent someone from directly accessing a particular constructor (or all of them). In the preceding example, you cannot create a Sundae object via its constructor; instead, you must call the makeASundae( ) method to do it for you.<a l:href="#bookmark26" type="note"><sup>27</sup></a><sup></sup></p>
<p>Any method that you’re certain is only a “helper” method for that class can be made private, to ensure that you don’t accidentally use it elsewhere in the package and thus prohibit yourself from changing or removing the method. Making a method private guarantees that you retain this option.</p>
<p>The same is true for a private field inside a class. Unless you must expose the underlying implementation (which is less likely than you might think), you should make all fields private. However, just because a reference to an object is private inside a class doesn’t mean that some other object can’t have a public reference to the same object. (See the online supplements for this book to learn about aliasing issues.)</p>
<subtitle>protected: inheritance access</subtitle>
<p>Understanding the protected access specifier requires a jump ahead. First, you should be aware that you don’t need to understand this section to continue through this book up through inheritance (the Reusing Classes chapter). But for completeness, here is a brief description and example using protected.</p>
<p>The protected keyword deals with a concept called inheritance, which takes an existing class— which we refer to as the base class—and adds new members to that class without touching the existing class. You can also change the behavior of existing members of the class. To inherit from a class, you say that your new class extends an existing class, like this:</p>
<p>class Foo extends Bar {</p>
<p>The rest of the class definition looks the same.</p>
<p>If you create a new package and inherit from a class in another package, the only members you have access to are the public members of the original package. (Of course, if you perform the inheritance in the same package, you can manipulate all the members that have package access.) Sometimes the creator of the base class would like to take a particular member and grant access to derived classes but not the world in general. That’s what protected does. protected also gives package access—that is, other classes in the same package may access protected elements.</p>
<p>If you refer back to the file Cookie.java, the following class cannot call the package-access member bite( ):</p>
<p>//: access/ChocolateChip.java</p>
<p>// Can’t use package-access member from another package. import access.dessert.*;</p>
<p>public class ChocolateChip extends Cookie { public ChocolateChip() {</p>
<p>System.out.println(&quot;ChocolateChip constructor&quot;);</p>
<p>}</p>
<p>public void chomp() {</p>
<p>//! bite(); // Can’t access bite</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>ChocolateChip x = new ChocolateChip(); x.chomp();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Cookie constructor ChocolateChip constructor *///:~</p>
<p>One of the interesting things about inheritance is that if a method bite( ) exists in class Cookie, then it also exists in any class inherited from Cookie. But since bite( ) has package access and is in a foreign package, it’s unavailable to us in this one. Of course, you could make it public, but then everyone would have access, and maybe that’s not what you want. If you change the class Cookie as follows:</p>
<p>//: access/cookie2/Cookie.java package access.cookie2;</p>
<p>public class Cookie { public Cookie() {</p>
<p>System.out.println(&quot;Cookie constructor&quot;);</p>
<p>}</p>
<p>protected void bite() {</p>
<p>System.out.println(&quot;bite&quot;);</p>
<p>}</p>
<p>} ///:~</p>
<p>now bite( ) becomes accessible to anyone inheriting from Cookie:</p>
<p>//: access/ChocolateChip2.java import access.cookie2.*;</p>
<p>public class ChocolateChip2 extends Cookie { public ChocolateChip2() {</p>
<p>System.out.println(&quot;ChocolateChip2 constructor&quot;);</p>
<p>}</p>
<p>public void chomp() { bite(); } // Protected method public static void main(String[] args) {</p>
<p>ChocolateChip2 x = new ChocolateChip2(); x.chomp();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Cookie constructor ChocolateChip2 constructor bite *///:~</p>
<p>Note that, although bite( ) also has package access, it is not public.</p>
<p>Exercise 4: (2) Show that protected methods have package access but are not public.</p>
<p>Exercise 5: (2) Create a class with public, private, protected, and package-access fields and method members. Create an object of this class and see what kind of compiler messages you get when you try to access all the class members. Be aware that classes in the same directory are part of the “default” package.</p>
<p>Exercise 6: (1) Create a class with protected data. Create a second class in the same file with a method that manipulates the protected data in the first class.</p>
</section>
<section>
<title>
<p>Interface and implementation</p></title><empty-line/>
<p>Access control is often referred to as implementation hiding. Wrapping data and methods within classes in combination with implementation hiding is often called encapsulation.<a l:href="#bookmark27" type="note"><sup>28</sup></a><sup> </sup>The result is a data type with characteristics and behaviors.</p>
<p>Access control puts boundaries within a data type for two important reasons. The first is to establish what the client programmers can and can’t use. You can build your internal mechanisms into the structure without worrying that the client programmers will accidentally treat the internals as part of the interface that they should be using.</p>
<p>This feeds directly into the second reason, which is to separate the interface from the implementation. If the structure is used in a set of programs, but client programmers can’t do anything but send messages to the public interface, then you are free to change anything that’s not public (e.g., package access, protected, or private) without breaking client code.</p>
<p>For clarity, you might prefer a style of creating classes that puts the public members at the beginning, followed by the protected, package-access, and private members. The advantage is that the user of the class can then read down from the top and see first what’s important to them (the public members, because they can be accessed outside the file), and stop reading when they encounter the non-public members, which are part of the internal implementation:</p>
<p>//: access/OrganizedByAccess.java</p>
<p>public class OrganizedByAccess {</p>
<p>public</p>
<p>public</p>
<p>public</p>
<p>private</p>
<p>private</p>
<p>private</p>
<p>private</p>
<p>// ...</p>
<p>} ///:~</p>
<p>void</p>
<p>void</p>
<p>void</p>
<p>pub1()</p>
<p>pub2()</p>
<p>pub3()</p>
<p>void void void int i</p>
<p>priv1()</p>
<p>priv2()</p>
<p>priv3()</p>
<p>/* . /* . /* . { /* { /* { /*</p>
<p>*/ } */ } */ } . */ . */ . */</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>This will make it only partially easier to read, because the interface and implementation are still mixed together. That is, you still see the source code—the implementation—because it’s right there in the class. In addition, the comment documentation supported by Javadoc lessens the importance of code readability by the client programmer. Displaying the interface to the consumer of a class is really the job of the class browser, a tool whose job is to look at all the available classes and show you what you can do with them (i.e., what members are available) in a useful fashion. In Java, viewing the JDK documentation with a Web browser gives you the same effect as a class browser.</p>
</section>
<section>
<title>
<p>Class access</p></title><empty-line/>
<p>In Java, the access specifiers can also be used to determine which classes within a library will be available to the users of that library. If you want a class to be available to a client programmer, you use the public keyword on the entire class definition. This controls whether the client programmer can even create an object of the class.</p>
<p>To control the access of a class, the specifier must appear before the keyword class. Thus you can say:</p>
<p>public class Widget {</p>
<p>Now if the name of your library is access, any client programmer can access Widget by saying</p>
<p>import access.Widget; or</p>
<p>import access.*;</p>
<p>However, there’s an extra set of constraints:</p>
<p>1.    There can be only one public class per compilation unit (file). The idea is that each compilation unit has a single public interface represented by that public class. It can have as many supporting package-access classes as you want. If you have more than one public class inside a compilation unit, the compiler will give you an error message.</p>
<p>2.    The name of the public class must exactly match the name of the file containing the compilation unit, including capitalization. So for Widget, the name of the file must be Widget.java, not widget.java or WIDGET.java. Again, you’ll get a compile-time error if they don’t agree.</p>
<p>3.    It is possible, though not typical, to have a compilation unit with no public class at all. In this case, you can name the file whatever you like (although naming it arbitrarily will be confusing to people reading and maintaining the code).</p>
<p>What if you’ve got a class inside access that you’re only using to accomplish the tasks performed by Widget or some other public class in access? You don’t want to go to the bother of creating documentation for the client programmer, and you think that sometime later you might want to completely change things and rip out your class altogether, substituting a different one. To give you this flexibility, you need to ensure that no client programmers become dependent on your particular implementation details hidden inside access. To accomplish this, you just leave the public keyword off the class, in which case it has package access. (That class can be used only within that package.)</p>
<p>Exercise 7: (1) Create the library according to the code fragments describing access and Widget. Create a Widget in a class that is not part of the access package.</p>
<p>When you create a package-access class, it still makes sense to make the fields of the class private—you should always make fields as private as possible—but it’s generally reasonable to give the methods the same access as the class (package access). Since a package-access class is usually used only within the package, you only need to make the methods of such a class public if you’re forced to, and in those cases, the compiler will tell you.</p>
<p>Note that a class cannot be private (that would make it inaccessible to anyone but the class) or protected.<sup>6</sup> So you have only two choices for class access: package access or public. If you don’t want anyone else to have access to that class, you can make all the constructors private, thereby preventing anyone but you, inside a static member of the class, from creating an object of that class. Here’s an example:</p>
<p>//: access/Lunch.java</p>
<p>// Demonstrates class access specifiers. Make a class // effectively private with private constructors:</p>
<p>class Soupl {</p>
<p>private Soup1() {}</p>
<p>// (1) Allow creation via static method: public static Soupl makeSoup() { return new Soup1();</p>
<p>}</p>
<p>}</p>
<p>class Soup2 {</p>
<p>private Soup2() {}</p>
<p>// (2) Create a static object and return a reference // upon request.(The &quot;Singleton&quot; pattern): private static Soup2 psl = new Soup2(); public static Soup2 access() { return psl;</p>
<p>}</p>
<p>public void f() {}</p>
<p>}</p>
<p>// Only one public class allowed per file: public class Lunch { void testPrivate() {</p>
<p>// Can’t do this! Private constructor:</p>
<p>//! Soupl soup = new Soup1();</p>
<p>}</p>
<p>void testStatic() {</p>
<p>Soupl soup = Soupl.makeSoup();</p>
<p>}</p>
<p>void testSingleton() {</p>
<p>Soup2.access().f();</p>
<p>}</p>
<p>} ///:~</p>
<p>Up to now, most of the methods have been returning either void or a primitive type, so the definition:</p>
<p>public static Soupl makeSoup() { return new Soupl();</p>
<p>}</p>
<p>might look a little confusing at first. The word Soupl before the method name (makeSoup) tells what the method returns. So far in this book, this has usually been void, which means it returns nothing. But you can also return a reference to an object, which is what happens here. This method returns a reference to an object of class Soupl.</p>
<p><sup>6</sup> Actually, an inner class can be private or protected, but that’s a special case. These will be introduced in the Inner Classes chapter.</p>
<p>The classes Soup1 and Soup2 show how to prevent direct creation of a class by making all the constructors private. Remember that if you don’t explicitly create at least one constructor, the default constructor (a constructor with no arguments) will be created for you. By writing the default constructor, it won’t be created automatically. By making it private, no one can create an object of that class. But now how does anyone use this class? The preceding example shows two options. In Soup1, a static method is created that creates a new Soup1 and returns a reference to it. This can be useful if you want to do some extra operations on the Soup1 before returning it, or if you want to keep count of how many Soup1 objects to create (perhaps to restrict their population).</p>
<p>Soup2 uses what’s called a design pattern, which is covered in Thinking in Patterns (with Java) at <a l:href="http://www.MindView.net">www.MindView.net</a>. This particular pattern is called a Singleton, because it allows only a single object to ever be created. The object of class Soup2 is created as a static private member of Soup2, so there’s one and only one, and you can’t get at it except through the public method access( ).</p>
<p>As previously mentioned, if you don’t put an access specifier for class access, it defaults to package access. This means that an object of that class can be created by any other class in the package, but not outside the package. (Remember, all the files within the same directory that don’t have explicit package declarations are implicitly part of the default package for that directory.) However, if a static member of that class is public, the client programmer can still access that static member even though they cannot create an object of that class.</p>
<p>Exercise 8: (4) Following the form of the example Lunch.java, create a class called ConnectionManager that manages a fixed array of Connection objects. The client programmer must not be able to explicitly create Connection objects, but can only get them via a static method in ConnectionManager. When the ConnectionManager runs out of objects, it returns a null reference. Test the classes in main( ).</p>
<p>Exercise 9: (2) Create the following file in the access/local directory (presumably in your CLASSPATH):</p>
<p>// access/local/PackagedClass.java package access.local;</p>
<p>class PackagedClass { public PackagedClass() {</p>
<p>System.out.println(&quot;Creating a packaged class&quot;);</p>
<p>}</p>
<p>}</p>
<p>Then create the following file in a directory other than access/local:</p>
<p>// access/foreign/Foreign.java package access.foreign; import access.local.*;</p>
<p>public class Foreign {</p>
<p>public static void main(String[] args) {</p>
<p>PackagedClass pc = new PackagedClass();</p>
<p>}</p>
<p>}</p>
<p>Explain why the compiler generates an error. Would making the Foreign class part of the access.local package change anything?</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>In any relationship it’s important to have boundaries that are respected by all parties involved. When you create a library, you establish a relationship with the user of that library—the client programmer—who is another programmer, but one using your library to build an application or a bigger library.</p>
<p>Without rules, client programmers can do anything they want with all the members of a class, even if you might prefer they don’t directly manipulate some of the members. Everything’s naked to the world.</p>
<p>This chapter looked at how classes are built to form libraries: first, the way a group of classes is packaged within a library, and second, the way the class controls access to its members.</p>
<p>It is estimated that a C programming project begins to break down somewhere between 50K and 100K lines of code because C has a single namespace, and names begin to collide, causing extra management overhead. In Java, the package keyword, the package naming scheme, and the import keyword give you complete control over names, so the issue of name collision is easily avoided.</p>
<p>There are two reasons for controlling access to members. The first is to keep users’ hands off portions that they shouldn’t touch. These pieces are necessary for the internal operations of the class, but not part of the interface that the client programmer needs. So making methods and fields private is a service to client programmers, because they can easily see what’s important to them and what they can ignore. It simplifies their understanding of the class.</p>
<p>The second and most important reason for access control is to allow the library designer to change the internal workings of the class without worrying about how it will affect the client programmer. You might, for example, build a class one way at first, and then discover that restructuring your code will provide much greater speed. If the interface and implementation are clearly separated and protected, you can accomplish this without forcing client programmers to rewrite their code. Access control ensures that no client programmer becomes dependent on any part of the underlying implementation of a class.</p>
<p>When you have the ability to change the underlying implementation, you not only have the freedom to improve your design, you also have the freedom to make mistakes. No matter how carefully you plan and design, you’ll make mistakes. Knowing that it’s relatively safe to make these mistakes means you’ll be more experimental, you’ll learn more quickly, and you’ll finish your project sooner.</p>
<p>The public interface to a class is what the user does see, so that is the most important part of the class to get “right” during analysis and design. Even that allows you some leeway for change. If you don’t get the interface right the first time, you can add more methods, as long as you don’t remove any that client programmers have already used in their code.</p>
<p>Notice that access control focuses on a relationship—and a kind of communication—between a library creator and the external clients of that library. There are many situations where this is not the case. For example, you are writing all the code yourself, or you are working in close quarters with a small team and everything goes into the same package. These situations have a different kind of communication, and rigid adherence to access rules may not be optimal. Default (package) access may be just fine.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Reusing Classes</p></title><empty-line/>
<p>One of the most compelling features about Java is code reuse. But to be revolutionary, you’ve got to be able to do a lot more than copy code and change it.</p>
<p>That’s the approach used in procedural languages like C, and it hasn’t worked very well. Like everything in Java, the solution revolves around the class. You reuse code by creating new classes, but instead of creating them from scratch, you use existing classes that someone has already built and debugged.</p>
<p>The trick is to use the classes without soiling the existing code. In this chapter you’ll see two ways to accomplish this. The first is quite straightforward: you simply create objects of your existing class inside the new class. This is called composition, because the new class is composed of objects of existing classes. You’re simply reusing the functionality of the code, not its form.</p>
<p>The second approach is more subtle. It creates a new class as a type of an existing class. You literally take the form of the existing class and add code to it without modifying the existing class. This technique is called inheritance, and the compiler does most of the work. Inheritance is one of the cornerstones of object-oriented programming, and has additional implications that will be explored in the Polymorphism chapter.</p>
<p>It turns out that much of the syntax and behavior are similar for both composition and inheritance (which makes sense because they are both ways of making new types from existing types). In this chapter, you’ll learn about these code reuse mechanisms.</p>
<section>
<title>
<p>Composition syntax</p></title><empty-line/>
<p>Composition has been used quite frequently up to this point in the book. You simply place object references inside new classes. For example, suppose you’d like an object that holds several String objects, a couple of primitives, and an object of another class. For the nonprimitive objects, you put references inside your new class, but you define the primitives directly:</p>
<p>//: reusing/SprinklerSystem.java // Composition for code reuse.</p>
<p>class WaterSource { private String s;</p>
<p>WaterSource() {</p>
<p>System.out.println(&quot;WaterSourceQ&quot;); s = &quot;Constructed&quot;;</p>
<p>}</p>
<p>public String toStringQ { return s; }</p>
<p>}</p>
<p>public class SprinklerSystem {</p>
<p>private String valve1, valve2, valve3, valve4; private WaterSource source = new WaterSource(); private int i; private float f; public String toString() { return</p>
<p>+</p>
<table>
<tr><td>valvel =</td><td>&quot; +</td><td>valvel</td><td>+</td><td>&quot; &quot; +</td></tr>
<tr><td>valve2 =</td><td>&quot; +</td><td>valve2</td><td>+</td><td>&quot; &quot; +</td></tr>
<tr><td>valve3 =</td><td>&quot; +</td><td>valve3</td><td>+</td><td>&quot; &quot; +</td></tr>
<tr><td>valve4 =</td><td>&quot; +</td><td>valve4</td><td>+</td><td>&quot;\n&quot; +</td></tr>
<tr><td>i = &quot; + i</td><td>+ &quot;</td><td>&quot; + &quot;</td><td>f =</td><td>&quot; + f</td></tr>
<tr><td>source =</td><td>&quot; +</td><td>source</td><td>;</td><td></td></tr>
</table>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>SprinklerSystem sprinklers = new SprinklerSystem(); System.out.println(sprinklers);</p>
<p>}</p>
<p>} /* Output:</p>
<p>WaterSource()</p>
<p>valvel = null valve2 = null valve3 = null valve4 = null i = 0 f = 0.0 source = Constructed *///:</p>
<p>One of the methods defined in both classes is special: toString( ). Every non-primitive object has a toString( ) method, and it’s called in special situations when the compiler wants a String but it has an object. So in the expression in SprinklerSystem.toString( ):</p>
<p>&quot;source = &quot; + source;</p>
<p>the compiler sees you trying to add a String object (&quot;source = &quot;) to a WaterSource. Because you can only “add” a String to another String, it says “I’ll turn source into a String by calling toString( )!” After doing this it can combine the two Strings and pass the resulting String to System.out.println( ) (or equivalently, this book’s print() and printnb( ) static methods). Any time you want to allow this behavior with a class you create, you need only write a toString( ) method.</p>
<p>Primitives that are fields in a class are automatically initialized to zero, as noted in the Everything Is an Object chapter. But the object references are initialized to null, and if you try to call methods for any of them, you’ll get an exception-a runtime error. Conveniently, you can still print a null reference without throwing an exception.</p>
<p>It makes sense that the compiler doesn’t just create a default object for every reference, because that would incur unnecessary overhead in many cases. If you want the references initialized, you can do it:</p>
<p>1.    At the point the objects are defined. This means that they’ll always be initialized before the constructor is called.</p>
<p>2.    In the constructor for that class.</p>
<p>3.    Right before you actually need to use the object. This is often called lazy initialization. It can reduce overhead in situations where object creation is expensive and the object doesn’t need to be created every time.</p>
<p>4.    Using instance initialization.</p>
<p>All four approaches are shown here:</p>
<p>//: reusing/Bath.java</p>
<p>// Constructor initialization with composition. import static net.mindview.util.Print.*;</p>
<p>class Soap {</p>
<p>private String s;</p>
<p>Soap() {</p>
<p>print(&quot;Soap()&quot;); s = &quot;Constructed&quot;;</p>
<p>}</p>
<p>public String toString() { return s; }</p>
<p>} public class Bath {</p>
<p>private String // Initializing at point of definition: si = &quot;Happy&quot;, s2 = &quot;Happy&quot;, s3, s4;</p>
<p>private Soap castille; private int i; private float toy; public Bath() {</p>
<p>print(&quot;Inside Bath()&quot;); s3 = &quot;Joy&quot;; toy = 3.14f; castille = new Soap();</p>
<table>
<tr><th colspan="7">}</th></tr>
<tr><td>//</td><td>I</td><td colspan="2">nstance in</td><td>iti</td><td>al</td><td>ization:</td></tr>
<tr><td>{</td><td>i</td><td>= 47;</td><td>}</td><td></td><td></td><td></td></tr>
<tr><td colspan="2">publ</td><td>ic St</td><td>ring</td><td colspan="2">toStr</td><td>ing() {</td></tr>
<tr><td></td><td>if</td><td>(s4 =</td><td>= nul</td><td>l)</td><td>//</td><td>Delayed initialization</td></tr>
<tr><td></td><td></td><td>s4 =</td><td>&quot;Joy&quot;</td><td>;</td><td></td><td></td></tr>
<tr><td></td><td>re</td><td>turn</td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td>&quot;si =</td><td>&quot; +</td><td>si</td><td>+</td><td>&quot;\n&quot; +</td></tr>
<tr><td></td><td></td><td>&quot;s2 =</td><td>&quot; +</td><td>s2</td><td>+</td><td>&quot;\n&quot; +</td></tr>
<tr><td></td><td></td><td>&quot;s3 =</td><td>&quot; +</td><td>s3</td><td>+</td><td>&quot;\n&quot; +</td></tr>
<tr><td></td><td></td><td>&quot;s4 =</td><td>&quot; +</td><td>s4</td><td>+</td><td>&quot;\n&quot; +</td></tr>
<tr><td></td><td></td><td>&quot;i =</td><td>&quot; + i</td><td>+</td><td>&quot;\</td><td>n&quot; +</td></tr>
<tr><td></td><td></td><td>&quot;toy</td><td>= &quot; +</td><td colspan="2">toy</td><td>+ &quot;\n&quot; +</td></tr>
<tr><td></td><td></td><td>&quot;cast</td><td>ille</td><td>_ 1</td><td>+</td><td>castille;</td></tr>
<tr><td colspan="2">spubl</td><td>ic st</td><td>atic</td><td>voi</td><td>d</td><td>main(String[] args) {</td></tr>
<tr><td colspan="7">Bath b = new Bath() print(b);</td></tr>
</table>
<p>}</p>
<p>} /* Output:</p>
<p>Inside Bath()</p>
<p>Soap() si = Happy s2 = Happy s3 = Joy s4 = Joy i = 47 toy = 3.14</p>
<p>castille = Constructed *///:~</p>
<p>Note that in the Bath constructor, a statement is executed before any of the initializations take place. When you don’t initialize at the point of definition, there’s still no guarantee that you’ll perform any initialization before you send a message to an object reference—except for the inevitable run-time exception.</p>
<p>When toString( ) is called it fills in s4 so that all the fields are properly initialized by the time they are used.</p>
<p>Exercise 1: (2) Create a simple class. Inside a second class, define a reference to an object of the first class. Use lazy initialization to instantiate this object.</p>
</section>
<section>
<title>
<p>Inheritance syntax</p></title><empty-line/>
<p>Inheritance is an integral part of Java (and all OOP languages). It turns out that you’re always doing inheritance when you create a class, because unless you explicitly inherit from some other class, you implicitly inherit from Java’s standard root class Object.</p>
<p>The syntax for composition is obvious, but to perform inheritance there’s a distinctly different form. When you inherit, you say “This new class is like that old class.” You state this in code before the opening brace of the class body, using the keyword extends followed by the name of the base class. When you do this, you automatically get all the fields and methods in the base class. Here’s an example:</p>
<p>//: reusing/Detergent.java // Inheritance syntax &amp; properties. import static net.mindview.util.Print.*;</p>
<p>class Cleanser {</p>
<p>private String s = &quot;Cleanser&quot;; public void append(String a) { s += a; } public void dilute() { append(&quot; dilute()&quot;); } public void apply() { append(&quot; apply()&quot;); } public void scrub() { append(&quot; scrub()&quot;); } public String toString() { return s; } public static void main(String[] args) {</p>
<p>Cleanser x = new Cleanser(); x.dilute(); x.apply(); x.scrub(); print(x);</p>
<p>}</p>
<p>}</p>
<p>public class Detergent extends Cleanser {</p>
<p>// Change a method: public void scrub() {</p>
<p>append(&quot; Detergent.scrub()&quot;); super.scrub(); // Call base-class version</p>
<p>}</p>
<p>// Add methods to the interface: public void foam() { append(&quot; foam()&quot;); }</p>
<p>// Test the new class:</p>
<p>public static void main(String[] args) {</p>
<p>Detergent x = new Detergent();</p>
<p>x.dilute();</p>
<p>x.apply();</p>
<p>x.scrub();</p>
<p>x.foam();</p>
<p>print(x);</p>
<p>print(&quot;Testing base class:&quot;);</p>
<p>Cleanser.main(args);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Cleanser dilute() apply() Detergent.scrub() scrub() foam()</p>
<p>Testing base class:</p>
<p>Cleanser dilute() apply() scrub()</p>
<p>*///:~</p>
<p>This demonstrates a number of features. First, in the Cleanser append( ) method, Strings are concatenated to s using the += operator, which is one of the operators (along with ‘+’) that the Java designers “overloaded” to work with Strings.</p>
<p>Second, both Cleanser and Detergent contain a main( ) method. You can create a main( ) for each one of your classes; this technique of putting a main() in each class allows easy testing for each class. And you don’t need to remove the main() when you’re finished; you can leave it in for later testing.</p>
<p>Even if you have a lot of classes in a program, only the main( ) for the class invoked on the command line will be called. So in this case, when you say java Detergent, Detergent.main( ) will be called. But you can also say java Cleanser to invoke Cleanser.main( ), even though Cleanser is not a public class. Even if a class has package access, a public main() is accessible.</p>
<p>Here, you can see that Detergent.main( ) calls Cleanser.main( ) explicitly, passing it the same arguments from the command line (however, you could pass it any String array).</p>
<p>It’s important that all of the methods in Cleanser are public. Remember that if you leave off any access specifier, the member defaults to package access, which allows access only to package members. Thus, within this package, anyone could use those methods if there were no access specifier. Detergent would have no trouble, for example. However, if a class from some other package were to inherit from Cleanser, it could access only public members. So to allow for inheritance, as a general rule make all fields private and all methods public. (protected members also allow access by derived classes; you’ll learn about this later.) Of course, in particular cases you must make adjustments, but this is a useful guideline.</p>
<p>Cleanser has a set of methods in its interface: append( ), dilute( ), apply( ), scrub( ),</p>
<p>and toString( ). Because Detergent is derived from Cleanser (via the extends keyword), it automatically gets all these methods in its interface, even though you don’t see them all explicitly defined in Detergent. You can think of inheritance, then, as reusing the class.</p>
<p>As seen in scrub( ), it’s possible to take a method that’s been defined in the base class and modify it. In this case, you might want to call the method from the base class inside the new version. But inside scrub( ), you cannot simply call scrub( ), since that would produce a recursive call, which isn’t what you want. To solve this problem, Java has the keyword super that refers to the “superclass” that the current class inherits. Thus the expression super.scrub( ) calls the base-class version of the method scrub( ).</p>
<p>When inheriting you’re not restricted to using the methods of the base class. You can also add new methods to the derived class exactly the way you put any method in a class: Just define it. The method foam( ) is an example of this.</p>
<p>In Detergent.main( ) you can see that for a Detergent object, you can call all the methods that are available in Cleanser as well as in Detergent (i.e., foam( )).</p>
<p>Exercise 2: (2) Inherit a new class from class Detergent. Override scrub( ) and add a new method called sterilize( ).</p>
<subtitle>Initializing the base class</subtitle>
<p>Since there are now two classes involved—the base class and the derived class—instead of just one, it can be a bit confusing to try to imagine the resulting object produced by a derived class. From the outside, it looks like the new class has the same interface as the base class and maybe some additional methods and fields. But inheritance doesn’t just copy the interface of the base class. When you create an object of the derived class, it contains within it a subobject of the base class. This subobject is the same as if you had created an object of the base class by itself. It’s just that from the outside, the subobject of the base class is wrapped within the derived-class object.</p>
<p>Of course, it’s essential that the base-class subobject be initialized correctly, and there’s only one way to guarantee this: Perform the initialization in the constructor by calling the base-class constructor, which has all the appropriate knowledge and privileges to perform the base-class initialization. Java automatically inserts calls to the base-class constructor in the derived-class constructor. The following example shows this working with three levels of inheritance:</p>
<p>//: reusing/Cartoon.java</p>
<p>// Constructor calls during inheritance.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Art {</p>
<p>Art() { print(&quot;Art constructor&quot;); }</p>
<p>}</p>
<p>class Drawing extends Art {</p>
<p>Drawing() { print(&quot;Drawing constructor&quot;); }</p>
<p>}</p>
<p>public class Cartoon extends Drawing {</p>
<p>public Cartoon() { print(&quot;Cartoon constructor&quot;); } public static void main(String[] args) {</p>
<p>Cartoon x = new Cartoon();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Art constructor Drawing constructor Cartoon constructor *///:~</p>
<p>You can see that the construction happens from the base “outward,” so the base class is initialized before the derived-class constructors can access it. Even if you don’t create a constructor for Cartoon( ), the compiler will synthesize a default constructor for you that calls the base class constructor.</p>
<p>Exercise 3: (2) Prove the previous sentence.</p>
<p>Exercise 4: (2) Prove that the base-class constructors are (a) always called and (b) called before derived-class constructors.</p>
<p>Exercise 5: (1) Create two classes, A and B, with default constructors (empty argument lists) that announce themselves. Inherit a new class called C from A, and create a member of class B inside C. Do not create a constructor for C. Create an object of class C and observe the results.</p>
<p>Constructors with arguments</p>
<p>The preceding example has default constructors; that is, they don’t have any arguments. It’s easy for the compiler to call these because there’s no question about what arguments to pass. If your class doesn’t have default arguments, or if you want to call a base-class constructor that has an argument, you must explicitly write the calls to the base-class constructor using the super keyword and the appropriate argument list:</p>
<p>//: reusing/Chess.java</p>
<p>// Inheritance, constructors and arguments. import static net.mindview.util.Print.*;</p>
<p>class Game {</p>
<p>Game(int i) {</p>
<p>print(&quot;Game constructor&quot;);</p>
<p>class BoardGame extends Game { BoardGame(int i) { super(i);</p>
<p>print(&quot;BoardGame constructor&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class Chess extends BoardGame { Chess() { super(11);</p>
<p>print(&quot;Chess constructor&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { Chess x = new Chess();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Game constructor BoardGame constructor Chess constructor *///:~</p>
<p>If you don’t call the base-class constructor in BoardGame( ), the compiler will complain that it can’t find a constructor of the form Game( ). In addition, the call to the base-class constructor must be the first thing you do in the derived-class constructor. (The compiler will remind you if you get it wrong.)</p>
<p>Exercise 6: (1) Using Chess.java, prove the statements in the previous paragraph.</p>
<p>Exercise 7: (1) Modify Exercise 5 so that A and B have constructors with arguments instead of default constructors. Write a constructor for C and perform all initialization within C’s constructor.</p>
<p>Exercise 8: (1) Create a base class with only a non-default constructor, and a derived class with both a default (no-arg) and non-default constructor. In the derived-class constructors, call the base-class constructor.</p>
<p>Exercise 9: (2) Create a class called Root that contains an instance of each of the classes (that you also create) named Component! Component2, and Component3. Derive a class Stem from Root that also contains an instance of each “component.” All classes should have default constructors that print a message about that class.</p>
<p>Exercise 10: (1) Modify the previous exercise so that each class only has non-default constructors.</p>
</section>
<section>
<title>
<p>Delegation</p></title><empty-line/>
<p>A third relationship, which is not directly supported by Java, is called delegation. This is midway between inheritance and composition, because you place a member object in the class you’re building (like composition), but at the same time you expose all the methods from the member object in your new class (like inheritance). For example, a spaceship needs a control module:</p>
<p>//: reusing/SpaceShipControls.java</p>
<p>public class SpaceShipControls { void up(int velocity) {} void down(int velocity) {} void left(int velocity) {} void right(int velocity) {} void forward(int velocity) {} void back(int velocity) {} void turboBoost() {}</p>
<p>} ///:~</p>
<p>One way to build a spaceship is to use inheritance:</p>
<p>//: reusing/SpaceShip.java</p>
<p>public class SpaceShip extends SpaceShipControls { private String name;</p>
<p>public SpaceShip(String name) { this.name = name; } public String toString() { return name; } public static void main(String[] args) {</p>
<p>SpaceShip protector = new SpaceShip(&quot;NSEA Protector&quot;); protector.forward(100);</p>
<p>}</p>
<p>} ///:~</p>
<p>However, a SpaceShip isn’t really “a type of’ SpaceShipControls, even if, for example, you “tell” a SpaceShip to go forward( ). It’s more accurate to say that a SpaceShip contains SpaceShipControls, and at the same time all the methods in SpaceShipControls are exposed in a SpaceShip. Delegation solves the dilemma:</p>
<p>//: reusing/SpaceShipDelegation.java</p>
<p>public class SpaceShipDelegation { private String name; private SpaceShipControls controls = new SpaceShipControls(); public SpaceShipDelegation(String name) { this.name = name;</p>
<p>}</p>
<p>// Delegated methods: public void back(int velocity) { controls.back(velocity);</p>
<p>}</p>
<p>public void down(int velocity) { controls.down(velocity);</p>
<p>}</p>
<p>public void forward(int velocity) { controls.forward(velocity);</p>
<p>}</p>
<p>public void left(int velocity) { controls.left(velocity);</p>
<p>}</p>
<p>public void right(int velocity) { controls.right(velocity);</p>
<p>}</p>
<p>public void turboBoost() { controls.turboBoost();</p>
<p>}</p>
<p>public void up(int velocity) { controls.up(velocity);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>SpaceShipDelegation protector =</p>
<p>new SpaceShipDelegation(&quot;NSEA Protector&quot;); protector.forward(100);</p>
<p>} ///:~</p>
<p>You can see how the methods are forwarded to the underlying controls object, and the interface is thus the same as it is with inheritance. However, you have more control with delegation because you can choose to provide only a subset of the methods in the member object.</p>
<p>Although the Java language doesn’t support delegation, development tools often do. The above example, for instance, was automatically generated using the JetBrains Idea IDE.</p>
<p>Exercise 11: (3) Modify Detergent.java so that it uses delegation.</p>
</section>
<section>
<title>
<p>Combining composition and inheritance</p></title><empty-line/>
<p>It is very common to use composition and inheritance together. The following example shows the creation of a more complex class, using both inheritance and composition, along with the necessary constructor initialization:</p>
<p>//: reusing/PlaceSetting.java // Combining composition &amp; inheritance. import static net.mindview.util.Print.*;</p>
<p>class Plate {</p>
<p>Plate(int i) {</p>
<p>print(&quot;Plate constructor&quot;);</p>
<p>}</p>
<p>}</p>
<p>class DinnerPlate extends Plate {</p>
<p>DinnerPlate(int i) { super(i);</p>
<p>print(&quot;DinnerPlate constructor&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Utensil {</p>
<p>Utensil(int i) {</p>
<p>print(&quot;Utensil constructor&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Spoon extends Utensil {</p>
<p>Spoon(int i) { super(i);</p>
<p>print(&quot;Spoon constructor&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Fork extends Utensil {</p>
<p>Fork(int i) { super(i);</p>
<p>print(&quot;Fork constructor&quot;);</p>
<p>}</p>
<p>class Knife extends Utensil {</p>
<p>Knife(int i) { super(i);</p>
<p>print(&quot;Knife constructor&quot;);</p>
<p>}</p>
<p>}</p>
<p>// A cultural way of doing something: class Custom {</p>
<p>Custom(int i) {</p>
<p>print(&quot;Custom constructor&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class PlaceSetting extends Custom { private Spoon sp; private Fork frk; private Knife kn; private DinnerPlate pl; public PlaceSetting(int i) { super(i + 1); sp = new Spoon(i + 2); frk = new Fork(i + 3); kn = new Knife(i + 4); pl = new DinnerPlate(i + 5); print(&quot;PlaceSetting constructor&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { PlaceSetting x = new PlaceSetting(9);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Custom constructor Utensil constructor Spoon constructor Utensil constructor Fork constructor Utensil constructor Knife constructor Plate constructor DinnerPlate constructor PlaceSetting constructor *///:~</p>
<p>Although the compiler forces you to initialize the base classes, and requires that you do it right at the beginning of the constructor, it doesn’t watch over you to make sure that you initialize the member objects, so you must remember to pay attention to that.</p>
<p>It’s rather amazing how cleanly the classes are separated. You don’t even need the source code for the methods in order to reuse the code. At most, you just import a package. (This is true for both inheritance and composition.)</p>
<subtitle>Guaranteeing proper cleanup</subtitle>
<p>Java doesn’t have the C++ concept of a destructor, a method that is automatically called when an object is destroyed. The reason is probably that in Java, the practice is simply to forget about objects rather than to destroy them, allowing the garbage collector to reclaim the memory as necessary.</p>
<p>Often this is fine, but there are times when your class might perform some activities during its lifetime that require cleanup. As mentioned in the Initialization &amp; Cleanup chapter, you can’t know when the garbage collector will be called, or if it will be called. So if you want something cleaned up for a class, you must explicitly write a special method to do it, and make sure that the client programmer knows that they must call this method. On top of this—as described in the Error Handling with Exceptions chapter—you must guard against an exception by putting such cleanup in a finally clause.</p>
<p>Consider an example of a computer-aided design system that draws pictures on the screen:</p>
<p>//: reusing/CADSystem.java // Ensuring proper cleanup. package reusing;</p>
<p>import static net.mindview.util.Print.*; class Shape {</p>
<p>Shape(int i) { print(&quot;Shape constructor&quot;); } void dispose() { print(&quot;Shape dispose&quot;); }</p>
<p>}</p>
<p>class Circle extends Shape {</p>
<p>Circle(int i) { super(i);</p>
<p>print(&quot;Drawing Circle&quot;);</p>
<p>}</p>
<p>void dispose() {</p>
<p>print(&quot;Erasing Circle&quot;); super.dispose();</p>
<p>}</p>
<p>}</p>
<p>class Triangle extends Shape {</p>
<p>Triangle(int i) { super(i);</p>
<p>print(&quot;Drawing Triangle&quot;);</p>
<p>}</p>
<p>void dispose() {</p>
<p>print(&quot;Erasing Triangle&quot;); super.dispose();</p>
<p>}</p>
<p>}</p>
<p>class Line extends Shape { private int start, end;</p>
<p>Line(int start, int end) { super(start); this.start = start; this.end = end;</p>
<p>print(&quot;Drawing Line: &quot; + start + &quot;, &quot; + end);</p>
<p>}</p>
<p>void dispose() {</p>
<p>print(&quot;Erasing Line: &quot; + start + &quot;, &quot; + end); super.dispose();</p>
<p>}</p>
<p>}</p>
<p>public class CADSystem extends Shape { private Circle c; private Triangle t; private Line[] lines = new Line[3]; public CADSystem(int i) { super(i + 1);</p>
<p>for(int j = 0; j &lt; lines.length; j++) Hnes[j] = new Line(j, j*j); c = new Circle(1); t = new Triangle(l); print(&quot;Combined constructor&quot;);</p>
<p>}</p>
<p>public void dispose() {</p>
<p>print(&quot;CADSystem.dispose()&quot;);</p>
<p>// The order of cleanup is the reverse // of the order of initialization: t.dispose(); c.dispose();</p>
<p>for(int i = lines.length - 1; i &gt;= 0; i--) lines[i].dispose(); super.dispose();</p>
<p>}</p>
<p>public static void main(String[] args) { CADSystem x = new CADSystem(47); try {</p>
<p>// Code and exception handling...</p>
<p>} finally { x.dispose();</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Shape constructor Shape constructor Drawing Line: 0, 0 Shape constructor Drawing Line: 1, 1 Shape constructor Drawing Line: 2, 4 Shape constructor Drawing Circle Shape constructor Drawing Triangle Combined constructor CADSystem.dispose()</p>
<p>Erasing Triangle Shape dispose Erasing Circle Shape dispose Erasing Line: 2, 4 Shape dispose Erasing Line: 1, 1 Shape dispose Erasing Line: 0, 0 Shape dispose Shape dispose *///:~</p>
<p>Everything in this system is some kind of Shape (which is itself a kind of Object, since it’s implicitly inherited from the root class). Each class overrides Shape’s dispose( ) method in addition to calling the base-class version of that method using super. The specific Shape classes—Circle, Triangle, and Line-all have constructors that “draw,” although any method called during the lifetime of the object could be responsible for doing something that needs cleanup. Each class has its own dispose( ) method to restore non-memory things back to the way they were before the object existed.</p>
<p>In main( ), you can see two keywords that are new, and won’t be explained until the Error Handling with Exceptions chapter: try and finally. The try keyword indicates that the block that follows (delimited by curly braces) is a guarded region, which means that it is given special treatment. One of these special treatments is that the code in the finally clause following this guarded region is always executed, no matter how the try block exits. (With exception handling, it’s possible to leave a try block in a number of non-ordinary ways.) Here, the finally clause is saying “always call dispose( ) for x, no matter what happens.”</p>
<p>Note that in your cleanup method, you must also pay attention to the calling order for the base-class and member-object cleanup methods in case one subobject depends on another. In general, you should follow the same form that is imposed by a C++ compiler on its destructors: First perform all of the cleanup work specific to your class, in the reverse order of creation. (In general, this requires that base-class elements still be viable.) Then call the base-class cleanup method, as demonstrated here.</p>
<p>There can be many cases in which the cleanup issue is not a problem; you just let the garbage collector do the work. But when you must do it explicitly, diligence and attention are required, because there’s not much you can rely on when it comes to garbage collection. The garbage collector might never be called. If it is, it can reclaim objects in any order it wants. You can’t rely on garbage collection for anything but memory reclamation. If you want cleanup to take place, make your own cleanup methods and don’t use on finalize( ).</p>
<p>Exercise 12: (3) Add a proper hierarchy of dispose( ) methods to all the classes in Exercise 9.</p>
<subtitle>Name hiding</subtitle>
<p>If a Java base class has a method name that’s overloaded several times, redefining that method name in the derived class will not hide any of the base-class versions (unlike C++). Thus overloading works regardless of whether the method was defined at this level or in a base class:</p>
<p>//: reusing/Hide.java</p>
<p>// Overloading a base-class method name in a derived // class does not hide the base-class versions. import static net.mindview.util.Print.*;</p>
<p>class Homer {</p>
<p>char doh(char c) { print(&quot;doh(char)&quot;); return ‘d’;</p>
<p>}</p>
<p>float doh(float f) { print(&quot;doh(float)&quot;); return 1.0f;</p>
<p>}</p>
<p>}</p>
<p>class Milhouse {}</p>
<p>class Bart extends Homer { void doh(Milhouse m) { print(&quot;doh(Milhouse)&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class Hide {</p>
<p>public static void main(String[] args) {</p>
<p>Bart b = new Bart(); b.doh(1); b.doh(‘x’); b.doh(1.0f);</p>
<p>b.doh(new MilhouseQ);</p>
<p>} /* Output:</p>
<p>doh(float)</p>
<p>doh(char)</p>
<p>doh(float)</p>
<p>doh(Milhouse)</p>
<p>*///:~</p>
<p>You can see that all the overloaded methods of Homer are available in Bart, even though Bart introduces a new overloaded method (in C++ doing this would hide the base-class methods). As you’ll see in the next chapter, it’s far more common to override methods of the same name, using exactly the same signature and return type as in the base class. It can be confusing otherwise (which is why C++ disallows it—to prevent you from making what is probably a mistake).</p>
<p>Java SE5 has added the @Override annotation, which is not a keyword but can be used as if it were. When you mean to override a method, you can choose to add this annotation and the compiler will produce an error message if you accidentally overload instead of overriding.</p>
<p>//: reusing/Lisa.java // {CompileTimeError} (Won’t compile)</p>
<p>class Lisa extends Homer {</p>
<p>@Override void doh(Milhouse m) {</p>
<p>System.out.println(&quot;doh(Milhouse)&quot;);</p>
<p>}</p>
<p>} ///:~</p>
<p>The {CompileTimeError} tag excludes the file from this book’s Ant build, but if you compile it by hand you’ll see the error message:</p>
<p>method does not override a method from its superclass</p>
<p>The @Override annotation will thus prevent you from accidentally overloading when you don’t mean to.</p>
<p>Exercise 13: (2) Create a class with a method that is overloaded three times. Inherit a new class, add a new overloading of the method, and show that all four methods are available in the derived class.</p>
</section>
<section>
<title>
<p>Choosing composition vs. inheritance</p></title><empty-line/>
<p>Both composition and inheritance allow you to place subobjects inside your new class (composition explicitly does this—with inheritance it’s implicit). You might wonder about the difference between the two, and when to choose one over the other.</p>
<p>Composition is generally used when you want the features of an existing class inside your new class, but not its interface. That is, you embed an object so that you can use it to implement features in your new class, but the user of your new class sees the interface you’ve defined for the new class rather than the interface from the embedded object. For this effect, you embed private objects of existing classes inside your new class.</p>
<p>Sometimes it makes sense to allow the class user to directly access the composition of your new class; that is, to make the member objects public. The member objects use</p>
<p>implementation hiding themselves, so this is a safe thing to do. When the user knows you’re assembling a bunch of parts, it makes the interface easier to understand. A car object is a good example:</p>
<p>//: reusing/Car.java // Composition with public objects.</p>
<p>class Engine {</p>
<p>public void start() {} public void rev() {} public void stop() {}</p>
<p>}</p>
<p>class Wheel {</p>
<p>public void inflate(int psi) {}</p>
<p>}</p>
<p>class Window {</p>
<p>public void rollup() {} public void rolldown() {}</p>
<p>}</p>
<p>class Door {</p>
<p>public Window window = new Window(); public void open() {} public void close() {}</p>
<p>}</p>
<p>public class Car {</p>
<p>public Engine engine = new Engine(); public Wheel[] wheel = new Wheel[4]; public Door</p>
<p>left = new Door(), right = new Door(); // 2-door public Car() {</p>
<p>for(int i = 0; i &lt; 4; i++) wheel[i] = new Wheel();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Car car = new Car();</p>
<p>car.left.window.rollup();</p>
<p>car.wheel[0].inflate(72);</p>
<p>}</p>
<p>} ///:~</p>
<p>Because in this case the composition of a car is part of the analysis of the problem (and not simply part of the underlying design), making the members public assists the client programmer’s understanding of how to use the class and requires less code complexity for the creator of the class. However, keep in mind that this is a special case, and that in general you should make fields private.</p>
<p>When you inherit, you take an existing class and make a special version of it. In general, this means that you’re taking a general-purpose class and specializing it for a particular need. With a little thought, you’ll see that it would make no sense to compose a car using a vehicle object—a car doesn’t contain a vehicle, it is a vehicle. The is-a relationship is expressed with inheritance, and the has-a relationship is expressed with composition.</p>
<p>Exercise 14: (1) In Car.java add a service( ) method to Engine and call this method in main( ).</p>
</section>
<section>
<title>
<p>protected</p></title><empty-line/>
<p>Now that you’ve been introduced to inheritance, the keyword protected finally has meaning. In an ideal world, the private keyword would be enough. In real projects, there are times when you want to make something hidden from the world at large and yet allow access for members of derived classes.</p>
<p>The protected keyword is a nod to pragmatism. It says “This is private as far as the class user is concerned, but available to anyone who inherits from this class or anyone else in the same package.” (In Java, protected also provides package access.)</p>
<p>Although it’s possible to create protected fields, the best approach is to leave the fields private; you should always preserve your right to change the underlying implementation. You can then allow controlled access to inheritors of your class through protected methods:</p>
<p>//: reusing/Orc.java</p>
<p>// The protected keyword.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Villain {</p>
<p>private String name;</p>
<p>protected void set(String nm) { name = nm; } public Villain(String name) { this.name = name; } public String toString() {</p>
<p>return &quot;I’m a Villain and my name is &quot; + name;</p>
<p>}</p>
<p>}</p>
<p>public class Orc extends Villain { private int orcNumber;</p>
<p>public Orc(String name, int orcNumber) { super(name);</p>
<p>this.orcNumber = orcNumber;</p>
<p>}</p>
<p>public void change(String name, int orcNumber) { set(name); // Available because it’s protected this.orcNumber = orcNumber;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;Orc &quot; + orcNumber + &quot;: &quot; + super.toString();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Orc orc = new Orc(&quot;Limburger&quot;, 12); print(orc);</p>
<p>orc.change(&quot;Bob&quot;, 19); print(orc);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Orc 12: I’m a Villain and my name is Limburger Orc 19: I’m a Villain and my name is Bob *///:~</p>
<p>You can see that change( ) has access to set( ) because it’s protected. Also note the way that Orc’s toString( ) method is defined in terms of the base-class version of toString( ).</p>
<p>Exercise 15: (2) Create a class inside a package. Your class should contain a protected method. Outside of the package, try to call the protected method and explain the results. Now inherit from your class and call the protected method from inside a method of your derived class.</p>
</section>
<section>
<title>
<p>Upcasting</p></title><empty-line/>
<p>The most important aspect of inheritance is not that it provides methods for the new class.</p>
<p>It’s the relationship expressed between the new class and the base class. This relationship can be summarized by saying, “The new class is a type of the existing class.”</p>
<p>This description is not just a fanciful way of explaining inheritance—it’s supported directly by the language. As an example, consider a base class called Instrument that represents musical instruments, and a derived class called Wind. Because inheritance means that all of the methods in the base class are also available in the derived class, any message you can send to the base class can also be sent to the derived class. If the Instrument class has a play( ) method, so will Wind instruments. This means we can accurately say that a Wind object is also a type of Instrument. The following example shows how the compiler supports this notion:</p>
<p>//: reusing/Wind.java // Inheritance &amp; upcasting.</p>
<p>class Instrument { public void play() {} static void tune(Instrument i) {</p>
<p>// ... i.play();</p>
<p>}</p>
<p>}</p>
<p>// Wind objects are instruments // because they have the same interface: public class Wind extends Instrument { public static void main(String[] args) {</p>
<p>Wind flute = new Wind();</p>
<p>Instrument.tune(flute); // Upcasting</p>
<p>}</p>
<p>} ///:~</p>
<p>What’s interesting in this example is the tune( ) method, which accepts an Instrument reference. However, in Wind.main( ) the tune( ) method is called by giving it a Wind reference. Given that Java is particular about type checking, it seems strange that a method that accepts one type will readily accept another type, until you realize that a Wind object is also an Instrument object, and there’s no method that tune( ) could call for an Instrument that isn’t also in Wind. Inside tune( ), the code works for Instrument and anything derived from Instrument, and the act of converting a Wind reference into an Instrument reference is called upcasting.</p>
<subtitle>Why &quot;upcasting&quot;?</subtitle>
<p>The term is based on the way that class inheritance diagrams have traditionally been drawn: with the root at the top of the page, growing downward. (Of course, you can draw your diagrams any way you find helpful.) The inheritance diagram for Wind.java is then:</p><image l:href="#image14.jpg"/>
<p>Casting from a derived type to a base type moves up on the inheritance diagram, so it’s commonly referred to as upcasting. Upcasting is always safe because you’re going from a more specific type to a more general type. That is, the derived class is a superset of the base class. It might contain more methods than the base class, but it must contain at least the methods in the base class. The only thing that can occur to the class interface during the upcast is that it can lose methods, not gain them. This is why the compiler allows upcasting without any explicit casts or other special notation.</p>
<p>You can also perform the reverse of upcasting, called downcasting, but this involves a dilemma that will be examined further in the next chapter, and in the Type Information chapter.</p>
<subtitle>Composition vs. inheritance revisited</subtitle>
<p>In object-oriented programming, the most likely way that you’ll create and use code is by simply packaging data and methods together into a class, and using objects of that class. You’ll also use existing classes to build new classes with composition. Less frequently, you’ll use inheritance. So although inheritance gets a lot of emphasis while learning OOP, it doesn’t mean that you should use it everywhere you possibly can. On the contrary, you should use it sparingly, only when it’s clear that inheritance is useful. One of the clearest ways to determine whether you should use composition or inheritance is to ask whether you’ll ever need to upcast from your new class to the base class. If you must upcast, then inheritance is necessary, but if you don’t need to upcast, then you should look closely at whether you need inheritance. The Polymorphism chapter provides one of the most compelling reasons for upcasting, but if you remember to ask “Do I need to upcast?” you’ll have a good tool for deciding between composition and inheritance.</p>
<p>Exercise 16: (2) Create a class called Amphibian. From this, inherit a class called Frog. Put appropriate methods in the base class. In main( ), create a Frog and upcast it to Amphibian and demonstrate that all the methods still work.</p>
<p>Exercise 17: (1) Modify Exercise 16 so that Frog overrides the method definitions from the base class (provides new definitions using the same method signatures). Note what happens in main( ).</p>
</section>
<section>
<title>
<p>The final keyword</p></title><empty-line/>
<p>Java’s final keyword has slightly different meanings depending on the context, but in general it says “This cannot be changed.” You might want to prevent changes for two reasons: design or efficiency. Because these two reasons are quite different, it’s possible to misuse the final keyword.</p>
<p>The following sections discuss the three places where final can be used: for data, methods, and classes.</p>
<subtitle>final data</subtitle>
<p>Many programming languages have a way to tell the compiler that a piece of data is “constant.” A constant is useful for two reasons:</p>
<p>1.    It can be a compile-time constant that won’t ever change.</p>
<p>2.    It can be a value initialized at run time that you don’t want changed.</p>
<p>In the case of a compile-time constant, the compiler is allowed to “fold” the constant value into any calculations in which it’s used; that is, the calculation can be performed at compile time, eliminating some run-time overhead. In Java, these sorts of constants must be primitives and are expressed with the final keyword. A value must be given at the time of definition of such a constant.</p>
<p>A field that is both static and final has only one piece of storage that cannot be changed.</p>
<p>When final is used with object references rather than primitives, the meaning can be confusing. With a primitive, final makes the value a constant, but with an object reference, final makes the reference a constant. Once the reference is initialized to an object, it can never be changed to point to another object. However, the object itself can be modified; Java does not provide a way to make any arbitrary object a constant. (You can, however, write your class so that objects have the effect of being constant.) This restriction includes arrays, which are also objects.</p>
<p>Here’s an example that demonstrates final fields. Note that by convention, fields that are both static and final (that is, compile-time constants) are capitalized and use underscores to separate words.</p>
<p>//: reusing/FinalData.java // The effect of final on fields. import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Value {</p>
<p>int i; // Package access</p>
<p>public Value(int i) { this.i = i; }</p>
<p>}</p>
<p>public class FinalData {</p>
<p>private static Random rand = new Random(47); private String id;</p>
<p>public FinalData(String id) { this.id = id; }</p>
<p>// Can be compile-time constants: private final int valueOne = 9; private static final int VALUE_TWO = 99;</p>
<p>// Typical public constant:</p>
<p>public static final int VALUE_THREE = 39;</p>
<p>// Cannot be compile-time constants: private final int i4 = rand.nextInt(20); static final int INT_5 = rand.nextInt(20); private Value v1 = new Value(11); private final Value v2 = new Value(22); private static final Value VAL_3 = new Value(33);</p>
<p>// Arrays:</p>
<p>private final int[] a = { 1, 2, 3, 4, 5, 6 }; public String toString() {</p>
<p>return id + &quot;: &quot; + &quot;i4 = &quot; + i4 + &quot;, INT_5 = &quot; + INT_5;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>FinalData fd1 = new FinalData(&quot;fd1&quot;);</p>
<p>//! fd1.valueOne++; // Error: can’t change value fd1.v2.i++; // Object isn’t constant! fdl.vl = new Value(9); // OK -- not final for(int i = 0; i &lt; fdl.a.length; i++) fd1.a[i]++; // Object isn’t constant!</p>
<p>Error: Can’t // change reference</p>
<p>//! fd1.v2 = new Value(0); //</p>
<p>//! fd1.VAL_3 = new Value(1);</p>
<p>//! fd1.a = new int[3];</p>
<p>}</p>
<p>INT_5 = 18 FinalData INT_5 = 18 INT 5 = 18</p>
<p>print(fd1); print(&quot;Creating FinalData fd2 = print(fd1); print(fd2);</p>
<p>} /* Output: fd1: i4 = 15, Creating new fd1: i4 = 15, fd2: i4 = 13, *///:~</p>
<p>new FinalData&quot;); new FinalData(&quot;fd2&quot;);</p>
<p>Since valueOne and VALUE_TWO are final primitives with compile-time values, they can both be used as compile-time constants and are not different in any important way. VALUE_THREE is the more typical way you’ll see such constants defined: public so they’re usable outside the package, static to emphasize that there’s only one, and final to say that it’s a constant. Note that final static primitives with constant initial values (that is, compile-time constants) are named with all capitals by convention, with words separated by underscores. (This is just like C constants, which is where the convention originated.)</p>
<p>Just because something is final doesn’t mean that its value is known at compile time. This is demonstrated by initializing i4 and INT 5 at run time using randomly generated numbers. This portion of the example also shows the difference between making a final value static or non-static. This difference shows up only when the values are initialized at run time, since the compile-time values are treated the same by the compiler. (And presumably optimized out of existence.) The difference is shown when you run the program. Note that the values of i4 for fd1 and fd2 are unique, but the value for INT 5 is not changed by creating the second FinalData object. That’s because it’s static and is initialized once upon loading and not each time a new object is created.</p>
<p>The variables v1 through VAL 3 demonstrate the meaning of a final reference. As you can see in main( ), just because v2 is final doesn’t mean that you can’t change its value.</p>
<p>Because it’s a reference, final means that you cannot rebind v2 to a new object. You can also see that the same meaning holds true for an array, which is just another kind of reference. (There is no way that I know of to make the array references themselves final.) Making references final seems less useful than making primitives final.</p>
<p>Exercise 18: (2) Create a class with a static final field and a final field and demonstrate the difference between the two.</p>
<p>Blank finals</p>
<p>Java allows the creation of blank finals, which are fields that are declared as final but are not given an initialization value. In all cases, the blank final must be initialized before it is used, and the compiler ensures this. However, blank finals provide much more flexibility in the use of the final keyword since, for example, a final field inside a class can now be different for each object, and yet it retains its immutable quality. Here’s an example:</p>
<p>//: reusing/BlankFinal.java // &quot;Blank&quot; final fields.</p>
<p>class Poppet { private int i;</p>
<p>Poppet(int ii) { i = ii; }</p>
<p>}</p>
<p>public class BlankFinal {</p>
<p>private final int i = 0; // Initialized final private final int j; // Blank final private final Poppet p; // Blank final reference // Blank finals MUST be initialized in the constructor: public BlankFinal() {</p>
<p>j = 1; // Initialize blank final</p>
<p>p = new Poppet(1); // Initialize blank final reference</p>
<p>}</p>
<p>public BlankFinal(int x) {</p>
<p>j = x; // Initialize blank final</p>
<p>p = new Poppet(x); // Initialize blank final reference</p>
<p>}</p>
<p>public static void main(String[] args) { new BlankFinal(); new BlankFinal(47);</p>
<p>}</p>
<p>} ///:~</p>
<p>You’re forced to perform assignments to finals either with an expression at the point of definition of the field or in every constructor. That way it’s guaranteed that the final field is always initialized before use.</p>
<p>Exercise 19: (2) Create a class with a blank final reference to an object. Perform the initialization of the blank final inside all constructors. Demonstrate the guarantee that the final must be initialized before use, and that it cannot be changed once initialized.</p>
<p>final arguments</p>
<p>Java allows you to make arguments final by declaring them as such in the argument list. This means that inside the method you cannot change what the argument reference points to:</p>
<p>//: reusing/FinalArguments.java // Using &quot;final&quot; with method arguments.</p>
<p>class Gizmo {</p>
<p>public void spin() {}</p>
<p>}</p>
<p>public class FinalArguments { void with(final Gizmo g) {</p>
<p>//! g = new Gizmo(); // Illegal -- g is final</p>
<p>}</p>
<p>void without(Gizmo g) {</p>
<p>g = new Gizmo(); // OK -- g not final g.spin();</p>
<p>}</p>
<p>// void f(final int i) { i++; } // Can’t change // You can only read from a final primitive: int g(final int i) { return i + 1; } public static void main(String[] args) {</p>
<p>FinalArguments bf = new FinalArguments();</p>
<p>bf.without(null);</p>
<p>bf.with(null);</p>
<p>} ///:~</p>
<p>The methods f( ) and g( ) show what happens when primitive arguments are final: You can read the argument, but you can’t change it. This feature is primarily used to pass data to anonymous inner classes, which you’ll learn about in the Inner Classes chapter.</p>
<subtitle>final methods</subtitle>
<p>There are two reasons for final methods. The first is to put a “lock” on the method to prevent any inheriting class from changing its meaning. This is done for design reasons when you want to make sure that a method’s behavior is retained during inheritance and cannot be overridden.</p>
<p>The second reason for final methods is efficiency. In earlier implementations of Java, if you made a method final, you allowed the compiler to turn any calls to that method into inline calls. When the compiler saw a final method call, it could (at its discretion) skip the normal approach of inserting code to perform the method call mechanism (push arguments on the stack, hop over to the method code and execute it, hop back and clean off the stack arguments, and deal with the return value) and instead replace the method call with a copy of the actual code in the method body. This eliminated the overhead of the method call. Of course, if a method is big, then your code begins to bloat, and you probably wouldn’t see any performance gains from inlining, since any improvements will be dwarfed by the amount of time spent inside the method.</p>
<p>In more recent version of Java, the virtual machine (in particular, the hotspot technologies) can detect these situations and optimize away the extra indirection, so its no longer necessary-in fact, it is now generally discouraged-to use final to try to help the optimizer. With Java SE5/6, you should let the compiler and JVM handle efficiency issues and make a method final only if you want to explicitly prevent overriding.<a l:href="#bookmark28" type="note"><sup>29</sup></a><sup></sup></p>
<p>final and private</p>
<p>Any private methods in a class are implicitly final. Because you can’t access a private method, you can’t override it. You can add the final specifier to a private method, but it doesn’t give that method any extra meaning.</p>
<p>This issue can cause confusion, because if you try to override a private method (which is implicitly final), it seems to work, and the compiler doesn’t give an error message:</p>
<p>//: reusing/FinalOverridinglllusion.java // It only looks like you can override // a private or private final method. import static net.mindview.util.Print.*;</p>
<p>class WithFinals {</p>
<p>// Identical to &quot;private&quot; alone:</p>
<p>private final void f() { print(&quot;WithFinals.f()&quot;); }</p>
<p>// Also automatically &quot;final&quot;:</p>
<p>private void g() { print(&quot;WithFinals.g()&quot;); }</p>
<p>}</p>
<p>class OverridingPrivate extends WithFinals {</p>
<p>private final void f() {</p>
<p>print(&quot;OverridingPrivate.f()&quot;);</p>
<p>}</p>
<p>private void g() {</p>
<p>print(&quot;OverridingPrivate.g()&quot;);</p>
<p>}</p>
<p>}</p>
<p>class OverridingPrivate2 extends OverridingPrivate {</p>
<p>public final void f() {</p>
<p>print(&quot;OverridingPrivate2.f()&quot;);</p>
<p>}</p>
<p>public void g() {</p>
<p>print(&quot;OverridingPrivate2.g()&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class FinalOverridingIllusion {</p>
<p>public static void main(String[] args) {</p>
<p>OverridingPrivate2 op2 = new OverridingPrivate2();</p>
<p>op2.f();</p>
<p>op2.g();</p>
<p>// You can upcast:</p>
<p>OverridingPrivate op = op2;</p>
<p>// But you can’t call the methods:</p>
<p>//! op.f();</p>
<p>//! op.g();</p>
<p>// Same here:</p>
<p>WithFinals wf = op2;</p>
<p>//! wf.f();</p>
<p>//! wf.g();</p>
<p>}</p>
<p>} /* Output:</p>
<p>OverridingPrivate2.f()</p>
<p>OverridingPrivate2.g()</p>
<p>*///:~ “Overriding” can only occur if something is part of the base-class interface. That is, you must be able to upcast an object to its base type and call the same method (the point of this will become clear in the next chapter). If a method is private, it isn’t part of the base-class interface. It is just some code that’s hidden away inside the class, and it just happens to have that name, but if you create a public, protected, or package-access method with the same name in the derived class, there’s no connection to the method that might happen to have that name in the base class. You haven’t overridden the method; you’ve just created a new method. Since a private method is unreachable and effectively invisible, it doesn’t factor into anything except for the code organization of the class for which it was defined.</p>
<p>Exercise 20: (1) Show that @Override annotation solves the problem in this section.</p>
<p>Exercise 21: (1) Create a class with a final method. Inherit from that class and attempt to overwrite that method.</p>
<subtitle>final classes</subtitle>
<p>When you say that an entire class is final (by preceding its definition with the final keyword), you state that you don’t want to inherit from this class or allow anyone else to do so. In other words, for some reason the design of your class is such that there is never a need to make any changes, or for safety or security reasons you don’t want subclassing.</p>
<p>//: reusing/Jurassic.java // Making an entire class final.</p>
<p>class SmallBrain {}</p>
<p>final class Dinosaur { int i = 7; int j = 1;</p>
<p>SmallBrain x = new SmallBrain(); void f() {}</p>
<p>}</p>
<p>//! class Further extends Dinosaur {}</p>
<p>// error: Cannot extend final class ‘Dinosaur’</p>
<p>public class Jurassic {</p>
<p>public static void main(String[] args) {</p>
<p>Dinosaur n = new Dinosaur();</p>
<p>n.f();</p>
<p>n.i = 40;</p>
<p>n.j++;</p>
<p>}</p>
<p>} ///:~</p>
<p>Note that the fields of a final class can be final or not, as you choose. The same rules apply to final for fields regardless of whether the class is defined as final. However, because it prevents inheritance, all methods in a final class are implicitly final, since there’s no way to override them. You can add the final specifier to a method in a final class, but it doesn’t add any meaning.</p>
<p>Exercise 22: (1) Create a final class and attempt to inherit from it.</p>
<subtitle>final caution</subtitle>
<p>It can seem to be sensible to make a method final while you’re designing a class. You might feel that no one could possibly want to override your methods. Sometimes this is true.</p>
<p>But be careful with your assumptions. In general, it’s difficult to anticipate how a class can be reused, especially a general-purpose class. If you define a method as final, you might prevent the possibility of reusing your class through inheritance in some other programmer’s project simply because you couldn’t imagine it being used that way.</p>
<p>The standard Java library is a good example of this. In particular, the Java 1.0/1.1 Vector class was commonly used and might have been even more useful if, in the name of efficiency (which was almost certainly an illusion), all the methods hadn’t been made final. It’s easily conceivable that you might want to inherit and override with such a fundamentally useful class, but the designers somehow decided this wasn’t appropriate. This is ironic for two reasons. First, Stack is inherited from Vector, which says that a Stack is a Vector, which isn’t really true from a logical standpoint. Nonetheless, it’s a case where the Java designers themselves inherited Vector. At the point they created Stack this way, they should have realized that final methods were too restrictive.</p>
<p>Second, many of the most important methods of Vector, such as addElement( ) and elementAt( ), are synchronized. As you will see in the Concurrency chapter, this imposes a significant performance overhead that probably wipes out any gains provided by final. This lends credence to the theory that programmers are consistently bad at guessing where optimizations should occur. It’s just too bad that such a clumsy design made it into the standard library, where everyone had to cope with it. (Fortunately, the modern Java</p>
<p>container library replaces Vector with ArrayList, which behaves much more civilly. Unfortunately, there’s still new code being written that uses the old container library.)</p>
<p>It’s also interesting to note that Hashtable, another important Java 1.0/1.1 standard library class, does not have any final methods. As mentioned elsewhere in this book, it’s quite obvious that some classes were designed by completely different people than others. (You’ll see that the method names in Hashtable are much briefer compared to those in Vector, another piece of evidence.) This is precisely the sort of thing that should not be obvious to consumers of a class library. When things are inconsistent, it just makes more work for the user—yet another paean to the value of design and code walkthroughs. (Note that the modern Java container library replaces Hashtable with HashMap.)</p>
</section>
<section>
<title>
<p>Initialization and class loading</p></title><empty-line/>
<p>In more traditional languages, programs are loaded all at once as part of the startup process. This is followed by initialization, and then the program begins. The process of initialization in these languages must be carefully controlled so that the order of initialization of statics doesn’t cause trouble. C++, for example, has problems if one static expects another static to be valid before the second one has been initialized.</p>
<p>Java doesn’t have this problem because it takes a different approach to loading. This is one of the activities that become easier, because everything in Java is an object. Remember that the compiled code for each class exists in its own separate file. That file isn’t loaded until the code is needed. In general, you can say that “class code is loaded at the point of first use.”</p>
<p>This is usually when the first object of that class is constructed, but loading also occurs when a static field or static method is accessed.<a l:href="#bookmark29" type="note"><sup>30</sup></a><sup></sup></p>
<p>The point of first use is also where the static initialization takes place. All the static objects and the static code block will be initialized in textual order (that is, the order that you write them down in the class definition) at the point of loading. The statics, of course, are initialized only once.</p>
<subtitle>Initialization with inheritance</subtitle>
<p>It’s helpful to look at the whole initialization process, including inheritance, to get a full picture of what happens. Consider the following example:</p>
<p>//: reusing/Beetle.java</p>
<p>// The full process of initialization.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Insect {</p>
<p>private int i = 9; protected int j;</p>
<p>Insect() {</p>
<p>print(&quot;i = &quot; + i + &quot;, j = &quot; + j); j = 39;</p>
<p>}</p>
<p>private static int x1 =</p>
<p>printInit(&quot;static Insect.x1 initialized&quot;); static int printInit(String s) {</p>
<p>print(s); return 47;</p>
<p>public class Beetle extends Insect {</p>
<p>private int k = printInit(&quot;Beetle.k initialized&quot;); public Beetle() { print(&quot;k = &quot; + k); print(&quot;j = &quot; + j);</p>
<p>}</p>
<p>private static int x2 =</p>
<p>printInit(&quot;static Beetle.x2 initialized&quot;); public static void main(String[] args) { print(&quot;Beetle constructor&quot;);</p>
<p>Beetle b = new Beetle();</p>
<p>}</p>
<p>} /* Output:</p>
<p>static Insect.xl initialized static Beetle.x2 initialized Beetle constructor i = 9, j = 0 Beetle.k initialized k = 47 j = 39 *///:~</p>
<p>The first thing that happens when you run Java on Beetle is that you try to access Beetle.main( ) (a static method), so the loader goes out and finds the compiled code for the Beetle class (this happens to be in a file called Beetle.class). In the process of loading it, the loader notices that it has a base class (that’s what the extends keyword says), which it then loads. This will happen whether or not you’re going to make an object of that base class. (Try commenting out the object creation to prove it to yourself.)</p>
<p>If the base class has a base class, that second base class would then be loaded, and so on. Next, the static initialization in the root base class (in this case, Insect) is performed, and then the next derived class, and so on. This is important because the derived-class static initialization might depend on the base class member being initialized properly.</p>
<p>At this point, the necessary classes have all been loaded so the object can be created. First, all the primitives in this object are set to their default values and the object references are set to null—this happens in one fell swoop by setting the memory in the object to binary zero. Then the base-class constructor will be called. In this case the call is automatic, but you can also specify the base-class constructor call (as the first operation in the Beetle( ) constructor) by using super. The base class construction goes through the same process in the same order as the derived-class constructor. After the base-class constructor completes, the instance variables are initialized in textual order. Finally, the rest of the body of the constructor is executed.</p>
<p>Exercise 23: (2) Prove that class loading takes place only once. Prove that loading may be caused by either the creation of the first instance of that class or by the access of a static member.</p>
<p>Exercise 24: (2) In Beetle.java, inherit a specific type of beetle from class Beetle, following the same format as the existing classes. Trace and explain the output.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>Both inheritance and composition allow you to create a new type from existing types. Composition reuses existing types as part of the underlying implementation of the new type, and inheritance reuses the interface.</p>
<p>With Inheritance, the derived class has the base-class interface, so it can be upcast to the base, which is critical for polymorphism, as you’ll see in the next chapter.</p>
<p>Despite the strong emphasis on inheritance in object-oriented programming, when you start a design you should generally prefer composition (or possibly delegation) during the first cut and use inheritance only when it is clearly necessary. Composition tends to be more flexible. In addition, by using the added artifice of inheritance with your member type, you can change the exact type, and thus the behavior, of those member objects at run time. Therefore, you can change the behavior of the composed object at run time.</p>
<p>When designing a system, your goal is to find or create a set of classes in which each class has a specific use and is neither too big (encompassing so much functionality that it’s unwieldy to reuse) nor annoyingly small (you can’t use it by itself or without adding functionality). If your designs become too complex, it’s often helpful to add more objects by breaking down existing ones into smaller parts.</p>
<p>When you set out to design a system, it’s important to realize that program development is an incremental process, just like human learning. It relies on experimentation; you can do as much analysis as you want, but you still won’t know all the answers when you set out on a project. You’ll have much more success-and more immediate feedback-if you start out to “grow” your project as an organic, evolutionary creature, rather than constructing it all at once like a glass-box skyscraper. Inheritance and composition are two of the most fundamental tools in object-oriented programming that allow you to perform such experiments.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Polymorphism</p></title><empty-line/>
<p>”I have been asked, ‘Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?’ I am not able to rightly apprehend the kind of confusion of ideas that could provoke such a question.” Charles Babbage (1791-1871)</p>
<p>Polymorphism is the third essential feature of an object-oriented programming language, after data abstraction and inheritance.</p>
<p>It provides another dimension of separation of interface from implementation, to decouple what from how. Polymorphism allows improved code organization and readability as well as the creation of extensible programs that can be “grown” not only during the original creation of the project, but also when new features are desired.</p>
<p>Encapsulation creates new data types by combining characteristics and behaviors. Implementation hiding separates the interface from the implementation by making the details private. This sort of mechanical organization makes ready sense to someone with a procedural programming background. But polymorphism deals with decoupling in terms of types. In the last chapter, you saw how inheritance allows the treatment of an object as its own type or its base type. This ability is critical because it allows many types (derived from the same base type) to be treated as if they were one type, and a single piece of code to work on all those different types equally. The polymorphic method call allows one type to express its distinction from another, similar type, as long as they’re both derived from the same base type. This distinction is expressed through differences in behavior of the methods that you can call through the base class.</p>
<p>In this chapter, you’ll learn about polymorphism (also called dynamic binding or late binding or run-time binding) starting from the basics, with simple examples that strip away everything but the polymorphic behavior of the program.</p>
<section>
<title>
<p>Upcasting revisited</p></title><empty-line/>
<p>In the last chapter you saw how an object can be used as its own type or as an object of its base type. Taking an object reference and treating it as a reference to its base type is called upcasting because of the way inheritance trees are drawn with the base class at the top.</p>
<p>You also saw a problem arise, which is embodied in the following example about musical instruments.</p>
<p>First, since several examples play Notes, we should create a separate Note enumeration, in a package:</p>
<p>//: polymorphism/music/Note.java // Notes to play on musical instruments. package polymorphism.music;</p>
<p>public enum Note {</p>
<p>MIDDLE_C, C_SHARP, B_FLAT; // Etc.</p>
<p>} ///:~ enums were introduced in the Initialization &amp; Cleanup chapter.</p>
<p>Here, Wind is a type of Instrument; therefore, Wind is inherited from Instrument:</p>
<p>//: polymorphism/music/Instrument.java</p>
<p>package polymorphism.music;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Instrument {</p>
<p>public void play(Note n) { print(&quot;Instrument.play()&quot;);</p>
<p>}</p>
<p>}</p>
<p>///:~</p>
<p>//: polymorphism/music/Wind.java package polymorphism.music;</p>
<p>// Wind objects are instruments // because they have the same interface: public class Wind extends Instrument {</p>
<p>// Redefine interface method: public void play(Note n) {</p>
<p>System.out.println(&quot;Wind.play() &quot; + n);</p>
<p>}</p>
<p>} ///:~</p>
<p>//: polymorphism/music/Music.java // Inheritance &amp; upcasting. package polymorphism.music;</p>
<p>public class Music {</p>
<p>public static void tune(Instrument i) {</p>
<p>// ...</p>
<p>i.play(Note.MIDDLE_C);</p>
<p>}</p>
<p>public static void main(String[] args) { Wind flute = new Wind(); tune(flute); // Upcasting</p>
<p>}</p>
<p>} /* Output:</p>
<p>Wind.play() MIDDLE_C *///:~</p>
<p>The method Music.tune( ) accepts an Instrument reference, but also anything derived from Instrument. In main( ), you can see this happening as a Wind reference is passed to tune( ), with no cast necessary. This is acceptable—the interface in Instrument must exist in Wind, because Wind is inherited from Instrument. Upcasting from Wind to Instrument may “narrow” that interface, but it cannot make it anything less than the full interface to Instrument.</p>
<subtitle>Forgetting the object type</subtitle>
<p>Music.java might seem strange to you. Why should anyone intentionally forget the type of an object? This is what happens when you upcast, and it seems like it could be much more straightforward if tune( ) simply takes a Wind reference as its argument. This brings up an essential point: If you did that, you’d need to write a new tune( ) for every type of Instrument in your system. Suppose we follow this reasoning and add Stringed and Brass instruments:</p>
<p>//: polymorphism/music/Music2.java // Overloading instead of upcasting.</p>
<p>package polymorphism.music;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Stringed extends Instrument {</p>
<p>public void play(Note n) {</p>
<p>print(&quot;Stringed.play() &quot; + n);</p>
<p>}</p>
<p>}</p>
<p>class Brass extends Instrument {</p>
<p>public void play(Note n) { print(&quot;Brass.play() &quot; + n);</p>
<p>}</p>
<p>}</p>
<p>public class Music2 {</p>
<p>public static void tune(Wind i) { i.play(Note.MIDDLE_C);</p>
<p>}</p>
<p>public static void tune(Stringed i) { i.play(Note.MIDDLE_C);</p>
<p>}</p>
<p>public static void tune(Brass i) { i.play(Note.MIDDLE_C);</p>
<p>}</p>
<p>public static void main(String[] args) { Wind flute = new Wind();</p>
<p>Stringed violin = new Stringed();</p>
<p>Brass frenchHorn = new Brass(); tune(flute); // No upcasting tune(violin); tune(frenchHorn);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Wind.play() MIDDLE_C Stringed.play() MIDDLE_C Brass.play() MIDDLE_C *///:~</p>
<p>This works, but there’s a major drawback: you must write type-specific methods for each new Instrument class you add. This means more programming in the first place, but it also means that if you want to add a new method like tune( ) or a new type of Instrument, you’ve got a lot of work to do. Add the fact that the compiler won’t give you any error messages if you forget to overload one of your methods and the whole process of working with types becomes unmanageable.</p>
<p>Wouldn’t it be much nicer if you could just write a single method that takes the base class as its argument, and not any of the specific derived classes? That is, wouldn’t it be nice if you could forget that there are derived classes, and write your code to talk only to the base class?</p>
<p>That’s exactly what polymorphism allows you to do. However, most programmers who come from a procedural programming background have a bit of trouble with the way polymorphism works.</p>
<p>Exercise 1: (2) Create a Cycle class, with subclasses Unicycle, Bicycle and Tricycle. Demonstrate that an instance of each type can be upcast to Cycle via a ride( ) method.</p>
</section>
<section>
<title>
<p>The twist</p></title><empty-line/>
<p>The difficulty with Music java can be seen by running the program. The output is Wind.play( ). This is clearly the desired output, but it doesn’t seem to make sense that it would work that way. Look at the tune( ) method:</p>
<p>public static void tune(Instrument i) {</p>
<p>// ...</p>
<p>i.play(Note.MIDDLE_C);</p>
<p>}</p>
<p>It receives an Instrument reference. So how can the compiler possibly know that this Instrument reference points to a Wind in this case and not a Brass or Stringed? The compiler can’t. To get a deeper understanding of the issue, it’s helpful to examine the subject of binding.</p>
<subtitle>Method-call binding</subtitle>
<p>Connecting a method call to a method body is called binding. When binding is performed before the program is run (by the compiler and linker, if there is one), it’s called early binding. You might not have heard the term before because it has never been an option with procedural languages. C compilers have only one kind of method call, and that’s early binding.</p>
<p>The confusing part of the preceding program revolves around early binding, because the compiler cannot know the correct method to call when it has only an Instrument reference.</p>
<p>The solution is called late binding, which means that the binding occurs at run time, based on the type of object. Late binding is also called dynamic binding or runtime binding. When a language implements late binding, there must be some mechanism to determine the type of the object at run time and to call the appropriate method. That is, the compiler still doesn’t know the object type, but the method-call mechanism finds out and calls the correct method body. The late-binding mechanism varies from language to language, but you can imagine that some sort of type information must be installed in the objects.</p>
<p>All method binding in Java uses late binding unless the method is static or final (private methods are implicitly final). This means that ordinarily you don’t need to make any decisions about whether late binding will occur—it happens automatically.</p>
<p>Why would you declare a method final? As noted in the last chapter, it prevents anyone from overriding that method. Perhaps more important, it effectively “turns off’ dynamic binding, or rather it tells the compiler that dynamic binding isn’t necessary. This allows the compiler to generate slightly more efficient code for final method calls. However, in most cases it won’t make any overall performance difference in your program, so it’s best to only use final as a design decision, and not as an attempt to improve performance.</p>
<subtitle>Producing the right behavior</subtitle>
<p>Once you know that all method binding in Java happens polymorphically via late binding, you can write your code to talk to the base class and know that all the derived-class cases will work correctly using the same code. Or to put it another way, you “send a message to an object and let the object figure out the right thing to do.”</p>
<p>The classic example in OOP is the “shape” example. This is commonly used because it is easy to visualize, but unfortunately it can confuse novice programmers into thinking that OOP is just for graphics programming, which is of course not the case.</p>
<p>The shape example has a base class called Shape and various derived types: Circle, Square, Triangle, etc. The reason the example works so well is that it’s easy to say “a circle is a type of shape” and be understood. The inheritance diagram shows the relationships:</p><image l:href="#image15.jpg"/>
<p>The upcast could occur in a statement as simple as:</p>
<p>Shape s = new Circle();</p>
<p>Here, a Circle object is created, and the resulting reference is immediately assigned to a Shape, which would seem to be an error (assigning one type to another); and yet it’s fine because a Circle is a Shape by inheritance. So the compiler agrees with the statement and doesn’t issue an error message.</p>
<p>Suppose you call one of the base-class methods (that have been overridden in the derived classes):</p>
<p>s.draw();</p>
<p>Again, you might expect that Shape’s draw( ) is called because this is, after all, a Shape reference—so how could the compiler know to do anything else? And yet the proper Circle.draw( ) is called because of late binding (polymorphism).</p>
<p>The following example puts it a slightly different way. First, let’s create a reusable library of Shape types:</p>
<p>//: polymorphism/shape/Shape.java package polymorphism.shape;</p>
<p>public class Shape { public void draw() {} public void erase() {}</p>
<p>} ///:~</p>
<p>//: polymorphism/shape/Circle.java</p>
<p>package polymorphism.shape;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Circle extends Shape {</p>
<p>//: polymorphism/shape/Square.java</p>
<p>package polymorphism.shape;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Square extends Shape {</p>
<p>public void draw() { print(&quot;Square.draw()&quot;); } public void erase() { print(&quot;Square.erase()&quot;); }</p>
<p>} ///:~</p>
<p>//: polymorphism/shape/Triangle.java</p>
<p>package polymorphism.shape;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Triangle extends Shape {</p>
<p>public void draw() { print(&quot;Triangle.draw()&quot;); } public void erase() { print(&quot;Triangle.erase()&quot;); } } ///:~</p>
<p>//: polymorphism/shape/RandomShapeGenerator.java // A &quot;factory&quot; that randomly creates shapes. package polymorphism.shape; import java.util.*;</p>
<p>public class RandomShapeGenerator { private Random rand = new Random(47); public Shape next() {</p>
<p>switch(rand.nextInt(3)) { default:</p>
<p>case    0:    return    new    Circle();</p>
<p>case    1:    return    new    Square();</p>
<p>case    2:    return    new    Triangle();</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>//: polymorphism/Shapes.java // Polymorphism in Java. import polymorphism.shape.*;</p>
<p>public class Shapes {</p>
<p>private static RandomShapeGenerator gen = new RandomShapeGenerator(); public static void main(String[] args) {</p>
<p>Shape[] s = new Shape[9];</p>
<p>// Fill up the array with shapes: for(int i = 0; i &lt; s.length; i++) s[i] = gen.next();</p>
<p>// Make polymorphic method calls: for(Shape shp : s) shp.draw();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Triangle.draw()</p>
<p>Triangle.draw()</p>
<p>Square.draw()</p>
<p>Triangle.draw()</p>
<p>Square.draw()</p>
<p>Triangle.draw()</p>
<p>Square.draw()</p>
<p>Triangle.draw()</p>
<p>Circle.draw()</p>
<p>*///:~</p>
<p>The base class Shape establishes the common interface to anything inherited from Shape— that is, all shapes can be drawn and erased. The derived classes override these definitions to provide unique behavior for each specific type of shape.</p>
<p>RandomShapeGenerator is a kind of “factory” that produces a reference to a randomly-selected Shape object each time you call its next( ) method. Note that the upcasting happens in the return statements, each of which takes a reference to a Circle, Square, or Triangle and sends it out of next( ) as the return type, Shape. So whenever you call next( ), you never get a chance to see what specific type it is, since you always get back a plain Shape reference.</p>
<p>main( ) contains an array of Shape references filled through calls to RandomShapeGenerator.next( ). At this point you know you have Shapes, but you</p>
<p>don’t know anything more specific than that (and neither does the compiler). However, when you step through this array and call draw( ) for each one, the correct type-specific behavior magically occurs, as you can see from the output when you run the program.</p>
<p>The point of creating the shapes randomly is to drive home the understanding that the compiler can have no special knowledge that allows it to make the correct calls at compile time. All the calls to draw( ) must be made through dynamic binding.</p>
<p>Exercise 2: (1) Add the @Override annotation to the shapes example.</p>
<p>Exercise 3: (1) Add a new method in the base class of Shapes.java that prints a message, but don’t override it in the derived classes. Explain what happens. Now override it in one of the derived classes but not the others, and see what happens. Finally, override it in all the derived classes.</p>
<p>Exercise 4: (2) Add a new type of Shape to Shapes.java and verify in main( ) that polymorphism works for your new type as it does in the old types.</p>
<p>Exercise 5: (1) Starting from Exercise 1, add a wheels( ) method in Cycle, which returns the number of wheels. Modify ride( ) to call wheels( ) and verify that polymorphism works.</p>
<subtitle>Extensibility</subtitle>
<p>Now let’s return to the musical instrument example. Because of polymorphism, you can add as many new types as you want to the system without changing the tune( ) method. In a well-designed OOP program, most or all of your methods will follow the model of tune( ) and communicate only with the base-class interface. Such a program is extensible because you can add new functionality by inheriting new data types from the common base class. The methods that manipulate the base-class interface will not need to be changed at all to accommodate the new classes.</p>
<p>Consider what happens if you take the instrument example and add more methods in the base class and a number of new classes. Here’s the diagram:</p><image l:href="#image16.jpg"/>
<p>All these new classes work correctly with the old, unchanged tune( ) method. Even if tune( ) is in a separate file and new methods are added to the interface of Instrument, tune( ) will still work correctly, even without recompiling it. Here is the implementation of the diagram: //: polymorphism/music3/Music3.java</p>
<p>// An extensible program.</p>
<p>package polymorphism.music3;</p>
<p>import polymorphism.music.Note;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Instrument {</p>
<p>void play(Note n) { print(&quot;Instrument.play() &quot; + n); }</p>
<p>String what() { return &quot;Instrument&quot;; }</p>
<p>void adjust() { print(&quot;Adjusting Instrument&quot;); }</p>
<p>}</p>
<p>class Wind extends Instrument {</p>
<p>void play(Note n) { print(&quot;Wind.play() &quot; + n); }</p>
<p>String what() { return &quot;Wind&quot;; }</p>
<p>void adjust() { print(&quot;Adjusting Wind&quot;); }</p>
<p>}</p>
<p>class Percussion extends Instrument {</p>
<p>void play(Note n) { print(&quot;Percussion.play() &quot; + n); }</p>
<p>String what() { return &quot;Percussion&quot;; }</p>
<p>void adjust() { print(&quot;Adjusting Percussion&quot;); }</p>
<p>} class Stringed extends Instrument {</p>
<p>class Brass extends Wind {</p>
<p>void play(Note n) { print(&quot;Brass.play() &quot; + n); } void adjust() { print(&quot;Adjusting Brass&quot;); }</p>
<p>}</p>
<p>class Woodwind extends Wind {</p>
<p>void play(Note n) { print(&quot;Woodwind.play() &quot; + n); } String what() { return &quot;Woodwind&quot;; }</p>
<p>}</p>
<p>public class Music3 {</p>
<p>// Doesn’t care about type, so new types // added to the system still work right: public static void tune(Instrument i) {</p>
<p>// ...</p>
<p>i.play(Note.MIDDLE_C);</p>
<p>}</p>
<p>public static void tuneAll(Instrument[] e) { for(Instrument i : e) tune(i);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>// Upcasting during addition to the array: Instrument[] orchestra = { new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind()</p>
<p>};</p>
<p>tuneAll(orchestra);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Wind.play() MIDDLE_C Percussion.play() MIDDLE_C Stringed.play() MIDDLE_C Brass.play() MIDDLE_C Woodwind.play() MIDDLE_C *///:~</p>
<p>The new methods are what( ), which returns a String reference with a description of the class, and adjust( ), which provides some way to adjust each instrument.</p>
<p>In main( ), when you place something inside the orchestra array, you automatically upcast to Instrument.</p>
<p>You can see that the tune( ) method is blissfully ignorant of all the code changes that have happened around it, and yet it works correctly. This is exactly what polymorphism is supposed to provide. Changes in your code don’t cause damage to parts of the program that should not be affected. Put another way, polymorphism is an important technique for the programmer to “separate the things that change from the things that stay the same.”</p>
<p>Exercise 6: (1) Change Music3.java so that what( ) becomes the root Object method toString( ). Try printing the Instrument objects using System.out.println( ) (without any casting).</p>
<p>Exercise 7: (2) Add a new type of Instrument to Music3.java and verify that polymorphism works for your new type.</p>
<p>Exercise 8: (2) Modify Music3.java so that it randomly creates Instrument objects the way Shapes.java does.</p>
<p>Exercise 9: (3) Create an inheritance hierarchy of Rodent: Mouse, Gerbil, Hamster, etc. In the base class, provide methods that are common to all Rodents, and override these in the derived classes to perform different behaviors depending on the specific type of Rodent. Create an array of Rodent, fill it with different specific types of Rodents, and call your base-class methods to see what happens.</p>
<p>Exercise 10: (3) Create a base class with two methods. In the first method, call the second method. Inherit a class and override the second method. Create an object of the derived class, upcast it to the base type, and call the first method. Explain what happens.</p>
<subtitle>Pitfall: &quot;overriding&quot; private methods</subtitle>
<p>Here’s something you might innocently try to do:</p>
<p>//: polymorphism/PrivateOverride.java // Trying to override a private method. package polymorphism;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class PrivateOverride {</p>
<p>private void f() { print(&quot;private f()&quot;); } public static void main(String[] args) {</p>
<p>PrivateOverride po = new Derived(); po.f();</p>
<p>}</p>
<p>}</p>
<p>class Derived extends PrivateOverride { public void f() { print(&quot;public f()&quot;); }</p>
<p>} /* Output: private f()</p>
<p>*///:~</p>
<p>You might reasonably expect the output to be “public f( )”, but a private method is automatically final, and is also hidden from the derived class. So Derived’s f( ) in this case is a brand new method; it’s not even overloaded, since the base-class version of f( ) isn’t visible in Derived.</p>
<p>The result of this is that only non-private methods may be overridden, but you should watch out for the appearance of overriding private methods, which generates no compiler warnings, but doesn’t do what you might expect. To be clear, you should use a different name from a private base-class method in your derived class.</p>
<subtitle>Pitfall: fields and static methods</subtitle>
<p>Once you learn about polymorphism, you can begin to think that everything happens polymorphically. However, only ordinary method calls can be polymorphic. For example, if you access a field directly, that access will be resolved at compile time, as the following example demonstrates:<a l:href="#bookmark30" type="note"><sup>31</sup></a><sup></sup></p>
<p>//: polymorphism/FieldAccess.java</p>
<p>// Direct field access is determined at compile time.</p>
<p>class Super {</p>
<p>public int field = 0;</p>
<p>public int getField() { return field; }</p>
<p>}</p>
<p>class Sub extends Super { public int field = 1;</p>
<p>public int getField() { return field; }</p>
<p>public int getSuperField() { return super.field; }</p>
<p>}</p>
<p>public class FieldAccess {</p>
<p>public static void main(String[] args) {</p>
<p>Super sup = new Sub(); // Upcast System.out.println(&quot;sup.field = &quot; + sup.field +</p>
<p>&quot;, sup.getField() = &quot; + sup.getField());</p>
<p>Sub sub = new Sub();</p>
<p>System.out.println(&quot;sub.field = &quot; + sub.field + &quot;, sub.getField() = &quot; + sub.getField() +</p>
<p>&quot;, sub.getSuperField() = &quot; + sub.getSuperField());</p>
<p>}</p>
<p>} /* Output:</p>
<p>sup.field = 0, sup.getField() = 1</p>
<p>sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0 *///:~</p>
<p>When a Sub object is upcast to a Super reference, any field accesses are resolved by the compiler, and are thus not polymorphic. In this example, different storage is allocated for Super.field and Sub.field. Thus, Sub actually contains two fields called field: its own and the one that it gets from Super. However, the Super version is not the default that is produced when you refer to field in Sub; in order to get the Super field you must explicitly say super.field.</p>
<p>Although this seems like it could be a confusing issue, in practice it virtually never comes up. For one thing, you’ll generally make all fields private and so you won’t access them directly, but only as side effects of calling methods. In addition, you probably won’t give the same name to a base-class field and a derived-class field, because its confusing.</p>
<p>If a method is static, it doesn’t behave polymorphically:</p>
<p>//: polymorphism/StaticPolymorphism.java // Static methods are not polymorphic.</p>
<p>class StaticSuper {</p>
<p>public static String staticGet() {</p>
<p>}</p>
<p>return &quot;Base staticGet()&quot;;</p>
<p>public String dynamicGet() { return &quot;Base dynamicGet()&quot;;</p>
<p>}</p>
<p>}</p>
<p>class StaticSub extends StaticSuper {</p>
<p>public static String staticGet() { return &quot;Derived staticGet()&quot;;</p>
<p>}</p>
<p>public String dynamicGet() { return &quot;Derived dynamicGet()&quot;;</p>
<p>}</p>
<p>}</p>
<p>public class StaticPolymorphism {</p>
<p>public static void main(String[] args) {</p>
<p>StaticSuper sup = new StaticSub(); // Upcast</p>
<p>System.out.println(sup.staticGet());</p>
<p>System.out.println(sup.dynamicGet());</p>
<p>}</p>
<p>} /* Output:</p>
<p>Base staticGet()</p>
<p>Derived dynamicGet()</p>
<p>*///:~ static methods are associated with the class, and not the individual objects.</p>
</section>
<section>
<title>
<p>Constructors and polymorphism</p></title><empty-line/>
<p>As usual, constructors are different from other kinds of methods. This is also true when polymorphism is involved. Even though constructors are not polymorphic (they’re actually static methods, but the static declaration is implicit), it’s important to understand the way constructors work in complex hierarchies and with polymorphism. This understanding will help you avoid unpleasant entanglements.</p>
<subtitle>Order of constructor calls</subtitle>
<p>The order of constructor calls was briefly discussed in the Initialization &amp; Cleanup chapter and again in the Reusing Classes chapter, but that was before polymorphism was introduced.</p>
<p>A constructor for the base class is always called during the construction process for a derived class, chaining up the inheritance hierarchy so that a constructor for every base class is called. This makes sense because the constructor has a special job: to see that the object is built properly. A derived class has access to its own members only, and not to those of the base class (whose members are typically private). Only the base-class constructor has the proper knowledge and access to initialize its own elements. Therefore, it’s essential that all constructors get called; otherwise the entire object wouldn’t be constructed. That’s why the compiler enforces a constructor call for every portion of a derived class. It will silently call the default constructor if you don’t explicitly call a base-class constructor in the derived-class constructor body. If there is no default constructor, the compiler will complain. (In the case where a class has no constructors, the compiler will automatically synthesize a default constructor.)</p>
<p>Let’s take a look at an example that shows the effects of composition, inheritance, and polymorphism on the order of construction:</p>
<p>//: polymorphism/Sandwich.java // Order of constructor calls. package polymorphism;</p>
<p>import static net.mindview.util.Print.*; class Meal {</p>
<p>Meal() { print(&quot;Meal()&quot;); }</p>
<p>}</p>
<p>class Bread {</p>
<p>Bread() { print(&quot;Bread()&quot;); }</p>
<p>}</p>
<p>class Cheese {</p>
<p>Cheese() { print(&quot;Cheese()&quot;); }</p>
<p>}</p>
<p>class Lettuce {</p>
<p>Lettuce() { print(&quot;Lettuce()&quot;); }</p>
<p>}</p>
<p>class Lunch extends Meal {</p>
<p>Lunch() { print(&quot;Lunch()&quot;); }</p>
<p>}</p>
<p>class PortableLunch extends Lunch {</p>
<p>PortableLunch() { print(&quot;PortableLunch()&quot;);}</p>
<p>}</p>
<p>public class Sandwich extends PortableLunch { private Bread b = new Bread(); private Cheese c = new Cheese(); private Lettuce l = new Lettuce(); public Sandwich() { print(&quot;Sandwich()&quot;); } public static void main(String[] args) { new Sandwich();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Meal()</p>
<p>Lunch()</p>
<p>PortableLunch()</p>
<p>Bread()</p>
<p>Cheese()</p>
<p>Lettuce()</p>
<p>Sandwich()</p>
<p>*///:~</p>
<p>This example creates a complex class out of other classes, and each class has a constructor that announces itself. The important class is Sandwich, which reflects three levels of inheritance (four, if you count the implicit inheritance from Object) and three member objects. You can see the output when a Sandwich object is created in main( ). This means that the order of constructor calls for a complex object is as follows:</p>
<p>1.    The base-class constructor is called. This step is repeated recursively such that the root of the hierarchy is constructed first, followed by the next-derived class, etc., until the most-derived class is reached.</p>
<p>2.    Member initializers are called in the order of declaration.</p>
<p>3. The body of the derived-class constructor is called.</p>
<p>The order of the constructor calls is important. When you inherit, you know all about the base class and can access any public and protected members of the base class. This means that you must be able to assume that all the members of the base class are valid when you’re in the derived class. In a normal method, construction has already taken place, so all the members of all parts of the object have been built. Inside the constructor, however, you must be able to assume that all members that you use have been built. The only way to guarantee this is for the base-class constructor to be called first. Then when you’re in the derived-class constructor, all the members you can access in the base class have been initialized. Knowing that all members are valid inside the constructor is also the reason that, whenever possible, you should initialize all member objects (that is, objects placed in the class using composition) at their point of definition in the class (e.g., b, c, and l in the preceding example). If you follow this practice, you will help ensure that all base class members and member objects of the current object have been initialized. Unfortunately, this doesn’t handle every case, as you will see in the next section.</p>
<p>Exercise 11: (1) Add class Pickle to Sandwich.java.</p>
<subtitle>Inheritance and cleanup</subtitle>
<p>When using composition and inheritance to create a new class, most of the time you won’t have to worry about cleaning up; subobjects can usually be left to the garbage collector. If you do have cleanup issues, you must be diligent and create a dispose( ) method (the name I have chosen to use here; you may come up with something better) for your new class. And with inheritance, you must override dispose( ) in the derived class if you have any special cleanup that must happen as part of garbage collection. When you override dispose( ) in an inherited class, it’s important to remember to call the base-class version of dispose( ), since otherwise the base-class cleanup will not happen. The following example demonstrates this:</p>
<p>//: polymorphism/Frog.java // Cleanup and inheritance. package polymorphism;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Characteristic { private String s;</p>
<p>Characteristic(String s) { this.s = s;</p>
<p>print(&quot;Creating Characteristic &quot; + s);</p>
<p>}</p>
<p>protected void dispose() {</p>
<p>print(&quot;disposing Characteristic &quot; + s);</p>
<p>}</p>
<p>}</p>
<p>class Description { private String s;</p>
<p>Description(String s) { this.s = s;</p>
<p>print(&quot;Creating Description &quot; + s);</p>
<p>}</p>
<p>protected void dispose() {</p>
<p>print(&quot;disposing Description &quot; + s);</p>
<p>}</p>
<p>}</p>
<p>class LivingCreature {</p>
<p>private Characteristic p =</p>
<p>new Characteristic(&quot;is alive&quot;); private Description t =</p>
<p>new Description(&quot;Basic Living Creature&quot;); LivingCreature() {</p>
<p>print(&quot;LivingCreature()&quot;);</p>
<p>}</p>
<p>protected void dispose() {</p>
<p>print(&quot;LivingCreature dispose&quot;);</p>
<p>t.dispose();</p>
<p>p.dispose();</p>
<p>}</p>
<p>}</p>
<p>class Animal extends LivingCreature { private Characteristic p =</p>
<p>new Characteristic(&quot;has heart&quot;); private Description t =</p>
<p>new Description(&quot;Animal not Vegetable&quot;);</p>
<p>Animal() { print(&quot;Animal()&quot;); } protected void dispose() { print(&quot;Animal dispose&quot;); t.dispose(); p.dispose(); super.dispose();</p>
<p>}</p>
<p>}</p>
<p>class Amphibian extends Animal { private Characteristic p =</p>
<p>new Characteristic(&quot;can live in water&quot;); private Description t =</p>
<p>new Description(&quot;Both water and land&quot;);</p>
<p>Amphibian() {</p>
<p>print(&quot;Amphibian()&quot;);</p>
<p>}</p>
<p>protected void dispose() { print(&quot;Amphibian dispose&quot;); t.dispose(); p.dispose(); super.dispose();</p>
<p>}</p>
<p>}</p>
<p>public class Frog extends Amphibian {</p>
<p>private Characteristic p = new Characteristic(&quot;Croaks&quot;); private Description t = new Description(&quot;Eats Bugs&quot;); public Frog() { print(&quot;Frog()&quot;); } protected void dispose() { print(&quot;Frog dispose&quot;); t.dispose(); p.dispose(); super.dispose();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Frog frog = new Frog();</p>
<p>print(&quot;Bye!&quot;);</p>
<p>frog.dispose();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Creating Characteristic is alive</p>
<p>Creating Description Basic Living Creature</p>
<p>LivingCreature()</p>
<p>Creating Characteristic has heart Creating Description Animal not Vegetable Animal()</p>
<p>Creating Characteristic can live in water Creating Description Both water and land Amphibian()</p>
<p>Creating Characteristic Croaks Creating Description Eats Bugs Frog()</p>
<p>Bye!</p>
<p>Frog dispose</p>
<p>disposing Description Eats Bugs disposing Characteristic Croaks Amphibian dispose</p>
<p>disposing Description Both water and land disposing Characteristic can live in water Animal dispose</p>
<p>disposing Description Animal not Vegetable disposing Characteristic has heart LivingCreature dispose</p>
<p>disposing Description Basic Living Creature disposing Characteristic is alive *///:~</p>
<p>Each class in the hierarchy also contains a member objects of types Characteristic and Description, which must also be disposed. The order of disposal should be the reverse of the order of initialization, in case one subobject is dependent on another. For fields, this means the reverse of the order of declaration (since fields are initialized in declaration order). For base classes (following the form that’s used in C++ for destructors), you should perform the derived-class cleanup first, then the base-class cleanup. That’s because the derived-class cleanup could call some methods in the base class that require the base-class components to be alive, so you must not destroy them prematurely. From the output you can see that all parts of the Frog object are disposed in reverse order of creation.</p>
<p>From this example, you can see that although you don’t always need to perform cleanup, when you do, the process requires care and awareness.</p>
<p>Exercise 12: (3) Modify Exercise 9 so that it demonstrates the order of initialization of the base classes and derived classes. Now add member objects to both the base and derived classes and show the order in which their initialization occurs during construction.</p>
<p>Also note that in the above example, a Frog object “owns” its member objects. It creates them, and it knows how long they should live (as long as the Frog does), so it knows when to dispose( ) the member objects. However, if one of these member objects is shared with one or more other objects, the problem becomes more complex and you cannot simply assume that you can call dispose( ). In this case, reference counting may be necessary to keep track of the number of objects that are still accessing a shared object. Here’s what it looks like:</p>
<p>//: polymorphism/ReferenceCounting.java // Cleaning up shared member objects. import static net.mindview.util.Print.*;</p>
<p>class Shared {</p>
<p>private int refcount = 0; private static long counter = 0; private final long id = counter++; public Shared() {</p>
<p>print(&quot;Creating &quot; + this);</p>
<p>}</p>
<p>public void addRef() { refcount++; } protected void dispose() { if(--refcount == 0)</p>
<p>print(&quot;Disposing &quot; + this);</p>
<p>}</p>
<p>public String toString() { return &quot;Shared &quot; + id; }</p>
<p>}</p>
<p>class Composing {</p>
<p>private Shared shared; private static long counter = 0; private final long id = counter++; public Composing(Shared shared) { print(&quot;Creating &quot; + this); this.shared = shared; this.shared.addRef();</p>
<p>}</p>
<p>protected void dispose() { print(&quot;disposing &quot; + this); shared.dispose();</p>
<p>}</p>
<p>public String toString() { return &quot;Composing &quot; + id; }</p>
<p>}</p>
<p>public class ReferenceCounting {</p>
<p>public static void main(String[] args) {</p>
<p>Shared shared = new Shared();</p>
<p>Composing[] composing = { new Composing(shared), new Composing(shared), new Composing(shared), new Composing(shared), new Composing(shared) }; for(Composing c : composing) c.dispose();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Creating Shared 0 Creating Composing 0 Creating Composing 1 Creating Composing 2 Creating Composing 3 Creating Composing 4 disposing Composing 0 disposing Composing 1 disposing Composing 2 disposing Composing 3 disposing Composing 4 Disposing Shared 0 *///:~</p>
<p>The static long counter keeps track of the number of instances of Shared that are created, and it also provides a value for id. The type of counter is long rather than int, to prevent overflow (this is just good practice; overflowing such a counter is not likely to happen in any of the examples in this book). The id is final because we do not expect it to change its value during the lifetime of the object.</p>
<p>When you attach a shared object to your class, you must remember to call addRef( ), but the dispose( ) method will keep track of the reference count and decide when to actually perform the cleanup. This technique requires extra diligence to use, but if you are sharing objects that require cleanup you don’t have much choice.</p>
<p>Exercise 13: (3) Add a finalize( ) method to ReferenceCounting.java to verify the termination condition (see the Initialization &amp; Cleanup chapter).</p>
<p>Exercise 14: (4) Modify Exercise 12 so that one of the member objects is a shared object with reference counting, and demonstrate that it works properly.</p>
<subtitle>Behavior of polymorphic methods inside constructors</subtitle>
<p>The hierarchy of constructor calls brings up an interesting dilemma. What happens if you’re inside a constructor and you call a dynamically-bound method of the object being constructed?</p>
<p>Inside an ordinary method, the dynamically-bound call is resolved at run time, because the object cannot know whether it belongs to the class that the method is in or some class derived from it.</p>
<p>If you call a dynamically-bound method inside a constructor, the overridden definition for that method is used. However, the effect of this call can be rather unexpected because the overridden method will be called before the object is fully constructed. This can conceal some difficult-to-find bugs.</p>
<p>Conceptually, the constructor’s job is to bring the object into existence (which is hardly an ordinary feat). Inside any constructor, the entire object might be only partially formed—you can only know that the base-class objects have been initialized. If the constructor is only one step in building an object of a class that’s been derived from that constructor’s class, the derived parts have not yet been initialized at the time that the current constructor is being called. A dynamically bound method call, however, reaches “outward” into the inheritance hierarchy. It calls a method in a derived class. If you do this inside a constructor, you call a method that might manipulate members that haven’t been initialized yet—a sure recipe for disaster.</p>
<p>You can see the problem in the following example:</p>
<p>//: polymorphism/PolyConstructors.java // Constructors and polymorphism // don’t produce what you might expect. import static net.mindview.util.Print.*;</p>
<p>class Glyph {</p>
<p>void draw() { print(&quot;Glyph.draw()&quot;); }</p>
<p>Glyph() {</p>
<p>print(&quot;Glyph() before draw()&quot;); draw();</p>
<p>print(&quot;Glyph() after draw()&quot;);</p>
<p>}</p>
<p>}</p>
<p>class RoundGlyph extends Glyph { private int radius = 1;</p>
<p>RoundGlyph(int r) { radius = r;</p>
<p>print(&quot;RoundGlyph.RoundGlyph(), radius = &quot; + radius);</p>
<p>}</p>
<p>void draw() {</p>
<p>print(&quot;RoundGlyph.draw(), radius = &quot; + radius);</p>
<p>}</p>
<p>}</p>
<p>public class PolyConstructors {</p>
<p>public static void main(String[] args) {</p>
<p>new RoundG!yph(5);</p>
<p>} /* Output:</p>
<p>GlyphQ before draw() RoundGlyph.drawQ, radius = 0 GlyphQ after draw() RoundGlyph.RoundGlyph(), radius = 5 *///:~</p>
<p>Glyph. draw( ) is designed to be overridden, which happens in RoundGlyph. But the Glyph constructor calls this method, and the call ends up in RoundGlyph.draw( ), which would seem to be the intent. But if you look at the output, you can see that when Glyph’s constructor calls draw( ), the value of radius isn’t even the default initial value 1. It’s o.</p>
<p>This would probably result in either a dot or nothing at all being drawn on the screen, and you’d be left staring, trying to figure out why the program won’t work.</p>
<p>The order of initialization described in the earlier section isn’t quite complete, and that’s the key to solving the mystery. The actual process of initialization is:</p>
<p>1.    The storage allocated for the object is initialized to binary zero before anything else happens.</p>
<p>2.    The base-class constructors are called as described previously. At this point, the overridden draw( ) method is called (yes, before the RoundGlyph constructor is called), which discovers a radius value of zero, due to Step 1.</p>
<p>3.    Member initializers are called in the order of declaration.</p>
<p>4.    The body of the derived-class constructor is called.</p>
<p>There’s an upside to this, which is that everything is at least initialized to zero (or whatever zero means for that particular data type) and not just left as garbage. This includes object references that are embedded inside a class via composition, which become null. So if you forget to initialize that reference, you’ll get an exception at run time. Everything else gets zero, which is usually a telltale value when looking at output.</p>
<p>On the other hand, you should be pretty horrified at the outcome of this program. You’ve done a perfectly logical thing, and yet the behavior is mysteriously wrong, with no complaints from the compiler. (C++ produces more rational behavior in this situation.) Bugs like this could easily be buried and take a long time to discover.</p>
<p>As a result, a good guideline for constructors is, “Do as little as possible to set the object into a good state, and if you can possibly avoid it, don’t call any other methods in this class.” The only safe methods to call inside a constructor are those that are final in the base class. (This also applies to private methods, which are automatically final.) These cannot be overridden and thus cannot produce this kind of surprise. You may not always be able to follow this guideline, but it’s something to strive towards.</p>
<p>Exercise 15: (2) Add a RectangularGlyph to PolyConstructors.java and</p>
<p>demonstrate the problem described in this section.</p>
</section>
<section>
<title>
<p>Covariant return types</p></title><empty-line/>
<p>Java SE5 adds covariant return types, which means that an overridden method in a derived class can return a type derived from the type returned by the base-class method:</p>
<p>//: polymorphism/CovariantReturn.java</p>
<p>class Grain {</p>
<p>public String toString() { return &quot;Grain&quot;; }</p>
<p>}</p>
<p>class Wheat extends Grain {</p>
<p>public String toString() { return &quot;Wheat&quot;; }</p>
<p>}</p>
<p>class Mill {</p>
<p>Grain process() { return new Grain(); }</p>
<p>}</p>
<p>class WheatMill extends Mill {</p>
<p>Wheat process() { return new Wheat(); }</p>
<p>}</p>
<p>public class CovariantReturn {</p>
<p>public static void main(String[] args) {</p>
<p>Mill m = new Mill();</p>
<p>Grain g = m.process(); System.out.println(g); m = new WheatMill(); g = m.process();</p>
<p>System.out.println(g);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Grain</p>
<p>Wheat</p>
<p>*///:~</p>
<p>The key difference between Java SE5 and earlier versions of java is that the earlier versions would force the overridden version of process( ) to return Grain, rather than Wheat, even though Wheat is derived from Grain and thus is still a legitimate return type. Covariant return types allow the more specific Wheat return type.</p>
</section>
<section>
<title>
<p>Designing with inheritance</p></title><empty-line/>
<p>Once you learn about polymorphism, it can seem that everything ought to be inherited, because polymorphism is such a clever tool. This can burden your designs; in fact, if you choose inheritance first when you’re using an existing class to make a new class, things can become needlessly complicated.</p>
<p>A better approach is to choose composition first, especially when it’s not obvious which one you should use. Composition does not force a design into an inheritance hierarchy. But composition is also more flexible since it’s possible to dynamically choose a type (and thus behavior) when using composition, whereas inheritance requires an exact type to be known at compile time. The following example illustrates this:</p>
<p>//: polymorphism/Transmogrify.java // Dynamically changing the behavior of an object // via composition (the &quot;State&quot; design pattern). import static net.mindview.util.Print.*;</p>
<p>class Actor {</p>
<p>public void act() {}</p>
<p>}</p>
<p>class HappyActor extends Actor {</p>
<p>public void act() { print(&quot;HappyActor&quot;); }</p>
<p>class SadActor extends Actor {</p>
<p>public void act() { print(&quot;SadActor&quot;); }</p>
<p>}</p>
<p>class Stage {</p>
<p>private Actor actor = new HappyActor(); public void change() { actor = new SadActor(); } public void performPlay() { actor.act(); }</p>
<p>}</p>
<p>public class Transmogrify {</p>
<p>public static void main(String[] args) {</p>
<p>Stage stage = new Stage(); stage.performPlay(); stage.change(); stage.performPlay();</p>
<p>}</p>
<p>} /* Output:</p>
<p>HappyActor</p>
<p>SadActor</p>
<p>*///:~</p>
<p>A Stage object contains a reference to an Actor, which is initialized to a HappyActor object. This means performPlay( ) produces a particular behavior. But since a reference can be rebound to a different object at run time, a reference for a SadActor object can be substituted in actor, and then the behavior produced by performPlay( ) changes. Thus you gain dynamic flexibility at run time. (This is also called the State Pattern. See Thinking in Patterns (with Java) at <a l:href="http://www.MindView.com">www.MindView.com</a>.) In contrast, you can’t decide to inherit differently at run time; that must be completely determined at compile time.</p>
<p>A general guideline is “Use inheritance to express differences in behavior, and fields to express variations in state.” In the preceding example, both are used; two different classes are inherited to express the difference in the act( ) method, and Stage uses composition to allow its state to be changed. In this case, that change in state happens to produce a change in behavior.</p>
<p>Exercise 16: (3) Following the example in Transmogrify.java, create a Starship class containing an AlertStatus reference that can indicate three different states. Include methods to change the states.</p>
<subtitle>Substitution vs. extension</subtitle>
<p>It would seem that the cleanest way to create an inheritance hierarchy is to take the “pure” approach. That is, only methods that have been established in the base class are overridden in the derived class, as seen in this diagram:</p><image l:href="#image17.jpg"/>
<p>This can be called a pure “is-a” relationship because the interface of a class establishes what it is. Inheritance guarantees that any derived class will have the interface of the base class and nothing less. If you follow this diagram, derived classes will also have no more than the base-class interface.</p>
<p>This can be thought of as pure substitution, because derived class objects can be perfectly substituted for the base class, and you never need to know any extra information about the subclasses when you’re using them:</p><image l:href="#image18.jpg"/>
<p>That is, the base class can receive any message you can send to the derived class because the two have exactly the same interface. All you need to do is upcast from the derived class and never look back to see what exact type of object you’re dealing with. Everything is handled through polymorphism.</p>
<p>When you see it this way, it seems like a pure is-a relationship is the only sensible way to do things, and any other design indicates muddled thinking and is by definition broken. This too is a trap. As soon as you start thinking this way, you’ll turn around and discover that extending the interface (which, unfortunately, the keyword extends seems to encourage) is the perfect solution to a particular problem. This can be termed an “is-like-a” relationship, because the derived class is like the base class—it has the same fundamental interface—but it has other features that require additional methods to implement:</p>
<p>Assume this represents a big interface</p>
<p>Useful</p>
<p>void fQ void g()</p>
<table>
<tr><th colspan="2">7T&quot;</th></tr>
<tr><td colspan="2">M ore Useful</td></tr>
<tr><td>void</td><td>fO</td></tr>
<tr><td>void</td><td>g()</td></tr>
<tr><td>void</td><td>u()</td></tr>
<tr><td>void</td><td>VQ</td></tr>
<tr><td>void</td><td>w()</td></tr>
</table>
<p>&quot;Is֊like֊a&quot;</p>
<p>&gt;</p>
<p>Extending the interface</p>
<p>While this is also a useful and sensible approach (depending on the situation), it has a drawback. The extended part of the interface in the derived class is not available from the base class, so once you upcast, you can’t call the new methods:</p><image l:href="#image19.jpg"/>
<p>If you’re not upcasting in this case, it won’t bother you, but often you’ll get into a situation in which you need to rediscover the exact type of the object so you can access the extended methods of that type. The following section shows how this is done.</p>
<subtitle>Downcasting and runtime type information</subtitle>
<p>Since you lose the specific type information via an upcast (moving up the inheritance hierarchy), it makes sense that to retrieve the type information—that is, to move back down the inheritance hierarchy—you use a downcast. However, you know an upcast is always safe because the base class cannot have a bigger interface than the derived class. Therefore, every message you send through the base class interface is guaranteed to be accepted. But with a downcast, you don’t really know that a shape (for example) is actually a circle. It could instead be a triangle or square or some other type.</p>
<p>To solve this problem, there must be some way to guarantee that a downcast is correct, so that you won’t accidentally cast to the wrong type and then send a message that the object can’t accept. This would be quite unsafe.</p>
<p>In some languages (like C++) you must perform a special operation in order to get a type-safe downcast, but in Java, every cast is checked! So even though it looks like you’re just performing an ordinary parenthesized cast, at run time this cast is checked to ensure that it is in fact the type you think it is. If it isn’t, you get a ClassCastException. This act of checking types at run time is called runtime type identification (RTTI). The following example demonstrates the behavior of RTTI:</p>
<table>
<tr><th colspan="3">//: polymorphism/RTTI.java</th></tr>
<tr><td>// Downcasting &amp;</td><td>Runtime</td><td>type information (RTTI)</td></tr>
<tr><td>// {ThrowsExcepti</td><td>on}</td><td></td></tr>
<tr><td>class Useful {</td><td></td><td></td></tr>
<tr><td>public void f()</td><td>{}</td><td></td></tr>
<tr><td>public void g()}</td><td>{}</td><td></td></tr>
<tr><td>class MoreUseful</td><td>extends</td><td>Useful {</td></tr>
<tr><td>public void f()</td><td>{}</td><td></td></tr>
<tr><td>public void g()</td><td>{}</td><td></td></tr>
<tr><td>public void u()</td><td>{}</td><td></td></tr>
<tr><td>public void v()</td><td>{}</td><td></td></tr>
<tr><td>public void w()}</td><td>{}</td><td></td></tr>
<tr><td>public class RTTI</td><td>{</td><td></td></tr>
<tr><td colspan="3">public static void main(String[] args) {</td></tr>
<tr><td>Useful[] x =</td><td>{</td><td></td></tr>
<tr><td colspan="2">new Useful(),</td><td></td></tr>
<tr><td colspan="3">new MoreUseful()</td></tr>
</table>
<p>};</p>
<p>x[0].f();</p>
<p>x[1].g();</p>
<p>// Compile time: method not found in Useful:</p>
<p>//! x[1].u();</p>
<p>((MoreUseful)x[1]).u(); // Downcast/RTTI ((MoreUseful)x[0]).u(); // Exception thrown</p>
<p>}</p>
<p>} ///:~</p>
<p>As in the previous diagram, MoreUseful extends the interface of Useful. But since it’s inherited, it can also be upcast to a Useful. You can see this happening in the initialization of the array x in main( ). Since both objects in the array are of class Useful, you can send the f( ) and g( ) methods to both, and if you try to call u( ) (which exists only in MoreUseful), you’ll get a compile-time error message.</p>
<p>If you want to access the extended interface of a MoreUseful object, you can try to downcast. If it’s the correct type, it will be successful. Otherwise, you’ll get a ClassCastException. You don’t need to write any special code for this exception, since it indicates a programmer error that could happen anywhere in a program. The {ThrowsException} comment tag tells this book’s build system to expect this program to throw an exception when it executes.</p>
<p>There’s more to RTTI than a simple cast. For example, there’s a way to see what type you’re dealing with before you try to downcast it. All of the Type Information chapter is devoted to the study of different aspects of Java run-time type identification.</p>
<p>Exercise 17: (2) Using the Cycle hierarchy from Exercise 1, add a balance( ) method to Unicycle and Bicycle, but not to Tricycle. Create instances of all three types and upcast them to an array of Cycle. Try to call balance( ) on each element of the array and observe the results. Downcast and call balance( ) and observe what happens.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>Polymorphism means “different forms.” In object-oriented programming, you have the same interface from the base class, and different forms using that interface: the different versions of the dynamically bound methods.</p>
<p>You’ve seen in this chapter that it’s impossible to understand, or even create, an example of polymorphism without using data abstraction and inheritance. Polymorphism is a feature that cannot be viewed in isolation (like a switch statement can, for example), but instead works only in concert, as part of the larger picture of class relationships.</p>
<p>To use polymorphism—and thus object-oriented techniques—effectively in your programs, you must expand your view of programming to include not just members and messages of an individual class, but also the commonality among classes and their relationships with each other. Although this requires significant effort, it’s a worthy struggle. The results are faster program development, better code organization, extensible programs, and easier code maintenance.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Interfaces</p></title><empty-line/>
<p>Interfaces and abstract classes provide more structured way to separate interface from implementation.</p>
<p>Such mechanisms are not that common in programming languages. C++, for example, only has indirect support for these concepts. The fact that language keywords exist in Java indicates that these ideas were considered important enough to provide direct support.</p>
<p>First, we’ll look at the abstract class, which is a kind of midway step between an ordinary class and an interface. Although your first impulse will be to create an interface, the abstract class is an important and necessary tool for building classes that have some unimplemented methods. You can’t always use a pure interface.</p>
<section>
<title>
<p>Abstract classes and methods</p></title><empty-line/>
<p>In all the “instrument” examples in the previous chapter, the methods in the base class Instrument were always “dummy” methods. If these methods are ever called, you’ve done something wrong. That’s because the intent of Instrument is to create a common interface for all the classes derived from it.</p>
<p>In those examples, the only reason to establish this common interface is so that it can be expressed differently for each different subtype. It establishes a basic form, so that you can say what’s common for all the derived classes. Another way of saying this is to call Instrument an abstract base class, or simply an abstract class.</p>
<p>If you have an abstract class like Instrument, objects of that specific class almost always have no meaning. You create an abstract class when you want to manipulate a set of classes through its common interface. Thus, Instrument is meant to express only the interface, and not a particular implementation, so creating an Instrument object makes no sense, and you’ll probably want to prevent the user from doing it. This can be accomplished by making all methods in Instrument generate errors, but that delays the information until run time and requires reliable exhaustive testing on the user’s part. It’s usually better to catch problems at compile time.</p>
<p>Java provides a mechanism for doing this called the abstract method.<a l:href="#bookmark31" type="note"><sup>32</sup></a><sup></sup> This is a method that is incomplete; it has only a declaration and no method body. Here is the syntax for an abstract method declaration.</p>
<p>abstract void f( );</p>
<p>A class containing abstract methods is called an abstract class. If a class contains one or more abstract methods, the class itself must be qualified as abstract. (Otherwise, the compiler gives you an error message.)</p>
<p>If an abstract class is incomplete, what is the compiler supposed to do when someone tries to make an object of that class? It cannot safely create an object of an abstract class, so you get an error message from the compiler. This way, the compiler ensures the purity of the abstract class, and you don’t need to worry about misusing it.</p>
<p>If you inherit from an abstract class and you want to make objects of the new type, you must provide method definitions for all the abstract methods in the base class. If you don’t (and you may choose not to), then the derived class is also abstract, and the compiler will force you to qualify that class with the abstract keyword.</p>
<p>It’s possible to make a class abstract without including any abstract methods. This is useful when you’ve got a class in which it doesn’t make sense to have any abstract methods, and yet you want to prevent any instances of that class.</p>
<p>The Instrument class from the previous chapter can easily be turned into an abstract class. Only some of the methods will be abstract, since making a class abstract doesn’t force you to make all the methods abstract. Here’s what it looks like:</p><image l:href="#image20.jpg"/>
<p>Here’s the orchestra example modified to use abstract classes and methods:</p>
<p>//: interfaces/music4/Music4.java // Abstract classes and methods. package interfaces.music4; import polymorphism.music.Note; import static net.mindview.util.Print.*;</p>
<p>abstract class Instrument {</p>
<p>private int i; // Storage allocated for each</p>
<p>public abstract void play(Note n);</p>
<p>public    String what()    { return    &quot;Instrument&quot;; }</p>
<p>public    abstract void    adjust();</p>
<p>class Wind extends Instrument { public void play(Note n) { print(&quot;Wind.play() &quot; + n);</p>
<p>}</p>
<p>public    String what()    { return    &quot;Wind&quot;;    }</p>
<p>public    void adjust()    {}</p>
<p>}</p>
<p>class Percussion extends Instrument { public void play(Note n) {</p>
<p>print(&quot;Percussion.play() &quot; + n);</p>
<p>}</p>
<p>public    String what()    { return    &quot;Percussion&quot;;    }</p>
<p>public    void adjust()    {}</p>
<p>}</p>
<p>class Stringed extends Instrument { public void play(Note n) {</p>
<p>print(&quot;Stringed.play() &quot; + n);</p>
<p>}</p>
<p>public    String what()    { return    &quot;Stringed&quot;;    }</p>
<p>public    void adjust()    {}</p>
<p>}</p>
<p>class Brass extends Wind { public void play(Note n) { print(&quot;Brass.play() &quot; + n);</p>
<p>}</p>
<p>public void adjust() { print(&quot;Brass.adjust()&quot;); }</p>
<p>}</p>
<p>class Woodwind extends Wind { public void play(Note n) {</p>
<p>print(&quot;Woodwind.play() &quot; + n);</p>
<p>}</p>
<p>public String what() { return &quot;Woodwind&quot;; }</p>
<p>}</p>
<p>public class Music4 {</p>
<p>// Doesn’t care about type, so new types // added to the system still work right: static void tune(Instrument i) {</p>
<p>// ...</p>
<p>i.play(Note.MIDDLE_C);</p>
<p>}</p>
<p>static void tuneAll(Instrument[] e) { for(Instrument i : e) tune(i);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>// Upcasting during addition to the array: Instrument[] orchestra = { new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind()</p>
<p>};</p>
<p>}</p>
<p>} /* Output:</p>
<p>Wind.play() MIDDLE_C Percussion.play() MIDDLE_C Stringed.play() MIDDLE_C Brass.play() MIDDLE_C Woodwind.play() MIDDLE_C *///:~</p>
<p>You can see that there’s really no change except in the base class.</p>
<p>It’s helpful to create abstract classes and methods because they make the abstractness of a class explicit, and tell both the user and the compiler how it was intended to be used. Abstract classes are also useful refactoring tolls, since they allow you to easily move common methods up the inheritance hierarchy.</p>
<p>Exercise 1: (1) Modify Exercise 9 in the previous chapter so that Rodent is an abstract class. Make the methods of Rodent abstract whenever possible.</p>
<p>Exercise 2: (1) Create a class as abstract without including any abstract methods and verify that you cannot create any instances of that class.</p>
<p>Exercise 3: (2) Create a base class with an abstract print( ) method that is overridden in a derived class. The overridden version of the method prints the value of an int variable defined in the derived class. At the point of definition of this variable, give it a nonzero value. In the base-class constructor, call this method. In main( ), create an object of the derived type, and then call its print( ) method. Explain the results.</p>
<p>Exercise 4: (3) Create an abstract class with no methods. Derive a class and add a method. Create a static method that takes a reference to the base class, downcasts it to the derived class, and calls the method. In main( ), demonstrate that it works. Now put the abstract declaration for the method in the base class, thus eliminating the need for the downcast.</p>
</section>
<section>
<title>
<p>Interfaces</p></title><empty-line/>
<p>The interface keyword takes the concept of abstractness one step further. The abstract keyword allows you to create one or more undefined methods in a class—you provide part of the interface without providing a corresponding implementation. The implementation is provided by inheritors. The interface keyword produces a completely abstract class, one that provides no implementation at all. It allows the creator to determine method names, argument lists, and return types, but no method bodies. An interface provides only a form, but no implementation.</p>
<p>An interface says, &quot;All classes that implement this particular interface will look like this.&quot; Thus, any code that uses a particular interface knows what methods might be called for that interface, and that’s all. So the interface is used to establish a &quot;protocol&quot; between classes. (Some object-oriented programming languages have a keyword called protocol to do the same thing.)</p>
<p>However, an interface is more than just an abstract class taken to the extreme, since it allows you to perform a variation of &quot;multiple inheritance&quot; by creating a class that can be upcast to more than one base type.</p>
<p>To create an interface, use the interface keyword instead of the class keyword. As with a class, you can add the public keyword before the interface keyword (but only if that interface is defined in a file of the same name). If you leave off the public keyword, you get package access, so the interface is only usable within the same package. An interface can also contain fields, but these are implicitly static and final.</p>
<p>To make a class that conforms to a particular interface (or group of interfaces), use the implements keyword, which says, &quot;The interface is what it looks like, but now I’m going to say how it works.&quot; Other than that, it looks like inheritance. The diagram for the instrument example shows this:</p><image l:href="#image21.jpg"/>
<p>You can see from the Woodwind and Brass classes that once you’ve implemented an interface, that implementation becomes an ordinary class that can be extended in the regular way.</p>
<p>You can choose to explicitly declare the methods in an interface as public, but they are public even if you don’t say it. So when you implement an interface, the methods from the interface must be defined as public. Otherwise, they would default to package access, and you’d be reducing the accessibility of a method during inheritance, which is not allowed by the Java compiler.</p>
<p>You can see this in the modified version of the Instrument example. Note that every method in the interface is strictly a declaration, which is the only thing the compiler allows. In addition, none of the methods in Instrument are declared as public, but they’re automatically public anyway: //: interfaces/music5/Music5.java</p>
<p>// Interfaces.</p>
<p>package interfaces.music5;</p>
<p>import polymorphism.music.Note;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>interface Instrument {</p>
<p>// Compile-time constant:</p>
<p>int VALUE = 5; // static &amp; final</p>
<p>// Cannot have method definitions:</p>
<p>void play(Note n); // Automatically public</p>
<p>void adjust();</p>
<p>}</p>
<p>class Wind implements Instrument { public void play(Note n) { print(this + &quot;.play() &quot; + n);</p>
<p>}</p>
<p>public String toString() { return &quot;Wind&quot;; } public void adjust() { print(this + &quot;.adjust()&quot;); }</p>
<p>}</p>
<p>class Percussion implements Instrument { public void play(Note n) { print(this + &quot;.play() &quot; + n);</p>
<p>}</p>
<p>public String toString() { return &quot;Percussion&quot;; } public void adjust() { print(this + &quot;.adjust()&quot;); }</p>
<p>}</p>
<p>class Stringed implements Instrument { public void play(Note n) { print(this + &quot;.play() &quot; + n);</p>
<p>}</p>
<p>public String toString() { return &quot;Stringed&quot;; } public void adjust() { print(this + &quot;.adjust()&quot;); }</p>
<p>}</p>
<p>class Brass extends Wind {</p>
<p>public String toString() { return &quot;Brass&quot;; }</p>
<p>} class Woodwind extends Wind {</p>
<p>public String toString() { return &quot;Woodwind&quot;; }</p>
<p>} public class Music5 {</p>
<p>// Doesn’t care about type, so new types // added to the system still work right: static void tune(Instrument i) {</p>
<p>// ...</p>
<p>i.play(Note.MIDDLE_C);</p>
<p>}</p>
<p>static void tuneAll(Instrument[] e) { for(Instrument i : e) tune(i);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>// Upcasting during addition to the array: Instrument[] orchestra = { new Wind(), new Percussion(), new Stringed(),</p>
<p>new Brass(), new Woodwind()</p>
<p>};</p>
<p>tuneAH(orchestra);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Wind.play() MIDDLE_C Percussion.play() MIDDLE_C Stringed.play() MIDDLE_C Brass.play() MIDDLE_C Woodwind.play() MIDDLE_C *///:~</p>
<p>One other change has been made to this version of the example: The what( ) method has been changed to toString( ), since that was how the method was being used. Since toString( ) is part of the root class Object, it doesn’t need to appear in the interface.</p>
<p>The rest of the code works the same. Notice that it doesn’t matter if you are upcasting to a &quot;regular&quot; class called Instrument, an abstract class called Instrument, or to an interface called Instrument. The behavior is the same. In fact, you can see in the tune( ) method that there isn’t any evidence about whether Instrument is a &quot;regular&quot; class, an abstract class, or an interface.</p>
<p>Exercise 5: (2) Create an interface containing three methods, in its own package. Implement the interface in a different package.</p>
<p>Exercise 6: (2) Prove that all the methods in an interface are automatically public.</p>
<p>Exercise 7: (1) Change Exercise 9 in the Polymorphism chapter so that Rodent is an interface.</p>
<p>Exercise 8: (2) In polymorphism.Sandwich.java, create an interface called FastFoo d (with appropriate methods) and change Sandwic h so that it also implements FastFood.</p>
<p>Exercise 9: (3) Refactor Musics.java by moving the common methods in Wind, Percussion and Stringed into an abstract class.</p>
<p>Exercise 10: (3) Modify Musics.java by adding a Playable interface. Move the play( ) declaration from Instrument to Playable. Add Playable to the derived classes by including it in the implement s list. Change tune( ) so that it takes a Playable instead of an Instrument.</p>
</section>
<section>
<title>
<p>Complete decoupling</p></title><empty-line/>
<p>Whenever a method works with a class instead of an interface, you are limited to using that class or its subclasses. If you would like to apply the method to a class that isn’t in that hierarchy, you’re out of luck. An interface relaxes this constraint considerably. As a result, it allows you to write more reusable code.</p>
<p>For example, suppose you have a Processor class that has a name( ) and a process( ) method that takes input, modifies it and produces output. The base class is extended to create different types of Processor. In this case, the Processor subtypes modify String objects (note that the return types can be covariant, but not the argument types):</p>
<p>//: interfaces/classprocessor/Apply.java</p>
<p>package interfaces.classprocessor; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Processor {</p>
<p>public String name() {</p>
<p>return getClass().getSimpleName();</p>
<p>}</p>
<p>Object process(Object input) { return input; }</p>
<p>}</p>
<p>class Upcase extends Processor {</p>
<p>String process(Object input) { // Covariant return return ((String)input).toUpperCase();</p>
<p>}</p>
<p>}</p>
<p>class Downcase extends Processor {</p>
<p>String process(Object input) {</p>
<p>return ((String)input).toLowerCase();</p>
<p>}</p>
<p>}</p>
<p>class Splitter extends Processor {</p>
<p>String process(Object input) {</p>
<p>// The split() argument divides a String into pieces: return Arrays.toString(((String)input).split(&quot; &quot;));</p>
<p>}</p>
<p>}</p>
<p>public class Apply {</p>
<p>public static void process(Processor p, Object s) { print(&quot;Using Processor &quot; + p.name()); print(p.process(s));</p>
<p>}</p>
<p>public static String s =</p>
<p>&quot;Disagreement with beliefs is by definition incorrect&quot;;</p>
<p>public static void main(String[] args) { process(new Upcase(), s); process(new Downcase(), s); process(new Splitter(), s);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Using Processor Upcase</p>
<p>DISAGREEMENT WITH BELIEFS IS BY DEFINITION INCORRECT Using Processor Downcase</p>
<p>disagreement with beliefs is by definition incorrect Using Processor Splitter</p>
<p>[Disagreement, with, beliefs, is, by, definition, incorrect] *///:~</p>
<p>The Apply.process( ) method takes any kind of Processor and applies it to an Object, then prints the results. Creating a method that behaves differently depending on the argument object that you pass it is called the Strategy design pattern. The method contains the fixed part of the algorithm to be performed, and the Strategy contains the part that varies. The Strategy is the object that you pass in, and it contains code to be executed. Here, the Processor object is the Strategy, and in main( ) you can see three different Strategies applied to the String s.</p>
<p>The split( ) method is part of the String class. It takes the String object and splits it using the argument as a boundary, and returns a String[]. It is used here as a shorter way of creating an array of String.</p>
<p>Now suppose you discover a set of electronic filters that seem like they could fit into your Apply.process( ) method:</p>
<p>//: interfaces/filters/Waveform.java package interfaces.filters;</p>
<p>public class Waveform {</p>
<p>private static long counter; private final long id = counter++;</p>
<p>public String toString() { return &quot;Waveform &quot; + id; }</p>
<p>} ///:~</p>
<p>//: interfaces/filters/Filter.java package interfaces.filters;</p>
<p>public class Filter { public String name() {</p>
<p>return getClass().getSimpleName();</p>
<p>}</p>
<p>public Waveform process(Waveform input) { return input; }</p>
<p>} ///:~</p>
<p>//: interfaces/filters/LowPass.java package interfaces.filters;</p>
<p>public class LowPass extends Filter { double cutoff;</p>
<p>public LowPass(double cutoff) { this.cutoff = cutoff; } public Waveform process(Waveform input) { return input; // Dummy processing</p>
<p>}</p>
<p>} ///:~</p>
<p>//: interfaces/filters/HighPass.java package interfaces.filters;</p>
<p>public class HighPass extends Filter { double cutoff;</p>
<p>public HighPass(double cutoff) { this.cutoff = cutoff; } public Waveform process(Waveform input) { return input; }</p>
<p>} ///:~</p>
<p>//: interfaces/filters/BandPass.java package interfaces.filters;</p>
<p>public class BandPass extends Filter { double lowCutoff, highCutoff;</p>
<p>public BandPass(double lowCut, double highCut) { lowCutoff = lowCut; highCutoff = highCut;</p>
<p>}</p>
<p>public Waveform process(Waveform input) { return input; }</p>
<p>} ///:~</p>
<p>Filter has the same interface elements as Processor, but because it isn’t inherited from Processor—because the creator of the Filter class had no clue you might want to use it as a Processor—you can’t use a Filter with the Apply.process( ) method, even though it would work fine. Basically, the coupling between Apply.process( ) and Processor is stronger than it needs to be, and this prevents the Apply.process( ) code from being reused when it ought to be. Also notice that the inputs and outputs are both Waveforms.</p>
<p>If Processor is an interface, however, the constraints are loosened enough that you can reuse an Apply.process( ) that takes that interface. Here are the modified versions of Processor and Apply: //: interfaces/interfaceprocessor/Processor.java package interfaces.interfaceprocessor;</p>
<p>public interface Processor {</p>
<p>String name();</p>
<p>Object process(Object input);</p>
<p>} ///:~</p>
<p>//: interfaces/interfaceprocessor/Apply.java package interfaces.interfaceprocessor; import static net.mindview.util.Print.*;</p>
<p>public class Apply {</p>
<p>public static void process(Processor p, Object s) { print(&quot;Using Processor &quot; + p.name()); print(p.process(s));</p>
<p>}</p>
<p>} ///:~</p>
<p>The first way you can reuse code is if client programmers can write their classes to conform to the interface, like this:</p>
<p>//: interfaces/interfaceprocessor/StringProcessor.java package interfaces.interfaceprocessor; import java.util.*;</p>
<p>public abstract class StringProcessor implements Processor{ public String name() {</p>
<p>return getClass().getSimpleName();</p>
<p>}</p>
<p>public abstract String process(Object input); public static String s =</p>
<p>&quot;If she weighs the same as a duck, she’s made of wood&quot;; public static void main(String[] args) {</p>
<p>Apply.process(new Upcase(), s);</p>
<p>Apply.process(new Downcase(), s);</p>
<p>Apply.process(new Splitter(), s);</p>
<p>}</p>
<p>}</p>
<p>class Upcase extends StringProcessor {</p>
<p>public String process(Object input) { // Covariant return return ((String)input).toUpperCase();</p>
<p>}</p>
<p>}</p>
<p>class Downcase extends StringProcessor { public String process(Object input) { return ((String)input).toLowerCase();</p>
<p>}</p>
<p>}</p>
<p>class Splitter extends StringProcessor { public String process(Object input) {</p>
<p>return Arrays.toString(((String)input).split(&quot; &quot;));</p>
<p>}</p>
<p>} /* Output:</p>
<p>Using Processor Upcase</p>
<p>IF SHE WEIGHS THE SAME AS A DUCK, SHE&apos;S MADE OF WOOD Using Processor Downcase</p>
<p>if she weighs the same as a duck, she&apos;s made of wood Using Processor Splitter</p>
<p>[If, she, weighs, the, same, as, a, duck,, she&apos;s, made, of, wood] *///:~</p>
<p>However, you are often in the situation of not being able to modify the classes that you want to use. In the case of the electronic filters, for example, the library was discovered rather than created. In these cases, you can use the Adapter design pattern. In Adapter, you write code to take the interface that you have and produce the interface that you need, like this:</p>
<p>//: interfaces/interfaceprocessor/FilterProcessor.java package interfaces.interfaceprocessor; import interfaces.filters.*;</p>
<p>class FilterAdapter implements Processor {</p>
<p>Filter filter;</p>
<p>public Fi!terAdapter(Fi!ter filter) { this.filter = filter;</p>
<p>}</p>
<p>public String name() { return fi!ter.name(); } public Waveform process(Object input) { return fi!ter.process((Waveform)input);</p>
<p>}</p>
<p>}</p>
<p>public class FilterProcessor {</p>
<p>public static void main(String[] args) {</p>
<p>Waveform w = new Waveform();</p>
<p>App!y.process(new Fi!terAdapter(new LowPass(1.0)), w); App!y.process(new Fi!terAdapter(new HighPass(2.0)), w); App!y.process(</p>
<p>new Fi!terAdapter(new BandPass(3.0, 4.0)), w);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Using Processor LowPass Waveform 0</p>
<p>Using Processor HighPass Waveform 0</p>
<p>Using Processor BandPass Waveform 0 *///:~</p>
<p>In this approach to Adapter, the FilterAdapter constructor takes the interface that you have—Filter—and produces an object that has the Processor interface that you need. You may also notice delegation in the FilterAdapter class.</p>
<p>Decoupling interface from implementation allows an interface to be applied to multiple different implementations, and thus your code is more reusable.</p>
<p>Exercise 11: (4) Create a class with a method that takes a String argument and produces a result that swaps each pair of characters in that argument. Adapt the class so that it works with interfaceprocessor.Apply.process( ).</p>
</section>
<section>
<title>
<p>&quot;Multiple inheritance&quot; in Java</p></title><empty-line/>
<p>Because an interface has no implementation at all—that is, there is no storage associated with an interface—there’s nothing to prevent many interfaces from being combined. This is valuable because there are times when you need to say, &quot;An x is an a and a b and a c.&quot; In C++, this act of combining multiple class interfaces is called multiple inheritance, and it carries some rather sticky baggage because each class can have an implementation. In Java, you can perform the same act, but only one of the classes can have an implementation, so the C++ problems do not occur with Java when combining multiple interfaces:</p>
<table>
<tr><th colspan="5">Abstract or Concrete Base Cassinterface 1&quot;K</th></tr>
<tr><td>J</td><td></td><td>I interf.............1</td><td>ace 2...........</td><td>! *• ** ***■---------------------------<sub>1</sub>i interface n :................a.........</td></tr>
<tr><td colspan="4">Base Class Methods interface 1 interface 2</td><td>interface n</td></tr>
</table>
<p>In a derived class, you aren’t forced to have a base class that is either abstract or &quot;concrete&quot; (one with no abstract methods). If you do inherit from a non-interface, you can inherit from only one. All the rest of the base elements must be interfaces. You place all the interface names after the implements keyword and separate them with commas. You can have as many interfaces as you want. You can upcast to each interface, because each interface is an independent type. The following example shows a concrete class combined with several interfaces to produce a new class:</p>
<p>//: interfaces/Adventure.java // Multiple interfaces.</p>
<p>interface CanFight { void fight();</p>
<p>}</p>
<p>interface CanSwim { void swim();</p>
<p>}</p>
<p>interface CanFly { void fly();</p>
<p>}</p>
<p>class ActionCharacter { public void fight() {}</p>
<p>}</p>
<p>class Hero extends ActionCharacter</p>
<p>implements CanFight, CanSwim, CanFly { public void swim() {} public void fly() {}</p>
<p>}</p>
<p>public class Adventure {</p>
<p>public static void t(CanFight x) { x.fight(); } public static void u(CanSwim x) { x.swim(); }</p>
<p>public static void v(CanF!y x) { x.fly(); }</p>
<p>public static void w(ActionCharacter x) { x.fight(); }</p>
<p>public static void main(String[] args) {</p>
<table>
<tr><td>Hero</td><td>h =</td><td colspan="3">new Hero();</td><td></td><td></td></tr>
<tr><td>t(h)</td><td>//</td><td>Treat</td><td>it</td><td>as</td><td>a</td><td>CanFight</td></tr>
<tr><td>u(h)</td><td>//</td><td>Treat</td><td>it</td><td>as</td><td>a</td><td>CanSwim</td></tr>
<tr><td>v(h)</td><td>//</td><td>Treat</td><td>it</td><td>as</td><td>a</td><td>CanFly</td></tr>
<tr><td>w(h)</td><td>//</td><td>Treat</td><td>it</td><td>as</td><td>an</td><td>ActionCharacter</td></tr>
</table>
<p>}</p>
<p>} ///:~</p>
<p>You can see that Hero combines the concrete class ActionCharacter with the interfaces CanFight, CanSwim, and CanFly. When you combine a concrete class with interfaces this way, the concrete class must come first, then the interfaces. (The compiler gives an error otherwise.)</p>
<p>The signature for fight( ) is the same in the interface CanFight and the class ActionCharacter, and that fight( ) is not provided with a definition in Hero. You can extend an interface, but then you’ve got another interface. When you want to create an object, all the definitions must first exist. Even though Hero does not explicitly provide a definition for fight( ), the definition comes along with ActionCharacter; thus, it’s possible to create Hero objects.</p>
<p>In class Adventure, you can see that there are four methods that take arguments of the various interfaces and of the concrete class. When a Hero object is created, it can be passed to any of these methods, which means it is being upcast to each interface in turn. Because of the way interfaces are designed in Java, this works without any particular effort on the part of the programmer.</p>
<p>Keep in mind that one of the core reasons for interfaces is shown in the preceding example: to upcast to more than one base type (and the flexibility that this provides). However, a second reason for using interfaces is the same as using an abstract base class: to prevent the client programmer from making an object of this class and to establish that it is only an interface.</p>
<p>This brings up a question: Should you use an interface or an abstract class? If it’s possible to create your base class without any method definitions or member variables, you should always prefer interfaces to abstract classes. In fact, if you know something is going to be a base class, you can consider making it an interface (this subject will be revisited in the chapter summary).</p>
<p>Exercise 12: (2) In Adventure.java, add an interface called CanClimb, following the form of the other interfaces.</p>
<p>Exercise 13: (2) Create an interface, and inherit two new interfaces from that interface. Multiply inherit a third interface from the second two.<a l:href="#bookmark32" type="note"><sup>33</sup></a><sup></sup></p>
</section>
<section>
<title>
<p>Extending an interface with inheritance</p></title><empty-line/>
<p>You can easily add new method declarations to an interface by using inheritance, and you can also combine several interfaces into a new interface with inheritance. In both cases you get a new interface, as seen in this example:</p>
<p>//: interfaces/HorrorShow.java // Extending an interface with inheritance.</p>
<p>interface Monster { void menace();</p>
<p>}</p>
<p>interface DangerousMonster extends Monster { void destroy();</p>
<p>}</p>
<p>interface Lethal { void kill();</p>
<p>}</p>
<p>class DragonZilla implements DangerousMonster { public void menace() {} public void destroy() {}</p>
<p>}</p>
<p>interface Vampire extends DangerousMonster, Lethal { void drinkBlood();</p>
<p>}</p>
<p>class VeryBadVampire implements Vampire { public void menace() {} public void destroy() {} public void kill() {} public void drinkBlood() {}</p>
<p>}</p>
<p>public class HorrorShow {</p>
<p>static void u(Monster b) { b.menace(); } static void v(DangerousMonster d) { d.menace(); d.destroy();</p>
<p>}</p>
<p>static void w(Lethal l) { l.kill(); } public static void main(String[] args) {</p>
<p>DangerousMonster barney = new DragonZilla();</p>
<p>u(barney);</p>
<p>v(barney);</p>
<p>Vampire vlad = new VeryBadVampire();</p>
<p>u(vlad);</p>
<p>v(vlad);</p>
<p>w(vlad);</p>
<p>}</p>
<p>} ///:~</p>
<p>DangerousMonster is a simple extension to Monster that produces a new interface. This is implemented in DragonZilla.</p>
<p>The syntax used in Vampire works only when inheriting interfaces. Normally, you can use extends with only a single class, but extends can refer to multiple base interfaces when building a new interface. As you can see, the interface names are simply separated with commas.</p>
<p>Exercise 14: (2) Create three interfaces, each with two methods. Inherit a new interface that combines the three, adding a new method. Create a class by implementing the new interface and also inheriting from a concrete class. Now write four methods, each of which takes one of the four interfaces as an argument. In main( ), create an object of your class and pass it to each of the methods.</p>
<p>Exercise 15: (2) Modify the previous exercise by creating an abstract class and inheriting that into the derived class.</p>
<subtitle>Name collisions when combining Interfaces</subtitle>
<p>You can encounter a small pitfall when implementing multiple interfaces. In the preceding example, both CanFight and ActionCharacter have identical void fight( ) methods. An identical method is not a problem, but what if the method differs by signature or return type? Here’s an example:</p>
<p>//: interfaces/InterfaceCollision.java package interfaces;</p>
<p>interface I1 { void f(); }</p>
<p>interface I2 { int f(int i); }</p>
<p>interface I3 { int f(); }</p>
<p>class C { public int f() { return 1; } }</p>
<p>class C2 implements I1, I2 { public void f() {}</p>
<p>public int f(int i) { return 1; } // overloaded</p>
<p>}</p>
<p>class C3 extends C implements I2 {</p>
<p>public int f(int i) { return 1; } // overloaded</p>
<p>}</p>
<p>class C4 extends C implements I3 {</p>
<p>// Identical, no problem: public int f() { return 1; }</p>
<p>}</p>
<p>// Methods differ only by return type:</p>
<p>//! class C5 extends C implements I1 {}</p>
<p>//! interface I4 extends I1, I3 {} ///:~</p>
<p>The difficulty occurs because overriding, implementation, and overloading get unpleasantly mixed together. Also, overloaded methods cannot differ only by return type. When the last two lines are uncommented, the error messages say it all:</p>
<p>InterfaceCollision.java:23: f() in C cannot implementf() in It; attempting to use incompatible return type found: int required: void</p>
<p>InterfaceCollision.java:24: Interfaces I3 andh are incompatible; both define f(), but with different return type</p>
<p>Using the same method names in different interfaces that are intended to be combined generally causes confusion in the readability of the code, as well. Strive to avoid it.</p>
</section>
<section>
<title>
<p>Adapting to an interface</p></title><empty-line/>
<p>One of the most compelling reasons for interfaces is to allow multiple implementations for the same interface. In simple cases this is in the form of a method that accepts an interface, leaving it up to you to implement that interface and pass your object to the method.</p>
<p>Thus, a common use for interfaces is the aforementioned Strategy design pattern. You write a method that performs certain operations, and that method takes an interface that you also specify. You’re basically saying, &quot;You can use my method with any object you like, as long as your object conforms to my interface.&quot; This makes your method more flexible, general and reusable.</p>
<p>For example, the constructor for the Java SE5 Scanner class (which you’ll learn more about in the Strings chapter) takes a Readable interface. You’ll find that Readable is not an argument for any other method in the Java standard library—it was created solely for Scanner, so that Scanner doesn’t have to constrain its argument to be a particular class. This way, Scanner can be made to work with more types. If you create a new class and you want it to be usable with Scanner, you make it Readable, like this:</p>
<p>//: interfaces/RandomWords.java</p>
<p>// Implementing an interface to conform to a method. import java.nio.*; import java.util.*;</p>
<p>public class RandomWords implements Readable { private static Random rand = new Random(47); private static final char[] capitals =</p>
<p>&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray(); private static final char[] lowers =</p>
<p>&quot;abcdefghijklmnopqrstuvwxyz&quot;.toCharArray(); private static final char[] vowels =</p>
<p>&quot;aeiou&quot;.toCharArray(); private int count;</p>
<p>public RandomWords(int count) { this.count = count; } public int read(CharBuffer cb) { if(count-- == 0)</p>
<p>return -1; // Indicates end of input cb.append(capitals[rand.nextInt(capitals.length)]); for(int i = 0; i &lt; 4; i++) {</p>
<p>cb.append(vowels[rand.nextInt(vowels.length)]);</p>
<p>cb.append(lowers[rand.nextInt(lowers.length)]);</p>
<p>}</p>
<p>cb.append(&quot; &quot;);</p>
<p>return 10; // Number of characters appended</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Scanner s = new Scanner(new RandomWords(10)); while(s.hasNext())</p>
<p>System.out.println(s.next());</p>
<p>}</p>
<p>} /* Output:</p>
<p>Yazeruyac</p>
<p>Fowenucor</p>
<p>Goeazimom</p>
<p>Raeuuacio</p>
<p>Nuoadesiw</p>
<p>Hageaikux</p>
<p>Ruqicibui</p>
<p>Numasetih</p>
<p>Kuuuuozog</p>
<p>Waqizeyoy</p>
<p>*///:~</p>
<p>The Readable interface only requires the implementation of a read( ) method. Inside read( ), you add to the CharBuffer argument (there are several ways to do this; see the CharBuffer documentation), or return -l when you have no more input.</p>
<p>Suppose you have a class that does not already implement Readable—how do you make it work with Scanner? Here’s an example of a class that produces random floating point numbers:</p>
<p>//: interfaces/RandomDoubles.java import java.util.*;</p>
<p>public class RandomDoubles {</p>
<p>private static Random rand = new Random(47); public double next() { return rand.nextDouble(); } public static void main(String[] args) {</p>
<p>RandomDoubles rd = new RandomDoubles(); for(int i = 0; i &lt; 7; i ++)</p>
<p>System.out.print(rd.next() + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>0.7271157860730044 0.5309454508634242 0.16020656493302599 0.18847866977771732 0.5166020801268457 0.2678662084200585 0.2613610344283964 *///:~</p>
<p>Because you can add an interface onto any existing class in this way, it means that a method that takes an interface provides a way for any class to be adapted to work with that method. This is the power of using interfaces instead of classes.</p>
<p>Exercise 16: (3) Create a class that produces a sequence of chars. Adapt this class so that it can be an input to a Scanner object.</p>
</section>
<section>
<title>
<p>Fields in interfaces</p></title><empty-line/>
<p>Because any fields you put into an interface are automatically static and final, the interface is a convenient tool for creating groups of constant values. Before Java SE5, this was the only way to produce the same effect as an enum in C or C++. So you will see pre-Java SE5 code like this: //: interfaces/Months.java</p>
<p>// Using interfaces to create groups of constants. package interfaces;</p>
<table>
<tr><th colspan="5">public interface Months { int</th></tr>
<tr><td>JANUARY = 1</td><td>, FEBRUARY =</td><td>2,</td><td>MARCH = 3,</td><td></td></tr>
<tr><td>APRIL = 4,</td><td>MAY = 5, JUNE</td><td>=</td><td>6, JULY =</td><td>7,</td></tr>
<tr><td>AUGUST = 8,</td><td>SEPTEMBER =</td><td>9,</td><td>OCTOBER =</td><td>10,</td></tr>
<tr><td>NOVEMBER =</td><td>11, DECEMBER</td><td><sub>=</sub></td><td>12;</td><td></td></tr>
</table>
<p>} ///:~</p>
<p>Notice the Java style of using all uppercase letters (with underscores to separate multiple words in a single identifier) for static finals that have constant initializers. The fields in an interface are automatically public, so that is not explicitly specified.</p>
<p>With Java SE5, you now have the much more powerful and flexible enum keyword, so it rarely makes sense to use interfaces for constants anymore. However, you will probably run across the old idiom on many occasions when reading legacy code (the supplements for this book at <a l:href="http://www.MindView.net">www.MindView.net</a> contain a complete description of the pre-Java SE5 approach to producing enumerated types using interfaces). You can find more details about using enums in the Enumerated Types chapter.</p>
<p>Exercise 17: (2) Prove that the fields in an interface are implicitly static and final.</p>
<subtitle>Initializing fields in interfaces</subtitle>
<p>Fields defined in interfaces cannot be &quot;blank finals,&quot; but they can be initialized with nonconstant expressions. For example:</p>
<p>//: interfaces/RandVals.java // Initializing interface fields with // non-constant initializers. import java.util.*;</p>
<p>public interface RandVals {</p>
<p>Random RAND = new Random(47);</p>
<p>int RANDOM_INT = RAND.nextInt(10);</p>
<p>long RANDOM_LONG = RAND.nextLong() * 10;</p>
<p>float RANDOM_FLOAT = RAND.nextLong() * 10;</p>
<p>double RANDOM_DOUBLE = RAND.nextDouble() * 10;</p>
<p>} ///:~</p>
<p>Since the fields are static, they are initialized when the class is first loaded, which happens when any of the fields are accessed for the first time. Here’s a simple test:</p>
<p>//: interfaces/TestRandVals.java import static net.mindview.util.Print.*;</p>
<p>public class TestRandVals {</p>
<p>public static void main(String[] args) { print(RandVals.RANDOM_INT); print(RandVals.RANDOM_LONG); print(RandVals.RANDOM_FLOAT); print(RandVals.RANDOM_DOUBLE);</p>
<p>}</p>
<p>} /* Output:</p>
<p>8</p>
<p>-32032247016559954</p>
<p>-8.5939291E18</p>
<p>5.779976127815049</p>
<p>*///:~</p>
<p>The fields, of course, are not part of the interface. The values are stored in the static storage area for that interface.</p>
</section>
<section>
<title>
<p>Nesting interfaces</p></title><empty-line/>
<p>Interfaces may be nested within classes and within other interfaces.<a l:href="#bookmark33" type="note"><sup>34</sup></a><sup></sup> This reveals a number</p>
<p>of interesting features:</p>
<p>//: interfaces/nesting/Nestinglnterfaces.java</p>
<p>package interfaces.nesting;</p>
<p>class A {</p>
<p>interface B { void f();</p>
<p>}</p>
<p>public class BImp implements B { public void f() {}</p>
<p>}</p>
<p>private class BImp2 implements B { public void f() {}</p>
<p>}</p>
<p>public interface C { void f();</p>
<p>}</p>
<p>class CImp implements C { public void f() {}</p>
<p>}</p>
<p>private class CImp2 implements C { public void f() {}</p>
<p>}</p>
<p>private interface D { void f();</p>
<p>}</p>
<p>private class DImp implements D { public void f() {}</p>
<p>}</p>
<p>public class DImp2 implements D { public void f() {}</p>
<p>}</p>
<p>public D getD() { return new DImp2(); } private D dRef; public void receiveD(D d) { dRef = d; dRef.f();</p>
<p>}</p>
<p>}</p>
<p>interface E { interface G { void f();</p>
<p>}</p>
<p>// Redundant &quot;public&quot;: public interface H { void f();</p>
<p>}</p>
<p>void g();</p>
<p>// Cannot be private within an interface:</p>
<p>//! private interface I {}</p>
<p>}</p>
<p>public class NestingInterfaces {</p>
<p>public class BImp implements A.B { public void f() {}</p>
<p>}</p>
<p>class CImp implements A.C { public void f() {}</p>
<p>}</p>
<p>// Cannot implement a private interface except // within that interface’s defining class:</p>
<p>//! class DImp implements A.D {</p>
<p>//! public void f() {}</p>
<p>//! }</p>
<p>class EImp implements E { public void g() {}</p>
<p>}</p>
<p>class EGImp implements E.G { public void f() {}</p>
<p>}</p>
<p>class EImp2 implements E { public void g() {} class EG implements E.G { public void f() {}</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>A a = new A();</p>
<p>// Can’t access A.D:</p>
<p>//! A.D ad = a.getD();</p>
<p>// Doesn’t return anything but A.D:</p>
<p>//! A.DImp2 di2 = a.getD();</p>
<p>// Cannot access a member of the interface:</p>
<p>//! a.getD().f();</p>
<p>// Only another A can do anything with getD():</p>
<p>A a2 = new A(); a2.receiveD(a.getD());</p>
<p>}</p>
<p>} ///:~</p>
<p>The syntax for nesting an interface within a class is reasonably obvious. Just like non-nested interfaces, these can have public or package-access visibility.</p>
<p>As an added twist, interfaces can also be private, as seen in A.D (the same qualification syntax is used for nested interfaces as for nested classes). What good is a private nested interface? You might guess that it can only be implemented as a private inner class as in DImp, but A.DImp2 shows that it can also be implemented as a public class. However, A.DImp2 can only be used as itself. You are not allowed to mention the fact that it implements the private interface D, so implementing a private interface is a way to force the definition of the methods in that interface without adding any type information (that is, without allowing any upcasting).</p>
<p>The method getD( ) produces a further quandary concerning the private interface: It’s a public method that returns a reference to a private interface. What can you do with the return value of this method? In main( ), you can see several attempts to use the return value, all of which fail. The only thing that works is if the return value is handed to an object that has permission to use it—in this case, another A, via the receiveD( ) method.</p>
<p>Interface E shows that interfaces can be nested within each other. However, the rules about interfaces—in particular, that all interface elements must be public—are strictly enforced here, so an interface nested within another interface is automatically public and cannot be made private.</p>
<p>Nestinglnterfaces shows the various ways that nested interfaces can be implemented. In particular, notice that when you implement an interface, you are not required to implement any interfaces nested within. Also, private interfaces cannot be implemented outside of their defining classes.</p>
<p>Initially, these features may seem like they are added strictly for syntactic consistency, but I generally find that once you know about a feature, you often discover places where it is useful.</p>
</section>
<section>
<title>
<p>Interfaces and factories</p></title><empty-line/>
<p>An interface is intended to be a gateway to multiple implementations, and a typical way to produce objects that fit the interface is the Factory Method design pattern. Instead of calling a constructor directly, you call a creation method on a factory object which produces an implementation of the interface—this way, in theory, your code is completely isolated from the implementation of the interface, thus making it possible to transparently swap one implementation for another. Here’s a demonstration showing the structure of the Factory Method:</p>
<p>//: interfaces/Factories.java</p>
<p>import static net.mindview.util.Print.*;</p>
<p>interface Service { void method1(); void method2();</p>
<p>}</p>
<p>interface ServiceFactory {</p>
<p>Service getService();</p>
<p>}</p>
<p>class Implementation1 implements Service {</p>
<p>Implementation^) {} // Package access</p>
<p>public    void    method1()    {print(&quot;Implementation1    method1&quot;);}</p>
<p>public    void    method2()    {print(&quot;Implementation1    method2&quot;);}</p>
<p>}</p>
<p>class Implementation1Factory implements ServiceFactory { public Service getService() { return new Implementation^);</p>
<p>}</p>
<p>}</p>
<p>class Implementation2 implements Service {</p>
<p>Implementation2() {} // Package access</p>
<p>public    void    method1()    {print(&quot;Implementation2    method1&quot;);}</p>
<p>public    void    method2()    {print(&quot;Implementation2    method2&quot;);}</p>
<p>}</p>
<p>class Implementation2Factory implements ServiceFactory { public Service getService() { return new Implementation2();</p>
<p>}</p>
<p>}</p>
<p>public class Factories {</p>
<p>public static void serviceConsumer(ServiceFactory fact) {</p>
<p>Service s = fact.getService();</p>
<p>s.method1();</p>
<p>s.method2();</p>
<p>public static void main(String[] args) {</p>
<p>serviceConsumer(new Implementation1Factory());</p>
<p>// Implementations are completely interchangeable: serviceConsumer(new Implementation2Factory());</p>
<p>}</p>
<p>} /* Output:</p>
<p>Implementation1 method1 Implementation1 method2 Implementation2 method1 Implementation2 method2 *///:~</p>
<p>Without the Factory Method, your code would somewhere have to specify the exact type of Service being created, so that it could call the appropriate constructor.</p>
<p>Why would you want to add this extra level of indirection? One common reason is to create a framework. Suppose you are creating a system to play games; for example, to play both chess and checkers on the same board:</p>
<p>//: interfaces/Games.java</p>
<p>// A Game framework using Factory Methods.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>interface Game { boolean move(); } interface GameFactory { Game getGame(); }</p>
<p>class Checkers implements Game { private int moves = 0; private static final int MOVES = 3; public boolean move() {</p>
<p>print(&quot;Checkers move &quot; + moves); return ++moves != MOVES;</p>
<p>}</p>
<p>}</p>
<p>class CheckersFactory implements GameFactory { public Game getGame() { return new Checkers(); }</p>
<p>}</p>
<p>class Chess implements Game { private int moves = 0; private static final int MOVES = 4; public boolean move() {</p>
<p>print(&quot;Chess move &quot; + moves); return ++moves != MOVES;</p>
<p>}</p>
<p>}</p>
<p>class ChessFactory implements GameFactory { public Game getGame() { return new Chess(); }</p>
<p>}</p>
<p>public class Games {</p>
<p>public static void playGame(GameFactory factory) {</p>
<p>Game s = factory.getGame(); while(s.move())</p>
<p>}</p>
<p>public static void main(String[] args) { playGame(new CheckersFactory()); playGame(new ChessFactory());</p>
<p>} /* Output:</p>
<p>Checkers move 0 Checkers move 1 Checkers move 2 Chess move 0 Chess move 1 Chess move 2 Chess move 3 *///:~</p>
<p>If the Games class represents a complex piece of code, this approach allows you to reuse that code with different types of games. You can imagine more elaborate games that can benefit from this pattern. In the next chapter, you’ll see a more elegant way to implement the factories using anonymous inner classes.</p>
<p>Exercise 18: (2) Create a Cycle interface, with implementations Unicycle, Bicycle</p>
<p>and Tricycle. Create factories for each type of Cycle, and code that uses these factories.</p>
<p>Exercise 19: (3) Create a framework using Factory Methods that performs both coin tossing and dice tossing.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>It is tempting to decide that interfaces are good, and therefore you should always choose interfaces over concrete classes. Of course, almost anytime you create a class, you could instead create an interface and a factory.</p>
<p>Many people have fallen to this temptation, creating interfaces and factories wherever it’s possible. The logic seems to be that you might need to use a different implementation, so you should always add that abstraction. It has become a kind of premature design optimization.</p>
<p>Any abstraction should be motivated by a real need. Interfaces should be something you refactor to when necessary, rather than installing the extra level of indirection everywhere, along with the extra complexity. That extra complexity is significant, and if you make someone work through that complexity only to realize that you’ve added interfaces &quot;just in case&quot; and for no compelling reason-well, if I see such a thing I begin to question all the designs that this particular person has done.</p>
<p>An appropriate guideline is to prefer classes to interfaces. Start with classes, and if it becomes clear that interfaces are necessary, then refactor. Interfaces are a great tool, but they can easily be overused.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Inner Classes</p></title><empty-line/>
<p>It’s possible to place a class definition within another class definition. This is called an inner class.</p>
<p>The inner class is a valuable feature because it allows you to group classes that logically belong together and to control the visibility of one within the other. However, it’s important to understand that inner classes are distinctly different from composition.</p>
<p>At first, inner classes look like a simple code-hiding mechanism: You place classes inside other classes. You’ll learn, however, that the inner class does more than that—it knows about and can communicate with the surrounding class—and the kind of code you can write with inner classes is more elegant and clear, although there’s certainly no guarantee of this.</p>
<p>Initially, inner classes may seem odd, and it will take some time to become comfortable using them in your designs. The need for inner classes isn’t always obvious, but after the basic syntax and semantics of inner classes have been described, the section &quot;Why inner classes?&quot; should begin to make clear the benefits of inner classes.</p>
<p>After that section, the remainder of the chapter contains more detailed explorations of the syntax of inner classes. These features are provided for language completeness, but you might not need to use them, at least not at first. So the initial parts of the chapter might be all you need for now, and you can leave the more detailed explorations as reference material.</p>
<section>
<title>
<p>Creating inner classes</p></title><empty-line/>
<p>You create an inner class just as you’d expect—by placing the class definition inside a surrounding class:</p>
<p>//: innerclasses/Parcell.java // Creating inner classes.</p>
<p>public class Parcell { class Contents { private int i = 11; public int value() { return i; }</p>
<p>}</p>
<p>class Destination { private String label;</p>
<p>Destination(String whereTo) { label = whereTo;</p>
<p>}</p>
<p>String readLabel() { return label; }</p>
<p>}</p>
<p>// Using inner classes looks just like // using any other class, within Parcell: public void ship(String dest) {</p>
<p>Contents c = new Contents();</p>
<p>Destination d = new Destination(dest); System.out.println(d.readLabel());</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Parcell p = new Parcel1(); p.ship(&quot;Tasmania&quot;);</p>
<p>}</p>
<p>} /* Output: Tasmania *///:~</p>
<p>The inner classes used inside ship( ) look just like ordinary classes. Here, the only practical difference is that the names are nested within Parceli. You’ll see in a while that this isn’t the only difference. More typically, an outer class will have a method that returns a reference to an inner class, as you can see in the to( ) and contents( ) methods:</p>
<p>//: innerclasses/Parcel2.java</p>
<p>// Returning a reference to an inner class.</p>
<p>public class Parcel2 { class Contents { private int i = 11; public int value() { return i; }</p>
<p>}</p>
<p>class Destination { private String label;</p>
<p>Destination(String whereTo) { label = whereTo;</p>
<p>}</p>
<p>String readLabel() { return label; }</p>
<p>}</p>
<p>public Destination to(String s) { return new Destination(s);</p>
<p>}</p>
<p>public Contents contents() { return new Contents();</p>
<p>}</p>
<p>public void ship(String dest) {</p>
<p>Contents c = contents();</p>
<p>Destination d = to(dest);</p>
<p>System.out.println(d.readLabel());</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Parcel2 p = new Parcel2(); p.ship(&quot;Tasmania&quot;);</p>
<p>Parcel2 q = new Parcel2();</p>
<p>// Defining references to inner classes:</p>
<p>Parcel2.Contents c = q.contents();</p>
<p>Parcel2.Destination d = q.to(&quot;Borneo&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Tasmania</p>
<p>*///:~</p>
<p>If you want to make an object of the inner class anywhere except from within a non-static method of the outer class, you must specify the type of that object as OuterClassName.InnerClassName, as seen in main( ).</p>
<p>Exercise 1: (1) Write a class named Outer that contains an inner class named Inner. Add a method to Outer that returns an object of type Inner. In main( ), create and initialize a reference to an Inner.</p>
</section>
<section>
<title>
<p>The link to the outer class</p></title><empty-line/>
<p>So far, it appears that inner classes are just a name-hiding and code organization scheme, which is helpful but not totally compelling. However, there’s another twist. When you create an inner class, an object of that inner class has a link to the enclosing object that made it, and so it can access the members of that enclosing object—without any special qualifications. In addition, inner classes have access rights to all the elements in the enclosing class.<a l:href="#bookmark34" type="note"><sup>35</sup></a><sup></sup> The following example demonstrates this:</p>
<p>//: innerclasses/Sequence.java // Holds a sequence of Objects.</p>
<p>interface Selector { boolean end();</p>
<p>Object current(); void next();</p>
<p>}</p>
<p>public class Sequence { private Object[] items; private int next = 0;</p>
<p>public Sequence(int size) { items = new Object[size]; } public void add(Object x) { if(next &lt; items.length) items[next++] = x;</p>
<p>}</p>
<p>private class SequenceSelector implements Selector { private int i = 0;</p>
<p>public boolean end() { return i == items.length; } public Object current() { return items[i]; } public void next() { if(i &lt; items.length) i++; }</p>
<p>}</p>
<p>public Selector selector() { return new SequenceSelector();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Sequence sequence = new Sequence(10); for(int i = 0; i &lt; 10; i++)</p>
<p>sequence.add(Integer.toString(i));</p>
<p>Selector selector = sequence.selector(); while(!selector.end()) {</p>
<p>System.out.print(selector.current() + &quot; &quot;); selector.next();</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>0 1 2 3 4 5 6 7 8 9 *///:~</p>
<p>The Sequence is simply a fixed-sized array of Object with a class wrapped around it. You call add( ) to add a new Object to the end of the sequence (if there’s room left). To fetch each of the objects in a Sequence, there’s an interface called Selector. This is an example of the Iterator design pattern that you shall learn more about later in the book. A Selector allows you to see if you’re at the end( ), to access the current( ) Object, and to move to the next( ) Object in the Sequence. Because Selector is an interface, other classes can implement the interface in their own ways, and other methods can take the interface as an argument, in order to create more general-purpose code.</p>
<p>Here, the SequenceSelector is a private class that provides Selector functionality. In main( ), you can see the creation of a Sequence, followed by the addition of a number of String objects. Then, a Selector is produced with a call to selector( ), and this is used to move through the Sequence and select each item.</p>
<p>At first, the creation of SequenceSelector looks like just another inner class. But examine it closely. Note that each of the methods—end( ), current( ), and next( )—refers to items, which is a reference that isn’t part of SequenceSelector, but is instead a private field in the enclosing class. However, the inner class can access methods and fields from the enclosing class as if it owned them. This turns out to be very convenient, as you can see in the preceding example.</p>
<p>So an inner class has automatic access to the members of the enclosing class. How can this happen? The inner class secretly captures a reference to the particular object of the enclosing class that was responsible for creating it. Then, when you refer to a member of the enclosing class, that reference is used to select that member. Fortunately, the compiler takes care of all these details for you, but now you can see that an object of an inner class can be created only in association with an object of the enclosing class (when, as you shall see, the inner class is non-static). Construction of the inner-class object requires the reference to the object of the enclosing class, and the compiler will complain if it cannot access that reference. Most of the time this occurs without any intervention on the part of the programmer.</p>
<p>Exercise 2: (1) Create a class that holds a String, and has a toString( ) method that displays this String. Add several instances of your new class to a Sequence object, then display them.</p>
<p>Exercise 3: (1) Modify Exercise 1 so that Outer has a private String field (initialized by the constructor), and Inner has a toString( ) that displays this field. Create an object of type Inner and display it.</p>
</section>
<section>
<title>
<p>Using .this and .new</p></title><empty-line/>
<p>If you need to produce the reference to the outer-class object, you name the outer class followed by a dot and this. The resulting reference is automatically the correct type, which is known and checked at compile time, so there is no runtime overhead. Here’s an example that shows how to use .this:</p>
<p>//: innerclasses/DotThis.java</p>
<p>// Qualifying access to the outer-class object. public class DotThis {</p>
<p>void f() { System.out.println(&quot;DotThis.fQ&quot;); } public class Inner {</p>
<p>public DotThis outer() { return DotThis.this;</p>
<p>// A plain &quot;this&quot; would be Inner&apos;s &quot;this&quot;</p>
<p>}</p>
<p>}</p>
<p>public Inner inner() { return new Inner(); } public static void main(String[] args) {</p>
<p>DotThis dt = new DotThis();</p>
<p>DotThis.Inner dti = dt.inner(); dti.outer().f();</p>
<p>}</p>
<p>} /* Output:</p>
<p>DotThis.fQ</p>
<p>*///:~</p>
<p>Sometimes you want to tell some other object to create an object of one of its inner classes. To do this you must provide a reference to the other outer-class object in the new expression, using the .new syntax, like this:</p>
<p>//: innerclasses/DotNew.java // Creating an inner class directly using the .new syntax.</p>
<p>public class DotNew { public class Inner {}</p>
<p>public static void main(String[] args) {</p>
<p>DotNew dn = new DotNew();</p>
<p>DotNew.Inner dni = dn.new Inner();</p>
<p>}</p>
<p>} ///:~</p>
<p>To create an object of the inner class directly, you don’t follow the same form and refer to the outer class name DotNew as you might expect, but instead you must use an object of the outer class to make an object of the inner class, as you can see above. This also resolves the name scoping issues for the inner class, so you don’t say (indeed, you can’t say) dn.new DotNew.Inner( ).</p>
<p>It’s not possible to create an object of the inner class unless you already have an object of the outer class. This is because the object of the inner class is quietly connected to the object of the outer class that it was made from. However, if you make a nested class (a static inner class), then it doesn’t need a reference to the outer-class object.</p>
<p>Here, you see the use of .new applied to the &quot;Parcel&quot; example:</p>
<p>//: innerclasses/Parcel3.java</p>
<p>// Using .new to create instances of inner classes.</p>
<p>public class Parcel3 { class Contents { private int i = 11; public int value() { return i; }</p>
<p>}</p>
<p>class Destination { private String label;</p>
<p>Destination(String whereTo) { label = whereTo; }</p>
<p>String readLabel() { return label; }</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Parcel3 p = new Parcel3();</p>
<p>// Must use instance of outer class</p>
<p>// to create an instance of the inner class:</p>
<p>Parcel3.Contents c = p.new Contents();</p>
<p>Parcel3.Destination d = p.new Destination(&quot;Tasmania&quot;);</p>
<p>}</p>
<p>} ///:~</p>
<p>Exercise 4: (2) Add a method to the class Sequence.SequenceSelector that produces the reference to the outer class Sequence.</p>
<p>Exercise 5: (1) Create a class with an inner class. In a separate class, make an instance of the inner class.</p>
</section>
<section>
<title>
<p>Inner classes and upcasting</p></title><empty-line/>
<p>Inner classes really come into their own when you start upcasting to a base class, and in particular to an interface. (The effect of producing an interface reference from an object that implements it is essentially the same as upcasting to a base class.) That’s because the inner class—the implementation of the interface-can then be unseen and unavailable, which is convenient for hiding the implementation. All you get back is a reference to the base class or the interface.</p>
<p>We can create interfaces for the previous examples:</p>
<p>//: innerclasses/Destination.java public interface Destination {</p>
<p>String readLabel();</p>
<p>} ///:~</p>
<p>Now Contents and Destination represent interfaces available to the client programmer. Remember that an interface automatically makes all of its members public.</p>
<p>When you get a reference to the base class or the interface, it’s possible that you can’t even find out the exact type, as shown here:</p>
<p>//: innerclasses/TestParcel.java class Parcel4 {</p>
<p>private class PContents implements Contents { private int i = 11; public int value() { return i; }</p>
<p>}</p>
<p>protected class PDestination implements Destination { private String label; private PDestination(String whereTo) { label = whereTo;</p>
<p>}</p>
<p>public String readLabel() { return label; }</p>
<p>}</p>
<p>public Destination destination(String s) { return new PDestination(s);</p>
<p>}</p>
<p>public Contents contents() { return new PContents();</p>
<p>}</p>
<p>}</p>
<p>public class TestParcel {</p>
<p>public static void main(String[] args) {</p>
<p>Parcel4 p = new Parcel4();</p>
<p>Contents c = p.contents();</p>
<p>Destination d = p.destination(&quot;Tasmania&quot;);</p>
<p>// Illegal -- can’t access private class:</p>
<p>//! Parcel4.PContents pc = p.new PContents();</p>
<p>}</p>
<p>} ///:~</p>
<p>In Parcel4, something new has been added: The inner class PContents is private, so nothing but Parcel4 can access it. Normal (non-inner) classes cannot be made private or protected; they may only be given public or package access. PDestination is protected,</p>
<p>so nothing but Parcel4, classes in the same package (since protected also gives package access), and the inheritors of Parcel4 can access PDestination. This means that the client programmer has restricted knowledge and access to these members. In fact, you can’t even downcast to a private inner class (or a protected inner class unless you’re an inheritor), because you can’t access the name, as you can see in class TestParcel. Thus, the private inner class provides a way for the class designer to completely prevent any type-coding dependencies and to completely hide details about implementation. In addition, extension of an interface is useless from the client programmer’s perspective since the client programmer cannot access any additional methods that aren’t part of the public interface. This also provides an opportunity for the Java compiler to generate more efficient code.</p>
<p>Exercise 6: (2) Create an interface with at least one method, in its own package. Create a class in a separate package. Add a protected inner class that implements the interface. In a third package, inherit from your class and, inside a method, return an object of the protected inner class, upcasting to the interface during the return.</p>
<p>Exercise 7: (2) Create a class with a private field and a private method. Create an inner class with a method that modifies the outer-class field and calls the outer-class method. In a second outer-class method, create an object of the inner class and call its method, then show the effect on the outer-class object.</p>
<p>Exercise 8: (2) Determine whether an outer class has access to the private elements of its inner class.</p>
</section>
<section>
<title>
<p>Inner classes</p></title><empty-line/>
</section>
<section>
<title>
<p>in methods and scopes</p></title><empty-line/>
<p>What you’ve seen so far encompasses the typical use for inner classes. In general, the code that you’ll write and read involving inner classes will be &quot;plain&quot; inner classes that are simple and easy to understand. However, the syntax for inner classes covers a number of other, more obscure techniques. Inner classes can be created within a method or even an arbitrary scope. There are two reasons for doing this:</p>
<p>1.    As shown previously, you’re implementing an interface of some kind so that you can create and return a reference.</p>
<p>2.    You’re solving a complicated problem and you want to create a class to aid in your solution, but you don’t want it publicly available.</p>
<p>In the following examples, the previous code will be modified to use:</p>
<p>1.    A class defined within a method</p>
<p>2.    A class defined within a scope inside a method</p>
<p>3.    An anonymous class implementing an interface</p>
<p>4.    An anonymous class extending a class that has a non-default constructor</p>
<p>5.    An anonymous class that performs field initialization</p>
<p>6.    An anonymous class that performs construction using instance initialization (anonymous inner classes cannot have constructors)</p>
<p>The first example shows the creation of an entire class within the scope of a method (instead of the scope of another class). This is called a local inner class:</p>
<p>//: innerclasses/Parce!5.java // Nesting a class within a method.</p>
<p>public class Parcel5 {</p>
<p>public Destination destination(String s) { class PDestination implements Destination {</p>
<p>private String label; private PDestination(String whereTo) { label = whereTo;</p>
<p>}</p>
<p>public String readLabel() { return label; }</p>
<p>}</p>
<p>return new PDestination(s);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Parcel5 p = new Parcel5();</p>
<p>Destination d = p.destination(&quot;Tasmania&quot;);</p>
<p>}</p>
<p>} ///:~</p>
<p>The class PDestination is part of destination( ) rather than being part of Parcels. Therefore, PDestination cannot be accessed outside of destination( ). Notice the upcasting that occurs in the return statementnothing comes out of destination( ) except a reference to Destination, the base class. Of course, the fact that the name of the class PDestination is placed inside destination( ) doesn’t mean that PDestination is not a valid object once destination( ) returns.</p>
<p>You could use the class identifier PDestination for an inner class inside each class in the same subdirectory without a name clash.</p>
<p>The next example shows how you can nest an inner class within any arbitrary scope:</p>
<p>//: innerclasses/Parcel6.java // Nesting a class within a scope.</p>
<p>public class Parcel6 {</p>
<p>private void internalTracking(boolean b) { if(b) {</p>
<p>class TrackingSlip { private String id;</p>
<p>TrackingSlip(String s) { id = s;</p>
<p>}</p>
<p>String getSlip() { return id; }</p>
<p>}</p>
<p>TrackingSlip ts = new TrackingSlip(&quot;slip&quot;);</p>
<p>String s = ts.getSlip();</p>
<p>}</p>
<p>// Can’t use it here! Out of scope:</p>
<p>//! TrackingSlip ts = new TrackingSlip(&quot;x&quot;);</p>
<p>}</p>
<p>public void track() { internalTracking(true); } public static void main(String[] args) {</p>
<p>Parcel6 p = new Parcel6(); p.track();</p>
<p>}</p>
<p>} ///:~</p>
<p>The class TrackingSlip is nested inside the scope of an if statement. This does not mean that the class is conditionally created—it gets compiled along with everything else. However, it’s not available outside the scope in which it is defined. Other than that, it looks just like an ordinary class.</p>
<p>Exercise 9: (1) Create an interface with at least one method, and implement that interface by defining an inner class within a method, which returns a reference to your interface.</p>
<p>Exercise 10: (1) Repeat the previous exercise but define the inner class within a scope within a method.</p>
<p>Exercise 11: (2) Create a private inner class that implements a public interface. Write a method that returns a reference to an instance of the private inner class, upcast to the interface. Show that the inner class is completely hidden by trying to downcast to it.</p>
</section>
<section>
<title>
<p>Anonymous inner classes</p></title><empty-line/>
<p>The next example looks a little odd:</p>
<p>//: innerclasses/Parcel7.java</p>
<p>// Returning an instance of an anonymous inner class.</p>
<p>public class Parcel7 {</p>
<p>public Contents contents() {</p>
<p>return new Contents() { // Insert a class definition private int i = 11; public int value() { return i; }</p>
<p>}; // Semicolon required in this case</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Parcel7 p = new Parcel7();</p>
<p>Contents c = p.contents();</p>
<p>}</p>
<p>} ///:~</p>
<p>The contents( ) method combines the creation of the return value with the definition of the class that represents that return value! In addition, the class is anonymous; it has no name. To make matters a bit worse, it looks like you’re starting out to create a Contents object, But then, before you get to the semicolon, you say, &quot;But wait, I think I’ll slip in a class definition.&quot;</p>
<p>What this strange syntax means is &quot;Create an object of an anonymous class that’s inherited from Contents.&quot; The reference returned by the new expression is automatically upcast to a Contents reference. The anonymous inner-class syntax is a shorthand for:</p>
<p>//: innerclasses/Parcel7b.java // Expanded version of Parcel7.java</p>
<p>public class Parcel7b {</p>
<p>class MyContents implements Contents { private int i = 11; public int value() { return i; }</p>
<p>}</p>
<p>public Contents contents() { return new MyContents(); } public static void main(String[] args) {</p>
<p>Parcel7b p = new Parcel7b();</p>
<p>Contents c = p.contents();</p>
<p>}</p>
<p>} ///:~</p>
<p>In the anonymous inner class, Contents is created by using a default constructor.</p>
<p>The following code shows what to do if your base class needs a constructor with an argument:</p>
<p>//: innerclasses/Parcel8.java // Calling the base-class constructor.</p>
<p>public class Parcel8 {</p>
<p>public Wrapping wrapping(int x) {</p>
<p>// Base constructor call:</p>
<p>return new Wrapping(x) { // Pass constructor argument. public int value() {</p>
<p>return super.value() * 47;</p>
<p>}</p>
<p>}; // Semicolon required</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Parcel8 p = new Parcel8();</p>
<p>Wrapping w = p.wrapping(10);</p>
<p>}</p>
<p>} ///:~</p>
<p>That is, you simply pass the appropriate argument to the base-class constructor, seen here as the x passed in new Wrapping(x). Although it’s an ordinary class with an implementation, Wrapping is also being used as a common &quot;interface&quot; to its derived classes:</p>
<p>//: innerclasses/Wrapping.java public class Wrapping { private int i;</p>
<p>public Wrapping(int x) { i = x; } public int value() { return i; }</p>
<p>} ///:~</p>
<p>You’ll notice that Wrapping has a constructor that requires an argument, to make things a bit more interesting.</p>
<p>The semicolon at the end of the anonymous inner class doesn’t mark the end of the class body. Instead, it marks the end of the expression that happens to contain the anonymous class. Thus, it’s identical to the use of the semicolon everywhere else.</p>
<p>You can also perform initialization when you define fields in an anonymous class:</p>
<p>//: innerclasses/Parcel9.java</p>
<p>// An anonymous inner class that performs</p>
<p>// initialization. A briefer version of Parcel5.java.</p>
<p>public class Parcel9 {</p>
<p>// Argument must be final to use inside // anonymous inner class:</p>
<p>public Destination destination(final String dest) { return new Destination() { private String label = dest; public String readLabel() { return label; }</p>
<p>};</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Parcel9 p = new Parcel9();</p>
<p>Destination d = p.destination(&quot;Tasmania&quot;);</p>
<p>}</p>
<p>} ///:~</p>
<p>If you’re defining an anonymous inner class and want to use an object that’s defined outside the anonymous inner class, the compiler requires that the argument reference be final, as you see in the argument to destination( ). If you forget, you’ll get a compile-time error message.</p>
<p>As long as you’re simply assigning a field, the approach in this example is fine. But what if you need to perform some constructor-like activity? You can’t have a named constructor in an anonymous class (since there’s no name!), but with instance initialization, you can, in effect, create a constructor for an anonymous inner class, like this:</p>
<p>//: innerclasses/AnonymousConstructor.java</p>
<p>// Creating a constructor for an anonymous inner class.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>abstract class Base { public Base(int i) {</p>
<p>print(&quot;Base constructor, i = &quot; + i);</p>
<p>}</p>
<p>public abstract void f();</p>
<p>}</p>
<p>public class AnonymousConstructor { public static Base getBase(int i) { return new Base(i) {</p>
<p>{ print(&quot;Inside instance initializer&quot;); } public void f() {</p>
<p>print(&quot;In anonymous f()&quot;);</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Base base = getBase(47); base.f();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Base constructor, i = 47 Inside instance initializer In anonymous f()</p>
<p>*///:~</p>
<p>In this case, the variable i did nor have to be final. While i is passed to the base constructor of the anonymous class, it is never directly used inside the anonymous class.</p>
<p>Here’s the &quot;parcel&quot; theme with instance initialization. Note that the arguments to destination( ) must be final since they are used within the anonymous class:</p>
<p>//: innerclasses/Parcel10.java</p>
<p>// Using &quot;instance initialization&quot; to perform</p>
<p>// construction on an anonymous inner class.</p>
<p>public class Parcel10 { public Destination</p>
<p>destination(final String dest, final float price) { return new Destination() { private int cost;</p>
<p>// Instance initialization for each object:</p>
<p>{</p>
<p>cost = Math.round(price); if(cost &gt; 100)</p>
<p>System.out.println(&quot;Over budget!&quot;);</p>
<p>}</p>
<p>private String label = dest;</p>
<p>public String readLabel() { return label; }</p>
<p>};</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Parcel10 p = new Parcel10();</p>
<p>Destination d = p.destination(&quot;Tasmania&quot;, 101.395F);</p>
<p>}</p>
<p>} /* Output: Over budget! *///:~</p>
<p>Inside the instance initializer you can see code that couldn’t be executed as part of a field initializer (that is, the if statement). So in effect, an instance initializer is the constructor for an anonymous inner class. Of course, it’s limited; you can’t overload instance initializers, so you can have only one of these constructors.</p>
<p>Anonymous inner classes are somewhat limited compared to regular inheritance, because they can either extend a class or implement an interface, but not both. And if you do implement an interface, you can only implement one.</p>
<p>Exercise 12: (1) Repeat Exercise 7 using an anonymous inner class.</p>
<p>Exercise 13: (1) Repeat Exercise 9 using an anonymous inner class.</p>
<p>Exercise 14: (1) Modify interfaces/HorrorShow.java to implement DangerousMonster and Vampire using anonymous classes.</p>
<p>Exercise 15: (2) Create a class with a non-default constructor (one with arguments) and no default constructor (no &quot;no-arg&quot; constructor). Create a second class that has a method that returns a reference to an object of the first class. Create the object that you return by making an anonymous inner class that inherits from the first class.</p>
<subtitle>Factory Method revisited</subtitle>
<p>Look at how much nicer the interfaces/Factories.java example comes out when you use anonymous inner classes:</p>
<p>//: innerclasses/Factories.java import static net.mindview.util.Print.*;</p>
<p>interface Service { void method1(); void method2();</p>
<p>}</p>
<p>interface ServiceFactory {</p>
<p>Service getService();</p>
<p>}</p>
<p>class Implementationl implements Service { private Implementation^) {}</p>
<p>public void method1() {print(&quot;Implementation1 methodl&quot;);} public void method2() {print(&quot;Implementation1 method2&quot;);} public static ServiceFactory factory = new ServiceFactory() {</p>
<p>public Service getService() { return new Implementation^);</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>class Implementation2 implements Service { private Implementation2() {}</p>
<p>public void method1() {print(&quot;Implementation2 methodl&quot;);} public void method2() {print(&quot;Implementation2 method2&quot;);} public static ServiceFactory factory = new ServiceFactory() {</p>
<p>public Service getService() { return new Implementation2();</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>public class Factories {</p>
<p>public static void serviceConsumer(ServiceFactory fact) { Service s = fact.getService(); s.method1(); s.method2();</p>
<p>}</p>
<p>public static void main(String[] args) { serviceConsumer(Implementationl.factory);</p>
<p>// Implementations are completely interchangeable: serviceConsumer(Implementation2.factory);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Implementation1 method1 Implementation1 method2 Implementation2 method1 Implementation2 method2 *///:~</p>
<p>Now the constructors for Implementationi and Implementation2 can be private, and</p>
<p>there’s no need to create a named class as the factory. In addition, you often only need a single factory object, and so here it has been created as a static field in the Service implementation. The resulting syntax is more meaningful, as well.</p>
<p>The interfaces/Games.java example can also be improved with anonymous inner classes:</p>
<p>//: innerclasses/Games.java</p>
<p>// Using anonymous inner classes with the Game framework. import static net.mindview.util.Print.*;</p>
<p>interface Game { boolean move(); } interface GameFactory { Game getGame(); }</p>
<p>class Checkers implements Game { private Checkers() {} private int moves = 0; private static final int MOVES = 3; public boolean move() {</p>
<p>print(&quot;Checkers move &quot; + moves); return ++moves != MOVES;</p>
<p>}</p>
<p>public static GameFactory factory = new GameFactory() { public Game getGame() { return new Checkers(); }</p>
<p>};</p>
<p>}</p>
<p>class Chess implements Game { private Chess() {} private int moves = 0; private static final int MOVES = 4; public boolean move() {</p>
<p>print(&quot;Chess move &quot; + moves); return ++moves != MOVES;</p>
<p>public static GameFactory factory = new GameFactory() { public Game getGame() { return new Chess(); }</p>
<p>};</p>
<p>}</p>
<p>public class Games {</p>
<p>public static void playGame(GameFactory factory) {</p>
<p>Game s = factory.getGame(); while(s.move())</p>
<p>} ’</p>
<p>public static void main(String[] args) { playGame(Checkers.factory); playGame(Chess.factory);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Checkers move 0 Checkers move 1 Checkers move 2 Chess move 0 Chess move 1 Chess move 2 Chess move 3 *///:~</p>
<p>Remember the advice given at the end of the last chapter: Prefer classes to interfaces. If your design demands an interface, you’ll know it. Otherwise, don’t put it in until you are forced to.</p>
<p>Exercise 16: (1) Modify the solution to Exercise 18 from the Interfaces chapter to use anonymous inner classes.</p>
<p>Exercise 17: (1) Modify the solution to Exercise 19 from the Interfaces chapter to use anonymous inner classes.</p>
</section>
<section>
<title>
<p>Nested classes</p></title><empty-line/>
<p>If you don’t need a connection between the inner-class object and the outerclass object, then you can make the inner class static. This is commonly called a nested class.<sup>2</sup> To understand the meaning of static when applied to inner classes, you must remember that the object of an ordinary inner class implicitly keeps a reference to the object of the enclosing class that created it. This is not true, however, when you say an inner class is static. A nested class means:</p>
<p>1.    You don’t need an outer-class object in order to create an object of a nested class.</p>
<p>2.    You can’t access a non-static outer-class object from an object of a nested class.</p>
<p>Nested classes are different from ordinary inner classes in another way, as well. Fields and methods in ordinary inner classes can only be at the outer level of a class, so ordinary inner classes cannot have static data, static fields, or nested classes. However, nested classes can have all of these:</p>
<p>//: innerclasses/Parcelll.java</p>
<p>// Nested classes (static inner classes).</p>
<p>Roughly similar to nested classes in C++, except that those classes cannot access private members as they can in Java.</p>
<p>public class Parcelii {</p>
<p>private static class ParcelContents implements Contents { private int i = ii; public int value() { return i; }</p>
<p>}</p>
<p>protected static class ParcelDestination implements Destination { private String label;</p>
<p>private ParcelDestination(String whereTo) { label = whereTo;</p>
<p>}</p>
<p>public String readLabel() { return label; }</p>
<p>// Nested classes can contain other static elements: public static void f() {} static int x = 10; static class AnotherLevel { public static void f() {} static int x = 10;</p>
<p>}</p>
<p>}</p>
<p>public static Destination destination(String s) { return new ParcelDestination(s);</p>
<p>}</p>
<p>public static Contents contents() { return new ParcelContents();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Contents c = contents();</p>
<p>Destination d = destination(&quot;Tasmania&quot;);</p>
<p>}</p>
<p>} ///:~</p>
<p>In main( ), no object of Parceln is necessary; instead, you use the normal syntax for selecting a static member to call the methods that return references to Contents and Destination.</p>
<p>As you’ve seen earlier in this chapter, in an ordinary (non-static) inner class, the link to the outer-class object is achieved with a special this reference. A nested class does not have a special this reference, which makes it analogous to a static method.</p>
<p>Exercise 18: (1) Create a class containing a nested class. In main( ), create an instance of the nested class.</p>
<p>Exercise 19: (2) Create a class containing an inner class that itself contains an inner class. Repeat this using nested classes. Note the names of the .class files produced by the compiler.</p>
<subtitle>Classes inside interfaces</subtitle>
<p>Normally, you can’t put any code inside an interface, but a nested class can be part of an interface. Any class you put inside an interface is automatically public and static. Since the class is static, it doesn’t violate the rules for interfaces—the nested class is only placed inside the namespace of the interface. You can even implement the surrounding interface in the inner class, like this:</p>
<p>//: innerclasses/Classlnlnterface.java // {main: ClassInInterface$Test}</p>
<p>public interface ClassInInterface { void howdy();</p>
<p>class Test implements ClassInInterface { public void howdy() {</p>
<p>System.out.println(&quot;Howdy!&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { new Test().howdy();</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Howdy!</p>
<p>*///:~</p>
<p>It’s convenient to nest a class inside an interface when you want to create some common code to be used with all different implementations of that interface.</p>
<p>Earlier in this book I suggested putting a main( ) in every class to act as a test bed for that class. One drawback to this is the amount of extra compiled code you must carry around. If this is a problem, you can use a nested class to hold your test code:</p>
<p>//: innerclasses/TestBed.java // Putting test code in a nested class.</p>
<p>// {main: TestBed$Tester}</p>
<p>public class TestBed {</p>
<p>public void f() { System.out.println(&quot;f()&quot;); } public static class Tester {</p>
<p>public static void main(String[] args) { TestBed t = new TestBed(); t.f();</p>
<p>}</p>
<p>}</p>
<p>} /* Output: f()</p>
<p>*///:~</p>
<p>This generates a separate class called TestBed$Tester (to run the program, you say Java TestBed$Tester, but you must escape the ‘$’ under Unix/Linux systems). You can use this class for testing, but you don’t need to include it in your shipping product; you can simply delete TestBed$Tester.class before packaging things up.</p>
<p>Exercise 20: (1) Create an interface containing a nested class. Implement this interface and create an instance of the nested class.</p>
<p>Exercise 21: (2) Create an interface that contains a nested class that has a static method that calls the methods of your interface and displays the results. Implement your interface and pass an instance of your implementation to the method.</p>
<subtitle>Reaching outward from a multiply nested class</subtitle>
<p>It doesn’t matter how deeply an inner class may be nested—it can transparently access all of the members of all the classes it is nested within, as seen here:<a l:href="#bookmark35" type="note"><sup>36</sup></a><sup></sup></p>
<p>//: innerclasses/MultiNestingAccess.java // Nested classes can access all members of all // levels of the classes they are nested within.</p>
<p>class MNA {</p>
<p>private void f() {} class A {</p>
<p>private void g() {} public class B { void h() { g(); f();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class MultiNestingAccess {</p>
<p>public static void main(String[] args) {</p>
<p>MNA mna = new MNA();</p>
<p>MNA.A mnaa = mna.new A();</p>
<p>MNA.A.B mnaab = mnaa.new B(); mnaab.h();</p>
<p>}</p>
<p>} ///:~</p>
<p>You can see that in MNAAB, the methods g( ) and f( ) are callable without any qualification (despite the fact that they are private). This example also demonstrates the syntax necessary to create objects of multiply nested inner classes when you create the objects in a different class. The &quot;.new&quot; syntax produces the correct scope, so you do not have to qualify the class name in the constructor call.</p>
</section>
<section>
<title>
<p>Why inner classes?</p></title><empty-line/>
<p>At this point you’ve seen a lot of syntax and semantics describing the way inner classes work, but this doesn’t answer the question of why they exist. Why did the Java designers go to so much trouble to add this fundamental language feature?</p>
<p>Typically, the inner class inherits from a class or implements an interface, and the code in the inner class manipulates the outer-class object that it was created within. So you could say that an inner class provides a kind of window into the outer class.</p>
<p>A question that cuts to the heart of inner classes is this: If I just need a reference to an interface, why don’t I just make the outer class implement that interface? The answer is &quot;If that’s all you need, then that’s how you should do it.&quot; So what is it that distinguishes an inner class implementing an interface from an outer class implementing the same interface? The answer is that you can’t always have the convenience of interfaces—sometimes you’re working with implementations. So the most compelling reason for inner classes is:</p>
<p>Each inner class can independently inherit from an implementation. Thus, the inner class is not limited by whether the outer class is already inheriting from an implementation.</p>
<p>Without the ability that inner classes provide to inherit—in effect—from more than one concrete or abstract class, some design and programming problems would be intractable.</p>
<p>So one way to look at the inner class is as the rest of the solution of the multiple-inheritance problem. Interfaces solve part of the problem, but inner classes effectively allow &quot;multiple implementation inheritance.&quot; That is, inner classes effectively allow you to inherit from more than one non-interface.</p>
<p>To see this in more detail, consider a situation in which you have two interfaces that must somehow be implemented within a class. Because of the flexibility of interfaces, you have two choices: a single class or an inner class.</p>
<p>//: innerclasses/Multilnterfaces.java</p>
<p>// Two ways that a class can implement multiple interfaces. package innerclasses;</p>
<p>interface A {} interface B {}</p>
<p>class X implements A, B {}</p>
<p>class Y implements A {</p>
<p>B makeB() {</p>
<p>// Anonymous inner class: return new B() {};</p>
<p>}</p>
<p>}</p>
<p>public class Multiinterfaces { static void takesA(A a) {} static void takesB(B b) {} public static void main(String[] args) {</p>
<p>X x = new X();</p>
<p>Y y = new Y();</p>
<p>takesA(x);</p>
<p>takesA(y);</p>
<p>takesB(x);</p>
<p>takesB(y.makeB());</p>
<p>}</p>
<p>} ///:~</p>
<p>Of course, this assumes that the structure of your code makes logical sense either way. However, you’ll ordinarily have some kind of guidance from the nature of the problem about whether to use a single class or an inner class. But without any other constraints, the approach in the preceding example doesn’t really make much difference from an implementation standpoint. Both of them work.</p>
<p>However, if you have abstract or concrete classes instead of interfaces, you are suddenly limited to using inner classes if your class must somehow implement both of the others:</p>
<p>//: innerclasses/Multilmplementation.java // With concrete or abstract classes, inner // classes are the only way to produce the effect // of &quot;multiple implementation inheritance.&quot; package innerclasses;</p>
<p>class D {} abstract class E {} class Z extends D {</p>
<p>E makeE() { return new E() {}; }</p>
<p>}</p>
<p>args)</p>
<p>{</p>
<p>public class Multiimplementation { static void takesD(D d) {} static void takesE(E e) {} public static void main(String[] Z z = new Z(); takesD(z); takesE(z.makeE());</p>
<p>}</p>
<p>} ///:~</p>
<p>If you didn’t need to solve the &quot;multiple implementation inheritance&quot; problem, you could conceivably code around everything else without the need for inner classes. But with inner classes you have these additional features:</p>
<p>1.    The inner class can have multiple instances, each with its own state information that is independent of the information in the outer-class object.</p>
<p>2.    In a single outer class you can have several inner classes, each of which implements the same interface or inherits from the same class in a different way. An example of this will be shown shortly.</p>
<p>3.    The point of creation of the inner-class object is not tied to the creation of the outer-class object.</p>
<p>4.    There is no potentially confusing &quot;is-a&quot; relationship with the inner class; it’s a separate entity.</p>
<p>As an example, if Sequence.java did not use inner classes, you’d have to say, &quot;A Sequence is a Selector,&quot; and you’d only be able to have one Selector in existence for a particular Sequence. You can easily have a second method, reverseSelector( ), that produces a Selector that moves backward through the sequence. This kind of flexibility is only available with inner classes.</p>
<p>Exercise 22: (2) Implement reverseSelector( ) in Sequence.java.</p>
<p>Exercise 23: (4) Create an interface U with three methods. Create a class A with a method that produces a reference to a U by building an anonymous inner class. Create a second class B that contains an array of U. B should have one method that accepts and stores a reference to a U in the array, a second method that sets a reference in the array (specified by the method argument) to null, and a third method that moves through the array and calls the methods in U. In main( ), create a group of A objects and a single B. Fill the B with U references produced by the A objects. Use the B to call back into all the A objects. Remove some of the U references from the B.</p>
<subtitle>Closures &amp; callbacks</subtitle>
<p>A closure is a callable object that retains information from the scope in which it was created. From this definition, you can see that an inner class is an object-oriented closure, because it doesn’t just contain each piece of information from the outer-class object (&quot;the scope in which it was created&quot;), but it automatically holds a reference back to the whole outer-class object, where it has permission to manipulate all the members, even private ones.</p>
<p>One of the most compelling arguments made to include some kind of pointer mechanism in Java was to allow callbacks. With a callback, some other object is given a piece of information that allows it to call back into the originating object at some later point. This is a very powerful concept, as you will see later in the book. If a callback is implemented using a pointer, however, you must rely on the programmer to behave properly and not misuse the pointer. As you’ve seen by now, Java tends to be more careful than that, so pointers were not included in the language.</p>
<p>The closure provided by the inner class is a good solution-more flexible and far safer than a pointer. Here’s an example:</p>
<p>//: innerclasses/Callbacks.java // Using inner classes for callbacks package innerclasses;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>interface Incrementable { void increment();</p>
<p>}</p>
<p>// Very simple to just implement the interface: class Calleel implements Incrementable { private int i = 0; public void increment() { i++;</p>
<p>print(i);</p>
<p>}</p>
<p>}</p>
<p>class MyIncrement {</p>
<p>public void increment() { print(&quot;Other operation&quot;); } static void f(MyIncrement mi) { mi.increment(); }</p>
<p>}</p>
<p>// If your class must implement increment() in // some other way, you must use an inner class: class Callee2 extends MyIncrement { private int i = 0; public void increment() { super.increment(); i++;</p>
<p>print(i);</p>
<p>}</p>
<p>private class Closure implements Incrementable { public void increment() {</p>
<p>// Specify outer-class method, otherwise // you’d get an infinite recursion:</p>
<p>Callee2.this.increment();</p>
<p>}</p>
<p>}</p>
<p>Incrementable getCallbackReference() { return new Closure();</p>
<p>}</p>
<p>}</p>
<p>class Caller {</p>
<p>private Incrementable callbackReference;</p>
<p>Caller(Incrementable cbh) { callbackReference = cbh; } void go() { callbackReference.increment(); }</p>
<p>}</p>
<p>public class Callbacks {</p>
<p>public static void main(String[] Callee1 c1 = new Callee1(); Callee2 c2 = new Callee2(); MyIncrement.f(c2);</p>
<p>args) {</p>
<p>Caller caller1</p>
<p>Caller caller2</p>
<p>caller1.go();</p>
<p>caller1.go();</p>
<p>caller2.go();</p>
<p>caller2.go();</p>
<p>new Caller(c1);</p>
<p>new Caller(c2.getCallbackReference())</p>
<p>}</p>
<p>} /* Output: Other operation 1 1 2</p>
<p>Other operation 2</p>
<p>Other operation 3</p>
<p>*///:~</p>
<p>This also shows a further distinction between implementing an interface in an outer class versus doing so in an inner class. Callee1 is clearly the simpler solution in terms of the code. Callee2 inherits from Mylncrement, which already has a different increment( ) method that does something unrelated to the one expected by the Incrementable interface. When Mylncrement is inherited into Callee2, increment( ) can’t be overridden for use by Incrementable, so you’re forced to provide a separate implementation using an inner class. Also note that when you create an inner class, you do not add to or modify the interface of the outer class.</p>
<p>Everything except getCallbackReference( ) in Callee2 is private. To allow any connection to the outside world, the interface Incrementable is essential. Here you can see how interfaces allow for a complete separation of interface from implementation.</p>
<p>The inner class Closure implements Incrementable to provide a hook back into Callee2— but a safe hook. Whoever gets the Incrementable reference can, of course, only call increment( ) and has no other abilities (unlike a pointer, which would allow you to run wild).</p>
<p>Caller takes an Incrementable reference in its constructor (although the capturing of the callback reference could happen at any time) and then, sometime later, uses the reference to &quot;call back&quot; into the Callee class.</p>
<p>The value of the callback is in its flexibility; you can dynamically decide what methods will be called at run time. The benefit of this will become more evident in the Graphical User Interfaces chapter, where callbacks are used everywhere to implement GUI functionality.</p>
<subtitle>Inner classes &amp; control frameworks</subtitle>
<p>A more concrete example of the use of inner classes can be found in something that I will refer to here as a control framework.</p>
<p>An application framework is a class or a set of classes that’s designed to solve a particular type of problem. To apply an application framework, you typically inherit from one or more classes and override some of the methods. The code that you write in the overridden methods customizes the general solution provided by that application framework in order to solve your specific problem. This is an example of the Template Method design pattern (see</p>
<p>Thinking in Patterns (with Java) at <a l:href="http://www.MindView.net">www.MindView.net</a>). The Template Method contains the basic structure of the algorithm, and it calls one or more overrideable methods to complete the action of that algorithm. A design pattern separates things that change from things that stay the same, and in this case the Template Method is the part that stays the same, and the overrideable methods are the things that change.</p>
<p>A control framework is a particular type of application framework dominated by the need to respond to events. A system that primarily responds to events is called an event-driven system. A common problem in application programming is the graphical user interface (GUI), which is almost entirely event-driven. As you will see in the Graphical User Interfaces chapter, the Java Swing library is a control framework that elegantly solves the GUI problem and that heavily uses inner classes.</p>
<p>To see how inner classes allow the simple creation and use of control frameworks, consider a control framework whose job is to execute events whenever those events are &quot;ready.&quot; Although &quot;ready&quot; could mean anything, in this case it will be based on clock time. What follows is a control framework that contains no specific information about what it’s controlling. That information is supplied during inheritance, when the action( ) portion of the algorithm is implemented.</p>
<p>First, here is the interface that describes any control event. It’s an abstract class instead of an actual interface because the default behavior is to perform the control based on time.</p>
<p>Thus, some of the implementation is included here:</p>
<p>//: innerclasses/controller/Event.java // The common methods for any control event. package innerclasses.controller;</p>
<p>public abstract class Event { private long eventTime; protected final long delayTime; public Event(long delayTime) { this.delayTime = delayTime; start();</p>
<p>}</p>
<p>public void start() { // Allows restarting eventTime = System.nanoTime() + delayTime;</p>
<p>}</p>
<p>public boolean ready() {</p>
<p>return System.nanoTime() &gt;= eventTime;</p>
<p>}</p>
<p>public abstract void action();</p>
<p>} ///:~</p>
<p>The constructor captures the time (measured from the time of creation of the object) when you want the Event to run, and then calls start( ), which takes the current time and adds the delay time to produce the time when the event will occur. Rather than being included in the constructor, start( ) is a separate method. This way, you can restart the timer after the event has run out, so the Event object can be reused. For example, if you want a repeating event, you can simply call start( ) inside your action( ) method.</p>
<p>ready( ) tells you when it’s time to run the action( ) method. Of course, ready( ) can be overridden in a derived class to base the Event on something other than time.</p>
<p>The following file contains the actual control framework that manages and fires events. The Event objects are held inside a container object of type List&lt;Event&gt; (pronounced &quot;List of Event&quot;), which you’ll learn more about in the Holding Your Objects chapter. For now, all you need to know is that add( ) will append an Event to the end of the List, size( ) produces the number of entries in the List, the foreach syntax fetches successive Events from the List, and remove( ) removes the specified Event from the List.</p>
<p>//: innerclasses/controller/Controller.java // The reusable framework for control systems. package innerclasses.controller; import java.util.*;</p>
<p>public class Controller {</p>
<p>// A class from java.util to hold Event objects: private List&lt;Event&gt; eventList = new ArrayList&lt;Event&gt;(); public void addEvent(Event c) { eventList.add(c); } public void run() {</p>
<p>while(eventList.size() &gt; 0)</p>
<p>// Make a copy so you’re not modifying the list // while you’re selecting the elements in it: for(Event e : new ArrayList&lt;Event&gt;(eventList)) if(e.ready()) {</p>
<p>System.out.println(e);</p>
<p>e.action();</p>
<p>eventList.remove(e);</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>The run( ) method loops through a copy of the eventList, hunting for an Event object that’s ready( ) to run. For each one it finds ready( ), it prints information using the object’s toString( ) method, calls the action( ) method, and then removes the Event from the list.</p>
<p>Note that so far in this design you know nothing about exactly what an Event does. And this is the crux of the design-how it &quot;separates the things that change from the things that stay the same.&quot; Or, to use my term, the &quot;vector of change&quot; is the different actions of the various kinds of Event objects, and you express different actions by creating different Event subclasses.</p>
<p>This is where inner classes come into play. They allow two things:</p>
<p>1.    The entire implementation of a control framework is created in a single class, thereby encapsulating everything that’s unique about that implementation. Inner classes are used to express the many different kinds of action( ) necessary to solve the problem.</p>
<p>2.    Inner classes keep this implementation from becoming awkward, since you’re able to easily access any of the members in the outer class. Without this ability the code might become unpleasant enough that you’d end up seeking an alternative.</p>
<p>Consider a particular implementation of the control framework designed to control greenhouse functions.<a l:href="#bookmark36" type="note"><sup>37</sup></a><sup></sup> Each action is entirely different: turning lights, water, and thermostats on and off, ringing bells, and restarting the system. But the control framework is designed to easily isolate this different code. Inner classes allow you to have multiple derived versions of the same base class, Event, within a single class. For each type of action, you inherit a new Event inner class, and write the control code in the action( ) implementation.</p>
<p>As is typical with an application framework, the class GreenhouseControls is inherited from Controller:</p>
<p>//: innerclasses/GreenhouseControls.java // This produces a specific application of the // control system, all in a single class. Inner // classes allow you to encapsulate different // functionality for each type of event. import innerclasses.controller.*;</p>
<p>public class GreenhouseControls extends Controller {</p>
<p>private boolean light = false;</p>
<p>public class LightOn extends Event {</p>
<p>public LightOn(long delayTime) { super(delayTime); } public void action() {</p>
<p>// Put hardware control code here to // physically turn on the light. light = true;</p>
<p>}</p>
<p>public String toString() { return &quot;Light is on&quot;; }</p>
<p>}</p>
<p>public class LightOff extends Event {</p>
<p>public LightOff(long delayTime) { super(delayTime); } public void action() {</p>
<p>// Put hardware control code here to // physically turn off the light. light = false;</p>
<p>}</p>
<p>public String toString() { return &quot;Light is off&quot;; }</p>
<p>}</p>
<p>private boolean water = false;</p>
<p>public class WaterOn extends Event {</p>
<p>public WaterOn(long delayTime) { super(delayTime); } public void action() {</p>
<p>// Put hardware control code here. water = true;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;Greenhouse water is on&quot;;</p>
<p>}</p>
<p>}</p>
<p>public class WaterOff extends Event {</p>
<p>public WaterOff(long delayTime) { super(delayTime); } public void action() {</p>
<p>// Put hardware control code here. water = false;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;Greenhouse water is off&quot;;</p>
<p>}</p>
<p>}</p>
<p>private String thermostat = &quot;Day&quot;;</p>
<p>public class ThermostatNight extends Event { public ThermostatNight(long delayTime) { super(delayTime);</p>
<p>}</p>
<p>public void action() {</p>
<p>// Put hardware control code here. thermostat = &quot;Night&quot;;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;Thermostat on night setting&quot;;</p>
<p>}</p>
<p>}</p>
<p>public class ThermostatDay extends Event { public ThermostatDay(long delayTime) {</p>
<p>super(delayTime);</p>
<p>public void action() {</p>
<p>// Put hardware control code here. thermostat = &quot;Day&quot;;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;Thermostat on day setting&quot;;</p>
<p>}</p>
<p>}</p>
<p>// An example of an action() that inserts a // new one of itself into the event list: public class Bell extends Event {</p>
<p>public Bell(long delayTime) { super(delayTime); } public void action() {</p>
<p>addEvent(new Bell(delayTime));</p>
<p>}</p>
<p>public String toString() { return &quot;Bing!&quot;; }</p>
<p>}</p>
<p>public class Restart extends Event { private Event[] eventList;</p>
<p>public Restart(long delayTime, Event[] eventList) { super(delayTime); this.eventList = eventList; for(Event e : eventList) addEvent(e);</p>
<p>}</p>
<p>public void action() {</p>
<p>for(Event e : eventList) {</p>
<p>e.start(); // Rerun each event addEvent(e);</p>
<p>}</p>
<p>start(); // Rerun this Event addEvent(this);</p>
<p>}</p>
<p>public String toString() { return &quot;Restarting system&quot;;</p>
<p>}</p>
<p>}</p>
<p>public static class Terminate extends Event {</p>
<p>public Terminate(long delayTime) { super(delayTime); }</p>
<p>public void action() { System.exit(0); }</p>
<p>public String toString() { return &quot;Terminating&quot;; }</p>
<p>}</p>
<p>} ///:~</p>
<p>Note that light, water, and thermostat belong to the outer class GreenhouseControls,</p>
<p>and yet the inner classes can access those fields without qualification or special permission. Also, the action( ) methods usually involve some sort of hardware control.</p>
<p>Most of the Event classes look similar, but Bell and Restart are special. Bell rings and then adds a new Bell object to the event list, so it will ring again later. Notice how inner classes almost look like multiple inheritance: Bell and Restart have all the methods of Event and also appear to have all the methods of the outer class GreenhouseControls.</p>
<p>Restart is given an array of Event objects that it adds to the controller. Since Restart( ) is just another Event object, you can also add a Restart object within Restart.action( ) so that the system regularly restarts itself.</p>
<p>The following class configures the system by creating a GreenhouseControls object and adding various kinds of Event objects. This is an example of the Command design pattern-each object in eventList is a request encapsulated as an object:</p>
<p>//: innerclasses/GreenhouseController.java // Configure and execute the greenhouse system.</p>
<p>// {Args: 5000}</p>
<p>import innerclasses.controller.*;</p>
<p>public class GreenhouseController {</p>
<p>public static void main(String[] args) {</p>
<p>GreenhouseControls gc = new GreenhouseControls();</p>
<p>// Instead of hard-wiring, you could parse // configuration information from a text file here: gc.addEvent(gc.new Bell(900));</p>
<p>Event[] eventList = {</p>
<p>gc.new ThermostatNight(0), gc.new LightOn(200), gc.new LightOff(400), gc.new WaterOn(600), gc.new WaterOff(800), gc.new ThermostatDay(1400)</p>
<p>};</p>
<p>gc.addEvent(gc.new Restart(2000, eventList)); if(args.length == 1) gc.addEvent(</p>
<p>new GreenhouseControls.Terminate( new Integer(args[0]))); gc.run();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Bing!</p>
<p>Thermostat on night setting Light is on Light is off Greenhouse water is on Greenhouse water is off Thermostat on day setting Restarting system Terminating *///:~</p>
<p>This class initializes the system, so it adds all the appropriate events. The Restart event is repeatedly run, and it loads the eventList into the GreenhouseControls object each time. If you provide a command-line argument indicating milliseconds, it will terminate the program after that many milliseconds (this is used for testing).</p>
<p>Of course, it’s more flexible to read the events from a file instead of hardcoding them. An exercise in the I/O chapter asks you to modify this example to do just that.</p>
<p>This example should move you toward an appreciation of the value of inner classes, especially when used within a control framework. However, in the Graphical User Interfaces chapter you’ll see how elegantly inner classes are used to describe the actions of a graphical user interface. By the time you finish that chapter, you should be fully convinced.</p>
<p>Exercise 24: (2) In GreenhouseControls.java, add Event inner classes that turn fans on and off. Configure GreenhouseController.java to use these new Event objects.</p>
<p>Exercise 25: (3) Inherit from GreenhouseControls in GreenhouseControls.java to add Event inner classes that turn water mist generators on and off. Write a new version of GreenhouseController.java to use these new Event objects.</p>
</section>
<section>
<title>
<p>Inheriting from inner classes</p></title><empty-line/>
<p>Because the inner-class constructor must attach to a reference of the enclosing class object, things are slightly complicated when you inherit from an inner class. The problem is that the &quot;secret&quot; reference to the enclosing class object must be initialized, and yet in the derived class there’s no longer a default object to attach to. You must use a special syntax to make the association explicit:</p>
<p>//: innerclasses/Inheritlnner.java // Inheriting an inner class.</p>
<p>class WithInner { class Inner {}</p>
<p>}</p>
<p>public class InheritInner extends WithInner.Inner {</p>
<p>//! InheritInner() {} // Won’t compile InheritInner(WithInner wi) { wi.super();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>WithInner wi = new WithInner();</p>
<p>InheritInner ii = new InheritInner(wi);</p>
<p>}</p>
<p>} ///:~</p>
<p>You can see that InheritInner is extending only the inner class, not the outer one. But when it comes time to create a constructor, the default one is no good, and you can’t just pass a reference to an enclosing object. In addition, you must use the syntax</p>
<p>enclosingClassReference.super();</p>
<p>inside the constructor. This provides the necessary reference, and the program will then compile.</p>
<p>Exercise 26: (2) Create a class with an inner class that has a non-default constructor (one that takes arguments). Create a second class with an inner class that inherits from the first inner class.</p>
</section>
<section>
<title>
<p>Can inner classes be overridden?</p></title><empty-line/>
<p>What happens when you create an inner class, then inherit from the enclosing class and redefine the inner class? That is, is it possible to &quot;override&quot; the entire inner class? This seems like it would be a powerful concept, but &quot;overriding&quot; an inner class as if it were another method of the outer class doesn’t really do anything:</p>
<p>//: innerclasses/BigEgg.java</p>
<p>// An inner class cannot be overriden like a method. import static net.mindview.util.Print.*;</p>
<p>class Egg {</p>
<p>private Yolk y;</p>
<p>protected class Yolk {</p>
<p>public Yolk() { print(&quot;Egg.Yolk()&quot;); }</p>
<p>}</p>
<p>public Egg() {</p>
<p>print(&quot;New Egg()&quot;); y = new Yolk();</p>
<p>}</p>
<p>}</p>
<p>public class BigEgg extends Egg { public class Yolk {</p>
<p>public Yolk() { print(&quot;BigEgg.Yolk()&quot;); }</p>
<p>}</p>
<p>public static void main(String[] args) { new BigEgg();</p>
<p>}</p>
<p>} /* Output:</p>
<p>New Egg()</p>
<p>Egg.Yolk()</p>
<p>*///:~</p>
<p>The default constructor is synthesized automatically by the compiler, and this calls the base-class default constructor. You might think that since a BigEgg is being created, the &quot;overridden&quot; version of Yolk would be used, but this is not the case, as you can see from the output.</p>
<p>This example shows that there isn’t any extra inner-class magic going on when you inherit from the outer class. The two inner classes are completely separate entities, each in its own namespace. However, it’s still possible to explicitly inherit from the inner class:</p>
<p>//: innerclasses/BigEgg2.java</p>
<p>// Proper inheritance of an inner class.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Egg2 {</p>
<p>protected class Yolk {</p>
<p>public Yolk() { print(&quot;Egg2.Yolk()&quot;); } public void f() { print(&quot;Egg2.Yolk.f()&quot;);}</p>
<p>}</p>
<p>private Yolk y = new Yolk(); public Egg2() { print(&quot;New Egg2()&quot;); } public void insertYolk(Yolk yy) { y = yy; } public void g() { y.f(); }</p>
<p>}</p>
<p>public class BigEgg2 extends Egg2 { public class Yolk extends Egg2.Yolk {</p>
<p>public Yolk() { print(&quot;BigEgg2.Yolk()&quot;); } public void f() { print(&quot;BigEgg2.Yolk.f()&quot;); }</p>
<p>}</p>
<p>public BigEgg2() { insertYolk(new Yolk()); } public static void main(String[] args) {</p>
<p>Egg2 e2 = new BigEgg2(); e2.g();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Egg2.Yolk()</p>
<p>New Egg2()</p>
<p>Egg2.Yolk()</p>
<p>BigEgg2.Yolk()</p>
<p>BigEgg2.Yolk.f()</p>
<p>*///:~</p>
<p>Now BigEgg2.Yolk explicitly extends Egg2.Yolk and overrides its methods. The method insertYolk( ) allows BigEgg2 to upcast one of its own Yolk objects into the y reference in Egg2, so when g( ) calls y.f( ), the overridden version of f( ) is used. The second call to Egg2.Yolk( ) is the base-class constructor call of the BigEgg2.Yolk constructor. You can see that the overridden version of f( ) is used when g( ) is called.</p>
</section>
<section>
<title>
<p>Local inner classes</p></title><empty-line/>
<p>As noted earlier, inner classes can also be created inside code blocks, typically inside the body of a method. A local inner class cannot have an access specifier because it isn’t part of the outer class, but it does have access to the final variables in the current code block and all the members of the enclosing class. Here’s an example comparing the creation of a local inner class with an anonymous inner class:</p>
<p>//: innerclasses/LocallnnerClass.java // Holds a sequence of Objects. import static net.mindview.util.Print.*;</p>
<p>interface Counter { int next();</p>
<p>}</p>
<p>public class LocalInnerClass { private int count = 0;</p>
<p>Counter getCounter(final String name) {</p>
<p>// A local inner class: class LocalCounter implements Counter { public LocalCounter() {</p>
<p>// Local inner class can have a constructor print(&quot;LocalCounter()&quot;);</p>
<p>}</p>
<p>public int next() {</p>
<p>printnb(name); // Access local final return count++;</p>
<p>}</p>
<p>}</p>
<p>return new LocalCounter();</p>
<p>}</p>
<p>// The same thing with an anonymous inner class:</p>
<p>Counter getCounter2(final String name) { return new Counter() {</p>
<p>// Anonymous inner class cannot have a named // constructor, only an instance initializer:</p>
<p>{</p>
<p>print(&quot;Counter()&quot;);</p>
<p>}</p>
<p>public int next() {</p>
<p>printnb(name); // Access local final return count++;</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>LocalInnerClass lic = new LocalInnerClass();</p>
<p>Counter</p>
<p>cl = lic.getCounter(&quot;Local inner &quot;), c2 = lic.getCounter2(&quot;Anonymous inner &quot;); for(int i = 0; i &lt; 5; i++) print(c1.next()); for(int i = 0; i &lt; 5; i++)</p>
<p>print(c2.next());</p>
<p>} /* Output: LocalCounter()</p>
<p>Counter()</p>
<p>Local inner 0 Local inner 1 Local inner 2 Local inner 3 Local inner 4 Anonymous inner 5 Anonymous inner 6 Anonymous inner 7 Anonymous inner 8 Anonymous inner 9 *///:~</p>
<p>Counter returns the next value in a sequence. It is implemented as both a local class and an anonymous inner class, both of which have the same behaviors and capabilities. Since the name of the local inner class is not accessible outside the method, the only justification for using a local inner class instead of an anonymous inner class is if you need a named constructor and/or an overloaded constructor, since an anonymous inner class can only use instance initialization.</p>
<p>Another reason to make a local inner class rather than an anonymous inner class is if you need to make more than one object of that class.</p>
</section>
<section>
<title>
<p>Inner-class identifiers</p></title><empty-line/>
<p>Since every class produces a .class file that holds all the information about how to create objects of this type (this information produces a &quot;meta-class&quot; called the Class object), you might guess that inner classes must also produce .class files to contain the information for their Class objects. The names of these files/classes have a strict formula: the name of the enclosing class, followed by a ‘$’, followed by the name of the inner class. For example, the .class files created by LocalInnerClass.java include:</p>
<p>Counter.class</p>
<p>LocalInnerClass$l.class</p>
<p>LocallnnerClassSlLocalCounter.class</p>
<p>LocallnnerClass.class</p>
<p>If inner classes are anonymous, the compiler simply starts generating numbers as inner-class identifiers. If inner classes are nested within inner classes, their names are simply appended after a ‘$’ and the outer-class identifier (s).</p>
<p>Although this scheme of generating internal names is simple and straightforward, it’s also robust and handles most situations.<a l:href="#bookmark37" type="note"><sup>38</sup></a><sup></sup> Since it is the standard naming scheme for Java, the generated files are automatically platform-independent. (Note that the Java compiler is changing your inner classes in all sorts of other ways in order to make them work.)</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>Interfaces and inner classes are more sophisticated concepts than what you’ll find in many OOP languages; for example, there’s nothing like them in C++. Together, they solve the same problem that C++ attempts to solve with its multiple inheritance (MI) feature. However, MI in C++ turns out to be rather difficult to use, whereas Java interfaces and inner classes are, by comparison, much more accessible.</p>
<p>Although the features themselves are reasonably straightforward, the use of these features is a design issue, much the same as polymorphism. Over time, you’ll become better at recognizing situations where you should use an interface, or an inner class, or both. But at this point in this book, you should at least be comfortable with the syntax and semantics. As you see these language features in use, you’ll eventually internalize them.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Holding Your Objects</p></title><empty-line/>
<p>It’s a fairly simple program that only has a fixed quantity of objects with known lifetimes.</p>
<p>In general, your programs will always be creating new objects based on some criteria that will be known only at run time. Before then, you won’t know the quantity or even the exact type of the objects you need. To solve the general programming problem, you need to create any number of objects, anytime, anywhere. So you can’t rely on creating a named reference to hold each one of your objects:</p>
<p>MyType aReference;</p>
<p>since you’ll never know how many of these you’ll actually need.</p>
<p>Most languages provide some way to solve this essential problem. Java has several ways to hold objects (or rather, references to objects). The compiler-supported type is the array, which has been discussed before. An array is the most efficient way to hold a group of objects, and you’re pointed towards this choice if you want to hold a group of primitives. But an array has a fixed size, and in the more general case, you won’t know at the time you’re writing the program how many objects you’re going to need, or whether you need a more sophisticated way to store your objects—so the fixed-sized constraint of an array is too limiting.</p>
<p>The java.util library has a reasonably complete set of container classes to solve this problem, the basic types of which are List, Set, Queue, and Map. These types of objects are also known as collection classes, but because the Java library uses the name Collection to refer to a particular subset of the library, I shall use the more inclusive term &quot;container.&quot; Containers provide sophisticated ways to hold your objects, and you can solve a surprising number of problems by using these tools.</p>
<p>Among their other characteristics—Set, for example, holds only one object of each value, and Map is an associative array that lets you associate objects with other objects—the Java container classes will automatically resize themselves. So, unlike with arrays, you can put in any number of objects and you don’t need to worry about how big to make the container while you’re writing the program.</p>
<p>Even though they don’t have direct keyword support in Java,՝ container classes are fundamental tools that significantly increase your programming muscle. In this chapter you’ll get a basic working knowledge of the Java container library, with an emphasis on typical usage. Here, we’ll focus on the containers that you’ll use in day-to-day programming. Later, in the Containers in Depth chapter, you’ll learn about the rest of the containers and more details about their functionality and how to use them. <a l:href="#bookmark38" type="note"><sup>39</sup></a><sup></sup></p>
<section>
<title>
<p>Generics and type-safe containers</p></title><empty-line/>
<p>One of the problems of using pre-Java SE5 containers was that the compiler allowed you to insert an incorrect type into a container. For example, consider a container of Apple objects, using the basic workhorse container, ArrayList. For now, you can think of ArrayList as &quot;an array that automatically expands itself.&quot; Using an ArrayList is straightforward: Create one, insert objects using add( ), and access them with get( ), using an index-just as you do with an array, but without the square brackets.<sup>2</sup> ArrayList also has a method size( ) to let you know how many elements have been added, so that you don’t inadvertently index off the end and cause an error (by throwing a runtime exception; exceptions will be introduced in the chapter Error Handling with Exceptions).</p>
<p>In this example, Apples and Oranges are placed into the container, then pulled out. Normally, the Java compiler will give you a warning because the example does not use generics. Here, a special Java SE5 annotation is used to suppress the warning. Annotations start with an ‘@’ sign, and can take an argument; this one is @SuppressWarnings and the argument indicates that &quot;unchecked&quot; warnings only should be suppressed:</p>
<p>//: holding/ApplesAndOrangesWithoutGenerics.java // Simple container example (produces compiler warnings).</p>
<p>// {ThrowsException} import java.util.*;</p>
<p>class Apple {</p>
<p>private static long counter; private final long id = counter++; public long id() { return id; }</p>
<p>}</p>
<p>class Orange {}</p>
<p>public class ApplesAndOrangesWithoutGenerics { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) {</p>
<p>ArrayList apples = new ArrayList(); for(int i = 0; i &lt; 3; i++) apples.add(new Apple());</p>
<p>// Not prevented from adding an Orange to apples:</p>
<p>apples.add(new Orange());</p>
<p>for(int i = 0; i &lt; apples.size(); i++)</p>
<p>((Apple)apples.get(i)).id();</p>
<p>// Orange is detected only at run time</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>You’ll learn more about Java SE5 annotations in the Annotations chapter.</p>
<p>The classes Apple and Orange are distinct; they have nothing in common except that they are both Objects. (Remember that if you don’t explicitly say what class you’re inheriting from, you automatically inherit from Object.) Since ArrayList holds Objects, you can not only add Apple objects into this container using the ArrayList method add( ), but you can also add Orange objects without complaint at either compile time or run time. When you go to fetch out what you think are Apple objects using the ArrayList method get( ), you get back a reference to an Object that you must cast to an Apple. Then you need to surround the entire expression with parentheses to force the evaluation of the cast before calling the id( ) method for Apple; otherwise, you’ll get a syntax error. At run time, when you try to cast the Orange object to an Apple, you’ll get an error in the form of the aforementioned exception. In the Generics chapter, you’ll learn that creating classes using Java generics can be complex. However, applying predefined generic classes is usually straightforward. For example, to define an ArrayList intended to hold Apple objects, you say ArrayList&lt;Apple&gt; instead of just ArrayList. The angle brackets surround the type parameters (there may be more than one), which specify the type(s) that can be held by that instance of the container. With generics, you’re prevented, at compile time, from putting the wrong type of object into a container.<a l:href="#bookmark39" type="note"><sup>40</sup></a><sup></sup> Here’s the example again, using generics:</p>
<p>//: holding/ApplesAndOrangesWithGenerics.java import java.util.*;</p>
<p>public class ApplesAndOrangesWithGenerics { public static void main(String[] args) {</p>
<p>ArrayList&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;(); for(int i = 0; i &lt; 3; i++) apples.add(new Apple());</p>
<p>// Compile-time error:</p>
<p>// apples.add(new Orange()); for(int i = 0; i &lt; apples.size(); i++) System.out.println(apples.get(i).id());</p>
<p>// Using foreach: for(Apple c : apples)</p>
<p>System.out.println(c.id());</p>
<p>}</p>
<p>} /* Output:</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>*///:~</p>
<p>Now the compiler will prevent you from putting an Orange into apples, so it becomes a compile-time error rather than a runtime error. Also notice that the cast is no longer necessary when fetching items back out from the List. Since the List knows what type it holds, it does the cast for you when you call get( ). Thus, with generics you not only know that the compiler will check the type of object that you put into a container, but you also get cleaner syntax when using the objects in the container. The example also shows that, if you do not need to use the index of each element, you can use the foreach syntax to select each element in the List. You are not limited to putting the exact type of object into a container when you specify that type as a generic parameter. Upcasting works the same with generics as it does with other types:</p>
<p>//: holding/GenericsAndUpcasting.java import java.util.*;</p>
<p>class GrannySmith extends Apple {} class Gala extends Apple {} class Fuji extends Apple {} class Braeburn extends Apple {}</p>
<p>public class GenericsAndUpcasting {</p>
<p>public static void main(String[] args) {</p>
<p>ArrayList&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;(); apples.add(new GrannySmithQ);</p>
<p>apples.add(new Gala()); apples.add(new Fuji()); apples.add(new Braeburn()); for(Apple c : apples) System.out.println(c);</p>
<p>}</p>
<p>} /* Output: (Sample) GrannySmith@7d772e Gala@11b86e7 Fuji@35ce36 Braeburn@757aef *///:~</p>
<p>Thus, you can add a subtype of Apple to a container that is specified to hold Apple objects.</p>
<p>The output is produced from the default toString( ) method of Object, which prints the class name followed by the unsigned hexadecimal representation of the hash code of the object (generated by the hashCode( ) method). You’ll learn about hash codes in detail in Containers in Depth.</p>
<p>Exercise 1: (2) Create a new class called Gerbil with an int gerbilNumber that’s initialized in the constructor. Give it a method called hop( ) that displays which gerbil number this is, and that it’s hopping. Create an ArrayList and add Gerbil objects to the List. Now use the get( ) method to move through the List and call hop( ) for each Gerbil.</p>
</section>
<section>
<title>
<p>Basic concepts</p></title><empty-line/>
<p>The Java container library takes the idea of &quot;holding your objects&quot; and divides it into two distinct concepts, expressed as the basic interfaces of the library:</p>
<p>1.    Collection: a sequence of individual elements with one or more rules applied to them. A List must hold the elements in the way that they were inserted, a Set cannot have duplicate elements, and a Queue produces the elements in the order determined by a queuing discipline (usually the same order in which they are inserted).</p>
<p>2.    Map: a group of key-value object pairs, allowing you to look up a value using a key. An ArrayList allows you to look up an object using a number, so in a sense it associates numbers to objects. A map allows you to look up an object using another object. It’s also called an associative array, because it associates objects with other objects, or a dictionary, because you look up a value object using a key object just like you look up a definition using a word. Maps are powerful programming tools.</p>
<p>Although it’s not always possible, ideally you’ll write most of your code to talk to these interfaces, and the only place where you’ll specify the precise type you’re using is at the point of creation. So you can create a List like this:</p>
<p>List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;();</p>
<p>Notice that the ArrayList has been upcast to a List, in contrast to the way it was handled in the previous examples. The intent of using the interface is that if you decide you want to change your implementation, all you need to do is change it at the point of creation, like this:</p>
<p>List&lt;Apple&gt; apples = new LinkedList&lt;Apple&gt;();</p>
<p>Thus, you’ll typically make an object of a concrete class, upcast it to the corresponding interface, and then use the interface throughout the rest of your code.</p>
<p>This approach won’t always work, because some classes have additional functionality. For example, LinkedList has additional methods that are not in the List interface, and a TreeMap has methods that are not in the Map interface. If you need to use those methods, you won’t be able to upcast to the more general interface.</p>
<p>The Collection interface generalizes the idea of a sequence—a way of holding a group of objects. Here’s a simple example that fills a Collection (represented here with an ArrayList) with Integer objects and then prints each element in the resulting container:</p>
<p>//: holding/SimpleCollection.java import java.util.*;</p>
<p>public class SimpleCollection {</p>
<p>public static void main(String[] args) {</p>
<p>Collection&lt;Integer&gt; c = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; 10; i++) c.add(i); // Autoboxing for(Integer i : c)</p>
<p>System.out.print(i + &quot;, &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9,</p>
<p>*///:~</p>
<p>Since this example only uses Collection methods, any object of a class inherited from Collection would work, but ArrayList is the most basic type of sequence.</p>
<p>The name of the add( ) method suggests that it puts a new element in the Collection. However, the documentation carefully states that add( ) &quot;ensures that this Collection contains the specified element.&quot; This is to allow for the meaning of Set, which adds the element only if it isn’t already there. With an ArrayList, or any sort of List, add( ) always means &quot;put it in,&quot; because Lists don’t care if there are duplicates.</p>
<p>All Collections can be traversed using the foreach syntax, as shown here. Later in this chapter you’ll learn about a more flexible concept called an Iterator.</p>
<p>Exercise 2: (1) Modify SimpleCollection.java to use a Set for c.</p>
<p>Exercise 3: (2) Modify innerclasses/Sequence.java so that you can add any number of elements to it.</p>
</section>
<section>
<title>
<p>Adding groups of elements</p></title><empty-line/>
<p>There are utility methods in both the Arrays and Collections classes in java.util that add groups of elements to a Collection. Arrays.asList( ) takes either an array or a comma-separated list of elements (using varargs) and turns it into a List object. Collections.addAll( ) takes a Collection object and either an array or a comma-separated list and adds the elements to the Collection. Here’s an example that shows both methods, as well as the more conventional addAll( ) method that’s part of all Collection types:</p>
<p>//: holding/AddingGroups.java</p>
<p>// Adding groups of elements to Collection objects. import java.util.*;</p>
<p>public class AddingGroups {</p>
<p>public static void main(String[] args) {</p>
<p>Collection&lt;Integer&gt; collection =</p>
<p>new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3, 4, 5)); Integer[] moreInts = { 6, 7, 8, 9, 10 }; collection.addAH(Arrays.asList(moreInts));</p>
<p>// Runs significantly faster, but you can’t // construct a Collection this way: Collections.addAll(collection, 11, 12, 13, 14, 15); Collections.addAll(collection, moreInts);</p>
<p>// Produces a list &quot;backed by&quot; an array:</p>
<p>List&lt;Integer&gt; list = Arrays.asList(16, 17, 18, 19, 20); list.set(1, 99); // OK -- modify an element // list.add(21); // Runtime error because the</p>
<p>// underlying array cannot be resized.</p>
<p>}</p>
<p>}</p>
<p>///:~</p>
<p>The constructor for a Collection can accept another Collection which it uses for initializing itself, so you can use Arrays.asList( ) to produce input for the constructor. However, Collections.addAll( ) runs much faster, and it’s just as easy to construct the Collection with no elements and then call Collections.addAll( ), so this is the preferred approach.</p>
<p>The Collection.addAll( ) member method can only take an argument of another Collection object, so it is not as flexible as Arrays.asList( ) or Collections.addAll( ),</p>
<p>which use variable argument lists.</p>
<p>It’s also possible to use the output of Arrays.asList( ) directly, as a List, but the underlying representation in this case is the array, which cannot be resized. If you try to add( ) or delete( ) elements in such a list, that would attempt to change the size of an array, so you’ll get an &quot;Unsupported Operation&quot; error at run time.</p>
<p>A limitation of Arrays.asList( ) is that it takes a best guess about the resulting type of the List, and doesn’t pay attention to what you’re assigning it to. Sometimes this can cause a problem:</p>
<p>//: holding/AsListInference.java</p>
<p>// Arrays.asList() makes its best guess about type. import java.util.*;</p>
<p>class Snow {}</p>
<p>class Powder extends Snow {} class Light extends Powder {} class Heavy extends Powder {} class Crusty extends Snow {} class Slush extends Snow {}</p>
<p>public class AsListInference {</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;Snow&gt; snow1 = Arrays.asList(</p>
<p>new Crusty(), new Slush(), new Powder());</p>
<p>// Won’t compile:</p>
<p>// List&lt;Snow&gt; snow2 = Arrays.asList(</p>
<p>// new Light(), new Heavy());</p>
<p>// Compiler says:</p>
<p>// found : java.util.List&lt;Powder&gt;</p>
<p>// required: java.util.List&lt;Snow&gt;</p>
<p>// Collections.addAll() doesn’t get confused:</p>
<p>List&lt;Snow&gt; snow3 = new ArrayList&lt;Snow&gt;();</p>
<p>Collections.addAll(snow3, new Light(), new Heavy());</p>
<p>// Give a hint using an</p>
<p>// explicit type argument specification:</p>
<p>List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList( new Light(), new Heavy());</p>
<p>}</p>
<p>} ///:~</p>
<p>When trying to create snow2, Arrays.asList( ) only has types of Powder, so it creates a List&lt;Powder&gt; rather than a List&lt;Snow&gt;, whereas Collections.addAll( ) works fine because it knows from the first argument what the target type is.</p>
<p>As you can see from the creation of snow4, it’s possible to insert a &quot;hint&quot; in the middle of Arrays.asList( ), to tell the compiler what the actual target type should be for the resulting List type produced by Arrays.asList( ). This is called an explicit type argument specification.</p>
<p>Maps are more complex, as you’ll see, and the Java standard library does not provide any way to automatically initialize them, except from the contents of another Map.</p>
</section>
<section>
<title>
<p>Printing containers</p></title><empty-line/>
<p>You must use Arrays.toString( ) to produce a printable representation of an array, but the containers print nicely without any help. Here’s an example that also introduces you to the basic Java containers:</p>
<p>//: holding/PrintingContainers.java // Containers print themselves automatically. import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class PrintingContainers {</p>
<p>static Collection fill(Collection&lt;String&gt; collection) { collection.add(&quot;rat&quot;); collection.add(&quot;cat&quot;); collection.add(&quot;dog&quot;); collection.add(&quot;dog&quot;); return collection;</p>
<p>}</p>
<p>static Map fill(Map&lt;String,String&gt; map) { map.put(&quot;rat&quot;, &quot;Fuzzy&quot;); map.put(&quot;cat&quot;, &quot;Rags&quot;); map.put(&quot;dog&quot;, &quot;Bosco&quot;); map.put(&quot;dog&quot;, &quot;Spot&quot;); return map;</p>
<p>}</p>
<p>public static void main(String[] args) { print(fill(new ArrayList&lt;String&gt;())); print(fill(new LinkedList&lt;String&gt;())); print(fill(new HashSet&lt;String&gt;())); print(fill(new TreeSet&lt;String&gt;())); print(fill(new LinkedHashSet&lt;String&gt;())); print(fill(new HashMap&lt;String,String&gt;())); print(fill(new TreeMap&lt;String,String&gt;())); print(fill(new LinkedHashMap&lt;String,String&gt;()));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[rat, cat, dog, dog]</p>
<p>[rat, cat, dog, dog]</p>
<p>[dog, cat, rat]</p>
<p>[cat, dog, [rat, cat, {dog=Spot, {cat=Rags, {rat=Fuzzy *///:~</p>
<p>rat]</p>
<p>dog]</p>
<p>cat=Rags,</p>
<p>dog=Spot,</p>
<p>cat=Rags</p>
<p>rat=Fuzzy}</p>
<p>rat=Fuzzy}</p>
<p>dog=Spot}</p>
<p>This shows the two primary categories in the Java container library. The distinction is based on the number of items that are held in each &quot;slot&quot; in the container. The Collection category only holds one item in each slot. It includes the List, which holds a group of items in a specified sequence, the Set, which only allows the addition of one identical item, and the Queue, which only allows you to insert objects at one &quot;end&quot; of the container and remove objects from the other &quot;end&quot; (for the purposes of this example, this is just another way of looking at a sequence and so it is not shown). A Map holds two objects, a key and an associated value, in each slot.</p>
<p>In the output, you can see that the default printing behavior (provided via each container’s toString( ) method) produces reasonably readable results. A Collection is printed surrounded by square brackets, with each element separated by a comma. A Map is surrounded by curly braces, with each key and value associated with an equal sign (keys on the left, values on the right).</p>
<p>The first fill( ) method works with all types of Collection, each of which implements the add( ) method to include new elements.</p>
<p>ArrayList and LinkedList are both types of List, and you can see from the output that they both hold elements in the same order in which they are inserted. The difference between the two is not only performance for certain types of operations, but also that a LinkedList contains more operations than an ArrayList. These will be explored more fully later in this chapter.</p>
<p>HashSet, TreeSet and LinkedHashSet are types of Set. The output shows that a Set will only hold one of each identical item, but it also shows that the different Set implementations store the elements differently. The HashSet stores elements using a rather complex approach that will be explored in the Containers in Depth chapter-all you need to know at this point is that this technique is the fastest way to retrieve elements, and as a result the storage order can seem nonsensical (often, you only care whether something is a member of the Set, not the order in which it appears). If storage order is important, you can use a TreeSet, which keeps the objects in ascending comparison order, or a LinkedHashSet, which keeps the objects in the order in which they were added.</p>
<p>A Map (also called an associative array) allows you to look up an object using a key, like a simple database. The associated object is called a value. If you have a Map that associates states with their capitals and you want to know the capital of Ohio, you look it up using &quot;Ohio&quot; as the key-almost as if you were indexing into an array. Because of this behavior, a Map only accepts one of each key.</p>
<p>Map.put(key, value) adds a value (the thing you want) and associates it with a key (the thing you look it up with). Map.get(key) produces the value associated with that key. The above example only adds key-value pairs, and does not perform lookups. That will be shown later.</p>
<p>Notice that you don’t have to specify (or think about) the size of the Map because it resizes itself automatically. Also, Maps know how to print themselves, showing the association with keys and values. The order that the keys and values are held inside the Map is not the insertion order because the HashMap implementation uses a very fast algorithm that controls the order.</p>
<p>The example uses the three basic flavors of Map: HashMap, TreeMap and LinkedHashMap. Like HashSet, HashMap provides the fastest lookup technique, and also doesn’t hold its elements in any apparent order. A TreeMap keeps the keys sorted by ascending comparison order, and a LinkedHashMap keeps the keys in insertion order while retaining the lookup speed of the HashMap.</p>
<p>Exercise 4: (3) Create a generator class that produces character names (as String objects) from your favorite movie (you can use Snow White or Star Wars as a fallback) each time you call next( ), and loops around to the beginning of the character list when it runs out of names. Use this generator to fill an array, an ArrayList, a LinkedList, a HashSet, a LinkedHashSet, and a TreeSet, then print each container.</p>
</section>
<section>
<title>
<p>List</p></title><empty-line/>
<p>Lists promise to maintain elements in a particular sequence. The List interface adds a number of methods to Collection that allow insertion and removal of elements in the middle of a List.</p>
<p>There are two types of List:</p>
<p>•    The basic ArrayList, which excels at randomly accessing elements, but is slower when inserting and removing elements in the middle of a List.</p>
<p>•    The LinkedList, which provides optimal sequential access, with inexpensive insertions and deletions from the middle of the List. A LinkedList is relatively slow for random access, but it has a larger feature set than the ArrayList.</p>
<p>The following example reaches forward in the book to use a library from the Type Information chapter by importing typeinfo.pets. This is a library that contains a hierarchy of Pet classes along with some tools to randomly generate Pet objects. You don’t need to know the full details at this point, just that (1) there’s a Pet class and various subtypes of Pet and (2) the static Pets.arrayList( ) method will return an ArrayList filled with randomly selected Pet objects:</p>
<p>//: holding/ListFeatures.java import typeinfo.pets.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ListFeatures {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47);</p>
<p>List&lt;Pet&gt; pets = Pets.arrayList(7); print(&quot;1: &quot; + pets);</p>
<p>Hamster h = new Hamster(); pets.add(h); // Automatically resizes print(&quot;2: &quot; + pets); print(&quot;3: &quot; + pets.contains(h)); pets.remove(h); // Remove by object Pet p = pets.get(2);</p>
<p>print(&quot;4: &quot; + p + &quot; &quot; + pets.indexOf(p));</p>
<p>Pet cymric = new Cymric(); print(&quot;5: &quot; + pets.indexOf(cymric)); print(&quot;6: &quot; + pets.remove(cymric));</p>
<p>// Must be the exact object: print(&quot;7: &quot; + pets.remove(p)); print(&quot;8: &quot; + pets);</p>
<p>pets.add(3, new Mouse()); // Insert at an index print(&quot;9: &quot; + pets);</p>
<p>List&lt;Pet&gt; sub = pets.subList(1, 4); print(&quot;subList: &quot; + sub); print(&quot;10: &quot; + pets.containsAH(sub)); Collections.sort(sub); // In-place sort print(&quot;sorted subList: &quot; + sub);</p>
<p>// Order is not important in containsAll(): print(&quot;11: &quot; + pets.containsAll(sub)); Collections.shuffle(sub, rand); // Mix it up print(&quot;shuffled subList: &quot; + sub); print(&quot;12: &quot; + pets.containsAll(sub));</p>
<p>List&lt;Pet&gt; copy = new ArrayList&lt;Pet&gt;(pets); sub = Arrays.asList(pets.get(1), pets.get(4)); print(&quot;sub: &quot; + sub); copy.retainAll(sub); print(&quot;13: &quot; + copy);</p>
<p>copy = new ArrayList&lt;Pet&gt;(pets); // Get a fresh copy copy.remove(2); // Remove by index print(&quot;14: &quot; + copy);</p>
<p>copy.removeAll(sub); // Only removes exact objects print(&quot;15: &quot; + copy);</p>
<p>copy.set(1, new Mouse()); // Replace an element print(&quot;16: &quot; + copy);</p>
<p>copy.addAll(2, sub); // Insert a list in the middle</p>
<p>print(&quot;17: &quot; + copy);</p>
<p>print(&quot;18: &quot; + pets.isEmpty());</p>
<p>pets.clear(); // Remove all elements</p>
<p>print(&quot;19: &quot; + pets);</p>
<p>print(&quot;20: &quot; + pets.isEmpty());</p>
<p>pets.addAll(Pets.arrayList(4));</p>
<p>print(&quot;21: &quot; + pets);</p>
<p>Object[] o = pets.toArray(); print(&quot;22: &quot; + o[3]);</p>
<p>Pet[] pa = pets.toArray(new Pet[0]); print(&quot;23: &quot; + pa[3].id());</p>
<p>}</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20 21 22</p>
<p>} /* Output:</p>
<p>1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug]</p>
<p>2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster]</p>
<p>3: true</p>
<p>4: Cymric 2</p>
<p>5: -1</p>
<p>6: false</p>
<p>7: true</p>
<p>8: [Rat, Manx, Mutt, Pug, Cymric, Pug]</p>
<p>9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug] subList: [Manx, Mutt, Mouse]</p>
<p>10: true</p>
<p>sorted subList: [Manx, Mouse, Mutt]</p>
<p>11: true</p>
<p>shuffled subList: [Mouse, Manx, Mutt]</p>
<p>12: true</p>
<p>sub: [Mouse, Pug]</p>
<p>[Mouse, Pug]</p>
<p>[Rat, Mouse, Mutt, Pug, Cymric, Pug] [Rat, Mutt, Cymric, Pug]</p>
<p>[Rat, Mouse, Cymric, Pug]</p>
<p>[Rat, Mouse, Mouse, Pug, Cymric, Pug] false []</p>
<p>true</p>
<p>[Manx, Cymric, Rat, EgyptianMau] EgyptianMau</p>
<p>The print lines are numbered so the output can be related to the source code. The first output line shows the original List of Pets. Unlike an array, a List allows you to add elements after it has been created, or remove elements, and it resizes itself. That’s its fundamental value: a modifiable sequence. You can see the result of adding a Hamster in output line 2—the object is appended to the end of the list.</p>
<p>You can find out whether an object is in the list using the contains( ) method. If you want to remove an object, you can pass that object’s reference to the remove( ) method. Also, if you have a reference to an object, you can discover the index number where that object is located in the List using indexOf( ), as you can see in output line 4.</p>
<p>When deciding whether an element is part of a List, discovering the index of an element, and removing an element from a List by reference, the equals( ) method (part of the root class Object) is used. Each Pet is defined to be a unique object, so even though there are two Cymrics in the list, if I create a new Cymric object and pass it to indexOf( ), the result will be -1 (indicating it wasn’t found), and attempts to remove( ) the object will return false.</p>
<p>For other classes, equals( ) may be defined differently—Strings, for example, are equal if the contents of two Strings are identical. So to prevent surprises, it’s important to be aware that List behavior changes depending on equals( ) behavior.</p>
<p>In output lines 7 and 8, removing an object that exactly matches an object in the List is shown to be successful.</p>
<p>It’s possible to insert an element in the middle of the List, as you can see in output line 9 and the code that precedes it, but this brings up an issue: for a LinkedList, insertion and removal in the middle of a list is a cheap operation (except for, in this case, the actual random access into the middle of the list), but for an ArrayList it is an expensive operation. Does this mean you should never insert elements in the middle of an ArrayList, and switch to a LinkedList if you do? No, it just means you should be aware of the issue, and if you start doing many insertions in the middle of an ArrayList and your program starts slowing down, that you might look at your List implementation as the possible culprit (the best way to discover such a bottleneck, as you will see in the supplement at</p>
<p><a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a>, is to use a profiler). Optimization is a tricky issue, and the best policy is to leave it alone until you discover you need to worry about it (although understanding the issues is always a good idea).</p>
<p>The subList( ) method allows you to easily create a slice out of a larger list, and this naturally produces a true result when passed to containsAll( ) for that larger list. It’s also interesting to note that order is unimportant—you can see in output lines 11 and 12 that calling the intuitively named Collections.sort( ) and Collections.shuffle( ) on sub doesn’t affect the outcome of containsAll( ). subList( ) produces a list backed by the original list. Therefore, changes in the returned list are reflected in the original list, and vice versa.</p>
<p>The retainAll( ) method is effectively a &quot;set intersection&quot; operation, in this case keeping all the elements in copy that are also in sub. Again, the resulting behavior depends on the equals( ) method.</p>
<p>Output line 14 shows the result of removing an element using its index number, which is more straightforward than removing it by object reference since you don’t have to worry about equals( ) behavior when using indexes.</p>
<p>The removeAll( ) method also operates based on the equals( ) method. As the name implies, it removes all the objects from the List that are in the argument List. The set( ) method is rather unfortunately named because of the potential confusion with the Set class—</p>
<p>&quot;replace&quot; might have been a better name here, because it replaces the element at the index (the first argument) with the second argument.</p>
<p>Output line 17 shows that for Lists, there’s an overloaded addAll( ) method that allows you to insert the new list in the middle of the original list, instead of just appending it to the end with the addAll( ) that comes from Collection.</p>
<p>Output lines 18-20 show the effect of the isEmpty( ) and clear( ) methods.</p>
<p>Output lines 22 and 23 show how you can convert any Collection to an array using toArray( ). This is an overloaded method; the no-argument version returns an array of Object, but if you pass an array of the target type to the overloaded version, it will produce an array of the type specified (assuming it passes type checking). If the argument array is too small to hold all the objects in the List (as is the case here), to Array( ) will create a new array of the appropriate size. Pet objects have an id( ) method, which you can see is called on one of the objects in the resulting array.</p>
<p>Exercise 5: (3) Modify ListFeatures.java so that it uses Integers (remember autoboxing!) instead of Pets, and explain any difference in results.</p>
<p>Exercise 6: (2) Modify ListFeatures.java so that it uses Strings instead of Pets, and</p>
<p>explain any difference in results.</p>
<p>Exercise 7: (3) Create a class, then make an initialized array of objects of your class. Fill a List from your array. Create a subset of your List by using subList( ), then remove this subset from your List.</p>
</section>
<section>
<title>
<p>Iterator</p></title><empty-line/>
<p>In any container, you must have a way to insert elements and fetch them out again. After all, that’s the primary job of a container—to hold things. In a List, add( ) is one way to insert elements, and get( ) is one way to fetch elements.</p>
<p>If you want to start thinking at a higher level, there’s a drawback: You need to program to the exact type of the container in order to use it. This might not seem bad at first, but what if you write code for a List, and later on you discover that it would be convenient to apply that same code to a Set? Or suppose you’d like to write, from the beginning, a piece of general-purpose code that doesn’t know or care what type of container it’s working with, so that it can be used on different types of containers without rewriting that code?</p>
<p>The concept of an Iterator (another design pattern) can be used to achieve this abstraction. An iterator is an object whose job is to move through a sequence and select each object in that sequence without the client programmer knowing or caring about the underlying structure of that sequence. In addition, an iterator is usually what’s called a lightweight object: one that’s cheap to create. For that reason, you’ll often find seemingly strange constraints for iterators; for example, the Java Iterator can move in only one direction. There’s not much you can do with an Iterator except: <a l:href="#bookmark40" type="note"><sup>41</sup></a><sup></sup></p>
<p>To see how it works, we can again use the Pets tools from the Type Information chapter:</p>
<p>//: holding/Simplelteration.java import typeinfo.pets.*; import java.util.*;</p>
<p>public class Simplelteration {</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;Pet&gt; pets = Pets.arrayList(12);</p>
<p>Iterator&lt;Pet&gt; it = pets.iterator(); while(it.hasNext()) {</p>
<p>Pet p = it.next();</p>
<p>System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);</p>
<p>}</p>
<p>System.out.println();</p>
<p>// A simpler approach, when possible: for(Pet p : pets)</p>
<p>System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);</p>
<p>System.out.println();</p>
<p>// An Iterator can also remove elements: it = pets.iterator(); for(int i = 0; i &lt; 6; i++) { it.next(); it.remove();</p>
<p>}</p>
<p>System.out.println(pets);</p>
<p>}</p>
<p>} /* Output:</p>
<p>0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</p>
<p>0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</p>
<p>[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]</p>
<p>*///:~</p>
<p>With an Iterator, you don’t need to worry about the number of elements in the container. That’s taken care of for you by hasNext( ) and next( ).</p>
<p>If you’re simply moving forward through the List and not trying to modify the List object itself, you can see that the foreach syntax is more succinct.</p>
<p>An Iterator will also remove the last element produced by next( ), which means you must call next( ) before you call remove( ).<a l:href="#bookmark41" type="note"><sup>42</sup></a><sup></sup></p>
<p>This idea of taking a container of objects and passing through it to perform an operation on each one is powerful and will be seen throughout this book.</p>
<p>Now consider the creation of a display( ) method that is container-agnostic:</p>
<p>//: holding/CrossContainerlteration.java import typeinfo.pets.*; import java.util.*;</p>
<p>public class CrossContainerlteration {</p>
<p>public static void display(Iterator&lt;Pet&gt; it) { while(it.hasNext()) {</p>
<p>Pet p = it.next();</p>
<p>System.out.print(p.id() +    + p + &quot; &quot;);</p>
<p>}</p>
<p>System.out.println();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>ArrayList&lt;Pet&gt; pets = Pets.arrayList(8); LinkedList&lt;Pet&gt; petsLL = new LinkedList&lt;Pet&gt;(pets); HashSet&lt;Pet&gt; petsHS = new HashSet&lt;Pet&gt;(pets); TreeSet&lt;Pet&gt; petsTS = new TreeSet&lt;Pet&gt;(pets); display(pets.iterator()); display(petsLL.iterator()); display(petsHS.iterator()); display(petsTS.iterator());</p>
<p>}</p>
<p>} /* Output:</p>
<p>0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat 5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat *///:~</p>
<p>Note that display( ) contains no information about the type of sequence that it is traversing, and this shows the true power of the Iterator: the ability to separate the operation of traversing a sequence from the underlying structure of that sequence. For this reason, we sometimes say that iterators unify access to containers.</p>
<p>Exercise 8: (1) Modify Exercise l so it uses an Iterator to move through the List while calling hop( ).</p>
<p>Exercise 9: (4) Modify innerclasses/Sequence.java so that Sequence works with an Iterator instead of a Selector.</p>
<p>Exercise 10: (2) Change Exercise 9 in the Polymorphism chapter to use an ArrayList to hold the Rodents and an Iterator to move through the sequence of Rodents.</p>
<p>Exercise 11: (2) Write a method that uses an Iterator to step through a Collection and print the toString( ) of each object in the container. Fill all the different types of Collections with objects and apply your method to each container.</p>
<subtitle>ListIterator</subtitle>
<p>The ListIterator is a more powerful subtype of Iterator that is produced only by List classes. While Iterator can only move forward, ListIterator is bidirectional. It can also produce the indexes of the next and previous elements relative to where the iterator is pointing in the list, and it can replace the last element that it visited using the set( ) method. You can produce a ListIterator that points to the beginning of the List by calling listIterator( ), and you can also create a ListIterator that starts out pointing to an index n in the list by calling listIterator(n). Here’s an example that demonstrates all these abilities:</p>
<p>//: holding/Listlteration.java import typeinfo.pets.*; import java.util.*;</p>
<p>public class ListIteration {</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;Pet&gt; pets = Pets.arrayList(8);</p>
<p>ListIterator&lt;Pet&gt; it = pets.listIterator(); while(it.hasNext())</p>
<p>System.out.print(it.next() + &quot;, &quot; + it.nextIndex() +</p>
<p>&quot;, &quot; + it.previousIndex() + &quot;; &quot;);</p>
<p>System.out.println();</p>
<p>// Backwards: while(it.hasPrevious())</p>
<p>System.out.print(it.previous().id() + &quot; &quot;);</p>
<p>System.out.println();</p>
<p>System.out.println(pets); it = pets.listIterator(3); while(it.hasNext()) { it.next();</p>
<p>it.set(Pets.randomPet());</p>
<p>}</p>
<p>System.out.println(pets);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;</p>
<p>7 6 5 4 3 2 1 0</p>
<p>[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]</p>
<p>[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster, EgyptianMau] *///:~</p>
<p>The Pets.randomPet( ) method is used to replace all the Pet objects in the List from location 3 onward.</p>
<p>Exercise 12: (3) Create and populate a List&lt;Integer&gt;. Create a second List&lt;Integer&gt; of the same size as the first, and use ListIterators to read elements from the first List and insert them into the second in reverse order. (You may want to explore a number of different ways to solve this problem.)</p>
</section>
<section>
<title>
<p>LinkedList</p></title><empty-line/>
<p>The LinkedList also implements the basic List interface like ArrayList does, but it performs certain operations (insertion and removal in the middle of the List) more efficiently than does ArrayList. Conversely, it is less efficient for random-access operations.</p>
<p>LinkedList also adds methods that allow it to be used as a stack, a Queue or a double-ended queue (deque).</p>
<p>Some of these methods are aliases or slight variations of each other, to produce names that are more familiar within the context of a particular usage (Queue, in particular). For example, getFirst( ) and element( ) are identical—they return the head (first element) of the list without removing it, and throw NoSuchElementException if the List is empty. peek( ) is a slight variation of those two that returns null if the list is empty.</p>
<p>removeFirst( ) and remove( ) are also identical—they remove and return the head of the list, and throw NoSuchElementException for an empty list, and poll( ) is a slight variation that returns null if this list is empty.</p>
<p>addFirst( ) inserts an element at the beginning of the list.</p>
<p>offer( ) is the same as add( ) and addLast( ). They all add an element to the tail (end) of a list.</p>
<p>Here’s an example that shows the basic similarity and differences between these features. It doesn’t repeat the behavior that was shown in ListFeatures.java:</p>
<p>//: holding/LinkedListFeatures.java import typeinfo.pets.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class LinkedListFeatures {</p>
<p>public static void main(String[] args) {</p>
<p>LinkedList&lt;Pet&gt; pets =</p>
<p>new LinkedList&lt;Pet&gt;(Pets.arrayList(5)); print(pets);</p>
<p>// Identical:</p>
<p>print(&quot;pets.getFirst(): &quot; + pets.getFirst()); print(&quot;pets.element(): &quot; + pets.element());</p>
<p>// Only differs in empty-list behavior: print(&quot;pets.peek(): &quot; + pets.peek());</p>
<p>// Identical; remove and return the first element: print(&quot;pets.remove(): &quot; + pets.remove()); print(&quot;pets.removeFirst(): &quot; + pets.removeFirst());</p>
<p>// Only differs in empty-list behavior: print(&quot;pets.poll(): &quot; + pets.poll()); print(pets);</p>
<p>pets.addFirst(new Rat());</p>
<p>print(&quot;After addFirst(): &quot; + pets);</p>
<p>pets.offer(Pets.randomPet());</p>
<p>print(&quot;After offer(): &quot; + pets);</p>
<p>pets.add(Pets.randomPet());</p>
<p>print(&quot;After add(): &quot; + pets);</p>
<p>pets.addLast(new Hamster());</p>
<p>print(&quot;After addLast(): &quot; + pets);</p>
<p>print(&quot;pets.removeLast(): &quot; + pets.removeLast());</p>
<p>}</p>
<p>} /* Output:</p>
<p>[Rat, Manx, Cymric, Mutt, Pug] pets.getFirst(): Rat pets.element(): Rat pets.peek(): Rat pets.remove(): Rat pets.removeFirst(): Manx pets.poll(): Cymric [Mutt, Pug]</p>
<p>After addFirst(): [Rat, Mutt, Pug]</p>
<p>After offer(): [Rat, Mutt, Pug, Cymric]</p>
<p>After add(): [Rat, Mutt, Pug, Cymric, Pug]</p>
<p>After addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster] pets.removeLast(): Hamster *///:~</p>
<p>The result of Pets.arrayList( ) is handed to the LinkedList constructor in order to populate it. If you look at the Queue interface, you’ll see the element( ), offer( ), peek( ), poll( ) and remove( ) methods that were added to LinkedList in order that it could be a Queue implementation. Full examples of Queues will be given later in this chapter.</p>
<p>Exercise 13: (3) In the innerclasses/GreenhouseController.java example, the class Controller uses an ArrayList. Change the code to use a LinkedList instead, and use an Iterator to cycle through the set of events.</p>
<p>Exercise 14: (3) Create an empty LinkedList&lt;Integer&gt;. Using a Listlterator, add Integers to the List by always inserting them in the middle of the List.</p>
</section>
<section>
<title>
<p>Stack</p></title><empty-line/>
<p>A stack is sometimes referred to as a &quot;last-in, first-out&quot; (LIFO) container. It’s sometimes called a pushdown stack, because whatever you &quot;push&quot; on the stack last is the first item you can &quot;pop&quot; off of the stack. An often-used analogy is of cafeteria trays in a spring-loaded holder—the last ones that go in are the first ones that come out.</p>
<p>LinkedList has methods that directly implement stack functionality, so you can also just use a LinkedList rather than making a stack class. However, a stack class can sometimes tell the story better:</p>
<p>//: net/mindview/util/Stack.java // Making a stack from a LinkedList. package net.mindview.util; import java.util.LinkedList;</p>
<p>public class Stack&lt;T&gt; {</p>
<p>private LinkedList&lt;T&gt; storage = new LinkedList&lt;T&gt;(); public void push(T v) { storage.addFirst(v); } public T peek() { return storage.getFirst(); } public T pop() { return storage.removeFirst(); } public boolean empty() { return storage.isEmpty(); } public String toString() { return storage.toString(); }</p>
<p>} ///:~</p>
<p>This introduces the simplest possible example of a class definition using generics. The &lt;T&gt; after the class name tells the compiler that this will be a parameterized type, and that the type parameter—the one that will be substituted with a real type when the class is used—is T. Basically, this says, &quot;We’re defining a Stack that holds objects of type T.&quot; The Stack is implemented using a LinkedList, and the LinkedList is also told that it is holding type T. Notice that push( ) takes an object of type T, while peek( ) and pop( ) return an object of type T. The peek( ) method provides you with the top element without removing it from the top of the stack, while pop( ) removes and returns the top element.</p>
<p>If you want only stack behavior, inheritance is inappropriate here because it would produce a class with all the rest of the LinkedList methods (you’ll see in the Containers in Depth chapter that this very mistake was made by the Java l.o designers when they created java.util.Stack).</p>
<p>Here’s a simple demonstration of this new Stack class:</p>
<p>//: holding/StackTest.java import net.mindview.util.*;</p>
<p>public class StackTest {</p>
<p>public static void main(String[] args) {</p>
<p>Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;)) stack.push(s); while(!stack.empty())</p>
<p>System.out.print(stack.pop() + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output: fleas has dog My *///:~</p>
<p>If you want to use this Stack class in your own code, you’ll need to fully specify the package— or change the name of the class—when you create one; otherwise, you’ll probably collide with the Stack in the java.util package. For example, if we import java.util.* into the above example, we must use package names in order to prevent collisions:</p>
<p>//: holding/StackCollision.java import net.mindview.util.*;</p>
<p>public class StackCollision {</p>
<p>public static void main(String[] args) { net.mindview.util.Stack&lt;String&gt; stack = new net.mindview.util.Stack&lt;String&gt;(); for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;)) stack.push(s); while(!stack.empty())</p>
<p>System.out.print(stack.pop() + &quot; &quot;);</p>
<p>System.out.println(); java.util.Stack&lt;String&gt; stack2 = new java.util.Stack&lt;String&gt;(); for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;)) stack2.push(s); while(!stack2.empty())</p>
<p>System.out.print(stack2.pop() + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output: fleas has dog My fleas has dog My *///:~</p>
<p>The two Stack classes have the same interface, but there is no common Stack interface in java.util—probably because the original, poorly designed java.util.Stack class in Java 1.0 co-opted the name. Even though java.util.Stack exists, LinkedList produces a better Stack and so the net.mindview.util.Stack approach is preferable.</p>
<p>You can also control the selection of the &quot;preferred&quot; Stack implementation using an explicit import:</p>
<p>import net.mindview.util.Stack;</p>
<p>Now any reference to Stack will select the net.mindview.util version, and to select java.util.Stack you must use full qualification.</p>
<p>Exercise 15: (4) Stacks are often used to evaluate expressions in programming languages. Using net.mindview.util.Stack, evaluate the following expression, where’+’ means &quot;push the following letter onto the stack,&quot; and’-’ means &quot;pop the top of the stack and print it&quot;: &quot;+U+n+c—+e+r+t—+a-+i-+n+t+y—+ -+r+u—+l+e+s—&quot;</p>
</section>
<section>
<title>
<p>Set</p></title><empty-line/>
<p>A Set refuses to hold more than one instance of each object value. If you try to add more than one instance of an equivalent object, the Set prevents duplication. The most common use for a Set is to test for membership, so that you can easily ask whether an object is in a Set. Because of this, lookup is typically the most important operation for a Set, so you’ll usually choose a HashSet implementation, which is optimized for rapid lookup.</p>
<p>Set has the same interface as Collection, so there isn’t any extra functionality like there is in the two different types of List. Instead, the Set is exactly a Collection—it just has different behavior. (This is the ideal use of inheritance and polymorphism: to express different behavior.) A Set determines membership based on the &quot;value&quot; of an object, a more complex topic that you will learn about in the Containers in Depth chapter.</p>
<p>Here’s an example that uses a HashSet with Integer objects:</p>
<p>//: holding/SetOfInteger.java import java.util.*;</p>
<p>public class SetOfInteger {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47);</p>
<p>Set&lt;Integer&gt; intset = new HashSet&lt;Integer&gt;(); for(int i = 0; i &lt; 10000; i++) intset.add(rand.nextInt(30));</p>
<p>System.out.println(intset);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[15, 8, 23, 16, 7, 22, 9, 21, 6, 1, 29, 14, 24, 4, 19, 26, 11, 18, 3, 12, 27, 17, 2, 13, 28, 20, 25, 10, 5, 0]</p>
<p>*///:~</p>
<p>Ten thousand random numbers from o up to 29 are added to the Set, so you can imagine that each value has many duplications. And yet you can see that only one instance of each appears in the result.</p>
<p>You’ll also notice that the output is in no discernible order. This is because a HashSet uses hashing for speed-hashing is covered in the Containers in Depth chapter. The order maintained by a HashSet is different from a TreeSet or a LinkedHashSet, since each implementation has a different way of storing elements. TreeSet keeps elements sorted into a red-black tree data structure, whereas HashSet uses the hashing function. LinkedHashSet also uses hashing for lookup speed, but appears to maintain elements in insertion order using a linked list.</p>
<p>If you want the results to be sorted, one approach is to use a TreeSet instead of a HashSet:</p>
<p>//: holding/SortedSetOfInteger.java import java.util.*;</p>
<p>public class SortedSetOfInteger {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47);</p>
<p>SortedSet&lt;Integer&gt; intset = new TreeSet&lt;Integer&gt;(); for(int i = 0; i &lt; 10000; i++) intset.add(rand.nextInt(30));</p>
<p>System.out.println(intset);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]</p>
<p>*///:~</p>
<p>One of the most common operations you will perform is a test for set membership using contains( ), but there are also operations that will remind you of the Venn diagrams you may have been taught in elementary school:</p>
<p>//: holding/SetOperations.java import java.util.*;</p>
<p>import static net.mindview.util.Print.*; public class SetOperations {</p>
<p>public static void main(String[] args) {</p>
<p>Set&lt;String&gt; setl = new HashSet&lt;String&gt;(); Collections.addAll(set1,</p>
<p>&quot;A B C D E F G H I J K L&quot;.split(&quot; &quot;)); set1.add(&quot;M&quot;);</p>
<p>print(&quot;H: &quot; + set1.contains(&quot;H&quot;)); print(&quot;N: &quot; + set1.contains(&quot;N&quot;));</p>
<p>Set&lt;String&gt; set2 = new HashSet&lt;String&gt;(); Collections.addAll(set2, &quot;H I J K L&quot;.split(&quot; &quot;)); print(&quot;set2 in set1: &quot; + set1.containsAll(set2)); set1.remove(&quot;H&quot;); print(&quot;set1: &quot; + set1);</p>
<p>print(&quot;set2 in set1: &quot; + set1.containsAll(set2)); set1.removeAll(set2);</p>
<p>print(&quot;set2 removed from set1: &quot; + set1); Collections.addAll(set1, &quot;X Y Z&quot;.split(&quot; &quot;)); print(&quot;‘X Y Z&apos; added to set1: &quot; + set1);</p>
<p>}</p>
<p>} /* Output:</p>
<p>H: true N: false</p>
<p>set2 in set1: true</p>
<p>set1: [D, K, C, B, L, G, I, M, A, F, J, E] set2 in set1: false</p>
<p>set2 removed from set1: [D, C, B, G, M, A, F, E]</p>
<p>‘X Y Z&apos; added to set1: [Z, D, C, B, G, M, A, F, Y, X, E] *///:~</p>
<p>The method names are self-explanatory, and there are a few more that you will find in the JDK documentation.</p>
<p>Producing a list of unique elements can be quite useful. For example, suppose you’d like to list all the words in the file SetOperations.java, above. Using the</p>
<p>net.mindview.TextFile utility that will be introduced later in the book, you can open and read a file into a Set:</p>
<p>//: holding/UniqueWords.java</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>public class UniqueWords {</p>
<p>public static void main(String[] args) {</p>
<p>Set&lt;String&gt; words = new TreeSet&lt;String&gt;(</p>
<p>new TextFile(&quot;SetOperations.java&quot;, &quot;\\W+&quot;)); System.out.println(words);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[A, B, C, Collections, D, E, F, G, H, HashSet, I, J, K, L, M, N, Output, Print, Set, SetOperations, String, X, Y, Z, add, addAll, added, args, class, contains, containsAll, false, from, holding, import, in, java, main, mindview, net, new, print, public, remove, removeAll, removed, set1, set2, split, static, to, true, util, void]</p>
<p>*///:~</p>
<p>TextFile is inherited from List&lt;String&gt;. The TextFile constructor opens the file and breaks it into words according to the regular expression &quot;\\W+&quot;, which means &quot;one or more letters&quot; (regular expressions are introduced in the Strings chapter). The result is handed to the TreeSet constructor, which adds the contents of the List to itself. Since it is a TreeSet, the result is sorted. In this case, the sorting is done lexicographically so that the uppercase and lowercase letters are in separate groups. If you’d like to sort it alphabetically, you can pass the String.CASE_INSENSITIVE_ORDER Comparator (a comparator is an object that establishes order) to the TreeSet constructor:</p>
<p>//: holding/UniqueWordsAlphabetic.java // Producing an alphabetic listing. import java.util.*; import net.mindview.util.*;</p>
<p>public class UniqueWordsAlphabetic {</p>
<p>public static void main(String[] args) {</p>
<p>Set&lt;String&gt; words =</p>
<p>new TreeSet&lt;String&gt;(String.CASE_INSENSITIVE_ORDER); words.addAll(</p>
<p>new TextFile(&quot;SetOperations.java&quot;, &quot;\\W+&quot;)); System.out.println(words);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[A, add, addAll, added, args, B, C, class, Collections, contains, containsAll, D, E, F, false, from, G, H, HashSet, holding, I, import, in, J, java, K, L, M, main, mindview, N, net, new, Output, Print, public, remove, removeAll, removed, Set, setl, set2, SetOperations, split, static, String, to, true, util, void, X, Y, Z]</p>
<p>*///:~</p>
<p>Comparators will be explored in detail in the Arrays chapter.</p>
<p>Exercise 16: (5) Create a Set of the vowels. Working from UniqueWords.Java, count and display the number of vowels in each input word, and also display the total number of vowels in the input file.</p>
</section>
<section>
<title>
<p>Map</p></title><empty-line/>
<p>The ability to map objects to other objects can be an immensely powerful way to solve programming problems. For example, consider a program to examine the randomness of Java’s Random class. Ideally, Random would produce a perfect distribution of numbers, but to test this you need to generate many random numbers and count the ones that fall in the various ranges. A Map easily solves the problem; in this case, the key is the number produced by Random, and the value is the number of times that number appears:</p>
<p>//: holding/Statistics.java // Simple demonstration of HashMap. import java.util.*;</p>
<p>public class Statistics {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47);</p>
<p>Map&lt;Integer,Integer&gt; m =</p>
<p>new HashMap&lt;Integer,Integer&gt;(); for(int i = 0; i &lt; 10000; i++) {</p>
<p>// Produce a number between 0 and 20: int r = rand.nextInt(20);</p>
<p>Integer freq = m.get(r);</p>
<p>m.put(r, freq == null ? 1 : freq + 1);</p>
<p>}</p>
<p>System.out.println(m);</p>
<p>}</p>
<p>} /* Output:</p>
<p>{15=497, 4=481, 19=464, 8=468, 11=531, 16=533, 18=478, 3=508, 7=471, 12=521, 17=509, 2=489, 13=506, 9=549, 6=519, 1=502, 14=477, 10=513, 5=503, 0=481}</p>
<p>In main( ), autoboxing converts the randomly generated int into an Integer reference that can be used with the HashMap (you can’t use primitives with containers). The get( ) method returns null if the key is not already in the container (which means that this is the first time the number has been found). Otherwise, the get( ) method produces the associated Integer value for the key, which is incremented (again, autoboxing simplifies the expression but there are actually conversions to and from Integer taking place).</p>
<p>Here’s an example that allows you to use a String description to look up Pet objects. It also shows how you can test a Map to see if it contains a key or a value with containsKey( ) and containsValue( ):</p>
<p>//: holding/PetMap.java import typeinfo.pets.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class PetMap {</p>
<p>public static void main(String[] args) {</p>
<p>Map&lt;String,Pet&gt; petMap = new HashMap&lt;String,Pet&gt;(); petMap.put(&quot;My Cat&quot;, new Cat(&quot;Molly&quot;)); petMap.put(&quot;My Dog&quot;, new Dog(&quot;Ginger&quot;)); petMap.put(&quot;My Hamster&quot;, new Hamster(&quot;Bosco&quot;)); print(petMap);</p>
<p>Pet dog = petMap.get(&quot;My Dog&quot;); print(dog);</p>
<p>print(petMap.containsKey(&quot;My Dog&quot;)); print(petMap.containsValue(dog));</p>
<p>}</p>
<p>} /* Output:</p>
<p>{My Cat=Cat Molly, My Hamster=Hamster Bosco, My Dog=Dog Ginger}</p>
<p>Dog Ginger</p>
<p>true</p>
<p>true</p>
<p>*///:~</p>
<p>Maps, like arrays and Collections, can easily be expanded to multiple dimensions; you simply make a Map whose values are Maps (and the values of those Maps can be other containers, even other Maps). Thus, it’s quite easy to combine containers to quickly produce powerful data structures. For example, suppose you are keeping track of people who have multiple pets—all you need is a Map&lt;Person, List&lt;Pet&gt;&gt;:</p>
<p>//: holding/MapOfList.java package holding; import typeinfo.pets.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class MapOfList {</p>
<p>public static Map&lt;Person, List&lt;? extends Pet&gt;&gt;</p>
<p>petPeople = new HashMap&lt;Person, List&lt;? extends Pet&gt;&gt;(); static {</p>
<p>petPeople.put(new Person(&quot;Dawn&quot;),</p>
<p>Arrays.asList(new Cymric(&quot;Molly&quot;),new Mutt(&quot;Spot&quot;))); petPeople.put(new Person(&quot;Kate&quot;),</p>
<p>Arrays.asList(new Cat(&quot;Shackleton&quot;),</p>
<p>new Cat(&quot;Elsie May&quot;), new Dog(&quot;Margrett&quot;)));</p>
<p>petPeople.put(new Person(&quot;Marilyn&quot;),</p>
<p>Arrays.asList(</p>
<p>new Pug(&quot;Louie aka Louis Snorkelstein Dupree&quot;), new Cat(&quot;Stanford aka Stinky el Negro&quot;), new Cat(&quot;Pinkola&quot;))); petPeople.put(new Person(&quot;Luke&quot;),</p>
<p>Arrays.asList(new Rat(&quot;Fuzzy&quot;), new Rat(&quot;Fizzy&quot;))); petPeople.put(new Person(&quot;Isaac&quot;),</p>
<p>Arrays.asList(new Rat(&quot;Freckly&quot;)));</p>
<p>}</p>
<p>public static void main(String[] args) { print(&quot;People: &quot; + petPeople.keySet()); print(&quot;Pets: &quot; + petPeople.values()); for(Person person : petPeople.keySet()) { print(person + &quot; has:&quot;); for(Pet pet : petPeople.get(person)) print(&quot; &quot; + pet);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>People: [Person Luke, Person Marilyn, Person Isaac, Person Dawn, Person Kate]</p>
<p>Pets: [[Rat Fuzzy, Rat Fizzy], [Pug Louie aka Louis Snorkelstein Dupree, Cat Stanford aka Stinky el Negro, Cat Pinkola], [Rat Freckly], [Cymric Molly, Mutt Spot], [Cat Shackleton, Cat Elsie May, Dog Margrett]]</p>
<p>Person Luke has:</p>
<p>Rat Fuzzy Rat Fizzy</p>
<p>Person Marilyn has:</p>
<p>Pug Louie aka Louis Snorkelstein Dupree Cat Stanford aka Stinky el Negro Cat Pinkola Person Isaac has:</p>
<p>Rat Freckly Person Dawn has:</p>
<p>Cymric Molly Mutt Spot Person Kate has:</p>
<p>Cat Shackleton Cat Elsie May Dog Margrett *///:~</p>
<p>A Map can return a Set of its keys, a Collection of its values, or a Set of its pairs. The keySet( ) method produces a Set of all the keys in petPeople, which is used in the foreach statement to iterate through the Map.</p>
<p>Exercise 17: (2) Take the Gerbil class in Exercise 1 and put it into a Map instead, associating each Gerbil’s name (e.g. &quot;Fuzzy&quot; or &quot;Spot&quot;) as a String (the key) for each Gerbil (the value) you put in the table. Get an Iterator for the keySet( ) and use it to move through the Map, looking up the Gerbil for each key and printing out the key and telling the Gerbil to hop( ).</p>
<p>Exercise 18: (3) Fill a HashMap with key-value pairs. Print the results to show ordering by hash code. Extract the pairs, sort by key, and place the result into a LinkedHashMap. Show that the insertion order is maintained.</p>
<p>Exercise 19: (2) Repeat the previous exercise with a HashSet and LinkedHashSet.</p>
<p>Exercise 20: (3) Modify Exercise 16 so that you keep a count of the occurrence of each vowel.</p>
<p>Exercise 21: (3) Using a Map&lt;String,Integer&gt;, follow the form of UniqueWords.java to create a program that counts the occurrence of words in a file. Sort the results using Collections.sort( ) with a second argument of</p>
<p>String.CASE_INSENSITIVE_ORDER (to produce an alphabetic sort), and display the result.</p>
<p>Exercise 22: (5) Modify the previous exercise so that it uses a class containing a String and a count field to store each different word, and a Set of these objects to maintain the list of words.</p>
<p>Exercise 23: (4) Starting with Statistics.java, create a program that runs the test repeatedly and looks to see if any one number tends to appear more than the others in the results.</p>
<p>Exercise 24: (2) Fill a LinkedHashMap with String keys and objects of your choice. Now extract the pairs, sort them based on the keys, and reinsert them into the Map.</p>
<p>Exercise 25: (3) Create a Map&lt;String,ArrayList&lt;Integer&gt;&gt;. Use net.mindview.TextFile to open a text file and read it in a word at a time (use &quot;\\W+&quot; as the second argument to the TextFile constructor). Count the words as you read them in, and for each word in the file, record in the ArrayList&lt;Integer&gt; the word count associated with that word—this is, in effect, the location in the file where that word was found.</p>
<p>Exercise 26: (4) Take the resulting Map from the previous exercise and re-create the order of the words as they appeared in the original file.</p>
</section>
<section>
<title>
<p>Queue</p></title><empty-line/>
<p>A queue is typically a “first-in, first-out&quot; (FIFO) container. That is, you put things in at one end and pull them out at the other, and the order in which you put them in will be the same order in which they come out. Queues are commonly used as a way to reliably transfer objects from one area of a program to another. Queues are especially important in concurrent programming, as you will see in the Concurrency chapter, because they safely transfer objects from one task to another.</p>
<p>LinkedList has methods to support queue behavior and it implements the Queue interface, so a LinkedList can be used as a Queue implementation. By upcasting a LinkedList to a Queue, this example uses the Queuespecific methods in the Queue interface:</p>
<p>//: holding/QueueDemo.java</p>
<p>// Upcasting to a Queue from a LinkedList.</p>
<p>import java.util.*;</p>
<p>public class QueueDemo {</p>
<p>public static void printQ(Queue queue) { while(queue.peek() != null)</p>
<p>System.out.print(queue.remove() + &quot; &quot;);</p>
<p>System.out.println();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();</p>
<p>Random rand = new Random(47); for(int i = 0; i &lt; 10; i++)</p>
<p>queue.offer(rand.nextInt(i + 10)); printQ(queue);</p>
<p>Queue&lt;Character&gt; qc = new LinkedList&lt;Character&gt;(); for(char c : &quot;Brontosaurus&quot;.toCharArrayQ) qc.offer(c); printQ(qc);</p>
<p>}</p>
<p>} /* Output:</p>
<p>8 1 1 1 5 14 3 1 0 1 B r o n t o s a u r u s *///:~</p>
<p>offer( ) is one of the Queue-specific methods; it inserts an element at the tail of the queue if it can, or returns false. Both peek( ) and element( ) return the head of the queue without removing it, but peek( ) returns null if the queue is empty and element( ) throws NoSuchElementException. Both poll( ) and remove( ) remove and return the head of the queue, but poll( ) returns null if the queue is empty, while remove( ) throws NoSuchElementException.</p>
<p>Autoboxing automatically converts the int result of nextInt( ) into the Integer object required by queue, and the char c into the Character object required by qc. The Queue interface narrows access to the methods of LinkedList so that only the appropriate methods are available, and you are thus less tempted to use LinkedList methods (here, you could actually cast queue back to a LinkedList, but you are at least discouraged from doing so).</p>
<p>Notice that the Queue-specific methods provide complete and standalone functionality. That is, you can have a usable Queue without any of the methods that are in Collection, from which it is inherited.</p>
<p>Exercise 27: (2) Write a class called Command that contains a String and has a method operation( ) that displays the String. Write a second class with a method that fills a Queue with Command objects and returns it. Pass the filled Queue to a method in a third class that consumes the objects in the Queue and calls their operation( ) methods.</p>
<subtitle>PriorityQueue</subtitle>
<p>First-in, first-out (FIFO) describes the most typical queuing discipline. A queuing discipline is what decides, given a group of elements in the queue, which one goes next. First-in, first-out says that the next element should be the one that was waiting the longest.</p>
<p>Apriority queue says that the element that goes next is the one with the greatest need (the highest priority). For example, in an airport, a customer might be pulled out of a queue if their plane is about to leave. If you build a messaging system, some messages will be more important than others, and should be dealt with sooner, regardless of when they arrive. The PriorityQueue was added in Java SE5 to provide an automatic implementation for this behavior.</p>
<p>When you offer( ) an object onto a PriorityQueue, that object is sorted into the queue.<a l:href="#bookmark42" type="note"><sup>43</sup></a><sup> </sup>The default sorting uses the natural order of the objects in the queue, but you can modify the order by providing your own Comparator. The PriorityQueue ensures that when you call peek( ), poll( ) or remove( ), the element you get will be the one with the highest priority.</p>
<p>It’s trivial to make a PriorityQueue that works with built-in types like Integer, String or Character. In the following example, the first set of values are the identical random values from the previous example, so you can see that they emerge differently from the PriorityQueue:</p>
<p>//: holding/PriorityQueueDemo.java import java.util.*;</p>
<p>public class PriorityQueueDemo {</p>
<p>public static void main(String[] args) {</p>
<p>PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;Integer&gt;();</p>
<p>Random rand = new Random(47); for(int i = 0; i &lt; 10; i++)</p>
<p>priorityQueue.offer(rand.nextInt(i + 10)); QueueDemo.printQ(priorityQueue);</p>
<p>List&lt;Integer&gt; ints = Arrays.asList(25, 22, 20,</p>
<p>18, 14, 9, 3, 1, 1, 2, 3, 9, 14, 18, 21, 23, 25); priorityQueue = new PriorityQueue&lt;Integer&gt;(ints); QueueDemo.printQ(priorityQueue); priorityQueue = new PriorityQueue&lt;Integer&gt;( ints.size(), Collections.reverseOrder()); priorityQueue.addAll(ints);</p>
<p>QueueDemo.printQ(priorityQueue);</p>
<p>String fact = &quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;;</p>
<p>List&lt;String&gt; strings = Arrays.asList(fact.split(&quot;&quot;)); PriorityQueue&lt;String&gt; stringPQ = new PriorityQueue&lt;String&gt;(strings);</p>
<p>QueueDemo.printQ(stringPQ); stringPQ = new PriorityQueue&lt;String&gt;(</p>
<p>strings.size(), Collections.reverseOrder()); stringPQ.addAll(strings);</p>
<p>QueueDemo.printQ(stringPQ);</p>
<p>Set&lt;Character&gt; charSet = new HashSet&lt;Character&gt;(); for(char c : fact.toCharArray()) charSet.add(c); // Autoboxing PriorityQueue&lt;Character&gt; characterPQ = new PriorityQueue&lt;Character&gt;(charSet); QueueDemo.printQ(characterPQ);</p>
<p>}</p>
<p>} /* Output:</p>
<p>*///:~</p>
<p>You can see that duplicates are allowed, and the lowest values have the highest priority (in the case of String, spaces also count as values and are higher in priority than letters). To show how you can change the ordering by providing your own Comparator object, the third constructor call to PriorityQueue&lt;Integer&gt; and the second call to PriorityQueue&lt;String&gt; use the reverse-order Comparator produced by Collections.reverseOrder( ) (added in Java SE5).</p>
<p>The last section adds a HashSet to eliminate duplicate Characters, just to make things a little more interesting.</p>
<p>Integer, String and Character work with PriorityQueue because these classes already have natural ordering built in. If you want you use your own class in a PriorityQueue, you must include additional functionality to produce natural ordering, or provide your own Comparator. There’s a more sophisticated example that demonstrates this in the Containers in Depth chapter.</p>
<p>Exercise 28: (2) Fill a PriorityQueue (using offer( )) with Double values created using java.util.Random, then remove the elements using poll( ) and display them.</p>
<p>Exercise 29: (2) Create a simple class that inherits from Object and contains no members, and show that you cannot successfully add multiple elements of that class to a PriorityQueue. This issue will be fully explained in the Containers in Depth chapter.</p>
</section>
<section>
<title>
<p>Collection vs. Iterator</p></title><empty-line/>
<p>Collection is the root interface that describes what is common for all sequence containers.</p>
<p>It might be thought of as an &quot;incidental interface,&quot; one that appeared because of commonality between other interfaces. In addition, the java.utiLAbstractCollection class provides a default implementation for a Collection, so that you can create a new subtype of AbstractCollection without unnecessary code duplication.</p>
<p>One argument for having an interface is that it allows you to create more generic code. By writing to an interface rather than an implementation, your code can be applied to more types of objects.<a l:href="#bookmark43" type="note"><sup>44</sup></a><sup></sup> So if I write a method that takes a Collection, that method can be applied to any type that implements Collection—and this allows a new class to choose to implement Collection in order to be used with my method. It’s interesting to note, however, that the Standard C++ Library has no common base class for its containers—all commonality between containers is achieved through iterators. In Java, it might seem sensible to follow the C++ approach, and to express commonality between containers using an iterator rather than a Collection. However, the two approaches are bound together, since implementing Collection also means providing an iterator( ) method:</p>
<p>//: holding/InterfaceVsIterator.java import typeinfo.pets.*; import java.util.*;</p>
<p>public class InterfaceVsIterator {</p>
<p>public static void display(Iterator&lt;Pet&gt; it) { while(it.hasNext()) {</p>
<p>Pet p = it.next();</p>
<p>System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);</p>
<p>}</p>
<p>System.out.println();</p>
<p>}</p>
<p>public static void display(Collection&lt;Pet&gt; pets) { for(Pet p : pets)</p>
<p>System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);</p>
<p>System.out.println();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;Pet&gt; petList = Pets.arrayList(8);</p>
<p>Set&lt;Pet&gt; petSet = new HashSet&lt;Pet&gt;(petList);</p>
<p>Map&lt;String,Pet&gt; petMap =</p>
<p>new LinkedHashMap&lt;String,Pet&gt;();</p>
<p>String[] names = (&quot;Ralph, Eric, Robin, Lacey, &quot;</p>
<p>+</p>
<p>&quot;Britney, Sam, Spot, Fluffy&quot;).split(&quot;, &quot;); for(int i = 0; i &lt; names.length; i++) petMap.put(names[i], petList.get(i)); display(petList); display(petSet); display(petList.iterator()); display(petSet.iterator());</p>
<p>System.out.println(petMap); System.out.println(petMap.keySet()); display(petMap.values()); display(petMap.valuesQ.iteratorQ);</p>
<p>}</p>
<p>} /* Output:</p>
<p>0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat {Ralph=Rat, Eric=Manx, Robin=Cymric, Lacey=Mutt, Britney=Pug, Sam=Cymric, Spot=Pug, Fluffy=Manx}</p>
<p>[Ralph, Eric, Robin, Lacey, Britney, Sam, Spot, Fluffy]</p>
<p>0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx *///:~</p>
<p>Both versions of display( ) work with Map objects as well as with subtypes of Collection, and both the Collection interface and the Iterator decouple the display( ) methods from knowing about the particular implementation of the underlying container.</p>
<p>In this case the two approaches come up even. In fact, Collection pulls ahead a bit because it is Iterable, and so in the implementation of display(Collection) the foreach construct can be used, which makes the code a little cleaner.</p>
<p>The use of Iterator becomes compelling when you implement a foreign class, one that is not a Collection, in which it would be difficult or annoying to make it implement the Collection interface. For example, if we create a Collection implementation by inheriting from a class that holds Pet objects, we must implement all the Collection methods, even if we don’t need to use them within the display( ) method. Although this can easily be accomplished by inheriting from AbstractCollection, you’re forced to implement iterator( ) anyway, along with size( ), in order to provide the methods that are not implemented by AbstractCollection, but that are used by the other methods in AbstractCollection:</p>
<p>//: holding/CollectionSequence.java import typeinfo.pets.*; import java.util.*;</p>
<p>public class CollectionSequence extends AbstractCollection&lt;Pet&gt; {</p>
<p>private Pet[] pets = Pets.createArray(8); public int size() { return pets.length; } public Iterator&lt;Pet&gt; iterator() { return new Iterator&lt;Pet&gt;() { private int index = 0; public boolean hasNext() { return index &lt; pets.length;</p>
<p>}</p>
<p>public Pet next() { return pets[index++]; } public void remove() { // Not implemented throw new UnsupportedOperationException();</p>
<p>}</p>
<p>};</p>
<p>public static void main(String[] args) {</p>
<p>CollectionSequence c = new CollectionSequence();</p>
<p>InterfaceVsIterator.display(c);</p>
<p>InterfaceVsIterator.display(c.iterator());</p>
<p>}</p>
<p>} /* Output:</p>
<p>0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx *///:~</p>
<p>The remove( ) method is an &quot;optional operation,&quot; which you will learn about in the Containers in Depth chapter. Here, it’s not necessary to implement it, and if you call it, it will throw an exception.</p>
<p>From this example, you can see that if you implement Collection, you also implement iterator( ), and just implementing iterator( ) alone requires only slightly less effort than inheriting from AbstractCoUection. However, if your class already inherits from another class, then you cannot also inherit from AbstractCollection. In that case, to implement Collection you’d have to implement all the methods in the interface. In this case it would be much easier to inherit and add the ability to create an iterator:</p>
<p>//: holding/NonCollectionSequence.java import typeinfo.pets.*; import java.util.*;</p>
<p>class PetSequence {</p>
<p>protected Pet[] pets = Pets.createArray(8);</p>
<p>}</p>
<p>public class NonCollectionSequence extends PetSequence { public Iterator&lt;Pet&gt; iterator() { return new Iterator&lt;Pet&gt;() { private int index = 0; public boolean hasNext() { return index &lt; pets.length;</p>
<p>}</p>
<p>public Pet next() { return pets[index++]; } public void remove() { // Not implemented throw new UnsupportedOperationException();</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>NonCollectionSequence nc = new NonCollectionSequence(); InterfaceVsIterator.display(nc.iterator());</p>
<p>}</p>
<p>} /* Output:</p>
<p>0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx *///:~</p>
<p>Producing an Iterator is the least-coupled way of connecting a sequence to a method that consumes that sequence, and puts far fewer constraints on the sequence class than does implementing Collection.</p>
<p>Exercise 30: (5) Modify CollectionSequence.java so that it does not inherit from AbstractCollection, but instead implements Collection.</p>
</section>
<section>
<title>
<p>Foreach and iterators</p></title><empty-line/>
<p>So far, the foreach syntax has been primarily used with arrays, but it also works with any Collection object. You’ve actually seen a few examples of this using ArrayList, but here’s a general proof:</p>
<p>//: holding/ForEachCollections.java // All collections work with foreach. import java.util.*;</p>
<p>public class ForEachCollections {</p>
<p>public static void main(String[] args) {</p>
<p>Collection&lt;String&gt; cs = new LinkedList&lt;String&gt;(); Collections.addAll(cs,</p>
<p>&quot;Take the long way home&quot;.split(&quot; &quot;)); for(String s : cs)</p>
<p>System.out.print(..... + s + .....);</p>
<p>}</p>
<p>} /* Output:</p>
<p>‘Take’ ‘the’ ‘long’ ‘way’ ‘home’</p>
<p>*///:~</p>
<p>Since cs is a Collection, this code shows that working with foreach is a characteristic of all Collection objects.</p>
<p>The reason that this works is that Java SE5 introduced a new interface called Iterable which contains an iterator( ) method to produce an Iterator, and the Iterable interface is what foreach uses to move through a sequence. So if you create any class that implements Iterable, you can use it in a foreach statement:</p>
<p>//: holding/IterableClass.java // Anything Iterable works with foreach. import java.util.*;</p>
<p>public class IterableClass implements Iterable&lt;String&gt; { protected String[] words = (&quot;And that is how &quot; +</p>
<p>&quot;we know the Earth to be banana-shaped.&quot;).split(&quot; &quot;); public Iterator&lt;String&gt; iterator() { return new Iterator&lt;String&gt;() { private int index = 0; public boolean hasNext() { return index &lt; words.length;</p>
<p>}</p>
<p>public String next() { return words[index++]; } public void remove() { // Not implemented throw new UnsupportedOperationException();</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>public static void main(String[] args) { for(String s : new IterableClass())</p>
<p>System.out.print(s + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>And that is how we know the Earth to be banana-shaped.</p>
<p>*///:~</p>
<p>The iterator( ) method returns an instance of an anonymous inner implementation of Iterator&lt;String&gt; which delivers each word in the array. In main( ), you can see that IterableClass does indeed work in a foreach statement.</p>
<p>In Java SE5, a number of classes have been made Iterable, primarily all Collection classes (but not Maps). For example, this code displays all the operating system environment variables:</p>
<p>//: holding/EnvironmentVariables.java import java.util.*;</p>
<p>public class EnvironmentVariables {</p>
<p>public static void main(String[] args) {</p>
<p>for(Map.Entry entry: System.getenv().entrySet()) { System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());</p>
<p>}</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>System.getenv( )<sup>7</sup> returns a Map, entrySet( ) produces a Set of Map.Entry elements, and a Set is Iterable so it can be used in a foreach loop.</p>
<p>A foreach statement works with an array or anything Iterable, but that doesn’t mean that an array is automatically an Iterable, nor is there any autoboxing that takes place:</p>
<p>//: holding/ArraylsNotIterable.java import java.util.*;</p>
<p>public class ArraylsNotIterable {</p>
<p>static &lt;T&gt; void test(Iterable&lt;T&gt; ib) { for(T t : ib)</p>
<p>System.out.print(t + &quot; &quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { test(Arrays.asList(1, 2, 3));</p>
<p>String[] strings = { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; };</p>
<p>// An array works in foreach, but it’s not Iterable:</p>
<p>//! test(strings);</p>
<p>// You must explicitly convert it to an Iterable: test(Arrays.asList(strings));</p>
<p>}</p>
<p>} /* Output:</p>
<p>1 2 3 A B C *///:~</p>
<p>Trying to pass an array as an Iterable argument fails. There is no automatic conversion to an Iterable; you must do it by hand.</p>
<p>Exercise 31: (3) Modify polymorphism/shape/RandomShapeGenerator.java to make it Iterable. You’ll need to add a constructor that takes the number of elements that you want the iterator to produce before stopping. Verify that it works.</p>
<p><sup>7</sup> This was not available before Java SE5, because it was thought to be too tightly coupled to the operating system, and thus to violate &quot;write once, run anywhere.&quot; The fact that it is included now suggests that the Java designers are becoming more pragmatic.</p>
<p>The Adapter Method idiom</p>
<p>What if you have an existing class that is Iterable, and you’d like to add one or more new ways to use this class in a foreach statement? For example, suppose you’d like to choose whether to iterate through a list of words in either a forward or reverse direction. If you simply inherit from the class and override the iterator( ) method, you replace the existing method and you don’t get a choice.</p>
<p>One solution is what I call the Adapter Method idiom. The &quot;Adapter&quot; part comes from design patterns, because you must provide a particular interface to satisfy the foreach statement. When you have one interface and you need another one, writing an adapter solves the problem. Here, I want to add the ability to produce a reverse iterator to the default forward iterator, so I can’t override. Instead, I add a method that produces an Iterable object which can then be used in the foreach statement. As you see here, this allows us to provide multiple ways to use foreach:</p>
<p>//: holding/AdapterMethocUdiom.java</p>
<p>// The &quot;Adapter Method&quot; idiom allows you to use foreach // with additional kinds of Iterables. import java.util.*;</p>
<p>class ReversibleArrayList&lt;T&gt; extends ArrayList&lt;T&gt; {</p>
<p>public ReversibleArrayList(Collection&lt;T&gt; c) { super(c); } public Iterable&lt;T&gt; reversed() { return new Iterable&lt;T&gt;() {</p>
<p>public Iterator&lt;T&gt; iterator() { return new Iterator&lt;T&gt;() { int current = size() - 1;</p>
<p>public boolean hasNext() { return current &gt; -1; } public T next() { return get(current--); } public void remove() { // Not implemented throw new UnsupportedOperationException();</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>}</p>
<p>public class AdapterMethodIdiom {</p>
<p>public static void main(String[] args) {</p>
<p>ReversibleArrayList&lt;String&gt; ral = new ReversibleArrayList&lt;String&gt;(</p>
<p>Arrays.asList(&quot;To be or not to be&quot;.split(&quot; &quot;)));</p>
<p>// Grabs the ordinary iterator via iterator(): for(String s : ral)</p>
<p>System.out.print(s + &quot; &quot;);</p>
<p>System.out.println();</p>
<p>// Hand it the Iterable of your choice for(String s : ral.reversed())</p>
<p>System.out.print(s + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>To be or not to be be to not or be To *///:~</p>
<p>If you simply put the ral object in the foreach statement, you get the (default) forward iterator. But if you call reversed( ) on the object, it produces different behavior.</p>
<p>Using this approach, I can add two adapter methods to the IterableClass.java example:</p>
<p>//: holding/MultilterableClass.java // Adding several Adapter Methods. import java.util.*;</p>
<p>public class MultilterableClass extends IterableClass { public Iterable&lt;String&gt; reversed() { return new Iterable&lt;String&gt;() {</p>
<p>public Iterator&lt;String&gt; iterator() { return new Iterator&lt;String&gt;() { int current = words.length - 1;</p>
<p>public boolean hasNext() { return current &gt; -1; } public String next() { return words[current--]; } public void remove() { // Not implemented throw new UnsupportedOperationException();</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>public Iterable&lt;String&gt; randomized() { return new Iterable&lt;String&gt;() {</p>
<p>public Iterator&lt;String&gt; iterator() {</p>
<p>List&lt;String&gt; shuffled =</p>
<p>new ArrayList&lt;String&gt;(Arrays.asList(words)); Collections.shuffle(shuffled, new Random(47)); return shuffled.iterator();</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>MultiIterableClass mic = new MultiIterableClass(); for(String s : mic.reversed())</p>
<p>System.out.print(s + &quot; &quot;);</p>
<p>System.out.println(); for(String s : mic.randomized())</p>
<p>System.out.print(s + &quot; &quot;);</p>
<p>System.out.println(); for(String s : mic)</p>
<p>System.out.print(s + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>banana-shaped. be to Earth the know we how is that And is banana-shaped. Earth that how the be And we know to And that is how we know the Earth to be banana-shaped.</p>
<p>*///:~</p>
<p>Notice that the second method, random( ), doesn’t create its own Iterator but simply returns the one from the shuffled List.</p>
<p>You can see from the output that the Collections.shuffle( ) method doesn’t affect the original array, but only shuffles the references in shuffled. This is only true because the randomized( ) method wraps an ArrayList around the result of Arrays.asList( ). If the List produced by Arrays.asList( ) is shuffled directly, it will modify the underlying array, as you can see here:</p>
<p>//: holding/ModifyingArraysAsList.java import java.util.*;</p>
<p>public class ModifyingArraysAsList {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47);</p>
<p>Integer[] ia = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; List&lt;Integer&gt; listl =</p>
<p>new ArrayList&lt;Integer&gt;(Arrays.asList(ia)); System.out.println(&quot;Before shuffling: &quot; + listl); Collections.shuffle(list1, rand); System.out.println(&quot;After shuffling: &quot; + listl); System.out.println(&quot;array: &quot; + Arrays.toString(ia));</p>
<p>List&lt;Integer&gt; list2 = Arrays.asList(ia); System.out.println(&quot;Before shuffling: &quot; + list2); Collections.shuffle(list2, rand); System.out.println(&quot;After shuffling: &quot; + list2); System.out.println(&quot;array: &quot; + Arrays.toString(ia));</p>
<p>}</p>
<p>} /* Output:</p>
<p>Before shuffling: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<p>After shuffling: [4, 6, 3, 1, 8, 7, 2, 5, 10, 9] array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<p>Before shuffling: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<p>After shuffling: [9, 1, 6, 3, 7, 2, 5, 10, 4, 8] array: [9, 1, 6, 3, 7, 2, 5, 10, 4, 8]</p>
<p>*///:~</p>
<p>In the first case, the output of Arrays.asList( ) is handed to the ArrayList( ) constructor, and this creates an ArrayList that references the elements of ia. Shuffling these references doesn’t modify the array. However, if you use the result of Arrays.asList(ia) directly, shuffling modifies the order of ia. It’s important to be aware that Arrays.asList( ) produces a List object that uses the underlying array as its physical implementation. If you do anything to that List that modifies it, and you don’t want the original array modified, you should make a copy into another container.</p>
<p>Exercise 32: (2) Following the example of MultilterableClass, add reversed( ) and randomized( ) methods to NonCollectionSequence.java, as well as making NonCollectionSequence implement Iterable, and show that all the approaches work in foreach statements.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>Java provides a number of ways to hold objects:</p>
<p>1.    An array associates numerical indexes to objects. It holds objects of a known type so that you don’t have to cast the result when you’re looking up an object. It can be multidimensional, and it can hold primitives. However, its size cannot be changed once you create it.</p>
<p>2.    A Collection holds single elements, and a Map holds associated pairs. With Java generics, you specify the type of object to be held in the containers, so you can’t put the wrong type into a container and you don’t have to cast elements when you fetch them out of a container. Both Collections and Maps automatically resize themselves as you add more elements. A container won’t hold primitives, but autoboxing takes care of translating primitives back and forth to the wrapper types held in the container.</p>
<p>3.    Like an array, a List also associates numerical indexes to objects— thus, arrays and Lists are ordered containers.</p>
<p>4.    Use an ArrayList if you’re doing a lot of random accesses, but a LinkedList if you will be doing a lot of insertions and removals in the middle of the list.</p>
<p>5.    The behavior of Queues and stacks is provided via the LinkedList.</p>
<p>6.    A Map is a way to associate not integral values, but objects with other objects. HashMaps are designed for rapid access, whereas a TreeMap keeps its keys in sorted order, and thus is not as fast as a HashMap. A LinkedHashMap keeps its elements in insertion order, but provides rapid access with hashing.</p>
<p>7.    A Set only accepts one of each type of object. HashSets provide maximally fast lookups, whereas TreeSets keep the elements in sorted order. LinkedHashSets keep elements in insertion order.</p>
<p>8.    There’s no need to use the legacy classes Vector, Hashtable, and Stack in new code.</p>
<p>It’s helpful to look at a simplified diagram of the Java containers (without the abstract classes or legacy components). This only includes the interfaces and classes that you will encounter on a regular basis.</p>
<p>Iterator .......................-i Cotlection i</p>
<p>Produces</p>
<p>Produces</p>
<p>map</p>
<p>Listlterator !-*............• List</p>
<p>.......................֊ Produces L</p>
<p>Set [! Queue</p>
<p>HashMap</p>
<p>TreeMap</p>
<p>LinkedHashMap</p>
<p>ArrayList</p>
<p>Linked List</p>
<p>PriorityQueue</p>
<p>Utilities</p>
<p>HashSet</p>
<p>TreeSet</p>
<p>Collections</p>
<p>Arrays</p>
<p>Comparable</p>
<p>Comparator</p>
<p>LinkedHashSet</p>
<p>Simple Container Taxonomy</p>
<p>You’ll see that there are really only four basic container components—Map, List, Set, and Queue—and only two or three implementations of each one (the java.util.concurrent implementations of Queue are not included in this diagram). The containers that you will use most often have heavy black lines around them.</p>
<p>The dotted boxes represent interfaces, and the solid boxes are regular (concrete) classes. The dotted lines with hollow arrows indicate that a particular class is implementing an interface. The solid arrows show that a class can produce objects of the class the arrow is pointing to. For example, any Collection can produce an Iterator, and a List can produce a ListIterator (as well as an ordinary Iterator, since List is inherited from Collection).</p>
<p>Here’s an example that shows the difference in methods between the various classes. The actual code is from the Generics chapter; I’m just calling it here to produce the output. The output also shows the interfaces that are implemented in each class or interface:</p>
<p>//: holding/ContainerMethods.java import net.mindview.util.*;</p>
<p>public class ContainerMethods {</p>
<p>public static void main(String[] args) { ContainerMethodDifferences.main(args);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Collection: [add, addAll, clear, contains, containsAll, equals, hashCode, isEmpty, iterator, remove, removeAll, retainAll, size, toArray]</p>
<p>Interfaces in Collection: [Iterable]</p>
<p>Set extends Collection, adds: []</p>
<p>Interfaces in Set: [Collection]</p>
<p>HashSet extends Set, adds: []</p>
<p>Interfaces in HashSet: [Set, Cloneable, Serializable]</p>
<p>LinkedHashSet extends HashSet, adds: []</p>
<p>Interfaces in LinkedHashSet: [Set, Cloneable, Serializable]</p>
<p>TreeSet extends Set, adds: [pollLast, navigableHeadSet, descendingIterator, lower, headSet, ceiling, pollFirst, subSet, navigableTailSet, comparator, first, floor, last, navigableSubSet, higher, tailSet]</p>
<p>Interfaces in TreeSet: [NavigableSet, Cloneable, Serializable]</p>
<p>List extends Collection, adds: [listIterator, indexOf, get, subList, set, lastIndexOf]</p>
<p>Interfaces in List: [Collection]</p>
<p>ArrayList extends List, adds: [ensureCapacity, trimToSize]</p>
<p>Interfaces in ArrayList: [List, RandomAccess, Cloneable, Serializable] LinkedList extends List, adds: [pollLast, offer, descendingIterator, addFirst, peekLast, removeFirst, peekFirst, removeLast, getLast, pollFirst, pop, poll, addLast, removeFirstOccurrence, getFirst, element, peek, offerLast, push, offerFirst, removeLastOccurrence]</p>
<p>Interfaces in LinkedList: [List, Deque, Cloneable, Serializable]</p>
<p>Queue extends Collection, adds: [offer, element, peek, poll]</p>
<p>Interfaces in PriorityQueue Interfaces in Map: [clear,</p>
<p>Queue: [Collection] extends Queue, adds: [comparator]</p>
<p>PriorityQueue: [Serializable] containsKey, containsValue, entrySet, equals, get, hashCode, isEmpty, keySet, put, putAll, remove, size, values]</p>
<p>HashMap extends Map, adds: []</p>
<p>Interfaces in HashMap: [Map, Cloneable, Serializable]</p>
<p>LinkedHashMap extends HashMap, adds: []</p>
<p>Interfaces in LinkedHashMap: [Map]</p>
<p>SortedMap extends Map, adds: [subMap, comparator, firstKey, lastKey, headMap, tailMap]</p>
<p>Interfaces in SortedMap: [Map]</p>
<p>TreeMap extends Map, adds: [descendingEntrySet, subMap, pollLastEntry, lastKey, floorEntry, lastEntry, lowerKey, navigableHeadMap, navigableTailMap, descendingKeySet, tailMap, ceilingEntry, higherKey, pollFirstEntry, comparator, firstKey, floorKey, higherEntry, firstEntry, navigableSubMap, headMap, lowerEntry, ceilingKey]</p>
<p>Interfaces in TreeMap: [NavigableMap, Cloneable, Serializable]</p>
<p>*///:~</p>
<p>You can see that all Sets except TreeSet have exactly the same interface as Collection. List and Collection differ significantly, although List requires methods that are in Collection. On the other hand, the methods in the Queue interface stand alone; the Collection methods are not required to create a functioning Queue implementation. Finally, the only intersection between Map and Collection is the fact that a Map can produce Collections using the entrySet( ) and values( ) methods.</p>
<p>Notice the tagging interface java.util.RandomAccess, which is attached to ArrayList but not to LinkedList. This provides information for algorithms that might want to dynamically change their behavior depending on the use of a particular List.</p>
<p>It’s true that this organization is somewhat odd, as object-oriented hierarchies go. However, as you learn more about the containers in java.util (in particular, in the Containers in Depth chapter), you’ll see that there are more issues than just a slightly odd inheritance structure. Container libraries have always been difficult design problems—solving these problems involves satisfying a set of forces that often oppose each other. So you should be prepared for some compromises here and there. Despite these issues, the Java containers are fundamental tools that you can use on a day-to-day basis to make your programs simpler, more powerful, and more effective. It might take you a little while to get comfortable with some aspects of the library, but I think you’ll find yourself rapidly acquiring and using the classes in this library.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Error Handling with Exceptions</p></title><empty-line/>
<p>The basic philosophy of Java is that &quot;badly formed code will not be run.&quot;</p>
<p>The ideal time to catch an error is at compile time, before you even try to run the program. However, not all errors can be detected at compile time. The rest of the problems must be handled at run time through some formality that allows the originator of the error to pass appropriate information to a recipient who will know how to handle the difficulty properly.</p>
<p>Improved error recovery is one of the most powerful ways that you can increase the robustness of your code. Error recovery is a fundamental concern for every program you write, but it’s especially important in Java, where one of the primary goals is to create program components for others to use. To create a robust system, each component must be robust. By providing a consistent error-reporting model using exceptions, Java allows components to reliably communicate problems to client code.</p>
<p>The goals for exception handling in Java are to simplify the creation of large, reliable programs using less code than currently possible, and to do so with more confidence that your application doesn’t have an unhandled error. Exceptions are not terribly difficult to learn, and are one of those features that provide immediate and significant benefits to your project.</p>
<p>Because exception handling is the only official way that Java reports errors, and it is enforced by the Java compiler, there are only so many examples that can be written in this book without learning about exception handling. This chapter introduces you to the code that you need to write to properly handle exceptions, and shows how you can generate your own exceptions if one of your methods gets into trouble.</p>
<section>
<title>
<p>Concepts</p></title><empty-line/>
<p>C and other earlier languages often had multiple error-handling schemes, and these were generally established by convention and not as part of the programming language. Typically, you returned a special value or set a flag, and the recipient was supposed to look at the value or the flag and determine that something was amiss. However, as the years passed, it was discovered that programmers who use a library tend to think of themselves as invincible—as in &quot;Yes, errors might happen to others, but not in my code.&quot; So, not too surprisingly, they wouldn’t check for the error conditions (and sometimes the error conditions were too silly to check for<a l:href="#bookmark44" type="note"><sup>45</sup></a><sup></sup>). If you were thorough enough to check for an error every time you called a method, your code could turn into an unreadable nightmare. Because programmers could still coax systems out of these languages, they were resistant to admitting the truth: that this approach to handling errors was a major limitation to creating large, robust, maintainable programs.</p>
<p>The solution is to take the casual nature out of error handling and to enforce formality. This actually has a long history, because implementations of exception handling go back to operating systems in the 1960s, and even to BASIC’S &quot;on error goto.&quot; But C++ exception handling was based on Ada, and Java’s is based primarily on C++ (although it looks more like Object Pascal).</p>
<p>The word &quot;exception&quot; is meant in the sense of &quot;I take exception to that.&quot; At the point where the problem occurs, you might not know what to do with it, but you do know that you can’t just continue on merrily; you must stop, and somebody, somewhere, must figure out what to do. But you don’t have enough information in the current context to fix the problem. So you hand the problem out to a higher context where someone is qualified to make the proper decision.</p>
<p>The other rather significant benefit of exceptions is that they tend to reduce the complexity of error-handling code. Without exceptions, you must check for a particular error and deal with it at multiple places in your program. With exceptions, you no longer need to check for errors at the point of the method call, since the exception will guarantee that someone catches it. You only need to handle the problem in one place, in the so-called exception handler. This saves you code, and it separates the code that describes what you want to do during normal execution from the code that is executed when things go awry. In general, reading, writing, and debugging code becomes much clearer with exceptions than when using the old way of error handling.</p>
</section>
<section>
<title>
<p>Basic exceptions</p></title><empty-line/>
<p>An exceptional condition is a problem that prevents the continuation of the current method or scope. It’s important to distinguish an exceptional condition from a normal problem, in which you have enough information in the current context to somehow cope with the difficulty. With an exceptional condition, you cannot continue processing because you don’t have the information necessary to deal with the problem in the current context. All you can do is jump out of the current context and relegate that problem to a higher context. This is what happens when you throw an exception.</p>
<p>Division is a simple example. If you’re about to divide by zero, it’s worth checking for that condition. But what does it mean that the denominator is zero? Maybe you know, in the context of the problem you’re trying to solve in that particular method, how to deal with a zero denominator. But if it’s an unexpected value, you can’t deal with it and so must throw an exception rather than continuing along that execution path.</p>
<p>When you throw an exception, several things happen. First, the exception object is created in the same way that any Java object is created: on the heap, with new. Then the current path of execution (the one you couldn’t continue) is stopped and the reference for the exception object is ejected from the current context. At this point the exception-handling mechanism takes over and begins to look for an appropriate place to continue executing the program. This appropriate place is the exception handler, whose job is to recover from the problem so the program can either try another tack or just continue.</p>
<p>As a simple example of throwing an exception, consider an object reference called t. It’s possible that you might be passed a reference that hasn’t been initialized, so you might want to check before trying to call a method using that object reference. You can send information about the error into a larger context by creating an object representing your information and &quot;throwing&quot; it out of your current context. This is called throwing an exception. Here’s what it looks like:</p>
<p>if(t == null)</p>
<p>throw new NullPointerException();</p>
<p>This throws the exception, which allows you—in the current context—to abdicate responsibility for thinking about the issue further. It’s just magically handled somewhere else. Precisely where will be shown shortly.</p>
<p>Exceptions allow you to think of everything that you do as a transaction, and the exceptions guard those transactions: &quot;...the fundamental premise of transactions is that we needed exception handling in distributed computations. Transactions are the computer equivalent of contract law. If anything goes wrong, we’ll just blow away the whole computation.&quot;<a l:href="#bookmark45" type="note"><sup>46</sup></a><sup></sup> You can also think about exceptions as a built-in undo system, because (with some care) you can have various recovery points in your program. If a part of the program fails, the exception will &quot;undo&quot; back to a known stable point in the program.</p>
<p>One of the most important aspects of exceptions is that if something bad happens, they don’t allow a program to continue along its ordinary path. This has been a real problem in languages like C and C++; especially C, which had no way to force a program to stop going down a path if a problem occurred, so it was possible to ignore problems for a long time and get into a completely inappropriate state. Exceptions allow you to (if nothing else) force the program to stop and tell you what went wrong, or (ideally) force the program to deal with the problem and return to a stable state.</p>
<subtitle>Exception arguments</subtitle>
<p>As with any object in Java, you always create exceptions on the heap using new, which allocates storage and calls a constructor. There are two constructors in all standard exceptions: The first is the default constructor, and the second takes a string argument so that you can place pertinent information in the exception:</p>
<p>throw new NullPointerException(&quot;t = null&quot;);</p>
<p>This string can later be extracted using various methods, as you’ll see.</p>
<p>The keyword throw produces a number of interesting results. After creating an exception object with new, you give the resulting reference to throw. The object is, in effect,</p>
<p>&quot;returned&quot; from the method, even though that object type isn’t normally what the method is designed to return. A simplistic way to think about exception handling is as a different kind of return mechanism, although you get into trouble if you take that analogy too far. You can also exit from ordinary scopes by throwing an exception. In either case, an exception object is returned, and the method or scope exits.</p>
<p>Any similarity to an ordinary return from a method ends here, because where you return is someplace completely different from where you return for a normal method call. (You end up in an appropriate exception handler that might be far away—many levels on the call stack— from where the exception was thrown.)</p>
<p>In addition, you can throw any type of Throwable, which is the exception root class. Typically, you’ll throw a different class of exception for each different type of error. The information about the error is represented both inside the exception object and implicitly in the name of the exception class, so someone in the bigger context can figure out what to do with your exception. (Often, the only information is the type of exception, and nothing meaningful is stored within the exception object.)</p>
</section>
<section>
<title>
<p>Catching an exception</p></title><empty-line/>
<p>To see how an exception is caught, you must first understand the concept of a guarded region. This is a section of code that might produce exceptions and is followed by the code to handle those exceptions.</p>
<subtitle>The try block</subtitle>
<p>If you’re inside a method and you throw an exception (or another method that you call within this method throws an exception), that method will exit in the process of throwing. If you don’t want a throw to exit the method, you can set up a special block within that method to capture the exception. This is called the try block because you &quot;try&quot; your various method calls there. The try block is an ordinary scope preceded by the keyword try:</p>
<p>try {</p>
<p>// Code that might generate exceptions</p>
<p>}</p>
<p>If you were checking for errors carefully in a programming language that didn’t support exception handling, you’d have to surround every method call with setup and error-testing code, even if you call the same method several times. With exception handling, you put everything in a try block and capture all the exceptions in one place. This means your code is much easier to write and read because the goal of the code is not confused with the error checking.</p>
<subtitle>Exception handlers</subtitle>
<p>Of course, the thrown exception must end up someplace. This &quot;place&quot; is the exception handler, and there’s one for every exception type you want to catch. Exception handlers immediately follow the try block and are denoted by the keyword catch:</p>
<p>try {</p>
<p>// Code that might generate exceptions } catch(Type1 id1)|{</p>
<p>// Handle exceptions of Typel } catch(Type2 id2) {</p>
<p>// Handle exceptions of Type2 } catch(Type3 id3) {</p>
<p>// Handle exceptions of Type3</p>
<p>}</p>
<p>// etc...</p>
<p>Each catch clause (exception handler) is like a little method that takes one and only one argument of a particular type. The identifier (idi, id2, and so on) can be used inside the handler, just like a method argument. Sometimes you never use the identifier because the type of the exception gives you enough information to deal with the exception, but the identifier must still be there.</p>
<p>The handlers must appear directly after the try block. If an exception is thrown, the exception-handling mechanism goes hunting for the first handler with an argument that matches the type of the exception. Then it enters that catch clause, and the exception is considered handled. The search for handlers stops once the catch clause is finished. Only the matching catch clause executes; it’s not like a switch statement in which you need a break after each case to prevent the remaining ones from executing. Note that within the try block, a number of different method calls might generate the same exception, but you need only one handler.</p>
<p>Termination vs. resumption</p>
<p>There are two basic models in exception-handling theory. Java supportst termination,<a l:href="#bookmark46" type="note"><sup>47</sup></a><sup></sup> in which you assume that the error is so critical that there’s no way to get back to where the exception occurred. Whoever threw the exception decided that there was no way to salvage the situation, and they don’t want to come back.</p>
<p>The alternative is called resumption. It means that the exception handler is expected to do something to rectify the situation, and then the faulting method is retried, presuming success the second time. If you want resumption, it means you still hope to continue execution after the exception is handled.</p>
<p>If you want resumption-like behavior in Java, don’t throw an exception when you encounter an error. Instead, call a method that fixes the problem. Alternatively, place your try block inside a while loop that keeps reentering the try block until the result is satisfactory.</p>
<p>Historically, programmers using operating systems that supported resumptive exception handling eventually ended up using termination-like code and skipping resumption. So although resumption sounds attractive at first, it isn’t quite so useful in practice. The dominant reason is probably the coupling that results: A resumptive handler would need to be aware of where the exception is thrown, and contain non-generic code specific to the throwing location. This makes the code difficult to write and maintain, especially for large systems where the exception can be generated from many points.</p>
</section>
<section>
<title>
<p>Creating your own exceptions</p></title><empty-line/>
<p>You’re not stuck using the existing Java exceptions. The Java exception hierarchy can’t foresee all the errors you might want to report, so you can create your own to denote a special problem that your library might encounter.</p>
<p>To create your own exception class, you must inherit from an existing exception class, preferably one that is close in meaning to your new exception (although this is often not possible). The most trivial way to create a new type of exception is just to let the compiler create the default constructor for you, so it requires almost no code at all:</p>
<p>//: exceptions/InheritingExceptions.java // Creating your own exceptions.</p>
<p>class SimpleException extends Exception {}</p>
<p>public class InheritingExceptions {</p>
<p>public void f() throws SimpleException {</p>
<p>System.out.println(&quot;Throw SimpleException from f()&quot;); throw new SimpleException();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>InheritingExceptions sed = new InheritingExceptions(); try { sed.f();</p>
<p>} catch(SimpleException e) {</p>
<p>System.out.println(&quot;Caught it!&quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Throw SimpleException from f()</p>
<p>Caught it! *///:~</p>
<p>The compiler creates a default constructor, which automatically (and invisibly) calls the base-class default constructor. Of course, in this case you don’t get a SimpleException(String) constructor, but in practice that isn’t used much. As you’ll see, the most important thing about an exception is the class name, so most of the time an exception like the one shown here is satisfactory.</p>
<p>Here, the result is printed to the console, where it is automatically captured and tested with this book’s output-display system. However, you may want to send error output to the standard error stream by writing to System.err. This is usually a better place to send error information than System.out, which may be redirected. If you send output to System.err, it will not be redirected along with System.out so the user is more likely to notice it. You can also create an exception class that has a constructor with a String argument:</p>
<p>//: exceptions/FullConstructors.java</p>
<p>class MyException extends Exception { public MyException() {}</p>
<p>public MyException(String msg) { super(msg); }</p>
<p>}</p>
<p>public class FullConstructors {</p>
<p>public static void f() throws MyException {</p>
<p>System.out.println(&quot;Throwing MyException from f()&quot;); throw new MyException();</p>
<p>}</p>
<p>public static void g() throws MyException {</p>
<p>System.out.println(&quot;Throwing MyException from g()&quot;); throw new MyException(&quot;Originated in g()&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { try { f();</p>
<p>} catch(MyException e) {</p>
<p>e.printStackTrace(System.out);</p>
<p>}</p>
<p>try { g();</p>
<p>} catch(MyException e) {</p>
<p>e.printStackTrace(System.out);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Throwing MyException from f()</p>
<p>MyException</p>
<p>at FullConstructors.f(FullConstructors.java:11) at FullConstructors.main(FullConstructors.java:19)</p>
<p>Throwing MyException from g()</p>
<p>MyException: Originated in g()</p>
<p>at FullConstructors.g(FullConstructors.java:15) at FullConstructors.main(FullConstructors.java:24)</p>
<p>*///:~</p>
<p>The added code is small: two constructors that define the way MyException is created. In the second constructor, the base-class constructor with a String argument is explicitly invoked by using the super keyword.</p>
<p>In the handlers, one of the Throwable (from which Exception is inherited) methods is called: printStackTrace( ). As you can see from the output, this produces information about the sequence of methods that were called to get to the point where the exception happened. Here, the information is sent to System.out, and automatically captured and displayed in the output. However, if you call the default version:</p>
<p>e.printStackTrace();</p>
<p>the information goes to the standard error stream.</p>
<p>Exercise 1: (2) Create a class with a main( ) that throws an object of class Exception inside a try block. Give the constructor for Exception a String argument. Catch the exception inside a catch clause and print the String argument. Add a finally clause and print a message to prove you were there.</p>
<p>Exercise 2: (1) Define an object reference and initialize it to null. Try to call a method through this reference. Now wrap the code in a try-catch clause to catch the exception.</p>
<p>Exercise 3: (1) Write code to generate and catch an ArraylndexOutOfBoundsException.</p>
<p>Exercise 4: (2) Create your own exception class using the extends keyword. Write a constructor for this class that takes a String argument and stores it inside the object with a String reference. Write a method that displays the stored String. Create a try-catch clause to exercise your new exception.</p>
<p>Exercise 5: (3) Create your own resumption-like behavior using a while loop that repeats until an exception is no longer thrown.</p>
<subtitle>Exceptions and logging</subtitle>
<p>You may also want to log the output using the java.util.logging facility. Although full details of logging are introduced in the supplement at</p>
<p><a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a>, basic logging is straightforward enough to be used here.</p>
<p>//: exceptions/LoggingExceptions.java // An exception that reports through a Logger. import java.util.logging.*; import java.io.*;</p>
<p>class LoggingException extends Exception { private static Logger logger =</p>
<p>Logger.getLogger(&quot;LoggingException&quot;); public LoggingException() {</p>
<p>StringWriter trace = new StringWriter(); printStackTrace(new PrintWriter(trace)); logger.severe(trace.toString());</p>
<p>}</p>
<p>}</p>
<p>public class LoggingExceptions {</p>
<p>public static void main(String[] args) { try {</p>
<p>throw new LoggingException();</p>
<p>} catch(LoggingException e) {</p>
<p>System.err.println(&quot;Caught &quot; + e);</p>
<p>}</p>
<p>try {</p>
<p>throw new LoggingException();</p>
<p>} catch(LoggingException e) {</p>
<p>System.err.println(&quot;Caught &quot; + e);</p>
<p>}</p>
<p>}</p>
<p>} /* Output: (85% match)</p>
<p>Aug 30, 2005 4:02:31 PM LoggingException &lt;init&gt;</p>
<p>SEVERE: LoggingException</p>
<p>at LoggingExceptions.main(LoggingExceptions.java:19) Caught LoggingException</p>
<p>Aug 30, 2005 4:02:31 PM LoggingException &lt;init&gt;</p>
<p>SEVERE: LoggingException</p>
<p>at LoggingExceptions.main(LoggingExceptions.java:24)</p>
<p>Caught LoggingException *///:~</p>
<p>The static Logger.getLogger( ) method creates a Logger object associated with the String argument (usually the name of the package and class that the errors are about) which sends its output to System.err. The easiest way to write to a Logger is just to call the method associated with the level of logging message; here, severe( ) is used. To produce the String for the logging message, we’d like to have the stack trace where the exception is thrown, but printStackTrace( ) doesn’t produce a String by default. To get a String, we need to use the overloaded printStackTrace( ) that takes a java.io.PrintWriter object as an argument (all of this will be fully explained in the I/O chapter). If we hand the Print Writer constructor a java.io.StringWriter object, the output can be extracted as a String by calling toString( ).</p>
<p>Although the approach used by LoggingException is very convenient because it builds all the logging infrastructure into the exception itself, and thus it works automatically without client programmer intervention, it’s more common that you will be catching and logging someone else’s exception, so you must generate the log message in the exception handler:</p>
<p>//: exceptions/LoggingExceptions2.java // Logging caught exceptions. import java.util.logging.*; import java.io.*;</p>
<p>public class LoggingExceptions2 { private static Logger logger =</p>
<p>Logger.getLogger(&quot;LoggingExceptions2&quot;); static void logException(Exception e) {</p>
<p>StringWriter trace = new StringWriter(); e.printStackTrace(new PrintWriter(trace)); logger.severe(trace.toString());</p>
<p>}</p>
<p>public static void main(String[] args) { try {</p>
<p>throw new NullPointerException();</p>
<p>} catch(NullPointerException e) { logException(e);</p>
<p>}</p>
<p>}</p>
<p>} /* Output: (90% match)</p>
<p>Aug 30, 2005 4:07:54 PM LoggingExceptions2 logException SEVERE: java.lang.NullPointerException</p>
<p>at LoggingExceptions2.main(LoggingExceptions2.java:16)</p>
<p>*///:~</p>
<p>The process of creating your own exceptions can be taken further. You can add extra constructors and members: //: exceptions/ExtraFeatures.java</p>
<p>// Further embellishment of exception classes.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class MyException2 extends Exception { private int x; public MyException2() {}</p>
<p>public MyException2(String msg) { super(msg); } public MyException2(String msg, int x) { super(msg); this.x = x;</p>
<p>}</p>
<p>public int val() { return x; } public String getMessage() {</p>
<p>return &quot;Detail Message: &quot;+ x + &quot; &quot;+ super.getMessage();</p>
<p>}</p>
<p>}</p>
<p>public class ExtraFeatures {</p>
<p>public static void f() throws MyException2 { print(&quot;Throwing MyException2 from f()&quot;); throw new MyException2();</p>
<p>}</p>
<p>public static void g() throws MyException2 { print(&quot;Throwing MyException2 from g()&quot;); throw new MyException2(&quot;Originated in g()&quot;);</p>
<p>}</p>
<p>public static void h() throws MyException2 { print(&quot;Throwing MyException2 from h()&quot;); throw new MyException2(&quot;Originated in h()&quot;, 47);</p>
<p>}</p>
<p>public static void main(String[] args) { try { f();</p>
<p>} catch(MyException2 e) {</p>
<p>e.printStackTrace(System.out);</p>
<p>}</p>
<p>try { g();</p>
<p>} catch(MyException2 e) {</p>
<p>e.printStackTrace(System.out);</p>
<p>}</p>
<p>try { h();</p>
<p>} catch(MyException2 e) {</p>
<p>e.printStackTrace(System.out); System.out.println(&quot;e.val() = &quot; + e.val());</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Throwing MyException2 from f()</p>
<p>MyException2: Detail Message: 0 null</p>
<p>at ExtraFeatures.f(ExtraFeatures.java:22) at ExtraFeatures.main(ExtraFeatures.java:34) Throwing MyException2 from g()</p>
<p>MyException2: Detail Message: 0 Originated in g() at ExtraFeatures.g(ExtraFeatures.java:26) at ExtraFeatures.main(ExtraFeatures.java:39) Throwing MyException2 from h()</p>
<p>MyException2: Detail Message: 47 Originated in h() at ExtraFeatures.h(ExtraFeatures.java:30) at ExtraFeatures.main(ExtraFeatures.java:44) e.val() = 47</p>
<p>A field x has been added, along with a method that reads that value and an additional constructor that sets it. In addition, Throwable.getMessage( ) has been overridden to produce a more interesting detail message. getMessage( ) is something like toString( ) for exception classes.</p>
<p>Since an exception is just another kind of object, you can continue this process of embellishing the power of your exception classes. Keep in mind, however, that all this dressing-up might be lost on the client programmers using your packages, since they might simply look for the exception to be thrown and nothing more. (That’s the way most of the Java library exceptions are used.)</p>
<p>Exercise 6: (1) Create two exception classes, each of which performs its own logging automatically. Demonstrate that these work.</p>
<p>Exercise 7: (1) Modify Exercise 3 so that the catch clause logs the results.</p>
</section>
<section>
<title>
<p>The exception specification</p></title><empty-line/>
<p>In Java, you’re encouraged to inform the client programmer, who calls your method, of the exceptions that might be thrown from your method. This is civilized, because the caller can then know exactly what code to write to catch all potential exceptions. Of course, if the source code is available, the client programmer could hunt through and look for throw statements, but a library might not come with sources. To prevent this from being a problem, Java provides syntax (and forces you to use that syntax) to allow you to politely tell the client programmer what exceptions this method throws, so the client programmer can handle them. This is the exception specification and it’s part of the method declaration, appearing after the argument list.</p>
<p>The exception specification uses an additional keyword, throws, followed by a list of all the potential exception types. So your method definition might look like this:</p>
<p>void f() throws TooBig, TooSmall, DivZero { //...</p>
<p>However, if you say</p>
<p>void f() { //...</p>
<p>it means that no exceptions are thrown from the method {except for the exceptions inherited from RuntimeException, which can be thrown anywhere without exception specifications—these will be described later).</p>
<p>You can’t lie about an exception specification. If the code within your method causes exceptions, but your method doesn’t handle them, the compiler will detect this and tell you that you must either handle the exception or indicate with an exception specification that it may be thrown from your method. By enforcing exception specifications from top to bottom, Java guarantees that a certain level of exception correctness can be ensured at compile time.</p>
<p>There is one place you can lie: You can claim to throw an exception that you really don’t. The compiler takes your word for it, and forces the users of your method to treat it as if it really does throw that exception. This has the beneficial effect of being a placeholder for that exception, so you can actually start throwing the exception later without requiring changes to existing code. It’s also important for creating abstract base classes and interfaces whose derived classes or implementations may need to throw exceptions.</p>
<p>Exceptions that are checked and enforced at compile time are called checked exceptions.</p>
<p>Exercise 8: (1) Write a class with a method that throws an exception of the type created in Exercise 4. Try compiling it without an exception specification to see what the compiler says. Add the appropriate exception specification. Try out your class and its exception inside a try-catch clause.</p>
</section>
<section>
<title>
<p>Catching any exception</p></title><empty-line/>
<p>It is possible to create a handler that catches any type of exception. You do this by catching the base-class exception type Exception (there are other types of base exceptions, but Exception is the base that’s pertinent to virtually all programming activities):</p>
<p>catch(Exception e) {</p>
<p>System.out.println(&quot;Caught an exception&quot;);</p>
<p>}</p>
<p>This will catch any exception, so if you use it you’ll want to put it at the end of your list of handlers to avoid preempting any exception handlers that might otherwise follow it.</p>
<p>Since the Exception class is the base of all the exception classes that are important to the programmer, you don’t get much specific information about the exception, but you can call the methods that come from its base type Throwable:</p>
<p>String getMessage( )</p>
<p>String getLocalizedMessage( )</p>
<p>Gets the detail message, or a message adjusted for this particular locale.</p>
<p>String toString( )</p>
<p>Returns a short description of the Throwable, including the detail message if there is one.</p>
<p>void printStackTrace( )</p>
<p>voidprintStackTrace(PrintStream)</p>
<p>voidprintStackTrace(java.io.PrintWriter)</p>
<p>Prints the Throwable and the Throwable’s call stack trace. The call stack shows the sequence of method calls that brought you to the point at which the exception was thrown. The first version prints to standard error, the second and third print to a stream of your choice (in the I/O chapter, you’ll understand why there are two types of streams).</p>
<p>Throwable fillInStackTrace( )</p>
<p>Records information within this Throwable object about the current state of the stack frames. Useful when an application is rethrowing an error or exception (more about this shortly).</p>
<p>In addition, you get some other methods from Throwable’s base type Object (everybody’s base type). The one that might come in handy for exceptions is getClass( ), which returns an object representing the class of this object. You can in turn query this Class object for its name with getName( ), which includes package information, or getSimpleName( ), which produces the class name alone.</p>
<p>Here’s an example that shows the use of the basic Exception methods:</p>
<p>//: exceptions/ExceptionMethods.java // Demonstrating the Exception Methods. import static net.mindview.util.Print.*;</p>
<p>public class ExceptionMethods {</p>
<p>public static void main(String[] args) { try {</p>
<p>throw new Exception(&quot;My Exception&quot;);</p>
<p>} catch(Exception e) {</p>
<p>print(&quot;Caught Exception&quot;); print(&quot;getMessage():&quot; + e.getMessage()); print(&quot;getLocalizedMessage():&quot; + e.getLocalizedMessage()); print(&quot;toString():&quot; + e); print(&quot;printStackTrace():&quot;); e.printStackTrace(System.out);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Caught Exception getMessage():My Exception getLocalizedMessage():My Exception toString():java.lang.Exception: My Exception printStackTrace(): java.lang.Exception: My Exception</p>
<p>at ExceptionMethods.main(ExceptionMethods.java:8)</p>
<p>*///:~</p>
<p>You can see that the methods provide successively more information-each is effectively a superset of the previous one.</p>
<p>Exercise 9: (2) Create three new types of exceptions. Write a class with a method that throws all three. In main( ), call the method but only use a single catch clause that will catch all three types of exceptions.</p>
<subtitle>The stack trace</subtitle>
<p>The information provided by printStackTrace( ) can also be accessed directly using getStackTrace( ). This method returns an array of stack trace elements, each representing one stack frame. Element zero is the top of the stack, and is the last method invocation in the sequence (the point this Throwable was created and thrown). The last element of the array and the bottom of the stack is the first method invocation in the sequence. This program provides a simple demonstration:</p>
<p>//: exceptions/WhoCalled.java</p>
<p>// Programmatic access to stack trace information.</p>
<p>public class WhoCalled { static void f() {</p>
<p>// Generate an exception to fill in the stack trace try {</p>
<p>throw new Exception();</p>
<p>} catch (Exception e) {</p>
<p>for(StackTraceElement ste : e.getStackTrace()) System.out.println(ste.getMethodName());</p>
<p>}</p>
<p>}</p>
<p>static void g() { f(); } static void h() { g(); } public static void main(String[] args) {</p>
<p>f();</p>
<p>System.out.println(&quot;--------------------------------&quot;);</p>
<p>g();</p>
<p>System.out.println(&quot;--------------------------------&quot;);</p>
<p>h();</p>
<p>} /* Output: f</p>
<p>main f</p>
<p>g</p>
<p>main f</p>
<p><sup>g</sup></p>
<p>h</p>
<p>main</p>
<p>*///:~</p>
<p>Here, we just print the method name, but you can also print the entire StackTraceElement, which contains additional information.</p>
<subtitle>Rethrowing an exception</subtitle>
<p>Sometimes you’ll want to rethrow the exception that you just caught, particularly when you use Exception to catch any exception. Since you already have the reference to the current exception, you can simply rethrow that reference:</p>
<p>catch(Exception e) {</p>
<p>System.out.println(&quot;An exception was thrown&quot;); throw e;</p>
<p>}</p>
<p>Rethrowing an exception causes it to go to the exception handlers in the nexthigher context. Any further catch clauses for the same try block are still ignored. In addition, everything about the exception object is preserved, so the handler at the higher context that catches the specific exception type can extract all the information from that object.</p>
<p>If you simply rethrow the current exception, the information that you print about that exception in printStackTrace( ) will pertain to the exception’s origin, not the place where you rethrow it. If you want to install new stack trace information, you can do so by calling fillInStackTrace( ), which returns a Throwable object that it creates by stuffing the current stack information into the old exception object. Here’s what it looks like:</p>
<p>//: exceptions/Rethrowing.java // Demonstrating fillInStackTrace()</p>
<p>public class Rethrowing {</p>
<p>public static void f() throws Exception {</p>
<p>System.out.println(&quot;originating the exception in f()&quot;); throw new Exception(&quot;thrown from f()&quot;);</p>
<p>}</p>
<p>public static void g() throws Exception { try { f();</p>
<p>} catch(Exception e) {</p>
<p>System.out.println(&quot;Inside g(),e.printStackTrace()&quot;);</p>
<p>e.printStackTrace(System.out);</p>
<p>throw e;</p>
<p>}</p>
<p>}</p>
<p>public static void h() throws Exception {</p>
<p>try { f();</p>
<p>} catch(Exception e) {</p>
<p>System.out.println(&quot;Inside h(),e.printStackTrace()&quot;);</p>
<p>e.printStackTrace(System.out);</p>
<p>throw (Exception)e.fillInStackTrace();</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>try { g();</p>
<p>} catch(Exception e) {</p>
<p>System.out.println(&quot;main: printStackTrace()&quot;); e.printStackTrace(System.out);</p>
<p>}</p>
<p>try { h();</p>
<p>} catch(Exception e) {</p>
<p>System.out.println(&quot;main: printStackTrace()&quot;); e.printStackTrace(System.out);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>originating the exception in f()</p>
<p>Inside g(),e.printStackTrace() java.lang.Exception: thrown from f()</p>
<p>at Rethrowing.f(Rethrowing.java:7) at Rethrowing.g(Rethrowing.java:11) at Rethrowing.main(Rethrowing.java:29) main: printStackTrace() java.lang.Exception: thrown from f()</p>
<p>at Rethrowing.f(Rethrowing.java:7) at Rethrowing.g(Rethrowing.java:11) at Rethrowing.main(Rethrowing.java:29) originating the exception in f()</p>
<p>Inside h(),e.printStackTrace() java.lang.Exception: thrown from f()</p>
<p>at Rethrowing.f(Rethrowing.java:7) at Rethrowing.h(Rethrowing.java:20) at Rethrowing.main(Rethrowing.java:35) main: printStackTrace() java.lang.Exception: thrown from f()</p>
<p>at Rethrowing.h(Rethrowing.java:24) at Rethrowing.main(Rethrowing.java:35)</p>
<p>*///:~</p>
<p>The line where fillInStackTrace( ) is called becomes the new point of origin of the exception.</p>
<p>It’s also possible to rethrow a different exception from the one you caught. If you do this, you get a similar effect as when you use fillInStackTrace( )— the information about the original site of the exception is lost, and what you’re left with is the information pertaining to the new throw:</p>
<p>//: exceptions/RethrowNew.java</p>
<p>// Rethrow a different object from the one that was caught.</p>
<p>class OneException extends Exception {</p>
<p>public OneException(String s) { super(s); }</p>
<p>}</p>
<p>class TwoException extends Exception {</p>
<p>public TwoException(String s) { super(s); }</p>
<p>public class RethrowNew {</p>
<p>public static void f() throws OneException {</p>
<p>System.out.println(&quot;originating the exception in f()&quot;); throw new OneException(&quot;thrown from f()&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { try { try { f();</p>
<p>} catch(OneException e) {</p>
<p>System.out.println(</p>
<p>&quot;Caught in inner try, e.printStackTrace()&quot;); e.printStackTrace(System.out); throw new TwoException(&quot;from inner try&quot;);</p>
<p>}</p>
<p>} catch(TwoException e) {</p>
<p>System.out.println(</p>
<p>&quot;Caught in outer try, e.printStackTrace()&quot;); e.printStackTrace(System.out);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>originating the exception in f()</p>
<p>Caught in inner try, e.printStackTrace()</p>
<p>OneException: thrown from f()</p>
<p>at RethrowNew.f(RethrowNew.java:15) at RethrowNew.main(RethrowNew.java:20)</p>
<p>Caught in outer try, e.printStackTrace()</p>
<p>TwoException: from inner try</p>
<p>at RethrowNew.main(RethrowNew.java:25)</p>
<p>*///:~</p>
<p>The final exception knows only that it came from the inner try block and not from f( ).</p>
<p>You never have to worry about cleaning up the previous exception, or any exceptions for that matter. They’re all heap-based objects created with new, so the garbage collector automatically cleans them all up.</p>
<subtitle>Exception chaining</subtitle>
<p>Often you want to catch one exception and throw another, but still keep the information about the originating exception—this is called exception chaining. Prior to JDK 1.4, programmers had to write their own code to preserve the original exception information, but now all Throwable subclasses have the option to take a cause object in their constructor. The cause is intended to be the originating exception, and by passing it in you maintain the stack trace back to its origin, even though you’re creating and throwing a new exception.</p>
<p>It’s interesting to note that the only Throwable subclasses that provide the cause argument in the constructor are the three fundamental exception classes Error (used by the JVM to report system errors), Exception, and RuntimeException. If you want to chain any other exception types, you do it through the initCause( ) method rather than the constructor.</p>
<p>Here’s an example that allows you to dynamically add fields to a DynamicFields object at run time:</p>
<p>//: exceptions/DynamicFields.java</p>
<p>class DynamicFieldsException extends Exception {}</p>
<p>public class DynamicFields { private Object[][] fields; public DynamicFields(int initialSize) { fields = new Object[initialSize][2]; for(int i = 0; i &lt; initialSize; i++)</p>
<p>fields[i] = new Object[] { null, null };</p>
<p>}</p>
<p>public String toString() {</p>
<p>StringBuilder result = new StringBuilder(); for(Object[] obj : fields) { result.append(obj[0]); result.append(&quot;: &quot;); result.append(obj[1]); result.append(&quot;\n&quot;);</p>
<p>}</p>
<p>return result.toString();</p>
<p>}</p>
<p>private int hasField(String id) {</p>
<p>for(int i = 0; i &lt; fields.length; i++) if(id.equals(fields[i][0])) return i; return -1;</p>
<p>}</p>
<p>private int</p>
<p>getFieldNumber(String id) throws NoSuchFieldException { int fieldNum = hasField(id); if(fieldNum == -1)</p>
<p>throw new NoSuchFieldException(); return fieldNum;</p>
<p>}</p>
<p>private int makeField(String id) {</p>
<p>for(int i = 0; i &lt; fields.length; i++) if(fields[i][0] == null) { fields[i][0] = id; return i;</p>
<p>}</p>
<p>// No empty fields. Add one:</p>
<p>Object[][] tmp = new Object[fields.length + 1][2]; for(int i = 0; i &lt; fields.length; i++) tmp[i] = fields[i];</p>
<p>for(int i = fields.length; i &lt; tmp.length; i++) tmp[i] = new Object[] { null, null }; fields = tmp;</p>
<p>// Recursive call with expanded fields: return makeField(id);</p>
<p>}</p>
<p>public Object</p>
<p>getField(String id) throws NoSuchFieldException { return fields[getFieldNumber(id)][1];</p>
<p>}</p>
<p>public Object setField(String id, Object value) throws DynamicFieldsException { if(value == null) {</p>
<p>// Most exceptions don’t have a &quot;cause&quot; constructor. // In these cases you must use initCause(),</p>
<p>// available in all Throwable subclasses. DynamicFieldsException dfe =</p>
<p>new DynamicFieldsException(); dfe.initCause(new NullPointerException()); throw dfe;</p>
<p>int fieldNumber = hasField(id); if(fieldNumber == -1)</p>
<p>fieldNumber = makeField(id);</p>
<p>Object result = null; try {</p>
<p>result = getField(id); // Get old value } catch(NoSuchFieldException e) {</p>
<p>// Use constructor that takes &quot;cause&quot;: throw new RuntimeException(e);</p>
<p>}</p>
<p>fields[fieldNumber][1] = value; return result;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>DynamicFields df = new DynamicFields(3);</p>
<p>print(df);</p>
<p>try {</p>
<p>df.setField(&quot;d&quot;, &quot;A value for d&quot;); df.setField(&quot;number&quot;, 47); df.setField(&quot;number2&quot;, 48); print(df);</p>
<p>df.setField(&quot;d&quot;, &quot;A new value for d&quot;); df.setField(&quot;number3&quot;, 11); print(&quot;df: &quot; + df);</p>
<p>print(&quot;df.getField(\&quot;d\&quot;) : &quot; + df.getField(&quot;d&quot;)); Object field = df.setField(&quot;d&quot;, null); // Exception } catch(NoSuchFieldException e) { e.printStackTrace(System.out);</p>
<p>} catch(DynamicFieldsException e) { e.printStackTrace(System.out);</p>
<p>}</p>
<p>}</p>
<p>} /* Output: null: null null: null null: null</p>
<p>d: A value for d number: 47 number2: 48</p>
<p>df: d: A new value for d number: 47 number2: 48 number3: 11</p>
<p>df.getField(&quot;d&quot;) : A new value for d DynamicFieldsException</p>
<p>at DynamicFields.setField(DynamicFields.java:64) at DynamicFields.main(DynamicFields.java:94) Caused by: java.lang.NullPointerException</p>
<p>at DynamicFields.setField(DynamicFields.java:66) ... 1 more</p>
<p>*///:~</p>
<p>Each DynamicFields object contains an array of Object-Object pairs. The first object is the field identifier (a String), and the second is the field value, which can be any type except an unwrapped primitive. When you create the object, you make an educated guess about how many fields you need. When you call setField( ), it either finds the existing field by that</p>
<p>name or creates a new one, and puts in your value. If it runs out of space, it adds new space by creating an array of length one longer and copying the old elements in. If you try to put in a null value, then it throws a DynamicFieldsException by creating one and using initCause( ) to insert a NullPointerException as the cause.</p>
<p>As a return value, setField( ) also fetches out the old value at that field location using getField( ), which could throw a NoSuchFieldException. If the client programmer calls getField( ), then they are responsible for handling NoSuchFieldException, but if this exception is thrown inside setField( ), it’s a programming error, so the NoSuchFieldException is converted to a RuntimeException using the constructor that takes a cause argument.</p>
<p>You’ll notice that toString( ) uses a StringBuilder to create its result. You’ll learn more about StringBuilder in the Strings chapter, but in general you’ll want to use it whenever you’re writing a toString( ) that involves looping, as is the case here.</p>
<p>Exercise 10: (2) Create a class with two methods, f( ) and g( ). In g( ), throw an exception of a new type that you define. In f( ), call g( ), catch its exception and, in the catch clause, throw a different exception (of a second type that you define). Test your code in main( ).</p>
<p>Exercise 11: (1) Repeat the previous exercise, but inside the catch clause, wrap g( )’s exception in a RuntimeException.</p>
</section>
<section>
<title>
<p>Standard Java exceptions</p></title><empty-line/>
<p>The Java class Throwable describes anything that can be thrown as an exception. There are two general types of Throwable objects (&quot;types of = &quot;inherited from&quot;). Error represents compile-time and system errors that you don’t worry about catching (except in very special cases). Exception is the basic type that can be thrown from any of the standard Java library class methods and from your methods and runtime accidents. So the Java programmer’s base type of interest is usually Exception.</p>
<p>The best way to get an overview of the exceptions is to browse the JDK documentation. It’s worth doing this once just to get a feel for the various exceptions, but you’ll soon see that there isn’t anything special between one exception and the next except for the name. Also, the number of exceptions in Java keeps expanding; basically, it’s pointless to print them in a book. Any new library you get from a third-party vendor will probably have its own exceptions as well. The important thing to understand is the concept and what you should do with the exceptions.</p>
<p>The basic idea is that the name of the exception represents the problem that occurred, and the exception name is intended to be relatively selfexplanatory. The exceptions are not all defined in java.lang; some are created to support other libraries such as util, net, and io, which you can see from their full class names or what they are inherited from. For example, all I/O exceptions are inherited from java.io.IOException.</p>
<subtitle>Special case: RuntimeException</subtitle>
<p>The first example in this chapter was if(t == null)</p>
<p>throw new NullPointerException();</p>
<p>It can be a bit horrifying to think that you must check for null on every reference that is passed into a method (since you can’t know if the caller has passed you a valid reference). Fortunately, you don’t—this is part of the standard runtime checking that Java performs for you, and if any call is made to a null reference, Java will automatically throw a NullPointerException. So the above bit of code is always superfluous, although you may want to perform other checks in order to guard against the appearance of a NullPointerException.</p>
<p>There’s a whole group of exception types that are in this category. They’re always thrown automatically by Java and you don’t need to include them in your exception specifications. Conveniently enough, they’re all grouped together by putting them under a single base class called RuntimeException, which is a perfect example of inheritance: It establishes a family of types that have some characteristics and behaviors in common. Also, you never need to write an exception specification saying that a method might throw a RuntimeException (or any type inherited from RuntimeException), because they are unchecked exceptions. Because they indicate bugs, you don’t usually catch a RuntimeException—it’s dealt with automatically. If you were forced to check for RuntimeExceptions, your code could get too messy. Even though you don’t typically catch RuntimeExceptions, in your own packages you might choose to throw some of the RuntimeExceptions.</p>
<p>What happens when you don’t catch such exceptions? Since the compiler doesn’t enforce exception specifications for these, it’s quite plausible that a RuntimeException could percolate all the way out to your main( ) method without being caught. To see what happens in this case, try the following example:</p>
<p>//: exceptions/NeverCaught.java // Ignoring RuntimeExceptions.</p>
<p>// {ThrowsException}</p>
<p>public class NeverCaught { static void f() {</p>
<p>throw new RuntimeException(&quot;From f()&quot;);</p>
<p>}</p>
<p>static void g() { f();</p>
<p>}</p>
<p>public static void main(String[] args) { g();</p>
<p>}</p>
<p>} ///:~</p>
<p>You can already see that a RuntimeException (or anything inherited from it) is a special case, since the compiler doesn’t require an exception specification for these types. The output is reported to System.err:</p>
<p>Exception in thread &quot;main&quot; Java.lang.RuntimeException: From f() at NeverCaught.f(NeverCaught.Java:7) at NeverCaught.g(NeverCaught.Java:10) at NeverCaught.main(NeverCaught.Java:13)</p>
<p>So the answer is: If a RuntimeException gets all the way out to main( ) without being caught, printStackTrace( ) is called for that exception as the program exits.</p>
<p>Keep in mind that only exceptions of type RuntimeException (and subclasses) can be ignored in your coding, since the compiler carefully enforces the handling of all checked exceptions. The reasoning is that a RuntimeException represents a programming error, which is:</p>
<p>1.    An error you cannot anticipate. For example, a null reference that is outside of your control.</p>
<p>2.    An error that you, as a programmer, should have checked for in your code (such as ArraylndexOutOfBoundsException where you should have paid attention to the size of the array). An exception that happens from point #1 often becomes an issue for point #2.</p>
<p>You can see what a tremendous benefit it is to have exceptions in this case, since they help in the debugging process.</p>
<p>It’s interesting to notice that you cannot classify Java exception handling as a single-purpose tool. Yes, it is designed to handle those pesky runtime errors that will occur because of forces outside your code’s control, but it’s also essential for certain types of programming bugs that the compiler cannot detect.</p>
<p>Exercise 12: (3) Modify innerclasses/Sequence.java so that it throws an appropriate exception if you try to put in too many elements.</p>
</section>
<section>
<title>
<p>Performing cleanup with finally</p></title><empty-line/>
<p>There’s often some piece of code that you want to execute whether or not an exception is thrown within a try block. This usually pertains to some operation other than memory recovery (since that’s taken care of by the garbage collector). To achieve this effect, you use a finally clause<a l:href="#bookmark47" type="note"><sup>48</sup></a><sup></sup> at the end of all the exception handlers. The full picture of an exceptionhandling section is thus:</p>
<p>try {</p>
<p>// The guarded region: Dangerous activities // that might throw A, B, or C } catch(A a1) {</p>
<p>// Handler for situation A } catch(B b1) {</p>
<p>// Handler for situation B } catch(C cl) {</p>
<p>// Handler for situation C } finally {</p>
<p>// Activities that happen every time</p>
<p>}</p>
<p>To demonstrate that the finally clause always runs, try this program:</p>
<p>//: exceptions/FinallyWorks.java</p>
<p>// The finally clause is always executed.</p>
<p>class ThreeException extends Exception {}</p>
<p>public class FinallyWorks { static int count = 0;</p>
<p>public static void main(String[] args) { while(true) { try {</p>
<p>// Post-increment is zero first time: if(count++ == 0)</p>
<p>throw new ThreeException(); System.out.println(&quot;No exception&quot;);</p>
<p>} catch(ThreeException e) {</p>
<p>System.out.println(&quot;ThreeException&quot;);</p>
<p>} finally {</p>
<p>System.out.println(&quot;In finally clause&quot;); if(count == 2) break; // out of &quot;while&quot;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>ThreeException In finally clause No exception In finally clause *///:~</p>
<p>From the output, you can see that the finally clause is executed whether or not an exception is thrown.</p>
<p>This program also gives a hint for how you can deal with the fact that exceptions in Java do not allow you to resume back to where the exception was thrown, as discussed earlier. If you place your try block in a loop, you can establish a condition that must be met before you continue the program. You can also add a static counter or some other device to allow the loop to try several different approaches before giving up. This way you can build a greater level of robustness into your programs.</p>
<subtitle>What&apos;s finally for?</subtitle>
<p>In a language without garbage collection and without automatic destructor calls,<sup>5</sup> finally is important because it allows the programmer to guarantee the release of memory regardless of what happens in the try block. But Java has garbage collection, so releasing memory is virtually never a problem. Also, it has no destructors to call. So when do you need to use finally in Java?</p>
<p>The finally clause is necessary when you need to set something other than memory back to its original state. This is some kind of cleanup like an open file or network connection, something you’ve drawn on the screen, or even a switch in the outside world, as modeled in the following example:</p>
<p>//: exceptions/Switch.java import static net.mindview.util.Print.*;</p>
<p>public class Switch {</p>
<p>}</p>
<p>&quot;off&quot;; }</p>
<p>///:~</p>
<p>always know exactly where and when</p>
<p>private boolean state = false; public boolean read() { return state; } public void on() { state = true; print(this); } public void off() { state = false; print(this); public String toString() { return state ? &quot;on&quot; :</p>
<p>} ///:~</p>
<p>//: exceptions/OnOffExceptionl.java public class OnOffExceptionl extends Exception {} //: exceptions/OnOffException2.java</p>
<p>public class OnOffException2 extends Exception {} ///:~</p>
<p>//: exceptions/OnOffSwitch.java // Why use finally?</p>
<p>public class OnOffSwitch {</p>
<p>private static Switch sw = new Switch(); public static void f()</p>
<p>throws OnOffException1,OnOffException2 {} public static void main(String[] args) { try { sw.on();</p>
<p>// Code that can throw exceptions... f();</p>
<p>sw.off();</p>
<p>} catch(OnOffException1 e) {</p>
<p>System.out.println(&quot;OnOffException1&quot;);</p>
<p>sw.off();</p>
<p>} catch(OnOffException2 e) {</p>
<p>System.out.println(&quot;OnOffException2&quot;);</p>
<p>sw.off();</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>on</p>
<p>off</p>
<p>*///:~</p>
<p>The goal here is to make sure that the switch is off when main( ) is completed, so sw.off( ) is placed at the end of the try block and at the end of each exception handler. But it’s possible that an exception might be thrown that isn’t caught here, so sw.off( ) would be missed. However, with finally you can place the cleanup code from a try block in just one place:</p>
<p>//: exceptions/WithFinally.java // Finally Guarantees cleanup.</p>
<p>public class WithFinally {</p>
<p>static Switch sw = new Switch(); public static void main(String[] args) { try { sw.on();</p>
<p>// Code that can throw exceptions...</p>
<p>OnOffSwitch.f();</p>
<p>} catch(OnOffException1 e) {</p>
<p>System.out.println(&quot;OnOffException1&quot;);</p>
<p>} catch(OnOffException2 e) {</p>
<p>System.out.println(&quot;OnOffException2&quot;);</p>
<p>} finally { sw.off();</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>on</p>
<p>off</p>
<p>*///:~</p>
<p>Here the sw.off( ) has been moved to just one place, where it’s guaranteed to run no matter what happens.</p>
<p>Even in cases in which the exception is not caught in the current set of catch clauses, finally will be executed before the exception-handling mechanism continues its search for a handler at the next higher level:</p>
<p>//: exceptions/AlwaysFinally.java</p>
<p>// Finally is always executed.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class FourException extends Exception {}</p>
<p>public class AlwaysFinally {</p>
<p>public static void main(String[] args) { print(&quot;Entering first try block&quot;); try {</p>
<p>print(&quot;Entering second try block&quot;); try {</p>
<p>throw new FourException();</p>
<p>} finally {</p>
<p>print(&quot;finally in 2nd try block&quot;);</p>
<p>}</p>
<p>} catch(FourException e) {</p>
<p>System.out.println(</p>
<p>&quot;Caught FourException in 1st try block&quot;);</p>
<p>} finally {</p>
<p>System.out.println(&quot;finally in 1st try block&quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Entering first try block</p>
<p>Entering second try block</p>
<p>finally in 2nd try block</p>
<p>Caught FourException in 1st try block</p>
<p>finally in 1st try block</p>
<p>*///:~</p>
<p>The finally statement will also be executed in situations in which break and continue statements are involved. Note that, along with the labeled break and labeled continue, finally eliminates the need for a goto statement in Java.</p>
<p>Exercise 13: (2) Modify Exercise 9 by adding a finally clause. Verify that your finally clause is executed, even if a NullPointerException is thrown.</p>
<p>Exercise 14: (2) Show that OnOffSwitch.java can fail by throwing a RuntimeException inside the try block.</p>
<p>Exercise 15: (2) Show that WithFinally.java doesn’t fail by throwing a RuntimeException inside the try block.</p>
<subtitle>Using finally during return</subtitle>
<p>Because a finally clause is always executed, it’s possible to return from multiple points within a method and still guarantee that important cleanup will be performed:</p>
<p>//: exceptions/MultipleReturns.java import static net.mindview.util.Print.*;</p>
<p>public class MultipleReturns { public static void f(int i) {</p>
<p>print(&quot;Initialization that requires cleanup&quot;);</p>
<p>try {</p>
<p>print(&quot;Point 1&quot;); if(i == 1) return; print(&quot;Point 2&quot;); if(i == 2) return; print(&quot;Point 3&quot;); if(i == 3) return; print(&quot;End&quot;); return;</p>
<p>} finally {</p>
<p>print(&quot;Performing cleanup&quot;);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) { for(int i = 1; i &lt;= 4; i++) f(i);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Initialization that requires cleanup Point 1</p>
<p>Performing cleanup</p>
<p>Initialization that requires cleanup Point 1 Point 2</p>
<p>Performing cleanup</p>
<p>Initialization that requires cleanup Point 1 Point 2 Point 3</p>
<p>Performing cleanup</p>
<p>Initialization that requires cleanup</p>
<p>Point 1</p>
<p>Point 2</p>
<p>Point 3</p>
<p>End</p>
<p>Performing cleanup *///:~</p>
<p>You can see from the output that it doesn’t matter where you return from inside the finally class.</p>
<p>Exercise 16: (2) Modify reusing/CADSystem.java to demonstrate that returning from the middle of a try-finally will still perform proper cleanup.</p>
<p>Exercise 17: (3) Modify polymorphism/Frog.java so that it uses try-finally to</p>
<p>guarantee proper cleanup, and show that this works even if you return from the middle of the try-finally.</p>
<subtitle>Pitfall: the lost exception</subtitle>
<p>Unfortunately, there’s a flaw in Java’s exception implementation. Although exceptions are an indication of a crisis in your program and should never be ignored, it’s possible for an exception to simply be lost. This happens with a particular configuration using a finally clause:</p>
<p>//: exceptions/LostMessage.java // How an exception can be lost.</p>
<p>class VeryImportantException extends Exception { public String toString() {</p>
<p>return &quot;A very important exception!&quot;;</p>
<p>class HoHumException extends Exception { public String toString() { return &quot;A trivial exception&quot;;</p>
<p>}</p>
<p>}</p>
<p>public class LostMessage {</p>
<p>void f() throws VeryImportantException { throw new VeryImportantException();</p>
<p>}</p>
<p>void dispose() throws HoHumException { throw new HoHumException();</p>
<p>}</p>
<p>public static void main(String[] args) { try {</p>
<p>LostMessage lm = new LostMessage(); try { lm.f();</p>
<p>} finally { lm.dispose();</p>
<p>}</p>
<p>} catch(Exception e) { System.out.println(e);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>A trivial exception *///:~</p>
<p>You can see from the output that there’s no evidence of the VerylmportantException, which is simply replaced by the HoHumException in the finally clause. This is a rather serious pitfall, since it means that an exception can be completely lost, and in a far more subtle and difficult-to-detect fashion than the preceding example. In contrast, C++ treats the situation in which a second exception is thrown before the first one is handled as a dire programming error. Perhaps a future version of Java will repair this problem (on the other hand, you will typically wrap any method that throws an exception, such as dispose( ) in the example above, inside a try-catch clause).</p>
<p>An even simpler way to lose an exception is just to return from inside a finally clause:</p>
<p>//: exceptions/ExceptionSilencer.java</p>
<p>public class ExceptionSilencer {</p>
<p>public static void main(String[] args) { try {</p>
<p>throw new RuntimeException();</p>
<p>} finally {</p>
<p>// Using ‘return’ inside the finally block // will silence any thrown exception. return;</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>If you run this program you’ll see that it produces no output, even though an exception is thrown.</p>
<p>Exercise 18: (3) Add a second level of exception loss to LostMessage.java so that the HoHumException is itself replaced by a third exception.</p>
<p>Exercise 19: (2) Repair the problem in LostMessage.java by guarding the call in the finally clause.</p>
</section>
<section>
<title>
<p>Exception restrictions</p></title><empty-line/>
<p>When you override a method, you can throw only the exceptions that have been specified in the base-class version of the method. This is a useful restriction, since it means that code that works with the base class will automatically work with any object derived from the base class (a fundamental OOP concept, of course), including exceptions.</p>
<p>This example demonstrates the kinds of restrictions imposed (at compile time) for exceptions:</p>
<p>//: exceptions/Stormylnning.java</p>
<p>// Overridden methods may throw only the exceptions // specified in their base-class versions, or exceptions // derived from the base-class exceptions.</p>
<p>class BaseballException extends Exception {} class Foul extends BaseballException {} class Strike extends BaseballException {}</p>
<p>abstract class Inning {</p>
<p>public Inning() throws BaseballException {} public void event() throws BaseballException {</p>
<p>// Doesn’t actually have to throw anything</p>
<p>}</p>
<p>public abstract void atBat() throws Strike, Foul; public void walk() {} // Throws no checked exceptions</p>
<p>}</p>
<p>class StormException extends Exception {} class RainedOut extends StormException {} class PopFoul extends Foul {}</p>
<p>interface Storm {</p>
<p>public void event() throws RainedOut; public void rainHard() throws RainedOut;</p>
<p>}</p>
<p>public class StormyInning extends Inning implements Storm {</p>
<p>// OK to add new exceptions for constructors, but you // must deal with the base constructor exceptions: public StormyInning()</p>
<p>throws RainedOut, BaseballException {} public StormyInning(String s)</p>
<p>throws Foul, BaseballException {}</p>
<p>// Regular methods must conform to base class:</p>
<p>//! void walk() throws PopFoul {} //Compile error // Interface CANNOT add exceptions to existing // methods from the base class:</p>
<p>//! public void event() throws RainedOut {}</p>
<p>// If the method doesn’t already exist in the // base class, the exception is OK: public void rainHard() throws RainedOut {}</p>
<p>// You can choose to not throw any exceptions,</p>
<p>// even if the base version does: public void event() {}</p>
<p>// Overridden methods can throw inherited exceptions: public void atBat() throws PopFoul {} public static void main(String[] args) { try {</p>
<p>StormyInning si = new StormyInning(); si.atBat();</p>
<p>} catch(PopFoul e) {</p>
<p>System.out.println(&quot;Pop foul&quot;);</p>
<p>} catch(RainedOut e) {</p>
<p>System.out.println(&quot;Rained out&quot;);</p>
<p>} catch(BaseballException e) {</p>
<p>System.out.println(&quot;Generic baseball exception&quot;);</p>
<p>}</p>
<p>// Strike not thrown in derived version. try {</p>
<p>// What happens if you upcast?</p>
<p>Inning i = new StormyInning(); i.atBat();</p>
<p>// You must catch the exceptions from the // base-class version of the method:</p>
<p>} catch(Strike e) {</p>
<p>System.out.println(&quot;Strike&quot;);</p>
<p>} catch(Foul e) {</p>
<p>System.out.println(&quot;Foul&quot;);</p>
<p>} catch(RainedOut e) {</p>
<p>System.out.println(&quot;Rained out&quot;);</p>
<p>} catch(BaseballException e) {</p>
<p>System.out.println(&quot;Generic baseball exception&quot;);</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>In Inning, you can see that both the constructor and the event( ) method say that they will throw an exception, but they never do. This is legal because it allows you to force the user to catch any exceptions that might be added in overridden versions of event( ). The same idea holds for abstract methods, as seen in atBat( ).</p>
<p>The interface Storm is interesting because it contains one method (event( )) that is defined in Inning, and one method that isn’t. Both methods throw a new type of exception, RainedOut. When Stormylnning extends Inning and implements Storm, you’ll see that the event( ) method in Storm cannot change the exception interface of event( ) in Inning. Again, this makes sense because otherwise you’d never know if you were catching the correct thing when working with the base class. Of course, if a method described in an interface is not in the base class, such as rainHard( ), then there’s no problem if it throws exceptions.</p>
<p>The restriction on exceptions does not apply to constructors. You can see in Stormylnning that a constructor can throw anything it wants, regardless of what the base-class constructor throws. However, since a base-class constructor must always be called one way or another (here, the default constructor is called automatically), the derived-class constructor must declare any base-class constructor exceptions in its exception specification.</p>
<p>A derived-class constructor cannot catch exceptions thrown by its base-class constructor.</p>
<p>The reason StormyInning.walk( ) will not compile is that it throws an exception, but Inning.walk( ) does not. If this were allowed, then you could write code that called Inning.walk( ) and that didn’t have to handle any exceptions, but then when you substituted an object of a class derived from Inning, exceptions would be thrown so your code would break. By forcing the derived-class methods to conform to the exception specifications of the base-class methods, substitutability of objects is maintained.</p>
<p>The overridden event( ) method shows that a derived-class version of a method may choose not to throw any exceptions, even if the base-class version does. Again, this is fine since it doesn’t break code that is written assuming the base-class version throws exceptions. Similar logic applies to atBat( ), which throws PopFoul, an exception that is derived from Foul thrown by the base-class version of atBat( ). This way, if you write code that works with Inning and calls atBat( ), you must catch the Foul exception. Since PopFoul is derived from Foul, the exception handler will also catch PopFoul.</p>
<p>The last point of interest is in main( ). Here, you can see that if you’re dealing with exactly a StormyInning object, the compiler forces you to catch only the exceptions that are specific to that class, but if you upcast to the base type, then the compiler (correctly) forces you to catch the exceptions for the base type. All these constraints produce much more robust exceptionhandling code.<a l:href="#bookmark48" type="note"><sup>49</sup></a><sup></sup></p>
<p>Although exception specifications are enforced by the compiler during inheritance, the exception specifications are not part of the type of a method, which comprises only the method name and argument types. Therefore, you cannot overload methods based on exception specifications. In addition, just because an exception specification exists in a base-class version of a method doesn’t mean that it must exist in the derived-class version of the method. This is quite different from inheritance rules, where a method in the base class must also exist in the derived class. Put another way, the &quot;exception specification interface&quot; for a particular method may narrow during inheritance and overriding, but it may not widen—this is precisely the opposite of the rule for the class interface during inheritance.</p>
<p>Exercise 20: (3) Modify StormyInning.java by adding an UmpireArgument</p>
<p>exception type and methods that throw this exception. Test the modified hierarchy.</p>
</section>
<section>
<title>
<p>Constructors</p></title><empty-line/>
<p>It’s important that you always ask, &quot;If an exception occurs, will everything be properly cleaned up?&quot; Most of the time you’re fairly safe, but with constructors there’s a problem. The constructor puts the object into a safe starting state, but it might perform some operation— such as opening a filethat doesn’t get cleaned up until the user is finished with the object and calls a special cleanup method. If you throw an exception from inside a constructor, these cleanup behaviors might not occur properly. This means that you must be especially diligent while you write your constructor.</p>
<p>You might think that finally is the solution. But it’s not quite that simple, because finally performs the cleanup code every time. If a constructor fails partway through its execution, it might not have successfully created some part of the object that will be cleaned up in the finally clause.</p>
<p>In the following example, a class called InputFile is created that opens a file and allows you to read it one line at a time. It uses the classes FileReader and BufferedReader from the Java standard I/O library that will be discussed in the I/O chapter. These classes are simple enough that you probably won’t have any trouble understanding their basic use:</p>
<p>//: exceptions/InputFile.java</p>
<p>// Paying attention to exceptions in constructors. import java.io.*;</p>
<p>public class InputFile { private BufferedReader in;</p>
<p>public InputFile(String fname) throws Exception { try {</p>
<p>in = new BufferedReader(new FileReader(fname));</p>
<p>// Other code that might throw exceptions } catch(FileNotFoundException e) {</p>
<p>System.out.println(&quot;Could not open &quot; + fname);</p>
<p>// Wasn’t open, so don’t close it throw e;</p>
<p>} catch(Exception e) {</p>
<p>// All other exceptions must close it try {</p>
<p>in.close();</p>
<p>} catch(IOException e2) {</p>
<p>System.out.println(&quot;in.close() unsuccessful&quot;);</p>
<p>}</p>
<p>throw e; // Rethrow } finally {</p>
<p>// Don’t close it here!!!</p>
<p>}</p>
<p>}</p>
<p>public String getLine() {</p>
<p>String s; try {</p>
<p>s = in.readLine();</p>
<p>} catch(IOException e) {</p>
<p>throw new RuntimeException(&quot;readLine() failed&quot;);</p>
<p>}</p>
<p>return s;</p>
<p>}</p>
<p>public void dispose() { try {</p>
<p>in.close();</p>
<p>System.out.println(&quot;dispose() successful&quot;);</p>
<p>} catch(IOException e2) {</p>
<p>throw new RuntimeException(&quot;in.close() failed&quot;);</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>The constructor for InputFile takes a String argument, which is the name of the file you want to open. Inside a try block, it creates a FileReader using the file name. A FileReader isn’t particularly useful until you use it to create a BufferedReader. One of the benefits of InputFile is that it combines these two actions.</p>
<p>If the FileReader constructor is unsuccessful, it throws a FileNotFoundException. This is the one case in which you don’t want to close the file, because it wasn’t successfully opened. Any other catch clauses must close the file because it was opened by the time those catch clauses are entered. (Of course, this gets trickier if more than one method can throw a FileNotFoundException. In that case, you’ll usually have to break things into several try blocks.) The close( ) method might throw an exception so it is tried and caught even though it’s within the block of another catch clause—it’s just another pair of curly braces to the Java compiler. After performing local operations, the exception is rethrown, which is appropriate because this constructor failed, and you don’t want the calling method to assume that the object has been properly created and is valid.</p>
<p>In this example, the finally clause is definitely not the place to close( ) the file, since that would close it every time the constructor completed. We want the file to be open for the useful lifetime of the InputFile object.</p>
<p>The getLine( ) method returns a String containing the next line in the file. It calls readLine( ), which can throw an exception, but that exception is caught so that getLine( ) doesn’t throw any exceptions. One of the design issues with exceptions is whether to handle an exception completely at this level, to handle it partially and pass the same exception (or a different one) on, or whether to simply pass it on. Passing it on, when appropriate, can certainly simplify coding. In this situation, the getLine( ) method converts the exception to a RuntimeException to indicate a programming error.</p>
<p>The dispose( ) method must be called by the user when the InputFile object is no longer needed. This will release the system resources (such as file handles) that are used by the BufferedReader and/or FileReader objects. You don’t want to do this until you’re finished with the InputFile object. You might think of putting such functionality into a finalize( ) method, but as mentioned in the Initialization &amp; Cleanup chapter, you can’t always be sure that finalize( ) will be called (even if you can be sure that it will be called, you don’t know when). This is one of the downsides to Java: All cleanupother than memory cleanup—doesn’t happen automatically, so you must inform the client programmers that they are responsible.</p>
<p>The safest way to use a class which might throw an exception during construction and which requires cleanup is to use nested try blocks:</p>
<p>//: exceptions/Cleanup.java</p>
<p>// Guaranteeing proper cleanup of a resource.</p>
<p>public class Cleanup {</p>
<p>public static void main(String[] args) { try {</p>
<p>InputFile in = new InputFile(&quot;Cleanup.java&quot;); try {</p>
<p>String s; int i = 1;</p>
<p>while((s = in.getLine()) != null)</p>
<p>; // Perform line-by-line processing here...</p>
<p>} catch(Exception e) {</p>
<p>System.out.println(&quot;Caught Exception in main&quot;); e.printStackTrace(System.out);</p>
<p>} finally { in.dispose();</p>
<p>}</p>
<p>} catch(Exception e) {</p>
<p>System.out.println(&quot;InputFile construction failed&quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* Output: dispose() successful *///:~</p>
<p>Look carefully at the logic here: The construction of the InputFile object is effectively in its own try block. If that construction fails, the outer catch clause is entered and dispose( ) is not called. However, if construction succeeds then you want to make sure the object is cleaned up, so immediately after construction you create a new try block. The finally that performs cleanup is associated with the inner try block; this way, the finally clause is not executed if construction fails, and it is always executed if construction succeeds.</p>
<p>This general cleanup idiom should still be used if the constructor throws no exceptions. The basic rule is: Right after you create an object that requires cleanup, begin a try-finally:</p>
<p>//: exceptions/Cleanupldiom.java</p>
<p>// Each disposable object must be followed by a try-finally</p>
<p>class NeedsCleanup { // Construction can’t fail private static long counter = 1; private final long id = counter++; public void dispose() {</p>
<p>System.out.println(&quot;NeedsCleanup &quot; + id + &quot; disposed&quot;);</p>
<p>}</p>
<p>}</p>
<p>class ConstructionException extends Exception {}</p>
<p>class NeedsCleanup2 extends NeedsCleanup {</p>
<p>// Construction can fail:</p>
<p>public NeedsCleanup2() throws ConstructionException {}</p>
<p>}</p>
<p>public class CleanupIdiom {</p>
<p>public static void main(String[] args) {</p>
<p>// Section 1:</p>
<p>NeedsCleanup nc1 = new NeedsCleanup(); try {</p>
<p>// ...</p>
<p>} finally { nc1.dispose();</p>
<p>}</p>
<p>// Section 2:</p>
<p>// If construction cannot fail you can group objects: NeedsCleanup nc2 = new NeedsCleanup();</p>
<p>NeedsCleanup nc3 = new NeedsCleanup(); try {</p>
<p>// ...</p>
<p>} finally {</p>
<p>nc3.dispose(); // Reverse order of construction nc2.dispose();</p>
<p>} // Section 3:</p>
<p>// If construction can fail you must guard each one: try {</p>
<p>NeedsCleanup2 nc4 = new NeedsCleanup2(); try {</p>
<p>NeedsCleanup2 nc5 = new NeedsCleanup2(); try {</p>
<p>// ...</p>
<p>} finally { nc5.dispose();</p>
<p>}</p>
<p>} catch(ConstructionException e) System.out.println(e);</p>
<p>} finally { nc4.dispose();</p>
<p>}</p>
<p>} catch(ConstructionException e) { System.out.println(e);</p>
<p>}</p>
<p>{ // nc5 constructor</p>
<p>// nc4 constructor</p>
<p>}</p>
<p>} /* Output: NeedsCleanup NeedsCleanup NeedsCleanup NeedsCleanup NeedsCleanup</p>
<p>1    disposed</p>
<p>3    disposed</p>
<p>2    disposed 5 disposed</p>
<p>4    disposed</p>
<p>*///:~</p>
<p>In main( ), section 1 is fairly straightforward: You follow a disposable object with a try-finally. If the object construction cannot fail, no catch is necessary. In section 2, you can see that objects with constructors that cannot fail can be grouped together for both construction and cleanup.</p>
<p>Section 3 shows how to deal with objects whose constructors can fail and which need cleanup. To properly handle this situation, things get messy, because you must surround each construction with its own try-catch, and each object construction must be followed by a try-finally to guarantee cleanup.</p>
<p>The messiness of exception handling in this case is a strong argument for creating constructors that cannot fail, although this is not always possible.</p>
<p>Note that if dispose( ) can throw an exception you might need additional try blocks. Basically, you must think carefully about all the possibilities and guard for each one.</p>
<p>Exercise 21: (2) Demonstrate that a derived-class constructor cannot catch exceptions thrown by its base-class constructor.</p>
<p>Exercise 22: (2) Create a class called FailingConstructor with a constructor that might fail partway through the construction process and throw an exception. In main( ), write code that properly guards against this failure.</p>
<p>Exercise 23: (4) Add a class with a dispose( ) method to the previous exercise. Modify FailingConstructor so that the constructor creates one of these disposable objects as a member object, after which the constructor might throw an exception, after which it creates a second disposable member object. Write code to properly guard against failure, and in main( ) verify that all possible failure situations are covered.</p>
<p>Exercise 24: (3) Add a dispose( ) method to the FailingConstructor class and write code to properly use this class.</p>
</section>
<section>
<title>
<p>Exception matching</p></title><empty-line/>
<p>When an exception is thrown, the exception-handling system looks through the &quot;nearest&quot; handlers in the order they are written. When it finds a match, the exception is considered handled, and no further searching occurs.</p>
<p>Matching an exception doesn’t require a perfect match between the exception and its handler. A derived-class object will match a handler for the base class, as shown in this example:</p>
<p>//: exceptions/Human.java // Catching exception hierarchies.</p>
<p>class Annoyance extends Exception {} class Sneeze extends Annoyance {}</p>
<p>public class Human {</p>
<p>public static void main(String[] args) {</p>
<p>// Catch the exact type: try {</p>
<p>throw new Sneeze();</p>
<p>} catch(Sneeze s) {</p>
<p>System.out.println(&quot;Caught Sneeze&quot;);</p>
<p>} catch(Annoyance a) {</p>
<p>System.out.println(&quot;Caught Annoyance&quot;);</p>
<p>// Catch the base type: try {</p>
<p>throw new Sneeze();</p>
<p>} catch(Annoyance a) {</p>
<p>System.out.println(&quot;Caught Annoyance&quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Caught Sneeze Caught Annoyance *///:~</p>
<p>The Sneeze exception will be caught by the first catch clause that it matches, which is the first one, of course. However, if you remove the first catch clause, leaving only the catch clause for Annoyance, the code still works because it’s catching the base class of Sneeze. Put another way, catch(Annoyance a) will catch an Annoyance or any class derived from it. This is useful because if you decide to add more derived exceptions to a method, then the client programmer’s code will not need changing as long as the client catches the base-class exceptions.</p>
<p>If you try to &quot;mask&quot; the derived-class exceptions by putting the base-class catch clause first, like this:</p>
<p>try {</p>
<p>throw new Sneeze();</p>
<p>} catch(Annoyance a) {</p>
<p>// ...</p>
<p>} catch(Sneeze s) {</p>
<p>// ...</p>
<p>}</p>
<p>the compiler will give you an error message, since it sees that the Sneeze catch clause can never be reached.</p>
<p>Exercise 25: (2) Create a three-level hierarchy of exceptions. Now create a base-class A with a method that throws an exception at the base of your hierarchy. Inherit B from A and override the method so it throws an exception at level two of your hierarchy. Repeat by inheriting class C from B. In main( ), create a C and upcast it to A, then call the method.</p>
</section>
<section>
<title>
<p>Alternative approaches</p></title><empty-line/>
<p>An exception-handling system is a trapdoor that allows your program to abandon execution of the normal sequence of statements. The trapdoor is used when an &quot;exceptional condition&quot; occurs, such that normal execution is no longer possible or desirable. Exceptions represent conditions that the current method is unable to handle. The reason exception-handling systems were developed is because the approach of dealing with each possible error condition produced by each function call was too onerous, and programmers simply weren’t doing it.</p>
<p>As a result, they were ignoring the errors. It’s worth observing that the issue of programmer convenience in handling errors was a prime motivation for exceptions in the first place.</p>
<p>One of the important guidelines in exception handling is &quot;Don’t catch an exception unless you know what to do with it.&quot; In fact, one of the important goals of exception handling is to move the error-handling code away from the point where the errors occur. This allows you to focus on what you want to accomplish in one section of your code, and how you’re going to deal with problems in a distinct separate section of your code. As a result, your mainline code is not cluttered with error-handling logic, and it’s much easier to understand and maintain.</p>
<p>Exception handling also tends to reduce the amount of error-handling code, by allowing one handler to deal with many error sites.</p>
<p>Checked exceptions complicate this scenario a bit, because they force you to add catch clauses in places where you may not be ready to handle an error. This results in the &quot;harmful if swallowed&quot; problem:</p>
<p>try {</p>
<p>// ... to do something useful } catch(ObligatoryException e) {} // Gulp!</p>
<p>Programmers (myself included, in the 1st edition of this book) would just do the simplest thing, and &quot;swallow&quot; the exception—often unintentionally, but once you do it, the compiler has been satisfied, so unless you remember to revisit and correct the code, the exception will be lost. The exception happens, but it vanishes completely when swallowed. Because the compiler forces you to write code right away to handle the exception, this seems like the easiest solution even though it’s probably the worst thing you can do.</p>
<p>Horrified upon realizing that I had done this, in the 2<sup>nd</sup> edition I &quot;fixed&quot; the problem by printing the stack trace inside the handler (as is still seen— appropriately—in a number of examples in this chapter). While this is useful to trace the behavior of exceptions, it still indicates that you don’t really know what to do with the exception at that point in your code. In this section you’ll learn about some of the issues and complications arising from checked exceptions, and options that you have when dealing with them.</p>
<p>This topic seems simple. But it is not only complicated, it is also an issue of some volatility. There are people who are staunchly rooted on either side of the fence and who feel that the correct answer (theirs) is blatantly obvious. I believe the reason for one of these positions is the distinct benefit seen in going from a poorly typed language like pre-ANSI C to a strong, statically typed language (that is, checked at compile time) like C++ or Java. When you make that transition (as I did), the benefits are so dramatic that it can seem like static type checking is always the best answer to most problems. My hope is to relate a little bit of my own evolution that has brought the absolute value of static type checking into question; clearly, it’s very helpful much of the time, but there’s a fuzzy line we cross when it begins to get in the way and become a hindrance (one of my favorite quotes is &quot;All models are wrong. Some are useful.&quot;).</p>
<subtitle>History</subtitle>
<p>Exception handling originated in systems like PL/i and Mesa, and later appeared in CLU, Smalltalk, Modula-3, Ada, Eiffel, C++, Python, Java, and the post-Java languages Ruby and C#. The Java design is similar to C++, except in places where the Java designers felt that the C++ approach caused problems. To provide programmers with a framework that they were more likely to use for error handling and recovery, exception handling was added to C++ rather late in the standardization process, promoted by Bjarne Stroustrup, the language’s original author. The model for C++ exceptions came primarily from CLU. However, other languages existed at that time that also supported exception handling: Ada, Smalltalk (both of these had exceptions but no exception specifications) and Modula-3 (which included both exceptions and specifications).</p>
<p>In their seminal paper<a l:href="#bookmark49" type="note"><sup>50</sup></a><sup></sup> on the subject, Liskov and Snyder observe that a major defect of languages like C, which report errors in a transient fashion, is that:</p>
<p>&quot;...every invocation must be followed by a conditional test to determine what the outcome was. This requirement leads to programs that are difficult to read, and probably inefficient as well, thus discouraging programmers from signaling and handling exceptions.&quot;</p>
<p>Thus one of the original motivations of exception handling was to prevent this requirement, but with checked exceptions in Java we commonly see exactly this kind of code. They go on to say:</p>
<p>&quot;...requiring that the text of a handler be attached to the invocation that raises the exception would lead to unreadable programs in which expressions were broken up with handlers.&quot;</p>
<p>Following the CLU approach when designing C++ exceptions, Stroustrup stated that the goal was to reduce the amount of code required to recover from errors. I believe that he was observing that programmers were typically not writing error-handling code in C because the amount and placement of such code was daunting and distracting. As a result, they were used to doing it the C way, ignoring errors in code and using debuggers to track down problems.</p>
<p>To use exceptions, these C programmers had to be convinced to write &quot;additional&quot; code that they weren’t normally writing. Thus, to draw them into a better way of handling errors, the amount of code they would need to &quot;add&quot; must not be onerous. I think it’s important to keep this goal in mind when looking at the effects of checked exceptions in Java.</p>
<p>C++ brought an additional idea over from CLU: the exception specification, to programmatically state in the method signature the exceptions that could result from calling that method. The exception specification really has two purposes. It can say, &quot;I’m originating this exception in my code; you handle it.&quot; But it can also mean, &quot;I’m ignoring this exception that can occur as a result of my code; you handle it.&quot; We’ve been focusing on the &quot;you handle it&quot; part when looking at the mechanics and syntax of exceptions, but here I’m particularly interested in the fact that we often ignore exceptions and that’s what the exception specification can state.</p>
<p>In C++ the exception specification is not part of the type information of a function. The only compile-time checking is to ensure that exception specifications are used consistently; for example, if a function or method throws exceptions, then the overloaded or derived versions must also throw those exceptions. Unlike Java, however, no compile-time checking occurs to determine whether or not the function or method will actually throw that exception, or whether the exception specification is complete (that is, whether it accurately describes all exceptions that maybe thrown). That validation does happen, but only at run time. If an exception is thrown that violates the exception specification, the C++ program will call the standard library function unexpected( ).</p>
<p>It is interesting to note that, because of the use of templates, exception specifications are not used at all in the Standard C++ Library. In Java, there are restrictions on the way that Java generics can be used with exception specifications.</p>
<subtitle>Perspectives</subtitle>
<p>First, it’s worth noting that Java effectively invented the checked exception (clearly inspired by C++ exception specifications and the fact that C++ programmers typically don’t bother with them). However, it was an experiment which no subsequent language has chosen to duplicate.</p>
<p>Secondly, checked exceptions appear to be an &quot;obvious good thing&quot; when seen in introductory examples and in small programs. It has been suggested that the subtle difficulties begin to appear when programs start to get large. Of course, largeness usually doesn’t happen overnight; it creeps. Languages that may not be suited for large-scale projects are used for small projects. These projects grow, and at some point we realize that things have gone from &quot;manageable&quot; to &quot;difficult.&quot; This is what I’m suggesting may be the case with too much type checking; in particular, with checked exceptions.</p>
<p>The scale of the program seems to be a significant issue. This is a problem because most discussions tend to use small programs as demonstrations. One of the C# designers observed that:</p>
<p>&quot;Examination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result-decreased productivity and little or no increase in code quality.&quot;<a l:href="#bookmark50" type="note"><sup>51</sup></a><sup></sup></p>
<p>In reference to uncaught exceptions, the CLU creators stated:</p>
<p>&quot;We felt it was unrealistic to require the programmer to provide handlers in situations where no meaningful action can be taken.&quot;<a l:href="#bookmark51" type="note"><sup>52</sup></a><sup></sup></p>
<p>When explaining why a function declaration with no specification means that it can throw any exception, rather than no exceptions, Stroustrup states:</p>
<p>&quot;However, that would require exception specifications for essentially every function, would be a significant cause for recompilation, and would inhibit cooperation with software written in other languages. This would encourage programmers to subvert the exception-handling mechanisms and to write spurious code to suppress exceptions. It would provide a false sense of security to people who failed to notice the exception.&quot;<a l:href="#bookmark52" type="note"><sup>53</sup></a><sup> <a l:href="#bookmark53" type="note"><sup>54</sup></a></sup></p>
<p>We see this very behavior-subverting the exceptions—happening with checked exceptions in Java.</p>
<p>Martin Fowler (author of UML Distilled, Refactoring, and Analysis Patterns) wrote the following to me:</p>
<p>&quot;...on the whole I think that exceptions are good, but Java checked exceptions are more trouble than they are worth.&quot;</p>
<p>I now think that Java’s important step was to unify the error-reporting model, so that all errors are reported using exceptions. This wasn’t happening with C++, because for backward compatibility with C the old model of just ignoring errors was still available. But if you have consistent reporting with exceptions, then exceptions can be used if desired, and if not, they will propagate out to the highest level (the console or other container program). When Java modified the C++ model so that exceptions were the only way to report errors, the extra enforcement of checked exceptions may have become less necessary.</p>
<p>In the past, I have been a strong believer that both checked exceptions and static type checking were essential to robust program development. However, both anecdotal and direct experience<sup>11</sup> with languages that are more dynamic than static has led me to think that the great benefits actually come from:</p>
<p>1.    A unified error-reporting model via exceptions, regardless of whether the programmer is forced by the compiler to handle them.</p>
<p>2.    Type checking, regardless of when it takes place. That is, as long as proper use of a type is enforced, it often doesn’t matter if it happens at compile time or run time.</p>
<p>On top of this, there are very significant productivity benefits to reducing the compile-time constraints upon the programmer. Indeed, reflection and generics are required to compensate for the overconstraining nature of static typing, as you shall see in a number of examples throughout the book.</p>
<p>I’ve already been told by some that what I say here constitutes blasphemy, and by uttering these words my reputation will be destroyed, civilizations will fall, and a higher percentage of programming projects will fail. The belief that the compiler can save your project by pointing out errors at compile time runs strong, but it’s even more important to realize the limitation of what the compiler is able to do; in the supplement you will find at <a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a>, I emphasize the value of an automated build process and unit testing, which give you far more leverage than you get by trying to turn everything into a syntax error. It’s worth keeping in mind that:</p>
<p>&quot;A good programming language is one that helps programmers write good programs. No programming language will prevent its users from writing bad programs.&quot;<a l:href="#bookmark54" type="note"><sup>55</sup></a><sup></sup></p>
<p>In any event, the likelihood of checked exceptions ever being removed from Java seems dim. It would be too radical of a language change, and proponents within Sun appear to be quite strong. Sun has a history and policy of absolute backwards compatibility—to give you a sense of this, virtually all Sun software runs on all Sun hardware, no matter how old. However, if you find that some checked exceptions are getting in your way, or especially if you find yourself being forced to catch exceptions, but you don’t know what to do with them, there are some alternatives.</p>
<subtitle>Passing exceptions to the console</subtitle>
<p>In simple programs, like many of those in this book, the easiest way to preserve the exceptions without writing a lot of code is to pass them out of main( ) to the console. For example, if you want to open a file for reading (something you’ll learn about in detail in the I/O chapter), you must open and close a FilelnputStream, which throws exceptions. For a simple program, you can do this (you’ll see this approach used in numerous places throughout this book):</p>
<p>//: exceptions/MainException.java import java.io.*;</p>
<p>public class MainException {</p>
<p>// Pass all exceptions to the console:</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>// Open the file:</p>
<p>FilelnputStream file =</p>
<p>new FileInputStream(&quot;MainException.java&quot;);</p>
<p>// Use the file ...</p>
<p>// Close the file: file.close();</p>
<p>}</p>
<p>} ///:~</p>
<p>Note that main( ) is also a method that may have an exception specification, and here the type of exception is Exception, the root class of all checked exceptions. By passing it out to the console, you are relieved from writing try-catch clauses within the body of main( ). (Unfortunately, file I/O is significantly more complex than it would appear to be from this example, so don’t get too excited until after you’ve read the I/O chapter).</p>
<p>Exercise 26: (1) Change the file name string in MainException.java to name a file that doesn’t exist. Run the program and note the result.</p>
<subtitle>Converting checked to unchecked exceptions</subtitle>
<p>Throwing an exception from main( ) is convenient when you’re writing simple programs for your own consumption, but is not generally useful. The real problem is when you are writing an ordinary method body, and you call another method and realize, &quot;I have no idea what to do with this exception here, but I don’t want to swallow it or print some banal message.&quot; With chained exceptions, a new and simple solution prevents itself. You simply &quot;wrap&quot; a checked exception inside a RuntimeException by passing it to the RuntimeException constructor, like this:</p>
<p>t r y {</p>
<p>// ... to do something useful</p>
<p>} catch(IDontKnowWhatToDoWithThisCheckedException e) { throw new RuntimeException(e);</p>
<p>}</p>
<p>This seems to be an ideal solution if you want to &quot;turn off the checked exception—you don’t swallow it, and you don’t have to put it in your method’s exception specification, but because of exception chaining you don’t lose any information from the original exception.</p>
<p>This technique provides the option to ignore the exception and let it bubble up the call stack without being required to write try-catch clauses and/or exception specifications. However, you may still catch and handle the specific exception by using getCause( ), as seen here:</p>
<p>//: exceptions/TurnOffChecking.java // &quot;Turning off&quot; Checked exceptions. import java.io.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class WrapCheckedException {</p>
<p>void throwRuntimeException(int type) { try {</p>
<p>switch(type) {</p>
<p>case 0: throw new FileNotFoundException(); case 1: throw new IOException();</p>
<p>case 2: throw new RuntimeException(&quot;Where am I?&quot;); default: return;</p>
<p>}</p>
<p>} catch(Exception e) { // Adapt to unchecked: throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class SomeOtherException extends Exception {}</p>
<p>public class TurnOffChecking {</p>
<p>public static void main(String[] args) {</p>
<p>WrapCheckedException wce = new WrapCheckedException();</p>
<p>// You can call throwRuntimeException() without a try</p>
<p>// block, and let RuntimeExceptions leave the method: wce.throwRuntimeException(3);</p>
<p>// Or you can choose to catch exceptions: for(int i = 0; i &lt; 4; i++) try {</p>
<p>if(i &lt; 3)</p>
<p>wce.throwRuntimeException(i);</p>
<p>else</p>
<p>throw new SomeOtherException();</p>
<p>} catch(SomeOtherException e) {</p>
<p>print(&quot;SomeOtherException: &quot; + e);</p>
<p>} catch(RuntimeException re) { try {</p>
<p>throw re.getCause();</p>
<p>} catch(FileNotFoundException e) { print(&quot;FileNotFoundException: &quot; + e);</p>
<p>} catch(IOException e) { print(&quot;IOException: &quot; + e);</p>
<p>} catch(Throwable e) { print(&quot;Throwable: &quot; + e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>FileNotFoundException: java.io.FileNotFoundException IOException: java.io.IOException</p>
<p>Throwable: java.lang.RuntimeException: Where am I?</p>
<p>SomeOtherException: SomeOtherException</p>
<p>*///:~</p>
<p>WrapCheckedException.throwRuntimeException( ) contains code that generates different types of exceptions. These are caught and wrapped inside RuntimeException objects, so they become the &quot;cause&quot; of those exceptions.</p>
<p>In TurnOffChecking, you can see that it’s possible to call throwRuntimeException( )</p>
<p>with no try block because the method does not throw any checked exceptions. However, when you’re ready to catch exceptions, you still have the ability to catch any exception you want by putting your code inside a try block. You start by catching all the exceptions you explicitly know might emerge from the code in your try block—in this case, SomeOtherException is caught first. Lastly, you catch RuntimeException and throw the result of getCause( ) (the wrapped exception). This extracts the originating exceptions, which can then be handled in their own catch clauses.</p>
<p>The technique of wrapping a checked exception in a RuntimeException will be used when appropriate throughout the rest of this book. Another solution is to create your own subclass of RuntimeException. This way, it doesn’t need to be caught, but someone can catch it if they want to.</p>
<p>Exercise 27: (1) Modify Exercise 3 to convert the exception to a RuntimeException.</p>
<p>Exercise 28: (1) Modify Exercise 4 so that the custom exception class inherits from RuntimeException, and show that the compiler allows you to leave out the try block.</p>
<p>Exercise 29: (1) Modify all the exception types in Stormylnning.java so that they extend RuntimeException, and show that no exception specifications or try blocks are necessary. Remove the ‘//!’ comments and show how the methods can be compiled without specifications.</p>
<p>Exercise 30: (2) Modify Human.java so that the exceptions inherit from RuntimeException. Modify main( ) so that the technique in TurnOffChecking.java is</p>
<p>used to handle the different types of exceptions.</p>
</section>
<section>
<title>
<p>Exception guidelines</p></title><empty-line/>
<p>Use exceptions to:</p>
<p>1.    Handle problems at the appropriate level. (Avoid catching exceptions unless you know what to do with them.)</p>
<p>2.    Fix the problem and call the method that caused the exception again.</p>
<p>3.    Patch things up and continue without retrying the method.</p>
<p>4.    Calculate some alternative result instead of what the method was supposed to produce.</p>
<p>5.    Do whatever you can in the current context and rethrow the same exception to a higher context.</p>
<p>6.    Do whatever you can in the current context and throw a different exception to a higher context.</p>
<p>7.    Terminate the program.</p>
<p>8.    Simplify. (If your exception scheme makes things more complicated, then it is painful and annoying to use.)</p>
<p>9.    Make your library and program safer. (This is a short-term investment for debugging, and a long-term investment for application robustness.)</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>Exceptions are integral to programming with Java; you can accomplish only so much without knowing how to work with them. For that reason, exceptions are introduced at this point in the book—there are many libraries (like I/O, mentioned earlier) that you can’t use without handling exceptions.</p>
<p>One of the advantages of exception handling is that it allows you to concentrate on the problem you’re trying to solve in one place, and then deal with the errors from that code in another place. And although exceptions are generally explained as tools that allow you to report and recover from errors at run time, I have come to wonder how often the &quot;recovery&quot; aspect is implemented, or even possible. My perception is that it is less than 10 percent of the time, and even then it probably amounts to unwinding the stack to a known stable state rather than actually performing any kind of resumptive behavior. Whether or not this is true, I have come to believe that the &quot;reporting&quot; function is where the essential value of exceptions lie. The fact that Java effectively insists that all errors be reported in the form of exceptions is what gives it a great advantage over languages like C++, which allow you to report errors in a number of different ways, or not at all. A consistent errorreporting system means that you no longer have to ask the question &quot;Are errors slipping through the cracks?&quot; with each piece of code you write (as long as you don’t &quot;swallow&quot; the exceptions, that is!).</p>
<p>As you will see in future chapters, by laying this question to rest-even if you do so by throwing a RuntimeException—your design and implementation efforts can be focused on more interesting and challenging issues.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Strings</p></title><empty-line/>
<p>String manipulation is arguably one of the most common activities in computer programming.</p>
<p>This is especially true in Web systems, where Java is heavily used. In this chapter, we’ll look more deeply at what is certainly the most commonly used class in the language, String, along with some of its associated classes and utilities.</p>
<section>
<title>
<p>Immutable Strings</p></title><empty-line/>
<p>Objects of the String class are immutable. If you examine the JDK documentation for the String class, you’ll see that every method in the class that appears to modify a String actually creates and returns a brand new String object containing the modification. The original String is left untouched.</p>
<p>Consider the following code:</p>
<p>//: strings/Immutable.java</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Immutable {</p>
<p>public static String upcase(String s) { return s.toUpperCase();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>String q = &quot;howdy&quot;; print(q); // howdy String qq = upcase(q); print(qq); // HOWDY print(q); // howdy</p>
<p>}</p>
<p>} /* Output: howdy HOWDY howdy *///:~</p>
<p>When q is passed in to upcase( ) it’s actually a copy of the reference to q. The object this reference is connected to stays in a single physical location. The references are copied as they are passed around.</p>
<p>Looking at the definition for upcase( ), you can see that the reference that’s passed in has the name s, and it exists for only as long as the body of upcase( ) is being executed. When upcase( ) completes, the local reference s vanishes. upcase( ) returns the result, which is the original string with all the characters set to uppercase. Of course, it actually returns a reference to the result. But it turns out that the reference that it returns is for a new object, and the original q is left alone.</p>
<p>This behavior is usually what you want. Suppose you say:</p>
<p>String s = &quot;asdf&quot;;</p>
<p>String x = Immutable.upcase(s);</p>
<p>Do you really want the upcase( ) method to change the argument? To the reader of the code, an argument usually looks like a piece of information provided to the method, not something to be modified. This is an important guarantee, since it makes code easier to write and understand.</p>
</section>
<section>
<title>
<p>Overloading &apos;+&apos; vs. StringBuilder</p></title><empty-line/>
<p>Since String objects are immutable, you can alias to a particular String as many times as you want. Because a String is read-only, there’s no possibility that one reference will change something that will affect the other references.</p>
<p>Immutability can have efficiency issues. A case in point is the operator ‘+’ that has been overloaded for String objects. Overloading means that an operation has been given an extra meaning when used with a particular class. (The ‘+’ and ‘+=‘ for String are the only operators that are overloaded in Java, and Java does not allow the programmer to overload any others.)<a l:href="#bookmark55" type="note"><sup>56</sup></a><sup></sup> The’+’ operator allows you to concatenate Strings:</p>
<p>//: strings/Concatenation.java</p>
<p>public class Concatenation {</p>
<p>public static void main(String[] args) {</p>
<p>String mango = &quot;mango&quot;;</p>
<p>String s = &quot;abc&quot; + mango + &quot;def&quot; + 47;</p>
<p>System.out.println(s);</p>
<p>}</p>
<p>} /* Output: abcmangodef47 *///:~</p>
<p>You could imagine how this might work. The String &quot;abc&quot; could have a method append( ) that creates a new String object containing &quot;abc&quot; concatenated with the contents of mango. The new String object would then create another new String that added &quot;def,&quot; and so on.</p>
<p>This would certainly work, but it requires the creation of a lot of String objects just to put together this new String, and then you have a bunch of intermediate String objects that need to be garbage collected. I suspect that the Java designers tried this approach first (which is a lesson in software design—you don’t really know anything about a system until you try it out in code and get something working). I also suspect that they discovered it delivered unacceptable performance.</p>
<p>To see what really happens, you can decompile the above code using the javap tool that comes as part of the JDK. Here’s the command line:</p>
<p>javap -c Concatenation</p>
<p>The -c flag will produce the JVM bytecodes. After we strip out the parts we’re not interested in and do a bit of editing, here are the relevant bytecodes:</p>
<p>public static void main(java.lang.String[]);</p>
<p>Code:</p>
<p>Stack=2, Locals=3, Args_size=1 0:    ldc #2; //String mango</p>
<table>
<tr><td>2:</td><td>astore_1</td><td></td><td></td><td></td></tr>
<tr><td>3:</td><td>new #3; //cla</td><td colspan="2">ss StringBuilder</td><td></td></tr>
<tr><td>6:</td><td>dup</td><td></td><td></td><td></td></tr>
<tr><td>7:</td><td>invokespecial</td><td>#4;</td><td>//StringBui</td><td>lder.&quot;&lt;init&gt;&quot;:()</td></tr>
<tr><td>10:</td><td>ldc #5; // St</td><td>ring</td><td>abc</td><td></td></tr>
<tr><td>12</td><td>invokevirtual</td><td>#6;</td><td>//StringBui</td><td>lder.append:(String)</td></tr>
<tr><td>15</td><td>aload_1</td><td></td><td></td><td></td></tr>
<tr><td>16</td><td>invokevirtual</td><td>#6;</td><td>//StringBui</td><td>lder.append:(String)</td></tr>
<tr><td>19</td><td>ldc #7; //Str</td><td>ing</td><td>def</td><td></td></tr>
<tr><td>21</td><td>invokevirtual</td><td>#6;</td><td>//StringBui</td><td>lder.append:(String)</td></tr>
<tr><td>24</td><td>bipush 47</td><td></td><td></td><td></td></tr>
<tr><td>26</td><td>invokevirtual</td><td>#8;</td><td>//StringBui</td><td>lder.append:(I)</td></tr>
<tr><td>29</td><td>invokevirtual</td><td>#9;</td><td>//StringBui</td><td>lder.toString:()</td></tr>
<tr><td>32</td><td>astore_2</td><td></td><td></td><td></td></tr>
<tr><td>33</td><td>getstatic #10</td><td>; //</td><td>Field System</td><td>.out:PrintStream;</td></tr>
<tr><td>36</td><td>aload_2</td><td></td><td></td><td></td></tr>
<tr><td>37</td><td>invokevirtual</td><td>#11</td><td>; // PrintSt</td><td>ream.println:(String)</td></tr>
<tr><td>40</td><td>return</td><td></td><td></td><td></td></tr>
</table>
<p>If you’ve had experience with assembly language, this may look familiar to you—statements like dup and invokevirtual are the Java Virtual Machine (JVM) equivalent of assembly language. If you’ve never seen assembly language, don’t worry about it—the important part to notice is the introduction by the compiler of the java.lang.StringBuilder class. There was no mention of StringBuilder in the source code, but the compiler decided to use it anyway, because it is much more efficient.</p>
<p>In this case, the compiler creates a StringBuilder object to build the String s, and calls append( ) four times, one for each of the pieces. Finally, it calls toString( ) to produce the result, which it stores (with astore_2) as s.</p>
<p>Before you assume that you should just use Strings everywhere and that the compiler will make everything efficient, let’s look a little more closely at what the compiler is doing. Here’s an example that produces a String result in two ways: using Strings, and by hand-coding with StringBuilder: //: strings/WhitherStringBuilder.java</p>
<p>public class WhitherStringBuilder {</p>
<p>public String implicit(String[] fields) {</p>
<p>String result =</p>
<p>for(int i = 0; i &lt; fields.length; i++) result += fields[i]; return result;</p>
<p>}</p>
<p>public String explicit(String[] fields) {</p>
<p>StringBuilder result = new StringBuilder(); for(int i = 0; i &lt; fields.length; i++) result.append(fields[i]); return result.toString();</p>
<p>}</p>
<p>} ///:~</p>
<p>Now if you run javap -c WitherStringBuilder, you can see the (simplified) code for the two different methods. First, implicit( ):</p>
<p>public java.lang.String implicit(java.lang.String[]);</p>
<p>Code:</p>
<table>
<tr><td>0:</td><td>ldc #2</td><td>//String</td></tr>
<tr><td>2:</td><td>astore_</td><td>_2</td></tr>
<tr><td>3:</td><td>iconst_</td><td>_0</td></tr>
<tr><td>4:</td><td>istore</td><td>_3</td></tr>
</table>
<p>ngBuilder</p>
<table>
<tr><td>5:</td><td>iload_3</td><td></td><td></td></tr>
<tr><td>6:</td><td>aload_1</td><td></td><td></td></tr>
<tr><td>7:</td><td>arraylength</td><td></td><td></td></tr>
<tr><td>8:</td><td>if_icmpge 38</td><td></td><td></td></tr>
<tr><td>11:</td><td colspan="3">new #3; //class Stri</td></tr>
<tr><td>14:</td><td>dup</td><td></td><td></td></tr>
<tr><td>15:</td><td>invokespecial</td><td>#4;</td><td>//</td></tr>
<tr><td>18:</td><td>aload_2</td><td></td><td></td></tr>
<tr><td>19:</td><td>invokevirtual</td><td>LO=H=</td><td>//</td></tr>
<tr><td>22:</td><td>aload_1</td><td></td><td></td></tr>
<tr><td>23</td><td>iload_3</td><td></td><td></td></tr>
<tr><td>24</td><td>aaload</td><td></td><td></td></tr>
<tr><td>25:</td><td>invokevirtual</td><td>#5;</td><td>//</td></tr>
<tr><td>28:</td><td>invokevirtual</td><td>#6;</td><td>//</td></tr>
<tr><td>31:</td><td>astore_2</td><td></td><td></td></tr>
<tr><td>32:</td><td>iinc 3, 1</td><td></td><td></td></tr>
<tr><td>35:</td><td>goto 5</td><td></td><td></td></tr>
<tr><td>38:</td><td>aload_2</td><td></td><td></td></tr>
<tr><td>39</td><td>areturn</td><td></td><td></td></tr>
</table>
<p>StringBuilder.”&lt;init&gt;”:Q</p>
<p>StringBuilder.append:()</p>
<p>StringBuilder.append:()</p>
<p>StringBuiIder.toString:()</p>
<p>Notice 8: and 35:, which together form a loop. 8: does an &quot;integer compare greater than or equal to&quot; of the operands on the stack and jumps to 38: when the loop is done. 35: is a goto back to the beginning of the loop, at 5:. The important thing to note is that the StringBuilder construction happens inside this loop, which means you’re going to get a new StringBuilder object every time you pass through the loop.</p>
<p>Here are the bytecodes for explicit( ):</p>
<p>public java.lang.String explicit(java.lang.String[]);</p>
<p>Code:</p>
<p>0:    new #3; //class StringBuilder</p>
<p>3:    dup</p>
<p>4:    invokespecial    #4;    //    StringBuilder.”&lt;init&gt;”:Q</p>
<p>7:    astore_2</p>
<p>8:    iconst_0</p>
<p>9:    istore_3</p>
<p>10:    iload_3</p>
<p>11:    aload_1</p>
<p>12:    arraylength</p>
<p>13:    if_icmpge 30</p>
<p>16:    aload_2</p>
<p>17:    aload_1</p>
<p>18:    iload_3</p>
<p>19:    aaload</p>
<p>20    invokevirtual #5; // StringBuilder.append:()</p>
<p>23    pop</p>
<p>24:    iinc 3,1</p>
<p>27:    goto 10</p>
<p>30:    aload_2</p>
<p>31:    invokevirtual    #6;    //    StringBuiIder.toString:()</p>
<p>34:    areturn</p>
<p>Not only is the loop code shorter and simpler, the method only creates a single StringBuilder object. Creating an explicit StringBuilder also allows you to preallocate its size if you have extra information about how big it might need to be, so that it doesn’t need to constantly reallocate the buffer.</p>
<p>Thus, when you create a toString( ) method, if the operations are simple ones that the compiler can figure out on its own, you can generally rely on the compiler to build the result in a reasonable fashion. But if looping is involved, you should explicitly use a StringBuilder in your toString( ), like this:</p>
<p>//: strings/UsingStringBuilder.java import java.util.*;</p>
<p>public class UsingStringBuilder {</p>
<p>public static Random rand = new Random(47); public String toStringQ {</p>
<p>StringBuilder result = new StringBuilder(&quot;[&quot;); for(int i = 0; i &lt; 25; i++) {</p>
<p>result.append(rand.nextInt(100)); result.append(&quot;, &quot;);</p>
<p>}</p>
<p>result.delete(result.length()-2, result.length());</p>
<p>result.append(&quot;]&quot;);</p>
<p>return result.toString();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>UsingStringBuilder usb = new UsingStringBuilder(); System.out.println(usb);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[58, 55, 93, 61, 61, 29, 68, 0, 22, 7, 88, 28, 51, 89, 9, 78, 98, 61,</p>
<p>20, 58, 16, 40, 11, 22, 4]</p>
<p>*///:~</p>
<p>Notice that each piece of the result is added with an append( ) statement. If you try to take shortcuts and do something like append(a + &quot;: &quot; + c), the compiler will jump in and start making more StringBuilder objects again.</p>
<p>If you are in doubt about which approach to use, you can always run javap to double-check.</p>
<p>Although StringBuilder has a full complement of methods, including insert( ), replace( ), substring( ) and even reverse( ), the ones you will generally use are append( ) and toString( ). Note the use of delete( ) to remove the last comma and space before adding the closing square bracket.</p>
<p>StringBuilder was introduced in Java SE5. Prior to this, Java used StringBuffer, which ensured thread safety (see the Concurrency chapter) and so was significantly more expensive. Thus, string operations in Java SE5/6 should be faster.</p>
<p>Exercise 1: (2) Analyze SprinklerSystem.toString( ) in</p>
<p>reusing/SprinklerSystem.java to discover whether writing the toString( ) with an explicit StringBuilder will save any StringBuilder creations.</p>
</section>
<section>
<title>
<p>Unintended recursion</p></title><empty-line/>
<p>Because (like every other class) the Java standard containers are ultimately inherited from Object, they contain a toString( ) method. This has been overridden so that they can produce a String representation of themselves, including the objects they hold. ArrayList.toString( ), for example, steps through the elements of the Array List and calls toString( ) for each one:</p>
<p>//: strings/ArrayListDisplay.java import generics.coffee.*;</p>
<p>public class ArrayListDisplay {</p>
<p>public static void main(String[] args) {</p>
<p>ArrayList&lt;Coffee&gt; coffees = new ArrayList&lt;Coffee&gt;(); for(Coffee c : new CoffeeGenerator(10)) coffees.add(c);</p>
<p>System.out.println(coffees);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[Americano 0, Latte 1, Americano 2, Mocha 3, Mocha 4, Breve 5, Americano 6, Latte 7, Cappuccino 8, Cappuccino 9]</p>
<p>*///:~</p>
<p>Suppose you’d like your toString( ) to print the address of your class. It seems to make sense to simply refer to this:</p>
<p>//: strings/InfiniteRecursion.java // Accidental recursion.</p>
<p>// {RunByHand} import java.util.*;</p>
<p>public class InfiniteRecursion { public String toString() {</p>
<p>return &quot; InfiniteRecursion address: &quot; + this + &quot;\n&quot;;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;InfiniteRecursion&gt; v =</p>
<p>new ArrayList&lt;InfiniteRecursion&gt;(); for(int i = 0; i &lt; 10; i++)</p>
<p>v.add(new InfiniteRecursion());</p>
<p>System.out.println(v);</p>
<p>}</p>
<p>} ///:~</p>
<p>If you create an InfiniteRecursion object and then print it, you’ll get a very long sequence of exceptions. This is also true if you place the InfiniteRecursion objects in an ArrayList and print that ArrayList as shown here. What’s happening is automatic type conversion for Strings. When you say:</p>
<p>&quot;InfiniteRecursion address: &quot; + this</p>
<p>The compiler sees a String followed by a’+’ and something that’s not a String, so it tries to convert this to a String. It does this conversion by calling toString( ), which produces a recursive call.</p>
<p>If you really do want to print the address of the object, the solution is to call the ObjecttoString( ) method, which does just that. So instead of saying this, you’d say super.toString( ).</p>
<p>Exercise 2: (1) Repair InfiniteRecursion.java.</p>
</section>
<section>
<title>
<p>Operations on Strings</p></title><empty-line/>
<p>Here are some of the basic methods available for String objects. Methods that are overloaded are summarized in a single row:</p>
<table>
<tr><td>Method</td><td>Arguments, Overloading</td><td>Use</td></tr>
<tr><td>Constructor</td><td>Overloaded: default, String, StringBuilder, StringBuffer, char arrays, byte arrays.</td><td>Creating String objects.</td></tr>
<tr><td>length( )</td><td></td><td>Number of characters in the String.</td></tr>
<tr><td>charAt( )</td><td>int Index</td><td>The char at a location in the String.</td></tr>
<tr><td>getChars( ), getBytes( )</td><td>The beginning and end from which to copy, the array to copy into, an index into the destination array.</td><td>Copy chars or bytes into an external array.</td></tr>
<tr><td>toCharArray( )</td><td></td><td>Produces a char[] containing the characters in the String.</td></tr>
<tr><td>equals( ), equals-IgnoreCase( )</td><td>A String to compare with.</td><td>An equality check on the contents of the two Strings.</td></tr>
<tr><td>compareTo( )</td><td>A String to compare with.</td><td>Result is negative, zero, or positive depending on the lexicographical ordering of the String and the argument. Uppercase and lowercase are not equal!</td></tr>
<tr><td>contains( )</td><td>A CharSequence to search for.</td><td>Result is true if the argument is contained in the String.</td></tr>
<tr><td>contentEquals( )</td><td>A CharSequence or StringBuffer to compare to.</td><td>Result is true if there’s an exact match with the argument.</td></tr>
<tr><td>equalsIgnoreCase( )</td><td>A String to compare with.</td><td>Result is true if the contents are equal, ignoring case.</td></tr>
<tr><td>regionMatches( )</td><td>Offset into this String, the other String and its offset and length to compare. Overload adds &quot;ignore case.&quot;</td><td>boolean result indicates whether the region matches.</td></tr>
<tr><td>startsWith( )</td><td>String that it might start with. Overload adds offset into argument.</td><td>boolean result indicates whether the String starts with the argument.</td></tr>
<tr><td>endsWith( )</td><td>String that might be a suffix of this String.</td><td>boolean result indicates whether the argument is a suffix.</td></tr>
<tr><td>indexOf( ), lastIndexOf( )</td><td>Overloaded: char, char and starting index, String,</td><td>Returns -1 if the argument is not found within this String; otherwise, returns</td></tr>
</table>
<table>
<tr><td>Method</td><td>Arguments, Overloading</td><td>Use</td></tr>
<tr><td></td><td>String and starting index.</td><td>the index where the argument starts. lastIndexOf( ) searches backward from end.</td></tr>
<tr><td>substring( ) (also subSequence( ))</td><td>Overloaded: starting index; starting index + ending index.</td><td>Returns a new String object containing the specified character set.</td></tr>
<tr><td>concat( )</td><td>The String to concatenate.</td><td>Returns a new String object containing the original String’s characters followed by the characters in the argument.</td></tr>
<tr><td>replace()</td><td>The old character to search for, the newcharacter to replace it with. Can also replace a CharSequence with a CharSequence.</td><td>Returns a new String object with thereplacements made. Uses the old String if no match is found.</td></tr>
<tr><td>toLowerCase( ) toUpperCase( )</td><td></td><td>Returns a new String object with the case of all letters changed. Uses the old String if no changes need to be made.</td></tr>
<tr><td>trim( )</td><td></td><td>Returns a new String object with the whitespace removed from each end. Uses the old String if no changes need to be made.</td></tr>
<tr><td>valueOf( )</td><td>Overloaded: Object, char[], char[] and offset and count, boolean, char, int, long, float, double.</td><td>Returns a String containing a character representation of the argument.</td></tr>
<tr><td>intern( )</td><td></td><td>Produces one and only one String reference per unique character sequence.</td></tr>
</table>
<p>You can see that every String method carefully returns a new String object when it’s necessary to change the contents. Also notice that if the contents don’t need changing, the method will just return a reference to the original String. This saves storage and overhead.</p>
<p>The String methods involving regular expressions will be explained later in this chapter.</p>
</section>
<section>
<title>
<p>Formatting output</p></title><empty-line/>
<p>One of the long-awaited features that has finally appeared in Java SE5 is output formatting in the style of C’s printf( ) statement. Not only does this allow for simplified output code, but it also gives Java developers powerful control over output formatting and alignment.<a l:href="#bookmark56" type="note"><sup>57</sup></a><sup></sup></p>
<p>printf()</p>
<p>C’s printf( ) doesn’t assemble strings the way Java does, but takes a single format string and inserts values into it, formatting as it goes. Instead of using the overloaded ‘+’ operator (which C doesn’t overload) to concatenate quoted text and variables, printf( ) uses special placeholders to show where the data should go. The arguments that are inserted into the format string follow in a comma-separated list.</p>
<p>For example:</p>
<p>printf(&quot;Row 1: [%d %f]\n&quot;, x, y);</p>
<p>At run time, the value of x is inserted into %d and the value of y is inserted into %f. These placeholders are called/ormaf specifiers and, in addition to telling where to insert the value, they also tell what kind of variable is to be inserted and how to format it. For instance, the %d’ above says that x is an integer and the ‘%f says y is a floating point value (a float or double).</p>
<p>System.out.format()</p>
<p>Java SE5 introduced the format( ) method, available to PrintStream or PrintWriter objects (which you’ll learn more about in the I/O chapter), which includes System.out. The format( ) method is modeled after C’s printf( ). There’s even a convenience printf( ) method that you can use if you’re feeling nostalgic, which just calls format( ). Here’s a simple example:</p>
<p>//: strings/SimpleFormat.java</p>
<table>
<tr><th colspan="7">public class SimpleFormat {</th></tr>
<tr><td>public st</td><td>;atic</td><td>void ma</td><td>in(St</td><td>ring[]</td><td>args)</td><td>{</td></tr>
<tr><td>int x =</td><td><sup>:</sup> 5;</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>double</td><td>y =</td><td>5.332542</td><td>;</td><td></td><td></td><td></td></tr>
<tr><td>// The</td><td>old</td><td>way:</td><td></td><td></td><td></td><td></td></tr>
<tr><td>System.</td><td>out.</td><td>println(</td><td>&quot;Row</td><td>1: [&quot;</td><td>+ x + &quot;</td><td>&quot; + y</td></tr>
<tr><td>// The</td><td>new</td><td>way:</td><td></td><td></td><td></td><td></td></tr>
<tr><td>System.</td><td>out.</td><td>format(&quot;</td><td>Row 1</td><td>: [%d</td><td>%f]\n&quot;,</td><td>x, y)</td></tr>
<tr><td>// or</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>System.</td><td>out.</td><td>printf(&quot;</td><td>Row 1</td><td>: [%d</td><td>%f]\n&quot;,</td><td>x, y)</td></tr>
</table>
<p>}</p>
<p>} /* Output:</p>
<p>Row 1: [5 5.332542] Row 1: [5 5.332542] Row 1: [5 5.332542] *///:~</p>
<p>You can see that format( ) and printf( ) are equivalent. In both cases, there’s only a single format string, followed by one argument for each format specifier.</p>
<subtitle>The Formatter class</subtitle>
<p>All of Java’s new formatting functionality is handled by the Formatter class in the java.util package. You can think of Formatter as a translator that converts your format string and data into the desired result. When you create a Formatter object, you tell it where you want this result to go by passing that information to the constructor:</p>
<p>//: strings/Turtle.java</p>
<p>public class Turtle {</p>
<p>private String name;</p>
<p>private Formatter f;</p>
<p>public Turtle(String name, Formatter f) { this.name = name; this.f = f;</p>
<p>}</p>
<p>public void move(int x, int y) {</p>
<p>f.format(&quot;%s The Turtle is at (%d,%d)\n&quot;, name, x, y);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>PrintStream outAlias = System.out;</p>
<p>Turtle tommy = new Turtle(&quot;Tommy&quot;, new Formatter(System.out));</p>
<p>Turtle terry = new Turtle(&quot;Terry&quot;, new Formatter(outAlias)); tommy.move(0,0); terry.move(4,8); tommy.move(3,4); terry.move(2,5); tommy.move(3,3); terry.move(3,3);</p>
<p>}</p>
<table>
<tr><th colspan="6">} /* Output:</th></tr>
<tr><td>Tommy</td><td>The</td><td>Turtle</td><td>is</td><td>at</td><td>(0,0)</td></tr>
<tr><td>Terry</td><td>The</td><td>Turtle</td><td>is</td><td>at</td><td>(4,8)</td></tr>
<tr><td>Tommy</td><td>The</td><td>Turtle</td><td>is</td><td>at</td><td>(3,4)</td></tr>
<tr><td>Terry</td><td>The</td><td>Turtle</td><td>is</td><td>at</td><td>(2,5)</td></tr>
<tr><td>Tommy</td><td>The</td><td>Turtle</td><td>is</td><td>at</td><td>(3,3)</td></tr>
<tr><td>Terry*///:-</td><td>The</td><td>Turtle</td><td>is</td><td>at</td><td>(3,3)</td></tr>
</table>
<p>All the tommy output goes to System.out and all the terry output goes to an alias of System.out. The constructor is overloaded to take a range of output locations, but the most useful are PrintStreams (as above), OutputStreams, and Files. You’ll learn more about these in the I/O chapter.</p>
<p>Exercise 3: (1) Modify Turtle.java so that it sends all output to System.err.</p>
<p>The previous example uses a new format specifier, ‘%s’. This indicates a String argument and is an example of the simplest kind of format specifier-one that has only a conversion <sup>t</sup>yp<sup>e</sup>.</p>
<subtitle>Format specifiers</subtitle>
<p>To control spacing and alignment when data is inserted, you need more elaborate format specifiers. Here’s the general syntax:</p>
<p>%[argument_index$][flags][width][.precision]conversion</p>
<p>Often, you’ll need to control the minimum size of a field. This can be accomplished by specifying a width. The Formatter guarantees that a field is at least a certain number of characters wide by padding it with spaces if necessary. By default, the data is right justified, but this can be overridden by including a ‘-’ in the flags section.</p>
<p>The opposite of width is precision, which is used to specify a maximum. Unlike the width, which is applicable to all of the data conversion types and behaves the same with each, precision has a different meaning for different types. For Strings, the precision specifies the maximum number of characters from the String to print. For floating point numbers, precision specifies the number of decimal places to display (the default is 6), rounding if there are too many or adding trailing zeroes if there are too few. Since integers have no fractional part, precision isn’t applicable to them and you’ll get an exception if you use precision with an integer conversion type.</p>
<p>This example uses format specifiers to print a shopping receipt:</p>
<p>//: strings/Receipt.java import java.util.*;</p>
<p>public class Receipt { private double total = 0;</p>
<p>private Formatter f = new Formatter(System.out); public void printTitle() {</p>
<p>f.format(&quot;%-15s %5s %10s\n&quot;, &quot;Item&quot;, &quot;Qty&quot;, &quot;Price&quot;); f.format(&quot;%-15s %5s %10s\n&quot;, &quot;----&quot;, &quot;---&quot;, &quot;-----&quot;);</p>
<p>}</p>
<p>public void print(String name, int qty, double price) { f.format(&quot;%-15.15s %5d %10.2f\n&quot;, name, qty, price); total += price;</p>
<p>}</p>
<p>public void printTotal() {</p>
<p>f.format(&quot;%-15s %5s %10.2f\n&quot;, &quot;Tax&quot;, &quot;&quot;, total*0.06);</p>
<p>f.format(&quot;%-15s %5s %10s\n&quot;, &quot;&quot;, &quot;&quot;, &quot;-----&quot;);</p>
<p>f.format(&quot;%-15s %5s %10.2f\n&quot;, &quot;Total&quot;, &quot;&quot;, total * 1.06);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Receipt receipt = new Receipt(); receipt.printTitle();</p>
<p>receipt.print(&quot;Jack’s Magic Beans&quot;, 4, 4.25); receipt.print(&quot;Princess Peas&quot;, 3, 5.1); receipt.print(&quot;Three Bears Porridge&quot;, 1, 14.29); receipt.printTotal();</p>
<table>
<tr><th colspan="3">}</th></tr>
<tr><td>} /* Output: Item</td><td>Qty</td><td>Price</td></tr>
<tr><td>Jack’s Magic Be</td><td>4</td><td>4.25</td></tr>
<tr><td>Princess Peas</td><td>3</td><td>5.10</td></tr>
<tr><td>Three Bears Por</td><td>1</td><td>14.29</td></tr>
<tr><td>Tax</td><td></td><td>1.42</td></tr>
<tr><td>Total*///:~</td><td></td><td>25.06</td></tr>
</table>
<p>As you can see, the Formatter provides powerful control over spacing and alignment with fairly concise notation. Here, the format strings are simply copied in order to produce the appropriate spacing.</p>
<p>Exercise 4: (3) Modify Receipt.java so that the widths are all controlled by a single set of constant values. The goal is to allow you to easily change a width by changing a single value in one place.</p>
<subtitle>Formatter conversions</subtitle>
<table>
<tr><th colspan="2">These are the conversions you’ll come across most frequently:</th></tr>
<tr><td colspan="2">Conversion Characters</td></tr>
<tr><td>d</td><td>Integral (as decimal)</td></tr>
<tr><td>c</td><td>Unicode character</td></tr>
<tr><td>b</td><td>Boolean value</td></tr>
<tr><td>s</td><td>String</td></tr>
<tr><td>f</td><td>Floating point (as decimal)</td></tr>
<tr><td>e</td><td>Floating point (in scientific notation)</td></tr>
<tr><td>x</td><td>Integral (as hex)</td></tr>
<tr><td>h</td><td>Hash code (as hex)</td></tr>
<tr><td>%</td><td>Literal</td></tr>
</table>
<p>Here’s an example that shows these conversions in action:</p>
<p>//: strings/Conversion.java import java.math.*; import java.util.*;</p>
<p>public class Conversion {</p>
<p>public static void main(String[] args) { Formatter f = new Formatter(System.out);</p>
<p>char u = ‘a’;</p>
<p>System.out.println(&quot;u = ‘a’&quot;); f.format(&quot;s: %s\n&quot;, u);</p>
<p>// f.format(&quot;d: %d\n&quot;, u); f.format(&quot;c: %c\n&quot;, u); f.format(&quot;b: %b\n&quot;, u);</p>
<p>// f.format(&quot;f: %f\n&quot;, u);</p>
<p>// f.format(&quot;e: %e\n&quot;, u);</p>
<p>// f.format(&quot;x: %x\n&quot;, u); f.format(&quot;h: %h\n&quot;, u);</p>
<p>int v = 121;</p>
<p>System.out.println(&quot;v = 121&quot;); f.format(&quot;d: %d\n&quot;, v); f.format(&quot;c: %c\n&quot;, v); f.format(&quot;b: %b\n&quot;, v); f.format(&quot;s: %s\n&quot;, v);</p>
<p>// f.format(&quot;f: %f\n&quot;, v);</p>
<p>// f.format(&quot;e: %e\n&quot;, v); f.format(&quot;x: %x\n&quot;, v); f.format(&quot;h: %h\n&quot;, v);</p>
<p>BigInteger w = new BigInteger(&quot;50000000000000&quot;); System.out.println(</p>
<p>&quot;w = new BigInteger(\&quot;50000000000000\&quot;)&quot;);</p>
<table>
<tr><td></td><td>f.</td><td>format(&quot;d:</td><td>%d\n&quot;,</td><td>w)</td><td>;</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;c: %c\n&quot;,</td><td>w);</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;b:</td><td>%b\n&quot;,</td><td>w)</td><td>;</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;s:</td><td>%s\n&quot;,</td><td>w)</td><td>;</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;f: %f\n&quot;,</td><td>w);</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;e: %e\n&quot;,</td><td>w);</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;x:</td><td>%x\n&quot;,</td><td>w)</td><td>;</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;h:</td><td>%h\n&quot;,</td><td>w)</td><td><sup>;</sup></td><td></td></tr>
<tr><td></td><td colspan="3">double x = 179.543;</td><td></td><td></td><td></td></tr>
<tr><td></td><td>sy</td><td>stem.out.p</td><td>rintln(</td><td>x</td><td>= 179</td><td>543&quot;)</td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;d: %d\n&quot;,</td><td>x);</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;c: %c\n&quot;,</td><td>x);</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;b:</td><td>%b\n&quot;,</td><td>x)</td><td>;</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;s:</td><td>%s\n&quot;,</td><td>x)</td><td>;</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;f:</td><td>%f\n&quot;,</td><td>x)</td><td>;</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;e:</td><td>%e\n&quot;,</td><td>x)</td><td>;</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;x: %x\n&quot;,</td><td>x);</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;h:</td><td>%h\n&quot;,</td><td>x)</td><td><sup>;</sup></td><td></td></tr>
<tr><td></td><td colspan="2">Conversion y</td><td colspan="4">= new Conversion();</td></tr>
<tr><td></td><td>sy</td><td>stem.out.p</td><td>rintln(</td><td><sup>y</sup></td><td>= new</td><td>Conve</td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;d: %d\n&quot;,</td><td>y);</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;c: %c\n&quot;,</td><td>y);</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;b:</td><td>%b\n&quot;,</td><td>y)</td><td>;</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;s:</td><td>%s\n&quot;,</td><td>y)</td><td>;</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;f: %f\n&quot;,</td><td>y);</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;e: %e\n&quot;,</td><td>y);</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;x: %x\n&quot;,</td><td>y);</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;h:</td><td>%h\n&quot;,</td><td>y)</td><td><sup>;</sup></td><td></td></tr>
<tr><td></td><td colspan="2">boolean z =</td><td>false;</td><td></td><td></td><td></td></tr>
<tr><td></td><td>sy</td><td>stem.out.p</td><td>rintln(</td><td>z</td><td colspan="2">= false&quot;);</td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;d: %d\n&quot;,</td><td>z);</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;c: %c\n&quot;,</td><td>z);</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;b:</td><td>%b\n&quot;,</td><td>z)</td><td>;</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;s:</td><td>%s\n&quot;,</td><td>z)</td><td>;</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;f: %f\n&quot;,</td><td>z);</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;e: %e\n&quot;,</td><td>z);</td><td></td></tr>
<tr><td></td><td>//</td><td>f.format(</td><td colspan="2">&quot;x: %x\n&quot;,</td><td>z);</td><td></td></tr>
<tr><td></td><td>f.</td><td>format(&quot;h:</td><td>%h\n&quot;,</td><td>z)</td><td><sup>;</sup></td><td></td></tr>
<tr><td>}</td><td colspan="3">/* Output: (Sample)</td><td></td><td></td><td></td></tr>
<tr><td>u</td><td>= ‘a</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>s</td><td>a</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>c</td><td>a</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>b</td><td colspan="2">true</td><td></td><td></td><td></td><td></td></tr>
<tr><td>h</td><td>61</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>v</td><td>= 12</td><td>1</td><td></td><td></td><td></td><td></td></tr>
<tr><td>d</td><td>121</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>c</td><td>y</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>b</td><td colspan="2">true</td><td></td><td></td><td></td><td></td></tr>
<tr><td>s</td><td>121</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>x</td><td>79</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>h</td><td>79</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>w</td><td colspan="6">= new BigInteger(&quot;50000000000000&quot;)</td></tr>
<tr><td>d</td><td colspan="3">50000000000000</td><td></td><td></td><td></td></tr>
<tr><td>b</td><td colspan="2">true</td><td></td><td></td><td></td><td></td></tr>
<tr><td>s</td><td colspan="3">50000000000000</td><td></td><td></td><td></td></tr>
<tr><td>x</td><td colspan="2">2d79883d2000</td><td></td><td></td><td></td><td></td></tr>
<tr><td>h</td><td colspan="2">8842a1a7</td><td></td><td></td><td></td><td></td></tr>
<tr><td>x</td><td colspan="2">= 179.543</td><td></td><td></td><td></td><td></td></tr>
<tr><td>b</td><td colspan="2">true</td><td></td><td></td><td></td><td></td></tr>
</table>
<p>s: 179.543 f: 179.543000 e: 1.795430e+02 h: 1ef462c</p>
<p>y = new Conversion() b: true</p>
<p>s: Conversion@9cab16 h: 9cab16 z = false b: false s: false h: 4d5 *///:~</p>
<p>The commented lines show conversions that are invalid for that particular variable type; executing them will trigger an exception.</p>
<p>Notice that the ‘b’ conversion works for each variable above. Although it’s valid for any argument type, it might not behave as you’d expect. For boolean primitives or Boolean objects, the result will be true or false, accordingly. However, for any other argument, as long as the argument type is not null the result is always true. Even the numeric value of zero, which is synonymous with false in many languages (including C), will produce true, so be careful when using this conversion with non-boolean types.</p>
<p>There are more obscure conversion types and other format specifier options. You can read about these in the JDK documentation for the Formatter class.</p>
<p>Exercise 5: (5) For each of the basic conversion types in the above table, write the most complex formatting expression possible. That is, use all the possible format specifiers available for that conversion type.</p>
<subtitle>String.format()</subtitle>
<p>Java SE5 also took a cue from C’s sprintf( ), which is used to create Strings. String.format( ) is a static method which takes all the same arguments as Formatter’s format( ) but returns a String. It can come in handy when you only need to call format( ) once:</p>
<p>//: strings/DatabaseException.java</p>
<p>public class DatabaseException extends Exception {</p>
<p>public DatabaseException(int transactionID, int querylD,</p>
<p>String message) {</p>
<p>super(String.format(&quot;(t%d, q%d) %s&quot;, transactionID, querylD, message));</p>
<p>}</p>
<p>public static void main(String[] args) { try {</p>
<p>throw new DatabaseException(3, 7, &quot;Write failed&quot;);</p>
<p>} catch(Exception e) {</p>
<p>System.out.println(e);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>DatabaseException: (t3, q7) Write failed *///:~</p>
<p>Under the hood, all String.format( ) does is instantiate a Formatter and pass your arguments to it, but using this convenience method can often be clearer and easier than doing it by hand.</p>
<p>A hex dump tool</p>
<p>As a second example, often you want to look at the bytes inside a binary file using hex format. Here’s a small utility that displays a binary array of bytes in a readable hex format, using String.format( ):</p>
<p>//: net/mindview/util/Hex.java package net.mindview.util; import java.io.*;</p>
<p>public class Hex {</p>
<p>public static String format(byte[] data) {</p>
<p>StringBuilder result = new StringBuilder(); int n = 0;</p>
<p>for(byte b : data) { if(n % 16 == 0)</p>
<p>result.append(String.format(&quot;%05X: &quot;, n)); result.append(String.format(&quot;%02X &quot;, b)); n++;</p>
<p>if(n % 16 == 0) result.append(&quot;\n&quot;);</p>
<p>}</p>
<p>result.append(&quot;\n&quot;); return result.toString();</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { if(args.length == 0)</p>
<p>// Test by displaying this class file:</p>
<p>System.out.println(</p>
<p>format(BinaryFile.read(&quot;Hex.class&quot;)));</p>
<p>else</p>
<p>System.out.println(</p>
<p>format(BinaryFile.read(new File(args[0]))));</p>
<table>
<tr><th colspan="17">}</th></tr>
<tr><td>} /* 00000:</td><td colspan="2">iutput: CA FE</td><td colspan="3">(Sample) BA BE 00</td><td>00</td><td>00</td><td>31</td><td>00</td><td>52</td><td>0A</td><td>00</td><td>05</td><td>00</td><td>22</td><td>07</td></tr>
<tr><td>00010:</td><td>00</td><td>23</td><td>0A</td><td>00</td><td>02</td><td>00</td><td>22</td><td>08</td><td>00</td><td>24</td><td>07</td><td>00</td><td>25</td><td>0A</td><td>00</td><td>26</td></tr>
<tr><td>00020:</td><td>00</td><td>27</td><td>0A</td><td>00</td><td>28</td><td>00</td><td>29</td><td>0A</td><td>00</td><td>02</td><td>00</td><td>2A</td><td>08</td><td>00</td><td>2B</td><td>0A</td></tr>
<tr><td>00030</td><td>00</td><td>2C</td><td>00</td><td>2D</td><td>08</td><td>00</td><td>2E</td><td>0A</td><td>00</td><td>02</td><td>00</td><td>2F</td><td>09</td><td>00</td><td>30</td><td>00</td></tr>
<tr><td>00040</td><td>31</td><td>08</td><td>00</td><td>32</td><td>0A</td><td>00</td><td>33</td><td>00</td><td>34</td><td>0A</td><td>00</td><td>15</td><td>00</td><td>35</td><td>0A</td><td>00</td></tr>
<tr><td>00050:</td><td>36</td><td>00</td><td>37</td><td>07</td><td>00</td><td>38</td><td>0A</td><td>00</td><td>12</td><td>00</td><td>39</td><td>0A</td><td>00</td><td>33</td><td>00</td><td>3A</td></tr>
<tr><td colspan="17">*///:~</td></tr>
</table>
<p>To open and read the binary file, this uses another utility that will be introduced in the I/O chapter: net.mindview.utiLBinaryFile. The read( ) method returns the entire file as a byte array.</p>
<p>Exercise 6: (2) Create a class that contains int, long, float and double fields. Create a toString( ) method for this class that uses String.format( ), and demonstrate that your class works correctly.</p>
</section>
<section>
<title>
<p>Regular expressions</p></title><empty-line/>
<p>Regular expressions have long been integral to standard Unix utilities like sed and awk, and languages like Python and Perl (some would argue that they are the predominant reason for Perl’s success). String manipulation tools were previously delegated to the String, StringBuffer, and StringTokenizer classes in Java, which had relatively simple facilities compared to regular expressions.</p>
<p>Regular expressions are powerful and flexible text-processing tools. They allow you to specify, programmatically, complex patterns of text that can be discovered in an input string. Once you discover these patterns, you can then react to them any way you want. Although the syntax of regular expressions can be intimidating at first, they provide a compact and dynamic language that can be employed to solve all sorts of string processing, matching and selection, editing, and verification problems in a completely general way.</p>
<subtitle>Basics</subtitle>
<p>A regular expression is a way to describe strings in general terms, so that you can say, &quot;If a string has these things in it, then it matches what I’m looking for.&quot; For example, to say that a number might or might not be preceded by a minus sign, you put in the minus sign followed by a question mark, like this:</p>
<p>-?</p>
<p>To describe an integer, you say that it’s one or more digits. In regular expressions, a digit is described by saying ‘\d’. If you have any experience with regular expressions in other languages, you’ll immediately notice a difference in the way backslashes are handled. In other languages, ‘\\’ means &quot;I want to insert a plain old (literal) backslash in the regular expression. Don’t give it any special meaning.&quot; In Java, ‘ \ \ ‘ means &quot;I’m inserting a regular expression backslash, so that the following character has special meaning.&quot; For example, if you want to indicate a digit, your regular expression string will be ‘\\d’. If you want to insert a literal backslash, you say ‘\\\\’- However, things like newlines and tabs just use a single backslash: ‘\n\t’.</p>
<p>To indicate &quot;one or more of the preceding expression,&quot; you use a ‘+’. So to say, &quot;possibly a minus sign, followed by one or more digits,&quot; you write:</p>
<p>-?\\d+</p>
<p>The simplest way to use regular expressions is to use the functionality built into the String class. For example, we can see whether a String matches the regular expression above:</p>
<p>//: strings/IntegerMatch.java</p>
<p>public class IntegerMatch {</p>
<p>public static void main(String[] args) {</p>
<p>System.out.println(&quot;-1234&quot;.matches(&quot;-?\\d+&quot;));</p>
<p>System.out.println(&quot;5678&quot;.matches(&quot;-?\\d+&quot;));</p>
<p>System.out.println(&quot;+911&quot;.matches(&quot;-?\\d+&quot;));</p>
<p>System.out.println(&quot;+911&quot;.matches(&quot;(-|\\+)?\\d+&quot;));</p>
<p>}</p>
<p>} /* Output:</p>
<p>true</p>
<p>true</p>
<p>false</p>
<p>true</p>
<p>*///:~</p>
<p>The first two expressions match, but the third one starts with a ‘+’, which is a legitimate sign but means the number doesn’t match the regular expression. So we need a way to say, &quot;may start with a + or a -.&quot; In regular expressions, parentheses have the effect of grouping an expression, and the vertical bar ‘|’ means OR. So</p>
<p>(-I\\+)?</p>
<p>means that this part of the string may be either a ‘-’ or a ‘+’ or nothing (because of the ‘?’). Because the ‘+’ character has special meaning in regular expressions, it must be escaped with a ‘\\’ in order to appear as an ordinary character in the expression.</p>
<p>A useful regular expression tool that’s built into String is split( ), which means, &quot;Split this string around matches of the given regular expression.&quot;</p>
<p>//: strings/Splitting.java import java.util.*;</p>
<p>public class Splitting {</p>
<p>public static String knights =</p>
<p>&quot;Then, when you have found the shrubbery, you must &quot; +</p>
<p>&quot;cut down the mightiest tree in the forest... &quot; +</p>
<p>&quot;with... a herring!&quot;; public static void split(String regex) {</p>
<p>System.out.println(</p>
<p>Arrays.toString(knights.split(regex)));</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>split(&quot; &quot;); // Doesn’t have to contain regex chars split(&quot;\\W+&quot;); // Non-word characters split(&quot;n\\W+&quot;); // ‘n’ followed by non-word characters</p>
<p>}</p>
<p>} /* Output:</p>
<p>[Then,, when, you, have, found, the, shrubbery,, you, must, cut, down, the, mightiest, tree, in, the, forest..., with..., a, herring!]</p>
<p>[Then, when, you, have, found, the, shrubbery, you, must, cut, down, the, mightiest, tree, in, the, forest, with, a, herring]</p>
<p>[The, whe, you have found the shrubbery, you must cut dow, the mightiest tree i, the forest... with... a herring!]</p>
<p>*///:~</p>
<p>First, note that you may use ordinary characters as regular expressions—a regular expression doesn’t have to contain special characters, as you can see in the first call to split( ), which just splits on whitespace.</p>
<p>The second and third calls to split( ) use ‘\W’, which means a non-word character (the lowercase version, ‘\w’, means a word character)—you can see that the punctuation has been removed in the second case. The third call to split( ) says, &quot;the letter n followed by one or more non-word characters.&quot; You can see that the split patterns do not appear in the result.</p>
<p>An overloaded version of String. split( ) allows you to limit the number of splits that occur.</p>
<p>The final regular expression tool built into String is replacement. You can either replace the first occurrence, or all of them:</p>
<p>//: strings/Replacing.java</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Replacing {</p>
<p>static String s = Splitting.knights; public static void main(String[] args) {</p>
<p>print(s.replaceFirst(&quot;f\\w+&quot;, &quot;located&quot;)); pnnt(s.replaceAll(&quot;shrubbery|tree|hernng&quot;,&quot;banana&quot;));</p>
<p>} /* Output:</p>
<p>Then, when you have located the shrubbery, you must cut down the mightiest tree in the forest... with... a herring!</p>
<p>Then, when you have found the banana, you must cut down the mightiest banana in the forest... with... a banana!</p>
<p>*///:~</p>
<p>The first expression matches the letter f followed by one or more word characters (note that the w is lowercase this time). It only replaces the first match that it finds, so the word &quot;found&quot; is replaced by the word &quot;located.&quot;</p>
<p>The second expression matches any of the three words separated by the OR vertical bars, and it replaces all matches that it finds.</p>
<p>You’ll see that the non-String regular expressions have more powerful replacement tools— for example, you can call methods to perform replacements. Non-String regular expressions are also significantly more efficient if you need to use the regular expression more than once.</p>
<p>Exercise 7: (5) Using the documentation for java.util.regex.Pattern as a resource, write and test a regular expression that checks a sentence to see that it begins with a capital letter and ends with a period.</p>
<p>Exercise 8: (2) Split the string Splitting.knights on the words &quot;the&quot; or “you.&quot;</p>
<p>Exercise 9: (4) Using the documentation for java.util.regex.Pattern as a resource, replace all the vowels in Splitting.knights with underscores.</p>
<subtitle>Creating regular expressions</subtitle>
<p>You can begin learning regular expressions with a subset of the possible constructs. A complete list of constructs for building regular expressions can be found in the JDK documentation for the Pattern class for package java.util.regex.</p>
<table>
<tr><td colspan="2">Characters</td></tr>
<tr><td>B</td><td>The specific character B</td></tr>
<tr><td>\xhh</td><td>Character with hex value oxhh</td></tr>
<tr><td>\uhhhh</td><td>The Unicode character with hex representation oxhhhh</td></tr>
<tr><td>\t</td><td>Tab</td></tr>
<tr><td>\n</td><td>Newline</td></tr>
<tr><td>\r</td><td>Carriage return</td></tr>
<tr><td>\f</td><td>Form feed</td></tr>
<tr><td>\e</td><td>Escape</td></tr>
</table>
<p>The power of regular expressions begins to appear when you are defining character classes. Here are some typical ways to create character classes, and some predefined classes:</p>
<table>
<tr><td colspan="2">Character Classes</td></tr>
<tr><td>.</td><td>Any character</td></tr>
<tr><td>[abc]</td><td>Any of the characters a, b, or c (same as a|b|c)</td></tr>
<tr><td>[<sup>A</sup>abc]</td><td>Any character except a, b, and c (negation)</td></tr>
<tr><td>[a-zA-Z]</td><td>Any character a through z or A through Z (range)</td></tr>
<tr><td>[abc[hij]]</td><td>Any of a,b,c,h,Ij (same as a|b|c|h|i|j) (union)</td></tr>
<tr><td>[a-z&amp;&amp;[hij]]</td><td>Either h, i, or j (intersection)</td></tr>
<tr><td>\s</td><td>A whitespace character (space, tab, newline, form feed, carriage return)</td></tr>
<tr><td>\S</td><td>A non-whitespace character ([<sup>A</sup>\s])</td></tr>
<tr><td>\d</td><td>A numeric digit [0-9]</td></tr>
<tr><td>\D</td><td>A non-digit [<sup>A</sup>o-9]</td></tr>
<tr><td>\w</td><td>A word character [a-zA-Z_o-9]</td></tr>
<tr><td>\W</td><td>A non-word character [a\w]</td></tr>
</table>
<p>What’s shown here is only a sample; you’ll want to bookmark the JDK documentation page for java.util.regex.Pattern so you can easily access all the possible regular expression patterns.</p>
<table>
<tr><td colspan="2">Logical Operators</td></tr>
<tr><td>XY</td><td>X followed by Y</td></tr>
<tr><td>X|Y</td><td>X or Y</td></tr>
<tr><td>(X)</td><td>A capturing group. You can refer to the ith captured group later in the expression with \i.</td></tr>
</table>
<table>
<tr><td colspan="2">Boundary Matchers</td></tr>
<tr><td>A</td><td>Beginning of a line</td></tr>
<tr><td>$</td><td>End of a line</td></tr>
<tr><td>\b</td><td>Word boundary</td></tr>
<tr><td>\B</td><td>Non-word boundary</td></tr>
<tr><td>\G</td><td>End of the previous match</td></tr>
</table>
<p>As an example, each of the following successfully matches the character sequence &quot;Rudolph&quot;: //: strings/Rudolph.java</p>
<p>public class Rudolph {</p>
<p>public static void main(String[] args) {</p>
<p>for(String pattern : new String[]{ &quot;Rudolph&quot;,</p>
<p>&quot;[rR]udolph&quot;, &quot;[rR][aeiou][a-z]ol.*&quot;, &quot;R.*&quot; }) System.out.println(&quot;Rudolph&quot;.matches(pattern));</p>
<p>} /* Output:</p>
<p>true</p>
<p>true</p>
<p>true</p>
<p>true</p>
<p>*///:~</p>
<p>Of course, your goal should not be to create the most obfuscated regular expression, but rather the simplest one necessary to do the job. You’ll find that, once you start writing regular expressions, you’ll often use your code as a reference when writing new regular expressions.</p>
<subtitle>Quantifiers</subtitle>
<p>A quantifier describes the way that a pattern absorbs input text:</p>
<p>•    Greedy: Quantifiers are greedy unless otherwise altered. A greedy expression finds as many possible matches for the pattern as possible. A typical cause of problems is to assume that your pattern will only match the first possible group of characters, when it’s actually greedy and will keep going until it’s matched the largest possible string.</p>
<p>•    Reluctant: Specified with a question mark, this quantifier matches the minimum number of characters necessary to satisfy the pattern. Also called lazy, minimal matching, non-greedy, or ungreedy.</p>
<p>•    Possessive: Currently this is only available in Java (not in other languages) and is more advanced, so you probably won’t use it right away. As a regular expression is applied to a string, it generates many states so that it can backtrack if the match fails. Possessive quantifiers do not keep those intermediate states, and thus prevent backtracking. They can be used to prevent a regular expression from running away and also to make it execute more efficiently.</p>
<table>
<tr><td>Greedy</td><td>Reluctant</td><td>Possessive</td><td>Matches</td></tr>
<tr><td>X?</td><td>X??</td><td>X?+</td><td>X, one or none</td></tr>
<tr><td>X*</td><td>X*?</td><td>x*+</td><td>X, zero or more</td></tr>
<tr><td>x+</td><td>x+?</td><td>X++</td><td>X, one or more</td></tr>
<tr><td>X{n}</td><td>X{n}?</td><td>X{n}+</td><td>X, exactly n times</td></tr>
<tr><td>X{n,}</td><td>X{n,}?</td><td>X{n,}+</td><td>X, at least n times</td></tr>
<tr><td>X{n,m}</td><td>X{n,m}?</td><td>X{n,m}+</td><td>X, at least n but not more than m times</td></tr>
</table>
<p>Keep in mind that the expression ‘X’ will often need to be surrounded in parentheses for it to work the way you desire. For example:</p>
<p>abc+</p>
<p>might seem like it would match the sequence ‘abc’ one or more times, and if you apply it to the input string ‘abcabcabc’, you will in fact get three matches. However, the expression actually says, &quot;Match ‘ab’ followed by one or more occurrences of ‘c’.&quot; To match the entire string ‘abc’ one or more times, you must say:</p>
<p>(abc)+</p>
<p>You can easily be fooled when using regular expressions; it’s an orthogonal language, on top of Java.</p>
<p>CharSequence</p>
<p>The interface called CharSequence establishes a generalized definition of a character sequence abstracted from the CharBuffer, String, StringBuffer, or StringBuilder</p>
<p>classes:</p>
<p>interface CharSequence { charAt(int i); length();</p>
<p>subSequence(int start,| int end); toString();</p>
<p>}</p>
<p>The aforementioned classes implement this interface. Many regular expression operations take CharSequence arguments.</p>
<subtitle>Pattern and Matcher</subtitle>
<p>In general, you’ll compile regular expression objects rather than using the fairly limited String utilities. To do this, you import java.util.regex, then compile a regular expression by using the static Pattern.compile( ) method. This produces a Pattern object based on its String argument. You use the Pattern by calling the matcher( ) method, passing the string that you want to search. The matcher( ) method produces a Matcher object, which has a set of operations to choose from (you can see all of these in the JDK documentation for java.util.regex.Matcher). For example, the replaceAll( ) method replaces all the matches with its argument.</p>
<p>As a first example, the following class can be used to test regular expressions against an input string. The first command-line argument is the input string to match against, followed by one or more regular expressions to be applied to the input. Under Unix/Linux, the regular expressions must be quoted on the command line. This program can be useful in testing regular expressions as you construct them to see that they produce your intended matching behavior.</p>
<p>//: strings/TestRegularExpression.java</p>
<p>// Allows you to easily try out regular expressions.</p>
<p>// {Args: abcabcabcdefabc &quot;abc+&quot; &quot;(abc)+&quot; &quot;(abc){2,}&quot; }</p>
<p>import java.util.regex.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class TestRegularExpression {</p>
<p>public static void main(String[] args) { if(args.length &lt; 2) {</p>
<p>print(&quot;Usage:\njava TestRegularExpression &quot; +</p>
<p>&quot;characterSequence regularExpression+&quot;);</p>
<p>System.exit(0);</p>
<p>}</p>
<p>print(&quot;Input: \&quot;&quot; + args[0] + &quot;\&quot;&quot;); for(String arg : args) {</p>
<p>print(&quot;Regular expression: \&quot;&quot; + arg + &quot;\&quot;&quot;);</p>
<p>Pattern p = Pattern.compile(arg);</p>
<p>Matcher m = p.matcher(args[0]); while(m.find()) {</p>
<p>print(&quot;Match \&quot;&quot; + m.group() + &quot;\&quot; at positions &quot; + m.start() + &quot;-&quot; + (m.end() - 1));</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Input: &quot;abcabcabcdefabc&quot;</p>
<p>Regular expression: &quot;abcabcabcdefabc&quot;</p>
<p>Match &quot;abcabcabcdefabc&quot; at positions 0-14 Regular expression: &quot;abc+&quot;</p>
<p>Regular expression: &quot;(abc)+&quot;</p>
<p>Match &quot;abcabcabc&quot; at positions 0-8 Match &quot;abc&quot; at positions 12-14 Regular expression: &quot;(abc){2,}&quot;</p>
<p>Match &quot;abcabcabc&quot; at positions 0-8 *///:~</p>
<p>A Pattern object represents the compiled version of a regular expression. As seen in the preceding example, you can use the matcher( ) method and the input string to produce a Matcher object from the compiled Pattern object. Pattern also has a static method:</p>
<p>static boolean matches(String regex, CharSequence input)</p>
<p>to check whether regex matches the entire input CharSequence, and a split( ) method that produces an array of String that has been broken around matches of the regex.</p>
<p>A Matcher object is generated by calling Pattern.matcher( ) with the input string as an argument. The Matcher object is then used to access the results, using methods to evaluate the success or failure of different types of matches:</p>
<p>boolean matches() boolean lookingAt() boolean find() boolean find(int start)</p>
<p>The matches ( ) method is successful if the pattern matches the entire input string, while lookingAt( ) is successful if the input string, starting at the beginning, is a match to the pattern.</p>
<p>Exercise 10: (2) For the phrase &quot;Java now has regular expressions&quot; evaluate whether the following expressions will find a match:</p>
<p>Java</p>
<p>\Breg.*</p>
<p>n.w\s+h(a|i)s</p>
<p>s?</p>
<p>s*</p>
<p>s+</p>
<p>s{4}</p>
<p>S{1}.</p>
<p>s{0,3}</p>
<p>Exercise 11: (2) Apply the regular expression</p>
<p>(?i)((<sup>A</sup>[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b</p>
<p>to</p>
<p>&quot;Arline ate eight apples and one orange while Anita hadn’t any&quot;</p>
<p>find()</p>
<p>Matcher.find( ) can be used to discover multiple pattern matches in the CharSequence to which it is applied. For example: //: strings/Finding.java</p>
<p>import java.util.regex.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Finding {</p>
<p>public static void main(String[] args) {</p>
<p>Matcher m = Pattern.compile(&quot;\\w+&quot;)</p>
<p>.matcher(&quot;Evening is full of the linnet’s wings&quot;); while(m.find())</p>
<p>printnb(m.group() + &quot; &quot;); print(); int i = 0; while(m.find(i)) {</p>
<p>printnb(m.group() + &quot; &quot;); i++;</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>is s full full ull ll l of of f net et t s s wings wings ings ngs</p>
<p>Evening is full of the linnet s wings Evening vening ening ning ing ng g is the the he e linnet linnet innet nnet gs s *///:~</p>
<p>The pattern ‘\\w+’ splits the input into words. find( ) is like an iterator, moving forward through the input string. However, the second version of find( ) can be given an integer argument that tells it the character position for the beginning of the search—this version resets the search position to the value of the argument, as you can see from the output.</p>
<p>Groups</p>
<p>Groups are regular expressions set off by parentheses that can be called up later with their group number. Group o indicates the whole expression match, group l is the first parenthesized group, etc. Thus in</p>
<p>A(B(C))D</p>
<p>there are three groups: Group 0 is ABCD, group 1 is BC, and group 2 is C.</p>
<p>The Matcher object has methods to give you information about groups:</p>
<p>public int groupCount( ) returns the number of groups in this matcher’s pattern. Group o is not included in this count.</p>
<p>public String group( ) returns group o (the entire match) from the previous match operation (find( ), for example).</p>
<p>public String group(int i) returns the given group number during the previous match operation. If the match was successful, but the group specified failed to match any part of the input string, then null is returned.</p>
<p>public int start(int group) returns the start index of the group found in the previous match operation.</p>
<p>public int end(int group) returns the index of the last character, plus one, of the group found in the previous match operation.</p>
<p>Here’s an example:</p>
<p>//: strings/Groups.java</p>
<p>import java.util.regex.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Groups {</p>
<p>static public final String POEM =</p>
<p>&quot;Twas brillig, and the slithy toves\n&quot; +</p>
<p>&quot;Did gyre and gimble in the wabe.\n&quot; +</p>
<p>&quot;All mimsy were the borogoves,\n&quot; +</p>
<p>&quot;And the mome raths outgrabe.\n\n&quot; +</p>
<p>&quot;Beware the Jabberwock, my son,\n&quot; +</p>
<p>&quot;The jaws that bite, the claws that catch.\n&quot; +</p>
<p>&quot;Beware the Jubjub bird, and shun\n&quot; +</p>
<p>&quot;The frumious Bandersnatch.&quot;; public static void main(String[] args) {</p>
<p>Matcher m =</p>
<p>Pattern.compile(&quot;(?m)(\\S+)\\s+((\\S+)\\s+(\\S+))$&quot;) .matcher(POEM); while(m.find()) {</p>
<p>for(int j = 0; j &lt;= m.groupCount(); j++) printnb(&quot;[&quot; + m.group(j) + &quot;]&quot;); print();</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>[the slithy toves][the][slithy toves][slithy][toves]</p>
<p>[in the wabe.][in][the wabe.][the][wabe.]</p>
<p>[were the borogoves,][were][the borogoves,][the][borogoves,]</p>
<p>[mome raths outgrabe.][mome][raths outgrabe.][raths][outgrabe.] [Jabberwock, my son,][Jabberwock,][my son,][my][son,]</p>
<p>[claws that catch.][claws][that catch.][that][catch.]</p>
<p>[bird, and shun][bird,][and shun][and][shun]</p>
<p>[The frumious Bandersnatch.][The][frumious Bandersnatch.][frumious][Bandersnatch.]</p>
<p>*///:~</p>
<p>The poem is the first part of Lewis Carroll’s &quot;Jabberwocky,&quot; from Through the Looking Glass. You can see that the regular expression pattern has a number of parenthesized groups, consisting of any number of non-whitespace characters (‘\S+’) followed by any number of whitespace characters (‘\s+’). The goal is to capture the last three words on each line; the end of a line is delimited by ‘$’. However, the normal behavior is to match ‘$’ with the end of the entire input sequence, so you must explicitly tell the regular expression to pay attention to newlines within the input. This is accomplished with the ‘(?m)’ pattern flag at the beginning of the sequence (pattern flags will be shown shortly).</p>
<p>Exercise 12: (5) Modify Groups.java to count all of the unique words that do not start with a capital letter.</p>
<p>start() and end()</p>
<p>Following a successful matching operation, start( ) returns the start index of the previous match, and end( ) returns the index of the last character matched, plus one. Invoking either start( ) or end( ) following an unsuccessful matching operation (or before attempting a matching operation) produces an IllegalStateException. The following program also demonstrates matches( ) and lookingAt( ):<a l:href="#bookmark57" type="note"><sup>58</sup></a><sup></sup></p>
<p>//: strings/StartEnd.java import java.util.regex.*; import static net.mindview.util.Print.*;</p>
<p>public class StartEnd {</p>
<p>public static String input =</p>
<p>&quot;As long as there is injustice, whenever a\n&quot; +</p>
<p>&quot;Targathian baby cries out, wherever a distress\n&quot; +</p>
<p>&quot;signal sounds among the stars ... We’ll be there.\n&quot; +</p>
<p>&quot;This fine ship, and this fine crew ...\n&quot; +</p>
<p>&quot;Never give up! Never surrender!&quot;; private static class Display {</p>
<p>private boolean regexPrinted = false; private String regex;</p>
<p>Display(String regex) { this.regex = regex; } void display(String message) { if(!regexPrinted) { print(regex); regexPrinted = true;</p>
<p>}</p>
<p>print(message);</p>
<p>}</p>
<p>}</p>
<p>static void examine(String s, String regex) {</p>
<p>Display d = new Display(regex);</p>
<p>Pattern p = Pattern.compile(regex);</p>
<p>Matcher m = p.matcher(s); while(m.find())</p>
<p>d.display(&quot;find() ‘&quot; + m.group() +</p>
<p>&quot;‘ start = &quot;+ m.start() + &quot; end = &quot; + m.end()); if(m.lookingAt()) // No reset() necessary d.display(&quot;lookingAt() start = &quot;</p>
<p>+ m.start() + &quot; end = &quot; + m.end()); if(m.matches()) // No reset() necessary d.display(&quot;matches() start = &quot;</p>
<p>+ m.start() + &quot; end = &quot; + m.end());</p>
<p>}</p>
<p>public static void main(String[] args) { for(String in : input.split(&quot;\n&quot;)) { print(&quot;input : &quot; + in);</p>
<p>for(String regex : new String[]{&quot;\\w*ere\\w*&quot;,</p>
<p>&quot;\\w*ever&quot;, &quot;T\\w+&quot;, &quot;Never.*?!&quot;}) examine(in, regex);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>input : As long as there is injustice, whenever a \w*ere\w*</p>
<p>find() ‘there’ start = 11 end = 16 \w*ever</p>
<p>find() ‘whenever’ start = 31 end = 39</p>
<p>input : Targathian baby cries out, wherever a distress</p>
<p>\w*ere\w*</p>
<table>
<tr><td>find() ‘wherever’ \w*ever</td><td>start</td><td>= 27</td><td>end</td><td>= 35</td></tr>
<tr><td>find() ‘wherever’</td><td>start</td><td>= 27</td><td>end</td><td>= 35</td></tr>
</table>
<p>T\w+</p>
<p>find() ‘Targathian’ start = 0 end = 10 lookingAt() start = 0 end = 10</p>
<p>input : signal sounds among the stars ... We’ll be there. \w*ere\w*</p>
<p>find() ‘there’ start = 43 end = 48</p>
<p>input : This fine ship, and this fine crew ...</p>
<p>T\w+</p>
<p>find() ‘This’ start = 0 end = 4</p>
<p>lookingAt() start = 0 end = 4</p>
<p>input : Never give up! Never surrender!</p>
<p>\w*ever</p>
<p>find() ‘Never’ start = 0 end = 5 find() ‘Never’ start = 15 end = 20 lookingAt() start = 0 end = 5 Never.*?!</p>
<p>find() ‘Never give up!’ start = 0 end = 14 find() ‘Never surrender!’ start = 15 end = 31 lookingAt() start = 0 end = 14 matches() start = 0 end = 31 *///:~</p>
<p>Notice that find( ) will locate the regular expression anywhere in the input, but lookingAt( ) and matches( ) only succeed if the regular expression starts matching at the very beginning of the input. While matches( ) only succeeds if the entire input matches the regular expression, lookingAt( )<sup>4</sup> succeeds if only the first part of the input matches.</p>
<p>Exercise 13: (2) Modify StartEnd.java so that it uses Groups.POEM as input, but still produces positive outputs for find( ), lookingAt( ) and matches( ).</p>
<p>Pattern flags</p>
<p>An alternative compile( ) method accepts flags that affect matching behavior:</p>
<p>Pattern Pattern.compile(String regex, int flag)</p>
<p>where flag is drawn from among the following Pattern class constants:</p>
<table>
<tr><td>Compile Flag</td><td>Effect</td></tr>
<tr><td>Pattern.CANON_EQ</td><td>Two characters will be considered to match if, and only if, their full canonical decompositions match. The expression ‘\u003F’, for example, will match the string ‘?’ when this flag is specified. By default, matching does not take canonical equivalence into account.</td></tr>
<tr><td>Pattern.CASE INSENSITIVE(?i)</td><td>By default, case-insensitive matching assumes that only characters in the US-ASCII character set are being matched. This flag allows your pattern to match without regard to case (upper or lower). Unicode-aware case-insensitive matching can be enabled by specifying the UNICODE_CASE flag in conjunction with this flag.</td></tr>
<tr><td>Pattern.COMMENTS(?x)</td><td>In this mode, whitespace is ignored, and embedded comments starting with # are ignored until the end of a line. Unix lines mode can also be enabled via the embedded flag expression.</td></tr>
<tr><td>Pattern.DOTALL(?s)</td><td>In dotall mode, the expression’.’ matches any character, including a line terminator. By default, the ‘.’ expression does not match line terminators.</td></tr>
<tr><td>Pattern.MULTILINE(?m)</td><td>In multiline mode, the expressions ‘<sup>A</sup>’ and ‘$’ match the beginning and ending of a line, respectively.^’ also matches the beginning of the input string, and ‘$’ also matches the end of the input string. By default, these expressions only match at the beginning and the end of the entire input string.</td></tr>
<tr><td>Pattern.UNICODE CASE(?u)</td><td>Case-insensitive matching, when enabled by the CASE_INSENSITIVE flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII character set are being matched.</td></tr>
<tr><td>Pattern.UNIX LINES (?d)</td><td>In this mode, only the ‘\n’ line terminator is recognized in the behavior of ‘.’, ‘<sup>A</sup>’, and ‘$’.</td></tr>
</table>
<p>Particularly useful among these flags are Pattern.CASE_INSENSITIVE, Pattern.MULTILINE, and Pattern.COMMENTS (which is helpful for clarity and/or documentation). Note that the behavior of most of the flags can also be obtained by inserting the parenthesized characters, shown beneath the flags in the table, into your regular expression preceding the place where you want the mode to take effect.</p>
<p>You can combine the effect of these and other flags through an &quot;OR&quot; (‘|’) operation:</p>
<p>//: strings/ReFlags.java import java.util.regex.*;</p>
<p>public class ReFlags {</p>
<p>public static void main(String[] args) {</p>
<p>Pattern p = Pattern.compile(&quot;<sup>A</sup>java&quot;,</p>
<p>Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);</p>
<p>Matcher m = p.matcher(</p>
<p>&quot;java has regex\nJava has regex\n&quot; +</p>
<p>&quot;JAVA has pretty good regular expressions\n&quot; +</p>
<p>&quot;Regular expressions are in Java&quot;); while(m.find())</p>
<p>System.out.println(m.group());</p>
<p>}</p>
<p>} /* Output: java Java JAVA *///:~</p>
<p>This creates a pattern that will match lines starting with &quot;Java,&quot; &quot;Java,&quot; &quot;JAVA,&quot; etc., and attempt a match for each line within a multiline set (matches starting at the beginning of the character sequence and following each line terminator within the character sequence). Note that the group( ) method only produces the matched portion.</p>
<subtitle>split()</subtitle>
<p>split( ) divides an input string into an array of String objects, delimited by the regular expression.</p>
<p>String[] split(CharSequence input)</p>
<p>String[] split(CharSequence input, int limit)</p>
<p>This is a handy way to break input text on a common boundary:</p>
<p>//: strings/SplitDemo.java import java.util.regex.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class SplitDemo {</p>
<p>public static void main(String[] args) {</p>
<p>String input =</p>
<p>&quot;This!!unusual use!!of exclamation!!points&quot;; print(Arrays.toString(</p>
<p>Pattern.compile(&quot;!!&quot;).split(input)));</p>
<p>// Only do the first three: print(Arrays.toString(</p>
<p>Pattern.compile(&quot;!!&quot;).split(input, 3)));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[This, unusual use, of exclamation, points]</p>
<p>[This, unusual use, of exclamation!!points]</p>
<p>*///:~</p>
<p>The second form of split( ) limits the number of splits that occur.</p>
<p>Exercise 14: (1) Rewrite SplitDemo using String.split( ).</p>
<subtitle>Replace operations</subtitle>
<p>Regular expressions are especially useful to replace text. Here are the available methods:</p>
<p>replaceFirst(String replacement) replaces the first matching part of the input string with replacement.</p>
<p>replaceAll(String replacement) replaces every matching part of the input string with replacement.</p>
<p>appendReplacement(StringBuffer sbuf, String replacement) performs step-by-step replacements into sbuf, rather than replacing only the first one or all of them, as in replaceFirst( ) and replaceAll( ), respectively. This is a very important method, because it allows you to call methods and perform other processing in order to produce replacement (replaceFirst( ) and replaceAll( ) are only able to put in fixed strings). With this method, you can programmatically pick apart the groups and create powerful replacements.</p>
<p>appendTail(StringBuffer sbuf, String replacement) is invoked after one or more invocations of the appendReplacement( ) method in order to copy the remainder of the input string.</p>
<p>Here’s an example that shows the use of all the replace operations. The block of commented text at the beginning is extracted and processed with regular expressions for use as input in the rest of the example:</p>
<p>//: strings/TheReplacements.java import java.util.regex.*; import net.mindview.util.*; import static net.mindview.util.Print.*;</p>
<p>/*! Here’s a block of text to use as input to</p>
<p>the regular expression matcher. Note that we’ll first extract the block of text by looking for the special delimiters, then process the extracted block. !*/</p>
<p>public class TheReplacements {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>String s = TextFile.read(&quot;TheReplacements.java&quot;);</p>
<p>// Match the specially commented block of text above:</p>
<p>Matcher mInput =</p>
<p>Pattern.compile(&quot;/\\*!(.*)!\\*/&quot;, Pattern.DOTALL)</p>
<p>.matcher(s);</p>
<p>if(mInput.find())</p>
<p>s = mlnput.group(l); // Captured by parentheses // Replace two or more spaces with a single space: s = s.replaceAll(&quot; {2,}&quot;, &quot; &quot;);</p>
<p>// Replace one or more spaces at the beginning of each // line with no spaces. Must enable MULTILINE mode: s = s.replaceAll(&quot;(?m)<sup>A</sup> +&quot;, &quot;&quot;); print(s);</p>
<p>s = s.replaceFirst(&quot;[aeiou]&quot;, &quot;(VOWEL1)&quot;);</p>
<p>StringBuffer sbuf = new StringBuffer();</p>
<p>Pattern p = Pattern.compile(&quot;[aeiou]&quot;);</p>
<p>Matcher m = p.matcher(s);</p>
<p>// Process the find information as you</p>
<p>// perform the replacements: while(m.find())</p>
<p>m.appendReplacement(sbuf, m.group().toUpperCase()); // Put in the remainder of the text: m.appendTail(sbuf); print(sbuf);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Here’s a block of text to use as input to the regular expression matcher. Note that we’ll first extract the block of text by looking for the special delimiters, then process the extracted block.</p>
<p>H(VOWEL1)rE’s A blOck Of tExt tO UsE As InpUt tO thE rEgUlAr ExprEsslOn mAtchEr. NOtE thAt wE’ll fIrst ExtrAct thE blOck Of tExt by lOOkIng fOr thE spEcIAl dElImItErs, thEn prOcEss thE ExtrActEd blOck.</p>
<p>*///:~</p>
<p>The file is opened and read using the TextFile class in the net.mindview.util library (the code for this will be shown in the I/O chapter). The static read( ) method reads the entire file and returns it as a String. mInput is created to match all the text (notice the grouping parentheses) between ‘/*!’ and ‘!*/’. Then, more than two spaces are reduced to a single space, and any space at the beginning of each line is removed (in order to do this on all lines and not just the beginning of the input, multiline mode must be enabled). These two replacements are performed with the equivalent (but more convenient, in this case) replaceAll( ) that’s part of String. Note that since each replacement is only used once in the program, there’s no extra cost to doing it this way rather than precompiling it as a Pattern.</p>
<p>replaceFirst( ) only performs the first replacement that it finds. In addition, the replacement strings in replaceFirst( ) and replaceAll( ) are just literals, so if you want to perform some processing on each replacement, they don’t help. In that case, you need to use appendReplacement( ), which allows you to write any amount of code in the process of performing the replacement. In the preceding example, a group( ) is selected and processed—in this situation, setting the vowel found by the regular expression to uppercase— as the resulting sbuf is being built. Normally, you step through and perform all the replacements and then call appendTail( ), but if you want to simulate replaceFirst( ) (or &quot;replace n&quot;), you just do the replacement one time and then call appendTail( ) to put the rest into sbuf.</p>
<p>appendReplacement( ) also allows you to refer to captured groups directly in the replacement string by saying &quot;$g&quot;, where ‘g’ is the group number. However, this is for simpler processing and wouldn’t give you the desired results in the preceding program.</p>
<subtitle>reset()</subtitle>
<p>An existing Matcher object can be applied to a new character sequence using the reset( ) methods:</p>
<p>//: strings/Resetting.java import java.util.regex.*;</p>
<p>public class Resetting {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>Matcher m = Pattern.compile(&quot;[frb][aiu][gx]&quot;)</p>
<p>.matcher(&quot;fix the rug with bags&quot;); while(m.find())</p>
<p>System.out.print(m.group() + &quot; System.out.println(); m.reset(&quot;fix the rig with rags&quot;); while(m.find())</p>
<p>);</p>
<p>System.out.print(m.group() + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output: fix rug bag fix rig rag *///:~ reset( ) without any arguments sets the Matcher to the beginning of the current sequence.</p>
<subtitle>Regular expressions and Java I/O</subtitle>
<p>Most of the examples so far have shown regular expressions applied to static strings. The following example shows one way to apply regular expressions to search for matches in a file. Inspired by Unix’s grep, JGrep.java takes two arguments: a file name and the regular expression that you want to match. The output shows each line where a match occurs and the match position(s) within the line.</p>
<p>//: strings/JGrep.java</p>
<p>// A very simple version of the &quot;grep&quot; program.</p>
<p>// {Args: JGrep.java &quot;\\b[Ssct]\\w+&quot;} import java.util.regex.*; import net.mindview.util.*;</p>
<p>public class JGrep {</p>
<p>public static void main(String[] args) throws Exception { if(args.length &lt; 2) {</p>
<p>System.out.println(&quot;Usage: java JGrep file regex&quot;);</p>
<p>System.exit(0);</p>
<p>}</p>
<p>Pattern p = Pattern.compile(args[1]);</p>
<p>// Iterate through the lines of the input file: int index = 0;</p>
<p>Matcher m = p.matcher(&quot;&quot;); for(String line : new TextFile(args[0])) { m.reset(line); while(m.find())</p>
<p>System.out.println(index++ + &quot;: &quot; + m.group() + &quot;: &quot; + m.start());</p>
<p>}</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>0: strings: 4 1: simple: 10 2: the: 28 3: Ssct: 26 4: class: 7 5: static: 9 6: String: 26 7: throws: 41 8: System: 6 9: System: 6 10: compile: 24 11: through: 15 12: the: 23 13: the: 36 14: String: 8 15: System: 8</p>
<p>16: start: 31 *///:~</p>
<p>The file is opened as a net.mindview.util.TextFile object (which will be shown in the I/O chapter), which reads the lines of the file into an ArrayList. This means that the foreach syntax can iterate through the lines in the TextFile object.</p>
<p>Although it’s possible to create a new Matcher object within the for loop, it is slightly more optimal to create an empty Matcher object outside the loop and use the reset( ) method to assign each line of the input to the Matcher. The result is scanned with find( ).</p>
<p>The test arguments open the JGrep.java file to read as input, and search for words starting with [Ssct].</p>
<p>You can learn much more about regular expressions in Mastering Regular Expressions, 2nd Edition, by Jeffrey E. F. Friedl (O’Reilly, 2002). There are also numerous introductions to regular expressions on the Internet, and you can often find helpful information in the documentation for languages like Perl and Python.</p>
<p>Exercise 15: (5) Modify JGrep.java to accept flags as arguments (e.g., Pattern.CASE_INSENSITIVE, Pattern.MULTILINE).</p>
<p>Exercise 16: (5) Modify JGrep.java to accept a directory name or a file name as argument (if a directory is provided, search should include all files in the directory). Hint: You can generate a list of file names with:</p>
<p>File[] files = new File(&quot;.&quot;).listFilesQ;</p>
<p>Exercise 17: (8) Write a program that reads a Java source-code file (you provide the file name on the command line) and displays all the comments.</p>
<p>Exercise 18: (8) Write a program that reads a Java source-code file (you provide the file name on the command line) and displays all the string literals in the code.</p>
<p>Exercise 19: (8) Building on the previous two exercises, write a program that examines Java source code and produces all the class names used in a particular program.</p>
</section>
<section>
<title>
<p>Scanning input</p></title><empty-line/>
<p>Until now it has been relatively painful to read data from a human-readable file or from standard input. The usual solution is to read in a line of text, tokenize it, and then use the various parse methods of Integer, Double, etc., to parse the data:</p>
<p>//: strings/SimpleRead.java import java.io.*;</p>
<p>public class SimpleRead {</p>
<p>public static BufferedReader input = new BufferedReader( new StringReader(&quot;Sir Robin of Camelot\n22 1.61803&quot;)); public static void main(String[] args) { try {</p>
<p>System.out.println(&quot;What is your name?&quot;);</p>
<p>String name = input.readLine();</p>
<p>System.out.println(name);</p>
<p>System.out.println(</p>
<p>&quot;How old are you? What is your favorite double?&quot;);</p>
<p>System.out.println(&quot;(input: &lt;age&gt; &lt;double&gt;)&quot;); String numbers = input.readLine(); System.out.println(numbers);</p>
<p>String[] numArray = numbers.split(&quot; &quot;); int age = Integer.parseInt(numArray[0]); double favorite = Double.parseDouble(numArray[1]); System.out.format(&quot;Hi %s.\n&quot;, name); System.out.format(&quot;In 5 years you will be %d.\n&quot;, age + 5);</p>
<p>System.out.format(&quot;My favorite double is %f.&quot;, favorite / 2);</p>
<p>} catch(IOException e) {</p>
<p>System.err.println(&quot;I/O exception&quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>What is your name?</p>
<p>Sir Robin of Camelot</p>
<p>How old are you? What is your favorite double?</p>
<p>(input: &lt;age&gt; &lt;double&gt;)</p>
<p>22 1.61803</p>
<p>Hi Sir Robin of Camelot.</p>
<p>In 5 years you will be 27.</p>
<p>My favorite double is 0.809015.</p>
<p>*///:~</p>
<p>The input field uses classes from java.io, which will not officially be introduced until the I/O chapter. A StringReader turns a String into a readable stream, and this object is used to create a BufferedReader because BufferedReader has a readLine( ) method. The result is that the input object can be read a line at a time, just as if it were standard input from the console.</p>
<p>readLine( ) is used to get the String for each line of input. It’s fairly straightforward when you want to get one input for each line of data, but if two input values are on a single line, things get messy—the line must be split so we can parse each input separately. Here, the splitting takes place when creating numArray, but note that the split( ) method was introduced in J2SE1.4, so before that you had to do something else.</p>
<p>The Scanner class, added in Java SE5, relieves much of the burden of scanning input:</p>
<p>//: strings/BetterRead.java import java.util.*;</p>
<p>public class BetterRead {</p>
<p>public static void main(String[] args) {</p>
<p>Scanner stdin = new Scanner(SimpleRead.input); System.out.println(&quot;What is your name?&quot;);</p>
<p>String name = stdin.nextLine();</p>
<p>System.out.println(name);</p>
<p>System.out.println(</p>
<p>&quot;How old are you? What is your favorite double?&quot;); System.out.println(&quot;(input: &lt;age&gt; &lt;double&gt;)&quot;); int age = stdin.nextInt(); double favorite = stdin.nextDouble();</p>
<p>System.out.println(age);</p>
<p>System.out.println(favorite);</p>
<p>System.out.format(&quot;Hi %s.\n&quot;, name);</p>
<p>System.out.format(&quot;In 5 years you will be %d.\n&quot;, age + 5);</p>
<p>System.out.format(&quot;My favorite double is %f.&quot;, favorite / 2);</p>
<p>} /* Output:</p>
<p>What is your name?</p>
<p>Sir Robin of Camelot</p>
<p>How old are you? What is your favorite double? (input: &lt;age&gt; &lt;double&gt;)</p>
<p>22</p>
<p>1.61803</p>
<p>Hi Sir Robin of Camelot.</p>
<p>In 5 years you will be 27.</p>
<p>My favorite double is 0.809015.</p>
<p>*///:~</p>
<p>The Scanner constructor can take just about any kind of input object, including a File object (which will also be covered in the I/O chapter), an InputStream, a String, or in this case a Readable, which is an interface introduced in Java SE5 to describe &quot;something that has a read( ) method.&quot; The BufferedReader from the previous example falls into this category.</p>
<p>With Scanner, the input, tokenizing, and parsing are all ensconced in various different kinds of &quot;next&quot; methods. A plain next( ) returns the next String token, and there are &quot;next&quot; methods for all the primitive types (except char) as well as for BigDecimal and Biglnteger. All of the &quot;next&quot; methods block, meaning they will return only after a complete data token is available for input. There are also corresponding &quot;hasNext&quot; methods that return true if the next input token is of the correct type.</p>
<p>An interesting difference between the two previous examples above is the lack of a try block for IOExceptions in BetterRead.java. One of the assumptions made by the Scanner is that an IOException signals the end of input, and so these are swallowed by the Scanner. However, the most recent exception is available through the ioException( ) method, so you are able to examine it if necessary.</p>
<p>Exercise 20: (2) Create a class that contains int, long, float and double and String fields. Create a constructor for this class that takes a single String argument, and scans that string into the various fields. Add a toString( ) method and demonstrate that your class works correctly.</p>
<subtitle>Scanner delimiters</subtitle>
<p>By default, a Scanner splits input tokens along whitespace, but you can also specify your own delimiter pattern in the form of a regular expression:</p>
<p>//: strings/ScannerDelimiter.java import java.util.*;</p>
<p>public class ScannerDelimiter {</p>
<p>public static void main(String[] args) {</p>
<p>Scanner scanner = new Scanner(&quot;12, 42, 78, 99, 42&quot;);</p>
<p>scanner.useDelimiter(&quot;\\s*,\\s*&quot;);</p>
<p>while(scanner.hasNextInt())</p>
<p>System.out.println(scanner.nextInt());</p>
<p>}</p>
<p>} /* Output:</p>
<p>12</p>
<p>42</p>
<p>78</p>
<p>99</p>
<p>42</p>
<p>*///:~</p>
<p>This example uses commas (surrounded by arbitrary amounts of whitespace) as the delimiter when reading from the given String. This same technique can be used to read from comma-delimited files. In addition to useDelimiter( ) for setting the delimiter pattern, there is also delimiter( ), which returns the current Pattern being used as a delimiter.</p>
<subtitle>Scanning with regular expressions</subtitle>
<p>In addition to scanning for predefined primitive types, you can also scan for your own user-defined patterns, which is helpful when scanning more complex data. This example scans threat data from a log like your firewall might produce:</p>
<p>//: strings/ThreatAnalyzer.java import java.util.regex.*; import java.util.*;</p>
<p>public class ThreatAnalyzer { static String threatData =</p>
<p>&quot;58.27.82.161@02/10/2005\n&quot; +</p>
<p>&quot;204.45.234.40@02/11/2005\n&quot; +</p>
<p>&quot;58.27.82.161@02/11/2005\n&quot; +</p>
<p>&quot;58.27.82.161@02/12/2005\n&quot; +</p>
<p>&quot;58.27.82.161@02/12/2005\n&quot; +</p>
<p>&quot;[Next log section with different data format]&quot;; public static void main(String[] args) {</p>
<p>Scanner scanner = new Scanner(threatData);</p>
<p>String pattern = &quot;(\\d+[.]\\d+[.]\\d+[.]\\d+)@&quot; + &quot;(\\d{2}/\\d{2}/\\d{4})&quot;; while(scanner.hasNext(pattern)) { scanner.next(pattern);</p>
<p>MatchResult match = scanner.match();</p>
<p>String ip = match.group(1);</p>
<p>String date = match.group(2);</p>
<p>System.out.format(&quot;Threat on %s from %s\n&quot;, date,ip);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Threat on 02/10/2005 from 58.27.82.161 Threat on 02/11/2005 from 204.45.234.40 Threat on 02/11/2005 from 58.27.82.161 Threat on 02/12/2005 from 58.27.82.161 Threat on 02/12/2005 from 58.27.82.161 *///:~</p>
<p>When you use next( ) with a specific pattern, that pattern is matched against the next input token. The result is made available by the match( ) method, and as you can see above, it works just like the regular expression matching you saw earlier.</p>
<p>There’s one caveat when scanning with regular expressions. The pattern is matched against the next input token only, so if your pattern contains a delimiter it will never be matched.</p>
</section>
<section>
<title>
<p>StringTokenizer</p></title><empty-line/>
<p>Before regular expressions (in J2SE1.4) or the Scanner class (in Java SE5), the way to split a string into parts was to &quot;tokenize&quot; it with StringTokenizer. But now it’s much easier and more succinct to do the same thing with regular expressions or the Scanner class. Here’s a simple comparison of StringTokenizer to the other two techniques:</p>
<p>//: strings/ReplacingStringTokenizer.java import java.util.*;</p>
<p>public class ReplacingStringTokenizer { public static void main(String[] args) {</p>
<p>String input = &quot;But I’m not dead yet! I feel happy!&quot;; StringTokenizer stoke = new StringTokenizer(input); while(stoke.hasMoreElements())</p>
<p>System.out.print(stoke.nextToken() + &quot; &quot;); System.out.println();</p>
<p>System.out.println(Arrays.toString(input.split(&quot; &quot;))); Scanner scanner = new Scanner(input); while(scanner.hasNext())</p>
<p>System.out.print(scanner.next() + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>But I’m not dead yet! I feel happy!</p>
<p>[But, I’m, not, dead, yet!, I, feel, happy!]</p>
<p>But I’m not dead yet! I feel happy!</p>
<p>*///:~</p>
<p>With regular expressions or Scanner objects, you can also split a string into parts using more complex patterns—something that’s difficult with StringTokenizer. It seems safe to say that the StringTokenizer is obsolete.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>In the past, Java support for string manipulation was rudimentary, but in recent editions of the language we’ve seen far more sophisticated support adopted from other languages. At this point, the support for strings is reasonably complete, although you must sometimes pay attention to efficiency details such as the appropriate use of StringBuilder.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Type Information</p></title><empty-line/>
<p>Runtime type information (RTTI) allows you to discover and use type information while a program is running.</p>
<p>It frees you from the constraint of doing type-oriented things only at compile time, and can enable some very powerful programs. The need for RTTI uncovers a plethora of interesting (and often perplexing) o o design issues, and raises fundamental questions about how you should structure your programs. This chapter looks at the ways that Java allows you to discover information about objects and classes at run time. This takes two forms: &quot;traditional&quot; RTTI, which assumes that you have all the types available at compile time, and the reflection mechanism, which allows you to discover and use class information solely at run time.</p>
<section>
<title>
<p>The need for RTTI</p></title><empty-line/>
<p>Consider the now-familiar example of a class hierarchy that uses polymorphism. The generic type is the base class Shape, and the specific derived types are Circle, Square, and Triangle:</p><image l:href="#image22.jpg"/>
<p>This is a typical class hierarchy diagram, with the base class at the top and the derived classes growing downward. The normal goal in object-oriented programming is for your code to manipulate references to the base type (Shape, in this case), so if you decide to extend the program by adding a new class (such as Rhomboid, derived from Shape), the bulk of the code is not affected. In this example, the dynamically bound method in the Shape interface is draw( ), so the intent is for the client programmer to call draw( ) through a generic Shape reference. In all of the derived classes, draw( ) is overridden, and because it is a dynamically bound method, the proper behavior will occur even though it is called through a generic Shape reference. That’s polymorphism.</p>
<p>Thus, you generally create a specific object (Circle, Square, or Triangle), upcast it to a Shape (forgetting the specific type of the object), and use that anonymous Shape reference in the rest of the program.</p>
<p>You might code the Shape hierarchy as follows:</p>
<p>//: typeinfo/Shapes.java import java.util.*;</p>
<p>abstract class Shape {</p>
<p>void draw() { System.out.println(this + &quot;.drawQ&quot;); } abstract public String toString();</p>
<p>class Circle extends Shape {</p>
<p>public String toString() { return &quot;Circle&quot;; }</p>
<p>} class Square extends Shape {</p>
<p>public String toString() { return &quot;Square&quot;; }</p>
<p>} class Triangle extends Shape {</p>
<p>public String toString() { return &quot;Triangle&quot;; }</p>
<p>}</p>
<p>public class Shapes {</p>
<p>public static void main(String[] args) { List&lt;Shape&gt; shapeList = Arrays.asList(</p>
<p>new Circle(), new Square(), new Triangle()</p>
<p>);</p>
<p>for(Shape shape : shapeList) shape.draw();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Circle.draw()</p>
<p>Square.draw()</p>
<p>Triangle.draw()</p>
<p>*///:~</p>
<p>The base class contains a draw( ) method that indirectly uses toString( ) to print an identifier for the class by passing this to System.out.println( ) (notice that toString( ) is declared abstract to force inheritors to override it, and to prevent the instantiation of a plain Shape). If an object appears in a string concatenation expression (involving ‘+’ and String objects), the toString( ) method is automatically called to produce a String representation for that object. Each of the derived classes overrides the toString( ) method (from Object) so that draw( ) ends up (polymorphically) printing something different in each case.</p>
<p>In this example, the upcast occurs when the shape is placed into the List&lt;Shape&gt;. During the upcast to Shape, the fact that the objects are specific types of Shape is lost. To the array, they are just Shapes.</p>
<p>At the point that you fetch an element out of the array, the container—which is actually holding everything as an Object—automatically casts the result back to a Shape. This is the most basic form of RTTI, because all casts are checked at run time for correctness. That’s what RTTI means: At run time, the type of an object is identified.</p>
<p>In this case, the RTTI cast is only partial: The Object is cast to a Shape, and not all the way to a Circle, Square, or Triangle. That’s because the only thing you know at this point is that the List&lt;Shape&gt; is full of Shapes. At compile time, this is enforced by the container and the Java generic system, but at run time the cast ensures it.</p>
<p>Now polymorphism takes over and the exact code that’s executed for the Shape is determined by whether the reference is for a Circle, Square, or Triangle. And in general, this is how it should be; you want the bulk of your code to know as little as possible about specific types of objects, and to just deal with the general representation of a family of objects (in this case, Shape). As a result, your code will be easier to write, read, and maintain, and your designs will be easier to implement, understand, and change. So polymorphism is a general goal in object-oriented programming.</p>
<p>But what if you have a special programming problem that’s easiest to solve if you know the exact type of a generic reference? For example, suppose you want to allow your users to highlight all the shapes of any particular type by turning them a special color. This way, they can find all the triangles on the screen by highlighting them. Or perhaps your method needs to &quot;rotate&quot; a list of shapes, but it makes no sense to rotate a circle so you’d like to skip the circles. With RTTI, you can ask a Shape reference the exact type that it’s referring to, and thus select and isolate special cases.</p>
</section>
<section>
<title>
<p>The Class object</p></title><empty-line/>
<p>To understand how RTTI works in Java, you must first know how type information is represented at run time. This is accomplished through a special kind of object called the Class object, which contains information about the class. In fact, the Class object is used to create all of the &quot;regular&quot; objects of your class. Java performs its RTTI using the Class object, even if you’re doing something like a cast. The class Class also has a number of other ways you can use RTTI.</p>
<p>There’s one Class object for each class that is part of your program. That is, each time you write and compile a new class, a single Class object is also created (and stored, appropriately enough, in an identically named .class file). To make an object of that class, the Java Virtual Machine (JVM) that’s executing your program uses a subsystem called a class loader.</p>
<p>The class loader subsystem can actually comprise a chain of class loaders, but there’s only one primordial class loader, which is part of the JVM implementation. The primordial class loader loads so-called trusted classes, including Java API classes, typically from the local disk. It’s usually not necessary to have additional class loaders in the chain, but if you have special needs (such as loading classes in a special way to support Web server applications, or downloading classes across a network), then you have a way to hook in additional class loaders.</p>
<p>All classes are loaded into the JVM dynamically, upon the first use of a class. This happens when the program makes the first reference to a static member of that class. It turns out that the constructor is also a static method of a class, even though the static keyword is not used for a constructor. Therefore, creating a new object of that class using the new operator also counts as a reference to a static member of the class.</p>
<p>Thus, a Java program isn’t completely loaded before it begins, but instead pieces of it are loaded when necessary. This is different from many traditional languages. Dynamic loading enables behavior that is difficult or impossible to duplicate in a statically loaded language like C++.</p>
<p>The class loader first checks to see if the Class object for that type is loaded. If not, the default class loader finds the .class file with that name (an add-on class loader might, for example, look for the bytecodes in a database instead). As the bytes for the class are loaded, they are verified to ensure that they have not been corrupted and that they do not comprise bad Java code (this is one of the lines of defense for security in Java).</p>
<p>Once the Class object for that type is in memory, it is used to create all objects of that type. Here’s a program to prove it:</p>
<p>//: typeinfo/SweetShop.java</p>
<p>// Examination of the way the class loader works. import static net.mindview.util.Print.*;</p>
<p>class Candy {</p>
<p>static { print(&quot;Loading Candy&quot;); }</p>
<p>} class Gum {</p>
<p>static { print(&quot;Loading Gum&quot;); }</p>
<p>}</p>
<p>class Cookie {</p>
<p>static { print(&quot;Loading Cookie&quot;); }</p>
<p>}</p>
<p>public class Sweetshop {</p>
<p>public static void main(String[] args) { print(&quot;inside main&quot;); new Candy();</p>
<p>print(&quot;After creating Candy&quot;); try {</p>
<p>Class.forName(&quot;Gum&quot;);</p>
<p>} catch(ClassNotFoundException e) { print(&quot;Couldn’t find Gum&quot;);</p>
<p>}</p>
<p>print(&quot;After Class.forName(\&quot;Gum\&quot;)&quot;); new Cookie();</p>
<p>print(&quot;After creating Cookie&quot;);</p>
<p>}</p>
<p>} /* Output: inside main Loading Candy After creating Candy Loading Gum</p>
<p>After Class.forName(&quot;Gum&quot;)</p>
<p>Loading Cookie After creating Cookie *///:~</p>
<p>Each of the classes Candy, Gum, and Cookie has a static clause that is executed as the class is loaded for the first time. Information will be printed to tell you when loading occurs for that class. In main( ), the object creations are spread out between print statements to help detect the time of loading.</p>
<p>You can see from the output that each Class object is loaded only when it’s needed, and the static initialization is performed upon class loading.</p>
<p>A particularly interesting line is:</p>
<p>Class.forName(&quot;Gum&quot;);</p>
<p>All Class objects belong to the class Class. A Class object is like any other object, so you can get and manipulate a reference to it (that’s what the loader does). One of the ways to get a reference to the Class object is the static forName( ) method, which takes a String containing the textual name (watch the spelling and capitalization!) of the particular class you want a reference for. It returns a Class reference, which is being ignored here; the call to forName( ) is being made for its side effect, which is to load the class Gum if it isn’t already loaded. In the process of loading, Gum’s static clause is executed.</p>
<p>In the preceding example, if Class.forName( ) fails because it can’t find the class you’re trying to load, it will throw a ClassNotFoundException. Here, we simply report the problem and move on, but in more sophisticated programs, you might try to fix the problem inside the exception handler.</p>
<p>Anytime you want to use type information at run time, you must first get a reference to the appropriate Class object. Class.forName( ) is one convenient way to do this, because you don’t need an object of that type in order to get the Class reference. However, if you already have an object of the type you’re interested in, you can fetch the Class reference by calling a method that’s part of the Object root class: getClass( ). This returns the Class reference representing the actual type of the object. Class has many interesting methods; here are a few of them:</p>
<p>//: typeinfo/toys/ToyTest.java // Testing class Class. package typeinfo.toys;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>interface HasBatteries {} interface Waterproof {} interface Shoots {}</p>
<p>class Toy {</p>
<p>// Comment out the following default constructor // to see NoSuchMethodError from (*1*)</p>
<p>Toy() {}</p>
<p>Toy(int i) {}</p>
<p>}</p>
<p>class FancyToy extends Toy</p>
<p>implements HasBatteries, Waterproof, Shoots {</p>
<p>FancyToy() { super(1); }</p>
<p>}</p>
<p>public class ToyTest {</p>
<p>static void printInfo(Class cc) {</p>
<p>print(&quot;Class name: &quot; + cc.getName() +</p>
<p>&quot; is interface? [&quot; + cc.isInterface() + &quot;]&quot;); print(&quot;Simple name: &quot; + cc.getSimpleName()); print(&quot;Canonical name : &quot; + cc.getCanonicalName());</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Class c = null; try {</p>
<p>c = Class.forName(&quot;typeinfo.toys.FancyToy&quot;);</p>
<p>} catch(ClassNotFoundException e) { print(&quot;Can’t find FancyToy&quot;);</p>
<p>System.exit(l);</p>
<p>}</p>
<p>printlnfo(c);</p>
<p>for(Class face : c.getInterfaces()) printlnfo(face);</p>
<p>Class up = c.getSuperclass();</p>
<p>Object obj = null; try {</p>
<p>// Requires default constructor: obj = up.newInstance();</p>
<p>} catch(InstantiationException e) { print(&quot;Cannot instantiate&quot;);</p>
<p>System.exit(l);</p>
<p>} catch(IllegalAccessException e) { print(&quot;Cannot access&quot;);</p>
<p>System.exit(l);</p>
<p>}</p>
<p>printInfo(obj.getClass());</p>
<p>}</p>
<p>} /* Output:</p>
<p>Class name: typeinfo.toys.FancyToy is interface? [false] Simple name: FancyToy</p>
<p>Canonical name : typeinfo.toys.FancyToy</p>
<p>Class name: typeinfo.toys.HasBatteries is interface? [true] Simple name: HasBatteries</p>
<p>Canonical name : typeinfo.toys.HasBatteries</p>
<p>Class name: typeinfo.toys.Waterproof is interface? [true]</p>
<p>Simple name: Waterproof</p>
<p>Canonical name : typeinfo.toys.Waterproof</p>
<p>Class name: typeinfo.toys.Shoots is interface? [true]</p>
<p>Simple name: Shoots</p>
<p>Canonical name : typeinfo.toys.Shoots</p>
<p>Class name: typeinfo.toys.Toy is interface? [false]</p>
<p>Simple name: Toy</p>
<p>Canonical name : typeinfo.toys.Toy *///:~</p>
<p>FancyToy inherits from Toy and implements the interfaces HasBatteries, Waterproof, and Shoots. In main( ), a Class reference is created and initialized to the FancyToy Class using forName( ) inside an appropriate try block. Notice that you must use the fully qualified name (including the package name) in the string that you pass to forName( ).</p>
<p>printInfo( ) uses getName( ) to produce the fully qualified class name, and getSimpleName( ) and getCanonicalName( ) (introduced in Java SE5) to produce the name without the package, and the fully qualified name, respectively. As its name implies, islnterface( ) tells you whether this Class object represents an interface. Thus, with the Class object you can find out just about everything you want to know about a type.</p>
<p>The Class.getlnterfaces( ) method called in main( ) returns an array of Class objects representing the interfaces that are contained in the Class object of interest.</p>
<p>If you have a Class object, you can also ask it for its direct base class using getSuperclass( ). This returns a Class reference that you can further query. Thus you can discover an object’s entire class hierarchy at run time.</p>
<p>The newlnstance( ) method of Class is a way to implement a &quot;virtual constructor,&quot; which allows you to say, &quot;I don’t know exactly what type you are, but create yourself properly anyway.&quot; In the preceding example, up is just a Class reference with no further type information known at compile time. And when you create a new instance, you get back an Object reference. But that reference is pointing to a Toy object. Of course, before you can send any messages other than those accepted by Object, you must investigate it a bit and do some casting. In addition, the class that’s being created with newlnstance( ) must have a default constructor. Later in this chapter, you’ll see how to dynamically create objects of classes using any constructor, with the Java reflection API.</p>
<p>Exercise 1: (1) In ToyTest.java, comment out Toy’s default constructor and explain what happens.</p>
<p>Exercise 2: (2) Incorporate a new kind of interface into ToyTest.java and verify that it is detected and displayed properly.</p>
<p>Exercise 3: (2) Add Rhomboid to Shapes.java. Create a Rhomboid, upcast it to a Shape, then downcast it back to a Rhomboid. Try downcasting to a Circle and see what happens.</p>
<p>Exercise 4: (2) Modify the previous exercise so that it uses instanceof to check the type before performing the downcast.</p>
<p>Exercise 5: (3) Implement a rotate(Shape) method in Shapes.java, such that it checks to see if it is rotating a Circle (and, if so, doesn’t perform the operation).</p>
<p>Exercise 6: (4) Modify Shapes.java so that it can &quot;highlight&quot; (set a flag in) all shapes of a particular type. The toString( ) method for each derived Shape should indicate whether that Shape is &quot;highlighted.&quot;</p>
<p>Exercise 7: (3) Modify SweetShop.java so that each type of object creation is controlled by a command-line argument. That is, if your command line is &quot;Java Sweetshop Candy,&quot; then only the Candy object is created. Notice how you can control which Class objects are loaded via the commandline argument.</p>
<p>Exercise 8: (5) Write a method that takes an object and recursively prints all the classes in that object’s hierarchy.</p>
<p>Exercise 9: (5) Modify the previous exercise so that it uses Class.getDeclaredFields( ) to also display information about the fields in a class.</p>
<p>Exercise 10: (3) Write a program to determine whether an array of char is a primitive type or a true Object.</p>
<subtitle>Class literals</subtitle>
<p>Java provides a second way to produce the reference to the Class object: the class literal. In the preceding program this would look like:</p>
<p>FancyToy.class;</p>
<p>which is not only simpler, but also safer since it’s checked at compile time (and thus does not need to be placed in a try block). Because it eliminates the forName( ) method call, it’s also more efficient.</p>
<p>Class literals work with regular classes as well as interfaces, arrays, and primitive types. In addition, there’s a standard field called TYPE that exists for each of the primitive wrapper classes. The TYPE field produces a reference to the Class object for the associated primitive type, such that:</p>
<table>
<tr><td colspan="2">... is equivalent to ...</td></tr>
<tr><td>boolean.class</td><td>Boolean.TYPE</td></tr>
<tr><td>char.class</td><td>Character.TYPE</td></tr>
<tr><td>byte.class</td><td>Byte.TYPE</td></tr>
<tr><td>short.class</td><td>Short.TYPE</td></tr>
<tr><td>int.class</td><td>Integer.TYPE</td></tr>
<tr><td>long.class</td><td>Long.TYPE</td></tr>
<tr><td>float.class</td><td>Float.TYPE</td></tr>
<tr><td>double.class</td><td>Double.TYPE</td></tr>
<tr><td>void. class</td><td>Void.TYPE</td></tr>
</table>
<p>My preference is to use the &quot;.class&quot; versions if you can, since they’re more consistent with regular classes.</p>
<p>It’s interesting to note that creating a reference to a Class object using &quot;.class&quot; doesn’t automatically initialize the Class object. There are actually three steps in preparing a class for use:</p>
<p>1.    Loading, which is performed by the class loader. This finds the bytecodes (usually, but not necessarily, on your disk in your classpath) and creates a Class object from those bytecodes.</p>
<p>2.    Linking. The link phase verifies the bytecodes in the class, allocates storage for static fields, and if necessary, resolves all references to other classes made by this class.</p>
<p>3.    Initialization. If there’s a superclass, initialize that. Execute static initializers and static initialization blocks.</p>
<p>Initialization is delayed until the first reference to a static method (the constructor is implicitly static) or to a non-constant static field:</p>
<p>//: typeinfo/ClassInitialization.java import java.util.*;</p>
<p>class Initable {</p>
<p>static final int staticFinal = 47; static final int staticFinal2 =</p>
<p>ClassInitialization.rand.nextInt(1000); static {</p>
<p>System.out.println(&quot;Initializing Initable&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Initable2 {</p>
<p>static int staticNonFinal = 147; static {</p>
<p>System.out.println(&quot;Initializing Initable2&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Initable3 {</p>
<p>static int staticNonFinal = 74; static {</p>
<p>System.out.println(&quot;Initializing Initable3&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class ClassInitialization {</p>
<p>public static Random rand = new Random(47);</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>Class initable = Initable.class;</p>
<p>System.out.println(&quot;After creating Initable ref&quot;);</p>
<p>// Does not trigger initialization: System.out.println(Initable.staticFinal);</p>
<p>// Does trigger initialization: System.out.println(Initable.staticFinal2);</p>
<p>// Does trigger initialization: System.out.println(Initable2.staticNonFinal);</p>
<p>Class initable3 = Class.forName(&quot;Initable3&quot;); System.out.println(&quot;After creating Initable3 ref&quot;); System.out.println(Initable3.staticNonFinal);</p>
<p>}</p>
<p>} /* Output:</p>
<p>After creating Initable ref 47</p>
<p>Initializing Initable 258</p>
<p>Initializing Initable2 147</p>
<p>Initializing Initable3 After creating Initable3 ref 74</p>
<p>*///:~</p>
<p>Effectively, initialization is &quot;as lazy as possible.&quot; From the creation of the initable reference, you can see that just using the .class syntax to get a reference to the class doesn’t cause initialization. However, Class.forName( ) initializes the class immediately in order to produce the Class reference, as you can see in the creation of initable3.</p>
<p>If a static final value is a &quot;compile-time constant,&quot; such as Initable.staticFinal, that value can be read without causing the Initable class to be initialized. Making a field static and final, however, does not guarantee this behavior: accessing Initable.staticFinal2 forces class initialization because it cannot be a compile-time constant.</p>
<p>If a static field is not final, accessing it always requires linking (to allocate storage for the field) and initialization (to initialize that storage) before it can be read, as you can see in the access to Initable2.staticNonFinal.</p>
<subtitle>Generic class references</subtitle>
<p>A Class reference points to a Class object, which manufactures instances of classes and contains all the method code for those instances. It also contains the statics for that class. So a Class reference really does indicate the exact type of what it’s pointing to: an object of the class Class.</p>
<p>However, the designers of Java SE5 saw an opportunity to make this a bit more specific by allowing you to constrain the type of Class object that the Class reference is pointing to, using the generic syntax. In the following example, both syntaxes are correct:</p>
<p>//: typeinfo/GenericClassReferences.java</p>
<p>public class GenericClassReferences { public static void main(String[] args) {</p>
<p>Class intClass = int.class;</p>
<p>Class&lt;Integer&gt; genericIntClass = int.class; genericIntClass = Integer.class; // Same thing intClass = double.class;</p>
<p>// genericIntClass = double.class; // Illegal</p>
<p>}</p>
<p>} ///:~</p>
<p>The ordinary class reference does not produce a warning. However, you can see that the ordinary class reference can be reassigned to any other Class object, whereas the generic class reference can only be assigned to its declared type. By using the generic syntax, you allow the compiler to enforce extra type checking.</p>
<p>What if you’d like to loosen the constraint a little? Initially, it seems like you ought to be able to do something like:</p>
<p>Class&lt;Number&gt; genericNumberClass = int.class;</p>
<p>This would seem to make sense because Integer is inherited from Number. But this doesn’t work, because the Integer Class object is not a subclass of the Number Class object (this may seem like a subtle distinction; we’ll look into it more deeply in the Generics chapter).</p>
<p>To loosen the constraints when using generic Class references, I employ the wildcard, which is part of Java generics. The wildcard symbol is ‘?’, and it indicates &quot;anything.&quot; So we can add wildcards to the ordinary Class reference in the above example and produce the same results:</p>
<p>//: typeinfo/WildcardClassReferences.java</p>
<p>public class WildcardClassReferences { public static void main(String[] args) {</p>
<p>Class&lt;?&gt; intClass = int.class; intClass = double.class;</p>
<p>}</p>
<p>} ///:~</p>
<p>In Java SE5, Class&lt;?&gt; is preferred over plain Class, even though they are equivalent and the plain Class, as you saw, doesn’t produce a compiler warning. The benefit of Class&lt;?&gt; is that it indicates that you aren’t just using a non-specific class reference by accident, or out of ignorance. You chose the non-specific version.</p>
<p>In order to create a Class reference that is constrained to a type or any subtype, you combine the wildcard with the extends keyword to create a bound. So instead of just saying Class&lt;Number&gt;, you say:</p>
<p>//: typeinfo/BoundedClassReferences.java</p>
<p>public class BoundedClassReferences { public static void main(String[] args) {</p>
<p>Class&lt;? extends Number&gt; bounded = int.class; bounded = double.class; bounded = Number.class;</p>
<p>// Or anything else derived from Number.</p>
<p>}</p>
<p>} ///:~</p>
<p>The reason for adding the generic syntax to Class references is only to provide compile-time type checking, so that if you do something wrong you find out about it a little sooner. You can’t actually go astray with ordinary Class references, but if you make a mistake you won’t find out until run time, which can be inconvenient.</p>
<p>Here’s an example that uses the generic class syntax. It stores a class reference, and later produces a List filled with objects that it generates using newlnstance( ):</p>
<p>//: typeinfo/FilledList.java import java.util.*;</p>
<p>class CountedInteger {</p>
<p>private static long counter; private final long id = counter++;</p>
<p>public String toString() { return Long.toString(id); }</p>
<p>}</p>
<p>public class FilledList&lt;T&gt; { private Class&lt;T&gt; type;</p>
<p>public FilledList(Class&lt;T&gt; type) { this.type = type; } public List&lt;T&gt; create(int nElements) {</p>
<p>List&lt;T&gt; result = new ArrayList&lt;T&gt;(); try {</p>
<p>for(int i = 0; i &lt; nElements; i++) result.add(type.newInstance());</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>return result;</p>
<p>}</p>
<p>public static void main(String[] args) { FilledList&lt;CountedInteger&gt; fl =</p>
<p>new FilledList&lt;CountedInteger&gt;(CountedInteger.class); System.out.println(fl.create(15));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</p>
<p>*///:~</p>
<p>Notice that this class must assume that any type that it works with has a default constructor (one without arguments), and you’ll get an exception if that isn’t the case. The compiler does not issue any warnings for this program.</p>
<p>An interesting thing happens when you use the generic syntax for Class objects: newlnstance( ) will return the exact type of the object, rather than just a basic Object as you saw in ToyTest.java. This is somewhat limited:</p>
<p>//: typeinfo/toys/GenericToyTest.java // Testing class Class. package typeinfo.toys;</p>
<p>public class GenericToyTest {</p>
<p>public static void main(String[] args) throws Exception { Class&lt;FancyToy&gt; ftClass = FancyToy.class;</p>
<p>// Produces exact type:</p>
<p>FancyToy fancyToy = ftClass.newInstance();</p>
<p>Class&lt;? super FancyToy&gt; up = ftClass.getSuperclass();</p>
<p>// This won’t compile:</p>
<p>// Class&lt;Toy&gt; up2 = ftClass.getSuperclass();</p>
<p>// Only produces Object:</p>
<p>Object obj = up.newInstance();</p>
<p>}</p>
<p>} ///:~</p>
<p>If you get the superclass, the compiler will only allow you to say that the superclass reference is &quot;some class that is a superclass of FancyToy&quot; as seen in the expression Class &lt;? super FancyToy &gt;. It will not accept a declaration of Class&lt;Toy&gt;. This seems a bit strange because getSuperclass( ) returns the base class (not interface) and the compiler knows what that class is at compile time—in this case, Toy.class, not just &quot;some superclass of FancyToy.&quot; In any event, because of the vagueness, the return value of up.newlnstance( ) is not a precise type, but just an Object.</p>
<subtitle>New cast syntax</subtitle>
<p>Java SE5 also adds a casting syntax for use with Class references, which is the cast( ) method:</p>
<p>//: typeinfo/ClassCasts.java</p>
<p>class Building {}</p>
<p>class House extends Building {}</p>
<p>public class ClassCasts {</p>
<p>public static void main(String[] args) {</p>
<p>Building b = new House();</p>
<p>Class&lt;House&gt; houseType = House.class;</p>
<p>House h = houseType.cast(b); h = (House)b; // ... or just do this.</p>
<p>}</p>
<p>} ///:~</p>
<p>The cast( ) method takes the argument object and casts it to the type of the Class reference. Of course, if you look at the above code it seems like a lot of extra work compared to the last line in main( ), which does the same thing.</p>
<p>The new casting syntax is useful for situations where you can’t just use an ordinary cast. This usually happens when you’re writing generic code (which you’ll learn about in the Generics chapter), and you’ve stored a Class reference that you want to use to cast with at a later time. It turns out to be a rare thing—I found only one instance where cast( ) was used in the entire Java SE5 library (it was in com.sun.mirror.util.DeclarationFilter).</p>
<p>Another new feature had no usage in the Java SE5 library: Class.asSubclass( ). This allows you to cast the class object to a more specific type.</p>
</section>
<section>
<title>
<p>Checking before a cast</p></title><empty-line/>
<p>So far, you’ve seen forms of RTTI, including:</p>
<p>1.    The classic cast; e.g., &quot;(Shape),&quot; which uses RTTI to make sure the cast is correct. This will throw a ClassCastException if you’ve performed a bad cast.</p>
<p>2.    The Class object representing the type of your object. The Class object can be queried for useful runtime information.</p>
<p>In C++, the classic cast &quot;(Shape)” does not perform RTTI. It simply tells the compiler to treat the object as the new type. In Java, which does perform the type check, this cast is often called a &quot;type-safe downcast.&quot; The reason for the term &quot;downcast&quot; is the historical arrangement of the class hierarchy diagram. If casting a Circle to a Shape is an upcast, then casting a Shape to a Circle is a downcast. However, because it knows that a Circle is also a Shape, the compiler freely allows an upcast assignment, without requiring any explicit cast syntax. The compiler cannot know, given a Shape, what that Shape actually is—it could be exactly a Shape, or it could be a subtype of Shape, such as a Circle, Square, Triangle or some other type. At compile time, the compiler only sees a Shape. Thus, it won’t allow you to perform a downcast assignment without using an explicit cast, to tell it that you have extra information that allows you to know that it is a particular type (the compiler will check to see if that downcast is reasonable, so it won’t let you downcast to a type that’s not actually a subclass).</p>
<p>There’s a third form of RTTI in Java. This is the keyword instanceof, which tells you if an object is an instance of a particular type. It returns a boolean so you use it in the form of a question, like this:</p>
<p>if(x instanceof Dog)</p>
<p>((Dog)x).bark();</p>
<p>The if statement checks to see if the object x belongs to the class Dog before casting x to a Dog. It’s important to use instanceof before a downcast when you don’t have other information that tells you the type of the object; otherwise, you’ll end up with a ClassCastException.</p>
<p>Ordinarily, you might be hunting for one type (triangles to turn purple, for example), but you can easily tally all of the objects by using instanceof. For example, suppose you have a family of classes to describe Pets (and their people, a feature which will come in handy in a later example). Each Individual in the hierarchy has an id and an optional name. Although the classes that follow inherit from Individual, there are some complexities in the Individual class, so that code will be shown and explained in the Containers in Depth chapter. As you can see, it’s not really necessary to see the code for Individual at this point—you only need to know that you can create it with or without a name, and that each Individual has a method id( ) that returns a unique identifier (created by counting each object). There’s also a toString( ) method; if you don’t provide a name for an Individual, toString( ) only produces the simple type name.</p>
<p>Here is the class hierarchy that inherits from Individual:</p>
<p>//: typeinfo/pets/Person.java package typeinfo.pets;</p>
<p>public class Person extends Individual { public Person(String name) { super(name); }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/Pet.java package typeinfo.pets;</p>
<p>public class Pet extends Individual { public Pet(String name) { super(name); } public Pet() { super(); }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/Dog.java package typeinfo.pets;</p>
<p>public class Dog extends Pet {</p>
<p>public Dog(String name) { super(name); } public Dog() { super(); }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/Mutt.java package typeinfo.pets;</p>
<p>public class Mutt extends Dog {</p>
<p>public Mutt(String name) { super(name); } public Mutt() { super(); }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/Pug.java package typeinfo.pets;</p>
<p>public class Pug extends Dog {</p>
<p>public Pug(String name) { super(name); } public Pug() { super(); }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/Cat.java package typeinfo.pets;</p>
<p>public class Cat extends Pet {</p>
<p>public Cat(String name) { super(name); } public Cat() { super(); }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/EgyptianMau.java package typeinfo.pets;</p>
<p>public class EgyptianMau extends Cat {</p>
<p>public EgyptianMau(String name) { super(name); } public EgyptianMau() { super(); }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/Manx.java package typeinfo.pets;</p>
<p>public class Manx extends Cat {</p>
<p>public    Manx(String name) {    super(name); }</p>
<p>public    Manx() { super(); }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/Cymric.java package typeinfo.pets;</p>
<p>public class Cymric extends Manx {</p>
<p>public    Cymric(String name)    {    super(name);    }</p>
<p>public    Cymric() { super();    }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/Rodent.java package typeinfo.pets;</p>
<p>public class Rodent extends Pet {</p>
<p>public    Rodent(String name)    {    super(name);    }</p>
<p>public    Rodent() { super();    }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/Rat.java package typeinfo.pets;</p>
<p>public class Rat extends Rodent {</p>
<p>public Rat(String name) { super(name); } public Rat() { super(); }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/Mouse.java package typeinfo.pets;</p>
<p>public class Mouse extends Rodent {</p>
<p>public    Mouse(String name) {    super(name);    }</p>
<p>public    Mouse() { super(); }</p>
<p>} ///:~</p>
<p>//: typeinfo/pets/Hamster.java package typeinfo.pets;</p>
<p>public class Hamster extends Rodent {</p>
<p>public    Hamster(String name)    {    super(name);    }</p>
<p>public    Hamster() { super();    }</p>
<p>} ///:~</p>
<p>Next, we need a way to randomly create different types of pets, and for convenience, to create arrays and Lists of pets. To allow this tool to evolve through several different implementations, we’ll define it as an abstract class:</p>
<p>//: typeinfo/pets/PetCreator.java // Creates random sequences of Pets. package typeinfo.pets;</p>
<p>import java.util.*;</p>
<p>public abstract class PetCreator { private Random rand = new Random(47);</p>
<p>// The List of the different types of Pet to create: public abstract List&lt;Class&lt;? extends Pet&gt;&gt; types(); public Pet randomPet() { // Create one random Pet int n = rand.nextInt(types().size()); try {</p>
<p>return types().get(n).newInstance();</p>
<p>} catch(InstantiationException e) { throw new RuntimeException(e);</p>
<p>} catch(IllegalAccessException e) { throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>public Pet[] createArray(int size) {</p>
<p>Pet[] result = new Pet[size]; for(int i = 0; i &lt; size; i++) result[i] = randomPet(); return result;</p>
<p>}</p>
<p>public ArrayList&lt;Pet&gt; arrayList(int size) {</p>
<p>ArrayList&lt;Pet&gt; result = new ArrayList&lt;Pet&gt;(); Collections.addAll(result, createArray(size)); return result;</p>
<p>}</p>
<p>} ///:~</p>
<p>The abstract getTypes( ) method defers to a derived class to get the List of Class objects (this is a variation of the Template Method design pattern). Notice that the type of class is specified to be &quot;anything derived from Pet,&quot; so that newlnstance( ) produces a Pet without requiring a cast. randomPet( ) randomly indexes into the List and uses the selected Class object to generate a new instance of that class with Class.newlnstance( ). The createArray( ) method uses randomPet( ) to fill an array, and arrayList( ) uses createArray( ) in turn.</p>
<p>You can get two kinds of exceptions when calling newlnstance( ). You can see these handled in the catch clauses following the try block. Again, the names of the exceptions are relatively useful explanations of what went wrong (IllegalAccessException relates to a violation of the Java security mechanism, in this case if the default constructor is private).</p>
<p>When you derive a subclass of PetCreator, the only thing you need to supply is the List of the types of pet that you want to create using randomPet( ) and the other methods. The getTypes( ) method will normally just return a reference to a static List. Here’s an implementation using forName( ):</p>
<p>//: typeinfo/pets/ForNameCreator.java package typeinfo.pets; import java.util.*;</p>
<p>public class ForNameCreator extends PetCreator { private static List&lt;Class&lt;? extends Pet&gt;&gt; types = new ArrayList&lt;Class&lt;? extends Pet&gt;&gt;();</p>
<p>// Types that you want to be randomly created: private static String[] typeNames = {</p>
<p>&quot;typeinfo.pets.Mutt&quot;,</p>
<p>&quot;typeinfo.pets.Pug&quot;,</p>
<p>&quot;typeinfo.pets.EgyptianMau&quot;,</p>
<p>&quot;typeinfo.pets.Manx&quot;,</p>
<p>&quot;typeinfo.pets.Cymric&quot;, &quot;typeinfo.pets.Rat&quot;,</p>
<p>&quot;typeinfo.pets.Mouse&quot;,</p>
<p>&quot;typeinfo.pets.Hamster&quot;</p>
<p>};</p>
<p>@SuppressWarnings(&quot;unchecked&quot;) private static void loader() { try {</p>
<p>for(String name : typeNames) types.add(</p>
<p>(Class&lt;? extends Pet&gt;)Class.forName(name));</p>
<p>} catch(ClassNotFoundException e) { throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>static { loader(); }</p>
<p>public List&lt;Class&lt;? extends Pet&gt;&gt; types() {return types;}</p>
<p>} ///:~</p>
<p>The loader( ) method creates the List of Class objects using Class.forName( ). This may generate a ClassNotFoundException, which makes sense since you’re passing it a String which cannot be validated at compile time. Since the Pet objects are in package typeinfo, the package name must be used when referring to the classes.</p>
<p>In order to produce a typed List of Class objects, a cast is required, which produces a compile-time warning. The loader( ) method is defined separately and then placed inside a static initialization clause because the @SuppressWarnings annotation cannot be placed directly onto the static initialization clause. To count Pets, we need a tool that keeps track of the quantities of various different types of Pets. A Map is perfect for this; the keys are the Pet type names and the values are Integers to hold the Pet quantities. This way, you can say, &quot;How many Hamster objects are there?&quot; We can use instanceof to count Pets:</p>
<p>//: typeinfo/PetCount.java // Using instanceof. import typeinfo.pets.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*; public class PetCount {</p>
<p>static class PetCounter extends HashMap&lt;String,Integer&gt; { public void count(String type) {</p>
<p>Integer quantity = get(type); if(quantity == null) put(type, 1); else</p>
<p>put(type, quantity + 1);</p>
<p>}</p>
<p>}</p>
<p>public static void countPets(PetCreator creator) {</p>
<p>PetCounter counter= new PetCounter(); for(Pet pet : creator.createArray(20)) {</p>
<p>// List each individual pet:</p>
<p>printnb(pet.getClass().getSimpleName() + &quot; &quot;); if(pet instanceof Pet) counter.count(&quot;Pet&quot;); if(pet instanceof Dog) counter.count(&quot;Dog&quot;); if(pet instanceof Mutt) counter.count(&quot;Mutt&quot;); if(pet instanceof Pug) counter.count(&quot;Pug&quot;); if(pet instanceof Cat)</p>
<p>counter.count(&quot;Cat&quot;); if(pet instanceof Manx)</p>
<p>counter.count(&quot;EgyptianMau&quot;); if(pet instanceof Manx) counter.count(&quot;Manx&quot;); if(pet instanceof Manx) counter.count(&quot;Cymric&quot;); if(pet instanceof Rodent) counter.count(&quot;Rodent&quot;); if(pet instanceof Rat) counter.count(&quot;Rat&quot;); if(pet instanceof Mouse) counter.count(&quot;Mouse&quot;); if(pet instanceof Hamster) counter.count(&quot;Hamster&quot;);</p>
<p>}</p>
<p>// Show the counts:</p>
<p>print();</p>
<p>print(counter);</p>
<p>}</p>
<p>public static void main(String[] args) { countPets(new ForNameCreator());</p>
<p>}</p>
<p>} /* Output:</p>
<p>Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric</p>
<p>{Pug=3, Cat=9, Hamster=1, Cymric=7, Mouse=2, Mutt=3, Rodent=5, Pet=20, Manx=7, EgyptianMau=7, Dog=6, Rat=2}</p>
<p>*///:~</p>
<p>In countPets( ), an array is randomly filled with Pets using a PetCreator. Then each Pet in the array is tested and counted using instanceof. There’s a rather narrow restriction on instanceof: You can compare it to a named type only, and not to a Class object. In the preceding example you might feel that it’s tedious to write out all of those instanceof expressions, and you’re right. But there is no way to cleverly automate instanceof by creating an array of Class objects and comparing it to those instead (stay tuned—you’ll see an alternative). This isn’t as great a restriction as you might think, because you’ll eventually understand that your design is probably flawed if you end up writing a lot of instanceof expressions.</p>
<subtitle>Using class literals</subtitle>
<p>If we reimplement the PetCreator using class literals, the result is cleaner in many ways:</p>
<p>//: typeinfo/pets/LiteralPetCreator.java // Using class literals. package typeinfo.pets; import java.util.*;</p>
<p>public class LiteralPetCreator extends PetCreator {</p>
<p>// No try block needed.</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public static final List&lt;Class&lt;? extends Pet&gt;&gt; allTypes = Collections.unmodifiableList(Arrays.asList(</p>
<p>Pet.class, Dog.class, Cat.class, Rodent.class,</p>
<p>Mutt.class, Pug.class, EgyptianMau.class, Manx.class, Cymric.class, Rat.class, Mouse.class,Hamster.class));</p>
<p>// Types for random creation:</p>
<p>private static final List&lt;Class&lt;? extends Pet&gt;&gt; types = allTypes.subList(allTypes.indexOf(Mutt.class),</p>
<p>allTypes.size());</p>
<p>public List&lt;Class&lt;? extends Pet&gt;&gt; types() { return types;</p>
<p>}</p>
<p>public static void main(String[] args) { System.out.println(types);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[class typeinfo.pets.Mutt, class typeinfo.pets.Pug, class typeinfo.pets.EgyptianMau, class typeinfo.pets.Manx, class typeinfo.pets.Cymric, class typeinfo.pets.Rat, class typeinfo.pets.Mouse, class typeinfo.pets.Hamster]</p>
<p>*///:~</p>
<p>In the upcoming PetCount3.java example, we need to pre-load a Map with all the Pet types (not just the ones that are to be randomly generated), so the allTypes List is necessary. The types list is the portion of allTypes (created using List.subList( )) that includes the exact pet types, so it is used for random Pet generation.</p>
<p>This time, the creation of types does not need to be surrounded by a try block since it’s evaluated at compile time and thus won’t throw any exceptions, unlike Class.forName( ).</p>
<p>We now have two implementations of PetCreator in the typeinfo.pets library. In order to provide the second one as a default implementation, we can create a Faqade that utilizes LiteralPetCreator:</p>
<p>//: typeinfo/pets/Pets.java // Facade to produce a default PetCreator. package typeinfo.pets; import java.util.*;</p>
<p>public class Pets {</p>
<p>public static final PetCreator creator = new LiteralPetCreator(); public static Pet randomPet() { return creator.randomPet();</p>
<p>}</p>
<p>public static Pet[] createArray(int size) { return creator.createArray(size);</p>
<p>}</p>
<p>public static ArrayList&lt;Pet&gt; arrayList(int size) { return creator.arrayList(size);</p>
<p>}</p>
<p>} ///:~</p>
<p>This also provides indirection to randomPet( ), createArray( ) and arrayList( ).</p>
<p>Because PetCount.countPets( ) takes a PetCreator argument, we can easily test the LiteralPetCreator (via the above Facade):</p>
<p>//: typeinfo/PetCount2.java import typeinfo.pets.*;</p>
<p>public class PetCount2 {</p>
<p>public static void main(String[] args) { PetCount.countPets(Pets.creator);</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>The output is the same as that of PetCount.java.</p>
<subtitle>A dynamic instanceof</subtitle>
<p>The Class.islnstance( ) method provides a way to dynamically test the type of an object. Thus, all those tedious instanceof statements can be removed from PetCount.java:</p>
<p>//: typeinfo/PetCount3.java</p>
<p>// Using isInstance()</p>
<p>import typeinfo.pets.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class PetCount3 { static class PetCounter</p>
<p>extends LinkedHashMap&lt;Class&lt;? extends Pet&gt;,Integer&gt; { public PetCounter() {</p>
<p>super(MapData.map(LiteralPetCreator.allTypes, 0));</p>
<p>}</p>
<p>public void count(Pet pet) {</p>
<p>// Class.isInstance() eliminates instanceofs: for(Map.Entry&lt;Class&lt;? extends Pet&gt;,Integer&gt; pair : entrySet())</p>
<p>if(pair.getKey().isInstance(pet))</p>
<p>put(pair.getKey(), pair.getValue() + 1);</p>
<p>}</p>
<p>public String toString() {</p>
<p>StringBuilder result = new StringBuilder(&quot;{&quot;); for(Map.Entry&lt;Class&lt;? extends Pet&gt;,Integer&gt; pair : entrySet()) {</p>
<p>result.append(pair.getKey().getSimpleName()); result.append(&quot;=&quot;); result.append(pair.getValue()); result.append(&quot;, &quot;);</p>
<p>}</p>
<p>result.delete(result.length()-2, result.length());</p>
<p>result.append(&quot;}&quot;);</p>
<p>return result.toString();</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>PetCounter petCount = new PetCounter(); for(Pet pet : Pets.createArray(20)) {</p>
<p>printnb(pet.getClass().getSimpleName() + &quot; &quot;); petCount.count(pet);</p>
<p>}</p>
<p>print();</p>
<p>print(petCount);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric</p>
<p>{Pet=20, Dog=6, Cat=9, Rodent=5, Mutt=3, Pug=3, EgyptianMau=2, Manx=7, Cymric=5, Rat=2, Mouse=2, Hamster=1}</p>
<p>*///:~</p>
<p>In order to count all the different types of Pet, the PetCounter Map is preloaded with the types from LiteralPetCreator.allTypes. This uses the net.mindview.util.MapData</p>
<p>class, which takes an Iterable (the allTypes List) and a constant value (zero, in this case), and fills the Map with keys taken from allTypes and values of zero). Without pre-loading the Map, you would only end up counting the types that are randomly generated, and not the base types like Pet and Cat.</p>
<p>You can see that the isInstance( ) method has eliminated the need for the instanceof expressions. In addition, this means that you can add new types of Pet simply by changing the LiteralPetCreator.types array; the rest of the program does not need modification (as it did when using the instanceof expressions).</p>
<p>The toString( ) method has been overloaded for easier-to-read output that still matches the typical output that you see when printing a Map.</p>
<subtitle>Counting recursively</subtitle>
<p>The Map in PetCount3.PetCounter was pre-loaded with all the different Pet classes. Instead of pre-loading the map, we can use Class.isAssignableFrom( ) and create a general-purpose tool that is not limited to counting Pets:</p>
<p>//: net/mindview/util/TypeCounter.java // Counts instances of a type family. package net.mindview.util; import java.util.*;</p>
<p>public class TypeCounter extends HashMap&lt;Class&lt;?&gt;,Integer&gt;{ private Class&lt;?&gt; baseType; public TypeCounter(Class&lt;?&gt; baseType) { this.baseType = baseType;</p>
<p>}</p>
<p>public void count(Object obj) {</p>
<p>Class&lt;?&gt; type = obj.getClass(); if(!baseType.isAssignableFrom(type))</p>
<p>throw new RuntimeException(obj + &quot; incorrect type: &quot;</p>
<p>+ type + &quot;, should be type or subtype of &quot;</p>
<p>+ baseType); countClass(type);</p>
<p>}</p>
<p>private void countClass(Class&lt;?&gt; type) {</p>
<p>Integer quantity = get(type);</p>
<p>put(type, quantity == null ? 1 : quantity + 1);</p>
<p>Class&lt;?&gt; superClass = type.getSuperclass(); if(superClass != null &amp;&amp;</p>
<p>baseType.isAssignableFrom(superClass))</p>
<p>countClass(superClass);</p>
<p>}</p>
<p>public String toString() {</p>
<p>StringBuilder result = new StringBuilder(&quot;{&quot;); for(Map.Entry&lt;Class&lt;?&gt;,Integer&gt; pair : entrySet()) { result.append(pair.getKey().getSimpleName()); result.append(&quot;=&quot;); result.append(pair.getValue()); result.append(&quot;, &quot;);</p>
<p>}</p>
<p>result.delete(result.length()-2, result.length());</p>
<p>result.append(&quot;}&quot;);</p>
<p>return result.toString();</p>
<p>}</p>
<p>} ///:~</p>
<p>The count( ) method gets the Class of its argument, and uses isAssignableFrom( ) to perform a runtime check to verify that the object that you’ve passed actually belongs to the hierarchy of interest. countClass( ) first counts the exact type of the class. Then, if baseType is assignable from the superclass, countClass( ) is called recursively on the superclass.</p>
<p>//: typeinfo/PetCount4.java</p>
<p>import typeinfo.pets.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class PetCount4 {</p>
<p>public static void main(String[] args) {</p>
<p>TypeCounter counter = new TypeCounter(Pet.class); for(Pet pet : Pets.createArray(20)) {</p>
<p>printnb(pet.getClassQ.getSimpleNameQ + &quot; &quot;); counter.count(pet);</p>
<p>}</p>
<p>print();</p>
<p>print(counter);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric {Mouse=2, Dog=6, Manx=7, EgyptianMau=2, Rodent=5, Pug=3, Mutt=3, Cymric=5, Cat=9, Hamster=1, Pet=20, Rat=2}</p>
<p>*///:~</p>
<p>As you can see from the output, both base types as well as exact types are counted.</p>
<p>Exercise 11: (2) Add Gerbil to the typeinfo.pets library and modify all the examples in this chapter to adapt to this new class.</p>
<p>Exercise 12: (3) Use TypeCounter with the CoffeeGenerator.java class in the Generics chapter.</p>
<p>Exercise 13: (3) Use TypeCounter with the RegisteredFactories.java example in this chapter.</p>
</section>
<section>
<title>
<p>Registered factories</p></title><empty-line/>
<p>A problem with generating objects of the Pets hierarchy is the fact that every time you add a new type of Pet to the hierarchy you must remember to add it to the entries in LiteralPetCreator.java. In a system where you add more classes on a regular basis this can become problematic.</p>
<p>You might think of adding a static initializer to each subclass, so that the initializer would add its class to a list somewhere. Unfortunately, static initializers are only called when the class is first loaded, so you have a chicken-and-egg problem: The generator doesn’t have the class in its list, so it can never create an object of that class, so the class won’t get loaded and placed in the list.</p>
<p>Basically, you’re forced to create the list yourself, by hand (unless you want to write a tool that searches through and analyzes your source code, then creates and compiles the list). So the best you can probably do is to put the list in one central, obvious place. The base class for the hierarchy of interest is probably the best place.</p>
<p>The other change we’ll make here is to defer the creation of the object to the class itself, using the Factory Method design pattern. A factory method can be called polymorphically, and creates an object of the appropriate type for you. In this very simple version, the factory method is the create( ) method in the Factory interface:</p>
<p>The generic parameter T allows create( ) to return a different type for each implementation of Factory. This also makes use of covariant return types. In this example, the base class Part contains a List of factory objects. Factories for types that should be produced by the createRandom( ) method are &quot;registered&quot; with the base class by adding them to the partFactories List:</p>
<p>//: typeinfo/RegisteredFactories.java // Registering Class Factories in the base class. import typeinfo.factory.*; import java.util.*;</p>
<p>class Part {</p>
<p>public String toString() {</p>
<p>return getClass().getSimpleName();</p>
<p>}</p>
<p>static List&lt;Factory&lt;? extends Part&gt;&gt; partFactories = new ArrayList&lt;Factory&lt;? extends Part&gt;&gt;(); static {</p>
<p>// Collections.addAll() gives an &quot;unchecked generic // array creation ... for varargs parameter&quot; warning. partFactories.add(new FuelFilter.Factory()); partFactories.add(new AirFilter.Factory()); partFactories.add(new CabinAirFilter.Factory()); partFactories.add(new OilFilter.Factory()); partFactories.add(new FanBelt.Factory()); partFactories.add(new PowerSteeringBelt.Factory()); partFactories.add(new GeneratorBelt.Factory());</p>
<p>}</p>
<p>private static Random rand = new Random(47); public static Part createRandom() {</p>
<p>int n = rand.nextInt(partFactories.size()); return partFactories.get(n).create();</p>
<p>}</p>
<p>}</p>
<p>class Filter extends Part {}</p>
<p>class FuelFilter extends Filter {</p>
<p>// Create a Class Factory for each specific type: public static class Factory</p>
<p>implements typeinfo.factory.Factory&lt;FuelFilter&gt; {</p>
<p>public FuelFilter create() { return new FuelFilter(); }</p>
<p>}</p>
<p>}</p>
<p>class AirFilter extends Filter { public static class Factory</p>
<p>implements typeinfo.factory.Factory&lt;AirFilter&gt; {</p>
<p>public AirFilter create() { return new AirFilter(); }</p>
<p>}</p>
<p>}</p>
<p>class CabinAirFilter extends Filter { public static class Factory</p>
<p>implements typeinfo.factory.Factory&lt;CabinAirFilter&gt; { public CabinAirFilter create() { return new CabinAirFilter();</p>
<p>}</p>
<p>class OilFilter extends Filter { public static class Factory</p>
<p>implements typeinfo.factory.Factory&lt;OilFilter&gt; {</p>
<p>public OilFilter create() { return new OilFilter(); }</p>
<p>}</p>
<p>}</p>
<p>class Belt extends Part {}</p>
<p>class FanBelt extends Belt { public static class Factory</p>
<p>implements typeinfo.factory.Factory&lt;FanBelt&gt; { public FanBelt create() { return new FanBelt(); }</p>
<p>}</p>
<p>}</p>
<p>class GeneratorBelt extends Belt { public static class Factory</p>
<p>implements typeinfo.factory.Factory&lt;GeneratorBelt&gt; { public GeneratorBelt create() { return new GeneratorBelt();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class PowerSteeringBelt extends Belt { public static class Factory</p>
<p>implements typeinfo.factory.Factory&lt;PowerSteeringBelt&gt; { public PowerSteeringBelt create() { return new PowerSteeringBelt();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class RegisteredFactories {</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 10; i++)</p>
<p>System.out.println(Part.createRandom());</p>
<p>}</p>
<p>} /* Output:</p>
<p>GeneratorBelt</p>
<p>CabinAirFilter</p>
<p>GeneratorBelt</p>
<p>AirFilter</p>
<p>PowerSteeringBelt</p>
<p>CabinAirFilter</p>
<p>FuelFilter</p>
<p>PowerSteeringBelt</p>
<p>PowerSteeringBelt</p>
<p>FuelFilter</p>
<p>*///:~</p>
<p>Not all classes in the hierarchy should be instantiated; in this case Filter and Belt are just classifiers so you do not create an instance of either one, but only of their subclasses. If a class should be created by createRandom( ), it contains an inner Factory class. The only way to reuse the name Factory as seen above is by qualifying typeinfo.factory.Factory.</p>
<p>Although you can use Collections.addAll( ) to add the factories to the list, the compiler expresses its unhappiness with a warning about a &quot;generic array creation&quot; (which is supposed</p>
<p>to be impossible, as you’ll see in the Generics chapter), so I reverted to calling add( ). The createRandom( ) method randomly selects a factory object from partFactories and calls its create( ) to produce a new Part.</p>
<p>Exercise 14: (4) A constructor is a kind of factory method. Modify RegisteredFactories.java so that instead of using an explicit factory, the class object is stored in the List, and newlnstance( ) is used to create each object.</p>
<p>Exercise 15: (4) Implement a new PetCreator using Registered Factories, and modify the Pets Facade so that it uses this one instead of the other two. Ensure that the rest of the examples that use Pets .Java still work correctly.</p>
<p>Exercise 16: (4) Modify the Coffee hierarchy in the Generics chapter to use Registered Factories.</p>
<p>instanceof vs. Class equivalence</p>
<p>When you are querying for type information, there’s an important difference between either form of instanceof (that is, instanceof or islnstance( ), which produce equivalent results) and the direct comparison of the Class objects. Here’s an example that demonstrates the difference:</p>
<p>//: typeinfo/FamilyVsExactType.java</p>
<p>// The difference between instanceof and class</p>
<p>package typeinfo;</p>
<p>import static net.mindview.util.Print.*; class Base {}</p>
<p>class Derived extends Base {}</p>
<p>public class FamilyVsExactType { static void test(Object x) {</p>
<p>print(&quot;Testing x of type &quot; + x.getClass()); print(&quot;x instanceof Base &quot; + (x instanceof Base)); print(&quot;x instanceof Derived &quot;+ (x instanceof Derived)); print(&quot;Base.isInstance(x) &quot;+ Base.class.isInstance(x)); print(&quot;Derived.isInstance(x) &quot; +</p>
<p>Derived.class.isInstance(x)); print(&quot;x.getClass() == Base.class &quot; +</p>
<p>(x.getClass() == Base.class)); print(&quot;x.getClass() == Derived.class &quot; +</p>
<p>(x.getClass() == Derived.class)); print(&quot;x.getClass().equals(Base.class)) &quot;+ (x.getClass().equals(Base.class))); print(&quot;x.getClass().equals(Derived.class)) &quot; + (x.getClass().equals(Derived.class)));</p>
<p>}</p>
<p>public static void main(String[] args) { test(new Base()); test(new Derived());</p>
<p>}</p>
<p>} /* Output:</p>
<p>Testing x of type class typeinfo.Base x instanceof Base true x instanceof Derived false Base.isInstance(x) true Derived.isInstance(x) false x.getClass() == Base.class true x.getClass() == Derived.class false</p>
<p>x.getClass().equals(Base.class)) true x.getClass().equals(Derived.class)) false Testing x of type class typeinfo.Derived x instanceof Base true x instanceof Derived true Base.islnstance(x) true Derived.islnstance(x) true x.getClass() == Base.class false x.getClass() == Derived.class true x.getClass().equals(Base.class)) false x.getClass().equals(Derived.class)) true *///:~</p>
<p>The test( ) method performs type checking with its argument using both forms of instanceof. It then gets the Class reference and uses == and equals( ) to test for equality of the Class objects. Reassuringly, instanceof and islnstance( ) produce exactly the same results, as do equals( ) and ==. But the tests themselves draw different conclusions. In keeping with the concept of type, instanceof says, &quot;Are you this class, or a class derived from this class?&quot; On the other hand, if you compare the actual Class objects using ==, there is no concern with inheritance—it’s either the exact type or it isn’t.</p>
</section>
<section>
<title>
<p>Reflection: runtime class information</p></title><empty-line/>
<p>If you don’t know the precise type of an object, RTTI will tell you. However, there’s a limitation: The type must be known at compile time in order for you to detect it using RTTI and to do something useful with the information. Put another way, the compiler must know about all the classes you’re working with.</p>
<p>This doesn’t seem like that much of a limitation at first, but suppose you’re given a reference to an object that’s not in your program space. In fact, the class of the object isn’t even available to your program at compile time. For example, suppose you get a bunch of bytes from a disk file or from a network connection, and you’re told that those bytes represent a class. Since this class shows up long after the compiler generates the code for your program, how can you possibly use such a class?</p>
<p>In a traditional programming environment, this seems like a far-fetched scenario. But as we move into a larger programming world, there are important cases in which this happens. The first is component-based programming, in which you build projects using Rapid Application Development (RAD) in an Application Builder Integrated Development Environment, which I shall refer to simply as an IDE. This is a visual approach to creating a program by moving icons that represent components onto a form. These components are then configured by setting some of their values at program time. This design-time configuration requires that any component be instantiable, that it exposes parts of itself, and that it allows its properties to be read and modified. In addition, components that handle Graphical User Interface (GUI) events must expose information about appropriate methods so that the IDE can assist the programmer in overriding these event-handling methods. Reflection provides the mechanism to detect the available methods and produce the method names. Java provides a structure for component-based programming through JavaBeans (described in the Graphical User Interfaces chapter).</p>
<p>Another compelling motivation for discovering class information at run time is to provide the ability to create and execute objects on remote platforms, across a network. This is called Remote Method Invocation (RMI), and it allows a Java program to have objects distributed across many machines. This distribution can happen for a number of reasons. For example, perhaps you’re doing a computation-intensive task, and in order to speed things up, you want to break it up and put pieces on machines that are idle. In other situations you might want to place code that handles particular types of tasks (e.g., &quot;Business Rules&quot; in a multitier client/server architecture) on a particular machine, so the machine becomes a common repository describing those actions, and it can be easily changed to affect everyone in the system. (This is an interesting development, since the machine exists solely to make software changes easy!) Along these lines, distributed computing also supports specialized hardware that might be good at a particular task-matrix inversions, for example—but inappropriate or too expensive for generalpurpose programming.</p>
<p>The class Class supports the concept of reflection, along with the java.lang.reflect library which contains the classes Field, Method, and Constructor (each of which implements the Member interface). Objects of these types are created by the JVM at run time to represent the corresponding member in the unknown class. You can then use the Constructors to create new objects, the get( ) and set( ) methods to read and modify the fields associated with Field objects, and the invoke( ) method to call a method associated with a Method object. In addition, you can call the convenience methods getFields( ), getMethods( ), getConstructors( ), etc., to return arrays of the objects representing the fields, methods, and constructors. (You can find out more by looking up the class Class in the JDK documentation.) Thus, the class information for anonymous objects can be completely determined at run time, and nothing need be known at compile time.</p>
<p>It’s important to realize that there’s nothing magic about reflection. When you’re using reflection to interact with an object of an unknown type, the JVM will simply look at the object and see that it belongs to a particular class (just like ordinary RTTI). Before anything can be done with it, the Class object must be loaded. Thus, the .class file for that particular type must still be available to the JVM, either on the local machine or across the network. So the true difference between RTTI and reflection is that with RTTI, the compiler opens and examines the .class file at compile time. Put another way, you can call all the methods of an object in the &quot;normal&quot; way. With reflection, the .class file is unavailable at compile time; it is opened and examined by the runtime environment.</p>
<subtitle>A class method extractor</subtitle>
<p>Normally you won’t need to use the reflection tools directly, but they can be helpful when you need to create more dynamic code. Reflection is in the language to support other Java features, such as object serialization and JavaBeans (both covered later in the book). However, there are times when it’s quite useful to dynamically extract information about a class.</p>
<p>Consider a class method extractor. Looking at a class definition source code or JDK documentation shows only the methods that are defined or overridden within that class definition. But there might be dozens more available to you that have come from base classes. To locate these is both tedious and time consuming.<a l:href="#bookmark58" type="note"><sup>59</sup></a><sup></sup> Fortunately, reflection provides a way to write a simple tool that will automatically show you the entire interface. Here’s the way it works:</p>
<p>//: typeinfo/ShowMethods.java</p>
<p>// Using reflection to show all the methods of a class,</p>
<p>// even if the methods are defined in the base class.</p>
<p>// {Args: ShowMethods}</p>
<p>import java.lang.reflect.*;</p>
<p>import java.util.regex.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ShowMethods {</p>
<p>private static String usage =</p>
<p>&quot;usage:\n&quot; +</p>
<p>&quot;ShowMethods qualified.class.name\n&quot; +</p>
<p>&quot;To show all methods in class or:\n&quot; +</p>
<p>&quot;ShowMethods qualified.class.name word\n&quot; +</p>
<p>&quot;To search for methods involving ‘word’&quot;; private static Pattern p = Pattern.compile(&quot;\\w+\\.&quot;); public static void main(String[] args) { if(args.length &lt; 1) { print(usage);</p>
<p>System.exit(0);</p>
<p>}</p>
<p>int lines = 0; try {</p>
<p>Class&lt;?&gt; c = Class.forName(args[0]);</p>
<p>Method[] methods = c.getMethods();</p>
<p>Constructor[] ctors = c.getConstructors(); if(args.length == 1) {</p>
<p>for(Method method : methods) print(</p>
<p>p.matcher(method.toString()).replaceAll(&quot;&quot;)); for(Constructor ctor : ctors)</p>
<p>print(p.matcher(ctor.toString()).replaceAll(&quot;&quot;)); lines = methods.length + ctors.length;</p>
<p>} else {</p>
<p>for(Method method : methods)</p>
<p>if(method.toString().indexOf(args[1]) != -1) { print(</p>
<p>p.matcher(method.toString()).replaceAll(&quot;&quot;));</p>
<p>lines++;</p>
<p>}</p>
<p>for(Constructor ctor : ctors)</p>
<p>if(ctor.toString().indexOf(args[1]) != -1) { print(p.matcher(</p>
<p>ctor.toString()).replaceAll(&quot;&quot;));</p>
<p>lines++;</p>
<p>}</p>
<p>}</p>
<p>} catch(ClassNotFoundException e) { print(&quot;No such class: &quot; + e);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>public static void main(String[]) public native int hashCode() public final native Class getClass()</p>
<p>public final void wait(long,int) throws InterruptedException</p>
<p>public final void wait() throws InterruptedException</p>
<p>public final native void wait(long) throws InterruptedException</p>
<p>public boolean equals(Object)</p>
<p>public String toString()</p>
<p>public final native void notify()</p>
<p>public final native void notifyAll()</p>
<p>public ShowMethods()</p>
<p>*///:~</p>
<p>The Class methods getMethods( ) and getConstructors( ) return an array of Method and array of Constructor, respectively. Each of these classes has further methods to dissect the names, arguments, and return values of the methods they represent. But you can also just use toString( ), as is done here, to produce a String with the entire method signature. The rest of the code extracts the command-line information, determines if a particular signature matches your target string (using indexOf( )), and strips off the name qualifiers using regular expressions (introduced in the Strings chapter).</p>
<p>The result produced by Class.forName( ) cannot be known at compile time, and therefore all the method signature information is being extracted at run time. If you investigate the JDK reflection documentation, you’ll see that there is enough support to actually set up and make a method call on an object that’s totally unknown at compile time (there will be examples of this later in this book). Although initially this is something you may not think you’ll ever need, the value of full reflection can be quite surprising.</p>
<p>The output above is produced from the command line:</p>
<p>java ShowMethods ShowMethods</p>
<p>You can see that the output includes a public default constructor, even though no constructor was defined. The constructor you see is the one that’s automatically synthesized by the compiler. If you then make ShowMethods a non-public class (that is, package access), the synthesized default constructor no longer shows up in the output. The synthesized default constructor is automatically given the same access as the class.</p>
<p>Another interesting experiment is to invoke Java ShowMethods java.lang.String with an extra argument of char, int, String, etc.</p>
<p>This tool can be a real time-saver while you’re programming, when you can’t remember if a class has a particular method and you don’t want to go hunting through the index or class hierarchy in the JDK documentation, or if you don’t know whether that class can do anything with, for example, Color objects.</p>
<p>The Graphical User Interfaces chapter contains a GUI version of this program (customized to extract information for Swing components) so you can leave it running while you’re writing code, to allow quick lookups.</p>
<p>Exercise 17: (2) Modify the regular expression in ShowMethods.java to additionally strip off the keywords native and final (hint: use the OR operator’|’)-</p>
<p>Exercise 18: (1) Make ShowMethods a non-public class and verify that the synthesized default constructor no longer shows up in the output.</p>
<p>Exercise 19: (4) In ToyTest.java, use reflection to create a Toy object using the nondefault constructor.</p>
<p>Exercise 20: (5) Look up the interface for java.lang.Class in the JDK documentation from <a l:href="http://java.sun.com">http://java.sun.com</a>. Write a program that takes the name of a class as a command-line argument, then uses the Class methods to dump all the information available for that class. Test your program with a standard library class and a class you create.</p>
</section>
<section>
<title>
<p>Dynamic proxies</p></title><empty-line/>
<p>Proxy is one of the basic design patterns. It is an object that you insert in place of the &quot;real&quot; object in order to provide additional or different operations—these usually involve communication with a &quot;real&quot; object, so a proxy typically acts as a go-between. Here’s a trivial example to show the structure of a proxy:</p>
<p>//: typeinfo/SimpleProxyDemo.java import static net.mindview.util.Print.*;</p>
<p>interface Interface { void doSomething(); void somethingElse(String arg);</p>
<p>class RealObject implements Interface {</p>
<p>public void doSomething() { print(&quot;doSomething&quot;); } public void somethingElse(String arg) { print(&quot;somethingElse &quot; + arg);</p>
<p>}</p>
<p>}</p>
<p>class SimpleProxy implements Interface { private Interface proxied; public SimpleProxy(Interface proxied) { this.proxied = proxied;</p>
<p>}</p>
<p>public void doSomething() {</p>
<p>print(&quot;SimpleProxy doSomething&quot;); proxied.doSomething();</p>
<p>}</p>
<p>public void somethingElse(String arg) { print(&quot;SimpleProxy somethingElse &quot; + arg); proxied.somethingElse(arg);</p>
<p>}</p>
<p>}</p>
<p>class SimpleProxyDemo {</p>
<p>public static void consumer(Interface iface) { iface.doSomething(); iface.somethingElse(&quot;bonobo&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { consumer(new RealObject()); consumer(new SimpleProxy(new RealObject()));</p>
<p>}</p>
<p>} /* Output: doSomething somethingElse bonobo SimpleProxy doSomething doSomething</p>
<p>SimpleProxy somethingElse bonobo</p>
<p>somethingElse bonobo</p>
<p>*///:~</p>
<p>Because consumer( ) accepts an Interface, it can’t know if it’s getting a RealObject or a SimpleProxy, because both implement Interface. But the SimpleProxy inserted between the client and the RealObject performs operations and then calls the identical method on a RealObject.</p>
<p>A proxy can be helpful anytime you’d like to separate extra operations into a different place than the &quot;real object,&quot; and especially when you want to easily change from not using the extra operations to using them, and vice versa (the point of design patterns is to encapsulate change—so you need to be changing things in order to justify the pattern). For example, what if you wanted to track calls to the methods in the RealObject, or to measure the overhead of such calls? This is not code you want to have incorporated in your application, so a proxy allows you to add and remove it easily.</p>
<p>Java’s dynamic proxy takes the idea of a proxy one step further, by both creating the proxy object dynamically and handling calls to the proxied methods dynamically. All calls made on a dynamic proxy are redirected to a single invocation handler, which has the job of discovering what the call is and deciding what to do about it. Here’s SimpleProxyDemo.java rewritten to use a dynamic proxy:</p>
<p>//: typeinfo/SimpleDynamicProxy.java import java.lang.reflect.*;</p>
<p>class DynamicProxyHandler implements InvocationHandler { private Object proxied;</p>
<p>public DynamicProxyHandler(Object proxied) { this.proxied = proxied;</p>
<p>}</p>
<p>public Object</p>
<p>invoke(Object proxy, Method method, Object[] args) throws Throwable {</p>
<p>System.out.println(&quot;**** proxy: &quot; + proxy.getClass() + &quot;, method: &quot; + method + &quot;, args: &quot; + args); if(args != null)</p>
<p>for(Object arg : args)</p>
<p>System.out.println(&quot; &quot; + arg); return method.invoke(proxied, args);</p>
<p>}</p>
<p>}</p>
<p>class SimpleDynamicProxy {</p>
<p>public static void consumer(Interface iface) { iface.doSomething(); iface.somethingElse(&quot;bonobo&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>RealObject real = new RealObject(); consumer(real);</p>
<p>// Insert a proxy and call again:</p>
<p>Interface proxy = (Interface)Proxy.newProxyInstance( Interface.class.getClassLoader(), new Class[]{ Interface.class }, new DynamicProxyHandler(real)); consumer(proxy);</p>
<p>}</p>
<p>} /* Output: (95% match) doSomething somethingElse bonobo</p>
<p>**** proxy: class $Proxy0, method: public abstract void</p>
<p>Interface.doSomething(), args: null</p>
<p>doSomething</p>
<p>**** proxy: class $Proxy0, method: public abstract void Interface.somethingElse(java.lang.String), args: [Ljava.lang.Object;@42e816 bonobo</p>
<p>somethingElse bonobo *///:~</p>
<p>You create a dynamic proxy by calling the static method Proxy.newProxyInstance( ), which requires a class loader (you can generally just hand it a class loader from an object that has already been loaded), a list of interfaces (not classes or abstract classes) that you wish the proxy to implement, and an implementation of the interface InvocationHandler. The dynamic proxy will redirect all calls to the invocation handler, so the constructor for the invocation handler is usually given the reference to the &quot;real&quot; object so that it can forward requests once it performs its intermediary task.</p>
<p>The invoke( ) method is handed the proxy object, in case you need to distinguish where the request came from—but in many cases you won’t care. However, be careful when calling methods on the proxy inside invoke( ), because calls through the interface are redirected through the proxy.</p>
<p>In general you will perform the proxied operation and then use Method.invoke( ) to forward the request to the proxied object, passing the necessary arguments. This may initially seem limiting, as if you can only perform generic operations. However, you can filter for certain method calls, while passing others through:</p>
<p>//: typeinfo/SelectingMethods.java</p>
<p>// Looking for particular methods in a dynamic proxy.</p>
<p>import java.lang.reflect.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class MethodSelector implements InvocationHandler { private Object proxied; public MethodSelector(Object proxied) { this.proxied = proxied;</p>
<p>}</p>
<p>public Object</p>
<p>invoke(Object proxy, Method method, Object[] args) throws Throwable {</p>
<p>if(method.getName().equals(&quot;interesting&quot;))</p>
<p>print(&quot;Proxy detected the interesting method&quot;); return method.invoke(proxied, args);</p>
<p>}</p>
<p>}</p>
<p>interface SomeMethods { void boring1(); void boring2(); void interesting(String arg); void boring3();</p>
<p>}</p>
<p>class Implementation implements SomeMethods { public void boring1() { print(&quot;boring1&quot;); } public void boring2() { print(&quot;boring2&quot;); } public void interesting(String arg) { print(&quot;interesting &quot; + arg);</p>
<p>}</p>
<p>public void boring3() { print(&quot;boring3&quot;); }</p>
<p>}</p>
<p>class SelectingMethods {</p>
<p>public static void main(String[] args) {</p>
<p>SomeMethods proxy= (SomeMethods)Proxy.newProxyInstance( SomeMethods.class.getClassLoader(), new Class[]{ SomeMethods.class }, new MethodSelector(new Implementation())); proxy.boring1(); proxy.boring2(); proxy.interesting(&quot;bonobo&quot;); proxy.boring3();</p>
<p>}</p>
<p>} /* Output:</p>
<p>boring1</p>
<p>boring2</p>
<p>Proxy detected the interesting method interesting bonobo boring3 *///:~</p>
<p>Here, we are just looking for method names, but you could also be looking for other aspects of the method signature, and you could even search for particular argument values.</p>
<p>The dynamic proxy is not a tool that you’ll use every day, but it can solve certain types of problems very nicely. You can learn more about Proxy and other design patterns in Thinking in Patterns (see <a l:href="http://www.MindView.net">www.MindView.net</a>) and Design Patterns, by Erich Gamma et al. (Addison-Wesley, 1995).</p>
<p>Exercise 21: (3) Modify SimpleProxyDemo.java so that it measures method-call times.</p>
<p>Exercise 22: (3) Modify SimpleDynamicProxy.java so that it measures method-call times.</p>
<p>Exercise 23: (3) Inside invoke( ) in SimpleDynamicProxy.java, try to print the proxy argument and explain what happens.</p>
<p>Project:<sup>2</sup> Write a system using dynamic proxies to implement transactions, where the proxy performs a commit if the proxied call is successful (doesn’t throw any exceptions) and a rollback if it fails. Your commit and rollback should work on an external text file, which is outside the control of Java exceptions. You will have to pay attention to the atomicity of operations.</p>
</section>
<section>
<title>
<p>Null Objects</p></title><empty-line/>
<p>When you use the built-in null to indicate the absence of an object, you must test a reference for null-ness every time you use it. This can get very tedious and produce ponderous code. The problem is that null has no behavior of its own except for producing a NullPointerException if you try to do anything with it. Sometimes it is useful to introduce the idea of a Null Object<sup>3</sup> that will accept messages for the object that it’s &quot;standing in&quot; for, but will return values indicating that no &quot;real&quot; object is actually there. This way, you can assume that all objects are valid and you don’t have to waste programming time checking for null (and reading the resulting code).</p>
<p>Although it’s fun to imagine a programming language that would automatically create Null Objects for you, in practice it doesn’t make sense to use them everywhere—sometimes checking for null is fine, and sometimes you can reasonably assume that you won’t encounter null, and sometimes even detecting aberrations via NullPointerException is acceptable. The place where Null Objects seem to be most useful is &quot;closer to the data,&quot; with objects that represent entities in the problem space. As a simple example, many systems will have a Person class, and there are situations in the code where you don’t have an actual person (or you do, but you don’t have all the information about that person yet), so traditionally you’d use a null reference and test for it. Instead, we can make a Null Object.</p>
<p>But even though the Null Object will respond to all messages that the &quot;real&quot; object will respond to, you still need a way to test for nullness. The simplest way to do this is to create a tagging interface:</p>
<p>//: net/mindview/util/Null.java package net.mindview.util; public interface Null {} ///:~</p>
<p><sup>2</sup>    Projects are suggestions to be used (for example) as term projects. Solutions to projects are not included in the solution guide.</p>
<p><sup>3</sup>    Discovered by Bobby Woolf and Bruce Anderson. This can be seen as a special case of the Strategy pattern. A variant of Null Object is the Null Iterator pattern, which makes iteration over the nodes in a composite hierarchy transparent to the client (the client can then use the same logic for iterating over the composite and leaf nodes).</p>
<p>This allows instanceof to detect the Null Object, and more importantly, does not require you to add an isNull( ) method to all your classes (which would be, after all, just a different way of performing RTTI—why not use the built-in facility instead?).</p>
<p>//: typeinfo/Person.java</p>
<p>// A class with a Null Object.</p>
<p>import net.mindview.util.*;</p>
<p>class Person {</p>
<p>public final String first; public final String last; public final String address;</p>
<p>// etc.</p>
<p>public Person(String first, String last, String address){ this.first = first; this.last = last; this.address = address;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;Person: &quot; + first + &quot; &quot; + last + &quot; &quot; + address;</p>
<p>}</p>
<p>public static class NullPerson extends Person implements Null {</p>
<p>private NullPerson() { super(&quot;None&quot;, &quot;None&quot;, &quot;None&quot;); } public String toString() { return &quot;NullPerson&quot;; }</p>
<p>}</p>
<p>public static final Person NULL = new NullPerson();</p>
<p>} ///:~</p>
<p>In general, the Null Object will be a Singleton, so here it is created as a static final instance. This works because Person is immutable—you can only set the values in the constructor, and then read those values, but you can’t modify them (because Strings themselves are inherently immutable). If you want to change a NullPerson, you can only replace it with a new Person object. Notice that you have the option of detecting the generic Null or the more specific NullPerson using instanceof, but with the Singleton approach you can also just use equals( ) or even == to compare to Person.NULL.</p>
<p>Now suppose you’re back in the high-flying days of Internet startups and you’ve been given a big pile of venture funding for your Amazing Idea. You’re ready to staff up, but while you’re waiting for positions to be filled, you can use Person Null Objects as placeholders for each Position:</p>
<p>//: typeinfo/Position.java</p>
<p>class Position {</p>
<p>private String title; private Person person;</p>
<p>public Position(String jobTitle, Person employee) { title = jobTitle; person = employee; if(person == null) person = Person.NULL;</p>
<p>}</p>
<p>public Position(String jobTitle) { title = jobTitle; person = Person.NULL;</p>
<p>}</p>
<p>public String getTitle() { return title; } public void setTitle(String newTitle) { title = newTitle;</p>
<p>}</p>
<p>public Person getPerson() { return person; } public void setPerson(Person newPerson) { person = newPerson; if(person == null) person = Person.NULL;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;Position: &quot; + title + &quot; &quot; + person;</p>
<p>}</p>
<p>} ///:~</p>
<p>With Position, we don’t need to make a Null Object because the existence of Person.NULL implies a null Position (it’s possible that, later, you’ll discover the need to add an explicit Null Object for Position, but YAGNI<a l:href="#bookmark59" type="note"><sup>60</sup></a><sup></sup> (You Aren’t Going to Need It) says to try &quot;the simplest thing that could possibly work&quot; for your first draft, and to wait until some aspect of the program requires you to add in the extra feature, rather than assuming it’s necessary).</p>
<p>The Staff class can now look for Null Objects when you are filling positions:</p>
<p>//: typeinfo/Staff.java import java.util.*;</p>
<p>public class Staff extends ArrayList&lt;Position&gt; { public void add(String title, Person person) { add(new Position(title, person));</p>
<p>}</p>
<p>public void add(String... titles) { for(String title : titles) add(new Position(title));</p>
<p>}</p>
<p>public Staff(String... titles) { add(titles); } public boolean positionAvailable(String title) { for(Position position : this)</p>
<p>if(position.getTitle().equals(title) &amp;&amp; position.getPerson() == Person.NULL) return true; return false;</p>
<p>}</p>
<p>public void fillPosition(String title, Person hire) { for(Position position : this)</p>
<p>if(position.getTitle().equals(title) &amp;&amp; position.getPerson() == Person.NULL) { position.setPerson(hire); return;</p>
<p>}</p>
<p>throw new RuntimeException(</p>
<p>&quot;Position &quot; + title + &quot; not available&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Staff staff = new Staff(&quot;President&quot;, &quot;CTO&quot;,</p>
<p>&quot;Marketing Manager&quot;, &quot;Product Manager&quot;,</p>
<p>&quot;Project Lead&quot;, &quot;Software Engineer&quot;,</p>
<p>&quot;Software Engineer&quot;, &quot;Software Engineer&quot;,</p>
<p>&quot;Software Engineer&quot;, &quot;Test Engineer&quot;,</p>
<p>&quot;Technical Writer&quot;); staff.fillPosition(&quot;President&quot;,</p>
<p>new Person(&quot;Me&quot;, &quot;Last&quot;, &quot;The Top, Lonely At&quot;)); staff.fillPosition(&quot;Project Lead&quot;,</p>
<p>new Person(&quot;Janet&quot;, &quot;Planner&quot;, &quot;The Burbs&quot;)); if(staff.positionAvailable(&quot;Software Engineer&quot;)) staff.fillPosition(&quot;Software Engineer&quot;,</p>
<p>new Person(&quot;Bob&quot;, &quot;Coder&quot;, &quot;Bright Light City&quot;)); System.out.println(staff);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[Position: President Person: Me Last The Top, Lonely At, Position: CTO NullPerson, Position: Marketing Manager NullPerson, Position: Product Manager NullPerson, Position: Project Lead Person: Janet Planner The Burbs, Position: Software Engineer Person: Bob Coder Bright Light City, Position: Software Engineer NullPerson, Position: Software Engineer NullPerson, Position: Software Engineer NullPerson, Position: Test Engineer NullPerson, Position: Technical Writer NullPerson]</p>
<p>*///:~</p>
<p>Notice that you must still test for Null Objects in some places, which is not that different from checking for null, but in other places (such as toString( ) conversions, in this case), you don’t have to perform extra tests; you can just assume that all object references are valid.</p>
<p>If you are working with interfaces instead of concrete classes, it’s possible to use a DynamicProxy to automatically create the Null Objects. Suppose we have a Robot interface that defines a name, model, and a List &lt; Operation &gt; that describes what the Robot is capable of doing. Operation contains a description and a command (it’s a type of Command pattern):</p>
<p>//: typeinfo/Operation.java</p>
<p>public interface Operation {</p>
<p>String description(); void command();</p>
<p>} ///:~</p>
<p>You can access a Robot’s services by calling operations( ):</p>
<p>//: typeinfo/Robot.java import java.util.*; import net.mindview.util.*;</p>
<p>public interface Robot {</p>
<p>String name();</p>
<p>String model();</p>
<p>List&lt;Operation&gt; operations(); class Test {</p>
<p>public static void test(Robot r) { if(r instanceof Null)</p>
<p>System.out.println(&quot;[Null Robot]&quot;);</p>
<p>System.out.println(&quot;Robot name: &quot; + r.name()); System.out.println(&quot;Robot model: &quot; + r.model()); for(Operation operation : r.operations()) { System.out.println(operation.description()); operation.command();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>This also incorporates a nested class to perform tests.</p>
<p>We can now create a Robot that removes snow:</p>
<p>//: typeinfo/SnowRemovalRobot.java import java.util.*;</p>
<p>public class SnowRemovalRobot implements Robot { private String name;</p>
<p>public SnowRemovalRobot(String name) {this.name = name;} public String name() { return name; } public String model() { return &quot;SnowBot Series 11&quot;; } public List&lt;Operation&gt; operations() { return Arrays.asList( new Operation() {</p>
<p>public String description() {</p>
<p>return name + &quot; can shovel snow&quot;;</p>
<p>}</p>
<p>public void command() {</p>
<p>System.out.println(name + &quot; shoveling snow&quot;);</p>
<p>}</p>
<p>},</p>
<p>new Operation() {</p>
<p>public String description() { return name + &quot; can chip ice&quot;;</p>
<p>}</p>
<p>public void command() {</p>
<p>System.out.println(name + &quot; chipping ice&quot;);</p>
<p>}</p>
<p>},</p>
<p>new Operation() {</p>
<p>public String description() {</p>
<p>return name + &quot; can clear the roof&quot;;</p>
<p>}</p>
<p>public void command() {</p>
<p>System.out.println(name + &quot; clearing roof&quot;);</p>
<p>}</p>
<p>}</p>
<p>);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Robot.Test.test(new SnowRemovalRobot(&quot;Slusher&quot;));</p>
<p>}</p>
<p>} /* Output:</p>
<p>Robot name: Slusher Robot model: SnowBot Series 11 Slusher can shovel snow Slusher shoveling snow Slusher can chip ice Slusher chipping ice Slusher can clear the roof Slusher clearing roof *///:~</p>
<p>There will presumably be many different types of Robot, and we’d like to have each Null Object do something special for each Robot type-in this case, incorporate information about the exact type of Robot the Null Object is standing for. This information will be captured by the dynamic proxy:</p>
<p>//: typeinfo/NullRobot.java</p>
<p>// Using a dynamic proxy to create a Null Object.</p>
<p>import java.lang.reflect.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>class NullRobotProxyHandler implements InvocationHandler {</p>
<p>private String nullName; private Robot proxied = new NRobot(); NullRobotProxyHandler(Class&lt;? extends Robot&gt; type) { nullName = type.getSimpleName() + &quot; NullRobot&quot;;</p>
<p>}</p>
<p>private class NRobot implements Null, Robot { public String name() { return nullName; } public String model() { return nullName; } public List&lt;Operation&gt; operations() { return Collections.emptyList();</p>
<p>}</p>
<p>}</p>
<p>public Object</p>
<p>invoke(Object proxy, Method method, Object[] args) throws Throwable {</p>
<p>return method.invoke(proxied, args);</p>
<p>}</p>
<p>}</p>
<p>public class NullRobot { public static Robot</p>
<p>newNullRobot(Class&lt;? extends Robot&gt; type) { return (Robot)Proxy.newProxyInstance( NullRobot.class.getClassLoader(), new Class[]{ Null.class, Robot.class }, new NullRobotProxyHandler(type));</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Robot[] bots = {</p>
<p>new SnowRemovalRobot(&quot;SnowBee&quot;), newNullRobot(SnowRemovalRobot.class)</p>
<p>};</p>
<p>for(Robot bot : bots)</p>
<p>Robot.Test.test(bot);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Robot name: SnowBee Robot model: SnowBot Series 11 SnowBee can shovel snow SnowBee shoveling snow SnowBee can chip ice SnowBee chipping ice SnowBee can clear the roof SnowBee clearing roof [Null Robot]</p>
<p>Robot name: SnowRemovalRobot NullRobot Robot model: SnowRemovalRobot NullRobot *///:~</p>
<p>Whenever you need a null Robot object, you just call newNullRobot( ), passing the type of Robot you want a proxy for. The proxy fulfills the requirements of the Robot and Null interfaces, and provides the specific name of the type that it proxies.</p>
<subtitle>Mock Objects &amp; Stubs</subtitle>
<p>Logical variations of the Null Object are the MocA: Object and the Stub. Like Null Object, both of these are stand-ins for the &quot;real&quot; object that will be used in the finished program. However, both Mock Object and Stub pretend to be live objects that deliver real information, rather than being a more intelligent placeholder for null, as Null Object is.</p>
<p>The distinction between Mock Object and Stub is one of degree. Mock Objects tend to be lightweight and self-testing, and usually many of them are created to handle various testing situations. Stubs just return stubbed data, are typically heavyweight and are often reused between tests. Stubs can be configured to change depending on how they are called. So a Stub is a sophisticated object that does lots of things, whereas you usually create lots of small, simple Mock Objects if you need to do many things.</p>
<p>Exercise 24: (4) Add Null Objects to RegisteredFactories.java.</p>
</section>
<section>
<title>
<p>Interfaces and type information</p></title><empty-line/>
<p>An important goal of the interface keyword is to allow the programmer to isolate components, and thus reduce coupling. If you write to interfaces, you accomplish this, but with type information it’s possible to get around that— interfaces are not airtight guarantees of decoupling. Here’s an example, starting with an interface:</p>
<p>//: typeinfo/interfacea/A.java package typeinfo.interfacea;</p>
<p>public interface A { void f();</p>
<p>} ///:~</p>
<p>This interface is then implemented, and you can see how to sneak around to the actual implementation type:</p>
<p>//: typeinfo/InterfaceViolation.java // Sneaking around an interface. import typeinfo.interfacea.*;</p>
<p>class B implements A { public void f() {} public void g() {}</p>
<p>}</p>
<p>public class InterfaceViolation {</p>
<p>public static void main(String[] args) {</p>
<p>A a = new B();</p>
<p>a.f();</p>
<p>// a.g(); // Compile error System.out.println(a.getClass().getName()); if(a instanceof B) {</p>
<p>B b = (B)a;</p>
<p>b.g();</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>B</p>
<p>*///:~</p>
<p>Using RTTI, we discover that a has been implemented as a B. By casting to B, we can call a method that’s not in A.</p>
<p>This is perfectly legal and acceptable, but you may not want client programmers to do this, because it gives them an opportunity to couple more closely to your code than you’d like. That is, you may think that the interface keyword is protecting you, but it isn’t, and the fact that you’re using B to implement A in this case is effectively a matter of public record.<a l:href="#bookmark60" type="note"><sup>61</sup></a><sup></sup></p>
<p>One solution is to simply say that programmers are on their own if they decide to use the actual class rather than the interface. This is probably reasonable in many cases, but if &quot;probably&quot; isn’t enough, you might want to apply more stringent controls.</p>
<p>The easiest approach is to use package access for the implementation, so that clients outside the package may not see it:</p>
<p>//: typeinfo/packageaccess/HiddenC.java package typeinfo.packageaccess; import typeinfo.interfacea.*; import static net.mindview.util.Print.*;</p>
<p>class C implements A {</p>
<p>public void f() { print(&quot;public C.f()&quot;); } public void g() { print(&quot;public C.g()&quot;); } void u() { print(&quot;package C.u()&quot;); } protected void v() { print(&quot;protected C.v()&quot;); } private void w() { print(&quot;private C.w()&quot;); }</p>
<p>}</p>
<p>public class HiddenC {</p>
<p>public static A makeA() { return new C(); }</p>
<p>} ///:~</p>
<p>The only public part of this package, HiddenC, produces an A interface when you call it. What’s interesting about this is that even if you were to return a C from makeA( ), you still couldn’t use anything but an A from outside the package, since you cannot name C outside the package.</p>
<p>Now if you try to downcast to C, you can’t do it because there is no ‘C type available outside the package:</p>
<p>//: typeinfo/Hiddenlmplementation.java // Sneaking around package access. import typeinfo.interfacea.*; import typeinfo.packageaccess.*; import java.lang.reflect.*;</p>
<p>public class HiddenImplementation {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>A a = HiddenC.makeA(); a.f();</p>
<p>System.out.println(a.getClass().getName());</p>
<p>// Compile error: cannot find symbol ‘C’:</p>
<p>/* if(a instanceof C) {</p>
<p>C c = (C)a;</p>
<p>c.g();</p>
<p>} */</p>
<p>// Oops! Reflection still allows us to call g(): callHiddenMethod(a, &quot;g&quot;);</p>
<p>// And even methods that are less accessible! callHiddenMethod(a, &quot;u&quot;); callHiddenMethod(a, &quot;v&quot;); callHiddenMethod(a, &quot;w&quot;);</p>
<p>}</p>
<p>static void callHiddenMethod(Object a, String methodName) throws Exception {</p>
<p>Method g = a.getClass().getDeclaredMethod(methodName);</p>
<p>g.setAccessible(true);</p>
<p>g.invoke(a);</p>
<p>}</p>
<p>} /* Output: public C.f()</p>
<p>typeinfo.packageaccess.C public C.g() package C.u() protected C.v() private C.w()</p>
<p>*///:~</p>
<p>As you can see, it’s still possible to reach in and call all of the methods using reflection, even private methods! If you know the name of the method, you can call setAccessible(true) on the Method object to make it callable, as seen in callHiddenMethod( ).</p>
<p>You may think that you can prevent this by only distributing compiled code, but that’s no solution. All you must do is run javap, which is the decompiler that comes with the JDK. Here’s the command line:</p>
<p>javap -private C</p>
<p>The -private flag indicates that all members should be displayed, even private ones. Here’s the output:</p>
<p>class typeinfo.packageaccess.C extends java.lang.Object implements typeinfo.interfacea.A { typeinfo.packageaccess.C(); public void f( ); public void g( ); void u( );</p>
<p>protected void v( ); private void w();</p>
<p>}</p>
<p>So anyone can get the names and signatures of your most private methods, and call them.</p>
<p>What if you implement the interface as a private inner class? Here’s what it looks like:</p>
<p>//: typeinfo/InnerImplementation.java</p>
<p>// Private inner classes can’t hide from reflection.</p>
<p>import typeinfo.interfacea.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class InnerA {</p>
<p>private static class C implements A {</p>
<p>public void f() { print(&quot;public C.f()&quot;); } public void g() { print(&quot;public C.g()&quot;); } void u() { print(&quot;package C.u()&quot;); } protected void v() { print(&quot;protected C.v()&quot;); } private void w() { print(&quot;private C.w()&quot;); }</p>
<p>}</p>
<p>}</p>
<p>public class InnerImplementation {</p>
<p>public static void main(String[] args) throws Exception { A a = InnerA.makeA(); a.f();</p>
<p>System.out.println(a.getClass().getName());</p>
<p>// Reflection still gets into the private class: HiddenImplementation.callHiddenMethod(a, &quot;g&quot;); HiddenImplementation.callHiddenMethod(a, &quot;u&quot;); HiddenImplementation.callHiddenMethod(a, &quot;v&quot;); HiddenImplementation.callHiddenMethod(a, &quot;w&quot;);</p>
<p>}</p>
<p>} /* Output: public C.f()</p>
<p>InnerASC public C.g() package C.u() protected C.v() private C.w()</p>
<p>*///:~</p>
<p>That didn’t hide anything from reflection. What about an anonymous class?</p>
<p>//: typeinfo/AnonymousImplementation.java // Anonymous inner classes can’t hide from reflection. import typeinfo.interfacea.*; import static net.mindview.util.Print.*;</p>
<p>class AnonymousA {</p>
<p>public static A makeA() { return new A() {</p>
<p>public void f() { print(&quot;public C.f()&quot;); } public void g() { print(&quot;public C.g()&quot;); } void u() { print(&quot;package C.u()&quot;); } protected void v() { print(&quot;protected C.v()&quot;); } private void w() { print(&quot;private C.w()&quot;); }</p>
<p>};</p>
<p>}</p>
<p>}</p>
<p>public class AnonymousImplementation {</p>
<p>public static void main(String[] args) throws Exception { A a = AnonymousA.makeA(); a.f();</p>
<p>System.out.println(a.getClass().getName());</p>
<p>// Reflection still gets into the anonymous class: HiddenImplementation.callHiddenMethod(a, &quot;g&quot;); HiddenImplementation.callHiddenMethod(a, &quot;u&quot;); HiddenImplementation.callHiddenMethod(a, &quot;v&quot;); HiddenImplementation.callHiddenMethod(a, &quot;w&quot;);</p>
<p>}</p>
<p>} /* Output: public C.f()</p>
<p>AnonymousA$1 public C.g() package C.u() protected C.v() private C.w()</p>
<p>*///:~</p>
<p>There doesn’t seem to be any way to prevent reflection from reaching in and calling methods that have non-public access. This is also true for fields, even private fields:</p>
<p>//: typeinfo/ModifyingPrivateFields.java import java.lang.reflect.*;</p>
<p>class WithPrivateFinalField { private int i = 1;</p>
<p>private final String s = &quot;I’m totally safe&quot;; private String s2 = &quot;Am I safe?&quot;; public String toString() {</p>
<p>return &quot;i = &quot; + i + &quot;, &quot; + s + &quot;, &quot; + s2;</p>
<p>}</p>
<p>}</p>
<p>public class ModifyingPrivateFields {</p>
<p>public static void main(String[] args) throws Exception { WithPrivateFinalField pf = new WithPrivateFinalField(); System.out.println(pf);</p>
<p>Field f = pf.getClass().getDeclaredField(&quot;i&quot;); f.setAccessible(true);</p>
<p>System.out.println(&quot;f.getInt(pf): &quot; + f.getlnt(pf)); f.setInt(pf, 47);</p>
<p>System.out.println(pf);</p>
<p>f = pf.getClass().getDeclaredField(&quot;s&quot;);</p>
<p>f.setAccessible(true);</p>
<p>System.out.println(&quot;f.get(pf): &quot; + f.get(pf)); f.set(pf, &quot;No, you’re not!&quot;);</p>
<p>System.out.println(pf);</p>
<p>f = pf.getClass().getDeclaredField(&quot;s2&quot;); f.setAccessible(true);</p>
<p>System.out.println(&quot;f.get(pf): &quot; + f.get(pf)); f.set(pf, &quot;No, you’re not!&quot;);</p>
<p>System.out.println(pf);</p>
<p>}</p>
<p>} /* Output:</p>
<p>i = 1, I’m totally safe, Am I safe? f.getInt(pf): 1</p>
<p>i = 47, I’m totally safe, Am I safe? f.get(pf): I’m totally safe i = 47, I’m totally safe, Am I safe? f.get(pf): Am I safe?</p>
<p>i = 47, I’m totally safe, No, you’re not!</p>
<p>*///:~</p>
<p>However, final fields are actually safe from change. The runtime system accepts any attempts at change without complaint, but nothing actually happens.</p>
<p>In general, all these access violations are not the worst thing in the world. If someone uses such a technique to call methods that you marked with private or package access (thus clearly indicating they should not call them), then it’s difficult for them to complain if you change some aspect of those methods. On the other hand, the fact that you always have a back door into a class may allow you to solve certain types of problems that could otherwise be difficult or impossible, and the benefits of reflection in general are undeniable.</p>
<p>Exercise 25: (2) Create a class containing private, protected and package-access methods. Write code to access these methods from outside of the class’s package.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>RTTI allows you to discover type information from an anonymous base-class reference. Thus, it’s ripe for misuse by the novice, since it might make sense before polymorphic method calls do. For people coming from a procedural background, it’s difficult not to organize programs into sets of switch statements. You can accomplish this with RTTI and thus lose the important value of polymorphism in code development and maintenance. The intent of o o programming is to use polymorphic method calls everywhere you can, and RTTI only when you must.</p>
<p>However, using polymorphic method calls as they are intended requires that you have control of the base-class definition, because at some point in the extension of your program you might discover that the base class doesn’t include the method you need. if the base class comes from someone else’s library, one solution is RTTI: You can inherit a new type and add your extra method. Elsewhere in the code you can detect your particular type and call that special method. This doesn’t destroy the polymorphism and extensibility of the program, because adding a new type will not require you to hunt for switch statements in your program. However, when you add code that requires your new feature, you must use RTTI to detect your particular type.</p>
<p>Putting a feature in a base class might mean that, for the benefit of one particular class, all of the other classes derived from that base require some meaningless stub of a method. This makes the interface less clear and annoys those who must override abstract methods when they derive from that base class. For example, consider a class hierarchy representing musical instruments. Suppose you want to clear the spit valves of all the appropriate instruments in your orchestra. One option is to put a clearSpitValve( ) method in the base class Instrument, but this is confusing because it implies that Percussion, Stringed and Electronic instruments also have spit valves. RTTI provides a much more reasonable solution because you can place the method in the specific class where it’s appropriate (Wind, in this case). At the same time, you may discover that there’s a more sensible solution—here, a preparelnstrument( ) method in the base class. However, you might not see such a solution when you’re first solving the problem and could mistakenly assume that you must use RTTI.</p>
<p>Finally, RTTI will sometimes solve efficiency problems. Suppose your code nicely uses polymorphism, but it turns out that one of your objects reacts to this general-purpose code in a horribly inefficient way. You can pick out that type using RTTI and write case-specific code to improve the efficiency. Be wary, however, of programming for efficiency too soon. It’s a seductive trap. It’s best to get the program working/jrsf, then decide if it’s running fast enough, and only then should you attack efficiency issues—with a profiler (see the supplement at <a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a>).</p>
<p>We’ve also seen that reflection opens up a new world of programming possibilities by allowing a much more dynamic style of programming. There are some for whom the dynamic nature of reflection is disturbing. The fact that you can do things that can only be checked at run time and reported with exceptions seems, to a mind grown comfortable with the security of static type checking, to be the wrong direction. Some people go so far as to say that introducing the possibility of a runtime exception is a clear indicator that such code should be avoided. I find that this sense of security is an illusionthere are always things that can happen at run time and throw exceptions, even in a program that contains no try blocks or exception specifications. Instead, I think that the existence of a consistent error-reporting model empowers us to write dynamic code using reflection. Of course it’s worth trying to write code that can be statically checked ... when you can. But I believe that dynamic code is one of the important facilities that separate Java from languages like C++.</p>
<p>Exercise 26: (3) Implement clearSpitValve( ) as described in the summary.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Generics</p></title><empty-line/>
<p>Ordinary classes and methods work with specific types: either primitives or class types. If you are writing code that might be used across more types, this rigidity can be overconstraining.<sup>1</sup></p>
<p>One way that object-oriented languages allow generalization is through polymorphism. You can write (for example) a method that takes a base class object as an argument, and then use that method with any class derived from that base class. Now your method is a little more general and can be used in more places. The same is true within classes—anyplace you use a specific type, a base type provides more flexibility. Of course, anything but a final class<a l:href="#bookmark61" type="note"><sup>62</sup></a><sup> <a l:href="#bookmark62" type="note"><sup>63</sup></a></sup> can be extended, so this flexibility is automatic much of the time.</p>
<p>Sometimes, being constrained to a single hierarchy is too limiting. If a method argument is an interface instead of a class, the limitations are loosened to include anything that implements the interface—including classes that haven’t been created yet. This gives the client programmer the option of implementing an interface in order to conform to your class or method. So interfaces allow you to cut across class hierarchies, as long as you have the option to create a new class in order to do so.</p>
<p>Sometimes even an interface is too restrictive. An interface still requires that your code work with that particular interface. You could write even more general code if you could say that your code works with &quot;some unspecified type,&quot; rather than a specific interface or class.</p>
<p>This is the concept of generics, one of the more significant changes in Java SE5. Generics implement the concept of parameterized types, which allow multiple types. The term &quot;generic&quot; means &quot;pertaining or appropriate to large groups of classes.&quot; The original intent of generics in programming languages was to allow the programmer the greatest amount of expressiveness possible when writing classes or methods, by loosening the constraints on the types that those classes or methods work with. As you will see in this chapter, the Java implementation of generics is not that broad reaching—indeed, you may question whether the term &quot;generic&quot; is even appropriate for this feature.</p>
<p>If you’ve never seen any kind of parameterized type mechanism before, Java generics will probably seem like a convenient addition to the language. When you create an instance of a parameterized type, casts will be taken care of for you and the type correctness will be ensured at compile time. This seems like an improvement.</p>
<p>However, if you’ve had experience with a parameterized type mechanism, in C++, for example, you will find that you can’t do everything that you might expect when using Java generics. While using someone else’s generic type is fairly easy, when creating your own you will encounter a number of surprises. One of the things I shall try to explain is how the feature came to be like it is.</p>
<p>This is not to say that Java generics are useless. In many cases they make code more straightforward and even elegant. But if you’re coming from a language that has implemented a more pure version of generics, you may be disappointed. In this chapter, we will examine both the strengths and the limitations of Java generics so that you can use this new feature more effectively.</p>
<section>
<title>
<p>Comparison with C+ +</p></title><empty-line/>
<p>The Java designers stated that much of the inspiration for the language came as a reaction to C++. Despite this, it is possible to teach Java largely without reference to C++, and I have endeavored to do so except when the comparison will give you greater depth of understanding.</p>
<p>Generics require more comparison with C++ for two reasons. First, understanding certain aspects of C++ templates (the main inspiration for generics, including the basic syntax) will help you understand the foundations of the concept, as well as—and this is very important— the limitations of what you can do with Java generics and why. The ultimate goal is to give you a clear understanding of where the boundaries lie, because my experience is that by understanding the boundaries, you become a more powerful programmer. By knowing what you can’t do, you can make better use of what you can do (partly because you don’t waste time bumping up against walls).</p>
<p>The second reason is that there is significant misunderstanding in the Java community about C++ templates, and this misunderstanding may further confuse you about the intent of generics.</p>
<p>So although I will introduce a few C++ template examples in this chapter, I will keep them to a minimum.</p>
</section>
<section>
<title>
<p>Simple generics</p></title><empty-line/>
<p>One of the most compelling initial motivations for generics is to create container classes, which you saw in the Holding Your Objects chapter (you’ll learn more about these in the Containers in Depth chapter). A container is a place to hold objects while you’re working with them. Although this is also true of arrays, containers tend to be more flexible and have different characteristics than simple arrays. Virtually all programs require that you hold a group of objects while you use them, so containers are one of the most reusable of class libraries.</p>
<p>Let’s look at a class that holds a single object. Of course, the class could specify the exact type of the object, like this:</p>
<p>//: generics/Holder1.java</p>
<p>class Automobile {}</p>
<p>public class Holder1 { private Automobile a;</p>
<p>public Holder1(Automobile a) { this.a = a; }</p>
<p>Automobile get() { return a; }</p>
<p>} ///:~</p>
<p>But this is not a very reusable tool, since it can’t be used to hold anything else. We would prefer not to write a new one of these for every type we encounter.</p>
<p>Before Java SE5, we would simply make it hold an Object:</p>
<p>//: generics/Holder2.java</p>
<p>public class Holder2 { private Object a;</p>
<p>public Holder2(Object a) { this.a = a; }</p>
<p>public void set(Object a) { this.a = a; public Object get() { return a; } public static void main(String[] args) {</p>
<p>Holder2 h2 = new Holder2(new Automobile());</p>
<p>Automobile a = (Automobile)h2.get(); h2.set(&quot;Not an Automobile&quot;);</p>
<p>String s = (String)h2.get(); h2.set(1); // Autoboxes to Integer Integer x = (Integer)h2.get();</p>
<p>}</p>
<p>} ///:~</p>
<p>Now a Holder2 can hold anything—and in this example, a single Holder2 holds three different types of objects.</p>
<p>There are some cases where you want a container to hold multiple types of objects, but typically you only put one type of object into a container. One of the primary motivations for generics is to specify what type of object a container holds, and to have that specification backed up by the compiler.</p>
<p>So instead of Object, we’d like to use an unspecified type, which can be decided at a later time. To do this, you put a type parameter inside angle brackets after the class name, and then substitute an actual type when you use the class. For the &quot;holder&quot; class, it looks like this, where T is the type parameter:</p>
<p>//: generics/Holder3.java</p>
<p>public class Holder3&lt;T&gt; { private T a;</p>
<p>public Holder3(T a) { this.a = a; } public void set(T a) { this.a = a; } public T get() { return a; } public static void main(String[] args) {</p>
<p>Holder3&lt;Automobile&gt; h3 =</p>
<p>new Holder3&lt;Automobile&gt;(new Automobile());</p>
<p>Automobile a = h3.get(); // No cast needed // h3.set(&quot;Not an Automobile&quot;); // Error // h3.set(1); // Error</p>
<p>}</p>
<p>} ///:~</p>
<p>Now when you create a Holders, you must specify what type you want to put into it using the same angle-bracket syntax, as you can see in main( ). You are only allowed to put objects of that type (or a subtype, since the substitution principle still works with generics) into the holder. And when you get a value out, it is automatically the right type.</p>
<p>That’s the core idea of Java generics: You tell it what type you want to use, and it takes care of the details.</p>
<p>In general, you can treat generics as if they are any other type—they just happen to have type parameters. But as you’ll see, you can use generics just by naming them along with their type argument list.</p>
<p>Exercise 1: (1) Use Holders with the typeinfo.pets library to show that a Holders that is specified to hold a base type can also hold a derived type.</p>
<p>Exercise 2: (1) Create a holder class that holds three objects of the same type, along with the methods to store and fetch those objects and a constructor to initialize all three.</p>
<subtitle>A tuple library</subtitle>
<p>One of the things you often want to do is return multiple objects from a method call. The return statement only allows you to specify a single object, so the answer is to create an object that holds the multiple objects that you want to return. Of course, you can write a special class every time you encounter the situation, but with generics it’s possible to solve the problem once and save yourself the effort in the future. At the same time, you are ensuring compile-time type safety.</p>
<p>This concept is called a tuple, and it is simply a group of objects wrapped together into a single object. The recipient of the object is allowed to read the elements but not put new ones in. (This concept is also called a Data Transfer Object (or Messenger.)</p>
<p>Tuples can typically be any length, but each object in the tuple can be of a different type. However, we want to specify the type of each object and ensure that when the recipient reads the value, they get the right type. To deal with the problem of multiple lengths, we create multiple different tuples. Here’s one that holds two objects:</p>
<p>//: net/mindview/util/TwoTuple.java package net.mindview.util;</p>
<p>public class TwoTuple&lt;A,B&gt; { public final A first; public final B second;</p>
<p>public TwoTuple(A a, B b) { first = a; second = b; } public String toString() {</p>
<p>return &quot;(&quot; + first + &quot;, &quot; + second + &quot;)&quot;;</p>
<p>}</p>
<p>} ///:~</p>
<p>The constructor captures the object to be stored, and toString( ) is a convenience function to display the values in a list. Note that a tuple implicitly keeps its elements in order.</p>
<p>Upon first reading, you may think that this could violate common safety principles of Java programming. Shouldn’t first and second be private, and only accessed with methods named getFirst( ) and getSecond( )? Consider the safety that you would get in that case: Clients could still read the objects and do whatever they want with them, but they could not assign first or second to anything else. The final declaration buys you the same safety, but the above form is shorter and simpler.</p>
<p>Another design observation is that you might want to allow a client programmer to point first or second to another object. However, it’s safer to leave it in the above form, and just force the user to create a new TwoTuple if they want one that has different elements.</p>
<p>The longer-length tuples can be created with inheritance. You can see that adding more type parameters is a simple matter:</p>
<p>//: net/mindview/util/ThreeTuple.java package net.mindview.util;</p>
<p>public class ThreeTuple&lt;A,B,C&gt; extends TwoTuple&lt;A,B&gt; { public final C third; public ThreeTuple(A a, B b, C c) { super(a, b); third = c;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;(&quot; + first + &quot;, &quot; + second + &quot;, &quot; + third +&quot;)&quot;;</p>
<p>} ///:~</p>
<p>//: net/mindview/util/FourTuple.java package net.mindview.util;</p>
<p>public class FourTuple&lt;A,B,C,D&gt; extends ThreeTuple&lt;A,B,C&gt; { public final D fourth; public FourTuple(A a, B b, C c, D d) { super(a, b, c); fourth = d;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;(&quot; + first + &quot;, &quot; + second + &quot;, &quot; + third + &quot;, &quot; + fourth + &quot;)&quot;;</p>
<p>}</p>
<p>} ///:~</p>
<p>//: net/mindview/util/FiveTuple.java package net.mindview.util;</p>
<p>public class FiveTuple&lt;A,B,C,D,E&gt; extends FourTuple&lt;A,B,C,D&gt; { public final E fifth;</p>
<p>public FiveTuple(A a, B b, C c, D d, E e) { super(a, b, c, d); fifth = e;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;(&quot; + first + &quot;, &quot; + second + &quot;, &quot; + third + &quot;, &quot; + fourth + &quot;, &quot; + fifth + &quot;)&quot;;</p>
<p>}</p>
<p>} ///:~</p>
<p>To use a tuple, you simply define the appropriate-length tuple as the return value for your function, and then create and return it in your return statement:</p>
<p>//: generics/TupleTest.java import net.mindview.util.*;</p>
<p>class Amphibian {} class Vehicle {}</p>
<p>public class TupleTest {</p>
<p>static TwoTuple&lt;String,Integer&gt; f() {</p>
<p>// Autoboxing converts the int to Integer: return new TwoTuple&lt;String,Integer&gt;(&quot;hi&quot;, 47);</p>
<p>}</p>
<p>static ThreeTuple&lt;Amphibian,String,Integer&gt; g() { return new ThreeTuple&lt;Amphibian, String, Integer&gt;( new Amphibian(), &quot;hi&quot;, 47);</p>
<p>}</p>
<p>static</p>
<p>FourTuple&lt;Vehicle,Amphibian,String,Integer&gt; h() { return</p>
<p>new FourTuple&lt;Vehicle,Amphibian,String,Integer&gt;( new Vehicle(), new Amphibian(), &quot;hi&quot;, 47);</p>
<p>}</p>
<p>static</p>
<p>FiveTuple&lt;Vehicle,Amphibian,String,Integer,Double&gt; k() { return new</p>
<p>FiveTuple&lt;Vehicle,Amphibian,String,Integer,Double&gt;(</p>
<p>new Vehicle(), new Amphibian(), &quot;hi&quot;, 47, 11.1);</p>
<p>public static void main(String[] args) { TwoTuple&lt;String,Integer&gt; ttsi = f(); System.out.println(ttsi);</p>
<p>// ttsi.first = &quot;there&quot;; // Compile error: final System.out.println(g());</p>
<p>System.out.println(h());</p>
<p>System.out.println(k());</p>
<p>}</p>
<p>} /* Output: (80% match)</p>
<p>(hi, 47)</p>
<p>(Amphibian@1f6a7b9, hi, 47)</p>
<p>(Vehicle@35ce36, Amphibian@757aef, hi, 47) (Vehicle@9cab16, Amphibian@1a46e30, hi, 47, 11.1)</p>
<p>*///:~</p>
<p>Because of generics, you can easily create any tuple to return any group of types, just by writing the expression.</p>
<p>You can see how the final specification on the public fields prevents them from being reassigned after construction, in the failure of the statement ttsi.first = &quot;there&quot;.</p>
<p>The new expressions are a little verbose. Later in this chapter you’ll see how to simplify them using generic methods.</p>
<p>Exercise 3 : (1) Create and test a SixTuple generic.</p>
<p>Exercise 4: (3) &quot;Generify&quot; innerclasses/Sequence.java.</p>
<subtitle>A stack class</subtitle>
<p>Let’s look at something slightly more complicated: the traditional pushdown stack. In the Holding Your Objects chapter, you saw this implemented using a LinkedList as the net.mindview.util.Stack class (page 412). In that example, you can see that a LinkedList already has the necessary methods to create a stack. The Stack was constructed by composing one generic class (Stack&lt;T&gt;) with another generic class (LinkedList&lt;T&gt;). In that example, notice that (with a few exceptions that we shall look at later) a generic type is just another type.</p>
<p>Instead of using LinkedList, we can implement our own internal linked storage mechanism. //: generics/LinkedStack.java</p>
<p>// A stack implemented with an internal linked structure.</p>
<p>public class LinkedStack&lt;T&gt; { private static class Node&lt;U&gt; {</p>
<p>U item;</p>
<p>Node&lt;U&gt; next;</p>
<p>Node() { item = null; next = null; }</p>
<p>Node(U item, Node&lt;U&gt; next) { this.item = item; this.next = next;</p>
<p>}</p>
<p>boolean end() { return item == null &amp;&amp; next == null; }</p>
<p>}</p>
<p>private Node&lt;T&gt; top = new Node&lt;T&gt;(); // End sentinel public void push(T item) { top = new Node&lt;T&gt;(item, top);</p>
<p>public T pop() {</p>
<p>T result = top.item; if(!top.end()) top = top.next; return result;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>LinkedStack&lt;String&gt; Iss = new LinkedStack&lt;String&gt;(); for(String s : &quot;Phasers on stun!&quot;.split(&quot; &quot;)) lss.push(s);</p>
<p>String s;</p>
<p>while((s = lss.pop()) != null)</p>
<p>System.out.println(s);</p>
<p>}</p>
<p>} /* Output:</p>
<p>stun!</p>
<p>on</p>
<p>Phasers</p>
<p>*///:~</p>
<p>The inner class Node is also a generic, and has its own type parameter.</p>
<p>This example makes use of an end sentinel to determine when the stack is empty. The end sentinel is created when the LinkedStack is constructed, and each time you call push( ) a new Node&lt;T&gt; is created and linked to the previous Node&lt;T&gt;. When you call pop( ), you always return the top.item, and then you discard the current Node&lt;T&gt; and move to the next one— except when you hit the end sentinel, in which case you don’t move. That way, if the client keeps calling pop( ), they keep getting null back to indicate that the stack is empty.</p>
<p>Exercise 5: (2) Remove the type parameter on the Node class and modify the rest of the code in LinkedStack.java to show that an inner class has access to the generic type parameters of its outer class.</p>
<subtitle>RandomList</subtitle>
<p>For another example of a holder, suppose you’d like a special type of list that randomly selects one of its elements each time you call select( ). When doing this you want to build a tool that works with all objects, so you use generics:</p>
<p>//: generics/RandomList.java import java.util.*;</p>
<p>public class RandomList&lt;T&gt; {</p>
<p>private ArrayList&lt;T&gt; storage = new ArrayList&lt;T&gt;(); private Random rand = new Random(47); public void add(T item) { storage.add(item); } public T select() {</p>
<p>return storage.get(rand.nextInt(storage.size()));</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>RandomList&lt;String&gt; rs = new RandomList&lt;String&gt;(); for(String s: (&quot;The quick brown fox jumped over &quot; +</p>
<p>&quot;the lazy brown dog&quot;).split(&quot; &quot;)) rs.add(s);</p>
<p>for(int i = 0; i &lt; 11; i++)</p>
<p>System.out.print(rs.select() + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>brown over fox quick quick dog brown The brown lazy brown *///:~</p>
<p>Exercise 6: (1) Use RandomList with two more types in addition to the one shown in main( ).</p>
</section>
<section>
<title>
<p>Generic interfaces</p></title><empty-line/>
<p>Generics also work with interfaces. For example, a generator is a class that creates objects. It’s actually a specialization of the Factory Method design pattern, but when you ask a generator for new object, you don’t pass it any arguments, whereas you typically do pass arguments to a Factory Method. The generator knows how to create new objects without any extra information.</p>
<p>Typically, a generator just defines one method, the method that produces new objects. Here, we’ll call it next( ), and include it in the standard utilities:</p>
<p>//: net/mindview/util/Generator.java // A generic interface. package net.mindview.util;</p>
<p>public interface Generator&lt;T&gt; { T next(); } ///:~</p>
<p>The return type of next( ) is parameterized to T. As you can see, using generics with interfaces is no different than using generics with classes.</p>
<p>To demonstrate the implementation of a Generator, we’ll need some classes. Here’s a coffee hierarchy:</p>
<p>//: generics/coffee/Coffee.java package generics.coffee;</p>
<p>public class Coffee {</p>
<p>private static long counter = 0; private final long id = counter++; public String toString() {</p>
<p>return getClass().getSimpleName() + &quot; &quot; + id;</p>
<p>}</p>
<p>} ///:~</p>
<p>//: generics/coffee/Latte.java package generics.coffee;</p>
<p>public class Latte extends Coffee {} ///:~</p>
<p>//: generics/coffee/Mocha.java package generics.coffee;</p>
<p>public class Mocha extends Coffee {} ///:~</p>
<p>//: generics/coffee/Cappuccino.java package generics.coffee;</p>
<p>public class Cappuccino extends Coffee {} ///:~</p>
<p>//: generics/coffee/Americano.java package generics.coffee;</p>
<p>public class Americano extends Coffee {} ///:~</p>
<p>//: generics/coffee/Breve.java package generics.coffee;</p>
<p>public class Breve extends Coffee {} ///:~</p>
<p>Now we can implement a Generator &lt; Coffee &gt; that produces random different types of Coffee objects:</p>
<p>//: generics/coffee/CoffeeGenerator.java // Generate different types of Coffee: package generics.coffee; import java.util.*; import net.mindview.util.*;</p>
<p>public class CoffeeGenerator</p>
<p>implements Generator&lt;Coffee&gt;, Iterable&lt;Coffee&gt; { private Class[] types = { Latte.class, Mocha.class,</p>
<p>Cappuccino.class, Americano.class, Breve.class, }; private static Random rand = new Random(47); public CoffeeGenerator() {}</p>
<p>// For iteration: private int size = 0;</p>
<p>public CoffeeGenerator(int sz) { size = sz; } public Coffee next() { try {</p>
<p>return (Coffee)</p>
<p>types[rand.nextInt(types.length)].newInstance();</p>
<p>// Report programmer errors at run time:</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>class CoffeeIterator implements Iterator&lt;Coffee&gt; { int count = size;</p>
<p>public boolean hasNext() { return count &gt; 0; } public Coffee next() { count--;</p>
<p>return CoffeeGenerator.this.next();</p>
<p>}</p>
<p>public void remove() { // Not implemented throw new UnsupportedOperationException();</p>
<p>}</p>
<p>};</p>
<p>public Iterator&lt;Coffee&gt; iterator() { return new CoffeeIterator();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>CoffeeGenerator gen = new CoffeeGenerator(); for(int i = 0; i &lt; 5; i++)</p>
<p>System.out.println(gen.next()); for(Coffee c : new CoffeeGenerator(5))</p>
<p>System.out.println(c);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Americano 0 Latte 1 Americano 2 Mocha 3 Mocha 4 Breve 5 Americano 6 Latte 7 Cappuccino 8 Cappuccino 9 *///:~</p>
<p>The parameterized Generator interface ensures that next( ) returns the parameter type. CoffeeGenerator also implements the Iterable interface, so it can be used in a foreach statement. However, it requires an &quot;end sentinel&quot; to know when to stop, and this is produced using the second constructor.</p>
<p>Here’s a second implementation of Generator&lt;T&gt;, this time to produce Fibonacci numbers:</p>
<p>//: generics/Fibonacci.java // Generate a Fibonacci sequence. import net.mindview.util.*;</p>
<p>public class Fibonacci implements Generator&lt;Integer&gt; { private int count = 0;</p>
<p>public Integer next() { return fib(count++); } private int fib(int n) { if(n &lt; 2) return 1; return fib(n-2) + fib(n-1);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Fibonacci gen = new Fibonacci(); for(int i = 0; i &lt; 18; i++)</p>
<p>System.out.print(gen.next() + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 *///:~</p>
<p>Although we are working with ints both inside and outside the class, the type parameter is Integer. This brings up one of the limitations of Java generics: You cannot use primitives as type parameters. However, Java SE5 conveniently added autoboxing and autounboxing to convert from primitive types to wrapper types and back. You can see the effect here because ints are seamlessly used and produced by the class.</p>
<p>We can go one step further and make an Iterable Fibonacci generator. One option is to reimplement the class and add the Iterable interface, but you don’t always have control of the original code, and you don’t want to rewrite when you don’t have to. Instead, we can create an adapter to produce the desired interface—this design pattern was introduced earlier in the book.</p>
<p>Adapters can be implemented in multiple ways. For example, you could use inheritance to generate the adapted class:</p>
<p>//: generics/IterableFibonacci.java</p>
<p>// Adapt the Fibonacci class to make it Iterable.</p>
<p>import java.util.*;</p>
<p>public class IterableFibonacci</p>
<p>extends Fibonacci implements Iterable&lt;Integer&gt; { private int n;</p>
<p>public IterableFibonacci(int count) { n = count; } public Iterator&lt;Integer&gt; iterator() { return new Iterator&lt;Integer&gt;() {</p>
<p>public boolean hasNext() { return n &gt; 0; } public Integer next() { n--;</p>
<p>return IterableFibonacci.this.next();</p>
<p>}</p>
<p>public void remove() { // Not implemented throw new UnsupportedOperationException();</p>
<p>};</p>
<p>public static void main(String[] args) { for(int i : new IterableFibonacci(18)) System.out.print(i + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 *///:~</p>
<p>To use IterableFibonacci in a foreach statement, you give the constructor a boundary so that hasNext( ) can know when to return false.</p>
<p>Exercise 7: (2) Use composition instead of inheritance to adapt Fibonacci to make it Iterable.</p>
<p>Exercise 8: (2) Following the form of the Coffee example, create a hierarchy of StoryCharacters from your favorite movie, dividing them into GoodGuys and BadGuys. Create a generator for StoryCharacters, following the form of CoffeeGenerator.</p>
</section>
<section>
<title>
<p>Generic methods</p></title><empty-line/>
<p>So far we’ve looked at parameterizing entire classes. You can also parameterize methods within a class. The class itself may or may not be generic—this is independent of whether you have a generic method.</p>
<p>A generic method allows the method to vary independently of the class. As a guideline, you should use generic methods &quot;whenever you can.&quot; That is, if it’s possible to make a method generic rather than the entire class, it’s probably going to be clearer to do so. In addition, if a method is static, it has no access to the generic type parameters of the class, so if it needs to use genericity it must be a generic method.</p>
<p>To define a generic method, you simply place a generic parameter list before the return value, like this:</p>
<p>//: generics/GenericMethods.java</p>
<p>public class GenericMethods {</p>
<p>public &lt;T&gt; void f(T x) {</p>
<p>System.out.println(x.getClass().getName());</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>GenericMethods gm = new GenericMethods();</p>
<p>gm.f(&quot;&quot;);</p>
<p>gm.f(1);</p>
<p>gm.f(1.0);</p>
<p>gm.f(1.0F);</p>
<p>gm.f(‘c&apos;);</p>
<p>gm.f(gm);</p>
<p>}</p>
<p>} /* Output:</p>
<p>java.lang.String</p>
<p>java.lang.Integer</p>
<p>java.lang.Double</p>
<p>java.lang.Float</p>
<p>java.lang.Character</p>
<p>GenericMethods</p>
<p>The class GenericMethods is not parameterized, although both a class and its methods may be parameterized at the same time. But in this case, only the method f( ) has a type parameter, indicated by the parameter list before the method’s return type.</p>
<p>Notice that with a generic class, you must specify the type parameters when you instantiate the class. But with a generic method, you don’t usually have to specify the parameter types, because the compiler can figure that out for you. This is called type argument inference. So calls to f( ) look like normal method calls, and it appears that f( ) has been infinitely overloaded. It will even take an argument of the type GenericMethods.</p>
<p>For the calls to f( ) that use primitive types, autoboxing comes into play, automatically wrapping the primitive types in their associated objects. In fact, generic methods and autoboxing can eliminate some code that previously required hand conversion.</p>
<p>Exercise 9: (1) Modify GenericMethods.java so that f( ) accepts three arguments, all of which are of a different parameterized type.</p>
<p>Exercise 10: (1) Modify the previous exercise so that one of f( )’s arguments is nonparameterized.</p>
<subtitle>Leveraging type argument inference</subtitle>
<p>One of the complaints about generics is that it adds even more text to your code. Consider holding/MapOfList.java from the Holding Your Objects chapter. The creation of the Map of List looks like this:</p>
<p>Map&lt;Person, List&lt;? extends Pet&gt;&gt; petPeople = new HashMap&lt;Person, List&lt;? extends Pet&gt;&gt;();</p>
<p>(This use of extends and the question marks will be explained later in this chapter.) It appears that you are repeating yourself, and that the compiler should figure out one of the generic argument lists from the other. Alas, it cannot, but type argument inference in a generic method can produce some simplification. For example, we can create a utility containing various static methods, which produces the most commonly used implementations of the various containers:</p>
<p>//: net/mindview/util/New.java</p>
<p>// Utilities to simplify generic container creation // by using type argument inference. package net.mindview.util; import java.util.*;</p>
<p>public class New {</p>
<p>public static &lt;K,V&gt; Map&lt;K,V&gt; map() { return new HashMap&lt;K,V&gt;();</p>
<p>}</p>
<p>public static &lt;T&gt; List&lt;T&gt; list() { return new ArrayList&lt;T&gt;();</p>
<p>}</p>
<p>public static &lt;T&gt; LinkedList&lt;T&gt; lList() { return new LinkedList&lt;T&gt;();</p>
<p>}</p>
<p>public static &lt;T&gt; Set&lt;T&gt; set() { return new HashSet&lt;T&gt;();</p>
<p>}</p>
<p>public static &lt;T&gt; Queue&lt;T&gt; queue() {</p>
<p>return new LinkedList&lt;T&gt;();</p>
<p>// Examples:</p>
<p>public static void main(String[] args) {</p>
<p>Map&lt;String, List&lt;String&gt;&gt; sls = New.map();</p>
<p>List&lt;String&gt; Is = New.list();</p>
<p>LinkedList&lt;String&gt; lls = New.lList();</p>
<p>Set&lt;String&gt; ss = New.set();</p>
<p>Queue&lt;String&gt; qs = New.queue();</p>
<p>}</p>
<p>} ///:~</p>
<p>In main( ) you can see examples of how this is used-type argument inference eliminates the need to repeat the generic parameter list. This can be applied to holding/MapOfList.java:</p>
<p>//: generics/SimplerPets.java import typeinfo.pets.*; import java.util.*; import net.mindview.util.*;</p>
<p>public class SimplerPets {</p>
<p>public static void main(String[] args) {</p>
<p>Map&lt;Person, List&lt;? extends Pet&gt;&gt; petPeople = New.map();</p>
<p>// Rest of the code is the same...</p>
<p>}</p>
<p>} ///:~</p>
<p>Although this is an interesting example of type argument inference, it’s difficult to say how much it actually buys you. The person reading the code is required to parse and understand this additional library and its implications, so it might be just as productive to leave the original (admittedly repetitious) definition in place-ironically, for simplicity. However, if the standard Java library were to add something like the New.java utility above, it would make sense to use it.</p>
<p>Type inference doesn’t work for anything other than assignment. If you pass the result of a method call such as New.map( ) as an argument to another method, the compiler will not try to perform type inference. Instead it will treat the method call as though the return value is assigned to a variable of type Object. Here’s an example that fails:</p>
<p>//: generics/LimitsOfInference.java import typeinfo.pets.*; import java.util.*;</p>
<p>public class LimitsOfInference { static void</p>
<p>f(Map&lt;Person, List&lt;? extends Pet&gt;&gt; petPeople) {} public static void main(String[] args) {</p>
<p>// f(New.map()); // Does not compile</p>
<p>}</p>
<p>} ///:~</p>
<p>Exercise 11: (1) Test New.java by creating your own classes and ensuring that New will work properly with them.</p>
<p>Explicit type specification</p>
<p>It is possible to explicitly specify the type in a generic method, although the syntax is rarely needed. To do so, you place the type in angle brackets after the dot and immediately preceding the method name. When calling a method from within the same class, you must use this before the dot, and when working with static methods, you must use the class name before the dot. The problem shown in LimitsOflnference.java can be solved using this syntax:</p>
<p>//: generics/ExplicitTypeSpecification.java import typeinfo.pets.*; import java.util.*; import net.mindview.util.*;</p>
<p>public class ExplicitTypeSpecification {</p>
<p>static void f(Map&lt;Person, List&lt;Pet&gt;&gt; petPeople) {} public static void main(String[] args) { f(New.&lt;Person, List&lt;Pet&gt;&gt;map());</p>
<p>}</p>
<p>} ///:~</p>
<p>Of course, this eliminates the benefit of using the New class to reduce the amount of typing, but the extra syntax is only required when you are not writing an assignment statement.</p>
<p>Exercise 12: (1) Repeat the previous exercise using explicit type specification.</p>
<subtitle>Varargs and generic methods</subtitle>
<p>Generic methods and variable argument lists coexist nicely:</p>
<p>//: generics/GenericVarargs.java import java.util.*;</p>
<p>public class GenericVarargs {</p>
<p>public static &lt;T&gt; List&lt;T&gt; makeList(T... args) {</p>
<p>List&lt;T&gt; result = new ArrayList&lt;T&gt;(); for(T item : args) result.add(item); return result;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;String&gt; ls = makeList(&quot;A&quot;);</p>
<p>System.out.println(ls);</p>
<p>ls = makeList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</p>
<p>System.out.println(ls);</p>
<p>ls = makeList(&quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ&quot;.split(&quot;&quot;)); System.out.println(ls);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[A]</p>
<p>[A, B, C]</p>
<p>[, A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]</p>
<p>*///:~</p>
<p>The makeList( ) method shown here produces the same functionality as the standard library’s java.util.Arrays.asList( ) method.</p>
<subtitle>A generic method to use with Generators</subtitle>
<p>It is convenient to use a generator to fill a Collection, and it makes sense to &quot;generify&quot; this operation:</p>
<p>//: generics/Generators.java</p>
<p>// A utility to use with Generators.</p>
<p>import generics.coffee.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>public class Generators {</p>
<p>public static &lt;T&gt; Collection&lt;T&gt;</p>
<p>fill(Collection&lt;T&gt; coll, Generator&lt;T&gt; gen, int n) { for(int i = 0; i &lt; n; i++) coll.add(gen.next()); return coll;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Collection&lt;Coffee&gt; coffee = fill(</p>
<p>new ArrayList&lt;Coffee&gt;(), new CoffeeGenerator(), 4); for(Coffee c : coffee)</p>
<p>System.out.println(c);</p>
<p>Collection&lt;Integer&gt; fnumbers = fill(</p>
<p>new ArrayList&lt;Integer&gt;(), new Fibonacci(), 12); for(int i : fnumbers)</p>
<p>System.out.print(i + &quot;, &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Americano 0 Latte 1 Americano 2 Mocha 3</p>
<p>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,</p>
<p>*///:~</p>
<p>Notice how the generic method fill( ) can be transparently applied to both Coffee and Integer containers and generators.</p>
<p>Exercise 13: (4) Overload the fill( ) method so that the arguments and return types are the specific subtypes of Collection: List, Queue and Set. This way, you don’t lose the type of container. Can you overload to distinguish between List and LinkedList?</p>
<subtitle>A general-purpose Generator</subtitle>
<p>Here’s a class that produces a Generator for any class that has a default constructor. To reduce typing, it also includes a generic method to produce a BasicGenerator:</p>
<p>//: net/mindview/util/BasicGenerator.java // Automatically create a Generator, given a class // with a default (no-arg) constructor. package net.mindview.util;</p>
<p>public class BasicGenerator&lt;T&gt; implements Generator&lt;T&gt; { private Class&lt;T&gt; type;</p>
<p>public BasicGenerator(Class&lt;T&gt; type){ this.type = type; } public T next() {</p>
<p>try {</p>
<p>// Assumes type is a public class: return type.newInstance();</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>// Produce a Default generator given a type token: public static &lt;T&gt; Generator&lt;T&gt; create(Class&lt;T&gt; type) { return new BasicGenerator&lt;T&gt;(type);</p>
<p>}</p>
<p>} ///:~</p>
<p>This class provides a basic implementation that will produce objects of a class that (1) is public (because BasicGenerator is in a separate package, the class in question must have public and not just package access) and (2) has a default constructor (one that takes no arguments). To create one of these BasicGenerator objects, you call the create( ) method and pass it the type token for the type you want generated. The generic create( ) method allows you to say BasicGenerator.create(MyType.class) instead of the more awkward new BasicGenerator&lt;MyType&gt;(MyType.class).</p>
<p>For example, here’s a simple class that has a default constructor:</p>
<p>//: generics/CountedObject.java</p>
<p>public class CountedObject {</p>
<p>private static long counter = 0; private final long id = counter++; public long id() { return id; }</p>
<p>public String toString() { return &quot;CountedObject &quot; + id;}</p>
<p>} ///:~</p>
<p>The CountedObject class keeps track of how many instances of itself have been created, and reports these in its toString( ).</p>
<p>Using BasicGenerator, you can easily create a Generator for CountedObject:</p>
<p>//: generics/BasicGeneratorDemo.java import net.mindview.util.*;</p>
<p>public class BasicGeneratorDemo {</p>
<p>public static void main(String[] args) {</p>
<p>Generator&lt;CountedObject&gt; gen =</p>
<p>BasicGenerator.create(CountedObject.class); for(int i = 0; i &lt; 5; i++)</p>
<p>System.out.println(gen.next());</p>
<p>}</p>
<p>} /* Output:</p>
<p>CountedObject 0 CountedObject 1 CountedObject 2 CountedObject 3 CountedObject 4 *///:~</p>
<p>You can see how the generic method reduces the amount of typing necessary to produce the Generator object. Java generics force you to pass in the Class object anyway, so you might as well use it for type inference in the create( ) method.</p>
<p>Exercise 14: (1) Modify BasicGeneratorDemo.java to use the explicit form of creation for the Generator (that is, use the explicit constructor instead of the generic create( ) method).</p>
<subtitle>Simplifying tuple use</subtitle>
<p>Type argument inference, together with static imports, allows the tuples we saw earlier to be rewritten into a more general-purpose library. Here, tuples can be created using an overloaded static method:</p>
<p>//: net/mindview/util/Tuple.java</p>
<p>// Tuple library using type argument inference.</p>
<p>package net.mindview.util;</p>
<p>public class Tuple {</p>
<p>public static &lt;A,B&gt; TwoTuple&lt;A,B&gt; tuple(A a, B b) { return new TwoTuple&lt;A,B&gt;(a, b);</p>
<p>}</p>
<p>public static &lt;A,B,C&gt; ThreeTuple&lt;A,B,C&gt; tuple(A a, B b, C c) {</p>
<p>return new ThreeTuple&lt;A,B,C&gt;(a, b, c);</p>
<p>}</p>
<p>public static &lt;A,B,C,D&gt; FourTuple&lt;A,B,C,D&gt; tuple(A a, B b, C c, D d) {</p>
<p>return new FourTuple&lt;A,B,C,D&gt;(a, b, c, d);</p>
<p>}</p>
<p>public static &lt;A,B,C,D,E&gt;</p>
<p>FiveTuple&lt;A,B,C,D,E&gt; tuple(A a, B b, C c, D d, E e) { return new FiveTuple&lt;A,B,C,D,E&gt;(a, b, c, d, e);</p>
<p>}</p>
<p>} ///:~</p>
<p>Here’s a modification of TupleTest.java to test Tuple.java:</p>
<p>//: generics/TupleTest2.java</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Tuple.*;</p>
<p>public class TupleTest2 {</p>
<p>static TwoTuple&lt;String,Integer&gt; f() { return tuple(&quot;hi&quot;, 47);</p>
<p>}</p>
<p>static TwoTuple f2() { return tuple(&quot;hi&quot;, 47); } static ThreeTuple&lt;Amphibian,String,Integer&gt; g() { return tuple(new Amphibian(), &quot;hi&quot;, 47);</p>
<p>}</p>
<p>static</p>
<p>FourTuple&lt;Vehicle,Amphibian,String,Integer&gt; h() {</p>
<p>return tuple(new Vehicle(), new Amphibian(), &quot;hi&quot;, 47);</p>
<p>}</p>
<p>static</p>
<p>FiveTuple&lt;Vehicle,Amphibian,String,Integer,Double&gt; k() { return tuple(new Vehicle(), new Amphibian(),</p>
<p>&quot;hi&quot;, 47, 11.1);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>TwoTuple&lt;String,Integer&gt; ttsi = f();</p>
<p>System.out.println(ttsi);</p>
<p>System.out.println(f2());</p>
<p>System.out.println(g());</p>
<p>System.out.println(h());</p>
<p>System.out.println(k());</p>
<p>} /* Output: (80% match)</p>
<p>(hi, 47)</p>
<p>(hi, 47)</p>
<p>(Amphibian@7d772e, hi, 47)</p>
<p>(Vehicle@757aef, Amphibian@d9f9c3, hi, 47) (Vehicle@1a46e30, Amphibian@3e25a5, hi, 47, 11.1) *///:~</p>
<p>Notice that f( ) returns a parameterized TwoTuple object, while f2( ) returns an unparameterized TwoTuple object. The compiler doesn’t warn about f2( ) in this case because the return value is not being used in a parameterized fashion; in a sense, it is being &quot;upcast&quot; to an unparameterized TwoTuple. However, if you were to try to capture the result of f2( ) into a parameterized TwoTuple, the compiler would issue a warning.</p>
<p>Exercise 15: (1) Verify the previous statement.</p>
<p>Exercise 16: (2) Add a SixTuple to Tuple.java, and test it in TupleTest2 .j ava.</p>
<subtitle>A Set utility</subtitle>
<p>For another example of the use of generic methods, consider the mathematical relationships that can be expressed using Sets. These can be conveniently defined as generic methods, to be used with all different types:</p>
<p>//: net/mindview/util/Sets.java package net.mindview.util; import java.util.*;</p>
<p>public class Sets {</p>
<p>public static &lt;T&gt; Set&lt;T&gt; union(Set&lt;T&gt; a, Set&lt;T&gt; b) {</p>
<p>Set&lt;T&gt; result = new HashSet&lt;T&gt;(a);</p>
<p>result.addAll(b);</p>
<p>return result;</p>
<p>}</p>
<p>public static &lt;T&gt;</p>
<p>Set&lt;T&gt; intersection(Set&lt;T&gt; a, Set&lt;T&gt; b) {</p>
<p>Set&lt;T&gt; result = new HashSet&lt;T&gt;(a);</p>
<p>result.retainAll(b);</p>
<p>return result;</p>
<p>}</p>
<p>// Subtract subset from superset:</p>
<p>public static &lt;T&gt; Set&lt;T&gt;</p>
<p>difference(Set&lt;T&gt; superset, Set&lt;T&gt; subset) {</p>
<p>Set&lt;T&gt; result = new HashSet&lt;T&gt;(superset);</p>
<p>result.removeAll(subset);</p>
<p>return result;</p>
<p>}</p>
<p>// Reflexive--everything not in the intersection:</p>
<p>public static &lt;T&gt; Set&lt;T&gt; complement(Set&lt;T&gt; a, Set&lt;T&gt; b) { return difference(union(a, b), intersection(a, b));</p>
<p>}</p>
<p>} ///:~</p>
<p>The first three methods duplicate the first argument by copying its references into a new HashSet object, so the argument Sets are not directly modified. The return value is thus a new Set object.</p>
<p>The four methods represent mathematical set operations: union( ) returns a Set containing the combination of the two arguments, intersection( ) returns a Set containing the common elements between the two arguments, difference( ) performs a subtraction of the subset elements from the superset, and complement( ) returns a Set of all the elements that are not in the intersection. To create a simple example showing the effects of these methods, here’s an enum containing different names of watercolors: //: generics/watercolors/Watercolors.java package generics.watercolors;</p>
<p>public enum Watercolors {</p>
<p>ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW, ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER, BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK } ///:~</p>
<p>For convenience (so that all the names don’t have to be qualified), this is imported statically into the following example. This example uses the EnumSet, which is a Java SE5 tool for easy creation of Sets from enums. (You’ll learn more about EnumSet in the Enumerated Types chapter.) Here, the static method EnumSet.range( ) is given the first and last elements of the range to create in the resulting Set: //: generics/WatercolorSets.java import generics.watercolors.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>import static net.mindview.util.Sets.*;</p>
<p>import static generics.watercolors.Watercolors.*;</p>
<p>public class WatercolorSets {</p>
<p>public static void main(String[] args) { Set&lt;Watercolors&gt; setl =</p>
<p>EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE); Set&lt;Watercolors&gt; set2 =</p>
<p>EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER); print(&quot;set1: &quot; + setl); print(&quot;set2: &quot; + set2);</p>
<p>print(&quot;union(set1, set2): &quot; + union(set1, set2)); Set&lt;Watercolors&gt; subset = intersection(set1, set2);</p>
<p>print(&quot;intersection(set1, set2) print(&quot;difference(set1, subset) difference(set1, subset)); print(&quot;difference(set2, subset) difference(set2, subset)); print(&quot;complement(set1, set2): complement(set1, set2));</p>
<p>+ subset); +</p>
<p>+</p>
<p>+</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]</p>
<p>set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER, BURNT_UMBER]</p>
<p>union(set1, set2): [SAP_GREEN, ROSE_MADDER, YELLOW_OCHRE, PERMANENT_GREEN, BURNT_UMBER, COBALT_BLUE_HUE, VIOLET, BRILLIANT_RED, RAW_UMBER, ULTRAMARINE, BURNT_SIENNA, CRIMSON, CERULEAN_BLUE_HUE, PHTHALO_BLUE, MAGENTA, VIRIDIAN_HUE] intersection(set1, set2): [ULTRAMARINE, PERMANENT_GREEN, COBALT_BLUE_HUE, PHTHALO_BLUE, CERULEAN_BLUE_HUE, VIRIDIAN_HUE] difference(set1, subset): [ROSE_MADDER, CRIMSON, VIOLET, MAGENTA, BRILLIANT_RED]</p>
<p>difference(set2, subset): [RAW_UMBER, SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, BURNT_UMBER]</p>
<p>complement(set1, set2): [SAP_GREEN, ROSE_MADDER, YELLOW_OCHRE, BURNT_UMBER, VIOLET, BRILLIANT_RED, RAW_UMBER, BURNT_SIENNA, CRIMSON, MAGENTA]</p>
<p>*///:~</p>
<p>You can see the results of each operation from the output. The following example uses Sets.difference( ) to show the method differences between various Collection and Map classes in java.util:</p>
<p>//: net/mindview/util/ContainerMethodDifferences.java package net.mindview.util; import java.lang.reflect.*; import java.util.*;</p>
<p>public class ContainerMethodDifferences {</p>
<p>static Set&lt;String&gt; methodSet(Class&lt;?&gt; type) {</p>
<p>Set&lt;String&gt; result = new TreeSet&lt;String&gt;(); for(Method m : type.getMethods()) result.add(m.getName()); return result;</p>
<p>}</p>
<p>static void interfaces(Class&lt;?&gt; type) {</p>
<p>System.out.print(&quot;Interfaces in &quot; + type.getSimpleName() + &quot;: &quot;);</p>
<p>List&lt;String&gt; result = new ArrayList&lt;String&gt;(); for(Class&lt;?&gt; c : type.getInterfaces()) result.add(c.getSimpleName());</p>
<p>System.out.println(result);</p>
<p>}</p>
<p>static Set&lt;String&gt; object = methodSet(Object.class);</p>
<p>static { object.add(&quot;clone&quot;); }</p>
<p>static void</p>
<p>difference(Class&lt;?&gt; superset, Class&lt;?&gt; subset) { System.out.print(superset.getSimpleName() +</p>
<p>&quot; extends &quot; + subset.getSimpleName() + &quot;, adds: &quot;);</p>
<p>Set&lt;String&gt; comp = Sets.difference(</p>
<p>methodSet(superset), methodSet(subset)); comp.removeAll(object); // Don’t show ‘Object’ methods System.out.println(comp); interfaces(superset);</p>
<p>}</p>
<p>public static void main(String[] args) { System.out.println(&quot;Collection: &quot; + methodSet(Collection.class)); interfaces(Collection.class); difference(Set.class, Collection.class); difference(HashSet.class, Set.class); difference(LinkedHashSet.class, HashSet.class); difference(TreeSet.class, Set.class); difference(List.class, Collection.class); difference(ArrayList.class, List.class); difference(LinkedList.class, List.class); difference(Queue.class, Collection.class); difference(PriorityQueue.class, Queue.class); System.out.println(&quot;Map: &quot; + methodSet(Map.class)); difference(HashMap.class, Map.class);</p>
<p>difference(LinkedHashMap.class, HashMap.class); difference(SortedMap.class, Map.class); difference(TreeMap.class, Map.class);</p>
<p>} ///:~</p>
<p>The output of this program was used in the &quot;Summary&quot; section of the Holding Your Objects chapter.</p>
<p>Exercise 17: (4) Study the JDK documentation for EnumSet. You’ll see that there’s a clone( ) method defined. However, you cannot clone( ) from the reference to the Set interface passed in Sets.java. Can you modify Sets.java to handle both the general case of a Set interface as shown, and the special case of an EnumSet, using clone( ) instead of creating a new HashSet?</p>
</section>
<section>
<title>
<p>Anonymous inner classes</p></title><empty-line/>
<p>Generics can also be used with inner classes and anonymous inner classes. Here’s an example that implements the Generator interface using anonymous inner classes:</p>
<p>//: generics/BankTeller.java</p>
<p>// A very simple bank teller simulation.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>class Customer {</p>
<p>private static long counter = 1; private final long id = counter++; private Customer() {}</p>
<p>public String toString() { return &quot;Customer &quot; + id; }</p>
<p>// A method to produce Generator objects: public static Generator&lt;Customer&gt; generator() { return new Generator&lt;Customer&gt;() {</p>
<p>public Customer next() { return new Customer(); }</p>
<p>};</p>
<p>}</p>
<p>}</p>
<p>class Teller {</p>
<p>private static long counter = 1; private final long id = counter++; private Teller() {}</p>
<p>public String toString() { return &quot;Teller &quot; + id; }</p>
<p>// A single Generator object: public static Generator&lt;Teller&gt; generator = new Generator&lt;Teller&gt;() {</p>
<p>public Teller next() { return new Teller(); }</p>
<p>};</p>
<p>}</p>
<p>public class BankTeller {</p>
<p>public static void serve(Teller t, Customer c) {</p>
<p>System.out.println(t + &quot; serves &quot; + c);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47);</p>
<p>Queue&lt;Customer&gt; line = new LinkedList&lt;Customer&gt;(); Generators.fill(line, Customer.generator(), 15);</p>
<p>List&lt;Teller&gt; tellers = new ArrayList&lt;Teller&gt;(); Generators.fill(tellers, Teller.generator, 4);</p>
<p>for(Customer c : line)</p>
<p>serve(tellers.get(rand.nextInt(tellers.size())), c);</p>
<table>
<tr><td colspan="3">} /* Output:</td><td></td><td></td></tr>
<tr><td>Teller</td><td>3</td><td>serves</td><td>Customer</td><td>1</td></tr>
<tr><td>Teller</td><td>2</td><td>serves</td><td>Customer</td><td>2</td></tr>
<tr><td>Teller</td><td>3</td><td>serves</td><td>Customer</td><td>3</td></tr>
<tr><td>Teller</td><td>1</td><td>serves</td><td>Customer</td><td>4</td></tr>
<tr><td>Teller</td><td>1</td><td>serves</td><td>Customer</td><td>5</td></tr>
<tr><td>Teller</td><td>3</td><td>serves</td><td>Customer</td><td>6</td></tr>
<tr><td>Teller</td><td>1</td><td>serves</td><td>Customer</td><td>7</td></tr>
<tr><td>Teller</td><td>2</td><td>serves</td><td>Customer</td><td>8</td></tr>
<tr><td>Teller</td><td>3</td><td>serves</td><td>Customer</td><td>9</td></tr>
<tr><td>Teller</td><td>3</td><td>serves</td><td>Customer</td><td>10</td></tr>
<tr><td>Teller</td><td>2</td><td>serves</td><td>Customer</td><td>11</td></tr>
<tr><td>Teller</td><td>4</td><td>serves</td><td>Customer</td><td>12</td></tr>
<tr><td>Teller</td><td>2</td><td>serves</td><td>Customer</td><td>13</td></tr>
<tr><td>Teller</td><td>1</td><td>serves</td><td>Customer</td><td>14</td></tr>
<tr><td>Teller*///:~</td><td>1</td><td>serves</td><td>Customer</td><td>15</td></tr>
</table>
<p>Both Customer and Teller have private constructors, thereby forcing you to use Generator objects. Customer has a generator( ) method that produces a new Generator&lt;Customer&gt; object each time you call it. You may not need multiple Generator objects, and Teller creates a single public generator object. You can see both of these approaches used in the fill( ) methods in main( ).</p>
<p>Since both the generator( ) method in Customer and the Generator object in Teller are static, they cannot be part of an interface, so there is no way to &quot;generify&quot; this particular idiom. Despite that, it works reasonably well with the fill( ) method.</p>
<p>We’ll look at other versions of this queuing problem in the Concurrency chapter.</p>
<p>Exercise 18: (3) Following the form of BankTeller.java, create an example where BigFish eat LittleFish in the Ocean.</p>
</section>
<section>
<title>
<p>Building complex models</p></title><empty-line/>
<p>An important benefit of generics is the ability to simply and safely create complex models. For example, we can easily create a List of tuples:</p>
<p>//: generics/TupleList.java</p>
<p>// Combining generic types to make complex generic types.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>public class TupleList&lt;A,B,C,D&gt; extends ArrayList&lt;FourTuple&lt;A,B,C,D&gt;&gt; { public static void main(String[] args) {</p>
<p>TupleList&lt;Vehicle, Amphibian, String, Integer&gt; tl = new TupleList&lt;Vehicle, Amphibian, String, Integer&gt;(); tl.add(TupleTest.h()); tl.add(TupleTest.h());</p>
<p>for(FourTuple&lt;Vehicle,Amphibian,String,Integer&gt; i: tl) System.out.println(i);</p>
<p>}</p>
<p>} /* Output: (75% match)</p>
<p>(Vehicle@11b86e7, Amphibian@35ce36, hi, 47)</p>
<p>(Vehicle@757aef, Amphibian@d9f9c3, hi, 47)</p>
<p>Although it gets somewhat verbose (especially the creation of the iterator), you end up with a fairly powerful data structure without too much code.</p>
<p>Here’s another example showing how straightforward it is to build complex models using generic types. Even though each class is created as a building block, the total has many parts. In this case, the model is a retail store with aisles, shelves and products:</p>
<p>//: generics/Store.java</p>
<p>// Building up a complex model using generic containers.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>class Product {</p>
<p>private final int id; private String description; private double price;</p>
<p>public Product(int IDnumber, String descr, double price){ id = IDnumber; description = descr; this.price = price;</p>
<p>System.out.println(toStringO);</p>
<p>}</p>
<p>public String toString() {</p>
<p>return id + &quot;: &quot; + description + &quot;, price: $&quot; + price;</p>
<p>}</p>
<p>public void priceChange(double change) { price += change;</p>
<p>}</p>
<p>public static Generator&lt;Product&gt; generator = new Generator&lt;Product&gt;() {</p>
<p>private Random rand = new Random(47); public Product next() {</p>
<p>return new Product(rand.nextInt(1000), &quot;Test&quot;, Math.round(rand.nextDouble() * 1000.0) + 0.99);</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>class Shelf extends ArrayList&lt;Product&gt; { public Shelf(int nProducts) {</p>
<p>Generators.fill(this, Product.generator, nProducts);</p>
<p>}</p>
<p>}</p>
<p>class Aisle extends ArrayList&lt;Shelf&gt; {</p>
<p>public Aisle(int nShelves, int nProducts) { for(int i = 0; i &lt; nShelves; i++) add(new Shelf(nProducts));</p>
<p>}</p>
<p>}</p>
<p>class CheckoutStand {} class Office {}</p>
<p>public class Store extends ArrayList&lt;Aisle&gt; { private ArrayList&lt;CheckoutStand&gt; checkouts = new ArrayList&lt;CheckoutStand&gt;(); private Office office = new Office();</p>
<p>public Store(int nAisles, int nShelves, int nProducts) { for(int i = 0; i &lt; nAisles; i++)</p>
<p>add(new Aisle(nShelves, nProducts));</p>
<p>public String toString() {</p>
<p>StringBuilder result = new StringBuilder(); for(Aisle a : this) for(Shelf s : a)</p>
<p>for(Product p : s) { result.append(p); result.append(&quot;\n&quot;);</p>
<p>}</p>
<p>return result.toString();</p>
<p>}</p>
<p>public static void main(String[] args) { System.out.println(new Store(14, 5, 10));</p>
<table>
<tr><td colspan="2">}} /* Output</td><td></td><td></td><td></td><td></td></tr>
<tr><td>258</td><td>Test,</td><td>pri</td><td>ce:</td><td>$400</td><td>99</td></tr>
<tr><td>861</td><td>Test,</td><td>pri</td><td>ce:</td><td>$160</td><td>99</td></tr>
<tr><td>868</td><td>Test,</td><td>pri</td><td>ce:</td><td>$417</td><td>99</td></tr>
<tr><td>207</td><td>Test,</td><td>pri</td><td>ce:</td><td>$268</td><td>99</td></tr>
<tr><td>551:</td><td>Test,</td><td>pri</td><td>ce:</td><td>$114</td><td>99</td></tr>
<tr><td>278:</td><td>Test,</td><td>pri</td><td>ce:</td><td>$804</td><td>99</td></tr>
<tr><td>520:</td><td>Test,</td><td>pri</td><td>ce:</td><td>$554</td><td>99</td></tr>
<tr><td>140:</td><td>Test,</td><td>pri</td><td>ce:</td><td>$530</td><td>99</td></tr>
<tr><td colspan="2">*///:~</td><td></td><td></td><td></td><td></td></tr>
</table>
<p>As you can see in Store.toString( ), the result is many layers of containers that are nonetheless type-safe and manageable. What’s impressive is that it is not intellectually prohibitive to assemble such a model.</p>
<p>Exercise 19: (2) Following the form of Store.java, build a model of a containerized cargo ship.</p>
</section>
<section>
<title>
<p>The mystery of erasure</p></title><empty-line/>
<p>As you begin to delve more deeply into generics, there are a number of things that won’t initially make sense. For example, although you can say ArrayList.class, you cannot say ArrayList&lt;Integer&gt;.class. And consider the following:</p>
<p>//: generics/ErasedTypeEquivalence.java import java.util.*;</p>
<p>public class ErasedTypeEquivalence {</p>
<p>public static void main(String[] args) {</p>
<p>Class cl = new ArrayList&lt;String&gt;().getClass();</p>
<p>Class c2 = new ArrayList&lt;Integer&gt;().getClass(); System.out.println(c1 == c2);</p>
<p>}</p>
<p>} /* Output:</p>
<p>true</p>
<p>*///:~</p>
<p>Array List &lt; String &gt; and Array List &lt; Integer &gt; could easily be argued to be distinct types. Different types behave differently, and if you try, for example, to put an Integer into an Array List &lt; String &gt;, you get different behavior (it fails) than if you put an Integer into an ArrayList&lt; Integer &gt; (it succeeds). And yet the above program suggests that they are the same type.</p>
<p>Here’s an example that adds to this puzzle:</p>
<p>//: generics/Lostlnformation.java import java.util.*;</p>
<p>class Frob {} class Fnorkle {} class Quark&lt;Q&gt; {}</p>
<p>class Particle&lt;POSITION,MOMENTUM&gt; {}</p>
<p>public class LostInformation {</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;Frob&gt; list = new ArrayList&lt;Frob&gt;(); Map&lt;Frob,Fnorkle&gt; map = new HashMap&lt;Frob,Fnorkle&gt;(); Quark&lt;Fnorkle&gt; quark = new Quark&lt;Fnorkle&gt;(); Particle&lt;Long,Double&gt; p = new Particle&lt;Long,Double&gt;(); System.out.println(Arrays.toString( list.getClass().getTypeParameters())); System.out.println(Arrays.toString( map.getClass().getTypeParameters())); System.out.println(Arrays.toString(</p>
<p>quark.getClass().getTypeParameters()));</p>
<p>System.out.println(Arrays.toString(</p>
<p>p.getClass().getTypeParameters()));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[E]</p>
<p>[K, V]</p>
<p>[Q]</p>
<p>[POSITION, MOMENTUM]</p>
<p>*///:~</p>
<p>According to the JDK documentation, Class.getTypeParameters( ) &quot;returns an array of TypeVariable objects that represent the type variables declared by the generic declaration...&quot; This seems to suggest that you might be able to find out what the parameter types are. However, as you can see from the output, all you find out is the identifiers that are used as the parameter placeholders, which is not such an interesting piece of information.</p>
<p>The cold truth is:</p>
<p>There’s no information about generic parameter types available inside generic code.</p>
<p>Thus, you can know things like the identifier of the type parameter and the bounds of the generic type—you just can’t know the actual type parameter(s) used to create a particular instance. This fact, which is especially frustrating if you’re coming from C++, is the most fundamental issue that you must deal with when working with Java generics.</p>
<p>Java generics are implemented using erasure. This means that any specific type information is erased when you use a generic. Inside the generic, the only thing that you know is that you’re using an object. So List&lt;String&gt; and List&lt; Integer&gt; are, in fact, the same type at run time. Both forms are &quot;erased&quot; to their raw type, List. Understanding erasure and how you must deal with it will be one of the biggest hurdles you will face when learning Java generics, and that’s what we’ll explore in this section.</p>
<subtitle>The C++ approach</subtitle>
<p>Here’s a C++ example which uses templates. You’ll notice that the syntax for parameterized types is quite similar, because Java took inspiration from C++:</p>
<p>//: generics/Templates.cpp #include &lt;iostream&gt; using namespace std;</p>
<p>template&lt;class T&gt; class Manipulator {</p>
<p>T obj; public:</p>
<p>Manipulator(T x) { obj = x; } void manipulate() { obj.f(); }</p>
<p>};</p>
<p>class HasF { public:</p>
<p>void f() { cout &lt;&lt; &quot;HasF::f()&quot; &lt;&lt; endl; }</p>
<p>};</p>
<p>int main() {</p>
<p>HasF hf;</p>
<p>Manipulator&lt;HasF&gt; manipulator(hf); manipulator.manipulate();</p>
<p>} /* Output:</p>
<p>HasF::f()</p>
<p>///:~</p>
<p>The Manipulator class stores an object of type T. What’s interesting is the manipulate( ) method, which calls a method f( ) on obj. How can it know that the f( ) method exists for the type parameter T? The C++ compiler checks when you instantiate the template, so at the point of instantiation of Manipulator &lt;HasF&gt;, it sees that HasF has a method f( ). If it were not the case, you’d get a compile-time error, and thus type safety is preserved.</p>
<p>Writing this kind of code in C++ is straightforward because when a template is instantiated, the template code knows the type of its template parameters. Java generics are different. Here’s the translation of HasF:</p>
<p>//: generics/HasF.java public class HasF {</p>
<p>public void f() { System.out.println(&quot;HasF.f()&quot;); }</p>
<p>} ///:~</p>
<p>If we take the rest of the example and translate it to Java, it won’t compile:</p>
<p>//: generics/Manipulation.java // {CompileTimeError} (Won’t compile)</p>
<p>class Manipulator&lt;T&gt; { private T obj;</p>
<p>public Manipulator(T x) { obj = x; }</p>
<p>// Error: cannot find symbol: method f(): public void manipulate() { obj.f(); }</p>
<p>}</p>
<p>public class Manipulation {</p>
<p>public static void main(String[] args) {</p>
<p>HasF hf = new HasF();</p>
<p>Manipulator&lt;HasF&gt; manipulator = new Manipulator&lt;HasF&gt;(hf); manipulator.manipulate();</p>
<p>} ///:~</p>
<p>Because of erasure, the Java compiler can’t map the requirement that manipulate( ) must be able to call f( ) on obj to the fact that HasF has a method f( ). In order to call f( ), we must assist the generic class by giving it a bound that tells the compiler to only accept types that conform to that bound. This reuses the extends keyword. Because of the bound, the following compiles:</p>
<p>//: generics/Manipulator2.java</p>
<p>class Manipulator2&lt;T extends HasF&gt; { private T obj;</p>
<p>public Manipulator2(T x) { obj = x; } public void manipulate() { obj.f(); }</p>
<p>} ///:~</p>
<p>The bound &lt;T extends HasF&gt; says that T must be of type HasF or something derived from HasF. If this is true, then it is safe to call f( ) on obj.</p>
<p>We say that a generic type parameter erases to its first bound (it’s possible to have multiple bounds, as you shall see later). We also talk about the erasure of the type parameter. The compiler actually replaces the type parameter with its erasure, so in the above case, T erases to HasF, which is the same as replacing T with HasF in the class body.</p>
<p>You may correctly observe that in Manipulations.Java, generics do not contribute anything. You could just as easily perform the erasure yourself and produce a class without generics:</p>
<p>//: generics/Manipulator3.java</p>
<p>class Manipulator { private HasF obj;</p>
<p>public Manipulator3(HasF x) { obj = x; } public void manipulate() { obj.f(); }</p>
<p>} ///:~</p>
<p>This brings up an important point: Generics are only useful when you want to use type parameters that are more &quot;generic&quot; than a specific type (and all its subtypes)—that is, when you want code to work across multiple classes. As a result, the type parameters and their application in useful generic code will usually be more complex than simple class replacement. However, you can’t just say that anything of the form &lt;T extends HasF&gt; is therefore flawed. For example, if a class has a method that returns T, then generics are helpful, because they will then return the exact type:</p>
<p>//: generics/ReturnGenericType.java</p>
<p>class ReturnGenericType&lt;T extends HasF&gt; { private T obj;</p>
<p>public ReturnGenericType(T x) { obj = x; } public T get() { return obj; }</p>
<p>} ///:~</p>
<p>You have to look at all the code and understand whether it is &quot;complex enough&quot; to warrant the use of generics.</p>
<p>We’ll look at bounds in more detail later in the chapter.</p>
<p>Exercise 20: (1) Create an interface with two methods, and a class that implements that interface and adds another method. In another class, create a generic method with an argument type that is bounded by the interface, and show that the methods in the interface are callable inside this generic method. In main( ), pass an instance of the implementing class to the generic method.</p>
<subtitle>Migration compatibility</subtitle>
<p>To allay any potential confusion about erasure, you must clearly understand that it is not a language feature. It is a compromise in the implementation of Java generics, necessary because generics were not made part of the language from the beginning. This compromise will cause you pain, so you need to get used to it early and to understand why it’s there.</p>
<p>If generics had been part of Java l.o, the feature would not have been implemented using erasure—it would have used reification to retain the type parameters as first-class entities, so you would have been able to perform type-based language and reflective operations on type parameters. You’ll see later in this chapter that erasure reduces the &quot;genericity&quot; of generics. Generics are still useful in Java, just not as useful as they could be, and the reason is erasure.</p>
<p>In an erasure-based implementation, generic types are treated as secondclass types that cannot be used in some important contexts. The generic types are present only during static type checking, after which every generic type in the program is erased by replacing it with a non-generic upper bound. For example, type annotations such as List&lt;T&gt; are erased to List, and ordinary type variables are erased to Object unless a bound is specified.</p>
<p>The core motivation for erasure is that it allows generified clients to be used with non-generified libraries, and vice versa. This is often called migration compatibility. In the ideal world, we would have had a single day when everything was generified at once. In reality, even if programmers are only writing generic code, they will have to deal with non-generic libraries that were written before Java SE5. The authors of those libraries may never have the incentive to generify their code, or they may just take their time in getting to it.</p>
<p>So Java generics not only must support backwards compatibility-existing code and class files are still legal, and continue to mean what they meant before—but also must support migration compatibility, so that libraries can become generic at their own pace, and when a library does become generic, it doesn’t break code and applications that depend upon it. After deciding that this was the goal, the Java designers and the various groups working on the problem decided that erasure was the only feasible solution. Erasure enables this migration towards generics by allowing non-generic code to coexist with generic code.</p>
<p>For example, suppose an application uses two libraries, X and Y, and Y uses library Z. With the advent of Java SE5, the creators of this application and these libraries will probably, eventually, want to migrate to generics. Each of them, however, will have different motivations and constraints as to when that migration happens. To achieve migration compatibility, each library and application must be independent of all the others regarding whether generics are used. Thus, they must not be able to detect whether other libraries are or are not using generics. Ergo, the evidence that a particular library is using generics must be &quot;erased.&quot;</p>
<p>Without some kind of migration path, all the libraries that had been built up over time stood the chance of being cut off from the developers that chose to move to Java generics. Libraries are arguably the part of a programming language that has the greatest productivity impact, so this was not an acceptable cost. Whether or not erasure was the best or only migration path is something that only time will tell.</p>
<subtitle>The problem with erasure</subtitle>
<p>So the primary justification for erasure is the transition process from nongenerified code to generified code, and to incorporate generics into the language without breaking existing libraries. Erasure allows existing nongeneric client code to continue to be used without change, until clients are ready to rewrite code for generics. This is a noble motivation, because it doesn’t suddenly break all existing code.</p>
<p>The cost of erasure is significant. Generic types cannot be used in operations that explicitly refer to runtime types, such as casts, instanceof operations, and new expressions. Because all the type information about the parameters is lost, whenever you’re writing generic code you must constantly be reminding yourself that it only appears that you have type information about a parameter. So when you write a piece of code like this:</p>
<p>class Foo&lt;T&gt; {</p>
<p>T var;</p>
<p>}</p>
<p>it appears that when you create an instance of Foo:</p>
<p>Foo&lt;Cat&gt; f = new Foo&lt;Cat&gt;();</p>
<p>the code in class Foo ought to know that it is now working with a Cat. The syntax strongly suggests that the type T is being substituted everywhere throughout the class. But it isn’t, and you must remind yourself, &quot;No, it’s just an Object,&quot; whenever you’re writing the code for the class.</p>
<p>In addition, erasure and migration compatibility mean that the use of generics is not enforced when you might want it to be:</p>
<p>//: generics/ErasureAndlnheritance.java</p>
<p>class GenericBase&lt;T&gt; { private T element;</p>
<p>public void set(T arg) { arg = element; } public T get() { return element; }</p>
<p>}</p>
<p>class Derived1&lt;T&gt; extends GenericBase&lt;T&gt; {}</p>
<p>class Derived2 extends GenericBase {} // No warning</p>
<p>// class Derived3 extends GenericBase&lt;?&gt; {}</p>
<p>// Strange error:</p>
<p>// unexpected type found : ?</p>
<p>// required: class or interface without bounds</p>
<p>public class ErasureAndInheritance {</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public static void main(String[] args) {</p>
<p>Derived2 d2 = new Derived2();</p>
<p>Object obj = d2.get(); d2.set(obj); // Warning here!</p>
<p>}</p>
<p>} ///:~</p>
<p>Derived2 inherits from GenericBase with no generic parameters, and the compiler doesn’t issue a warning. The warning doesn’t occur until set( ) is called.</p>
<p>To turn off the warning, Java provides an annotation, the one that you see in the listing (this annotation was not supported in earlier releases of Java SE5):</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>Notice that this is placed on the method that generates the warning, rather than the entire class. It’s best to be as &quot;focused&quot; as possible when you turn off a warning, so that you don’t accidentally cloak a real problem by turning off warnings too broadly.</p>
<p>Presumably, the error produced by Derived3 means that the compiler expects a raw base class.</p>
<p>Add to this the extra effort of managing bounds when you want to treat your type parameter as more than just an Object, and you have far more effort for much less payoff than you get in parameterized types in languages like C++, Ada or Eiffel. This is not to say that those languages in general buy you more than Java does for the majority of programming problems, but rather that their parameterized type mechanisms are more flexible and powerful than Java’s.</p>
<subtitle>The action at the boundaries</subtitle>
<p>Because of erasure, I find that the most confusing aspect of generics is the fact that you can represent things that have no meaning. For example:</p>
<p>//: generics/ArrayMaker.java import java.lang.reflect.*; import java.util.*;</p>
<p>public class ArrayMaker&lt;T&gt; { private Class&lt;T&gt; kind;</p>
<p>public ArrayMaker(Class&lt;T&gt; kind) { this.kind = kind; } @SuppressWarnings(&quot;unchecked&quot;)</p>
<p>T[] create(int size) {</p>
<p>return (T[])Array.newInstance(kind, size);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>ArrayMaker&lt;String&gt; stringMaker =</p>
<p>new ArrayMaker&lt;String&gt;(String.class);</p>
<p>String[] stringArray = stringMaker.create(9); System.out.println(Arrays.toString(stringArray));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[null, null, null, null, null, null, null, null, null]</p>
<p>*///:~</p>
<p>Even though kind is stored as Class&lt;T&gt;, erasure means that it is actually just being stored as a Class, with no parameter. So, when you do something with it, as in creating an array, Array.newInstance( ) doesn’t actually have the type information that’s implied in kind; so it cannot produce the specific result, which must therefore be cast, which produces a warning that you cannot satisfy.</p>
<p>Note that using Array.newInstance( ) is the recommended approach for creating arrays in generics.</p>
<p>If we create a container instead of an array, things are different:</p>
<p>//: generics/ListMaker.java import java.util.*;</p>
<p>public class ListMaker&lt;T&gt; {</p>
<p>List&lt;T&gt; create() { return new ArrayList&lt;T&gt;(); } public static void main(String[] args) {</p>
<p>ListMaker&lt;String&gt; stringMaker= new ListMaker&lt;String&gt;();</p>
<p>List&lt;String&gt; stringList = stringMaker.create();</p>
<p>}</p>
<p>} ///:~</p>
<p>The compiler gives no warnings, even though we know (from erasure) that the &lt;T&gt; in new ArrayList&lt;T&gt;( ) inside create( ) is removed—at run time there’s no &lt;T&gt; inside the class, so it seems meaningless. But if you follow this idea and change the expression to new ArrayList( ), the compiler gives a warning.</p>
<p>Is it really meaningless in this case? What if you were to put some objects in the list before returning it, like this:</p>
<p>//: generics/FilledListMaker.java import java.util.*;</p>
<p>public class FilledListMaker&lt;T&gt; {</p>
<p>List&lt;T&gt; create(T t, int n) {</p>
<p>List&lt;T&gt; result = new ArrayList&lt;T&gt;(); for(int i = 0; i &lt; n; i++) result.add(t); return result;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>FilledListMaker&lt;String&gt; stringMaker = new FilledListMaker&lt;String&gt;();</p>
<p>List&lt;String&gt; list = stringMaker.create(&quot;Hello&quot;, 4); System.out.println(list);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[Hello, Hello, Hello, Hello]</p>
<p>*///:~</p>
<p>Even though the compiler is unable to know anything about T inside create( ), it can still ensure—at compile time—that what you put into result is of type T, so that it agrees with ArrayList&lt;T&gt;. Thus, even though erasure removes the information about the actual type inside a method or class, the compiler can still ensure internal consistency in the way that the type is used within the method or class.</p>
<p>Because erasure removes type information in the body of a method, what matters at run time is the boundaries: the points where objects enter and leave a method. These are the points at which the compiler performs type checks at compile time, and inserts casting code. Consider the following nongeneric example:</p>
<p>//: generics/SimpleHolder.java</p>
<p>public class SimpleHolder { private Object obj;</p>
<p>public void set(Object obj) { this.obj = obj; } public Object get() { return obj; } public static void main(String[] args) {</p>
<p>SimpleHolder holder = new SimpleHolder(); holder.set(&quot;Item&quot;);</p>
<p>String s = (String)holder.get();</p>
<p>}</p>
<p>} ///:~</p>
<p>If we decompile the result with javap -c SimpleHolder, we get (after editing): public void set(java.lang.Object);</p>
<p>0:    aload_0</p>
<p>1:    aload_1</p>
<p>2:    putfield    #2;    //Field    obj:Object;</p>
<p>5:    return</p>
<p>public java.lang.Object get();</p>
<p>0:    aload_0</p>
<p>1:    getfield    #2; //Field    obj:Object;</p>
<p>4:    areturn</p>
<p>public static void main(java.lang.String[]);</p>
<p>0:    new #3; //class SimpleHolder</p>
<p>3:    dup</p>
<p>4:    invokespecial    #4;    //Method    &quot;&lt;init&gt;&quot;:()V</p>
<p>7:    astore_1</p>
<p>8:    aload_1</p>
<p>9:    ldc #5; //String Item</p>
<p>11:    invokevirtual #6; //Method set:(Object;)V</p>
<p>14:    aload_1</p>
<p>15:    invokevirtual    #7;    //Method    get:()Object;</p>
<p>18:    checkcast #8; //class java/lang/String</p>
<p>21:    astore_2</p>
<p>22:    return</p>
<p>The set( ) and get( ) methods simply store and produce the value, and the cast is checked at the point of the call to get( ).</p>
<p>Now incorporate generics into the above code:</p>
<p>//: generics/GenericHolder.java</p>
<p>public class GenericHolder&lt;T&gt; { private T obj;</p>
<p>public void set(T obj) { this.obj = obj; }</p>
<p>public T get() { return obj; }</p>
<p>public static void main(String[] args) {</p>
<p>GenericHolder&lt;String&gt; holder = new GenericHolder&lt;String&gt;(); holder.set(&quot;Item&quot;);</p>
<p>String s = holder.get();</p>
<p>}</p>
<p>} ///:~</p>
<p>The need for the cast from get( ) has disappeared, but we also know that the value passed to set( ) is being type-checked at compile time. Here are the relevant bytecodes:</p>
<table>
<tr><th colspan="4">public void set(java.lang.Object);</th></tr>
<tr><td>0</td><td>aload_0</td><td></td><td></td></tr>
<tr><td>1</td><td>aload_1</td><td></td><td></td></tr>
<tr><td>2</td><td>putfield #2;</td><td>//Field</td><td>obj:Object</td></tr>
<tr><td>5</td><td>return</td><td></td><td></td></tr>
<tr><td colspan="3">public java.lang.Object get()</td><td></td></tr>
<tr><td>0:</td><td>aload_0</td><td></td><td></td></tr>
<tr><td>1:</td><td>getfield #2;</td><td>//Field</td><td>obj:Object</td></tr>
<tr><td>4:</td><td>areturn</td><td></td><td></td></tr>
</table>
<p>public static void main(java.lang.String[]);</p>
<p>0:    new #3; //class GenericHolder</p>
<p>3:    dup</p>
<p>4:    invokespecial    #4;    //Method    &quot;&lt;init&gt;&quot;:()V</p>
<p>7:    astore_1</p>
<p>8:    aload_1</p>
<p>9:    Idc #5; //String Item</p>
<p>11:    invokevirtual #6; //Method set:(Object;)V</p>
<p>14:    aload_1</p>
<p>15:    invokevirtual    #7;    //Method    get:()Object;</p>
<p>18:    checkcast #8; //class java/lang/String</p>
<p>21:    astore_2</p>
<p>22:    return</p>
<p>The resulting code is identical. The extra work of checking the incoming type in set( ) is free, because it is performed by the compiler. And the cast for the outgoing value of get( ) is still there, but it’s no less than you’d have to do yourself—and it’s automatically inserted by the compiler, so the code you write (and read) is less noisy.</p>
<p>Since get( ) and set( ) produce the same bytecodes, all the action in generics happens at the boundaries—the extra compile-time check for incoming values, and the inserted cast for outgoing values. It helps to counter the confusion of erasure to remember that &quot;the boundaries are where the action takes place.&quot;</p>
</section>
<section>
<title>
<p>Compensating for erasure</p></title><empty-line/>
<p>As we’ve seen, erasure loses the ability to perform certain operations in generic code. Anything that requires the knowledge of the exact type at run time won’t work:</p>
<p>//: generics/Erased.java // {CompileTimeError} (Won’t compile)</p>
<table>
<tr><th colspan="4">public class Erased&lt;T&gt; {</th></tr>
<tr><td>private final</td><td>int SIZE = 100;</td><td></td><td></td></tr>
<tr><td>public static</td><td>void f(Object arg) {</td><td></td><td></td></tr>
<tr><td colspan="2">if(arg instanceof T) {}</td><td>//</td><td>Error</td></tr>
<tr><td>T var = new</td><td>T();</td><td>//</td><td>Error</td></tr>
<tr><td>T[] array =</td><td>new T[SIZE];</td><td>//</td><td>Error</td></tr>
<tr><td>T[] array =</td><td>(T)new Object[SIZE];</td><td>//</td><td>Unchecked warning</td></tr>
<tr><td colspan="4">}} ///:~</td></tr>
</table>
<p>Occasionally you can program around these issues, but sometimes you must compensate for erasure by introducing a type tag. This means you explicitly pass in the Class object for your type so that you can use it in type expressions.</p>
<p>For example, the attempt to use instanceof in the previous program fails because the type information has been erased. If you introduce a type tag, a dynamic islnstance( ) can be used instead:</p>
<p>//: generics/ClassTypeCapture.java</p>
<p>class Building {}</p>
<p>class House extends Building {}</p>
<p>public class ClassTypeCapture&lt;T&gt; {</p>
<p>Class&lt;T&gt; kind;</p>
<p>public ClassTypeCapture(Class&lt;T&gt; kind) { this.kind = kind;</p>
<p>}</p>
<p>public boolean f(Object arg) { return kind.isInstance(arg);</p>
<p>}</p>
<p>public static void main(String[] args) { ClassTypeCapture&lt;Building&gt; cttl =</p>
<p>new ClassTypeCapture&lt;Building&gt;(Building.class); System.out.println(ctt1.f(new Building())); System.out.println(ctt1.f(new House())); ClassTypeCapture&lt;House&gt; ctt2 =</p>
<p>new ClassTypeCapture&lt;House&gt;(House.class); System.out.println(ctt2.f(new Building())); System.out.println(ctt2.f(new House()));</p>
<p>}</p>
<p>} /* Output:</p>
<p>true</p>
<p>true</p>
<p>false</p>
<p>true</p>
<p>*///:~</p>
<p>The compiler ensures that the type tag matches the generic argument.</p>
<p>Exercise 21: (4) Modify ClassTypeCapture.java by adding a</p>
<p>Map&lt;String,Class&lt;?&gt;&gt;, a method addType(String typename, Class&lt;?&gt; kind), and a method createNew(String typename). createNew( ) will either produce a new instance of the class associated with its argument string, or produce an error message.</p>
<subtitle>Creating instances of types</subtitle>
<p>The attempt to create a new T( ) in Erased.java won’t work, partly because of erasure, and partly because the compiler cannot verify that T has a default (no-arg) constructor. But in C++ this operation is natural, straightforward, and safe (it’s checked at compile time):</p>
<p>//: generics/InstantiateGenericType.cpp // C++, not Java!</p>
<p>template&lt;class T&gt; class Foo {</p>
<p>T x; // Create a field of type T T* y; // Pointer to T public:</p>
<p>// Initialize the pointer:</p>
<p>Foo() { y = new T(); }</p>
<p>};</p>
<p>class Bar {};</p>
<p>int main() {</p>
<p>Foo&lt;Bar&gt; fb;</p>
<p>Foo&lt;int&gt; fi; // ... and it works with primitives } ///:~</p>
<p>The solution in Java is to pass in a factory object, and use that to make the new instance. A convenient factory object is just the Class object, so if you use a type tag, you can use newlnstance( ) to create a new object of that type:</p>
<p>//: generics/InstantiateGenericType.java import static net.mindview.util.Print.*;</p>
<p>class ClassAsFactory&lt;T&gt; {</p>
<p>T x;</p>
<p>public ClassAsFactory(Class&lt;T&gt; kind) { try {</p>
<p>x = kind.newInstance();</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class Employee {}</p>
<p>public class InstantiateGenericType { public static void main(String[] args) {</p>
<p>ClassAsFactory&lt;Employee&gt; fe =</p>
<p>new ClassAsFactory&lt;Employee&gt;(Employee.class); print(&quot;ClassAsFactory&lt;Employee&gt; succeeded&quot;); try {</p>
<p>ClassAsFactory&lt;Integer&gt; fi =</p>
<p>new ClassAsFactory&lt;Integer&gt;(Integer.class);</p>
<p>} catch(Exception e) {</p>
<p>print(&quot;ClassAsFactory&lt;Integer&gt; failed&quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>ClassAsFactory&lt;Employee&gt; succeeded ClassAsFactory&lt;Integer&gt; failed *///:~</p>
<p>This compiles, but fails with ClassAsFactory&lt;Integer&gt; because Integer has no default constructor. Because the error is not caught at compile time, this approach is frowned upon by the Sun folks. They suggest instead that you use an explicit factory and constrain the type so that it only takes a class that implements this factory:</p>
<p>//: generics/FactoryConstraint.java</p>
<p>interface FactoryI&lt;T&gt; {</p>
<p>T create();</p>
<p>}</p>
<p>class Foo2&lt;T&gt; { private T x;</p>
<p>public &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory) { x = factory.create();</p>
<p>}</p>
<p>// ...</p>
<p>}</p>
<p>class IntegerFactory implements FactoryI&lt;Integer&gt; { public Integer create() { return new Integer(0);</p>
<p>}</p>
<p>} class Widget {</p>
<p>public static class Factory implements FactoryI&lt;Widget&gt; { public Widget create() { return new Widget();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class FactoryConstraint {</p>
<p>public static void main(String[] args) { new Foo2&lt;Integer&gt;(new IntegerFactory()); new Foo2&lt;Widget&gt;(new Widget.Factory());</p>
<p>}</p>
<p>} ///:~</p>
<p>Note that this is really just a variation of passing Class&lt;T&gt;. Both approaches pass factory objects; Class&lt;T&gt; happens to be the built-in factory object, whereas the above approach creates an explicit factory object. But you get compile-time checking.</p>
<p>Another approach is the Template Method design pattern. In the following example, get( ) is the Template Method, and create( ) is defined in the subclass to produce an object of that type:</p>
<p>//: generics/CreatorGeneric.java</p>
<p>abstract class GenericWithCreate&lt;T&gt; { final T element;</p>
<p>GenericWithCreate() { element = create(); } abstract T create();</p>
<p>}</p>
<p>class X {}</p>
<p>class Creator extends GenericWithCreate&lt;X&gt; {</p>
<p>X create() { return new X(); } void f() {</p>
<p>System.out.println(element.getClass().getSimpleName());</p>
<p>}</p>
<p>}</p>
<p>public class CreatorGeneric {</p>
<p>public static void main(String[] args) {</p>
<p>Creator c = new Creator(); c.f();</p>
<p>}</p>
<p>} /* Output:</p>
<p>X</p>
<p>*///:~</p>
<p>Exercise 22: (6) Use a type tag along with reflection to create a method that uses the argument version of newInstance( ) to create an object of a class with a constructor that has arguments.</p>
<p>Exercise 23: (1) Modify FactoryConstraint.java so that create( ) takes an argument.</p>
<p>Exercise 24: (3) Modify Exercise 21 so that factory objects are held in the Map instead of Class&lt;?&gt;.</p>
<subtitle>Arrays of generics</subtitle>
<p>As you saw in Erased.java, you can’t create arrays of generics. The general solution is to use an ArrayList everywhere that you are tempted to create an array of generics:</p>
<p>//: generics/ListOfGenerics.java import java.util.*;</p>
<p>public class ListOfGenerics&lt;T&gt; {</p>
<p>private List&lt;T&gt; array = new ArrayList&lt;T&gt;(); public void add(T item) { array.add(item); } public T get(int index) { return array.get(index); }</p>
<p>} ///:~</p>
<p>Here you get the behavior of an array but the compile-time type safety afforded by generics.</p>
<p>At times, you will still want to create an array of generic types (the ArrayList, for example, uses arrays internally). Interestingly enough, you can define a reference in a way that makes the compiler happy. For example:</p>
<p>//: generics/ArrayOfGenericReference.java class Generic&lt;T&gt; {}</p>
<p>public class ArrayOfGenericReference { static Generic&lt;Integer&gt;[] gia;</p>
<p>} ///:~</p>
<p>The compiler accepts this without producing warnings. But you can never create an array of that exact type (including the type parameters), so it’s a little confusing. Since all arrays have the same structure (size of each array slot and array layout) regardless of the type they hold, it seems that you should be able to create an array of Object and cast that to the desired array type. This does in fact compile, but it won’t run; it produces a ClassCastException:</p>
<p>//: generics/ArrayOfGeneric.java</p>
<p>public class ArrayOfGeneric { static final int SIZE = 100; static Generic&lt;Integer&gt;[] gia;</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public static void main(String[] args) {</p>
<p>// Compiles; produces ClassCastException:</p>
<p>//! gia = (Generic&lt;Integer&gt;[])new Object[SIZE];</p>
<p>// Runtime type is the raw (erased) type: gia = (Generic&lt;Integer&gt;[])new Generic[SIZE]; System.out.println(gia.getClassQ.getSimpleNameQ); gia[0] = new Generic&lt;Integer&gt;();</p>
<p>//! gia[1] = new Object(); // Compile-time error // Discovers type mismatch at compile time:</p>
<p>//! gia[2] = new Generic&lt;Double&gt;();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Generic[]</p>
<p>*///:~</p>
<p>The problem is that arrays keep track of their actual type, and that type is established at the point of creation of the array. So even though gia has been cast to a Generic &lt; Integer &gt;[], that information only exists at compile time (and without the @SuppressWarnings annotation, you’d get a warning for that cast). At run time, it’s still an array of Object, and that causes problems. The only way to successfully create an array of a generic type is to create a new array of the erased type, and cast that.</p>
<p>Let’s look at a slightly more sophisticated example. Consider a simple generic wrapper around an array:</p>
<p>//: generics/GenericArray.java</p>
<p>public class GenericArray&lt;T&gt; { private T[] array;</p>
<p>@SuppressWarnings(&quot;unchecked&quot;) public GenericArray(int sz) { array = (T[])new Object[sz];</p>
<p>}</p>
<p>public void put(int index, T item) { array[index] = item;</p>
<p>}</p>
<p>public T get(int index) { return array[index]; }</p>
<p>// Method that exposes the underlying representation: public T[] rep() { return array; } public static void main(String[] args) {</p>
<p>GenericArray&lt;Integer&gt; gai = new GenericArray&lt;Integer&gt;(10);</p>
<p>// This causes a ClassCastException:</p>
<p>//! Integer[] ia = gai.rep();</p>
<p>// This is OK:</p>
<p>Object[] oa = gai.rep();</p>
<p>}</p>
<p>} ///:~</p>
<p>As before, we can’t say T[] array = new T[sz], so we create an array of objects and cast it.</p>
<p>The rep( ) method returns a T[] , which in main( ) should be an Integer[] for gai, but if you call it and try to capture the result as an Integer [] reference, you get a ClassCastException, again because the actual runtime type is Object[].</p>
<p>If you compile GenericArray .Java after commenting out the @SuppressWarnings annotation, the compiler produces a warning:</p>
<p>Note: GenericArray.Java uses unchecked or unsafe operations.</p>
<p>Note: Recompile with -Xlint:unchecked for details.</p>
<p>In this case, we’ve gotten a single warning, and we believe that it’s about the cast. But if you really want to make sure, you should compile with -Xlint:unchecked:</p>
<p>GenericArray.java:7: warning: [unchecked] unchecked cast found : java.lang.Object[] required: T[]</p>
<p>array = (T[])new Object[sz];</p>
<p>A</p>
<p>1 warning</p>
<p>It is indeed complaining about that cast. Because warnings become noise, the best thing we could possibly do, once we verify that a particular warning is expected, is to turn it off using @SuppressWarnings. That way, when a warning does appear, we’ll actually investigate it.</p>
<p>Because of erasure, the runtime type of the array can only be Object[]. If we immediately cast it to T[], then at compile time the actual type of the array is lost, and the compiler may miss out on some potential error checks. Because of this, it’s better to use an Object[] inside the collection, and add a cast to T when you use an array element. Let’s see how that would look with the GenericArray.java example:</p>
<p>//: generics/GenericArray2.java</p>
<p>public class GenericArray2&lt;T&gt; { private Object[] array; public GenericArray2(int sz) { array = new Object[sz];</p>
<p>}</p>
<p>public void put(int index, T item) { array[index] = item;</p>
<p>}</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public T get(int index) { return (T)array[index]; }</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public T[] rep() {</p>
<p>return (T[])array; // Warning: unchecked cast</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>GenericArray2&lt;Integer&gt; gai = new GenericArray2&lt;Integer&gt;(10); for(int i = 0; i &lt; 10; i ++) gai.put(i, i);</p>
<p>for(int i = 0; i &lt; 10; i ++)</p>
<p>System.out.print(gai.get(i) + &quot; &quot;);</p>
<p>System.out.println(); try {</p>
<p>Integer[] ia = gai.rep();</p>
<p>} catch(Exception e) { System.out.println(e); }</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>0 1 2 3 4 5 6 7 8 9</p>
<p>java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;</p>
<p>*///:~</p>
<p>Initially, this doesn’t look very different, just that the cast has been moved. Without the ©SuppressWarnings annotations, you will still get &quot;unchecked&quot; warnings. However, the internal representation is now Object[] rather than T[] . When get( ) is called, it casts the object to T, which is in fact the correct type, so that is safe. However, if you call rep( ), it again attempts to cast the Object[] to a T[], which is still incorrect, and produces a warning at compile time and an exception at run time. Thus there’s no way to subvert the type of the underlying array, which can only be Object[]. The advantage of treating array internally as Object[] instead of T[] is that it’s less likely that you’ll forget the runtime type of the array and accidentally introduce a bug (although the majority, and perhaps all, of such bugs would be rapidly detected at run time).</p>
<p>For new code, you should pass in a type token. In that case, the GenericArray looks like this:</p>
<p>//: generics/GenericArrayWithTypeToken.java import java.lang.reflect.*;</p>
<p>public class GenericArrayWithTypeToken&lt;T&gt; { private T[] array;</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public GenericArrayWithTypeToken(Class&lt;T&gt; type, int sz) {</p>
<p>array = (T[])Array.newInstance(type, sz);</p>
<p>public void put(int index, T item) { array[index] = item;</p>
<p>}</p>
<p>public T get(int index) { return array[index]; }</p>
<p>// Expose the underlying representation: public T[] rep() { return array; } public static void main(String[] args) { GenericArrayWithTypeToken&lt;Integer&gt; gai = new GenericArrayWithTypeToken&lt;Integer&gt;(</p>
<p>Integer.class, 10);</p>
<p>// This now works:</p>
<p>Integer[] ia = gai.rep();</p>
<p>}</p>
<p>} ///:~</p>
<p>The type token Class&lt;T&gt; is passed into the constructor in order to recover from the erasure, so that we can create the actual type of array that we need, although the warning from the cast must be suppressed with @SuppressWarnings. Once we do get the actual type, we can return it and get the desired results, as you see in main( ). The runtime type of the array is the exact type T[].</p>
<p>Unfortunately, if you look at the source code in the Java SE5 standard libraries, you’ll see there are casts from Object arrays to parameterized types everywhere. For example, here’s the copy-ArrayList-from-Collection constructor, after cleaning up and simplifying:</p>
<p>public ArrayList(Collection c) { size = c.size();</p>
<p>elementData = (E[])new Object[size]; c.toArray(elementData);</p>
<p>}</p>
<p>If you look through ArrayList.java, you’ll find plenty of these casts. And what happens when we compile it?</p>
<p>Note: ArrayList.java uses unchecked or unsafe operations.</p>
<p>Note: Recompile with -Xlint:unchecked for details.</p>
<p>Sure enough, the standard libraries produce lots of warnings. If you’ve worked with C, especially pre-ANSI C, you remember a particular effect of warnings: When you discover you can ignore them, you do. For that reason, it’s best to not issue any kind of message from the compiler unless the programmer must do something about it.</p>
<p>In his weblog,<a l:href="#bookmark63" type="note"><sup>64</sup></a><sup></sup> Neal Gafter (one of the lead developers for Java SE5) points out that he was lazy when rewriting the Java libraries, and that we should not do what he did. Neal also points out that he could not fix some of the Java library code without breaking the existing interface. So even if certain idioms appear in the Java library sources, that’s not necessarily the right way to do it. When you look at library code, you cannot assume that it’s an example that you should follow in your own code.</p>
</section>
<section>
<title>
<p>Bounds</p></title><empty-line/>
<p>Bounds were briefly introduced earlier in the chapter (see page 652). Bounds allow you to place constraints on the parameter types that can be used with generics. Although this allows you to enforce rules about the types that your generics can be applied to, a potentially more important effect is that you can call methods that are in your bound types.</p>
<p>Because erasure removes type information, the only methods you can call for an unbounded generic parameter are those available for Object. If, however, you are able to constrain that parameter to be a subset of types, then you can call the methods in that subset. To perform this constraint, Java generics reuse the extends keyword. It’s important for you to understand that extends has a significantly different meaning in the context of generic bounds than it does ordinarily. This example shows the basics of bounds:</p>
<p>//: generics/BasicBounds.java</p>
<p>interface HasColor { java.awt.Color getColor(); }</p>
<p>class Colored&lt;T extends HasColor&gt; {</p>
<p>T item;</p>
<p>Colored(T item) { this.item = item; }</p>
<p>T getItem() { return item; }</p>
<p>// The bound allows you to call a method: java.awt.Color color() { return item.getColor(); }</p>
<p>}</p>
<p>class Dimension { public int x, y, z; }</p>
<p>// This won’t work -- class must be first, then interfaces:</p>
<p>// class ColoredDimension&lt;T extends HasColor &amp; Dimension&gt; {</p>
<p>// Multiple bounds:</p>
<p>class ColoredDimension&lt;T extends Dimension &amp; HasColor&gt; {</p>
<p>T item;</p>
<p>ColoredDimension(T item) { this.item = item; }</p>
<p>T getItem() { return item; }</p>
<p>}</p>
<p>interface Weight { int weight(); }</p>
<p>// As with inheritance, you can have only one</p>
<p>// concrete class but multiple interfaces:</p>
<p>class Solid&lt;T extends Dimension &amp; HasColor &amp; Weight&gt; {</p>
<p>T item;</p>
<p>Solid(T item) { this.item = item; }</p>
<p>T getItem() { return item; }</p>
<p>java.awt.Color color() { return item.getColor(); }</p>
<p>int weight() { return item.weight(); }</p>
<p>}</p>
<p>class Bounded</p>
<p>extends Dimension implements HasColor, Weight { public java.awt.Color getColor() { return null; }</p>
<p>public int weight() { return 0; }</p>
<p>public class BasicBounds {</p>
<p>public static void main(String[] args) {</p>
<p>Solid&lt;Bounded&gt; solid =</p>
<p>new Solid&lt;Bounded&gt;(new Bounded()); solid.color(); solid.getY(); solid.weight();</p>
<p>}</p>
<p>} ///:~</p>
<p>You might observe that BasicBounds.java seems to contain redundancies that could be eliminated through inheritance. Here, you can see how each level of inheritance also adds bounds constraints:</p>
<p>//: generics/InheritBounds.java</p>
<p>class HoldItem&lt;T&gt; {</p>
<p>T item;</p>
<p>HoldItem(T item) { this.item = item; }</p>
<p>T getItem() { return item; }</p>
<p>}</p>
<p>class Colored2&lt;T extends HasColor&gt; extends HoldItem&lt;T&gt; {</p>
<p>Colored2(T item) { super(item); } java.awt.Color color() { return item.getColor(); }</p>
<p>}</p>
<p>class ColoredDimension2&lt;T extends Dimension &amp; HasColor&gt; extends Colored2&lt;T&gt; {</p>
<p>}</p>
<p>class Solid2&lt;T extends Dimension &amp; HasColor &amp; Weight&gt; extends ColoredDimension2&lt;T&gt; {</p>
<p>Solid2(T item) { super(item); } int weight() { return item.weight(); }</p>
<p>}</p>
<p>public class InheritBounds {</p>
<p>public static void main(String[] args) {</p>
<p>Solid2&lt;Bounded&gt; solid2 =</p>
<p>new Solid2&lt;Bounded&gt;(new Bounded()); solid2.color(); solid2.getY(); solid2.weight();</p>
<p>}</p>
<p>} ///:~</p>
<p>Holdltem simply holds an object, so this behavior is inherited into Colored2, which also requires that its parameter conforms to HasColor. ColoredDimension2 and Solid2 further extend the hierarchy and add bounds at each level. Now the methods are inherited and they don’t have to be repeated in each class.</p>
<p>Here’s an example with more layers:</p>
<p>//: generics/EpicBattle.java // Demonstrating bounds in Java generics. import java.util.*;</p>
<p>interface Superpower {}</p>
<p>interface XRayVision extends Superpower { void seeThroughWalls();</p>
<p>}</p>
<p>interface SuperHearing extends Superpower { void hearSubtleNoises();</p>
<p>}</p>
<p>interface SuperSmell extends Superpower { void trackBySmell();</p>
<p>}</p>
<p>class SuperHero&lt;POWER extends SuperPower&gt; {</p>
<p>POWER power;</p>
<p>SuperHero(POWER power) { this.power = power; }</p>
<p>POWER getPower() { return power; }</p>
<p>}</p>
<p>class SuperSleuth&lt;POWER extends XRayVision&gt; extends SuperHero&lt;POWER&gt; {</p>
<p>SuperSleuth(POWER power) { super(power); } void see() { power.seeThroughWalls(); }</p>
<p>}</p>
<p>class CanineHero&lt;POWER extends SuperHearing &amp; SuperSmell&gt; extends SuperHero&lt;POWER&gt; {</p>
<p>CanineHero(POWER power) { super(power); } void hear() { power.hearSubtleNoises(); } void smell() { power.trackBySmell(); }</p>
<p>}</p>
<p>class SuperHearSmell implements SuperHearing, SuperSmell { public void hearSubtleNoises() {} public void trackBySmell() {}</p>
<p>}</p>
<p>class DogBoy extends CanineHero&lt;SuperHearSmell&gt; {</p>
<p>DogBoy() { super(new SuperHearSmell()); }</p>
<p>}</p>
<p>public class EpicBattle {</p>
<p>// Bounds in generic methods: static &lt;POWER extends SuperHearing&gt; void useSuperHearing(SuperHero&lt;POWER&gt; hero) { hero.getPower().hearSubtleNoises();</p>
<p>}</p>
<p>static &lt;POWER extends SuperHearing &amp; SuperSmell&gt; void superFind(SuperHero&lt;POWER&gt; hero) { hero.getPower().hearSubtleNoises(); hero.getPower().trackBySmell();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>DogBoy dogBoy = new DogBoy();</p>
<p>useSuperHearing(dogBoy);</p>
<p>superFind(dogBoy);</p>
<p>// You can do this:</p>
<p>List&lt;? extends SuperHearing&gt; audioBoys;</p>
<p>// But you can’t do this:</p>
<p>// List&lt;? extends SuperHearing &amp; SuperSmell&gt; dogBoys;</p>
<p>} ///:~</p>
<p>Notice that wildcards (which we shall study next) are limited to a single bound.</p>
<p>Exercise 25: (2) Create two interfaces and a class that implements both. Create two generic methods, one whose argument parameter is bounded by the first interface and one whose argument parameter is bounded by the second interface. Create an instance of the class that implements both interfaces, and show that it can be used with both generic methods.</p>
</section>
<section>
<title>
<p>Wildcards</p></title><empty-line/>
<p>You’ve already seen some simple uses of wildcards—question marks in generic argument expressions—in the Holding Your Objects chapter and more in the Type Information chapter. This section will explore the issue more deeply.</p>
<p>We’ll start with an example that shows a particular behavior of arrays: You can assign an array of a derived type to an array reference of the base type:</p>
<p>//: generics/CovariantArrays.java class Fruit {}</p>
<p>class Apple extends Fruit {} class Jonathan extends Apple {} class Orange extends Fruit {}</p>
<p>public class CovariantArrays {</p>
<p>public static void main(String[] args) {</p>
<p>Fruit[] fruit = new Apple[10]; fruit[0] = new Apple(); // OK fruit[1] = new Jonathan(); // OK</p>
<p>// Runtime type is Apple[], not Fruit[] or Orange[]: try {</p>
<p>// Compiler allows you to add Fruit: fruit[0] = new Fruit(); // ArrayStoreException } catch(Exception e) { System.out.println(e); } try {</p>
<p>// Compiler allows you to add Oranges: fruit[0] = new Orange(); // ArrayStoreException } catch(Exception e) { System.out.println(e); }</p>
<p>}</p>
<p>} /* Output:</p>
<p>java.lang.ArrayStoreException: Fruit java.lang.ArrayStoreException: Orange *///:~</p>
<p>The first line in main( ) creates an array of Apple and assigns it to a reference to an array of Fruit. This makes sense—an Apple is a kind of Fruit, so an array of Apple should also be an array of Fruit.</p>
<p>However, if the actual array type is Apple [], you should only be able to place an Apple or a subtype of Apple into the array, which in fact works at both compile time and run time. But notice that the compiler allows you to place a Fruit object into the array. This makes sense to the compiler, because it has a Fruit[] reference—why shouldn’t it allow a Fruit object, or anything descended from Fruit, such as Orange, to be placed into the array? So at compile</p>
<p>time, this is allowed. The runtime array mechanism, however, knows that it’s dealing with an Apple [] and throws an exception when a foreign type is placed into the array.</p>
<p>&quot;Upcast&quot; is actually rather a misnomer here. What you’re really doing is assigning one array to another. The array behavior is that it holds other objects, but because we are able to upcast, it’s clear that the array objects can preserve the rules about the type of objects they contain. It’s as if the arrays are conscious of what they are holding, so between the compiletime checks and the runtime checks, you can’t abuse them.</p>
<p>This arrangement for arrays is not so terrible, because you do find out at run time that you’ve inserted an improper type. But one of the primary goals of generics is to move such error detection to compile time. So what happens when we try to use generic containers instead of arrays?</p>
<p>//: generics/NonCovariantGenerics.java // {CompileTimeError} (Won’t compile) import java.util.*;</p>
<p>public class NonCovariantGenerics {</p>
<p>// Compile Error: incompatible types:</p>
<p>List&lt;Fruit&gt; flist = new ArrayList&lt;Apple&gt;();</p>
<p>Although you may at first read this as saying, &quot;You can’t assign a container of Apple to a container of Fruit,&quot; remember that generics are not just about containers. What it’s really saying is, &quot;You can’t assign a generic involving Apples to a generic involving Fruit.&quot; If, as in the case of arrays, the compiler knew enough about the code to determine that containers were involved, perhaps it could give some leeway. But it doesn’t know anything like that, so it refuses to allow the &quot;upcast.&quot; But it really isn’t an &quot;upcast&quot; anyway—a List of Apple is not a List of Fruit. A List of Apple will hold Apples and subtypes of Apple, and a List of Fruit will hold any kind of Fruit. Yes, including Apples, but that doesn’t make it a List of Apple; it’s still a List of Fruit. A List of Apple is not type-equivalent to a List of Fruit, even if an Apple is a type of Fruit.</p>
<p>The real issue is that we are talking about the type of the container, rather than the type that the container is holding. Unlike arrays, generics do not have built-in covariance. This is because arrays are completely defined in the language and can thus have both compile-time and runtime checks built in, but with generics, the compiler and runtime system cannot know what you want to do with your types and what the rules should be.</p>
<p>Sometimes, however, you’d like to establish some kind of upcasting relationship between the two. This is what wildcards allow.</p>
<p>//: generics/GenericsAndCovariance.java import java.util.*;</p>
<p>public class GenericsAndCovariance {</p>
<p>public static void main(String[] args) {</p>
<p>// Wildcards allow covariance:</p>
<p>List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;();</p>
<p>// Compile Error: can’t add any type of object:</p>
<p>// flist.add(new Apple());</p>
<p>// flist.add(new Fruit());</p>
<p>// flist.add(new Object()); flist.add(null); // Legal but uninteresting // We know that it returns at least Fruit:</p>
<p>Fruit f = flist.get(0);</p>
<p>}</p>
<p>} ///:~</p>
<p>The type of flist is now List&lt;? extends Fruit&gt;, which you can read as &quot;a list of any type that’s inherited from Fruit.&quot; This doesn’t actually mean that the List will hold any type of Fruit, however. The wildcard refers to a definite type, so it means &quot;some specific type which the flist reference doesn’t specify.&quot; So the List that’s assigned has to be holding some specified type such as Fruit or Apple, but in order to upcast to flist, that type is a &quot;don’t actually care.&quot;</p>
<p>If the only constraint is that the List hold a specific Fruit or subtype of Fruit, but you don’t actually care what it is, then what can you do with such a List? If you don’t know what type the List is holding, how can you safely add an object? Just as with the &quot;upcast&quot; array in CovariantArrays.java, you can’t, except that the compiler prevents it from happening rather than the runtime system. You discover the problem sooner.</p>
<p>You might argue that things have gone a bit overboard, because now you can’t even add an Apple to a List that you just said would hold Apples. Yes, but the compiler doesn’t know that. A List&lt;? extends Fruit&gt; could legally point to a List&lt;Orange&gt;. Once you do this kind of &quot;upcast,&quot; you lose the ability to pass anything in, even an Object.</p>
<p>On the other hand, if you call a method that returns Fruit, that’s safe because you know that anything in the List must at least be of type Fruit, so the compiler allows it.</p>
<p>Exercise 26: (2) Demonstrate array covariance using Numbers and Integers.</p>
<p>Exercise 27: (2) Show that covariance doesn’t work with Lists, using Numbers and Integers, then introduce wildcards.</p>
<subtitle>How smart is the compiler?</subtitle>
<p>Now, you might guess that you are prevented from calling any methods that take arguments, but consider this:</p>
<p>//: generics/Compilerlntelligence.java import java.util.*;</p>
<p>public class CompilerIntelligence {</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;? extends Fruit&gt; flist =</p>
<p>Arrays.asList(new Apple());</p>
<p>Apple a = (Apple)flist.get(0); // No warning flist.contains(new Apple()); // Argument is ‘Object’ flist.indexOf(new Apple()); // Argument is ‘Object’</p>
<p>}</p>
<p>} ///:~</p>
<p>You can see calls to contains( ) and indexOf( ) that take Apple objects as arguments, and those are just fine. Does this mean that the compiler actually examines the code to see if a particular method modifies its object?</p>
<p>By looking at the documentation for ArrayList, we find that the compiler is not that smart. While add( ) takes an argument of the generic parameter type, contains( ) and indexOf( ) take arguments of type Object. So when you specify an ArrayList &lt;? extends Fruit &gt;, the argument for add( ) becomes’? extends Fruit’. From that description, the compiler cannot know which specific subtype of Fruit is required there, so it won’t accept any type of Fruit. It doesn’t matter if you upcast the Apple to a Fruit first—the compiler simply refuses to call a method (such as add( )) if a wildcard is involved in the argument list.</p>
<p>With contains( ) and indexOf( ), the arguments are of type Object, so there are no wildcards involved and the compiler allows the call. This means that it’s up to the generic class designer to decide which calls are &quot;safe,&quot; and to use Object types for their arguments. To disallow a call when the type is used with wildcards, use the type parameter in the argument list.</p>
<p>You can see this in a very simple Holder class:</p>
<p>//: generics/Holder.java</p>
<p>public class Holder&lt;T&gt; { private T value; public Holder() {}</p>
<p>public Holder(T val) { value = val; } public void set(T val) { value = val; } public T get() { return value; } public boolean equals(Object obj) { return value.equals(obj);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Holder&lt;Apple&gt; Apple = new Holder&lt;Apple&gt;(new Apple());</p>
<p>Apple d = Apple.get();</p>
<p>Apple.set(d);</p>
<p>//    Holder&lt;Fruit&gt;    Fruit = Apple; // Cannot    upcast</p>
<p>Holder&lt;? extends    Fruit&gt; fruit    = Apple; //    OK</p>
<p>Fruit p = fruit.get();</p>
<p>d = (Apple)fruit.get(); // Returns ‘Object’ try {</p>
<p>Orange c = (Orange)fruit.get(); // No warning } catch(Exception e) { System.out.println(e); }</p>
<p>//    fruit.set(new    Apple()); //    Cannot call    set()</p>
<p>//    fruit.set(new    Fruit()); //    Cannot call    set()</p>
<p>System.out.println(fruit.equals(d)); // OK</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>java.lang.ClassCastException: Apple cannot be cast to Orange</p>
<p>true</p>
<p>*///:~</p>
<p>Holder has a set( ) which takes a T, a get( ) which returns a T, and an equals( ) that takes an Object. As you’ve already seen, if you create a Holder&lt;Apple&gt;, you cannot upcast it to a Holder&lt;Fruit&gt;, but you can upcast to a Holder&lt;? extends Fruit&gt;. If you call get( ), it only returns a Fruit—that’s as much as it knows given the &quot;anything that extends Fruit&quot; bound. If you know more about what’s there, you can cast to a specific type of Fruit and there won’t be any warning about it, but you risk a ClassCastException. The set( ) method won’t work with either an Apple or a Fruit, because the set( ) argument is also &quot;? Extends Fruit,&quot; which means it can be anything and the compiler can’t verify type safety for &quot;anything.&quot;</p>
<p>However, the equals( ) method works fine because it takes an Object instead of a T as an argument. Thus, the compiler is only paying attention to the types of objects that are passed and returned. It is not analyzing the code to see if you perform any actual writes or reads.</p>
<subtitle>Contravariance</subtitle>
<p>It’s also possible to go the other way, and use supertype wildcards. Here, you say that the wildcard is bounded by any base class of a particular class, by specifying &lt;? super MyClass&gt; or even using a type parameter: &lt;? super T&gt; (although you cannot give a generic parameter a supertype bound; that is, you cannot say &lt;T super MyClass&gt;). This allows you to safely pass a typed object into a generic type. Thus, with supertype wildcards you can write into a Collection:</p>
<p>//: generics/SuperTypeWildcards.java import java.util.*;</p>
<p>public class SuperTypeWildcards {</p>
<p>static void writeTo(List&lt;? super Apple&gt; apples) { apples.add(new Apple()); apples.add(new Jonathan());</p>
<p>// apples.add(new Fruit()); // Error</p>
<p>}</p>
<p>} ///:~</p>
<p>The argument apples is a List of some type that is the base type of Apple; thus you know that it is safe to add an Apple or a subtype of Apple. Since the lower bound is Apple, however, you don’t know that it is safe to add Fruit to such a List, because that would allow the List to be opened up to the addition of non-Apple types, which would violate static type safety.</p>
<p>You can thus begin to think of subtype and supertype bounds in terms of how you can &quot;write&quot; (pass into a method) to a generic type, and &quot;read&quot; (return from a method) from a generic <sup>t</sup>yp<sup>e</sup>.</p>
<p>Supertype bounds relax the constraints on what you can pass into a method:</p>
<p>//: generics/GenericWriting.java import java.util.*;</p>
<p>public class GenericWriting {</p>
<p>static &lt;T&gt; void writeExact(List&lt;T&gt; list, T item) { list.add(item);</p>
<p>}</p>
<p>static List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;(); static List&lt;Fruit&gt; fruit = new ArrayList&lt;Fruit&gt;(); static void f1() {</p>
<p>writeExact(apples, new Apple());</p>
<p>// writeExact(fruit, new Apple()); // Error:</p>
<p>// Incompatible types: found Fruit, required Apple</p>
<p>}</p>
<p>static &lt;T&gt; void</p>
<p>writeWithWildcard(List&lt;? super T&gt; list, T item) { list.add(item);</p>
<p>}</p>
<p>static void f2() {</p>
<p>writeWithWildcard(apples, new Apple()); writeWithWildcard(fruit, new Apple());</p>
<p>}</p>
<p>public static void main(String[] args) { f1(); f2(); }</p>
<p>} ///:~</p>
<p>The writeExact( ) method uses an exact parameter type (no wildcards). In fi( ) you can see that this works fine—as long as you only put an Apple into a List&lt;Apple&gt;. However, writeExact( ) does not allow you to put an Apple into a List&lt;Fruit&gt;, even though you know that should be possible.</p>
<p>In writeWithWildcard( ), the argument is now a List&lt;? super T&gt;, so the List holds a specific type that is derived from T; thus it is safe to pass a T or anything derived from T as an argument to List methods. You can see this in f2( ), where it’s still possible to put an Apple into a List&lt;Apple&gt;, as before, but it is now also possible to put an Apple into a List&lt;Fruit&gt;, as you expect.</p>
<p>We can perform this same type of analysis as a review of covariance and wildcards:</p>
<p>//: generics/GenericReading.java import java.util.*;</p>
<p>public class GenericReading {</p>
<p>static &lt;T&gt; T readExact(List&lt;T&gt; list) { return list.get(0);</p>
<p>}</p>
<p>static List&lt;Apple&gt; apples = Arrays.asList(new Apple()); static List&lt;Fruit&gt; fruit = Arrays.asList(new Fruit());</p>
<p>// A static method adapts to each call: static void f1() {</p>
<p>Apple a = readExact(apples);</p>
<p>Fruit f = readExact(fruit); f = readExact(apples);</p>
<p>}</p>
<p>// If, however, you have a class, then its type is // established when the class is instantiated: static class Reader&lt;T&gt; {</p>
<p>T readExact(List&lt;T&gt; list) { return list.get(0); }</p>
<p>}</p>
<p>static void f2() {</p>
<p>Reader&lt;Fruit&gt; fruitReader = new Reader&lt;Fruit&gt;();</p>
<p>Fruit f = fruitReader.readExact(fruit);</p>
<p>// Fruit a = fruitReader.readExact(apples); // Error:</p>
<p>// readExact(List&lt;Fruit&gt;) cannot be // applied to (List&lt;Apple&gt;).</p>
<p>}</p>
<p>static class CovariantReader&lt;T&gt; {</p>
<p>T readCovariant(List&lt;? extends T&gt; list) { return list.get(0);</p>
<p>}</p>
<p>}</p>
<p>static void f3() {</p>
<p>CovariantReader&lt;Fruit&gt; fruitReader = new CovariantReader&lt;Fruit&gt;();</p>
<p>Fruit f = fruitReader.readCovariant(fruit);</p>
<p>Fruit a = fruitReader.readCovariant(apples);</p>
<p>}</p>
<p>public static void main(String[] args) { fi(); f2(); f3();</p>
<p>}</p>
<p>} ///:~</p>
<p>As before, the first method readExact( ) uses the precise type. So if you use the precise type with no wildcards, you can both write and read that precise type into and out of a List. In addition, for the return value, the static generic method readExact( ) effectively &quot;adapts&quot; to each method call, and returns an Apple from a List&lt;Apple&gt; and a Fruit from a List&lt;Fruit&gt;, as you can see in f1( ). Thus, if you can get away with a static generic method, you don’t necessarily need covariance if you’re just reading.</p>
<p>If you have a generic class, however, the parameter is established for the class when you make an instance of that class. As you can see in f2( ), the fruitReader instance can read a piece of Fruit from a List&lt;Fruit&gt;, since that is its exact type. But a List&lt;Apple&gt; should also produce Fruit objects, and the fruitReader doesn’t allow this.</p>
<p>To fix the problem, the CovariantReader.readCovariant( ) method takes a List&lt;? extends T&gt;, and so it’s safe to read a T from that list (you know that everything in that list is at least a T, and possibly something derived from a T). In f3( ) you can see that it’s now possible to read a Fruit from a List&lt;Apple&gt;.</p>
<p>Exercise 28: (4) Create a generic class Generici&lt;T&gt; with a single method that takes an argument of type T. Create a second generic class Generic2&lt;T&gt; with a single method that returns an argument of type T. Write a generic method with a contravariant argument of the first generic class that calls its method. Write a second generic method with a covariant argument of the second generic class that calls its method. Test using the typeinfo.pets library.</p>
<subtitle>Unbounded wildcards</subtitle>
<p>The unbounded wildcard &lt;?&gt; appears to mean &quot;anything,&quot; and so using an unbounded wildcard seems equivalent to using a raw type. Indeed, the compiler seems at first to agree with this assessment:</p>
<p>//: generics/UnboundedWildcardsl.java import java.util.*;</p>
<p>public class UnboundedWildcardsl {</p>
<p>static List listl;</p>
<p>static List&lt;?&gt; list2;</p>
<p>static List&lt;? extends Object&gt; list3;</p>
<p>static void assign1(List list) { listl = list; list2 = list;</p>
<p>// list3 = list; // Warning: unchecked conversion // Found: List, Required: List&lt;? extends Object&gt;</p>
<p>}</p>
<p>static void assign2(List&lt;?&gt; list) { listl = list; list2 = list; list3 = list;</p>
<p>}</p>
<p>static void assign3(List&lt;? extends Object&gt; list) { listl = list; list2 = list; list3 = list;</p>
<p>}</p>
<p>public static void main(String[] args) { assignl(new ArrayList()); assign2(new ArrayList());</p>
<p>// assign3(new ArrayList()); // Warning:</p>
<p>// Unchecked conversion. Found: ArrayList // Required: List&lt;? extends Object&gt; assignl(new ArrayList&lt;String&gt;()); assign2(new ArrayList&lt;String&gt;()); assign3(new ArrayList&lt;String&gt;());</p>
<p>// Both forms are acceptable as List&lt;?&gt;:</p>
<p>List&lt;?&gt; wildList = new ArrayList(); wildList = new ArrayList&lt;String&gt;(); assignl(wildList); assign2(wildList); assign3(wildList);</p>
<p>}</p>
<p>} ///:~</p>
<p>There are many cases like the ones you see here where the compiler could care less whether you use a raw type or &lt;?&gt;. In those cases, &lt;?&gt; can be thought of as a decoration; and yet it is valuable because, in effect, it says, &quot;I wrote this code with Java generics in mind, and I don’t mean here that I’m using a raw type, but that in this case the generic parameter can hold any</p>
<p><sup>t</sup>yp<sup>e</sup>.&quot;</p>
<p>A second example shows an important use of unbounded wildcards. When you are dealing with multiple generic parameters, it’s sometimes important to allow one parameter to be any type while establishing a particular type for the other parameter:</p>
<p>//: generics/UnboundedWildcards2.java import java.util.*;</p>
<p>public class UnboundedWildcards2 { static Map mapl; static Map&lt;?,?&gt; map2; static Map&lt;String,?&gt; map3;</p>
<p>static void assign1(Map map) { mapl = map; } static void assign2(Map&lt;?,?&gt; map) { map2 = map; } static void assign3(Map&lt;String,?&gt; map) { map3 = map; } public static void main(String[] args) { assign1(new HashMap()); assign2(new HashMap());</p>
<p>// assign3(new HashMap()); // Warning:</p>
<p>// Unchecked conversion. Found: HashMap // Required: Map&lt;String,?&gt; assign1(new HashMap&lt;String,Integer&gt;()); assign2(new HashMap&lt;String,Integer&gt;()); assign3(new HashMap&lt;String,Integer&gt;());</p>
<p>}</p>
<p>} ///:~</p>
<p>But again, when you have all unbounded wildcards, as seen in Map&lt;?,?&gt;, the compiler doesn’t seem to distinguish it from a raw Map. In addition, UnboundedWildcards1.java shows that the compiler treats List&lt;?&gt; and List&lt;? extends Object&gt; differently.</p>
<p>What’s confusing is that the compiler doesn’t always care about the difference between, for example, List and List&lt;?&gt;, so they can seem like the same thing. Indeed, since a generic argument erases to its first bound, List&lt;?&gt; would seem to be equivalent to List&lt;Object&gt;, and List is effectively List&lt;Object&gt; as well—except neither of those statements is exactly true. List actually means &quot;a raw List that holds any Object type,&quot; whereas List&lt;?&gt; means &quot;a non-raw List of some specific type, but we just don’t know what that type is.&quot;</p>
<p>When does the compiler actually care about the difference between raw types and types involving unbounded wildcards? The following example uses the previously defined Holder&lt;T&gt; class. It contains methods that take Holder as an argument, but in various forms: as a raw type, with a specific type parameter, and with an unbounded wildcard parameter:</p>
<p>//: generics/Wildcards.java // Exploring the meaning of wildcards.</p>
<p>public class Wildcards {</p>
<p>// Raw argument:</p>
<p>static void rawArgs(Holder holder, Object arg) {</p>
<p>// holder.set(arg); // Warning:</p>
<p>// Unchecked call to set(T) as a // member of the raw type Holder // holder.set(new Wildcards()); // Same warning</p>
<p>// Can’t do this; don’t have any ‘T’:</p>
<p>// T t = holder.get();</p>
<p>// OK, but type information has been lost:</p>
<p>Object obj = holder.get();</p>
<p>}</p>
<p>// Similar to rawArgs(), but errors instead of warnings: static void unboundedArg(Holder&lt;?&gt; holder, Object arg) { // holder.set(arg); // Error:</p>
<p>// set(capture of ?) in Holder&lt;capture of ?&gt;</p>
<p>// cannot be applied to (Object)</p>
<p>// holder.set(new Wildcards()); // Same error</p>
<p>// Can’t do this; don’t have any ‘T’:</p>
<p>// T t = holder.get();</p>
<p>// OK, but type information has been lost:</p>
<p>Object obj = holder.get();</p>
<p>}</p>
<p>static &lt;T&gt; T exact1(Holder&lt;T&gt; holder) {</p>
<p>T t = holder.get(); return t;</p>
<p>}</p>
<p>static &lt;T&gt; T exact2(Holder&lt;T&gt; holder, T arg) { holder.set(arg);</p>
<p>T t = holder.get(); return t;</p>
<p>}</p>
<p>static &lt;T&gt;</p>
<p>T wildSubtype(Holder&lt;? extends T&gt; holder, T arg) {</p>
<p>// holder.set(arg); // Error:</p>
<p>// set(capture of ? extends T) in // Holder&lt;capture of ? extends T&gt;</p>
<p>// cannot be applied to (T)</p>
<p>T t = holder.get(); return t;</p>
<p>}</p>
<p>static &lt;T&gt;</p>
<p>void wildSupertype(Holder&lt;? super T&gt; holder, T arg) { holder.set(arg);</p>
<p>// T t = holder.get(); // Error:</p>
<p>// Incompatible types: found Object, required T</p>
<p>// OK, but type information has been lost:</p>
<p>Object obj = holder.get();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Holder raw = new Holder&lt;Long&gt;();</p>
<p>// Or:</p>
<p>raw = new Holder();</p>
<p>Holder&lt;Long&gt; qualified = new Holder&lt;Long&gt;();</p>
<p>Holder&lt;?&gt; unbounded = new Holder&lt;Long&gt;();</p>
<p>Holder&lt;? extends Long&gt; bounded = new Holder&lt;Long&gt;(); Long lng = 1L;</p>
<p>rawArgs(raw, lng); rawArgs(qualified, lng); rawArgs(unbounded, lng); rawArgs(bounded, lng);</p>
<p>unboundedArg(raw, lng); unboundedArg(qualified, lng); unboundedArg(unbounded, lng);</p>
<p>unboundedArg(bounded, Ing);</p>
<p>// Object r1 = exactl(raw); // Warnings:</p>
<p>// Unchecked conversion from Holder to Holder&lt;T&gt;</p>
<p>// Unchecked method invocation: exact1(Holder&lt;T&gt;)</p>
<p>// is applied to (Holder)</p>
<p>Long r2 = exactl(qualified);</p>
<p>Object r3 = exactl(unbounded); // Must return Object Long r4 = exactl(bounded);</p>
<p>// Long r5 = exact2(raw, lng); // Warnings:</p>
<p>// Unchecked conversion from Holder to Holder&lt;Long&gt;</p>
<p>// Unchecked method invocation: exact2(Holder&lt;T&gt;,T)</p>
<p>// is applied to (Holder,Long)</p>
<p>Long r6 = exact2(qualified, lng);</p>
<p>// Long r7 = exact2(unbounded, lng); // Error:</p>
<p>// exact2(Holder&lt;T&gt;,T) cannot be applied to //    (Holder&lt;capture of ?&gt;,Long)</p>
<p>// Long r8 = exact2(bounded, lng); // Error:</p>
<p>// exact2(Holder&lt;T&gt;,T) cannot be applied // to (Holder&lt;capture of ? extends Long&gt;,Long)</p>
<p>// Long r9 = wildSubtype(raw, lng); // Warnings:</p>
<p>//    Unchecked conversion from Holder</p>
<p>//    to Holder&lt;? extends Long&gt;</p>
<p>//    Unchecked method invocation:</p>
<p>//    wildSubtype(Holder&lt;? extends    T&gt;,T) is</p>
<p>//    applied to (Holder,Long)</p>
<p>Long    r10 = wildSubtype(qualified,    lng);</p>
<p>// OK, but can only return Object:</p>
<p>Object rll = wildSubtype(unbounded, lng);</p>
<p>Long rl2 = wildSubtype(bounded, lng);</p>
<p>// wildSupertype(raw, lng); // Warnings:</p>
<p>//    Unchecked conversion from Holder</p>
<p>//    to Holder&lt;? super Long&gt;</p>
<p>//    Unchecked method invocation:</p>
<p>//    wildSupertype(Holder&lt;?    super    T&gt;,T)</p>
<p>//    is applied to (Holder,Long)</p>
<p>wildSupertype(qualified, lng);</p>
<p>//    wildSupertype(unbounded,    lng);    // Error:</p>
<p>//    wildSupertype(Holder&lt;?    super    T&gt;,T)    cannot be</p>
<p>// applied to (Holder&lt;capture of ?&gt;,Long)</p>
<p>// wildSupertype(bounded, lng); // Error:</p>
<p>// wildSupertype(Holder&lt;? super T&gt;,T) cannot be // applied to (Holder&lt;capture of ? extends Long&gt;,Long)</p>
<p>}</p>
<p>} ///:~</p>
<p>In rawArgs( ), the compiler knows that Holder is a generic type, so even though it is expressed as a raw type here, the compiler knows that passing an Object to set( ) is unsafe. Since it’s a raw type, you can pass an object of any type into set( ), and that object is upcast to Object. So anytime you have a raw type, you give up compile-time checking. The call to get( ) shows the same issue: There’s no T, so the result can only be an Object.</p>
<p>It’s easy to start thinking that a raw Holder and a Holder&lt;?&gt; are roughly the same thing. But unboundedArg( ) emphasizes that they are differentit discovers the same kind of problems, but reports them as errors rather than warnings, because the raw Holder will hold a combination of any types, whereas a Holder&lt;?&gt; holds a homogeneous collection of some specific type, and thus you can’t just pass in an Object.</p>
<p>In exact1( ) and exact2( ), you see the exact generic parameters used—no wildcards. You’ll see that exact2( ) has different limitations than exact1( ), because of the extra argument.</p>
<p>In wildSubtype( ), the constraints on the type of Holder are relaxed to include a Holder of anything that extends T. Again, this means that T could be Fruit, while holder could legitimately be a Holder&lt;Apple&gt;. To prevent putting an Orange in a Holder&lt;Apple&gt;, the call to set( ) (or any method that takes an argument of the type parameter) is disallowed. However, you still know that anything that comes out of a Holder&lt;? extends Fruit&gt; will at least be Fruit, so get( ) (or any method that produces a return value of the type parameter) is allowed.</p>
<p>Supertype wildcards are shown in wildSupertype( ), which shows the opposite behavior of wildSubtype( ): holder can be a container that holds any type that’s a base class of T. Thus, set( ) can accept a T, since anything that works with a base type will polymorphically work with a derived type (thus a T). However, trying to call get( ) is not helpful, because the type held by holder can be any supertype at all, so the only safe one is Object.</p>
<p>This example also shows the limitations on what you can and can’t do with an unbounded parameter in unbounded( ): You can’t get( ) or set( ) a T because you don’t have a T.</p>
<p>In main( ) you can see which of these methods can accept which types of arguments without errors and warnings. For migration compatibility, rawArgs( ) will take all the different variations of Holder without producing warnings. The unboundedArg( ) method is equally accepting of all types, although, as previously noted, it handles them differently inside the body of the method.</p>
<p>If you pass a raw Holder reference into a method that takes an &quot;exact&quot; generic type (no wildcards), you get a warning because the exact argument is expecting information that doesn’t exist in the raw type. And if you pass an unbounded reference to exact1( ), there’s no type information to establish the return type.</p>
<p>You can see that exact2( ) has the most constraints, since it wants exactly a Holder&lt;T&gt; and an argument of type T, and because of this it generates errors or warnings unless you give it the exact arguments. Sometimes this is OK, but if it’s overconstraining, then you can use wildcards, depending on whether you want to get typed return values from your generic argument (as seen in wildSubtype( )) or you want to pass typed arguments to your generic argument (as seen in wildSupertype( )).</p>
<p>Thus, the benefit of using exact types instead of wildcard types is that you can do more with the generic parameters. But using wildcards allows you to accept a broader range of parameterized types as arguments. You must decide which trade-off is more appropriate for your needs on a case-by-case basis.</p>
<subtitle>Capture conversion</subtitle>
<p>One situation in particular requires the use of &lt;?&gt; rather than a raw type. If you pass a raw type to a method that uses &lt;?&gt;, it’s possible for the compiler to infer the actual type parameter, so that the method can turn around and call another method that uses the exact type. The following example demonstrates the technique, which is called capture conversion because the unspecified wildcard type is captured and converted to an exact type. Here, the comments about warnings only take effect when the @SuppressWarnings annotation is removed: //: generics/CaptureConversion.java</p>
<p>public class CaptureConversion {</p>
<p>static &lt;T&gt; void f1(Holder&lt;T&gt; holder) {</p>
<p>T t = holder.get();</p>
<p>System.out.println(t.getClass().getSimpleName());</p>
<p>}</p>
<p>static void f2(Holder&lt;?&gt; holder) {</p>
<p>fl(holder); // Call with captured type</p>
<p>}</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public static void main(String[] args) {</p>
<p>Holder raw = new Holder&lt;Integer&gt;(1);</p>
<p>// fl(raw); // Produces warnings</p>
<p>f2(raw); // No warnings</p>
<p>Holder rawBasic = new Holder();</p>
<p>rawBasic.set(new Object()); // Warning</p>
<p>f2(rawBasic); // No warnings</p>
<p>// Upcast to Holder&lt;?&gt;, still figures it out:</p>
<p>Holder&lt;?&gt; wildcarded = new Holder&lt;Double&gt;(1.0);</p>
<p>f2(wildcarded);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Integer</p>
<p>Object</p>
<p>Double</p>
<p>*///:~</p>
<p>The type parameters in fi( ) are all exact, without wildcards or bounds. In f2( ), the Holder parameter is an unbounded wildcard, so it would seem to be effectively unknown. However, within f2( ), f1( ) is called and f1( ) requires a known parameter. What’s happening is that the parameter type is captured in the process of calling f2( ), so it can be used in the call to</p>
<p>f1( ).</p>
<p>You might wonder if this technique could be used for writing, but that would require you to pass a specific type along with the Holder&lt;?&gt;. Capture conversion only works in situations where, within the method, you need to work with the exact type. Notice that you can’t return T from f2( ), because T is unknown for f2( ). Capture conversion is interesting, but quite limited.</p>
<p>Exercise 29: (5) Create a generic method that takes as an argument a Holder&lt;List&lt;?&gt;&gt;. Determine what methods you can and can’t call for the Holder and for the List. Repeat for an argument of List&lt;Holder&lt;?&gt;&gt;.</p>
</section>
<section>
<title>
<p>Issues</p></title><empty-line/>
<p>This section addresses an assorted set of issues that appear when you are using Java generics.</p>
<subtitle>No primitives as type parameters</subtitle>
<p>As mentioned earlier in this chapter, one of the limitations you will discover in Java generics is that you cannot use primitives as type parameters. So you cannot, for example, create an ArrayList&lt; int&gt;.</p>
<p>The solution is to use the primitive wrapper classes in conjunction with Java SE5 autoboxing. If you create an ArrayList&lt; Integer&gt; and use primitive ints with this container, you’ll discover that autoboxing does the conversion to and from Integer automatically—so it’s almost as if you have an Ar r ayList &lt; int &gt;:</p>
<p>//: generics/ListOflnt.java</p>
<p>// Autoboxing compensates for the inability to use // primitives in generics. import java.util.*;</p>
<p>public class ListOfInt {</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; 5; i++) li.add(i); for(int i : li)</p>
<p>System.out.print(i + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>0 1 2 3 4 *///:~</p>
<p>Note that autoboxing even allows the foreach syntax to produce ints.</p>
<p>In general this solution works fine—you’re able to successfully store and retrieve ints. There happen to be some conversions going on but these are hidden from you. However, if performance is a problem, you can use a specialized version of the containers adapted for primitive types; one opensource version of this is org.apache.commons.collections.primitives.</p>
<p>Here’s another approach, which creates a Set of Bytes:</p>
<p>//: generics/ByteSet.java import java.util.*;</p>
<p>public class ByteSet {</p>
<p>Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };</p>
<p>Set&lt;Byte&gt; mySet =</p>
<p>new HashSet&lt;Byte&gt;(Arrays.asList(possibles));</p>
<p>// But you can’t do this:</p>
<p>// Set&lt;Byte&gt; mySet2 = new HashSet&lt;Byte&gt;(</p>
<p>//    Arrays.&lt;Byte&gt;asList(1,2,3,4,5,6,7,8,9));</p>
<p>} ///:~</p>
<p>Notice that autoboxing solves some problems, but not all. The following example shows a generic Generator interface that specifies a next( ) that returns an object of the parameter type. The FArray class contains a generic method that uses a generator to fill an array with objects (making the class generic wouldn’t work in this case because the method is static). The Generator implementations come from the Arrays chapter, and in main( ) you can see FArray.filK ) used to fill arrays with objects:</p>
<p>//: generics/PrimitiveGenericTest.java import net.mindview.util.*;</p>
<p>// Fill an array using a generator: class FArray {</p>
<p>public static &lt;T&gt; T[] fill(T[] a, Generator&lt;T&gt; gen) { for(int i = 0; i &lt; a.length; i++) a[i] = gen.next(); return a;</p>
<p>}</p>
<p>}</p>
<p>public class PrimitiveGenericTest {</p>
<p>public static void main(String[] args) {</p>
<p>String[] strings = FArray.fill(</p>
<p>new String[7], new RandomGenerator.String(10)); for(String s : strings)</p>
<p>System.out.println(s);</p>
<p>Integer[] integers = FArray.fill(</p>
<p>new Integer[7], new RandomGenerator.Integer()); for(int i: integers)</p>
<p>System.out.println(i);</p>
<p>// Autoboxing won’t save you here. This won’t compile: // int[] b =</p>
<p>// FArray.fill(new int[7], new RandIntGenerator());</p>
<p>}</p>
<p>} /* Output:</p>
<p>YNzbrnyGcF</p>
<p>OWZnTcQrGs</p>
<p>eGZMmJMRoE</p>
<p>suEcUOneOE</p>
<p>dLsmwHLGEa</p>
<p>hKcxrEqUCB</p>
<p>bkInaMesbt</p>
<p>7052</p>
<p>6665</p>
<p>2654</p>
<p>3909</p>
<p>5202</p>
<p>2209</p>
<p>5458</p>
<p>*///:~</p>
<p>Since RandomGenerator.Integer implements Generator&lt;Integer&gt;, my hope was that autoboxing would automatically convert the value of next( ) from Integer to int. However, autoboxing doesn’t apply to arrays, so this won’t work.</p>
<p>Exercise 30: (2) Create a Holder for each of the primitive wrapper types, and show that autoboxing and autounboxing works for the set( ) and get( ) methods of each instance.</p>
<subtitle>Implementing parameterized interfaces</subtitle>
<p>A class cannot implement two variants of the same generic interface. Because of erasure, these are both the same interface. Here’s a situation where this clash occurs:</p>
<p>//: generics/MultipleInterfaceVariants.java // {CompileTimeError} (Won’t compile)</p>
<p>interface Payable&lt;T&gt; {}</p>
<p>class Employee implements Payable&lt;Employee&gt; {} class Hourly extends Employee</p>
<p>implements Payable&lt;Hourly&gt; {} ///:~</p>
<p>Hourly won’t compile because erasure reduces Payable&lt;Employee&gt; and Payable&lt;Hourly&gt; to the same class, Payable, and the above code would mean that you’d be implementing the same interface twice. Interestingly enough, if you remove the generic parameters from both uses of Payable—as the compiler does during erasure—the code compiles.</p>
<p>This issue can become annoying when you are working with some of the more fundamental Java interfaces, such as Comparable&lt;T&gt;, as you’ll see a little later in this section.</p>
<p>Exercise 31: (1) Remove all the generics from MultipleInterfaceVariants.java and</p>
<p>modify the code so that the example compiles.</p>
<subtitle>Casting and warnings</subtitle>
<p>Using a cast or instanceof with a generic type parameter doesn’t have any effect. The following container stores values internally as Objects and casts them back to T when you fetch them:</p>
<p>//: generics/GenericCast.java</p>
<p>class FixedSizeStack&lt;T&gt; { private int index = 0; private Object[] storage; public FixedSizeStack(int size) { storage = new Object[size];</p>
<p>}</p>
<p>public void push(T item) { storage[index++] = item; }</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public T pop() { return (T)storage[--index]; }</p>
<p>}</p>
<p>public class GenericCast {</p>
<p>public static final int SIZE = 10; public static void main(String[] args) {</p>
<p>FixedSizeStack&lt;String&gt; strings = new FixedSizeStack&lt;String&gt;(SIZE); for(String s : &quot;A B C D E F G H I J&quot;.split(&quot; &quot;)) strings.push(s); for(int i = 0; i &lt; SIZE; i++) {</p>
<p>String s = strings.pop();</p>
<p>System.out.print(s + &quot; &quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>J I H G F E D C B A *///:~</p>
<p>Without the @SuppressWarnings annotation, the compiler will produce an &quot;unchecked cast&quot; warning for pop( ). Because of erasure, it can’t know whether the cast is safe, and the pop( ) method doesn’t actually do any casting. T is erased to its first bound, which is Object by default, so pop( ) is actually just casting an Object to an Object.</p>
<p>There are times when generics do not eliminate the need to cast, and this generates a warning by the compiler which is inappropriate. For example:</p>
<p>//: generics/NeedCasting.java import java.io.*; import java.util.*;</p>
<p>public class NeedCasting {</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public void f(String[] args) throws Exception {</p>
<p>ObjectInputStream in = new ObjectInputStream( new FileInputStream(args[0]));</p>
<p>List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)in.readObject();</p>
<p>} ///:~</p>
<p>As you’ll learn in the next chapter, readObject( ) cannot know what it is reading, so it returns an object that must be cast. But when you comment out the @SuppressWarnings annotation and compile the program, you get a warning:</p>
<p>Note: NeedCasting.Java uses unchecked or unsafe operations.</p>
<p>Note: Recompile with -Xlint:unchecked for details.</p>
<p>And if you follow the instructions and recompile with -Xlint:unchecked:</p>
<p>NeedCasting.Java:12: warning: [unchecked] unchecked cast found : java.lang.Object required: java.uti1.List&lt;Widget&gt;</p>
<p>List&lt;Shape&gt; shapes = (List&lt;Widget&gt;)in.readObject();</p>
<p>You’re forced to cast, and yet you’re told you shouldn’t. To solve the problem, you must use a new form of cast introduced in Java SE5, the cast via a generic class:</p>
<p>//: generics/ClassCasting.java import java.io.*; import java.util.*;</p>
<p>public class ClassCasting {</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public void f(String[] args) throws Exception {</p>
<p>ObjectInputStream in = new ObjectInputStream( new FileInputStream(args[0]));</p>
<p>// Won’t Compile:</p>
<p>//    List&lt;Widget&gt; lw1 =</p>
<p>//    List&lt;Widget&gt;.class.cast(in.readObject());</p>
<p>List&lt;Widget&gt; lw2 = List.class.cast(in.readObject());</p>
<p>}</p>
<p>} ///:~</p>
<p>However, you can’t cast to the actual type (List&lt;Widget&gt;). That is, you can’t say</p>
<p>List&lt;Widget&gt;.class.cast(in.readObject())</p>
<p>and even if you add another cast like this:</p>
<p>(List&lt;Widget&gt;)List.class.cast(in.readObject())</p>
<p>you’ll still get a warning.</p>
<p>Exercise 32: (1) Verify that FixedSizeStack in GenericCast.java generates exceptions if you try to go out of its bounds. Does this mean that bounds-checking code is not required?</p>
<p>Exercise 33: (3) Repair GenericCast.java using an ArrayList.</p>
<subtitle>Overloading</subtitle>
<p>This won’t compile, even though it’s a reasonable thing to try:</p>
<p>//: generics/UseList.java // {CompileTimeError} (Won’t compile) import java.util.*;</p>
<p>public class UseList&lt;W,T&gt; { void f(List&lt;T&gt; v) {} void f(List&lt;W&gt; v) {}</p>
<p>} ///:~</p>
<p>Overloading the method produces the identical type signature because of erasure.</p>
<p>Instead, you must provide distinct method names when the erased arguments do not produce a unique argument list:</p>
<p>//: generics/UseList2.java import java.util.*;</p>
<p>public class UseList2&lt;W,T&gt; { void f1(List&lt;T&gt; v) {} void f2(List&lt;W&gt; v) {}</p>
<p>} ///:~</p>
<p>Fortunately, this kind of problem is detected by the compiler.</p>
<subtitle>Base class hijacks an interface</subtitle>
<p>Suppose you have a Pet class that is Comparable to other Pet objects:</p>
<p>//: generics/ComparablePet.java</p>
<p>public class ComparablePet implements Comparable&lt;ComparablePet&gt; {</p>
<p>public int compareTo(ComparablePet arg) { return 0; }</p>
<p>} ///:~</p>
<p>It makes sense to try to narrow the type that a subclass of ComparablePet can be compared to. For example, a Cat should only be Comparable with other Cats:</p>
<p>//: generics/HijackedInterface.java // {CompileTimeError} (Won’t compile)</p>
<p>class Cat extends ComparablePet implements Comparable&lt;Cat&gt;{</p>
<p>// Error: Comparable cannot be inherited with // different arguments: &lt;Cat&gt; and &lt;Pet&gt; public int compareTo(Cat arg) { return 0; }</p>
<p>} ///:~</p>
<p>Unfortunately, this won’t work. Once the ComparablePet argument is established for Comparable, no other implementing class can ever be compared to anything but a ComparablePet:</p>
<p>//: generics/RestrictedComparablePets.java</p>
<p>class Hamster extends ComparablePet implements Comparable&lt;ComparablePet&gt; {</p>
<p>public int compareTo(ComparablePet arg) { return 0; }</p>
<p>}</p>
<p>// Or just:</p>
<p>class Gecko extends ComparablePet {</p>
<p>public int compareTo(ComparablePet arg) { return 0; }</p>
<p>} ///:~</p>
<p>Hamster shows that it is possible to reimplement the same interface that is in ComparablePet, as long as it is exactly the same, including the parameter types. However, this is the same as just overriding the methods in the base class, as seen in Gecko.</p>
</section>
<section>
<title>
<p>Self-bounded types</p></title><empty-line/>
<p>There’s one rather mind-bending idiom that appears periodically in Java generics. Here’s what it looks like:</p>
<p>class SelfBoundecKT extends SelfBounded&lt;T&gt;&gt; { // ...</p>
<p>This has the dizzying effect of two mirrors pointed at each other, a kind of infinite reflection. The class SelfBounded takes a generic argument T, T is constrained by a bound, and that bound is SelfBounded, with T as an argument.</p>
<p>This is difficult to parse when you first see it, and it emphasizes that the extends keyword, when used with bounds, is definitely different than when it is used to create subclasses.</p>
<subtitle>Curiously recurring generics</subtitle>
<p>To understand what a self-bounded type means, let’s start with a simpler version of the idiom, without the self-bound.</p>
<p>You can’t inherit directly from a generic parameter. However, you can inherit from a class that uses that generic parameter in its own definition. That is, you can say:</p>
<p>//: generics/CuriouslyRecurringGeneric.java</p>
<p>class GenericType&lt;T&gt; {}</p>
<p>public class CuriouslyRecurringGeneric</p>
<p>extends GenericType&lt;CuriouslyRecurringGeneric&gt; {} ///:~</p>
<p>This could be called curiously recurring generics (CRG) after Jim Coplien’s Curiously Recurring Template Pattern in C++. The &quot;curiously recurring&quot; part refers to the fact that your class appears, rather curiously, in its own base class.</p>
<p>To understand what this means, try saying it aloud: &quot;I’m creating a new class that inherits from a generic type that takes my class name as its parameter.&quot; What can the generic base type accomplish when given the derived class name? Well, generics in Java are about arguments and return types, so it can produce a base class that uses the derived type for its arguments and return types. It can also use the derived type for field types, even though those will be erased to Object. Here’s a generic class that expresses this: //: generics/BasicHolder.java</p>
<p>public class BasicHolder&lt;T&gt; {</p>
<p>T element;</p>
<p>void set(T arg) { element = arg; }</p>
<p>T get() { return element; } void f() {</p>
<p>System.out.println(element.getClass().getSimpleName());</p>
<p>}</p>
<p>} ///:~</p>
<p>It’s an ordinary generic type with methods that both accept and produce objects of the parameter type, along with a method that operates on the stored field (although it only performs Object operations on that field).</p>
<p>We can use BasicHolder in a curiously recurring generic:</p>
<p>//: generics/CRGWithBasicHolder.java</p>
<p>class Subtype extends BasicHolder&lt;Subtype&gt; {}</p>
<p>public class CRGWithBasicHolder {</p>
<p>public static void main(String[] args) {</p>
<p>Subtype st1 = new Subtype(), st2 = new Subtype(); st1.set(st2);</p>
<p>Subtype st3 = st1.get(); st1.f();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Subtype</p>
<p>*///:~</p>
<p>Notice something important here: The new class Subtype takes arguments and returns values of Subtype, not just the base class BasicHolder. This is the essence of CRG: The base class substitutes the derived class for its parameters. This means that the generic base class becomes a kind of template for common functionality for all its derived classes, but this functionality will use the derived type for all of its arguments and return values. That is, the exact type instead of the base type will be used in the resulting class. So in Subtype, both the argument to set( ) and the return type of get( ) are exactly Subtypes.</p>
<subtitle>Self-bounding</subtitle>
<p>The BasicHolder can use any type as its generic parameter, as seen here:</p>
<p>//: generics/Unconstrained.java class Other {}</p>
<p>class BasicOther extends BasicHolder&lt;Other&gt; {}</p>
<p>public class Unconstrained {</p>
<p>public static void main(String[] args) {</p>
<p>BasicOther b = new BasicOther(), b2 = new BasicOther(); b.set(new Other());</p>
<p>Other other = b.get(); b.f();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Other</p>
<p>*///:~</p>
<p>Self-bounding takes the extra step of forcing the generic to be used as its own bound argument. Look at how the resulting class can and can’t be used:</p>
<p>//: generics/SelfBounding.java</p>
<p>class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt; {</p>
<p>T element;</p>
<p>SelfBounded&lt;T&gt; set(T arg) { element = arg; return this;</p>
<p>}</p>
<p>T get() { return element; }</p>
<p>}</p>
<p>class A extends SelfBounded&lt;A&gt; {} class B extends SelfBounded&lt;A&gt; {} // Also OK</p>
<p>class C extends SelfBounded&lt;C&gt; {</p>
<p>C setAndGet(C arg) { set(arg); return get(); }</p>
<p>}</p>
<p>class D {}</p>
<p>// Can’t do this:</p>
<p>// class E extends SelfBounded&lt;D&gt; {}</p>
<p>// Compile error: Type parameter D is not within its bound</p>
<p>// Alas, you can do this, so you can’t force the idiom: class F extends SelfBounded {}</p>
<p>public class SelfBounding {</p>
<p>public static void main(String[] args) {</p>
<p>A a = new A(); a.set(new A()); a = a.set(new A()).get(); a = a.get();</p>
<p>C c = new C(); c = c.setAndGet(new C());</p>
<p>}</p>
<p>} ///:~</p>
<p>What self-bounding does is require the use of the class in an inheritance relationship like this:</p>
<p>class A extends SelfBounded&lt;A&gt; {}</p>
<p>This forces you to pass the class that you are defining as a parameter to the base class.</p>
<p>What’s the added value in self-bounding the parameter? The type parameter must be the same as the class being defined. As you can see in the definition of class B, you can also derive from a SelfBounded that uses a parameter of another SelfBounded, although the predominant use seems to be the one that you see for class A. The attempt to define E shows that you cannot use a type parameter that is not a SelfBounded.</p>
<p>Unfortunately, F compiles without warnings, so the self-bounding idiom is not enforceable. If it’s really important, it may require an external tool to ensure that raw types are not being used in place of parameterized types.</p>
<p>Notice that you can remove the constraint and all the classes will still compile, but E will also compile:</p>
<p>//: generics/NotSelfBounded.java</p>
<p>public class NotSelfBounded&lt;T&gt; {</p>
<p>T element;</p>
<p>NotSelfBounded&lt;T&gt; set(T arg) { element = arg; return this;</p>
<p>}</p>
<p>T get() { return element; }</p>
<p>}</p>
<p>C2 setAndGet(C2 arg) { set(arg); return get(); }</p>
<p>class D2 {}</p>
<p>// Now this is OK:</p>
<p>class E2 extends NotSelfBounded&lt;D2&gt; {} ///:~</p>
<p>So clearly, the self-bounding constraint serves only to force the inheritance relationship. If you use self-bounding, you know that the type parameter used by the class will be the same basic type as the class that’s using that parameter. It forces anyone using that class to follow that form.</p>
<p>It’s also possible to use self-bounding for generic methods:</p>
<p>//: generics/SelfBoundingMethods.java</p>
<p>public class SelfBoundingMethods {</p>
<p>static &lt;T extends SelfBounded&lt;T&gt;&gt; T f(T arg) { return arg.set(arg).get();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>A a = f(new A());</p>
<p>}</p>
<p>} ///:~</p>
<p>This prevents the method from being applied to anything but a self-bounded argument of the form shown.</p>
<subtitle>Argument covariance</subtitle>
<p>The value of self-bounding types is that they produce covariant argument types—method argument types vary to follow the subclasses.</p>
<p>Although self-bounding types also produce return types that are the same as the subclass type, this is not so important because covariant return types were introduced in Java SE5:</p>
<p>//: generics/CovariantReturnTypes.java class Base {}</p>
<p>class Derived extends Base {}</p>
<p>interface OrdinaryGetter {</p>
<p>Base get();</p>
<p>}</p>
<p>interface DerivedGetter extends OrdinaryGetter {</p>
<p>// Return type of overridden method is allowed to vary:</p>
<p>Derived get();</p>
<p>}</p>
<p>public class CovariantReturnTypes { void test(DerivedGetter d) {</p>
<p>Derived d2 = d.get();</p>
<p>}</p>
<p>} ///:~</p>
<p>The get( ) method in DerivedGetter overrides get( ) in OrdinaryGetter and returns a type that is derived from the type returned by OrdinaryGetter.get( ). Although this is a</p>
<p>perfectly logical thing to do—a derived type method should be able to return a more specific type than the base type method that it’s overriding—it was illegal in earlier versions of Java.</p>
<p>A self-bounded generic does in fact produce the exact derived type as a return value, as seen here with get( ):</p>
<p>//: generics/GenericsAndReturnTypes.java</p>
<p>interface GenericGetter&lt;T extends GenericGetter&lt;T&gt;&gt; {</p>
<p>T get();</p>
<p>}</p>
<p>interface Getter extends GenericGetter&lt;Getter&gt; {}</p>
<p>public class GenericsAndReturnTypes { void test(Getter g) {</p>
<p>Getter result = g.get();</p>
<p>GenericGetter gg = g.get(); // Also the base type</p>
<p>}</p>
<p>} ///:~</p>
<p>Notice that this code would not have compiled unless covariant return types were included in Java SE5.</p>
<p>In non-generic code, however, the argument types cannot be made to vary with the subtypes: //: generics/OrdinaryArguments.java</p>
<p>class OrdinarySetter { void set(Base base) {</p>
<p>System.out.println(&quot;OrdinarySetter.set(Base)&quot;);</p>
<p>}</p>
<p>}</p>
<p>class DerivedSetter extends OrdinarySetter { void set(Derived derived) {</p>
<p>System.out.println(&quot;DerivedSetter.set(Derived)&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class OrdinaryArguments {</p>
<p>public static void main(String[] args) {</p>
<p>Base base = new Base();</p>
<p>Derived derived = new Derived();</p>
<p>DerivedSetter ds = new DerivedSetter(); ds.set(derived);</p>
<p>ds.set(base); // Compiles: overloaded, not overridden!</p>
<p>}</p>
<p>} /* Output:</p>
<p>DerivedSetter.set(Derived)</p>
<p>OrdinarySetter.set(Base)</p>
<p>*///:~</p>
<p>Both set(derived) and set(base) are legal, so DerivedSetter.set( ) is not overriding OrdinarySetter.set( ), but instead it is overloading that method. From the output, you can see that there are two methods in DerivedSetter, so the base-class version is still available, thus verifying that it has been overloaded.</p>
<p>However, with self-bounding types, there is only one method in the derived class, and that method takes the derived type as its argument, not the base type: //: generics/SelfBoundingAndCovariantArguments.java</p>
<p>interface SelfBoundSetter&lt;T extends SelfBoundSetter&lt;T&gt;&gt; { void set(T arg);</p>
<p>}</p>
<p>interface Setter extends SelfBoundSetter&lt;Setter&gt; {}</p>
<p>public class SelfBoundingAndCovariantArguments {</p>
<p>void testA(Setter s1, Setter s2, SelfBoundSetter sbs) { s1.set(s2);</p>
<p>// s1.set(sbs); // Error:</p>
<p>// set(Setter) in SelfBoundSetter&lt;Setter&gt;</p>
<p>// cannot be applied to (SelfBoundSetter)</p>
<p>}</p>
<p>} ///:~</p>
<p>The compiler doesn’t recognize the attempt to pass in the base type as an argument to set( ), because there is no method with that signature. The argument has, in effect, been overridden.</p>
<p>Without self-bounding, the ordinary inheritance mechanism steps in, and you get overloading, just as with the non-generic case:</p>
<p>//: generics/PlainGenericInheritance.java</p>
<p>class GenericSetter&lt;T&gt; { // Not self-bounded void set(T arg){</p>
<p>System.out.println(&quot;GenericSetter.set(Base)&quot;);</p>
<p>}</p>
<p>}</p>
<p>class DerivedGS extends GenericSetter&lt;Base&gt; { void set(Derived derived){</p>
<p>System.out.println(&quot;DerivedGS.set(Derived)&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class PlainGenericInheritance { public static void main(String[] args) {</p>
<p>Base base = new Base();</p>
<p>Derived derived = new Derived();</p>
<p>DerivedGS dgs = new DerivedGS(); dgs.set(derived);</p>
<p>dgs.set(base); // Compiles: overloaded, not overridden!</p>
<p>}</p>
<p>} /* Output:</p>
<p>DerivedGS.set(Derived)</p>
<p>GenericSetter.set(Base)</p>
<p>*///:~</p>
<p>This code mimics OrdinaryArguments.java; in that example, DerivedSetter inherits from OrdinarySetter which contains a set(Base). Here, DerivedGS inherits from GenericSetter&lt;Base&gt; which also contains a set(Base), created by the generic. And just like OrdinaryArguments.java, you can see from the output that DerivedGS contains two overloaded versions of set( ). Without self-bounding, you overload on argument types. If you use self-bounding, you only end up with one version of a method, which takes the exact argument type.</p>
<p>Exercise 34: (4) Create a self-bounded generic type that contains an abstract method that takes an argument of the generic type parameter and produces a return value of the</p>
<p>generic type parameter. In a non-abstract method of the class, call the abstract method and return its result. Inherit from the self-bounded type and test the resulting class.</p>
</section>
<section>
<title>
<p>Dynamic type safety</p></title><empty-line/>
<p>Because you can pass generic containers to pre-Java SE5 code, there’s still the possibility that old-style code can corrupt your containers. Java SE5 has a set of utilities in java.util.Collections to solve the type-checking problem in this situation: the static methods checkedCollection( ), checkedList( ), checkedMap( ), checkedSet( ), checkedSortedMap( ) and checkedSortedSet( ). Each of these takes the container you want to dynamically check as the first argument and the type that you want to enforce as the second argument.</p>
<p>A checked container will throw a ClassCastException at the point you try to insert an improper object, as opposed to a pre-generic (raw) container which would inform you that there was a problem when you pulled the object out. In the latter case, you know there’s a problem but you don’t know who the culprit is, but with checked containers you find out who tried to insert the bad object.</p>
<p>Let’s look at the problem of &quot;putting a cat in a list of dogs&quot; using a checked container. Here, oldStyleMethod( ) represents legacy code because it takes a raw List, and the @SuppressWarnings(&quot;unchecked&quot;) annotation is necessary to suppress the resulting warning:</p>
<p>//: generics/CheckedList.java // Using Coltection.checkedListQ. import typeinfo.pets.*; import java.util.*;</p>
<p>public class CheckedList {</p>
<p>@SuppressWarnings(&quot;unchecked&quot;) static void oldStyleMethod(List probablyDogs) { probablyDogs.add(new Cat());</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;Dog&gt; dogs1 = new ArrayList&lt;Dog&gt;(); oldStyleMethod(dogs1); // Quietly accepts a Cat List&lt;Dog&gt; dogs2 = Collections.checkedList( new ArrayList&lt;Dog&gt;(), Dog.class); try {</p>
<p>oldStyleMethod(dogs2); // Throws an exception } catch(Exception e) {</p>
<p>System.out.println(e);</p>
<p>}</p>
<p>// Derived types work fine:</p>
<p>List&lt;Pet&gt; pets = Collections.checkedList( new ArrayList&lt;Pet&gt;(), Pet.class); pets.add(new Dog()); pets.add(new Cat());</p>
<p>}</p>
<p>} /* Output:</p>
<p>java.lang.ClassCastException: Attempt to insert class typeinfo.pets.Cat element into collection with element type class typeinfo.pets.Dog *///:~</p>
<p>When you run the program you’ll see that the insertion of a Cat goes unchallenged by dogs1, but dogs2 immediately throws an exception upon the insertion of an incorrect type. You can also see that it’s fine to put derived-type objects into a checked container that is checking for the base type.</p>
<p>Exercise 35: (1) Modify CheckedList.java so that it uses the Coffee classes defined in this chapter.</p>
</section>
<section>
<title>
<p>Exceptions</p></title><empty-line/>
<p>Because of erasure, the use of generics with exceptions is extremely limited. A catch clause cannot catch an exception of a generic type, because the exact type of the exception must be known at both compile time and run time. Also, a generic class can’t directly or indirectly inherit from Throwable (this further prevents you from trying to define generic exceptions that can’t be caught).</p>
<p>However, type parameters may be used in the throws clause of a method declaration. This allows you to write generic code that varies with the type of a checked exception:</p>
<p>//: generics/ThrowGenericException.java import java.util.*;</p>
<p>interface Processor&lt;T,E extends Exception&gt; { void process(List&lt;T&gt; resultCollector) throws E;</p>
<p>}</p>
<p>class ProcessRunner&lt;T,E extends Exception&gt; extends ArrayList&lt;Processor&lt;T,E&gt;&gt; {</p>
<p>List&lt;T&gt; processAll() throws E {</p>
<p>List&lt;T&gt; resultCollector = new ArrayList&lt;T&gt;(); for(Processor&lt;T,E&gt; processor : this) processor.process(resultCollector); return resultCollector;</p>
<p>}</p>
<p>}</p>
<p>class Failure1 extends Exception {}</p>
<p>class Processor1 implements Processor&lt;String,Failure1&gt; { static int count = 3; public void</p>
<p>process(List&lt;String&gt; resultCollector) throws Failure1 { if(count-- &gt; 1)</p>
<p>resultCollector.add(&quot;Hep!&quot;);</p>
<p>else</p>
<p>resultCollector.add(&quot;Ho!&quot;); if(count &lt; 0)</p>
<p>throw new Failure1();</p>
<p>}</p>
<p>}</p>
<p>class Failure2 extends Exception {}</p>
<p>class Processor2 implements Processor&lt;Integer,Failure2&gt; { static int count = 2; public void</p>
<p>process(List&lt;Integer&gt; resultCollector) throws Failure2 { if(count-- == 0)</p>
<p>resultCollector.add(47); else {</p>
<p>resultCollector.add(11);</p>
<p>}</p>
<p>if(count &lt; 0)</p>
<p>throw new Failure2();</p>
<p>}</p>
<p>public class ThrowGenericException {</p>
<p>public static void main(String[] args) {</p>
<p>ProcessRunner&lt;String,Failure1&gt; runner = new ProcessRunner&lt;String,Failure1&gt;(); for(int i = 0; i &lt; 3; i++) runner.add(new Processor1()); try {</p>
<p>System.out.println(runner.processAll());</p>
<p>} catch(Failure1 e) {</p>
<p>System.out.println(e);</p>
<p>}</p>
<p>ProcessRunner&lt;Integer,Failure2&gt; runner2 = new ProcessRunner&lt;Integer,Failure2&gt;(); for(int i = 0; i &lt; 3; i++)</p>
<p>runner2.add(new Processor2()); try {</p>
<p>System.out.println(runner2.processAll());</p>
<p>} catch(Failure2 e) {</p>
<p>System.out.println(e);</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>A Processor performs a process( ) and may throw an exception of type E. The result of the process( ) is stored in the List&lt;T&gt; resultCollector (this is called a collecting parameter). A ProcessRunner has a processAll( ) method that executes every Process object that it holds, and returns the resultCollector.</p>
<p>If you could not parameterize the exceptions that are thrown, you would be unable to write this code generically because of the checked exceptions.</p>
<p>Exercise 36: (2) Add a second parameterized exception to the Processor class and demonstrate that the exceptions can vary independently.</p>
</section>
<section>
<title>
<p>Mixins</p></title><empty-line/>
<p>The term mixin seems to have acquired numerous meanings over time, but the fundamental concept is that of mixing in capabilities from multiple classes in order to produce a resulting class that represents all the types of the mixins. This is often something you do at the last minute, which makes it convenient to easily assemble classes.</p>
<p>One value of mixins is that they consistently apply characteristics and behaviors across multiple classes. As a bonus, if you want to change something in a mixin class, those changes are then applied across all the classes where the mixin is applied. Because of this, mixins have part of the flavor of aspect-oriented programming (AOP), and aspects are often suggested to solve the mixin problem.</p>
<subtitle>Mixins in C+ +</subtitle>
<p>One of the strongest arguments made for multiple inheritance in C++ is for the use of mixins. However, a more interesting and elegant approach to mixins is using parameterized types, whereby a mixin is a class that inherits from its type parameter. In C++, you can easily create mixins because C++ remembers the type of its template parameters.</p>
<p>Here’s a C++ example with two mixin types: one that allows you to mix in the property of having a time stamp, and another that mixes in a serial number for each object instance:</p>
<p>//: generics/Mixins.cpp #include &lt;string&gt;</p>
<p>#include &lt;ctime&gt;</p>
<p>#include &lt;iostream&gt; using namespace std;</p>
<p>template&lt;class T&gt; class TimeStamped : public T { long timeStamp; public:</p>
<p>TimeStamped() { timeStamp = time(0); } long getStamp() { return timeStamp; }</p>
<p>};</p>
<p>template&lt;class T&gt; class SerialNumbered : public T { long serialNumber; static long counter; public:</p>
<p>SerialNumbered() { serialNumber = counter++; } long getSerialNumber() { return serialNumber; }</p>
<p>};</p>
<p>// Define and initialize the static storage: template&lt;class T&gt; long SerialNumbered&lt;T&gt;::counter = 1;</p>
<p>class Basic { string value; public:</p>
<p>void set(string val) { value = val; } string get() { return value; }</p>
<p>};</p>
<p>int main() {</p>
<p>TimeStamped&lt;SerialNumbered&lt;Basic&gt; &gt; mixinl, mixin2; mixin1.set(&quot;test string 1&quot;); mixin2.set(&quot;test string 2&quot;);</p>
<p>cout &lt;&lt; mixin1.get() &lt;&lt; &quot; &quot; &lt;&lt; mixin1.getStamp() &lt;&lt; &quot; &quot; &lt;&lt; mixin1.getSeria!Number() &lt;&lt; endl; cout &lt;&lt; mixin2.get() &lt;&lt; &quot; &quot; &lt;&lt; mixin2.getStamp() &lt;&lt; &quot; &quot; &lt;&lt; mixin2.getSerialNumber() &lt;&lt; endl;</p>
<p>} /* Output: (Sample) test string 1 1129840250 1 test string 2 1129840250 2 *///:~</p>
<p>In main( ), the resulting type of mixini and mixin2 has all the methods of the mixed-in types. You can think of a mixin as a function that maps existing classes to new subclasses. Notice how trivial it is to create a mixin using this technique; basically, you just say, &quot;Here’s what I want,&quot; and it happens:</p>
<p>TimeStamped&lt;SerialNumbered&lt;Basic&gt; &gt; mixin1, mixin2;</p>
<p>Unfortunately, Java generics don’t permit this. Erasure forgets the base-class type, so a generic class cannot inherit directly from a generic parameter.</p>
<subtitle>Mixing with interfaces</subtitle>
<p>A commonly suggested solution is to use interfaces to produce the effect of mixins, like this:</p>
<p>//: generics/Mixins.java import java.util.*;</p>
<p>interface TimeStamped { long getStamp(); }</p>
<p>class TimeStampedImp implements TimeStamped { private final long timeStamp; public TimeStampedImp() {</p>
<p>timeStamp = new Date().getTime();</p>
<p>}</p>
<p>public long getStamp() { return timeStamp; }</p>
<p>}</p>
<p>interface SerialNumbered { long getSerialNumber(); }</p>
<p>class SerialNumberedImp implements SerialNumbered { private static long counter = 1; private final long serialNumber = counter++; public long getSerialNumber() { return serialNumber; }</p>
<p>}</p>
<p>interface Basic {</p>
<p>public void set(String val); public String get();</p>
<p>}</p>
<p>class BasicImp implements Basic { private String value;</p>
<p>public void set(String val) { value = val; } public String get() { return value; }</p>
<p>}</p>
<p>class Mixin extends BasicImp implements TimeStamped, SerialNumbered {</p>
<p>private TimeStamped timeStamp = new TimeStampedImp(); private SerialNumbered serialNumber = new SerialNumberedImp();</p>
<p>public long getStamp() { return timeStamp.getStamp(); } public long getSerialNumber() {</p>
<p>return serialNumber.getSerialNumber();</p>
<p>}</p>
<p>}</p>
<p>public class Mixins {</p>
<p>public static void main(String[] args) {</p>
<p>Mixin mixinl = new Mixin(), mixin2 = new Mixin(); mixin1.set(&quot;test string 1&quot;); mixin2.set(&quot;test string 2&quot;); System.out.println(mixin1.get() + &quot; &quot; +</p>
<p>mixin1.getStamp() +    &quot; &quot; + mixin1.getSerialNumber());</p>
<p>System.out.println(mixin2.get() + &quot; &quot; +</p>
<p>mixin2.getStamp() +    &quot; &quot; + mixin2.getSerialNumber());</p>
<p>}</p>
<p>} /* Output: (Sample) test string 1 1132437151359 1 test string 2 1132437151359 2 *///:~</p>
<p>The Mixin class is basically using delegation, so each mixed-in type requires a field in Mixin, and you must write all the necessary methods in Mixin to forward calls to the appropriate object. This example uses trivial classes, but with a more complex mixin the code grows rapidly.</p>
<p>Exercise 37: (2) Add a new mixin class Colored to Mixins.java, mix it into Mixin, and show that it works.</p>
<subtitle>Using the Decorator pattern</subtitle>
<p>When you look at the way that it is used, the concept of a mixin seems closely related to the Decorator design pattern.<a l:href="#bookmark64" type="note"><sup>65</sup></a><sup> <a l:href="#bookmark65" type="note"><sup>66</sup></a></sup> Decorators are often used when, in order to satisfy every possible combination, simple subclassing produces so many classes that it becomes impractical.</p>
<p>The Decorator pattern uses layered objects to dynamically and transparently add responsibilities to individual objects. Decorator specifies that all objects that wrap around your initial object have the same basic interface. Something is decoratable, and you layer on functionality by wrapping other classes around the decoratable. This makes the use of the decorators transparentthere are a set of common messages you can send to an object whether it has been decorated or not. A decorating class can also add methods, but as you shall see, this is limited.</p>
<p>Decorators are implemented using composition and formal structures (the decoratable/decorator hierarchy), whereas mixins are inheritance-based. So you could think of parameterized-type-based mixins as a generic decorator mechanism that does not require the inheritance structure of the Decorator design pattern.</p>
<p>The previous example can be recast using Decorator:</p>
<p>//: generics/decorator/Decoration.java package generics.decorator; import java.util.*;</p>
<p>class Basic {</p>
<p>private String value;</p>
<p>public void set(String val) { value = val; } public String get() { return value; }</p>
<p>}</p>
<p>class Decorator extends Basic { protected Basic basic;</p>
<p>public Decorator(Basic basic) { this.basic = basic; } public void set(String val) { basic.set(val); } public String get() { return basic.get(); }</p>
<p>}</p>
<p>class TimeStamped extends Decorator { private final long timeStamp; public TimeStamped(Basic basic) { super(basic);</p>
<p>timeStamp = new Date().getTime();</p>
<p>}</p>
<p>public long getStamp() { return timeStamp; }</p>
<p>}</p>
<p>class SerialNumbered extends Decorator { private static long counter = 1; private final long serialNumber = counter++; public SerialNumbered(Basic basic) { super(basic); } public long getSerialNumber() { return serialNumber; }</p>
<p>}</p>
<p>public class Decoration {</p>
<p>public static void main(String[] args) {</p>
<p>TimeStamped t = new TimeStamped(new Basic());</p>
<p>TimeStamped t2 = new TimeStamped( new SerialNumbered(new Basic()));</p>
<p>//! t2.getSerialNumber(); // Not available SerialNumbered s = new SerialNumbered(new Basic());</p>
<p>SerialNumbered s2 = new SerialNumbered( new TimeStamped(new Basic()));</p>
<p>//! s2.getStamp(); // Not available</p>
<p>}</p>
<p>} ///:~</p>
<p>The class resulting from a mixin contains all the methods of interest, but the type of the object that results from using decorators is the last type that it was decorated with. That is, although it’s possible to add more than one layer, the final layer is the actual type, so only the final layer’s methods are visible, whereas the type of the mixin is all the types that have been mixed together. So a significant drawback to Decorator is that it only effectively works with one layer of decoration (the final one), and the mixin approach is arguably more natural. Thus, Decorator is only a limited solution to the problem addressed by mixins.</p>
<p>Exercise 38: (4) Create a simple Decorator system by starting with basic coffee, then providing decorators of steamed milk, foam, chocolate, caramel and whipped cream.</p>
<subtitle>Mixins with dynamic proxies</subtitle>
<p>It’s possible to use a dynamic proxy to create a mechanism that more closely models mixins than does the Decorator (see the Type Information chapter for an explanation of how Java’s dynamic proxies work). With a dynamic proxy, the dynamic type of the resulting class is the combined types that have been mixed in.</p>
<p>Because of the constraints of dynamic proxies, each class that is mixed in must be the implementation of an interface:</p>
<p>//: generics/DynamicProxyMixin.java</p>
<p>import java.lang.reflect.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Tuple.*;</p>
<p>class MixinProxy implements InvocationHandler {</p>
<p>Map&lt;String,Object&gt; delegatesByMethod;</p>
<p>public MixinProxy(TwoTuple&lt;Object,Class&lt;?&gt;&gt;... pairs) { delegatesByMethod = new HashMap&lt;String,Object&gt;(); for(TwoTuple&lt;Object,Class&lt;?&gt;&gt; pair : pairs) { for(Method method : pair.second.getMethods()) {</p>
<p>String methodName = method.getName();</p>
<p>// The first interface in the map // implements the method.</p>
<p>if (!delegatesByMethod.containsKey(methodName)) delegatesByMethod.put(methodName, pair.first);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public Object invoke(Object proxy, Method method,</p>
<p>Object[] args) throws Throwable {</p>
<p>String methodName = method.getName();</p>
<p>Object delegate = delegatesByMethod.get(methodName); return method.invoke(delegate, args);</p>
<p>}</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public static Object newInstance(TwoTuple... pairs) {</p>
<p>Class[] interfaces = new Class[pairs.length]; for(int i = 0; i &lt; pairs.length; i++) { interfaces[i] = (Class)pairs[i].second;</p>
<p>}</p>
<p>ClassLoader cl =</p>
<p>pairs[0].first.getClass().getClassLoaderQ; return Proxy.newProxyInstance(</p>
<p>cl, interfaces, new MixinProxy(pairs));</p>
<p>}</p>
<p>}</p>
<p>public class DynamicProxyMixin {</p>
<p>public static void main(String[] args) {</p>
<p>Object mixin = MixinProxy.newInstance( tuple(new BasicImp(), Basic.class), tuple(new TimeStampedImp(), TimeStamped.class), tuple(new SerialNumberedImp(),SerialNumbered.class));</p>
<p>Basic b = (Basic)mixin;</p>
<p>TimeStamped t = (TimeStamped)mixin;</p>
<p>SerialNumbered s = (SerialNumbered)mixin; b.set(&quot;Hello&quot;);</p>
<p>System.out.println(b.get());</p>
<p>System.out.println(t.getStamp());</p>
<p>System.out.println(s.getSerialNumber());</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Hello</p>
<p>1132519137015</p>
<p>1</p>
<p>*///:~</p>
<p>Because only the dynamic type, and not the static type, includes all the mixed-in types, this is still not quite as nice as the C++ approach, because you’re forced to downcast to the appropriate type before you can call methods for it. However, it is significantly closer to a true mixin.</p>
<p>There has been a fair amount of work done towards the support of mixins for Java, including the creation of at least one language add-on, the Jam language, specifically for supporting mixins.</p>
<p>Exercise 39: (1) Add a new mixin class Colored to DynamicProxyMixin.java, mix it into mixin, and show that it works.</p>
</section>
<section>
<title>
<p>Latent typing</p></title><empty-line/>
<p>The beginning of this chapter introduced the idea of writing code that can be applied as generally as possible. To do this, we need ways to loosen the constraints on the types that our code works with, without losing the benefits of static type checking. We are then able to write code that can be used in more situations without change—that is, more &quot;generic&quot; code.</p>
<p>Java generics appear to take a further step in this direction. When you are writing or using generics that simply hold objects, the code works with any type (except for primitives, although as you’ve seen, autoboxing smoothes this over). Or, put another way, &quot;holder&quot; generics are able to say, &quot;I don’t care what type you are.&quot; Code that doesn’t care what type it works with can indeed be applied everywhere, and is thus quite &quot;generic.&quot;</p>
<p>As you’ve also seen, a problem arises when you want to perform manipulations on generic types (other than calling Object methods), because erasure requires that you specify the bounds of the generic types that may be used, in order to safely call specific methods for the generic objects in your code. This is a significant limitation to the concept of &quot;generic&quot; because you must constrain your generic types so that they inherit from particular classes or implement particular interfaces. In some cases you might end up using an ordinary class or interface instead, because a bounded generic might be no different from specifying a class or interface.</p>
<p>One solution that some programming languages provide is called latent typing or structural typing. A more whimsical term is duck typing, as in, &quot;If it walks like a duck and talks like a duck, you might as well treat it like a duck.&quot; Duck typing has become a fairly popular term, possibly because it doesn’t carry the historical baggage that other terms do.</p>
<p>Generic code typically only calls a few methods on a generic type, and a language with latent typing loosens the constraint (and produces more generic code) by only requiring that a subset of methods be implemented, not a particular class or interface. Because of this, latent typing allows you to cut across class hierarchies, calling methods that are not part of a common interface. So a piece of code might say, in effect, &quot;I don’t care what type you are as long as you can speak( ) and sit( ).&quot; By not requiring a specific type, your code can be more generic.</p>
<p>Latent typing is a code organization and reuse mechanism. With it you can write a piece of code that can be reused more easily than without it. Code organization and reuse are the foundational levers of all computer programming: Write it once, use it more than once, and keep the code in one place. Because I am not required to name an exact interface that my code operates upon, with latent typing I can write less code and apply it more easily in more places.</p>
<p>Two examples of languages that support latent typing are Python (freely downloadable from <a l:href="http://www.Python.org">www.Python.org</a>) and C++.<a l:href="#bookmark66" type="note"><sup>67</sup></a><sup></sup> Python is a dynamically typed language (virtually all the type checking happens at run time) and C++ is a statically typed language (the type checking happens at compile time), so latent typing does not require either static or dynamic type checking.</p>
<p>If we take the above description and express it in Python, it looks like this:</p>
<p>#: generics/DogsAndRobots.py</p>
<p>class Dog:</p>
<p>def speak(self): print &quot;Arf!&quot; def sit(self):</p>
<p>print &quot;Sitting&quot; def reproduce(self): pass</p>
<p>class Robot:</p>
<p>def speak(self): print &quot;Click!&quot; def sit(self):</p>
<p>print &quot;Clank!&quot; def oilChange(self) : pass</p>
<p>def perform(anything): anything.speak() anything.sit()</p>
<p>a = Dog() b = Robot() perform(a) perform(b)</p>
<p>#:~</p>
<p>Python uses indentation to determine scope (so no curly braces are needed), and a colon to begin a new scope. A ‘#’ indicates a comment to the end of the line, like ‘//’ in Java. The methods of a class explicitly specify the equivalent of the this reference as the first argument, called self by convention. Constructor calls do not require any sort of &quot;new&quot; keyword. And Python allows regular (non-member) functions, as evidenced by perform( ).</p>
<p>In perform(anything), notice that there is no type for anything, and anything is just an identifier. It must be able to perform the operations that perform( ) asks of it, so an interface is implied. But you never have to explicitly write out that interface—it’s latent. perform( ) doesn’t care about the type of its argument, so I can pass any object to it as long as it supports the speak( ) and sit( ) methods. If you pass an object to perform( ) that does not support these operations, you’ll get a runtime exception.</p>
<p>We can produce the same effect in C++:</p>
<p>//: generics/DogsAndRobots.cpp</p>
<p>class Dog { public:</p>
<p>void speak() {} void sit() {} void reproduce() {}</p>
<p>class Robot { public:</p>
<p>void speak() {} void sit() {} void oilChange() {</p>
<p>};</p>
<p>template&lt;class T&gt; void perform(T anything) { anything.speak(); anything.sit();</p>
<p>}</p>
<p>int main() {</p>
<p>Dog d;</p>
<p>Robot r;</p>
<p>perform(d);</p>
<p>perform(r);</p>
<p>} ///:~</p>
<p>In both Python and C++, Dog and Robot have nothing in common, other than that they happen to have two methods with identical signatures. From a type standpoint, they are completely distinct types. However, perform( ) doesn’t care about the specific type of its argument, and latent typing allows it to accept both types of object.</p>
<p>C++ ensures that it can actually send those messages. The compiler gives you an error message if you try to pass the wrong type (these error messages have historically been terrible and verbose, and are the primary reason that C++ templates have a poor reputation). Although they do it at different times— C++ at compile time, and Python at run time—both languages ensure that types cannot be misused and are thus considered to be strongly typed.<a l:href="#bookmark67" type="note"><sup>68</sup></a><sup></sup> Latent typing does not compromise strong typing.</p>
<p>Because generics were added to Java late in the game, there was no chance that any kind of latent typing could be implemented, so Java has no support for this feature. As a result, it initially seems that Java’s generic mechanism is &quot;less generic&quot; than a language that supports latent typing.<a l:href="#bookmark68" type="note"><sup>69</sup></a><sup></sup> For instance, if we try to implement the above example in Java, we are forced to use a class or an interface and specify it in a bounds expression:</p>
<p>//: generics/Performs.java</p>
<p>public interface Performs { void speak(); void sit();</p>
<p>} ///:~</p>
<p>//: generics/DogsAndRobots.java</p>
<p>// No latent typing in Java</p>
<p>import typeinfo.pets.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class PerformingDog extends Dog implements Performs { public void speak() { print(&quot;Woof!&quot;); } public void sit() { print(&quot;Sitting&quot;); } public void reproduce() {}</p>
<p>}</p>
<p>class Robot implements Performs {</p>
<p>public void speak() { print(&quot;Click!&quot;); } public void sit() { print(&quot;Clank!&quot;); } public void oilChange() {}</p>
<p>}</p>
<p>class Communicate {</p>
<p>public static &lt;T extends Performs&gt; void perform(T performer) { performer.speak(); performer.sit();</p>
<p>}</p>
<p>}</p>
<p>public class DogsAndRobots {</p>
<p>public static void main(String[] args) { PerformingDog d = new PerformingDog(); Robot r = new Robot(); Communicate.perform(d); Communicate.perform(r);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Woof!</p>
<p>Sitting</p>
<p>Click!</p>
<p>Clank!</p>
<p>*///:~</p>
<p>However, note that perform( ) does not need to use generics in order to work. It can simply be specified to accept a Performs object:</p>
<p>//: generics/SimpleDogsAndRobots.java // Removing the generic; code still works.</p>
<p>class CommunicateSimply {</p>
<p>static void perform(Performs performer) { performer.speak(); performer.sit();</p>
<p>}</p>
<p>}</p>
<p>public class SimpleDogsAndRobots {</p>
<p>public static void main(String[] args) {</p>
<p>CommunicateSimply.perform(new PerformingDog()); CommunicateSimply.perform(new Robot());</p>
<p>}</p>
<p>} /* Output:</p>
<p>Woof!</p>
<p>Sitting</p>
<p>Click!</p>
<p>Clank!</p>
<p>*///:~</p>
<p>In this case, generics were simply not necessary, since the classes were already forced to implement the Performs interface.</p>
</section>
<section>
<title>
<p>Compensating for the lack of latent typing</p></title><empty-line/>
<p>Although Java does not support latent typing, it turns out that this does not mean that your bounded generic code cannot be applied across different type hierarchies. That is, it is still possible to create truly generic code, but it takes some extra effort.</p>
<subtitle>Reflection</subtitle>
<p>One approach you can use is reflection. Here’s a perform( ) method that uses latent typing:</p>
<p>//: generics/LatentReflection.java</p>
<p>// Using Reflection to produce latent typing.</p>
<p>import java.lang.reflect.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>// Does not implement Performs: class Mime {</p>
<p>public void walkAgainstTheWind() {}</p>
<p>public void sit() { print(&quot;Pretending to sit&quot;); }</p>
<p>public void pushInvisibleWalls() {}</p>
<p>public String toString() { return &quot;Mime&quot;; }</p>
<p>}</p>
<p>// Does not implement Performs: class SmartDog {</p>
<p>public void speak() { print(&quot;Woof!&quot;); } public void sit() { print(&quot;Sitting&quot;); } public void reproduce() {}</p>
<p>}</p>
<p>class CommunicateReflectively {</p>
<p>public static void perform(Object speaker) {</p>
<p>Class&lt;?&gt; spkr = speaker.getClass(); try { try {</p>
<p>Method speak = spkr.getMethod(&quot;speak&quot;); speak.invoke(speaker);</p>
<p>} catch(NoSuchMethodException e) { print(speaker + &quot; cannot speak&quot;);</p>
<p>}</p>
<p>try {</p>
<p>Method sit = spkr.getMethod(&quot;sit&quot;); sit.invoke(speaker);</p>
<p>} catch(NoSuchMethodException e) { print(speaker + &quot; cannot sit&quot;);</p>
<p>}</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(speaker.toString(), e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class LatentReflection {</p>
<p>public static void main(String[] args) {</p>
<p>CommunicateReflectively.perform(new SmartDog()); CommunicateReflectively.perform(new Robot()); CommunicateReflectively.perform(new Mime());</p>
<p>6</p>
<p>} /* Output:</p>
<p>Woof!</p>
<p>Sitting</p>
<p>Click!</p>
<p>Clank!</p>
<p>Mime cannot speak Pretending to sit *///:~</p>
<p>Here, the classes are completely disjoint and have no base classes (other than Object) or interfaces in common. Through reflection, CommunicateReflectively.perform( ) is able to dynamically establish whether the desired methods are available and call them. It is even able to deal with the fact that Mime only has one of the necessary methods, and partially fulfills its goal.</p>
<subtitle>Applying a method to a sequence</subtitle>
<p>Reflection provides some interesting possibilities, but it relegates all the type checking to run time, and is thus undesirable in many situations. If you can achieve compile-time type checking, that’s usually more desirable. But is it possible to have compile-time type checking and latent typing?</p>
<p>Let’s look at an example that explores the problem. Suppose you want to create an apply( ) method that will apply any method to every object in a sequence. This is a situation where interfaces don’t seem to fit. You want to apply any method to a collection of objects, and interfaces constrain you too much to describe &quot;any method.&quot; How do you do this in Java?</p>
<p>Initially, we can solve the problem with reflection, which turns out to be fairly elegant because of Java SE5 varargs:</p>
<p>//: generics/Apply.java // {main: ApplyTest} import java.lang.reflect.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*; public class Apply {</p>
<p>public static &lt;T, S extends Iterable&lt;? extends T&gt;&gt; void apply(S seq, Method f, Object... args) { try {</p>
<p>for(T t: seq)</p>
<p>f.invoke(t, args);</p>
<p>} catch(Exception e) {</p>
<p>// Failures are programmer errors throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class Shape {</p>
<p>public void rotate() { print(this + &quot; rotate&quot;); } public void resize(int newSize) { print(this + &quot; resize &quot; + newSize);</p>
<p>}</p>
<p>}</p>
<p>class Square extends Shape {}</p>
<p>class FilledList&lt;T&gt; extends ArrayList&lt;T&gt; {</p>
<p>public FiHedList(Class&lt;? extends T&gt; type, int size) { try {</p>
<p>for(int i = 0; i &lt; size; i++)</p>
<p>// Assumes default constructor: add(type.newInstance());</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class ApplyTest {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>List&lt;Shape&gt; shapes = new ArrayList&lt;Shape&gt;(); for(int i = 0; i &lt; 10; i++) shapes.add(new Shape());</p>
<p>Apply.apply(shapes, Shape.class.getMethod(&quot;rotate&quot;)); Apply.apply(shapes,</p>
<p>Shape.class.getMethod(&quot;resize&quot;, int.class), 5);</p>
<p>List&lt;Square&gt; squares = new ArrayList&lt;Square&gt;(); for(int i = 0; i &lt; 10; i++) squares.add(new Square());</p>
<p>Apply.apply(squares, Shape.class.getMethod(&quot;rotate&quot;)); Apply.apply(squares,</p>
<p>Shape.class.getMethod(&quot;resize&quot;, int.class), 5);</p>
<p>Apply.apply(new FilledList&lt;Shape&gt;(Shape.class, 10), Shape.class.getMethod(&quot;rotate&quot;));</p>
<p>Apply.apply(new FilledList&lt;Shape&gt;(Square.class, 10), Shape.class.getMethod(&quot;rotate&quot;));</p>
<p>SimpleQueue&lt;Shape&gt; shapeQ = new SimpleQueue&lt;Shape&gt;(); for(int i = 0; i &lt; 5; i++) { shapeQ.add(new Shape()); shapeQ.add(new Square());</p>
<p>}</p>
<p>Apply.apply(shapeQ, Shape.class.getMethod(&quot;rotate&quot;));</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>In Apply, we get lucky because there happens to be an Iterable interface built into Java which is used by the Java containers library. Because of this, the apply( ) method can accept anything that implements the Iterable interface, which includes all the Collection classes such as List. But it can also accept anything else, as long as you make it Iterable—for example, the SimpleQueue class defined here and used above in main( ):</p>
<p>//: generics/SimpleQueue.java</p>
<p>// A different kind of container that is Iterable import java.util.*;</p>
<p>public class SimpleQueue&lt;T&gt; implements Iterable&lt;T&gt; { private LinkedList&lt;T&gt; storage = new LinkedList&lt;T&gt;(); public void add(T t) { storage.offer(t); } public T get() { return storage.poll(); } public Iterator&lt;T&gt; iterator() { return storage.iterator();</p>
<p>}</p>
<p>} ///:~</p>
<p>In Apply .java, exceptions are converted to RuntimeExceptions because there’s not much of a way to recover from exceptions—they really do represent programmer errors in this case.</p>
<p>Note that I had to put in bounds and wildcards in order for Apply and FilledList to be used in all desired situations. You can experiment by taking these out, and you’ll discover that some applications of Apply and FilledList will not work.</p>
<p>FilledList presents a bit of a quandary. In order for a type to be used, it must have a default (no-arg) constructor. Java has no way to assert such a thing at compile time, so it becomes a runtime issue. A common suggestion to ensure compile-time checking is to define a factory interface that has a method that generates objects; then FilledList would accept that interface rather than the &quot;raw factory&quot; of the type token. The problem with this is that all the classes you use in FilledList must then implement your factory interface. Alas, most classes are created without knowledge of your interface, and therefore do not implement it. Later, I’ll show one solution using adapters.</p>
<p>But the approach shown, of using a type token, is perhaps a reasonable tradeoff (at least as a first-cut solution). With this approach, using something like FilledList is just easy enough that it may be used rather than ignored. Of course, because errors are reported at run time, you need confidence that these errors will appear early in the development process.</p>
<p>Note that the type token technique is recommended in the Java literature, such as Gilad Bracha’s paper Generics in the Java Programming Language,<a l:href="#bookmark69" type="note"><sup>70</sup></a><sup></sup> where he notes, &quot;It’s an idiom that’s used extensively in the new APIs for manipulating annotations, for example.&quot; However, I’ve discovered some inconsistency in people’s comfort level with this technique; some people strongly prefer the factory approach, which was presented earlier in this chapter.</p>
<p>Also, as elegant as the Java solution turns out to be, we must observe that the use of reflection (although it has been improved significantly in recent versions of Java) may be slower than a non-reflection implementation, since so much is happening at run time. This should not stop you from using the solution, at least as a first cut (lest you fall sway to premature optimization), but it’s certainly a distinction between the two approaches.</p>
<p>Exercise 40: (3) Add a speak( ) method to all the pets in typeinfo.pets. Modify Apply.java to call the speak( ) method for a heterogeneous collection of Pet.</p>
<subtitle>When you don&apos;t happen to have the right interface</subtitle>
<p>The above example benefited because the Iterable interface was already built in, and was exactly what we needed. But what about the general case, when there isn’t an interface already in place that just happens to fit your needs?</p>
<p>For example, let’s generalize the idea in FilledList and create a parameterized fill( ) method that will take a sequence and fill it using a Generator. When we try to write this in Java, we run into a problem, because there is no convenient &quot;Addable&quot; interface as there was an Iterable interface in the previous example. So instead of saying, &quot;anything that you can call add( ) for,&quot; you must say, &quot;subtype of Collection.&quot; The resulting code is not particularly generic, since it must be constrained to work with Collection implementations. If I try to use a class that doesn’t implement Collection, my generic code won’t work. Here’s what it looks like:</p>
<p>//: generics/Fill.java // Generalizing the FilledList idea // {main: FillTest} import java.util.*;</p>
<p>// Doesn’t work with &quot;anything that has an add().&quot; There is // no &quot;Addable&quot; interface so we are narrowed to using a // Collection. We cannot generalize using generics in // this case. public class Fill {</p>
<p>public static &lt;T&gt; void fill(Collection&lt;T&gt; collection, Class&lt;? extends T&gt; classToken, int size) { for(int i = 0; i &lt; size; i++)</p>
<p>// Assumes default constructor: try {</p>
<p>collection.add(classToken.newInstance());</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class Contract {</p>
<p>private static long counter = 0; private final long id = counter++; public String toString() {</p>
<p>return getClass().getName() + &quot; &quot; + id;</p>
<p>}</p>
<p>}</p>
<p>class TitleTransfer extends Contract {} class FillTest {</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;Contract&gt; contracts = new ArrayList&lt;Contract&gt;(); Fill.fill(contracts, Contract.class, 3); Fill.fill(contracts, TitleTransfer.class, 2); for(Contract c: contracts)</p>
<p>System.out.println(c);</p>
<p>SimpleQueue&lt;Contract&gt; contractQueue = new SimpleQueue&lt;Contract&gt;();</p>
<p>// Won’t work. fill() is not generic enough:</p>
<p>// Fill.fill(contractQueue, Contract.class, 3);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Contract 0 Contract 1 Contract 2 TitleTransfer 3 TitleTransfer 4 *///:~</p>
<p>This is where a parameterized type mechanism with latent typing is valuable, because you are not at the mercy of the past design decisions of any particular library creator, so you do not have to rewrite your code every time you encounter a new library that didn’t take your situation into account (thus the code is truly &quot;generic&quot;). In the above case, because the Java designers (understandably) did not see the need for an &quot;Addable&quot; interface, we are constrained within the Collection hierarchy, and SimpleQueue, even though it has an add( ) method, will not work. Because it is thus constrained to working with Collection, the code is not particularly &quot;generic.&quot; With latent typing, this would not be the case.</p>
<subtitle>Simulating latent typing with adapters</subtitle>
<p>So Java generics don’t have latent typing, and we need something like latent typing in order to write code that can be applied across class boundaries (that is, &quot;generic&quot; code). Is there some way to get around this limitation?</p>
<p>What would latent typing accomplish here? It means that you could write code saying, &quot;I don’t care what type I’m using here as long as it has these methods.&quot; In effect, latent typing creates an implicit interface containing the desired methods. So it follows that if we write the necessary interface by hand (since Java doesn’t do it for us), that should solve the problem.</p>
<p>Writing code to produce an interface that we want from an interface that we have is an example of the Adapter design pattern. We can use adapters to adapt existing classes to produce the desired interface, with a relatively small amount of code. The solution, which uses the previously defined Coffee hierarchy, demonstrates different ways of writing adapters:</p>
<p>//: generics/FiH2.java</p>
<p>// Using adapters to simulate latent typing.</p>
<p>// {main: Fill2Test}</p>
<p>import generics.coffee.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>interface Addable&lt;T&gt; { void add(T t); }</p>
<p>public class Fill2 {</p>
<p>// Classtoken version:</p>
<p>public static &lt;T&gt; void fill(Addable&lt;T&gt; addable,</p>
<p>Class&lt;? extends T&gt; classToken, int size) { for(int i = 0; i &lt; size; i++) try {</p>
<p>addable.add(classToken.newInstance());</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>// Generator version:</p>
<p>public static &lt;T&gt; void fill(Addable&lt;T&gt; addable,</p>
<p>Generator&lt;T&gt; generator, int size) { for(int i = 0; i &lt; size; i++) addable.add(generator.next());</p>
<p>}</p>
<p>}</p>
<p>// To adapt a base type, you must use composition.</p>
<p>// Make any Collection Addable using composition: class AddableCollectionAdapter&lt;T&gt; implements Addable&lt;T&gt; { private Collection&lt;T&gt; c;</p>
<p>public AddableCollectionAdapter(Collection&lt;T&gt; c) { this.c = c;</p>
<p>}</p>
<p>public void add(T item) { c.add(item); }</p>
<p>}</p>
<p>// A Helper to capture the type automatically: class Adapter { public static &lt;T&gt;</p>
<p>Addable&lt;T&gt; collectionAdapter(Collection&lt;T&gt; c) { return new AddableCollectionAdapter&lt;T&gt;(c);</p>
<p>}</p>
<p>// To adapt a specific type, you can use inheritance. // Make a SimpleQueue Addable using inheritance: class AddableSimpleQueue&lt;T&gt;</p>
<p>extends SimpleQueue&lt;T&gt; implements Addable&lt;T&gt; { public void add(T item) { super.add(item); }</p>
<p>}</p>
<p>class Fill2Test {</p>
<p>public static void main(String[] args) {</p>
<p>// Adapt a Collection:</p>
<p>List&lt;Coffee&gt; carrier = new ArrayList&lt;Coffee&gt;(); Fill2.fill(</p>
<p>new AddableCollectionAdapter&lt;Coffee&gt;(carrier), Coffee.class, 3);</p>
<p>// Helper method captures the type: Fill2.fill(Adapter.collectionAdapter(carrier), Latte.class, 2); for(Coffee c: carrier) print(c);</p>
<p>print(&quot;----------------------&quot;);</p>
<p>// Use an adapted class: AddableSimpleQueue&lt;Coffee&gt; coffeeQueue = new AddableSimpleQueue&lt;Coffee&gt;(); Fill2.fill(coffeeQueue, Mocha.class, 4); Fill2.fill(coffeeQueue, Latte.class, 1); for(Coffee c: coffeeQueue) print(c);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Coffee 0 Coffee 1 Coffee 2 Latte 3 Latte 4</p>
<p>Mocha 5 Mocha 6 Mocha 7 Mocha 8 Latte 9 *///:~</p>
<p>Fill2 doesn’t require a Collection as Fill did. Instead, it only needs something that implements Addable, and Addable has been written just for Fill—it is a manifestation of the latent type that I wanted the compiler to make for me.</p>
<p>In this version, I’ve also added an overloaded fill( ) that takes a Generator rather than a type token. The Generator is type-safe at compile time: The compiler ensures that you pass it a proper Generator, so no exceptions can be thrown.</p>
<p>The first adapter, AddableCollectionAdapter, works with the base type Collection, which means that any implementation of Collection can be used. This version simply stores the Collection reference and uses it to implement add( ).</p>
<p>If you have a specific type rather than the base class of a hierarchy, you can write somewhat less code when creating your adapter by using inheritance, as you can see in AddableSimpleQueue.</p>
<p>In Fill2Test.main( ), you can see the various types of adapters at work. First, a Collection type is adapted with AddableCollectionAdapter. A second version of this uses a generic helper method, and you can see how the generic method captures the type so it doesn’t have to be explicitly written— this is a convenient trick that produces more elegant code.</p>
<p>Next, the pre-adapted AddableSimpleQueue is used. Note that in both cases the adapters allow the classes that previously didn’t implement Addable to be used with Fill2.fill( ).</p>
<p>Using adapters like this would seem to compensate for the lack of latent typing, and thus allow you to write genuinely generic code. However, it’s an extra step and something that must be understood both by the library creator and the library consumer, and the concept may not be grasped as readily by less experienced programmers. By removing the extra step, latent typing makes generic code easier to apply, and this is its value.</p>
<p>Exercise 41: (1) Modify Fill2.java to use the classes in typeinfo.pets instead of the Coffee classes.</p>
</section>
<section>
<title>
<p>Using function objects as strategies</p></title><empty-line/>
<p>This final example will create truly generic code using the adapter approach described in the previous section. The example began as an attempt to create a sum over a sequence of elements (of any type that can be summed), but evolved into performing general operations using afunctional style of programming.</p>
<p>If you just look at the process of trying to add objects, you can see that this is a case where we have common operations across classes, but the operations are not represented in any base class that we can specify—sometimes you can even use a’+’ operator, and other times there may be some kind of &quot;add&quot; method. This is generally the situation that you encounter when trying to write generic code, because you want the code to apply across multiple classes— especially, as in this case, multiple classes that already exist and that we have no ability to &quot;fix.&quot; Even if you were to narrow this case to subclasses of Number, that superclass doesn’t include anything about &quot;addability.&quot;</p>
<p>The solution is to use the Strategy design pattern, which produces more elegant code because it completely isolates &quot;the thing that changes&quot; inside of a function object.<a l:href="#bookmark70" type="note"><sup>71</sup></a><sup></sup> A function object is an object that in some way behaves like a function—typically, there’s one method of interest (in languages that support operator overloading, you can make the call to this method look like an ordinary method call). The value of function objects is that, unlike an ordinary method, they can be passed around, and they can also have state that persists across calls. Of course, you can accomplish something like this with any method in a class, but (as with any design pattern) the function object is primarily distinguished by its intent. Here the intent is to create something that behaves like a single method that you can pass around; thus it is closely coupled with—and sometimes indistinguishable from—the Strategy design pattern.</p>
<p>As I’ve found with a number of design patterns, the lines get kind of blurry here: We are creating function objects which perform adaptation, and they are being passed into methods to be used as strategies.</p>
<p>Taking this approach, I added the various kinds of generic methods that I had originally set out to create, and more. Here is the result:</p>
<p>//: generics/Functional.java import java.math.*;</p>
<p>import java.util.concurrent.atomic.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>// Different types of function objects: interface Combiner&lt;T&gt; { T combine(T x, T y); } interface UnaryFunction&lt;R,T&gt; { R function(T x); } interface Collector&lt;T&gt; extends UnaryFunction&lt;T,T&gt; {</p>
<p>T result(); // Extract result of collecting parameter</p>
<p>}</p>
<p>interface UnaryPredicate&lt;T&gt; { boolean test(T x); } public class Functional {</p>
<p>// Calls the Combiner object on each element to combine // it with a running result, which is finally returned: public static &lt;T&gt; T</p>
<p>reduce(Iterable&lt;T&gt; seq, Combiner&lt;T&gt; combiner) { Iterator&lt;T&gt; it = seq.iterator(); if(it.hasNext()) {</p>
<p>T result = it.next(); while(it.hasNext())</p>
<p>result = combiner.combine(result, it.next()); return result;</p>
<p>}</p>
<p>// If seq is the empty list: return null; // Or throw exception</p>
<p>}</p>
<p>// Take a function object and call it on each object in // the list, ignoring the return value. The function // object may act as a collecting parameter, so it is // returned at the end. public static &lt;T&gt; Collector&lt;T&gt; forEach(Iterable&lt;T&gt; seq, Collector&lt;T&gt; func) { for(T t : seq) func.function(t); return func;</p>
<p>}</p>
<p>// Creates a list of results by calling a // function object for each object in the list: public static &lt;R,T&gt; List&lt;R&gt;</p>
<p>transform(Iterable&lt;T&gt; seq, UnaryFunction&lt;R,T&gt; func) { List&lt;R&gt; result = new ArrayList&lt;R&gt;(); for(T t : seq)</p>
<p>result.add(func.function(t)); return result;</p>
<p>}</p>
<p>// Applies a unary predicate to each item in a sequence, // and returns a list of items that produced &quot;true&quot;: public static &lt;T&gt; List&lt;T&gt;</p>
<p>filter(Iterable&lt;T&gt; seq, UnaryPredicate&lt;T&gt; pred) {</p>
<p>List&lt;T&gt; result = new ArrayList&lt;T&gt;(); for(T t : seq) if(pred.test(t)) result.add(t); return result;</p>
<p>}</p>
<p>// To use the above generic methods, we need to create // function objects to adapt to our particular needs: static class IntegerAdder implements Combiner&lt;Integer&gt; { public Integer combine(Integer x, Integer y) { return x + y;</p>
<p>}</p>
<p>}</p>
<p>static class</p>
<p>IntegerSubtracter implements Combiner&lt;Integer&gt; { public Integer combine(Integer x, Integer y) { return x - y;</p>
<p>}</p>
<p>}</p>
<p>static class</p>
<p>BigDecimalAdder implements Combiner&lt;BigDecimal&gt; {</p>
<p>public BigDecimal combine(BigDecimal x, BigDecimal y) { return x.add(y);</p>
<p>}</p>
<p>}</p>
<p>static class</p>
<p>BigIntegerAdder implements Combiner&lt;BigInteger&gt; {</p>
<p>public BigInteger combine(BigInteger x, BigInteger y) { return x.add(y);</p>
<p>static class</p>
<p>AtomicLongAdder implements Combiner&lt;AtomicLong&gt; {</p>
<p>public AtomicLong combine(AtomicLong x, AtomicLong y) { // Not clear whether this is meaningful: return new AtomicLong(x.addAndGet(y.get()));</p>
<p>}</p>
<p>}</p>
<p>// We can even make a UnaryFunction with an &quot;ulp&quot;</p>
<p>// (Units in the last place): static class BigDecimalUlp</p>
<p>implements UnaryFunction&lt;BigDecimal,BigDecimal&gt; { public BigDecimal function(BigDecimal x) { return x.ulp();</p>
<p>}</p>
<p>}</p>
<p>static class GreaterThan&lt;T extends Comparable&lt;T&gt;&gt; implements UnaryPredicate&lt;T&gt; { private T bound;</p>
<p>public GreaterThan(T bound) { this.bound = bound; } public boolean test(T x) {</p>
<p>return x.compareTo(bound) &gt; 0;</p>
<p>}</p>
<p>}</p>
<p>static class MultiplyingIntegerCollector implements Collector&lt;Integer&gt; { private Integer val = 1; public Integer function(Integer x) { val *= x; return val;</p>
<p>}</p>
<p>public Integer result() { return val; }</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>// Generics, varargs &amp; boxing working together: List&lt;Integer&gt; li = Arrays.asList(1, 2, 3, 4, 5, 6, 7); Integer result = reduce(li, new IntegerAdder()); print(result);</p>
<p>result = reduce(li, new IntegerSubtracter()); print(result);</p>
<p>print(filter(li, new GreaterThan&lt;Integer&gt;(4))); print(forEach(li,</p>
<p>new MultiplyingIntegerCollector()).result());</p>
<p>print(forEach(filter(li, new GreaterThan&lt;Integer&gt;(4)), new MultiplyingIntegerCollector()).result());</p>
<p>MathContext mc = new MathContext(7);</p>
<p>List&lt;BigDecimal&gt; lbd = Arrays.asList(</p>
<p>new BigDecimal(1.1, mc), new BigDecimal(2.2, mc), new BigDecimal(3.3, mc), new BigDecimal(4.4, mc)); BigDecimal rbd = reduce(lbd, new BigDecimalAdder()); print(rbd);</p>
<p>print(filter(lbd,</p>
<p>new GreaterThan&lt;BigDecimal&gt;(new BigDecimal(3))));</p>
<p>// Use the prime-generation facility of BigInteger: List&lt;BigInteger&gt; lbi = new ArrayList&lt;BigInteger&gt;();</p>
<p>BigInteger bi = BigInteger.valueOf(11); for(int i = 0; i &lt; 11; i++) {</p>
<p>Ibi.add(bi);</p>
<p>bi = bi.nextProbablePrime();</p>
<p>}</p>
<p>print(lbi);</p>
<p>BigInteger rbi = reduce(lbi, new BigIntegerAdder()); print(rbi);</p>
<p>// The sum of this list of primes is also prime: print(rbi.isProbablePrime(5));</p>
<p>List&lt;AtomicLong&gt; lal = Arrays.asList( new AtomicLong(11), new AtomicLong(47), new AtomicLong(74), new AtomicLong(133)); AtomicLong ral = reduce(lal, new AtomicLongAdder()); print(ral);</p>
<p>print(transform(lbd,new BigDecimalUlp()));</p>
<p>}</p>
<p>} /* Output:</p>
<p>28</p>
<p>-26</p>
<p>[5, 6, 7]</p>
<p>5040</p>
<p>210</p>
<p>11.000000</p>
<p>[3.300000, 4.400000]</p>
<p>[11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]</p>
<p>311</p>
<p>true</p>
<p>265</p>
<p>[0.000001, 0.000001, 0.000001, 0.000001]</p>
<p>*///:~</p>
<p>I begin by defining interfaces for different types of function objects. These were created on demand, as I developed the different methods and discovered the need for each. The Combiner class was suggested by an anonymous contributor to one of the articles posted on my Web site. The Combiner abstracts away the specific detail of trying to add two objects, and just says that they are being combined somehow. As a result, you can see that IntegerAdder and IntegerSubtracter can be types of Combiner.</p>
<p>A UnaryFunction takes a single argument and produces a result; the argument and result need not be of the same type. A Collector is used as a &quot;collecting parameter,&quot; and you can extract the result when you’re finished. A UnaryPredicate produces a boolean result. There are other types of function objects that can be defined, but these are enough to make the point.</p>
<p>The Functional class contains a number of generic methods that apply function objects to sequences. reduce( ) applies the function in a Combiner to each element of a sequence in order to produce a single result.</p>
<p>forEach( ) takes a Collector and applies its function to each element, ignoring the result of each function call. This can be called just for the side effect (which wouldn’t be a &quot;functional&quot; style of programming but can still be useful), or the Collector can maintain internal state to become a collecting parameter, as is the case in this example.</p>
<p>transform( ) produces a list by calling a UnaryFunction on each object in the sequence and capturing the result.</p>
<p>Finally, filter( ) applies a UnaryPredicate to each object in a sequence and stores the ones that produce true in a List, which it returns.</p>
<p>You can define additional generic functions. The C++ STL, for example, has lots of them. The problem has also been solved in some open-source libraries, such as the JGA (Generic Algorithms for Java).</p>
<p>In C++, latent typing takes care of matching up operations when you call functions, but in Java we need to write the function objects to adapt the generic methods to our particular needs. So the next part of the class shows various different implementations of the function objects. Note, for example, that IntegerAdder and BigDecimalAdder solve the same problemadding two objects—by calling the appropriate operations for their particular type.</p>
<p>So that’s the Adapter pattern and Strategy pattern combined.</p>
<p>In main( ), you can see that in each method call, a sequence is passed along with the appropriate function object. Also, a number of the expressions can get fairly complex, such as:</p>
<p>forEach(filter(li, new GreaterThan(4)),</p>
<p>new MultiplyingIntegerCollector()).result()</p>
<p>This produces a list by selecting all elements in li that are greater than 4, and then applies the MultiplyingIntegerCollector( ) to the resulting list and extracts the result( ). I won’t explain the details of the rest of the code other than to say that you can probably figure it out by walking through it.</p>
<p>Exercise 42: (5) Create two separate classes, with nothing in common. Each class should hold a value, and at least have methods that produce that value and perform a modification upon that value. Modify Functional.java so that it performs functional operations on collections of your classes (these operations do not have to be arithmetic as they are in Functional .java).</p>
</section>
<section>
<title>
<p>Summary: Is casting really so bad?</p></title><empty-line/>
<p>Having worked to explain C++ templates since their inception, I have probably been putting forward the following argument longer than most people. Only recently have I stopped to wonder how often this argument is valid-how many times does the problem I’m about to describe really slip through the cracks?</p>
<p>The argument goes like this. One of the most compelling places to use a generic type mechanism is with container classes such as the Lists, Sets, Maps, etc. that you saw in Holding Your Objects and that you shall see more of in the Containers in Depth chapter. Before Java SE5, when you put an object into a container, it would be upcast to Object, so you’d lose the type information. When you wanted to pull it back out to do something with it, you had to cast it back down to the proper type. My example was a List of Cat (a variation of this using apples and oranges is shown at the beginning of the Holding Your Objects chapter). Without the Java SE5 generic version of the container, you put Objects in and you get Objects out, so it’s easily possible to put a Dog in a List of Cat.</p>
<p>However, pre-generic Java wouldn’t let you misuse the objects that you put into a container. If you threw a Dog into a container of Cats and then tried to treat everything in the container as a Cat, you’d get a RuntimeException when you pulled the Dog reference out of the Cat container and tried to cast it to a Cat. You’d still discover the problem, but you discovered it at run time rather than compile time.</p>
<p>In previous editions of this book, I go on to say:</p>
<p>This is more than just an annoyance. It’s something that can create difficult-to-find bugs. If one part (or several parts) of a program inserts objects into a container, and you discover only in a separate part of the program through an exception that a bad object was placed in the container, then you must find out where the bad insert occurred.</p>
<p>However, upon further examination of the argument, I began to wonder about it. First, how often does it happen? I don’t remember this kind of thing ever happening to me, and when I asked people at conferences, I didn’t hear anyone say that it had happened to them. Another book used an example of a list called files that contained String objects-in this example it seemed perfectly natural to add a File object to files, so a better name for the object might have been fileNames. No matter how much type checking Java provides, it’s still possible to write obscure programs, and a badly written program that compiles is still a badly written program. Perhaps most people use well-named containers such as &quot;cats&quot; that provide a visual warning to the programmer who would try to add a non-Cat. And even if it did happen, how long would such a thing really stay buried? It would seem that as soon as you started running tests with real data, you’d see an exception pretty quickly.</p>
<p>One author even asserted that such a bug could &quot;remain buried for years.&quot; But I do not recall any deluge of reports of people having great difficulty finding &quot;dog in cat list&quot; bugs, or even producing them very often. Whereas you will see in the Concurrency chapter that with threads, it is very easy and common to have bugs that may appear extremely rarely, and only give you a vague idea of what’s wrong. So is the &quot;dog in cat list&quot; argument really the reason that this very significant and fairly complex feature has been added to Java? <a l:href="#bookmark71" type="note"><sup>72</sup></a><sup></sup></p>
<p>So even though the &quot;dog in cat list&quot; argument is often used to justify generics, it is questionable. And as I asserted at the beginning of the chapter, I do not believe that this is what the concept of generics is really about. Instead, generics are as their name implies—a way to write more &quot;generic&quot; code that is less constrained by the types it can work with, so a single piece of code can be applied to more types. As you have seen in this chapter, it is fairly easy to write truly generic &quot;holder&quot; classes (which the Java containers are), but to write generic code that manipulates its generic types requires extra effort, on the part of both the class creator and the class consumer, who must understand the concept and implementation of the Adapter design pattern. That extra effort reduces the ease of use of the feature, and may thus make it less applicable in places where it might otherwise have added value.</p>
<p>Also note that because generics were back-engineered into Java instead of being designed into the language from the start, some of the containers cannot be made as robust as they should be. For example, look at Map, in particular the methods containsKey(Object key) and get(Object key). If these classes had been designed with pre-existing generics, these methods would have used parameterized types instead of Object, thus affording the compile-time checking that generics are supposed to provide. In C++ maps, for example, the key type is always checked at compile time.</p>
<p>One thing is very clear: Introducing any kind of generic mechanism in a later version of a language, after that language has come into general use, is a very, very messy proposition, and one that cannot be accomplished without pain. In C++, templates were introduced in the initial ISO version of the language (although even that caused some pain because there was an earlier nontemplate version in use before the first Standard C++ appeared), so in effect templates were always a part of the language. In Java, generics were not introduced until almost 10 years after the language was first released, so the issues of migrating to generics are quite considerable, and have made a significant impact on the design of generics. The result is that you, the programmer, will suffer because of the lack of vision exhibited by the Java designers when they created version l.o. When Java was first being created, the designers, of course, knew about C++ templates, and they even considered including them in the language, but for one reason or another decided to leave them out (indications are that they were in a hurry). As a result, both the language and the programmers that use it will suffer. Only time will show the ultimate impact that Java’s approach to generics will have on the language.</p>
<p>Some languages, notably Nice (see <a l:href="http://nice.sourceforge.net">http://nice.sourceforge.net</a>; this language generates Java bytecodes and works with existing Java libraries) and NextGen (see</p>
<p><a l:href="http://japan.cs.rice.edu/nextgen">http://japan.cs.rice.edu/nextgen</a>) have incorporated cleaner and less impactful approaches to parameterized types. It’s not impossible to imagine such a language becoming a successor to Java, because it takes exactly the approach that C++ did with C: Use what’s there and improve upon it.</p>
<subtitle>Further reading</subtitle>
<p>The introductory document for generics is Generics in the Java Programming Language, by Gilad Bracha, located at <a l:href="http://java.sun.eom/j2se/1.5/pdf/generics-tutorial.pdf">http://java.sun.eom/j2se/1.5/pdf/generics-tutorial.pdf</a></p>
<p>Angelika Langer’s Java Generics FAQs is a very helpful resource, located at <a l:href="http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html">www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html</a>.</p>
<p>You can find out more about wildcards in Adding Wildcards to the Java Programming Language, by Torgerson, Ernst, Hansen, von der Ahe, Bracha and Gafter, located at <a l:href="http://www.jot.fm/issues/issue_2004_12/artide5">www.jot.fm/issues/issue_2004_12/artide5</a>.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Arrays</p></title><empty-line/>
<p>At the end of the Initialization &amp; Cleanup chapter, you learned how to define and initialize an array.</p>
<p>The simple view of arrays is that you create and populate them, you select elements from them using int indexes, and they don’t change their size. Most of the time that’s all you need to know, but sometimes you need to perform more sophisticated operations on arrays, and you may also need to evaluate the use of an array vs. a more flexible container. This chapter will show you how to think about arrays in more depth.</p>
<section>
<title>
<p>Why arrays are special</p></title><empty-line/>
<p>There are a number of other ways to hold objects, so what makes an array special?</p>
<p>There are three issues that distinguish arrays from other types of containers: efficiency, type, and the ability to hold primitives. The array is Java’s most efficient way to store and randomly access a sequence of object references. The array is a simple linear sequence, which makes element access fast. The cost of this speed is that the size of an array object is fixed and cannot be changed for the lifetime of that array. You might suggest an ArrayList (from Holding Your Objects), which will automatically allocate more space, creating a new one and moving all the references from the old one to the new one. Although you should generally prefer an ArrayList to an array, this flexibility has overhead, so an ArrayList is measurably less efficient than an array.</p>
<p>Both arrays and containers guarantee that you can’t abuse them. Whether you’re using an array or a container, you’ll get a RuntimeException if you exceed the bounds, indicating a programmer error.</p>
<p>Before generics, the other container classes dealt with objects as if they had no specific type. That is, they treated them as type Object, the root class of all classes in Java. Arrays are superior to pre-generic containers because you create an array to hold a specific type. This means that you get compile-time type checking to prevent you from inserting the wrong type or mistaking the type that you’re extracting. Of course, Java will prevent you from sending an inappropriate message to an object at either compile time or run time. So it’s not riskier one way or the other; it’s just nicer if the compiler points it out to you, and there’s less likelihood that the end user will get surprised by an exception.</p>
<p>An array can hold primitives, whereas a pre-generic container could not. With generics, however, containers can specify and check the type of objects they hold, and with autoboxing containers can act as if they are able to hold primitives, since the conversion is automatic. Here’s an example that compares arrays with generic containers:</p>
<p>//: arrays/ContainerComparison.java import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class BerylliumSphere {</p>
<p>private static long counter;</p>
<p>private final long id = counter++;</p>
<p>public String toString() { return &quot;Sphere &quot; + id; }</p>
<p>} public class ContainerComparison {</p>
<p>public static void main(String[] args) {</p>
<p>BerylliumSphere[] spheres = new BerylliumSphere[10]; for(int i = 0; i &lt; 5; i++)</p>
<p>spheres[i] = new BerylliumSphere(); print(Arrays.toString(spheres)); print(spheres[4]);</p>
<p>List&lt;BerylliumSphere&gt; sphereList = new ArrayList&lt;BerylliumSphere&gt;(); for(int i = 0; i &lt; 5; i++)</p>
<p>sphereList.add(new BerylliumSphere()); print(sphereList); print(sphereList.get(4));</p>
<p>int[] integers = { 0, 1, 2, 3, 4, 5 };</p>
<p>print(Arrays.toString(integers));</p>
<p>print(integers[4]);</p>
<p>List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(</p>
<p>Arrays.asList(0, 1, 2, 3, 4, 5)); intList.add(97); print(intList); print(intList.get(4));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[Sphere 0, Sphere 1, Sphere 2, Sphere 3, Sphere 4, null, null, null, null, null]</p>
<p>Sphere 4</p>
<p>[Sphere 5, Sphere 6, Sphere 7, Sphere 8, Sphere 9]</p>
<p>Sphere 9</p>
<p>[0, 1, 2, 3, 4, 5]</p>
<p>4</p>
<p>[0, 1, 2, 3, 4, 5, 97]</p>
<p>4</p>
<p>*///:~</p>
<p>Both ways of holding objects are type-checked, and the only apparent difference is that arrays use [ ] for accessing elements, and a List uses methods such as add( ) and get( ). The similarity between arrays and the ArrayList is intentional, so that it’s conceptually easy to switch between the two. But as you saw in the Holding Your Objects chapter, containers have significantly more functionality than arrays.</p>
<p>With the advent of autoboxing, containers are nearly as easy to use for primitives as arrays. The only remaining advantage to arrays is efficiency. However, when you’re solving a more general problem, arrays can be too restrictive, and in those cases you use a container class.</p>
</section>
<section>
<title>
<p>Arrays are first-class objects</p></title><empty-line/>
<p>Regardless of what type of array you’re working with, the array identifier is actually a reference to a true object that’s created on the heap. This is the object that holds the references to the other objects, and it can be created either implicitly, as part of the array initialization syntax, or explicitly with a new expression. Part of the array object (in fact, the only field or method you can access) is the read-only length member that tells you how many elements can be stored in that array object. The ‘[ ]’ syntax is the only other access that you have to the array object.</p>
<p>The following example summarizes the various ways that an array can be initialized, and how the array references can be assigned to different array objects. It also shows that arrays of objects and arrays of primitives are almost identical in their use. The only difference is that arrays of objects hold references, but arrays of primitives hold the primitive values directly.</p>
<p>//: arrays/ArrayOptions.java // Initialization &amp; re-assignment of arrays. import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ArrayOptions {</p>
<p>public static void main(String[] args) {</p>
<p>// Arrays of objects:</p>
<p>BerylliumSphere[] a; // Local uninitialized variable BerylliumSphere[] b = new BerylliumSphere[5];</p>
<p>// The references inside the array are // automatically initialized to null: print(&quot;b: &quot; + Arrays.toString(b));</p>
<p>BerylliumSphere[] c = new BerylliumSphere[4]; for(int i = 0; i &lt; c.length; i++)</p>
<p>if(c[i] == null) // Can test for null reference c[i] = new BerylliumSphere();</p>
<p>// Aggregate initialization:</p>
<p>BerylliumSphere[] d = { new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere()</p>
<p>};</p>
<p>// Dynamic aggregate initialization: a = new BerylliumSphere[]{</p>
<p>new BerylliumSphere(), new BerylliumSphere(),</p>
<p>};</p>
<p>// (Trailing comma is optional in both cases) print(&quot;a.length    =    &quot;    +    a.length);</p>
<p>print(&quot;b.length    =    &quot;    +    b.length);</p>
<p>print(&quot;c.length    =    &quot;    +    c.length);</p>
<p>print(&quot;d.length    =    &quot;    +    d.length);</p>
<p>a = d;</p>
<p>print(&quot;a.length = &quot; + a.length);</p>
<p>// Arrays of primitives: int[] e; // Null reference int[] f = new int[5];</p>
<p>// The primitives inside the array are // automatically initialized to zero: print(&quot;f: &quot; + Arrays.toString(f)); int[] g = new int[4]; for(int i = 0; i &lt; g.length; i++)</p>
<p>g[i] = i*i;</p>
<p>int[] h = { 11, 47, 93 };</p>
<p>// Compile error: variable e not initialized:</p>
<p>//!print(&quot;e.length print(&quot;f.length = print(&quot;g.length = print(&quot;h.length = e = h;</p>
<p>print(&quot;e.length = e = new int[]{ 1, 2 } print(&quot;e.length = &quot; +</p>
<p>&quot; + e.length); + f.length);</p>
<p>+ g.length);</p>
<p>+ h.length);</p>
<p>+ e.length);</p>
<p>e.length);</p>
<p>}</p>
<p>} /* Output:</p>
<p>b: [null, null, null, null, null]</p>
<p>a. length = 2</p>
<p>b. length = 5</p>
<p>c. length = 4</p>
<p>d. length = 3 a.length = 3</p>
<p>f: [0, 0, 0, 0, 0]</p>
<p>f. length = 5</p>
<p>g. length = 4</p>
<p>h. length = 3 e.length = 3 e.length = 2 *///:~</p>
<p>The array a is an uninitialized local variable, and the compiler prevents you from doing anything with this reference until you’ve properly initialized it. The array b is initialized to point to an array of BerylliumSphere references, but no actual BerylliumSphere objects are ever placed in that array. However, you can still ask what the size of the array is, since b is pointing to a legitimate object. This brings up a slight drawback: You can’t find out how many elements are actually in the array, since length tells you only how many elements can be placed in the array; that is, the size of the array object, not the number of elements it actually holds. However, when an array object is created, its references are automatically initialized to null, so you can see whether a particular array slot has an object in it by checking to see whether it’s null. Similarly, an array of primitives is automatically initialized to zero for numeric types, (char)o for char, and false for boolean.</p>
<p>Array c shows the creation of the array object followed by the assignment of BerylliumSphere objects to all the slots in the array. Array d shows the &quot;aggregate initialization&quot; syntax that causes the array object to be created (implicitly with new on the heap, just like for array c) and initialized with BerylliumSphere objects, all in one statement.</p>
<p>The next array initialization can be thought of as a &quot;dynamic aggregate initialization.&quot; The aggregate initialization used by d must be used at the point of d’s definition, but with the second syntax you can create and initialize an array object anywhere. For example, suppose hide( ) is a method that takes an array of BerylliumSphere objects. You could call it by saying:</p>
<p>hide(d);</p>
<p>but you can also dynamically create the array you want to pass as the argument:</p>
<p>hide(new BerylliumSphere[]{ new BerylliumSphere(), new BerylliumSphere() });</p>
<p>In many situations this syntax provides a more convenient way to write code.</p>
<p>The expression: a = d;</p>
<p>shows how you can take a reference that’s attached to one array object and assign it to another array object, just as you can do with any other type of object reference. Now both a and d are pointing to the same array object on the heap.</p>
<p>The second part of ArrayOptions.java shows that primitive arrays work just like object arrays except that primitive arrays hold the primitive values directly.</p>
<p>Exercise 1: (2) Create a method that takes an array of BerylliumSphere as an argument. Call the method, creating the argument dynamically. Demonstrate that ordinary aggregate array initialization doesn’t work in this case. Discover the only situations where ordinary aggregate array initialization works, and where dynamic aggregate initialization is redundant.</p>
</section>
<section>
<title>
<p>Returning an array</p></title><empty-line/>
<p>Suppose you’re writing a method and you don’t want to return just one thing, but a whole bunch of things. Languages like C and C++ make this difficult because you can’t just return an array, only a pointer to an array. This introduces problems because it becomes messy to control the lifetime of the array, which leads to memory leaks.</p>
<p>In Java, you just return the array. You never worry about responsibility for that array—it will be around as long as you need it, and the garbage collector will clean it up when you’re done.</p>
<p>As an example, consider returning an array of String:</p>
<p>//: arrays/IceCream.java // Returning arrays from methods. import java.util.*;</p>
<p>public class IceCream {</p>
<p>private static Random rand = new Random(47); static final String[] FLAVORS = {</p>
<p>&quot;Chocolate&quot;, &quot;Strawberry&quot;, &quot;Vanilla Fudge Swirl&quot;,</p>
<p>&quot;Mint Chip&quot;, &quot;Mocha Almond Fudge&quot;, &quot;Rum Raisin&quot;,</p>
<p>&quot;Praline Cream&quot;, &quot;Mud Pie&quot;</p>
<p>};</p>
<p>public static String[] flavorSet(int n) { if(n &gt; FLAVORS.length)</p>
<p>throw new IllegalArgumentException(&quot;Set too big&quot;);</p>
<p>String[] results = new String[n]; boolean[] picked = new boolean[FLAVORS.length]; for(int i = 0; i &lt; n; i++) { int t; do</p>
<p>t = rand.nextInt(FLAVORS.length); while(picked[t]); results[i] = FLAVORS[t]; picked[t] = true;</p>
<p>}</p>
<p>return results;</p>
<p>}</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 7; i++)</p>
<p>System.out.println(Arrays.toString(flavorSet(3)));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[Rum Raisin, Mint Chip, Mocha Almond Fudge]</p>
<p>[Chocolate, Strawberry, Mocha Almond Fudge]</p>
<p>[Strawberry, Mint Chip, Mocha Almond Fudge]</p>
<p>[Rum Raisin, Vanilla Fudge Swirl, Mud Pie]</p>
<p>[Vanilla Fudge Swirl, Chocolate, Mocha Almond Fudge]</p>
<p>[Praline Cream, Strawberry, Mocha Almond Fudge]</p>
<p>[Mocha Almond Fudge, Strawberry, Mint Chip]</p>
<p>*///:~</p>
<p>The method flavorSet( ) creates an array of String called results. The size of this array is n, determined by the argument that you pass into the method. Then it proceeds to choose flavors randomly from the array FLAVORS and place them into results, which it returns. Returning an array is just like returning any other object—it’s a reference. It’s not important that the array was created within flavorSet( ), or that the array was created anyplace else, for that matter. The garbage collector takes care of cleaning up the array when you’re done with it, and the array will persist for as long as you need it.</p>
<p>As an aside, notice that when flavorSet( ) chooses flavors randomly, it ensures that a particular choice hasn’t already been selected. This is performed in a do loop that keeps making random choices until it finds one not already in the picked array. (Of course, a String comparison also could have been performed to see if the random choice was already in the results array.) If it’s successful, it adds the entry and finds the next one (i gets incremented).</p>
<p>You can see from the output that flavorSet( ) chooses the flavors in a random order each time.</p>
<p>Exercise 2: (1) Write a method that takes an int argument and returns an array of that size, filled with BerylliumSphere objects.</p>
</section>
<section>
<title>
<p>Multidimensional arrays</p></title><empty-line/>
<p>You can easily create multidimensional arrays. For a multidimensional array of primitives, you delimit each vector in the array by using curly braces:</p>
<p>//: arrays/MultidimensionalPrimitiveArray.java // Creating multidimensional arrays. import java.util.*;</p>
<p>public class MultidimensionalPrimitiveArray { public static void main(String[] args) { int[][] a = {</p>
<p>{ 1, 2, 3, },</p>
<p>{ 4, 5, 6, },</p>
<p>};</p>
<p>System.out.println(Arrays.deepToString(a));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[[1, 2, 3], [4, 5, 6]]</p>
<p>*///:~</p>
<p>Each nested set of curly braces moves you into the next level of the array.</p>
<p>This example uses the Java SE5 Arrays.deepToString( ) method, which turns multidimensional arrays into Strings, as you can see from the output.</p>
<p>You can also allocate an array using new. Here’s a three-dimensional array allocated in a new expression:</p>
<p>//: arrays/ThreeDWithNew.java import java.util.*;</p>
<p>public class ThreeDWithNew {</p>
<p>public static void main(String[] args) {</p>
<p>// 3-D array with fixed length: int[][][] a = new int[2][2][4]; System.out.println(Arrays.deepToString(a));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[[[0, 0, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0]]]</p>
<p>*///:~</p>
<p>You can see that primitive array values are automatically initialized if you don’t give them an explicit initialization value. Arrays of objects are initialized to null.</p>
<p>Each vector in the arrays that make up the matrix can be of any length (this is called a ragged array):</p>
<p>//: arrays/RaggedArray.java import java.util.*;</p>
<p>public class RaggedArray {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47);</p>
<p>// 3-D array with varied-length vectors: int[][][] a = new int[rand.nextInt(7)][][]; for(int i = 0; i &lt; a.length; i++) { a[i] = new int[rand.nextInt(5)][]; for(int j = 0; j &lt; a[i].length; j++) a[i][j] = new int[rand.nextInt(5)];</p>
<p>}</p>
<p>System.out.println(Arrays.deepToString(a));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[[], [[0], [0], [0, 0, 0, 0]], [[], [0, 0], [0, 0]], [[0, 0, 0], [0],</p>
<p>[0, 0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0], []], [[0], [], [0]]]</p>
<p>*///:~</p>
<p>The first new creates an array with a random-length first element and the rest undetermined. The second new inside the for loop fills out the elements but leaves the third index undetermined until you hit the third new.</p>
<p>You can deal with arrays of non-primitive objects in a similar fashion. Here, you can see how to collect many new expressions with curly braces:</p>
<p>//: arrays/MultidimensionalObjectArrays.java import java.util.*;</p>
<p>public class MultidimensionalObjectArrays { public static void main(String[] args) {</p>
<p>BerylliumSphere[][] spheres = {</p>
<p>{    new    BerylliumSphere(),    new    BerylliumSphere() },</p>
<p>{    new    BerylliumSphere(),    new    BerylliumSphere(),</p>
<p>new    BerylliumSphere(),    new    BerylliumSphere() },</p>
<p>{    new    BerylliumSphere(),    new    BerylliumSphere(),</p>
<p>new    BerylliumSphere(),    new    BerylliumSphere(),</p>
<p>new    BerylliumSphere(),    new    BerylliumSphere(),</p>
<p>new    BerylliumSphere(),    new    BerylliumSphere() },</p>
<p>};</p>
<p>System.out.println(Arrays.deepToString(spheres));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[[Sphere 0, Sphere 1], [Sphere 2, Sphere 3, Sphere 4, Sphere 5], [Sphere 6, Sphere 7, Sphere 8, Sphere 9, Sphere 10, Sphere 11, Sphere 12, Sphere 13]]</p>
<p>*///:~</p>
<p>You can see that spheres is another ragged array, where the length of each list of objects is different.</p>
<p>Autoboxing also works with array initializers: //: arrays/AutoboxingArrays.java import java.util.*;</p>
<p>public class AutoboxingArrays {</p>
<p>public static void main(String[] args) { Integer[][] a = { // Autoboxing:</p>
<table>
<tr><td>{</td><td>1,</td><td>2, 3</td><td>4,</td><td>5,</td><td>6, 7</td><td>8,</td><td>9,</td><td>10 }</td><td></td><td></td><td></td></tr>
<tr><td>{</td><td>21,</td><td>, 22,</td><td>23,</td><td>24,</td><td>25,</td><td>26,</td><td>27,</td><td>28,</td><td>29,</td><td>30</td><td>}</td></tr>
<tr><td>{</td><td>51,</td><td>, 52,</td><td>53,</td><td>54,</td><td>55,</td><td>56,</td><td>57,</td><td>58,</td><td>59,</td><td>60</td><td>}</td></tr>
<tr><td>{</td><td>71,</td><td>, 72,</td><td>73,</td><td>74,</td><td>75,</td><td>76,</td><td>77,</td><td>78,</td><td>79,</td><td>80</td><td>}</td></tr>
<tr><td colspan="12">};System.out.println(Arrays.deepToString(a));</td></tr>
</table>
<p>}</p>
<p>} /* Output:</p>
<p>[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [21, 22, 23, 24, 25, 26, 27, 28, 29, 30], [51, 52, 53, 54, 55, 56, 57, 58, 59, 60], [71, 72, 73, 74, 75, 76, 77, 78, 79, 80]]</p>
<p>*///:~</p>
<p>Here’s how an array of non-primitive objects can be built up piece-by-piece:</p>
<p>//: arrays/AssemblingMultidimensionalArrays.java // Creating multidimensional arrays. import java.util.*;</p>
<p>public class AssemblingMultidimensionalArrays { public static void main(String[] args) {</p>
<p>Integer[][] a; a = new Integer[3][]; for(int i = 0; i &lt; a.length; i++) { a[i] = new Integer[3]; for(int j = 0; j &lt; a[i].length; j++) a[i][j] = i * j; // Autoboxing</p>
<p>}</p>
<p>System.out.println(Arrays.deepToString(a));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[[0, 0, 0], [0, 1, 2], [0, 2, 4]]</p>
<p>*///:~</p>
<p>The i*j is only there to put an interesting value into the Integer.</p>
<p>The Arrays.deepToString( ) method works with both primitive arrays and object arrays:</p>
<p>//: arrays/MultiDimWrapperArray.java // Multidimensional arrays of &quot;wrapper&quot; objects. import java.util.*;</p>
<p>public class MultiDimWrapperArray {</p>
<p>public static void main(String[] args) {</p>
<p>Integer[][] a1 = { // Autoboxing { 1, 2, 3, },</p>
<p>{ 4, 5, 6, },</p>
<p>};</p>
<p>Double[][][] a2 =    {    // Autoboxing</p>
<p>};</p>
<p>String[][] a3 = {</p>
<p>{ &quot;The&quot;, &quot;Quick&quot;, &quot;Sly&quot;, &quot;Fox&quot; },</p>
<p>{ &quot;Jumped&quot;, &quot;Over&quot; },</p>
<p>{ &quot;The&quot;, &quot;Lazy&quot;, &quot;Brown&quot;, &quot;Dog&quot;, &quot;and&quot;, &quot;friend&quot; },</p>
<p>};</p>
<p>System.out.println(&quot;a1: &quot; + Arrays.deepToString(al)); System.out.println(&quot;a2: &quot; + Arrays.deepToString(a2)); System.out.println(&quot;a3: &quot; + Arrays.deepToString(a3));</p>
<p>}</p>
<p>} /* Output:</p>
<p>al: [[1, 2, 3], [4, 5, 6]]</p>
<p>a2: [[[1.1, 2.2], [3.3, 4.4]], [[5.5, 6.6], [7.7, 8.8]], [[9.9, 1.2], [2.3, 3.4]]]</p>
<p>a3: [[The, Quick, Sly, Fox], [Jumped, Over], [The, Lazy, Brown, Dog, and, friend]]</p>
<p>*///:~</p>
<p>Again, in the Integer and Double arrays, Java SE5 autoboxing creates the wrapper objects for you.</p>
<p>Exercise 3: (4) Write a method that creates and initializes a twodimensional array of double. The size of the array is determined by the arguments of the method, and the initialization values are a range determined by beginning and ending values that are also arguments of the method. Create a second method that will print the array generated by the first method. In main( ) test the methods by creating and printing several different sizes of arrays.</p>
<p>Exercise 4: (2) Repeat the previous exercise for a three-dimensional array.</p>
<p>Exercise 5: (1) Demonstrate that multidimensional arrays of nonprimitive types are automatically initialized to null.</p>
<p>Exercise 6: (1) Write a method that takes two int arguments, indicating the two sizes of a 2-D array. The method should create and fill a 2-D array of BerylliumSphere according to the size arguments.</p>
<p>Exercise 7: (1) Repeat the previous exercise for a 3-D array.</p>
</section>
<section>
<title>
<p>Arrays and generics</p></title><empty-line/>
<p>In general, arrays and generics do not mix well. You cannot instantiate arrays of parameterized types:</p>
<p>Peel&lt;Banana&gt;[] peels = new Peel&lt;Banana&gt; [10]; // Illegal</p>
<p>Erasure removes the parameter type information, and arrays must know the exact type that they hold, in order to enforce type safety.</p>
<p>However, you can parameterize the type of the array itself:</p>
<p>//: arrays/ParameterizedArrayType.java</p>
<p>class ClassParameter&lt;T&gt; {</p>
<p>public T[] f(T[] arg) { return arg; }</p>
<p>class MethodParameter {</p>
<p>public static &lt;T&gt; T[] f(T[] arg) { return arg; }</p>
<p>}</p>
<p>public class ParameterizedArrayType { public static void main(String[] args) {</p>
<p>Integer[] ints = { 1, 2, 3, 4, 5 };</p>
<p>Double[] doubles = { 1.1, 2.2, 3.3, 4.4, 5.5 };</p>
<p>Integer[] ints2 =</p>
<p>new ClassParameter&lt;Integer&gt;().f(ints);</p>
<p>Double[] doubles2 =</p>
<p>new ClassParameter&lt;Double&gt;().f(doubles); ints2 = MethodParameter.f(ints); doubles2 = MethodParameter.f(doubles);</p>
<p>}</p>
<p>} ///:~</p>
<p>Note the convenience of using a parameterized method instead of a parameterized class: You don’t have to instantiate a class with a parameter for each different type you need to apply it to, and you can make it static. Of course, you can’t always choose to use a parameterized method instead of a parameterized class, but it can be preferable.</p>
<p>As it turns out, it’s not precisely correct to say that you cannot create arrays of generic types. True, the compiler won’t let you instantiate an array of a generic type. However, it will let you create a reference to such an array. For example:</p>
<p>List&lt;String&gt;[] ls;</p>
<p>This passes through the compiler without complaint. And although you cannot create an actual array object that holds generics, you can create an array of the non-generified type and cast it:</p>
<p>//: arrays/ArrayOfGenerics.java</p>
<p>// It is possible to create arrays of generics.</p>
<p>import java.util.*;</p>
<p>public class ArrayOfGenerics {</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;String&gt;[] ls;</p>
<p>List[] la = new List[10];</p>
<p>ls = (List&lt;String&gt;[])la; // &quot;Unchecked&quot; warning ls[0] = new ArrayList&lt;String&gt;();</p>
<p>// Compile-time checking produces an error:</p>
<p>//! ls[1] = new ArrayList&lt;Integer&gt;();</p>
<p>// The problem: List&lt;String&gt; is a subtype of Object Object[] objects = ls; // So assignment is OK // Compiles and runs without complaint: objects[1] = new ArrayList&lt;Integer&gt;();</p>
<p>// However, if your needs are straightforward it is // possible to create an array of generics, albeit // with an &quot;unchecked&quot; warning:</p>
<p>List&lt;BerylliumSphere&gt;[] spheres =</p>
<p>(List&lt;BerylliumSphere&gt;[])new List[10]; for(int i = 0; i &lt; spheres.length; i++)</p>
<p>spheres[i] = new ArrayList&lt;BerylliumSphere&gt;();</p>
<p>}</p>
<p>Once you have a reference to a List&lt;String&gt;[], you can see that you get some compile-time checking. The problem is that arrays are covariant, so a List&lt;String&gt;[] is also an Object[], and you can use this to assign an ArrayList&lt;Integer&gt; into your array, with no error at either compile time or run time.</p>
<p>If you know you’re not going to upcast and your needs are relatively simple, however, it is possible to create an array of generics, which will provide basic compile-time type checking. However, a generic container will virtually always be a better choice than an array of generics.</p>
<p>In general you’ll find that generics are effective at the boundaries of a class or method. In the interiors, erasure usually makes generics unusable. So you cannot, for example, create an array of a generic type:</p>
<p>//: arrays/ArrayOfGenericType.java // Arrays of generic types won’t compile.</p>
<p>public class ArrayOfGenericType&lt;T&gt; {</p>
<p>T[] array; // OK @SuppressWarnings(&quot;unchecked&quot;) public ArrayOfGenericType(int size) {</p>
<p>//! array = new T[size]; // Illegal</p>
<p>array = (T[])new Object[size]; // &quot;unchecked&quot; Warning</p>
<p>}</p>
<p>// Illegal:</p>
<p>//! public &lt;U&gt; U[] makeArray() { return new U[10]; }</p>
<p>} ///:~</p>
<p>Erasure gets in the way again—this example attempts to create arrays of types that have been erased, and are thus unknown types. Notice that you can create an array of Object, and cast it, but without the @SuppressWarnings annotation you get an &quot;unchecked&quot; warning at compile time because the array doesn’t really hold or dynamically check for type T. That is, if I create a String[], Java will enforce at both compile time and run time that I can only place String objects in that array. However, if I create an Object[], I can put anything into that array except primitive types.</p>
<p>Exercise 8: (1) Demonstrate the assertions in the previous paragraph.</p>
<p>Exercise 9: (3) Create the classes necessary for the Peel&lt;Banana&gt; example and show that the compiler doesn’t accept it. Fix the problem using an ArrayList.</p>
<p>Exercise 10: (2) Modify ArrayOfGenerics .Java to use containers instead of arrays. Show that you can eliminate the compile-time warnings.</p>
</section>
<section>
<title>
<p>Creating test data</p></title><empty-line/>
<p>When experimenting with arrays, and with programs in general, it’s helpful to be able to easily generate arrays filled with test data. The tools in this section will fill an array with values or objects.</p>
<p>Arrays.fill()</p>
<p>The Java standard library Arrays class has a rather trivial fill( ) method: It only duplicates a single value into each location, or in the case of objects, copies the same reference into each location. Here’s an example:</p>
<p>//: arrays/FillingArrays.java // Using Arrays.fill() import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class FillingArrays {</p>
<p>public static void main(String[] args) { int size = 6;</p>
<p>boolean[] a1 = new boolean[size]; byte[] a2 = new byte[size]; char[] a3 = new char[size]; short[] a4 = new short[size]; int[] a5 = new int[size]; long[] a6 = new long[size]; float[] a7 = new float[size]; double[] a8 = new double[size]; String[] a9 = new String[size];</p>
<p>Arrays.fill(a1, print(&quot;a1 = &quot; + Arrays.fill(a2, print(&quot;a2 = &quot; + Arrays.fill(a3, print(&quot;a3 = &quot; + Arrays.fill(a4, print(&quot;a4 = &quot; + Arrays.fill(a5, print(&quot;a5 = &quot; + Arrays.fill(a6, print(&quot;a6 = &quot; + Arrays.fill(a7, print(&quot;a7 = &quot; + Arrays.fill(a8, print(&quot;a8 = &quot; + Arrays.fill(a9,</p>
<p>true);</p>
<p>Arrays.toString(al))</p>
<p>(byte)ll);</p>
<p>Arrays.toString(a2))</p>
<p>‘x&apos;);</p>
<p>Arrays.toString(a3))</p>
<p>(short)17);</p>
<p>Arrays.toString(a4))</p>
<p>19);</p>
<p>Arrays.toString(a5))</p>
<p>23);</p>
<p>Arrays.toString(a6))</p>
<p>29);</p>
<p>Arrays.toString(a7))</p>
<p>47);</p>
<p>Arrays.toString(a8))</p>
<p>&quot;Hello&quot;);</p>
<p>print(&quot;a9 = &quot;</p>
<p>// Manipulating ranges: Arrays.fill(a9, 3, 5, &quot;World&quot;); print(&quot;a9 = &quot; + Arrays.toString(a9))</p>
<p>Arrays.toString(a9))</p>
<p>}</p>
<table>
<tr><td>} /*</td><td colspan="2">Output:</td><td></td><td></td><td></td><td></td><td rowspan="8">29.0, 29.0]</td></tr>
<tr><td>a1 =</td><td colspan="3">[true, true,</td><td colspan="3">true, true,</td></tr>
<tr><td>a2 =</td><td>[11,</td><td>11,</td><td>11,</td><td>11,</td><td>11,</td><td>11]</td></tr>
<tr><td>a3 =</td><td>[x,</td><td>x, x,</td><td>x,</td><td>x,</td><td>x]</td><td></td></tr>
<tr><td>a4 =</td><td>[17,</td><td>17,</td><td>17,</td><td>17,</td><td>17,</td><td>17]</td></tr>
<tr><td>a5 =</td><td>[19,</td><td>19,</td><td>19,</td><td>19,</td><td>19,</td><td>19]</td></tr>
<tr><td>a6 =</td><td>[23,</td><td>23,</td><td>23,</td><td>23,</td><td>23,</td><td>23]</td></tr>
<tr><td>a7 =</td><td>[29.</td><td>0, 29</td><td>.0,</td><td>29.</td><td>0, 29</td><td>.0,</td></tr>
</table>
<p>a8 = [47.0, 47.0, 47.0, 47.0, 47.0, 47.0] a9 = [Hello, Hello, Hello, Hello, Hello, Hello] a9 = [Hello, Hello, Hello, World, World, Hello] *///:~</p>
<p>You can either fill the entire array or, as the last two statements show, fill a range of elements. But since you can only call Arrays.fill( ) with a single data value, the results are not especially useful.</p>
<subtitle>Data Generators</subtitle>
<p>To create more interesting arrays of data, but in a flexible fashion, we’ll use the Generator concept that was introduced in the Generics chapter. If a tool uses a Generator, you can produce any kind of data via your choice of Generator (this is an example of the Strategy design pattern-each different Generator represents a different strategy<a l:href="#bookmark72" type="note"><sup>73</sup></a><sup></sup>).</p>
<p>This section will supply some Generators, and as you’ve seen before, you can easily define your own.</p>
<p>First, here’s a basic set of counting generators for all primitive wrapper types, and for Strings. The generator classes are nested within the CountingGenerator class so that they may use the same name as the object types they are generating; for example, a generator that creates Integer objects would be created with the expression new CountingGenerator.Integer( ):</p>
<p>//: net/mindview/util/CountingGenerator.java // Simple generator implementations. package net.mindview.util;</p>
<p>public class CountingGenerator { public static class</p>
<p>Boolean implements Generator&lt;java.lang.Boolean&gt; { private boolean value = false; public java.lang.Boolean next() {</p>
<p>value = lvalue; // Just flips back and forth return value;</p>
<p>}</p>
<p>}</p>
<p>public static class</p>
<p>Byte implements Generator&lt;java.lang.Byte&gt; { private byte value = 0;</p>
<p>public java.lang.Byte next() { return value++; }</p>
<p>}</p>
<p>static char[] chars = (&quot;abcdefghijklmnopqrstuvwxyz&quot; + &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;).toCharArray(); public static class</p>
<p>Character implements Generator&lt;java.lang.Character&gt; { int index = -1;</p>
<p>public java.lang.Character next() { index = (index + 1) % chars.length; return chars[index];</p>
<p>}</p>
<p>}</p>
<p>public static class</p>
<p>String implements Generator&lt;java.lang.String&gt; { private int length = 7;</p>
<p>Generator&lt;java.lang.Character&gt; cg = new Character(); public String() {}</p>
<p>public String(int length) { this.length = length; } public java.lang.String next() { char[] buf = new char[length]; for(int i = 0; i &lt; length; i++) buf[i] = cg.next(); return new java.lang.String(buf);</p>
<p>}</p>
<p>}</p>
<p>public static class</p>
<p>Short implements Generator&lt;java.lang.Short&gt; { private short value = 0;</p>
<p>public java.lang.Short next() { return value++; }</p>
<p>}</p>
<p>public static class</p>
<p>Integer implements Generator&lt;java.lang.Integer&gt; { private int value = 0;</p>
<p>public java.lang.Integer next() { return value++; }</p>
<p>}</p>
<p>public static class</p>
<p>Long implements Generator&lt;java.lang.Long&gt; { private long value = 0;</p>
<p>public java.lang.Long next() { return value++; }</p>
<p>}</p>
<p>public static class</p>
<p>Float implements Generator&lt;java.lang.Float&gt; { private float value = 0; public java.lang.Float next() { float result = value; value += 1.0; return result;</p>
<p>}</p>
<p>}</p>
<p>public static class</p>
<p>Double implements Generator&lt;java.lang.Double&gt; { private double value = 0.0; public java.lang.Double next() { double result = value; value += 1.0; return result;</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>Each class implements some meaning of &quot;counting.&quot; In the case of</p>
<p>CountingGenerator.Character, this is just the upper and lowercase letters repeated over and over. The CountingGenerator.String class uses CountingGenerator.Character</p>
<p>to fill an array of characters, which is then turned into a String. The size of the array is determined by the constructor argument. Notice that CountingGenerator.String uses a basic Generator &lt;java.lang. Character &gt; instead of a specific reference to CountingGenerator.Character. Later, this generator can be replaced to produce RandomGenerator.String in RandomGenerator.java.</p>
<p>Here’s a test tool that uses reflection with the nested Generator idiom, so that it can be used to test any set of Generators that follow this form:</p>
<p>//: arrays/GeneratorsTest.java import net.mindview.util.*;</p>
<p>public class GeneratorsTest { public static int size = 10;</p>
<p>public static void test(Class&lt;?&gt; surroundingClass) { for(Class&lt;?&gt; type : surroundingClass.getClasses()) { System.out.print(type.getSimpleName() + &quot;: &quot;); try {</p>
<p>Generator&lt;?&gt; g = (Generator&lt;?&gt;)type.newInstance(); for(int i = 0; i &lt; size; i++)</p>
<p>System.out.printf(g.next() + &quot; &quot;);</p>
<p>System.out.println();</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) { test(CountingGenerator.class);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Double: 0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 Float: 0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 Long: 0 1 2 3 4 5 6 7 8 9 Integer: 0 1 2 3 4 5 6 7 8 9 Short: 0 1 2 3 4 5 6 7 8 9</p>
<p>String: abcdefg hijklmn opqrstu vwxyzAB CDEFGHI JKLMNOP QRSTUVW XYZabcd</p>
<p>efghijk lmnopqr</p>
<p>Character: a b c d e f g h i j</p>
<p>Byte: 0 1 2 3 4 5 6 7 8 9</p>
<p>Boolean: true false true false true false true false true false *///:~</p>
<p>This assumes that the class under test contains a set of nested Generator objects, each of which has a default constructor (one without arguments). The reflection method getClasses( ) produces all the nested classes. The test( ) method then creates an instance of each of these generators, and prints the result produced by calling next( ) ten times.</p>
<p>Here is a set of Generators that use the random number generator. Because the Random constructor is initialized with a constant value, the output is repeatable each time you run a program using one of these Generators:</p>
<p>//: net/mindview/util/RandomGenerator.java // Generators that produce random values. package net.mindview.util; import java.util.*;</p>
<p>public class RandomGenerator {</p>
<p>private static Random r = new Random(47); public static class</p>
<p>Boolean implements Generator&lt;java.lang.Boolean&gt; { public java.lang.Boolean next() { return r.nextBoolean();</p>
<p>}</p>
<p>}</p>
<p>public static class</p>
<p>Byte implements Generator&lt;java.lang.Byte&gt; { public java.lang.Byte next() { return (byte)r.nextInt();</p>
<p>}</p>
<p>}</p>
<p>public static class</p>
<p>Character implements Generator&lt;java.lang.Character&gt; { public java.lang.Character next() { return CountingGenerator.chars[</p>
<p>r.nextlnt(CountingGenerator.chars.length)];</p>
<p>public static class</p>
<p>String extends CountingGenerator.String {</p>
<p>// Plug in the random Character generator:</p>
<p>{ cg = new Character(); } // Instance initializer public String() {}</p>
<p>public String(int length) { super(length); }</p>
<p>}</p>
<p>public static class</p>
<p>Short implements Generator&lt;java.lang.Short&gt; { public java.lang.Short next() { return (short)r.nextInt();</p>
<p>}</p>
<p>}</p>
<p>public static class</p>
<p>Integer implements Generator&lt;java.lang.Integer&gt; { private int mod = 10000; public Integer() {}</p>
<p>public Integer(int modulo) { mod = modulo; } public java.lang.Integer next() { return r.nextInt(mod);</p>
<p>}</p>
<p>}</p>
<p>public static class</p>
<p>Long implements Generator&lt;java.lang.Long&gt; { private int mod = 10000; public Long() {}</p>
<p>public Long(int modulo) { mod = modulo; } public java.lang.Long next() {</p>
<p>return new java.lang.Long(r.nextInt(mod));</p>
<p>}</p>
<p>}</p>
<p>public static class</p>
<p>Float implements Generator&lt;java.lang.Float&gt; { public java.lang.Float next() {</p>
<p>// Trim all but the first two decimal places: int trimmed = Math.round(r.nextFloat() * 100); return ((float)trimmed) / 100;</p>
<p>}</p>
<p>}</p>
<p>public static class</p>
<p>Double implements Generator&lt;java.lang.Double&gt; { public java.lang.Double next() {</p>
<p>long trimmed = Math.round(r.nextDouble() * 100); return ((double)trimmed) / 100;</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>You can see that RandomGenerator.String inherits from CountingGenerator.String</p>
<p>and simply plugs in the new Character generator.</p>
<p>To generate numbers that aren’t too large, RandomGenerator.Integer defaults to a modulus of 10,000, but the overloaded constructor allows you to choose a smaller value. The same approach is used for RandomGenerator.Long. For the Float and Double Generators, the values after the decimal point are trimmed.</p>
<p>We can reuse GeneratorsTest to test RandomGenerator:</p>
<p>//: arrays/RandomGeneratorsTest.java import net.mindview.util.*;</p>
<p>public class RandomGeneratorsTest {</p>
<p>public static void main(String[] args) { GeneratorsTest.test(RandomGenerator.class);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Double: 0.73 0.53 0.16 0.19 0.52 0.27 0.26 0.05 0.8 0.76</p>
<p>Float: 0.53 0.16 0.53 0.4 0.49 0.25 0.8 0.11 0.02 0.8</p>
<p>Long: 7674 8804 8950 7826 4322 896 8033 2984 2344 5810</p>
<p>Integer: 8303 3141 7138 6012 9966 8689 7185 6992 5746 3976</p>
<p>Short: 3358 20592 284 26791 12834 -8092 13656 29324 -1423 5327</p>
<p>String: bkInaMe sbtWHkj UrUkZPg wsqPzDy CyRFJQA HxxHvHq XumcXZJ oogoYWM</p>
<p>NvqeuTp nXsgqia</p>
<p>Character: x x E A J J m z M s</p>
<p>Byte: -60 -17 55 -14 -5 115 39 -37 79 115</p>
<p>Boolean: false true false false true true true true true true *///:~</p>
<p>You can change the number of values produced by changing the GeneratorsTest.size value, which is public.</p>
<subtitle>Creating arrays from Generators</subtitle>
<p>In order to take a Generator and produce an array, we need two conversion tools. The first one uses any Generator to produce an array of Object subtypes. To cope with the problem of primitives, the second tool takes any array of primitive wrapper types and produces the associated array of primitives.</p>
<p>The first tool has two options, represented by an overloaded static method, array( ). The first version of the method takes an existing array and fills it using a Generator, and the second version takes a Class object, a Generator, and the desired number of elements, and creates a new array, again filling it using the Generator. Notice that this tool only produces arrays of Object subtypes and cannot create primitive arrays:</p>
<p>//: net/mindview/util/Generated.java package net.mindview.util; import java.util.*;</p>
<p>public class Generated {</p>
<p>// Fill an existing array:</p>
<p>public static &lt;T&gt; T[] array(T[] a, Generator&lt;T&gt; gen) { return new CollectionData&lt;T&gt;(gen, a.length).toArray(a);</p>
<p>}</p>
<p>// Create a new array:</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public static &lt;T&gt; T[] array(Class&lt;T&gt; type,</p>
<p>Generator&lt;T&gt; gen, int size) {</p>
<p>T[] a =</p>
<p>(T[])java.lang.reflect.Array.newInstance(type, size); return new CollectionData&lt;T&gt;(gen, size).toArray(a);</p>
<p>}</p>
<p>} ///:~</p>
<p>The CollectionData class will be defined in the Containers in Depth chapter. It creates a Collection object filled with elements produced by the Generator gen. The number of elements is determined by the second constructor argument. All Collection subtypes have a toArray( ) method that will fill the argument array with the elements from the Collection.</p>
<p>The second method uses reflection to dynamically create a new array of the appropriate type and size. This is then filled using the same technique as the first method.</p>
<p>We can test Generated using one of the CountingGenerator classes defined in the previous section:</p>
<p>//: arrays/TestGenerated.java</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>public class TestGenerated {</p>
<p>public static void main(String[] args) {</p>
<p>Integer[] a = { 9, 8, 7, 6 }; System.out.println(Arrays.toString(a)); a = Generated.array(a,new CountingGenerator.Integer()); System.out.println(Arrays.toString(a));</p>
<p>Integer[] b = Generated.array(Integer.class, new CountingGenerator.Integer(), 15); System.out.println(Arrays.toString(b));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[9, 8, 7, 6]</p>
<p>[0, 1, 2, 3]</p>
<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</p>
<p>*///:~</p>
<p>Even though the array a is initialized, those values are overwritten by passing it through Generated.array( ), which replaces the values (but leaves the original array in place). The initialization of b shows how you can create a filled array from scratch.</p>
<p>Generics don’t work with primitives, and we want to use the generators to fill primitive arrays. To solve the problem, we create a converter that takes any array of wrapper objects and converts it to an array of the associated primitive types. Without this tool, we would have to create special case generators for all the primitives.</p>
<p>//: net/mindview/util/ConvertTo.java package net.mindview.util;</p>
<p>public class ConvertTo {</p>
<p>public static boolean[] primitive(Boolean[] in) { boolean[] result = new boolean[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; // Autounboxing return result;</p>
<p>}</p>
<p>public static char[] primitive(Character[] in) { char[] result = new char[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result;</p>
<p>}</p>
<p>public static byte[] primitive(Byte[] in) { byte[] result = new byte[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result;</p>
<p>}</p>
<p>public static short[] primitive(Short[] in) { short[] result = new short[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i];</p>
<p>return result;</p>
<p>public static int[] primitive(Integer[] in) { int[] result = new int[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result;</p>
<p>}</p>
<p>public static long[] primitive(Long[] in) { long[] result = new long[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result;</p>
<p>}</p>
<p>public static float[] primitive(Float[] in) { float[] result = new float[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result;</p>
<p>}</p>
<p>public static double[] primitive(Double[] in) { double[] result = new double[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result;</p>
<p>}</p>
<p>} ///:~</p>
<p>Each version of primitive( ) creates an appropriate primitive array of the correct length, then copies the elements from the in array of wrapper types. Notice that autounboxing takes place in the expression:</p>
<p>result[i] = in [1];</p>
<p>Here’s an example that shows how you can use ConvertTo with both versions of Generated.array( ):</p>
<p>//: arrays/PrimitiveConversionDemonstration.java</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>public class PrimitiveConversionDemonstration {</p>
<p>public static void main(String[] args) {</p>
<p>Integer[] a = Generated.array(Integer.class, new CountingGenerator.Integer(), 15); int[] b = ConvertTo.primitive(a); System.out.println(Arrays.toString(b)); boolean[] c = ConvertTo.primitive(</p>
<p>Generated.array(Boolean.class,</p>
<p>new CountingGenerator.Boolean(), 7)); System.out.println(Arrays.toString(c));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</p>
<p>[true, false, true, false, true, false, true]</p>
<p>*///:~</p>
<p>Finally, here’s a program that tests the array generation tools using RandomGenerator classes:</p>
<p>//: arrays/TestArrayGeneration.java</p>
<p>// Test the tools that use generators to fill arrays.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class TestArrayGeneration {</p>
<p>public static void main(String[] args) { int size = 6;</p>
<p>boolean[] a1 = ConvertTo.primitive(Generated.array( Boolean.class, new RandomGenerator.Boolean(), size)); print(&quot;a1 = &quot; + Arrays.toString(a1)); byte[] a2 = ConvertTo.primitive(Generated.array( Byte.class, new RandomGenerator.Byte(), size)); print(&quot;a2 = &quot; + Arrays.toString(a2)); char[] a3 = ConvertTo.primitive(Generated.array( Character.class,</p>
<p>new RandomGenerator.Character(), size)); print(&quot;a3 = &quot; + Arrays.toString(a3)); short[] a4 = ConvertTo.primitive(Generated.array( Short.class, new RandomGenerator.Short(), size)); print(&quot;a4 = &quot; + Arrays.toString(a4)); int[] a5 = ConvertTo.primitive(Generated.array(</p>
<p>Integer.class, new RandomGenerator.Integer(), size)); print(&quot;a5 = &quot; + Arrays.toString(a5)); long[] a6 = ConvertTo.primitive(Generated.array( Long.class, new RandomGenerator.Long(), size)); print(&quot;a6 = &quot; + Arrays.toString(a6)); float[] a7 = ConvertTo.primitive(Generated.array( Float.class, new RandomGenerator.Float(), size)); print(&quot;a7 = &quot; + Arrays.toString(a7)); double[] a8 = ConvertTo.primitive(Generated.array( Double.class, new RandomGenerator.Double(), size)); print(&quot;a8 = &quot; + Arrays.toString(a8));</p>
<p>}</p>
<p>} /* Output:</p>
<p>a1 = [true, false, true, false, false, true] a2 = [104, -79, -76, 126, 33, -64] a3 = [Z, n, T, c, Q, r]</p>
<p>a4 = [-13408, 22612, 15401, 15161, -28466, -12603] a5 = [7704, 7383, 7706, 575, 8410, 6342] a6 = [7674, 8804, 8950, 7826, 4322, 896] a7 = [0.01, 0.2, 0.4, 0.79, 0.27, 0.45] a8 = [0.16, 0.87, 0.7, 0.66, 0.87, 0.59]</p>
<p>*///:~</p>
<p>This also ensures that each version of ConvertTo.primitive( ) works correctly.</p>
<p>Exercise 11: (2) Show that autoboxing doesn’t work with arrays.</p>
<p>Exercise 12: (1) Create an initialized array of double using CountingGenerator. Print the results.</p>
<p>Exercise 13: (2) Fill a String using CountingGenerator.Character.</p>
<p>Exercise 14: (6) Create an array of each primitive type, then fill each array by using CountingGenerator. Print each array.</p>
<p>Exercise 15: (2) Modify ContainerComparison.java by creating a Generator for BerylliumSphere, and change main( ) to use that Generator with Generated.array().</p>
<p>Exercise 16: (3) Starting with CountingGenerator.java, create a SkipGenerator</p>
<p>class that produces new values by incrementing according to a constructor argument. Modify TestArrayGeneration.java to show that your new class works correctly.</p>
<p>Exercise 17: (5) Create and test a Generator for BigDecimal, and ensure that it works with the Generated methods.</p>
</section>
<section>
<title>
<p>Arrays utilities</p></title><empty-line/>
<p>In java.util, you’ll find the Arrays class, which holds a set of static utility methods for arrays. There are six basic methods: equals( ), to compare two arrays for equality (and a deepEquals( ) for multidimensional arrays); fill( ), which you’ve seen earlier in this chapter; sort( ), to sort an array; binarySearch( ), to find an element in a sorted array; toString( ), to produce a String representation for an array; and hashCode( ), to produce the hash value of an array (you’ll learn what this means in the Containers in Depth chapter). All of these methods are overloaded for all the primitive types and Objects. In addition, Arrays.asList( ) takes any sequence or array and turns it into a List container—this method was covered in the Holding Your Objects chapter.</p>
<p>Before discussing the Arrays methods, there’s one other useful method that isn’t part of Arrays.</p>
<subtitle>Copying an array</subtitle>
<p>The Java standard library provides a static method, System.arraycopy( ), which can copy arrays far more quickly than if you use a for loop to perform the copy by hand. System.arraycopyC ) is overloaded to handle all types. Here’s an example that manipulates arrays of int:</p>
<p>//: arrays/CopyingArrays.java // Using System.arraycopy() import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class CopyingArrays {</p>
<p>public static void main(String[] args) { int[] i = new int[7]; int[] j = new int[10];</p>
<p>Arrays.fill(i, 47);</p>
<p>Arrays.fill(j, 99);</p>
<p>print(&quot;i = &quot; + Arrays.toString(i));</p>
<p>print(&quot;j = &quot; + Arrays.toString(j));</p>
<p>System.arraycopy(i, 0, j, 0, i.length); print(&quot;j = &quot; + Arrays.toString(j)); int[] k = new int[5];</p>
<p>Arrays.fill(k, 103);</p>
<p>System.arraycopy(i, 0, k, 0, k.length); print(&quot;k = &quot; + Arrays.toString(k));</p>
<p>Arrays.fill(k, 103);</p>
<p>System.arraycopy(k, 0, i, 0, k.length); print(&quot;i = &quot; + Arrays.toString(i));</p>
<p>// Objects:</p>
<p>Integer[] u = new Integer[10];</p>
<p>Integer[] v = new Integer[5];</p>
<p>Arrays.fill(u, new Integer(47));</p>
<p>Arrays.fiH(v, new Integer(99)); print(&quot;u = &quot; + Arrays.toString(u)); print(&quot;v = &quot; + Arrays.toString(v)); System.arraycopy(v, 0, u, u.length/2, v. print(&quot;u = &quot; + Arrays.toString(u));</p>
<p>length);</p>
<p>}</p>
<p>} /* Output:</p>
<p>The arguments to arraycopy( ) are the source array, the offset into the source array from whence to start copying, the destination array, the offset into the destination array where the copying begins, and the number of elements to copy. Naturally, any violation of the array boundaries will cause an exception.</p>
<p>The example shows that both primitive arrays and object arrays can be copied. However, if you copy arrays of objects, then only the references get copied—there’s no duplication of the objects themselves. This is called a shallow copy (see the online supplements for this book for more details).</p>
<p>System.arraycopy( ) will not perform autoboxing or autounboxing—the two arrays must be of exactly the same type.</p>
<p>Exercise 18: (3) Create and fill an array of BerylliumSphere. Copy this array to a new array and show that it’s a shallow copy.</p>
<subtitle>Comparing arrays</subtitle>
<p>Arrays provides the equals( ) method to compare entire arrays for equality, which is overloaded for all the primitives and for Object. To be equal, the arrays must have the same number of elements, and each element must be equivalent to each corresponding element in the other array, using the equals( ) for each element. (For primitives, that primitive’s wrapper class equals( ) is used; for example, Integer.equals( ) for int.) For example:</p>
<p>//: arrays/ComparingArrays.java // Using Arrays.equals() import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ComparingArrays {</p>
<p>public static void main(String[] args) { int[] a1 = new int[10]; int[] a2 = new int[10];</p>
<p>Arrays.fill(a1, 47);</p>
<p>Arrays.fill(a2, 47); print(Arrays.equals(a1, a2)); a2[3] = 11;</p>
<p>print(Arrays.equals(a1, a2));</p>
<p>String[] s1 = new String[4];</p>
<p>Arrays.fill(s1, &quot;Hi&quot;);</p>
<p>StringU s2 = { new String(&quot;Hi&quot;), new String(&quot;Hi&quot;), new String(&quot;Hi&quot;), new String(&quot;Hi&quot;) }; print(Arrays.equals(s1, s2));</p>
<p>} /* Output:</p>
<p>true</p>
<p>false</p>
<p>true</p>
<p>*///:~</p>
<p>Originally, a1 and a2 are exactly equal, so the output is &quot;true,&quot; but then one of the elements is changed, which makes the result &quot;false.&quot; In the last case, all the elements of s1 point to the same object, but s2 has five unique objects. However, array equality is based on contents (via Object.equals( )), so the result is &quot;true.&quot;</p>
<p>Exercise 19: (2) Create a class with an int field that’s initialized from a constructor argument. Create two arrays of these objects, using identical initialization values for each array, and show that Arrays.equals( ) says that they are unequal. Add an equals( ) method to your class to fix the problem.</p>
<p>Exercise 20: (4) Demonstrate deepEquals( ) for multidimensional arrays.</p>
<subtitle>Array element comparisons</subtitle>
<p>Sorting must perform comparisons based on the actual type of the object. Of course, one approach is to write a different sorting method for every different type, but such code is not reusable for new types.</p>
<p>A primary goal of programming design is to &quot;separate things that change from things that stay the same,&quot; and here, the code that stays the same is the general sort algorithm, but the thing that changes from one use to the next is the way objects are compared. So instead of placing the comparison code into many different sort routines, the Strategy design pattern is used.<a l:href="#bookmark73" type="note"><sup>74</sup></a><sup></sup> With a Strategy, the part of the code that varies is encapsulated inside a separate class (the Strategy object). You hand a Strategy object to the code that’s always the same, which uses the Strategy to fulfill its algorithm. That way, you can make different objects to express different ways of comparison and feed them to the same sorting code.</p>
<p>Java has two ways to provide comparison functionality. The first is with the &quot;natural&quot; comparison method that is imparted to a class by implementing the java.lang.Comparable interface. This is a very simple interface with a single method, compareTo( ). This method takes another object of the same type as an argument and produces a negative value if the current object is less than the argument, zero if the argument is equal, and a positive value if the current object is greater than the argument.</p>
<p>Here’s a class that implements Comparable and demonstrates the comparability by using the Java standard library method Arrays.sort( ):</p>
<p>//: arrays/CompType.java</p>
<p>// Implementing Comparable in a class.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class CompType implements Comparable&lt;CompType&gt; {</p>
<p>int i;</p>
<p>int j;</p>
<p>private static int count = 1;</p>
<p>public CompType(int n1, int n2) { i = n1; j = n2;</p>
<p>}</p>
<p>public String toString() {</p>
<p>String result = &quot;[i = &quot; + i + &quot;, j = &quot; + j + &quot;]&quot;; if(count++ % 3 == 0) result += &quot;\n&quot;; return result;</p>
<p>}</p>
<p>public int compareTo(CompType rv) {</p>
<p>return (i &lt; rv.i ? -1 : (i == rv.i ? 0 : 1));</p>
<p>}</p>
<p>private static Random r = new Random(47);</p>
<p>public static Generator&lt;CompType&gt; generator() { return new Generator&lt;CompType&gt;() { public CompType next() {</p>
<p>return new CompType(r.nextInt(100),r.nextInt(100));</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>CompType[] a =</p>
<p>Generated.array(new CompType[12], generator()); print(&quot;before sorting:&quot;); print(Arrays.toString(a));</p>
<p>Arrays.sort(a); print(&quot;after sorting:&quot;); print(Arrays.toString(a));</p>
<table>
<tr><th colspan="9">}} /* Output:</th></tr>
<tr><td>befo</td><td>re</td><td>sor</td><td>ting</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>[[i</td><td><sub>=</sub></td><td>58,</td><td>j =</td><td>55], [■</td><td>i = 93, j</td><td>= 61], [■</td><td>i = 61, j =</td><td>= 29]</td></tr>
<tr><td>, [i</td><td>=</td><td>68,</td><td>j =</td><td>0], [■</td><td>i = 22, j</td><td>= 7], [i</td><td>= 88, j =</td><td>28]</td></tr>
<tr><td>, [i</td><td>=</td><td>51,</td><td>j =</td><td>89],</td><td>[i = 9, j</td><td>= 78], [&apos;</td><td>i = 98, j =</td><td>= 61]</td></tr>
<tr><td>, [i <sub>]</sub></td><td>=</td><td>20,</td><td>j =</td><td>58],</td><td>[i = 16, j</td><td>= 40],</td><td>[i = 11, j</td><td>= 22]</td></tr>
<tr><td>afte</td><td>r</td><td>sort</td><td>ing:</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>[[i</td><td><sub>=</sub></td><td>9, j</td><td colspan="2">= 78], [i</td><td>= 11, j =</td><td>22], [i</td><td>= 16, j =</td><td>40]</td></tr>
<tr><td>, [i</td><td>=</td><td>20,</td><td>j =</td><td>58],</td><td>[i = 22, j</td><td>= 7], [&apos;</td><td>i = 51, j =</td><td>= 89]</td></tr>
<tr><td>, [i</td><td>=</td><td>58,</td><td>j =</td><td>55],</td><td>[i = 61, j</td><td>= 29],</td><td>[i = 68, j</td><td>= 0]</td></tr>
<tr><td>, [i</td><td>=</td><td>88,</td><td>j =</td><td>28],</td><td>[i = 93, j</td><td>= 61],</td><td>[i = 98, j</td><td>= 61]</td></tr>
<tr><td colspan="9">* L <sup>1</sup>    —]*///:~</td></tr>
</table>
<p>When you define the comparison method, you are responsible for deciding what it means to compare one of your objects to another. Here, only the i values are used in the comparison, and the j values are ignored.</p>
<p>The generator( ) method produces an object that implements the Generator interface by creating an anonymous inner class. This builds CompType objects by initializing them with random values. In main( ), the generator is used to fill an array of CompType, which is then sorted. If Comparable hadn’t been implemented, then you’d get a ClassCastException at run time when you tried to call sort( ). This is because sort( ) casts its argument to Comparable.</p>
<p>Now suppose someone hands you a class that doesn’t implement Comparable, or hands you this class that does implement Comparable, but you decide you don’t like the way it works and would rather have a different comparison method for the type. To solve the problem, you create a separate class that implements an interface called Comparator (briefly introduced in the Holding Your Objects chapter). This is an example of the Strategy design pattern. It has two methods, compare( ) and equals( ). However, you don’t have to implement equals( ) except for special performance needs, because anytime you create a class, it is implicitly inherited from Object, which has an equals( ). So you can just use the default Object equals( ) and satisfy the contract imposed by the interface.</p>
<p>The Collections class (which we’ll look at more in the next chapter) contains a method reverseOrder( ) that produces a Comparator to reverse the natural sorting order. This can be applied to CompType:</p>
<p>//: arrays/Reverse.java</p>
<p>// The Coltections.reverseOrderQ Comparator</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Reverse {</p>
<p>public static void main(String[] args) {</p>
<p>CompType[] a = Generated.array(</p>
<p>new CompType[12], CompType.generator()); print(&quot;before sorting:&quot;); print(Arrays.toString(a));</p>
<p>Arrays.sort(a, Collections.reverseOrder()); print(&quot;after sorting:&quot;); print(Arrays.toString(a));</p>
<p>}</p>
<p>} /* Output: before sorting:</p>
<p>]</p>
<p>*///:~</p>
<p>You can also write your own Comparator. This one compares CompType objects based on their j values rather than their i values:</p>
<p>//: arrays/ComparatorTest.java</p>
<p>// Implementing a Comparator for a class.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class CompTypeComparator implements Comparator&lt;CompType&gt; { public int compare(CompType o1, CompType o2) {</p>
<p>return (o1.j &lt; o2.j ? -1 : (o1.j == o2.j ? 0 : 1));</p>
<p>}</p>
<p>}</p>
<p>public class ComparatorTest {</p>
<p>public static void main(String[] args) { CompType[] a = Generated.array(</p>
<p>new CompType[12], CompType.generator()); print(&quot;before sorting:&quot;); print(Arrays.toString(a));</p>
<p>Arrays.sort(a, new CompTypeComparator()); print(&quot;after sorting:&quot;); print(Arrays.toString(a));</p>
<table>
<tr><th colspan="9">}} /* Output:</th></tr>
<tr><td>befo</td><td>re</td><td>sor</td><td>ting</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>[[i</td><td><sub>=</sub></td><td>58,</td><td>j =</td><td>55], [■</td><td>i = 93, j</td><td>= 61], [</td><td>i = 61, j</td><td>= 29]</td></tr>
<tr><td>, [i</td><td>=</td><td>68,</td><td>j =</td><td>0], [■</td><td>i = 22, j</td><td>= 7], [i</td><td>= 88, j =</td><td>28]</td></tr>
<tr><td>, [i</td><td>=</td><td>51,</td><td>j =</td><td>89],</td><td>[i = 9, j</td><td>= 78], [</td><td>i = 98, j</td><td>= 61]</td></tr>
<tr><td>, [i <sub>]</sub></td><td>=</td><td>20,</td><td>j =</td><td>58],</td><td>[i = 16, j</td><td>= 40],</td><td>[i = 11, j</td><td>= 22]</td></tr>
<tr><td>afte</td><td>r</td><td>sort</td><td>ing:</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>[[i</td><td><sub>=</sub></td><td>68,</td><td>j =</td><td>0], [i</td><td>= 22, j =</td><td>7], [i</td><td>= 11, j =</td><td>22]</td></tr>
<tr><td>, [i</td><td>=</td><td>88,</td><td>j =</td><td>28],</td><td>[i = 61, j</td><td>= 29],</td><td>[i = 16, j</td><td>= 40]</td></tr>
<tr><td>, [i</td><td>=</td><td>58,</td><td>j =</td><td>55],</td><td>[i = 20, j</td><td>= 58],</td><td>[i = 93, j</td><td>= 61]</td></tr>
<tr><td>, [i</td><td>=</td><td>98,</td><td>j =</td><td>61],</td><td>[i = 9, j</td><td>= 78], [</td><td>i = 51, j</td><td>= 89]</td></tr>
<tr><td colspan="9">* L <sup>1</sup>    —]*///:~</td></tr>
</table>
<p>Exercise 21: (3) Try to sort an array of the objects in Exercise 18. Implement Comparable to fix the problem. Now create a Comparator to sort the objects into reverse order.</p>
<subtitle>Sorting an array</subtitle>
<p>With the built-in sorting methods, you can sort any array of primitives, or any array of objects that either implements Comparable or has an associated Comparator.<sup>3</sup> Here’s an example that generates random String objects and sorts them:</p>
<p>//: arrays/StringSorting.java</p>
<p>// Sorting an array of Strings.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class StringSorting {</p>
<p>public static void main(String[] args) {</p>
<p>String[] sa = Generated.array(new String[20], new RandomGenerator.String(5)); print(&quot;Before sort: &quot; + Arrays.toString(sa));</p>
<p>Arrays.sort(sa);</p>
<p>print(&quot;After sort: &quot; + Arrays.toString(sa));</p>
<p>Arrays.sort(sa, Collections.reverseOrder()); print(&quot;Reverse sort: &quot; + Arrays.toString(sa));</p>
<p>Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER); print(&quot;Case-insensitive sort: &quot; + Arrays.toString(sa));</p>
<p>}</p>
<p>} /* Output:</p>
<p>Before sort: [YNzbr, nyGcF, OWZnT, cQrGs, eGZMm, JMRoE, suEcU, OneOE, dLsmw, HLGEa, hKcxr, EqUCB, bkIna, Mesbt, WHkjU, rUkZP, gwsqP, zDyCy, RFJQA, HxxHv]</p>
<p><sup>3</sup> Surprisingly, there was no support in Java 1.0 or 1.1 for sorting Strings.</p>
<p>After sort: [EqUCB, HLGEa, HxxHv, JMRoE, Mesbt, OWZnT, OneOE, RFJQA, WHkjU, YNzbr, bkIna, cQrGs, dLsmw, eGZMm, gwsqP, hKcxr, nyGcF, rUkZP, suEcU, zDyCy]</p>
<p>Reverse sort: [zDyCy, suEcU, rUkZP, nyGcF, hKcxr, gwsqP, eGZMm, dLsmw, cQrGs, bkIna, YNzbr, WHkjU, RFJQA, OneOE, OWZnT, Mesbt, JMRoE, HxxHv, HLGEa, EqUCB]</p>
<p>Case-insensitive sort: [bkIna, cQrGs, dLsmw, eGZMm, EqUCB, gwsqP, hKcxr, HLGEa, HxxHv, JMRoE, Mesbt, nyGcF, OneOE, OWZnT, RFJQA, rUkZP, suEcU, WHkjU, YNzbr, zDyCy]</p>
<p>*///:~</p>
<p>One thing you’ll notice about the output in the String sorting algorithm is that it’s lexicographic, so it puts all the words starting with uppercase letters first, followed by all the words starting with lowercase letters. (Telephone books are typically sorted this way.) If you want to group the words together regardless of case, use</p>
<p>String.CASE_INSENSITIVE_ORDER as shown in the last call to sort( ) in the above example.</p>
<p>The sorting algorithm that’s used in the Java standard library is designed to be optimal for the particular type you’re sorting—a Quicksort for primitives, and a stable merge sort for objects. You don’t need to worry about performance unless your profiler points you to the sorting process as a bottleneck.</p>
<subtitle>Searching a sorted array</subtitle>
<p>Once an array is sorted, you can perform a fast search for a particular item by using Arrays.binarySearch( ). However, if you try to use binarySearchC ) on an unsorted array the results will be unpredictable. The following example uses a</p>
<p>RandomGenerator.Integer to fill an array, and then uses the same generator to produce search values:</p>
<p>//: arrays/ArraySearching.java</p>
<p>// Using Arrays.binarySearch().</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ArraySearching {</p>
<p>public static void main(String[] args) {</p>
<p>Generator&lt;Integer&gt; gen =</p>
<p>new RandomGenerator.Integer(1000); int[] a = ConvertTo.primitive(</p>
<p>Generated.array(new Integer[25], gen));</p>
<p>Arrays.sort(a);</p>
<p>print(&quot;Sorted array: &quot; + Arrays.toString(a)); while(true) {</p>
<p>int r = gen.next();</p>
<p>int location = Arrays.binarySearch(a, r); if(location &gt;= 0) {</p>
<p>print(&quot;Location of &quot; + r + &quot; is &quot; + location +</p>
<p>&quot;, a[&quot; + location + &quot;] = &quot; + a[location]); break; // Out of while loop</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Sorted array: [128,    140,    200,    207, 258, 258,    278,    288, 322, 429, 511,</p>
<p>520, 522, 551, 555,    589,    693,    704, 809, 861,    861,    868, 916, 961, 998]</p>
<p>Location of 322 is 8, a[8] *///:~</p>
<p>In the while loop, random values are generated as search items until one of them is found.</p>
<p>Arrays.binarySearch( ) produces a value greater than or equal to zero if the search item is found. Otherwise, it produces a negative value representing the place that the element should be inserted if you are maintaining the sorted array by hand. The value produced is</p>
<p>-(insertion point) - 1</p>
<p>The insertion point is the index of the first element greater than the key, or a.size( ), if all elements in the array are less than the specified key.</p>
<p>If an array contains duplicate elements, there is no guarantee which of those duplicates will be found. The search algorithm is not designed to support duplicate elements, but rather to tolerate them. If you need a sorted list of non-duplicated elements, use a TreeSet (to maintain sorted order) or LinkedHashSet (to maintain insertion order). These classes take care of all the details for you automatically. Only in cases of performance bottlenecks should you replace one of these classes with a hand-maintained array.</p>
<p>If you sort an object array using a Comparator (primitive arrays do not allow sorting with a Comparator), you must include that same Comparator when you perform a binarySearch( ) (using the overloaded version of binarySearch( )). For example, the StringSorting.java program can be modified to perform a search:</p>
<p>//: arrays/AlphabeticSearch.java // Searching with a Comparator. import java.util.*; import net.mindview.util.*;</p>
<p>public class AlphabeticSearch {</p>
<p>public static void main(String[] args) {</p>
<p>String[] sa = Generated.array(new String[30], new RandomGenerator.String(5));</p>
<p>Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER); System.out.println(Arrays.toString(sa)); int index = Arrays.binarySearch(sa, sa[10], String.CASE_INSENSITIVE_ORDER);</p>
<p>System.out.println(&quot;Index: &quot;+ index + &quot;\n&quot;+ sa[index]);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[bkIna, cQrGs, cXZJo, dLsmw, eGZMm, EqUCB, gwsqP, hKcxr, HLGEa, HqXum, HxxHv, JMRoE, JmzMs,    Mesbt,    MNvqe,    nyGcF, ogoYW,    OneOE,    OWZnT,    RFJQA,</p>
<p>rUkZP, sgqia, slJrL,    suEcU,    uTpnX,    vpfFv, WHkjU,    xxEAJ,    YNzbr,    zDyCy]</p>
<p>Index: 10 HxxHv *///:~</p>
<p>The Comparator must be passed to the overloaded binarySearch( ) as the third argument. In this example, success is guaranteed because the search item is selected from the array itself.</p>
<p>Exercise 22: (2) Show that the results of performing a binarySearch( ) on an unsorted array are unpredictable.</p>
<p>Exercise 23: (2) Create an array of Integer, fill it with random int values (using autoboxing), and sort it into reverse order using a Comparator.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>In this chapter, you’ve seen that Java provides reasonable support for fixedsized, low-level arrays. This sort of array emphasizes performance over flexibility, just like the C and C++ array model. In the initial version of Java, fixed-sized, low-level arrays were absolutely necessary, not only because the Java designers chose to include primitive types (also for performance), but because the support for containers in that version was very minimal. Thus, in early versions of Java, it was always reasonable to choose arrays.</p>
<p>In subsequent versions of Java, container support improved significantly, and now containers tend to outshine arrays in all ways except for performance, and even then, the performance of containers has been significantly improved. As stated in other places in this book, performance problems are usually never where you imagine them to be, anyway.</p>
<p>With the addition of autoboxing and generics, holding primitives in containers has become effortless, which further encourages you to replace low-level arrays with containers. Because generics produce type-safe containers, arrays no long have an advantage on that front, either.</p>
<p>As noted in this chapter and as you’ll see when you try to use them, generics are fairly hostile towards arrays. Often, even when you can get generics and arrays to work together in some form (as you’ll see in the next chapter), you’ll still end up with &quot;unchecked&quot; warnings during compilation.</p>
<p>On several occasions I have been told directly by Java language designers that I should be using containers instead of arrays, when we were discussing particular examples (I was using arrays to demonstrate specific techniques and so I did not have that option).</p>
<p>All of these issues indicate that you should &quot;prefer containers to arrays&quot; when programming in recent versions of Java. Only when it’s proven that performance is an issue (and that switching to an array will make a difference) should you refactor to arrays.</p>
<p>This is a rather bold statement, but some languages have no fixed-sized, lowlevel arrays at all. They only have resizable containers with significantly more functionality than C/C++/Java-style arrays. Python,<a l:href="#bookmark74" type="note"><sup>75</sup></a><sup></sup> for example, has a list type that uses basic array syntax, but has much greater functionality—you can even inherit from it:</p>
<table>
<tr><th colspan="8">#: arrays/PythonLists.py</th></tr>
<tr><td>aLi</td><td>st</td><td>= [1, 2,</td><td>3,</td><td>4, 5]</td><td></td><td></td><td></td></tr>
<tr><td>pri</td><td>nt</td><td>type(aLis</td><td>t)</td><td colspan="2"># &lt;type ‘</td><td>list&apos;&gt;</td><td></td></tr>
<tr><td>pri</td><td>nt</td><td>aList # [</td><td>1,</td><td>2, 3,</td><td>4,</td><td>5]</td><td></td></tr>
<tr><td>pri</td><td>nt</td><td>aList[4]</td><td># 5</td><td>Basic</td><td>: li</td><td colspan="2">st indexing</td></tr>
<tr><td>aLi</td><td>st.</td><td>append(6)</td><td>#</td><td>lists</td><td>can</td><td>be res</td><td>ized</td></tr>
<tr><td>aLi</td><td>st</td><td>+= [7, 8]</td><td>#</td><td>Add a</td><td>lis</td><td>t to a</td><td>list</td></tr>
<tr><td>pri</td><td>nt</td><td>aList # [</td><td>1,</td><td>2, 3,</td><td>4,</td><td>5, 6, 7</td><td>, 8]</td></tr>
<tr><td>aSl</td><td>ice</td><td>! = aList[</td><td colspan="2">2:4]</td><td></td><td></td><td></td></tr>
<tr><td>pri</td><td>nt</td><td>aSlice #</td><td>[3,</td><td>4]</td><td></td><td></td><td></td></tr>
<tr><td>cla</td><td>ss</td><td>MyList(li</td><td>st)</td><td>: # In</td><td>her</td><td>it from</td><td>list</td></tr>
<tr><td></td><td>#</td><td>Define a</td><td colspan="2">method, ‘</td><td>thi</td><td>s&apos; poin</td><td>ter is</td></tr>
</table>
<p>def getReversed(self):</p>
<p>reversed = self[:] # Copy list using slices reversed.reverse() # Built-in list method return reversed</p>
<p>Iist2 = MyList(aList) # No ‘new’ needed for object creation</p>
<p>print type(list2) # &lt;class ‘_main_.MyList’&gt;</p>
<p>print list2.getReversed() # [8, 7, 6, 5, 4, 3, 2, 1]</p>
<p>#:~</p>
<p>Basic Python syntax was introduced in the previous chapter. Here, a list is created by simply surrounding a comma-separated sequence of objects with square brackets. The result is an object with a runtime type of list (the output of the print statements is shown as comments on the same line). The result of printing a list is the same as that of using Arrays.toStrmgO in Java.</p>
<p>Creating a sub-sequence of a list is accomplished with &quot;slicing,&quot; by placing the’:’ operator inside the index operation. The list type has many more builtin operations.</p>
<p>MyList is a class definition; the base classes are placed within the parentheses. Inside the class, def statements produce methods, and the first argument to the method is automatically the equivalent of this in Java, except that in Python it’s explicit and the identifier self is used by convention (it’s not a keyword). Notice how the constructor is automatically inherited.</p>
<p>Although everything in Python really is an object (including integral and floating point types), you still have an escape hatch in that you can optimize performance-critical portions of your code by writing extensions in C, C++ or a special tool called Pyrex, which is designed to easily speed up your code. This way you can have object purity without being prevented from performance improvements.</p>
<p>The PHP language<a l:href="#bookmark75" type="note"><sup>76</sup></a><sup></sup> goes even further by having only a single array type, which acts as both an int-indexed array and an associative array (a Map).</p>
<p>It’s interesting to speculate, after this many years of Java evolution, whether the designers would put primitives and low-level arrays in the language if they were to start over again. If these were left out, it would be possible to make a truly pure object-oriented language (despite claims, Java is not a pure o o language, precisely because of the low-level detritus). The initial argument for efficiency always seems compelling, but over time we have seen an evolution away from this idea and towards the use of higher-level components like containers. Add to this the fact that if containers can be built into the core language as they are in some languages, then the compiler has a much better opportunity to optimize.</p>
<p>Green-fields speculation aside, we are certainly stuck with arrays, and you will see them when reading code. Containers, however, are almost always a better choice.</p>
<p>Exercise 25: (3) Rewrite PythonLists.py in Java.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Containers in Depth</p></title><empty-line/>
<p>The Holding Your Objects chapter introduced the ideas and basic functionality of the Java containers library, and is enough to get you started using containers. This chapter explores this important library more deeply.</p>
<p>In order to get full use of the containers library, you need to know more than what was introduced in Holding Your Objects, but this chapter relies on advanced material (like generics) so it was delayed until later in the book.</p>
<p>After a more complete overview of containers, you’ll learn how hashing works, and how to write hashCode( ) and equals( ) to work with hashed containers. You’ll learn why there are different versions of some containers and how to choose between them. The chapter finishes with an exploration of general-purpose utilities and special classes.</p>
<section>
<title>
<p>Full container taxonomy</p></title><empty-line/>
<p>The &quot;Summary&quot; section of the Holding Your Objects chapter showed a simplified diagram of the Java containers library. Here is a more complete diagram of the collections library, including abstract classes and legacy components (with the exception of Queue implementations):</p>
<table>
<tr><td><image l:href="#image23.jpg"/></td>
</tr>
<tr><td>Full Container Taxonomy</td></tr>
</table>
<p>Java SE5 adds:</p>
<p>•    The Queue interface (which LinkedList has been modified to implement, as you saw in Holding Your Objects) and its implementations PriorityQueue and various flavors of BlockingQueue that will be shown in the Concurrency chapter.</p>
<p>•    A ConcurrentMap interface and its implementation ConcurrentHashMap, also for use in threading and shown in the Concurrency chapter.</p>
<p>•    CopyOnWriteArrayList and CopyOnWriteArraySet, also for concurrency.</p>
<p>•    EnumSet and EnumMap, special implementations of Set and Map for use with enums, and shown in the Enumerated Types chapter.</p>
<p>•    Several utilities in the Collections class.</p>
<p>The long-dashed boxes represent abstract classes, and you can see a number of classes whose names begin with &quot;Abstract.&quot; These can seem a bit confusing at first, but they are simply tools that partially implement a particular interface. If you were making your own Set, for example, you wouldn’t start with the Set interface and implement all the methods; instead, you’d inherit from AbstractSet and do the minimal necessary work to make your new class. However, the containers library contains enough functionality to satisfy your needs virtually all the time, so you can usually ignore any class that begins with &quot;Abstract.&quot;</p>
</section>
<section>
<title>
<p>Filling containers</p></title><empty-line/>
<p>Although the problem of printing containers is solved, filling containers suffers from the same deficiency as java.utiLArrays. Just as with Arrays, there is a companion class called Collections containing static utility methods, including one called fill( ). Like the Arrays version, this fill( ) just duplicates a single object reference throughout the container. In addition, it only works for List objects, but the resulting list can be passed to a constructor or to an addAll( ) method:</p>
<p>//: containers/FillingLists.java</p>
<p>// The Collections.fill() &amp; Collections.nCopies() methods. import java.util.*;</p>
<p>class StringAddress { private String s;</p>
<p>public StringAddress(String s) { this.s = s; } public String toString() {</p>
<p>return super.toString() + &quot; &quot; + s;</p>
<p>}</p>
<p>}</p>
<p>public class FillingLists {</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;StringAddress&gt; list= new ArrayList&lt;StringAddress&gt;( Collections.nCopies(4, new StringAddress(&quot;Hello&quot;))); System.out.println(list);</p>
<p>Collections.fill(list, new StringAddress(&quot;World!&quot;)); System.out.println(list);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>[StringAddress@82ba41 Hello, StringAddress@82ba41 Hello, StringAddress@82ba41 Hello, StringAddress@82ba41 Hello] [StringAddress@923e30 World!, StringAddress@923e30 World!, StringAddress@923e30 World!, StringAddress@923e30 World!]</p>
<p>*///:~</p>
<p>This example shows two ways to fill a Collection with references to a single object. The first, Collections.nCopies( ), creates a List which is passed to the constructor; this fills the ArrayList.</p>
<p>The toString( ) method in StringAddress calls Object.toString( ), which produces the class name followed by the unsigned hexadecimal representation of the hash code of the object (generated by the hashCode( ) method). You can see from the output that all the references are set to the same object, and this is also true after the second method, Collections.fill( ), is called. The fill( ) method is made even less useful by the fact that it can only replace elements that are already in the List and will not add new elements.</p>
<subtitle>A Generator solution</subtitle>
<p>Virtually all Collection subtypes have a constructor that takes another Collection object, from which it can fill the new container. In order to easily create test data, then, all we need to do is build a class that takes constructor arguments of a Generator (defined in the Generics chapter and further explored in the Arrays chapter) and a quantity value:</p>
<p>//: net/mindview/util/CollectionData.java</p>
<p>// A Collection filled with data using a generator object.</p>
<p>package net.mindview.util;</p>
<p>import java.util.*;</p>
<p>public class CollectionData&lt;T&gt; extends ArrayList&lt;T&gt; { public CollectionData(Generator&lt;T&gt; gen, int quantity) { for(int i = 0; i &lt; quantity; i++) add(gen.next());</p>
<p>}</p>
<p>// A generic convenience method: public static &lt;T&gt; CollectionData&lt;T&gt; list(Generator&lt;T&gt; gen, int quantity) {</p>
<p>return new CollectionData&lt;T&gt;(gen, quantity);</p>
<p>}</p>
<p>} ///:~</p>
<p>This uses the Generator to put as many objects into the container as you need. The resulting container can then be passed to the constructor for any Collection, and that constructor will copy the data into itself. The addAll( ) method that’s part of every Collection subtype can also be used to populate an existing Collection.</p>
<p>The generic convenience method reduces the amount of typing necessary when using the class.</p>
<p>CollectionData is an example of the Adapter design pattern;<a l:href="#bookmark76" type="note"><sup>77</sup></a><sup></sup> it adapts a Generator to the constructor for a Collection.</p>
<p>Here’s an example that initializes a LinkedHashSet:</p>
<p>//: containers/CollectionDataTest.java</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>class Government implements Generator&lt;String&gt; {</p>
<p>String[] foundation = (&quot;strange women lying in ponds &quot; +</p>
<p>&quot;distributing swords is no basis for a system of &quot; +</p>
<p>public class CollectionDataTest {</p>
<p>public static void main(String[] args) {</p>
<p>Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(</p>
<p>new CollectionData&lt;String&gt;(new Government(), 15));</p>
<p>// Using the convenience method:</p>
<p>set.addAll(CollectionData.list(new Government(), 15)); System.out.println(set);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[strange, women, lying, in, ponds, distributing, swords, is, no, basis, for, a, system, of, government]</p>
<p>*///:~</p>
<p>The elements are in the same order in which they are inserted because a LinkedHashSet maintains a linked list holding the insertion order.</p>
<p>All the generators defined in the Arrays chapter are now available via the CollectionData adapter. Here’s an example that uses two of them:</p>
<p>//: containers/CollectionDataGeneration.java</p>
<p>// Using the Generators defined in the Arrays chapter.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>public class CollectionDataGeneration { public static void main(String[] args) {</p>
<p>System.out.println(new ArrayList&lt;String&gt;(</p>
<p>CollectionData.list( // Convenience method new RandomGenerator.String(9), 10)));</p>
<p>System.out.println(new HashSet&lt;Integer&gt;( new CollectionData&lt;Integer&gt;(</p>
<p>new RandomGenerator.Integer(), 10)));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[YNzbrnyGc, FOWZnTcQr, GseGZMmJM, RoEsuEcUO, neOEdLsmw, HLGEahKcx, rEqUCBbkl, naMesbtWH, kjUrUkZPg, wsqPzDyCy]</p>
<p>[573, 4779, 871, 4367, 6090, 7882, 2017, 8037, 3455, 299]</p>
<p>*///:~</p>
<p>The String length produced by RandomGenerator.String is controlled by the constructor argument.</p>
<subtitle>Map generators</subtitle>
<p>We can take the same approach for a Map, but that requires a Pair class since a pair of objects (one key and one value) must be produced by each call to a Generator’s next( ) in order to populate a Map:</p>
<p>//: net/mindview/util/Pair.java package net.mindview.util;</p>
<p>public class Pair&lt;K,V&gt; { public final K key; public final V value; public Pair(K k, V v) {</p>
<p>key = k; value = v;</p>
<p>} ///:~</p>
<p>The key and value fields are made public and final so that Pair becomes a read-only Data Transfer Object (or Messenger).</p>
<p>The Map adapter can now use various combinations of Generators, Iterables, and constant values to fill Map initialization objects:</p>
<p>//: net/mindview/util/MapData.java</p>
<p>// A Map filled with data using a generator object.</p>
<p>package net.mindview.util;</p>
<p>import java.util.*;</p>
<p>public class MapData&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt; {</p>
<p>// A single Pair Generator:</p>
<p>public MapData(Generator&lt;Pair&lt;K,V&gt;&gt; gen, int quantity) { for(int i = 0; i &lt; quantity; i++) {</p>
<p>Pair&lt;K,V&gt; p = gen.next(); put(p.key, p.value);</p>
<p>}</p>
<p>}</p>
<p>// Two separate Generators:</p>
<p>public MapData(Generator&lt;K&gt; genK, Generator&lt;V&gt; genV, int quantity) {</p>
<p>for(int i = 0; i &lt; quantity; i++) { put(genK.next(), genV.next());</p>
<p>}</p>
<p>}</p>
<p>// A key Generator and a single value:</p>
<p>public MapData(Generator&lt;K&gt; genK, V value, int quantity){ for(int i = 0; i &lt; quantity; i++) { put(genK.next(), value);</p>
<p>}</p>
<p>}</p>
<p>// An Iterable and a value Generator: public MapData(Iterable&lt;K&gt; genK, Generator&lt;V&gt; genV) { for(K key : genK) { put(key, genV.next());</p>
<p>}</p>
<p>}</p>
<p>// An Iterable and a single value: public MapData(Iterable&lt;K&gt; genK, V value) { for(K key : genK) { put(key, value);</p>
<p>}</p>
<p>}</p>
<p>// Generic convenience methods: public static &lt;K,V&gt; MapData&lt;K,V&gt; map(Generator&lt;Pair&lt;K,V&gt;&gt; gen, int quantity) { return new MapData&lt;K,V&gt;(gen, quantity);</p>
<p>}</p>
<p>public static &lt;K,V&gt; MapData&lt;K,V&gt;</p>
<p>map(Generator&lt;K&gt; genK, Generator&lt;V&gt; genV, int quantity) { return new MapData&lt;K,V&gt;(genK, genV, quantity);</p>
<p>}</p>
<p>public static &lt;K,V&gt; MapData&lt;K,V&gt; map(Generator&lt;K&gt; genK, V value, int quantity) { return new MapData&lt;K,V&gt;(genK, value, quantity);</p>
<p>}</p>
<p>public static &lt;K,V&gt; MapData&lt;K,V&gt; map(Iterable&lt;K&gt; genK, Generator&lt;V&gt; genV) { return new MapData&lt;K,V&gt;(genK, genV);</p>
<p>}</p>
<p>public static &lt;K,V&gt; MapData&lt;K,V&gt; map(Iterable&lt;K&gt; genK, V value) {</p>
<p>return new MapData&lt;K,V&gt;(genK, value);</p>
<p>}</p>
<p>} ///:~</p>
<p>This gives you a choice of using a single Generator&lt;Pair&lt;K,V&gt; &gt;, two separate Generators, one Generator and a constant value, an Iterable (which includes any Collection) and a Generator, or an Iterable and a single value. The generic convenience methods reduce the amount of typing necessary when creating a MapData object.</p>
<p>Here’s an example using MapData. The Letters Generator also implements Iterable by producing an Iterator; this way, it can be used to test the MapData.map( ) methods that work with an Iterable:</p>
<p>//: containers/MapDataTest.java</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Letters implements Generator&lt;Pair&lt;Integer,String&gt;&gt;, Iterable&lt;Integer&gt; { private int size = 9; private int number = 1; private char letter = ‘A’; public Pair&lt;Integer,String&gt; next() { return new Pair&lt;Integer,String&gt;( number++, &quot;&quot; + letter++);</p>
<p>}</p>
<p>public Iterator&lt;Integer&gt; iterator() { return new Iterator&lt;Integer&gt;() {</p>
<p>public Integer next() { return number++; } public boolean hasNext() { return number &lt; size; } public void remove() {</p>
<p>throw new UnsupportedOperationException();</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>}</p>
<p>public class MapDataTest {</p>
<p>public static void main(String[] args) {</p>
<p>// Pair Generator:</p>
<p>print(MapData.map(new Letters(), 11));</p>
<p>// Two separate generators:</p>
<p>print(MapData.map(new CountingGenerator.Character(), new RandomGenerator.String(3), 8));</p>
<p>// A key Generator and a single value: print(MapData.map(new CountingGenerator.Character(),</p>
<p>&quot;Value&quot;, 6));</p>
<p>// An Iterable and a value Generator: print(MapData.map(new Letters(), new RandomGenerator.String(3)));</p>
<p>// An Iterable and a single value: print(MapData.map(new Letters(), &quot;Pop&quot;));</p>
<p>}</p>
<p>} /* Output:</p>
<p>{1=A, 2=B, 3=C, 4=D, 5=E, 6=F, 7=G, 8=H, 9=I, 10=J, 11=K}</p>
<p>{a=YNz, b=brn, c=yGc, d=FOW, e=ZnT, f=cQr, g=Gse, h=GZM} {a=Value, b=Value, c=Value, d=Value, e=Value, f=Value} {1=mJM, 2=RoE, 3=suE, 4=cUO, 5=neO, 6=EdL, 7=smw, 8=HLG} {1=Pop, 2=Pop, 3=Pop, 4=Pop, 5=Pop, 6=Pop, 7=Pop, 8=Pop}</p>
<p>This example also uses the generators from the Arrays chapter.</p>
<p>You can create any generated data set for Maps or Collections using these tools, and then initialize a Map or Collection using the constructor or the Map.putAll( ) or Collection.addAll( ) methods.</p>
<subtitle>Using Abstract classes</subtitle>
<p>An alternative approach to the problem of producing test data for containers is to create custom Collection and Map implementations. Each java.util container has its own Abstract class that provides a partial implementation of that container, so all you must do is implement the necessary methods in order to produce the desired container. If the resulting container is read-only, as it typically is for test data, the number of methods you need to provide is minimized.</p>
<p>Although it isn’t particularly necessary in this case, the following solution also provides the opportunity to demonstrate another design pattern: the Flyweight. You use a flyweight when the ordinary solution requires too many objects, or when producing normal objects takes up too much space. The Flyweight pattern externalizes part of the object so that, instead of everything in the object being contained within the object, some or all of the object is looked up in a more efficient external table (or produced through some other calculation that saves space).</p>
<p>An important point of this example is to demonstrate how relatively simple it is to create a custom Map and Collection by inheriting from the java.util.Abstract classes. In order to create a read-only Map, you inherit from AbstractMap and implement entrySet( ). In order to create a readonly Set, you inherit from AbstractSet and implement iterator( ) and size( ).</p>
<p>The data set in this example is a Map of the countries of the world and their capitals.<a l:href="#bookmark77" type="note"><sup>78</sup></a><sup></sup> The capitals( ) method produces a Map of countries and capitals. The names( ) method produces a List of the country names. In both cases you can get a partial listing by providing an int argument indicating the desired size:</p>
<p>//: net/mindview/util/Countries.java // &quot;Flyweight&quot; Maps and Lists of sample data. package net.mindview.util; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Countries {</p>
<p>public static final String[][] DATA = {</p>
<p>// Africa</p>
<p>{&quot;ALGERIA&quot;,&quot;Algiers&quot;}, {&quot;ANGOLA&quot;,&quot;Luanda&quot;},</p>
<p>{&quot;BENIN&quot;,&quot;Porto-Novo&quot;}, {&quot;BOTSWANA&quot;,&quot;Gaberone&quot;},</p>
<p>{&quot;BURKINA FASO&quot;,&quot;Ouagadougou&quot;},</p>
<p>{&quot;BURUNDI&quot;,&quot;Bujumbura&quot;},</p>
<p>{&quot;CAMEROON&quot;,&quot;Yaounde&quot;}, {&quot;CAPE VERDE&quot;,&quot;Praia&quot;},</p>
<p>{&quot;CENTRAL AFRICAN REPUBLIC&quot;,&quot;Bangui&quot;},</p>
<p>{&quot;CHAD&quot;,&quot;N&apos;djamena&quot;}, {&quot;COMOROS&quot;,&quot;Moroni&quot;},</p>
<p>{&quot;CONGO&quot;,&quot;BrazzaviHe&quot;}, {&quot;DJIBOUTI&quot;,&quot;Dijibouti&quot;}, {&quot;EGYPT&quot;,&quot;Cairo&quot;}, {&quot;EQUATORIAL GUINEA&quot;,&quot;Malabo&quot;}, {&quot;ERITREA&quot;,&quot;Asmara&quot;}, {&quot;ETHIOPIA&quot;,&quot;Addis Ababa&quot;}, {&quot;GABON&quot;,&quot;Libreville&quot;}, {&quot;THE GAMBIA&quot;,&quot;Banjul&quot;}, {&quot;GHANA&quot;,&quot;Accra&quot;}, {&quot;GUINEA&quot;,&quot;Conakry&quot;}, {&quot;BISSAU&quot;,&quot;Bissau&quot;},</p>
<p>{&quot;COTE D&apos;IVOIR (IVORY COAST)&quot;,&quot;Yamoussoukro&quot;}, {&quot;KENYA&quot;,&quot;Nairobi&quot;}, {&quot;LESOTHO&quot;,&quot;Maseru&quot;}, {&quot;LIBERIA&quot;,&quot;Monrovia&quot;}, {&quot;LIBYA&quot;,&quot;Tripoli&quot;}, {&quot;MADAGASCAR&quot;,&quot;Antananarivo&quot;}, {&quot;MALAWI&quot;,&quot;Lilongwe&quot;}, {&quot;MALI&quot;,&quot;Bamako&quot;}, {&quot;MAURITANIA&quot;,&quot;Nouakchott&quot;}, {&quot;MAURITIUS&quot;,&quot;Port Louis&quot;}, {&quot;MOROCCO&quot;,&quot;Rabat&quot;}, {&quot;MOZAMBIQUE&quot;,&quot;Maputo&quot;}, {&quot;NAMIBIA&quot;,&quot;Windhoek&quot;}, {&quot;NIGER&quot;,&quot;Niamey&quot;}, {&quot;NIGERIA&quot;,&quot;Abuja&quot;}, {&quot;RWANDA&quot;,&quot;Kigali&quot;},</p>
<p>{&quot;SAO TOME E PRINCIPE&quot;,&quot;Sao Tome&quot;}, {&quot;SENEGAL&quot;,&quot;Dakar&quot;}, {&quot;SEYCHELLES&quot;,&quot;Victoria&quot;}, {&quot;SIERRA LEONE&quot;,&quot;Freetown&quot;}, {&quot;SOMALIA&quot;,&quot;Mogadishu&quot;}, {&quot;SOUTH AFRICA&quot;,&quot;Pretoria/Cape Town&quot;}, {&quot;SUDAN&quot;,&quot;Khartoum&quot;},</p>
<p>{&quot;SWAZILAND&quot;,&quot;Mbabane&quot;}, {&quot;TANZANIA&quot;,&quot;Dodoma&quot;}, {&quot;TOGO&quot;,&quot;Lome&quot;}, {&quot;TUNISIA&quot;,&quot;Tunis&quot;}, {&quot;UGANDA&quot;,&quot;Kampala&quot;},</p>
<p>{&quot;DEMOCRATIC REPUBLIC OF THE CONGO (ZAIRE)&quot;, &quot;Kinshasa&quot;},</p>
<p>{&quot;ZAMBIA&quot;,&quot;Lusaka&quot;}, {&quot;ZIMBABWE&quot;,&quot;Harare&quot;},</p>
<p>// Asia</p>
<p>{&quot;AFGHANISTAN&quot;,&quot;Kabul&quot;}, {&quot;BAHRAIN&quot;,&quot;Manama&quot;}, {&quot;BANGLADESH&quot;,&quot;Dhaka&quot;}, {&quot;BHUTAN&quot;,&quot;Thimphu&quot;}, {&quot;BRUNEI&quot;,&quot;Bandar Seri Begawan&quot;},</p>
<p>{&quot;CAMBODIA&quot;,&quot;Phnom Penh&quot;},</p>
<p>{&quot;CHINA&quot;,&quot;Beijing&quot;}, {&quot;CYPRUS&quot;,&quot;Nicosia&quot;}, {&quot;INDIA&quot;,&quot;New Delhi&quot;}, {&quot;INDONESIA&quot;,&quot;Jakarta&quot;}, {&quot;IRAN&quot;,&quot;Tehran&quot;}, {&quot;IRAQ&quot;,&quot;Baghdad&quot;}, {&quot;ISRAEL&quot;,&quot;Jerusalem&quot;}, {&quot;JAPAN&quot;,&quot;Tokyo&quot;}, {&quot;JORDAN&quot;,&quot;Amman&quot;}, {&quot;KUWAIT&quot;,&quot;Kuwait City&quot;}, {&quot;LAOS&quot;,&quot;Vientiane&quot;}, {&quot;LEBANON&quot;,&quot;Beirut&quot;}, {&quot;MALAYSIA&quot;,&quot;Kuala Lumpur&quot;}, {&quot;THE MALDIVES&quot;,&quot;Male&quot;}, {&quot;MONGOLIA&quot;,&quot;Ulan Bator&quot;},</p>
<p>{&quot;MYANMAR (BURMA)&quot;,&quot;Rangoon&quot;},</p>
<p>{&quot;NEPAL&quot;,&quot;Katmandu&quot;}, {&quot;NORTH KOREA&quot;,&quot;P&apos;yongyang&quot;}, {&quot;OMAN&quot;,&quot;Muscat&quot;}, {&quot;PAKISTAN&quot;,&quot;Islamabad&quot;}, {&quot;PHILIPPINES&quot;,&quot;Manila&quot;}, {&quot;QATAR&quot;,&quot;Doha&quot;},</p>
<p>{&quot;SAUDI ARABIA&quot;,&quot;Riyadh&quot;}, {&quot;SINGAPORE&quot;,&quot;Singapore&quot;}, {&quot;SOUTH KOREA&quot;,&quot;Seoul&quot;}, {&quot;SRI LANKA&quot;,&quot;Colombo&quot;}, {&quot;SYRIA&quot;,&quot;Damascus&quot;},</p>
<p>{&quot;TAIWAN (REPUBLIC OF CHINA)&quot;,&quot;Taipei&quot;}, {&quot;THAILAND&quot;,&quot;Bangkok&quot;}, {&quot;TURKEY&quot;,&quot;Ankara&quot;},</p>
<p>{&quot;UNITED ARAB EMIRATES&quot;,&quot;Abu Dhabi&quot;}, {&quot;VIETNAM&quot;,&quot;Hanoi&quot;}, {&quot;YEMEN&quot;,&quot;Sana&apos;a&quot;},</p>
<p>// Australia and Oceania {&quot;AUSTRALIA&quot;,&quot;Canberra&quot;}, {&quot;FIJI&quot;,&quot;Suva&quot;}, {&quot;KIRIBATI&quot;,&quot;Bairiki&quot;},</p>
<p>{&quot;MARSHALL ISLANDS&quot;,&quot;Dalap-Uliga-Darrit&quot;}, {&quot;MICRONESIA&quot;,&quot;Palikir&quot;}, {&quot;NAURU&quot;,&quot;Yaren&quot;},</p>
<p>{&quot;NEW ZEALAND&quot;,&quot;Wellington&quot;}, {&quot;PALAU&quot;,&quot;Koror&quot;}, {&quot;PAPUA NEW GUINEA&quot;,&quot;Port Moresby&quot;},</p>
<p>{&quot;SOLOMON ISLANDS&quot;,&quot;Honaira&quot;}, {&quot;TONGA&quot;,&quot;Nuku&apos;alofa&quot;}, {&quot;TUVALU&quot;,&quot;Fongafale&quot;}, {&quot;VANUATU&quot;,&quot;&lt; Port-Vila&quot;}, {&quot;WESTERN SAMOA&quot;,&quot;Apia&quot;},</p>
<p>// Eastern Europe and former USSR {&quot;ARMENIA&quot;,&quot;Yerevan&quot;}, {&quot;AZERBAIJAN&quot;,&quot;Baku&quot;},</p>
<p>{&quot;BELARUS (BYELORUSSIA)&quot;,&quot;Minsk&quot;},</p>
<p>{&quot;BULGARIA&quot;,&quot;Sofia&quot;}, {&quot;GEORGIA&quot;,&quot;Tbilisi&quot;}, {&quot;KAZAKSTAN&quot;,&quot;Almaty&quot;}, {&quot;KYRGYZSTAN&quot;,&quot;Alma-Ata&quot;}, {&quot;MOLDOVA&quot;,&quot;Chisinau&quot;}, {&quot;RUSSIA&quot;,&quot;Moscow&quot;}, {&quot;TAJIKISTAN&quot;,&quot;Dushanbe&quot;}, {&quot;TURKMENISTAN&quot;,&quot;Ashkabad&quot;}, {&quot;UKRAINE&quot;,&quot;Kyiv&quot;}, {&quot;UZBEKISTAN&quot;,&quot;Tashkent&quot;},</p>
<p>// Europe</p>
<p>{&quot;ALBANIA&quot;,&quot;Tirana&quot;}, {&quot;ANDORRA&quot;,&quot;Andorra la Vella&quot;}, {&quot;AUSTRIA&quot;,&quot;Vienna&quot;}, {&quot;BELGIUM&quot;,&quot;Brussels&quot;}, {&quot;BOSNIA&quot;,&quot;-&quot;}, {&quot;HERZEGOVINA&quot;,&quot;Sarajevo&quot;}, {&quot;CROATIA&quot;,&quot;Zagreb&quot;}, {&quot;CZECH REPUBLIC&quot;,&quot;Prague&quot;}, {&quot;DENMARK&quot;,&quot;Copenhagen&quot;}, {&quot;ESTONIA&quot;,&quot;Tallinn&quot;}, {&quot;FINLAND&quot;,&quot;Helsinki&quot;}, {&quot;FRANCE&quot;,&quot;Paris&quot;}, {&quot;GERMANY&quot;,&quot;Berlin&quot;}, {&quot;GREECE&quot;,&quot;Athens&quot;}, {&quot;HUNGARY&quot;,&quot;Budapest&quot;}, {&quot;ICELAND&quot;,&quot;Reykjavik&quot;}, {&quot;IRELAND&quot;,&quot;Dublin&quot;}, {&quot;ITALY&quot;,&quot;Rome&quot;}, {&quot;LATVIA&quot;,&quot;Riga&quot;}, {&quot;LIECHTENSTEIN&quot;,&quot;Vaduz&quot;}, {&quot;LITHUANIA&quot;,&quot;Vilnius&quot;}, {&quot;LUXEMBOURG&quot;,&quot;Luxembourg&quot;}, {&quot;MACEDONIA&quot;,&quot;Skopje&quot;}, {&quot;MALTA&quot;,&quot;Valletta&quot;}, {&quot;MONACO&quot;,&quot;Monaco&quot;}, {&quot;MONTENEGRO&quot;,&quot;Podgorica&quot;},</p>
<p>{&quot;THE NETHERLANDS&quot;,&quot;Amsterdam&quot;}, {&quot;NORWAY&quot;,&quot;Oslo&quot;}, {&quot;POLAND&quot;,&quot;Warsaw&quot;}, {&quot;PORTUGAL&quot;,&quot;Lisbon&quot;}, {&quot;ROMANIA&quot;,&quot;Bucharest&quot;}, {&quot;SAN MARINO&quot;,&quot;San Marino&quot;}, {&quot;SERBIA&quot;,&quot;Belgrade&quot;}, {&quot;SLOVAKIA&quot;,&quot;Bratislava&quot;}, {&quot;SLOVENIA&quot;,&quot;Ljuijana&quot;}, {&quot;SPAIN&quot;,&quot;Madrid&quot;}, {&quot;SWEDEN&quot;,&quot;Stockholm&quot;}, {&quot;SWITZERLAND&quot;,&quot;Berne&quot;}, {&quot;UNITED KINGDOM&quot;,&quot;London&quot;}, {&quot;VATICAN CITY&quot;,&quot;---&quot;},</p>
<p>// North and Central America</p>
<p>{&quot;ANTIGUA AND BARBUDA&quot;,&quot;Saint John&apos;s&quot;},</p>
<p>{&quot;BAHAMAS&quot;,&quot;Nassau&quot;},</p>
<p>{&quot;BARBADOS&quot;,&quot;Bridgetown&quot;}, {&quot;BELIZE&quot;,&quot;Belmopan&quot;}, {&quot;CANADA&quot;,&quot;Ottawa&quot;}, {&quot;COSTA RICA&quot;,&quot;San Jose&quot;}, {&quot;CUBA&quot;,&quot;Havana&quot;}, {&quot;DOMINICA&quot;,&quot;Roseau&quot;},</p>
<p>{&quot;DOMINICAN REPUBLIC&quot;,&quot;Santo Domingo&quot;},</p>
<p>{&quot;EL SALVADOR&quot;,&quot;San Salvador&quot;},</p>
<p>{&quot;GRENADA&quot;,&quot;Saint George&apos;s&quot;},</p>
<p>{&quot;GUATEMALA&quot;,&quot;Guatemala City&quot;}, {&quot;HAITI&quot;,&quot;Port-au-Prince&quot;},</p>
<p>{&quot;HONDURAS&quot;,&quot;Tegucigalpa&quot;}, {&quot;JAMAICA&quot;,&quot;Kingston&quot;}, {&quot;MEXICO&quot;,&quot;Mexico City&quot;}, {&quot;NICARAGUA&quot;,&quot;Managua&quot;}, {&quot;PANAMA&quot;,&quot;Panama City&quot;}, {&quot;ST. KITTS&quot;,&quot;-&quot;}, {&quot;NEVIS&quot;,&quot;Basseterre&quot;}, {&quot;ST. LUCIA&quot;,&quot;Castries&quot;},</p>
<p>{&quot;ST. VINCENT AND THE GRENADINES&quot;,&quot;Kingstown&quot;},</p>
<p>{&quot;UNITED STATES OF AMERICA&quot;,&quot;Washington, D.C.&quot;},</p>
<p>// South America {&quot;ARGENTINA&quot;,&quot;Buenos Aires&quot;},</p>
<p>{&quot;BOLIVIA&quot;,&quot;Sucre (legal)/La Paz(administrative)&quot;}, {&quot;BRAZIL&quot;,&quot;Brasilia&quot;}, {&quot;CHILE&quot;,&quot;Santiago&quot;}, {&quot;COLOMBIA&quot;,&quot;Bogota&quot;}, {&quot;ECUADOR&quot;,&quot;Quito&quot;}, {&quot;GUYANA&quot;,&quot;Georgetown&quot;}, {&quot;PARAGUAY&quot;,&quot;Asuncion&quot;}, {&quot;PERU&quot;,&quot;Lima&quot;}, {&quot;SURINAME&quot;,&quot;Paramaribo&quot;},</p>
<p>{&quot;TRINIDAD AND TOBAGO&quot;,&quot;Port of Spain&quot;}, {&quot;URUGUAY&quot;,&quot;Montevideo&quot;}, {&quot;VENEZUELA&quot;,&quot;Caracas&quot;},</p>
<p>};</p>
<p>// Use AbstractMap by implementing entrySet() private static class FlyweightMap extends AbstractMap&lt;String,String&gt; { private static class Entry implements Map.Entry&lt;String,String&gt; { int index;</p>
<p>Entry(int index) { this.index = index; } public boolean equals(Object o) { return DATA[index][0].equals(o);</p>
<p>}</p>
<p>public String getKey() { return DATA[index][0]; } public String getValue() { return DATA[index][1]; } public String setValue(String value) {</p>
<p>throw new UnsupportedOperationException();</p>
<p>}</p>
<p>public int hashCode() {</p>
<p>return DATA[index][0].hashCode();</p>
<p>}</p>
<p>}</p>
<p>// Use AbstractSet by implementing size() &amp; iterator() static class EntrySet</p>
<p>extends AbstractSet&lt;Map.Entry&lt;String,String&gt;&gt; { private int size;</p>
<p>EntrySet(int size) { if(size &lt; 0) this.size = 0;</p>
<p>// Can’t be any bigger than the array: else if(size &gt; DATA.length) this.size = DATA.length; else</p>
<p>this.size = size;</p>
<p>}</p>
<p>public int size() { return size; } private class Iter</p>
<p>implements Iterator&lt;Map.Entry&lt;String,String&gt;&gt; {</p>
<p>// Only one Entry object per Iterator: private Entry entry = new Entry(-l); public boolean hasNext() {</p>
<p>return entry.index &lt; size - 1;</p>
<p>}</p>
<p>public Map.Entry&lt;String,String&gt; next() { entry.index++; return entry;</p>
<p>}</p>
<p>public void remove() {</p>
<p>throw new UnsupportedOperationException();</p>
<p>}</p>
<p>}</p>
<p>public</p>
<p>Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iterator() { return new Iter();</p>
<p>}</p>
<p>}</p>
<p>private static Set&lt;Map.Entry&lt;String,String&gt;&gt; entries = new EntrySet(DATA.length); public Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet() { return entries;</p>
<p>}</p>
<p>}</p>
<p>// Create a partial map of ‘size’ countries: static Map&lt;String,String&gt; select(final int size) { return new FlyweightMap() {</p>
<p>public Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet() { return new EntrySet(size);</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>static Map&lt;String,String&gt; map = new FlyweightMap(); public static Map&lt;String,String&gt; capitals() { return map; // The entire map</p>
<p>}</p>
<p>public static Map&lt;String,String&gt; capitals(int size) { return select(size); // A partial map</p>
<p>static List&lt;String&gt; names =</p>
<p>new ArrayList&lt;String&gt;(map.keySet());</p>
<p>// AH the names:</p>
<p>public static List&lt;String&gt; names() { return names; }</p>
<p>// A partial list:</p>
<p>public static List&lt;String&gt; names(int size) {</p>
<p>return new ArrayList&lt;String&gt;(select(size).keySet());</p>
<p>}</p>
<p>public static void main(String[] args) { print(capitals(10)); print(names(10));</p>
<p>print(new HashMap&lt;String,String&gt;(capitals(3))); print(new LinkedHashMap&lt;String,String&gt;(capitals(3))); print(new TreeMap&lt;String,String&gt;(capitals(3))); print(new Hashtable&lt;String,String&gt;(capitals(3))); print(new HashSet&lt;String&gt;(names(6))); print(new LinkedHashSet&lt;String&gt;(names(6))); print(new TreeSet&lt;String&gt;(names(6))); print(new ArrayList&lt;String&gt;(names(6))); print(new LinkedList&lt;String&gt;(names(6))); print(capitals().get(&quot;BRAZIL&quot;));</p>
<p>}</p>
<p>} /* Output:</p>
<p>{ALGERIA=Algiers, ANGOLA=Luanda, BENIN=Porto-Novo, BOTSWANA=Gaberone, BULGARIA=Sofia, BURKINA FASO=Ouagadougou, BURUNDI=Bujumbura, CAMEROON=Yaounde, CAPE VERDE=Praia, CENTRAL AFRICAN REPUBLIC=Bangui} [ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO, BURUNDI, CAMEROON, CAPE VERDE, CENTRAL AFRICAN REPUBLIC]</p>
<p>{BENIN=Porto-Novo, ANGOLA {ALGERIA=Algiers, ANGOLA {ALGERIA=Algiers, ANGOLA {ALGERIA=Algiers, ANGOLA [BULGARIA, BURKINA FASO, [ALGERIA, ANGOLA, BENIN, [ALGERIA, ANGOLA, BENIN, [ALGERIA, ANGOLA, BENIN, [ALGERIA, ANGOLA, BENIN, Brasilia</p>
<p>=Luanda, ALGERIA=Algiers}</p>
<p>Luanda, BENIN=Porto-Novo}</p>
<p>Luanda, BENIN=Porto-Novo}</p>
<p>Luanda, BENIN=Porto-Novo} BOTSWANA, BENIN, ANGOLA, ALGERIA] BOTSWANA, BULGARIA, BURKINA FASO] BOTSWANA, BULGARIA, BURKINA FASO] BOTSWANA, BULGARIA, BURKINA FASO] BOTSWANA, BULGARIA, BURKINA FASO]</p>
<p>*///:~</p>
<p>The two-dimensional array of String DATA is public so it can be used elsewhere. FlyweightMap must implement the entrySet( ) method, which requires both a custom Set implementation and a custom Map.Entry class. Here’s part of the flyweight: each Map.Entry object simply stores its index, rather than the actual key and value. When you call getKey( ) or getValue( ), it uses the index to return the appropriate DATA element. The EntrySet ensures that its size is no bigger than DATA.</p>
<p>You can see the other part of the flyweight implemented in EntrySet.Iterator. Instead of creating a Map.Entry object for each data pair in DATA, there’s only one Map.Entry object per iterator. The Entry object is used as a window into the data; it only contains an index into the static array of strings. Every time you call next( ) for the iterator, the index in the Entry is incremented so that it points to the next element pair, and then that Iterator’s single Entry object is returned from next( ).<a l:href="#bookmark78" type="note"><sup>79</sup></a><sup></sup></p>
<p>The select( ) method produces a FlyweightMap containing an EntrySet of the desired size, and this is used in the overloaded capitals( ) and names( ) methods that you see demonstrated in main( ).</p>
<p>For some tests, the limited size of Countries is a problem. We can take the same approach to produce initialized custom containers that have a data set of any size. This class is a List that can be any size, and is (effectively) preinitialized with Integer data:</p>
<p>//: net/mindview/util/CountingIntegerList.java // List of any length, containing sample data. package net.mindview.util; import java.util.*;</p>
<p>public class CountingIntegerList extends AbstractList&lt;Integer&gt; { private int size;</p>
<p>public CountingIntegerList(int size) { this.size = size &lt; 0 ? 0 : size;</p>
<p>}</p>
<p>public Integer get(int index) { return Integer.valueOf(index);</p>
<p>}</p>
<p>public int size() { return size; } public static void main(String[] args) {</p>
<p>System.out.println(new CountingIntegerList(30));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]</p>
<p>*///:~</p>
<p>To create a read-only List from an AbstractList, you must implement get( ) and size( ). Again, a flyweight solution is used: get( ) produces the value when you ask for it, so the List doesn’t actually have to be populated.</p>
<p>Here is a Map containing pre-initialized unique Integers and Strings; it can also be any size:</p>
<p>//: net/mindview/util/CountingMapData.java // Unlimited-length Map containing sample data. package net.mindview.util; import java.util.*;</p>
<p>public class CountingMapData extends AbstractMap&lt;Integer,String&gt; { private int size; private static String[] chars =</p>
<p>&quot;A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&quot;</p>
<p>.split(&quot; &quot;);</p>
<p>public CountingMapData(int size) { if(size &lt; 0) this.size = 0; this.size = size;</p>
<p>}</p>
<p>private static class Entry implements Map.Entry&lt;Integer,String&gt; { int index;</p>
<p>Entry(int index) { this.index = index; } public boolean equals(Object o) {</p>
<p>return Integer.valueOf(index).equals(o);</p>
<p>}</p>
<p>public Integer getKey() { return index; } public String getValue() { return</p>
<p>chars[index % chars.length] +</p>
<p>Integer.toString(index / chars.length);</p>
<p>}</p>
<p>public String setValue(String value) {</p>
<p>throw new UnsupportedOperationException();</p>
<p>public int hashCode() {</p>
<p>return Integer.valueOf(index).hashCode();</p>
<p>}</p>
<p>}</p>
<p>public Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entrySet() { // LinkedHashSet retains initialization order: Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries =</p>
<p>new LinkedHashSet&lt;Map.Entry&lt;Integer,String&gt;&gt;(); for(int i = 0; i &lt; size; i++) entries.add(new Entry(i)); return entries;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>System.out.println(new CountingMapData(60));</p>
<table>
<tr><th colspan="10">}} /* Output:</th></tr>
<tr><td>{0=A0,</td><td>1 = B0,</td><td>2=C0, 3</td><td>=D0, 4=</td><td colspan="2">E0, 5=F0, 6=G0,</td><td colspan="2">O 1—1 II00O=cIIr-v</td><td>9=J0, 10</td><td>= K0,</td></tr>
<tr><td>11=L0,</td><td>12=M0,</td><td>13=N0,</td><td>14=O0,</td><td>15=P0,</td><td>16=Q0,</td><td colspan="2">17=R0, 18=S0,</td><td>19=T0,</td><td>20=U0,</td></tr>
<tr><td>21=V0,</td><td>22=W0,</td><td>23=X0,</td><td>24=Y0,</td><td>OMIILOPM</td><td>26=A1,</td><td>27=B1,</td><td>28=C1,</td><td>29=D1,</td><td>30=E1,</td></tr>
<tr><td>31=F1,</td><td>32=G1,</td><td>33=H1,</td><td>34=I1,</td><td>35=J1,</td><td>36=K1,</td><td>37=L1,</td><td>38=M1,</td><td>39=N1,</td><td>40=O1,</td></tr>
<tr><td>41=P1,</td><td>42=Q1,</td><td>43=R1,</td><td>44=S1,</td><td>45=T1,</td><td>46=U1,</td><td>47=V1,</td><td>48=W1,</td><td>49=X1,</td><td>50=Y1,</td></tr>
<tr><td>51=Z1,</td><td>PM&lt;IIPMLO</td><td>53=B2,</td><td>54=C2,</td><td>55=D2,</td><td>56=E2,</td><td>PMu_IIr-vLO</td><td>58=G2,</td><td>59=H2}</td><td></td></tr>
<tr><td colspan="10">*///:~</td></tr>
</table>
<p>Here, a LinkedHashSet is used instead of creating a custom Set class, so the flyweight is not fully implemented.</p>
<p>Exercise 1: (1) Create a List (try both ArrayList and LinkedList) and fill it using Countries. Sort the list and print it, then apply Collections.shuffle( ) to the list repeatedly, printing it each time so that you can see how the shuffle( ) method randomizes the list differently each time.</p>
<p>Exercise 2: (2) Produce a Map and a Set containing all the countries that begin with ‘A’.</p>
<p>Exercise 3: (1) Using Countries, fill a Set multiple times with the same data and verify that the Set ends up with only one of each instance. Try this with HashSet, LinkedHashSet, and TreeSet.</p>
<p>Exercise 4: (2) Create a Collection initializer that opens a file and breaks it into words using TextFile, and then uses the words as the source of data for the resulting Collection. Demonstrate that it works.</p>
<p>Exercise 5: (3) Modify CountingMapData.java to fully implement the flyweight by adding a custom EntrySet class like the one in Countries.java.</p>
</section>
<section>
<title>
<p>Collection functionality</p></title><empty-line/>
<p>The following table shows everything you can do with a Collection (not including the methods that automatically come through with Object), and thus, everything you can do with a Set or a List. (List also has additional functionality.) Maps are not inherited from Collection and will be treated separately.</p>
<table>
<tr><td>boolean add(T)</td><td>Ensures that the container holds the argument which is of generic type T. Returns false if it doesn’t add the argument. (This is an &quot;optional&quot; method, described in the next section.)</td></tr>
<tr><td>boolean addAll( Collection&lt;? extends T&gt;)</td><td>Adds all the elements in the argument. Returns true if any elements were added. (&quot;Optional.&quot;)</td></tr>
<tr><td>void clear( )</td><td>Removes all the elements in the container. (&quot;Optional.&quot;)</td></tr>
<tr><td>boolean contains (T)</td><td>true if the container holds the argument which is of generic type T.</td></tr>
<tr><td>Boolean containsAll( Collection&lt;?&gt;)</td><td>true if the container holds all the elements in the argument.</td></tr>
<tr><td>boolean isEmpty( )</td><td>true if the container has no elements.</td></tr>
<tr><td>Iterator&lt;T&gt; iterator( )</td><td>Returns an Iterator&lt;T&gt; that you can use to move through the elements in the container.</td></tr>
<tr><td>Booleanremove(Object)</td><td>If the argument is in the container, one instance of that element is removed. Returns true if a removal occurred. (&quot;Optional&quot;)</td></tr>
<tr><td>boolean removeAll( Collection&lt;?&gt;)</td><td>Removes all the elements that are contained in the argument. Returns true if any removals occurred. (&quot;Optional.&quot;)</td></tr>
<tr><td>Boolean retainAll( Collection&lt;?&gt;)</td><td>Retains only elements that are contained in the argument (an &quot;intersection,&quot; from set theory). Returns true if any changes occurred. (&quot;Optional.&quot;)</td></tr>
<tr><td>int size( )</td><td>Returns the number of elements in the container.</td></tr>
<tr><td>Object[] toArray( )</td><td>Returns an array containing all the elements in the container.</td></tr>
<tr><td>&lt;T&gt;T[] toArray(T[] a)</td><td>Returns an array containing all the elements in the container. The runtime type of the result is that of the argument array a rather than plain Object.</td></tr>
</table>
<p>Notice that there’s no get( ) method for random-access element selection. That’s because Collection also includes Set, which maintains its own internal ordering (and thus makes random-access lookup meaningless). Thus, if you want to examine the elements of a Collection, you must use an iterator.</p>
<p>The following example demonstrates all of these methods. Although these methods work with anything that implements Collection, an ArrayList is used as a &quot;least-common denominator&quot;:</p>
<p>//: containers/CollectionMethods.java</p>
<p>// Things you can do with all Collections.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class CollectionMethods {</p>
<p>public static void main(String[] args) {</p>
<p>Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();</p>
<p>c.addAll(Countries.names(6));</p>
<p>c.add(&quot;ten&quot;);</p>
<p>c.add(&quot;eleven&quot;);</p>
<p>print(c);</p>
<p>// Make an array from the List:</p>
<p>Object[] array = c.toArray();</p>
<p>// Make a String array from the List:</p>
<p>String[] str = c.toArray(new String[0]);</p>
<p>// Find max and min elements; this means // different things depending on the way // the Comparable interface is implemented: print(&quot;Collections.max(c) = &quot; + Collections.max(c)); print(&quot;Collections.min(c) = &quot; + Collections.min(c));</p>
<p>// Add a Collection to another Collection</p>
<p>Collection&lt;String&gt; c2 = new ArrayList&lt;String&gt;();</p>
<p>c2.addAll(Countries.names(6));</p>
<p>c.addAll(c2);</p>
<p>print(c);</p>
<p>c.remove(Countries.DATA[0][0]);</p>
<p>print(c);</p>
<p>c.remove(Countries.DATA[1][0]);</p>
<p>print(c);</p>
<p>// Remove all components that are</p>
<p>// in the argument collection:</p>
<p>c.removeAll(c2);</p>
<p>print(c);</p>
<p>c.addAll(c2);</p>
<p>print(c);</p>
<p>// Is an element in this Collection?</p>
<p>String val = Countries.DATA[3][0];</p>
<p>print(&quot;c.contains(&quot; + val + &quot;) = &quot; + c.contains(val));</p>
<p>// Is a Collection in this Collection? print(&quot;c.containsAll(c2) = &quot; + c.containsAll(c2)); Collection&lt;String&gt; c3 =</p>
<p>((List&lt;String&gt;)c).subList(3, 5);</p>
<p>// Keep all the elements that are in both // c2 and c3 (an intersection of sets): c2.retainAll(c3); print(c2);</p>
<p>// Throw away all the elements // in c2 that also appear in c3: c2.removeAll(c3);</p>
<p>print(&quot;c2.isEmpty() = &quot; + c2.isEmpty()); c = new ArrayList&lt;String&gt;(); c.addAll(Countries.names(6)); print(c);</p>
<p>c.clear(); // Remove all elements print(&quot;after c.clear():&quot; + c);</p>
<p>}</p>
<p>} /* Output: [ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO, ten, eleven] CoIIections.max(c) = ten CoIIections.min(c) = ALGERIA</p>
<p>[ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO, ten, eleven, ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO]</p>
<p>[ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO, ten, eleven, ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO]</p>
<p>[BENIN, BOTSWANA, BULGARIA, BURKINA FASO, ten, eleven, ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO]</p>
<p>[ten, eIeven]</p>
<p>[ten, eleven, ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO]</p>
<p>c.contains(BOTSWANA) = true</p>
<p>c.containsAII(c2) = true</p>
<p>[ANGOLA, BENIN]</p>
<p>c2.isEmpty() = true</p>
<p>[ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] after c.cIear():[]</p>
<p>ArrayLists are created containing different sets of data and upcast to Collection objects, so it’s clear that nothing other than the Collection interface is being used. main( ) uses simple exercises to show all of the methods in Collection.</p>
<p>Subsequent sections in this chapter describe the various implementations of List, Set, and Map and indicate in each case (with an asterisk) which one should be your default choice. Descriptions of the legacy classes Vector, Stack, and Hashtable are delayed to the end of the chapter—although you shouldn’t use these classes, you will see them in old code.</p>
</section>
<section>
<title>
<p>Optional operations</p></title><empty-line/>
<p>The methods that perform various kinds of addition and removal are optional operations in the Collection interface. This means that the implementing class is not required to provide functioning definitions for these methods.</p>
<p>This is a very unusual way to define an interface. As you’ve seen, an interface is a contract in object-oriented design. It says, &quot;No matter how you choose to implement this interface, I guarantee that you can send these messages to this object.&quot;<a l:href="#bookmark79" type="note"><sup>80</sup></a><sup></sup> But an &quot;optional&quot; operation violates this very fundamental principle; it says that calling some methods will nor perform meaningful behavior. Instead, they will throw exceptions! It appears that compile-time type safety is discarded.</p>
<p>It’s not quite that bad. If an operation is optional, the compiler still restricts you to calling only the methods in that interface. It’s not like a dynamic language, in which you can call any method for any object, and find out at run time whether a particular call will work.<a l:href="#bookmark80" type="note"><sup>81</sup></a><sup></sup> In addition, most methods that take a Collection as an argument only read from that Collection, and all the &quot;read&quot; methods of Collection are not optional.</p>
<p>Why would you define methods as &quot;optional&quot;? Doing so prevents an explosion of interfaces in the design. Other designs for container libraries always seem to end up with a confusing plethora of interfaces to describe each of the variations on the main theme. It’s not even possible to capture all of the special cases in interfaces, because someone can always invent a new interface. The &quot;unsupported operation&quot; approach achieves an important goal of the Java containers library: The containers are simple to learn and use. Unsupported operations are a special case that can be delayed until necessary. For this approach to work, however:</p>
<p>1.    The UnsupportedOperationException must be a rare event. That is, for most classes, all operations should work, and only in special cases should an operation be unsupported. This is true in the Java containers library, since the classes you’ll use 99 percent of the time—ArrayList, LinkedList, HashSet, and HashMap, as well as the other concrete implementations—support all of the operations. The design does provide a &quot;back door&quot; if you want to create a new Collection without providing meaningful definitions for all the methods in the Collection interface, and yet still fit it into the existing library.</p>
<p>2.    When an operation is unsupported, there should be reasonable likelihood that an UnsupportedOperationException will appear at implementation time, rather than after you’ve shipped the product to the customer. After all, it indicates a programming error: You’ve used an implementation incorrectly.</p>
<p>It’s worth noting that unsupported operations are only detectable at run time, and therefore represent dynamic type checking. If you’re coming from a statically typed language like C++, Java might appear to be just another statically typed language. Java certainly has static type checking, but it also has a significant amount of dynamic typing, so it’s hard to say that it’s exactly one type of language or another. Once you begin to notice this, you’ll start to see other examples of dynamic type checking in Java.</p>
<subtitle>Unsupported operations</subtitle>
<p>A common source of unsupported operations involves a container backed by a fixed-sized data structure. You get such a container when you turn an array into a List with the Arrays.asList( ) method. You can also choose to make any container (including a Map) throw UnsupportedOperationExceptions by using the &quot;unmodifiable&quot; methods in the Collections class. This example shows both cases:</p>
<p>//: containers/Unsupported.java // Unsupported operations in Java containers. import java.util.*;</p>
<p>public class Unsupported {</p>
<p>static void test(String msg, List&lt;String&gt; list) {</p>
<p>System.out.println(&quot;— &quot; + msg + &quot; —&quot;);</p>
<p>Collection&lt;String&gt; c = list;</p>
<p>Collection&lt;String&gt; subList = list.subList(1,8);</p>
<p>// Copy of the sublist:</p>
<p>Collection&lt;String&gt; c2 = new ArrayList&lt;String&gt;(subList); try { c.retainAll(c2); } catch(Exception e) { System.out.println(&quot;retainAll(): &quot; + e);</p>
<p>}</p>
<p>try { c.removeAll(c2); } catch(Exception e) { System.out.println(&quot;removeAll(): &quot; + e);</p>
<p>}</p>
<p>try { c.clear(); } catch(Exception e) {</p>
<p>System.out.println(&quot;clear(): &quot; + e);</p>
<p>}</p>
<p>try { c.add(&quot;X&quot;); } catch(Exception e) {</p>
<p>System.out.println(&quot;add(): &quot; + e);</p>
<p>}</p>
<p>try { c.addAll(c2); } catch(Exception e) { System.out.println(&quot;addAll(): &quot; + e);</p>
<p>}</p>
<p>try { c.remove(&quot;C&quot;); } catch(Exception e) {</p>
<p>}</p>
<p>// The List.set() method modifies the value but // doesn’t change the size of the data structure: try {</p>
<p>list.set(0, &quot;X&quot;);</p>
<p>} catch(Exception e) {</p>
<p>System.out.println(&quot;List.set(): &quot; + e);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;String&gt; list =</p>
<p>Arrays.asList(&quot;A B C D E F G H I J K L&quot;.split(&quot; &quot;)); test(&quot;Modifiable Copy&quot;, new ArrayList&lt;String&gt;(list)); test(&quot;Arrays.asList()&quot;, list); test(&quot;unmodifiableList()&quot;,</p>
<p>Collections.unmodifiableList( new ArrayList&lt;String&gt;(list)));</p>
<p>}</p>
<p>} /* Output:</p>
<p>—    Modifiable Copy —</p>
<p>—    Arrays.asList() —</p>
<p>retainAll(): java.lang.UnsupportedOperationException removeAll(): java.lang.UnsupportedOperationException clear(): java.lang.UnsupportedOperationException add(): java.lang.UnsupportedOperationException addAll(): java.lang.UnsupportedOperationException remove(): java.lang.UnsupportedOperationException</p>
<p>—    unmodifiableList() —</p>
<p>retainAll(): java.lang.UnsupportedOperationException removeAll(): java.lang.UnsupportedOperationException clear(): java.lang.UnsupportedOperationException add(): java.lang.UnsupportedOperationException addAll(): java.lang.UnsupportedOperationException remove(): java.lang.UnsupportedOperationException List.set(): java.lang.UnsupportedOperationException *///:~</p>
<p>Because Arrays.asList( ) produces a List that is backed by a fixed-size array, it makes sense that the only supported operations are the ones that don’t change the size of the array. Any method that would cause a change to the size of the underlying data structure produces an UnsupportedOperationException, to indicate a call to an unsupported method (a programming error).</p>
<p>Note that you can always pass the result of Arrays.asList( ) as a constructor argument to any Collection (or use the addAll( ) method, or the Collections.addAll( ) static</p>
<p>method) in order to create a regular container that allows the use of all the methods—this is shown in the first call to test( ) in main( ). Such a call produces a new resizable underlying data structure.</p>
<p>The &quot;unmodifiable&quot; methods in the Collections class wrap the container in a proxy that produces an UnsupportedOperationException if you perform any operation that modifies the container in any way. The goal of using these methods is to produce a &quot;constant&quot; container object. The full list of &quot;unmodifiable&quot; Collections methods is described later.</p>
<p>The last try block in test( ) examines the set( ) method that’s part of List. This is interesting, because you can see how the granularity of the &quot;unsupported operation&quot; technique comes in handy—the resulting &quot;interface&quot; can vary by one method between the object returned by Arrays.asList( ) and that returned by</p>
<p>Collections.unmodifiableList( ). Arrays.asList( ) returns a fixed-sized List, whereas Collections.unmodifiableList( ) produces a list that cannot be changed. As you can see</p>
<p>from the output, it’s OK to modify the elements in the List returned by Arrays.asList( ), because this would not violate the &quot;fixed-sized&quot; nature of that List. But clearly, the result of unmodifiableList( ) should not be modifiable in any way. If interfaces were used, this would have required two additional interfaces, one with a working set( ) method and one without. Additional interfaces would be required for various unmodifiable subtypes of Collection.</p>
<p>The documentation for a method that takes a container as an argument should specify which of the optional methods must be implemented.</p>
<p>Exercise 6: (2) Note that List has additional &quot;optional&quot; operations that are not included in Collection. Write a version of Unsupported.java that tests these additional optional operations.</p>
</section>
<section>
<title>
<p>List functionality</p></title><empty-line/>
<p>As you’ve seen, the basic List is quite simple to use: Most of the time you just call add( ) to insert objects, use get( ) to get them out one at a time, and call iterator( ) to get an Iterator for the sequence.</p>
<p>The methods in the following example each cover a different group of activities: things that every List can do (basicTest( )), moving around with an Iterator (iterMotion( )) versus changing things with an Iterator (iterManipulation( )), seeing the effects of List manipulation (testVisual( )), and operations available only to LinkedLists:</p>
<p>//: containers/Lists.java</p>
<p>// Things you can do with Lists.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Lists {</p>
<p>private static boolean b; private static String s; private static int i; private static Iterator&lt;String&gt; it; private static ListIterator&lt;String&gt; lit; public static void basicTest(List&lt;String&gt; a) { a.add(1, &quot;x&quot;); // Add at location 1 a.add(&quot;x&quot;); // Add at end // Add a collection: a.addAll(Countries.names(25));</p>
<p>// Add a collection starting at location 3: a.addAll(3, Countries.names(25)); b = a.contains(&quot;1&quot;); // Is it in there?</p>
<p>// Is the entire collection in there? b = a.containsAll(Countries.names(25));</p>
<p>// Lists allow random access, which is cheap // for ArrayList, expensive for LinkedList: s = a.get(1); // Get (typed) object at location 1 i = a.indexOf(&quot;1&quot;); // Tell index of object b = a.isEmpty(); // Any elements inside? it = a.iterator(); // Ordinary Iterator lit = a.listIterator(); // ListIterator lit = a.listIterator(3); // Start at loc 3 i = a.lastIndexOf(&quot;1&quot;); // Last match a.remove(1); // Remove location 1 a.remove(&quot;3&quot;); // Remove this object a.set(1, &quot;y&quot;); // Set location 1 to &quot;y&quot;</p>
<p>// Keep everything that’s in the argument // (the intersection of the two sets): a.retainAll(Countries.names(25));</p>
<p>// Remove everything that’s in the argument: a.removeAll(Countries.names(25)); i = a.size(); // How big is it? a.clear(); // Remove all elements</p>
<p>}</p>
<p>public static void iterMotion(List&lt;String&gt; a) {</p>
<p>ListIterator&lt;String&gt; it = a.listIterator(); b = it.hasNext(); b = it.hasPrevious(); s = it.next(); i = it.nextIndex(); s = it.previous();</p>
<p>i = it.previousIndex();</p>
<p>public static void iterManipulation(List&lt;String&gt; a) { ListIterator&lt;String&gt; it = a.listIterator(); it.add(&quot;47&quot;);</p>
<p>// Must move to an element after add(): it.next();</p>
<p>// Remove the element after the newly produced one: it.remove();</p>
<p>// Must move to an element after remove(): it.next();</p>
<p>// Change the element after the deleted one: it.set(&quot;47&quot;);</p>
<p>}</p>
<p>public static void testVisual(List&lt;String&gt; a) { print(a);</p>
<p>List&lt;String&gt; b = Countries.names(25);</p>
<p>print(&quot;b = &quot; + b);</p>
<p>a.addAll(b);</p>
<p>a.addAll(b);</p>
<p>print(a);</p>
<p>// Insert, remove, and replace elements // using a ListIterator:</p>
<p>ListIterator&lt;String&gt; x = a.listIterator(a.size()/2);</p>
<p>x.add(&quot;one&quot;);</p>
<p>print(a);</p>
<p>print(x.next());</p>
<p>x.remove();</p>
<p>print(x.next());</p>
<p>x.set(&quot;47&quot;);</p>
<p>print(a);</p>
<p>// Traverse the list backwards: x = a.listIterator(a.size()); while(x.hasPrevious())</p>
<p>printnb(x.previous() + &quot; &quot;); print();</p>
<p>print(&quot;testVisual finished&quot;);</p>
<p>}</p>
<p>// There are some things that only LinkedLists can do: public static void testLinkedList() {</p>
<p>LinkedList&lt;String&gt; ll = new LinkedList&lt;String&gt;();</p>
<p>ll.addAll(Countries.names(25));</p>
<p>print(ll);</p>
<p>// Treat it like a stack, pushing:</p>
<p>ll.addFirst(&quot;one&quot;);</p>
<p>ll.addFirst(&quot;two&quot;);</p>
<p>print(ll);</p>
<p>// Like &quot;peeking&quot; at the top of a stack: print(ll.getFirst());</p>
<p>// Like popping a stack: print(ll.removeFirst()); print(ll.removeFirst());</p>
<p>// Treat it like a queue, pulling elements // off the tail end: print(ll.removeLast()); print(ll);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>// Make and fill a new list each time: basicTest(</p>
<p>new LinkedList&lt;String&gt;(Countries.names(25))); basicTest(</p>
<p>new ArrayList&lt;String&gt;(Countries.names(25)));</p>
<p>iterMotion(</p>
<p>new LinkedList&lt;String&gt;(Countries.names(25))); iterMotion(</p>
<p>new ArrayList&lt;String&gt;(Countries.names(25))); iterManipulation(</p>
<p>new LinkedList&lt;String&gt;(Countries.names(25))); iterManipulation(</p>
<p>new ArrayList&lt;String&gt;(Countries.names(25))); testVisual(</p>
<p>new LinkedList&lt;String&gt;(Countries.names(25))); testLinkedList();</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>In basicTest( ) and iterMotion( ) the calls are made in order to show the proper syntax, and although the return value is captured, it is not used. In some cases, the return value isn’t captured at all. You should look up the full usage of each of these methods in the JDK documentation before you use them.</p>
<p>Exercise 7: (4) Create both an ArrayList and a LinkedList, and fill each using the Countries.names( ) generator. Print each list using an ordinary Iterator, then insert one list into the other by using a Listlterator, inserting at every other location. Now perform the insertion starting at the end of the first list and moving backward.</p>
<p>Exercise 8: (7) Create a generic, singly linked list class called SList, which, to keep things simple, does not implement the List interface. Each Link object in the list should contain a reference to the next element in the list, but not the previous one (LinkedList, in contrast, is a doubly linked list, which means it maintains links in both directions). Create your own SListIterator which, again for simplicity, does not implement ListIterator. The only method in SList other than toString( ) should be iterator( ), which produces an SListIterator. The only way to insert and remove elements from an SList is through SListIterator. Write code to demonstrate SList.</p>
</section>
<section>
<title>
<p>Sets and storage order</p></title><empty-line/>
<p>The Set examples in the Holding Your Objects chapter provide a good introduction to the operations that can be performed with basic Sets. However, those examples conveniently use predefined Java types such as Integer and String, which were designed to be usable inside containers. When creating your own types, be aware that a Set needs a way to maintain storage order. How the storage order is maintained varies from one implementation of Set to another. Thus, different Set implementations not only have different behaviors, they have different requirements for the type of object that you can put into a particular Set:</p>
<table>
<tr><td>Set (interface)</td><td>Each element that you add to the Set must be unique; otherwise, the Set doesn’t add the duplicate element. Elements added to a Set must at least define equals( ) to establish object uniqueness. Set has exactly the same interface as Collection. The Set interface does not guarantee that it will maintain its elements in any particular order.</td></tr>
<tr><td>HashSet*</td><td>For Sets where fast lookup time is important. Elements must also define hashCode( ).</td></tr>
<tr><td>TreeSet</td><td>An ordered Set backed by a tree. This way, you can extract an ordered sequence from a Set. Elements must also implement the Comparable interface.</td></tr>
<tr><td>LinkedHashSet</td><td>Has the lookup speed of a HashSet, but internally maintains the order in which you add the elements (the insertion order) using a linked list. Thus, when you iterate through the Set, the results appear in insertion order. Elements must also define hashCode( ).</td></tr>
</table>
<p>The asterisk on HashSet indicates that, in the absence of other constraints, this should be your default choice because it is optimized for speed.</p>
<p>Defining hashCode( ) will be described later in this chapter. You must create an equals( ) for both hashed and tree storage, but the hashCode( ) is necessary only if the class will be placed in a HashSet (which is likely, since that should generally be your first choice as a Set implementation) or LinkedHashSet. However, for good programming style, you should always override hashCode( ) when you override equals( ).</p>
<p>This example demonstrates the methods that must be defined in order to successfully use a type with a particular Set implementation:</p>
<p>//: containers/TypesForSets.java</p>
<p>// Methods necessary to put your own type in a Set. import java.util.*;</p>
<p>class SetType { int i;</p>
<p>public SetType(int n) { i = n; } public boolean equals(Object o) {</p>
<p>return o instanceof SetType &amp;&amp; (i == ((SetType)o).i);</p>
<p>}</p>
<p>public String toString() { return Integer.toString(i); }</p>
<p>}</p>
<p>class HashType extends SetType {</p>
<p>public HashType(int n) { super(n); } public int hashCode() { return i; }</p>
<p>}</p>
<p>class TreeType extends SetType implements Comparable&lt;TreeType&gt; { public TreeType(int n) { super(n); } public int compareTo(TreeType arg) {</p>
<p>return (arg.i &lt; i ? -1 : (arg.i == i ? 0 : 1));</p>
<p>}</p>
<p>}</p>
<p>public class TypesForSets {</p>
<p>static &lt;T&gt; Set&lt;T&gt; fill(Set&lt;T&gt; set, Class&lt;T&gt; type) { try {</p>
<p>for(int i = 0; i &lt; 10; i++) set.add(</p>
<p>type.getConstructor(int.class).newInstance(i)); } catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>return set;</p>
<p>}</p>
<p>static &lt;T&gt; void test(Set&lt;T&gt; set, Class&lt;T&gt; type) { fill(set, type);</p>
<p>fill(set, type); // Try to add duplicates fill(set, type);</p>
<p>System.out.println(set);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>test(new HashSet&lt;HashType&gt;(), HashType.class); test(new LinkedHashSet&lt;HashType&gt;(), HashType.class); test(new TreeSet&lt;TreeType&gt;(), TreeType.class);</p>
<p>// Things that don’t work:</p>
<p>test(new HashSet&lt;SetType&gt;(), SetType.class); test(new HashSet&lt;TreeType&gt;(), TreeType.class); test(new LinkedHashSet&lt;SetType&gt;(), SetType.class); test(new LinkedHashSet&lt;TreeType&gt;(), TreeType.class); try {</p>
<p>test(new TreeSet&lt;SetType&gt;(), SetType.class);</p>
<p>} catch(Exception e) {</p>
<p>System.out.println(e.getMessage());</p>
<p>}</p>
<p>try {</p>
<p>test(new TreeSet&lt;HashType&gt;(), HashType.class);</p>
<p>} catch(Exception e) {</p>
<p>System.out.println(e.getMessage());</p>
<p>}</p>
<p>}</p>
<table>
<tr><th colspan="24">} /* Output: (Sample)</th></tr>
<tr><td>[2,</td><td>4,</td><td>9,</td><td>8,</td><td>6,</td><td>1,</td><td>3,</td><td>7,</td><td>5,</td><td>0]</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>[0,</td><td>1,</td><td>2,</td><td>3,</td><td>4,</td><td>5,</td><td>6,</td><td>7,</td><td>8,</td><td>9]</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>[9,</td><td>8,</td><td>7,</td><td>6,</td><td>5,</td><td>4,</td><td>3,</td><td>2,</td><td>1,</td><td>0]</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>[9,</td><td>9,</td><td>7,</td><td>5,</td><td>1,</td><td>2,</td><td>6,</td><td>3,</td><td>0,</td><td>7,</td><td>2,</td><td>4,</td><td>4,</td><td>7,</td><td>9,</td><td>1,</td><td>3,</td><td>6,</td><td>2,</td><td>4,</td><td>3,</td><td>0,</td><td>5,</td><td>0,</td></tr>
<tr><td>8,</td><td>8,</td><td>8,</td><td>6,</td><td>5,</td><td>1]</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>[0,</td><td>5,</td><td>5,</td><td>6,</td><td>5,</td><td>0,</td><td>3,</td><td>1,</td><td>9,</td><td>8,</td><td>4,</td><td>2,</td><td>3,</td><td>9,</td><td>7,</td><td>3,</td><td>4,</td><td>4,</td><td>0,</td><td>7,</td><td>1,</td><td>9,</td><td>6,</td><td>2,</td></tr>
<tr><td>1,</td><td>8,</td><td>2,</td><td>8,</td><td>6,</td><td>7]</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>[0,</td><td>1,</td><td>2,</td><td>3,</td><td>4,</td><td>5,</td><td>6,</td><td>7,</td><td>8,</td><td>9,</td><td>0,</td><td>1,</td><td>2,</td><td>3,</td><td>4,</td><td>5,</td><td>6,</td><td>7,</td><td>8,</td><td>9,</td><td>0,</td><td>1,</td><td>2,</td><td>3,</td></tr>
<tr><td>4,</td><td>5,</td><td>6,</td><td>7,</td><td>8,</td><td>9]</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>[0,</td><td>1,</td><td>2,</td><td>3,</td><td>4,</td><td>5,</td><td>6,</td><td>7,</td><td>8,</td><td>9,</td><td>0,</td><td>1,</td><td>2,</td><td>3,</td><td>4,</td><td>5,</td><td>6,</td><td>7,</td><td>8,</td><td>9,</td><td>0,</td><td>1,</td><td>2,</td><td>3,</td></tr>
<tr><td colspan="24">4, 5, 6, 7, 8, 9]</td></tr>
</table>
<p>java.lang.ClassCastException: SetType cannot be cast to java.lang.Comparable</p>
<p>java.lang.ClassCastException: HashType cannot be cast to java.lang.Comparable *///:~</p>
<p>In order to prove which methods are necessary for a particular Set and at the same time to avoid code duplication, three classes are created. The base class, SetType, simply stores an int, and produces it via toString( ). Since all classes stored in Sets must have an equals( ), that method is also placed in the base class. Equality is based on the value of the int i.</p>
<p>HashType inherits from SetType and adds the hashCode( ) method necessary for an object to be placed in a hashed implementation of a Set.</p>
<p>The Comparable interface, implemented by TreeType, is necessary if an object is to be used in any kind of sorted container, such as a SortedSet (of which TreeSet is the only implementation). In compareTo( ), note that I did not use the &quot;simple and obvious&quot; form return i-i2. Although this is a common programming error, it would only work properly if i and i2 were &quot;unsigned&quot; ints (if Java had an &quot;unsigned&quot; keyword, which it does not). It breaks for Java’s signed int, which is not big enough to represent the difference of two signed ints. If i is a large positive integer and j is a large negative integer, i-j will overflow and return a negative value, which will not work.</p>
<p>You’ll usually want the compareTo( ) method to produce a natural ordering that is consistent with the equals( ) method. If equals( ) produces true for a particular comparison, then compareTo( ) should produce a zero result for that comparison, and if equals ( ) produces false for a comparison then compareTo( ) should produce a nonzero result for that comparison.</p>
<p>In TypesForSets, both fill( ) and test( ) are defined using generics, in order to prevent code duplication. To verify the behavior of a Set, test( ) calls fill( ) on the test set three times, attempting to introduce duplicate objects. The fill( ) method takes a Set of any type, and a Class object of the same type. It uses the Class object to discover the constructor that takes an int argument, and calls that constructor to add elements to the Set.</p>
<p>From the output, you can see that the HashSet keeps the elements in some mysterious order (which will be made clear later in the chapter), the LinkedHashSet keeps the elements in the order in which they were inserted, and the TreeSet maintains the elements in sorted order (because of the way that compareTo( ) is implemented, this happens to be descending order).</p>
<p>If we try to use types that don’t properly support the necessary operations with Sets that require those operations, things go very wrong. Placing a SetType or TreeType object, which doesn’t include a redefined hashCode( ) method, into any hashed implementations results in duplicate values, so the primary contract of the Set is violated. This is rather disturbing because there’s not even a runtime error. However, the default hashCode( ) is legitimate and so this is legal behavior, even if it’s incorrect. The only reliable way to ensure the correctness of such a program is to incorporate unit tests into your build system (see the supplement at <a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a> for more information).</p>
<p>If you try to use a type that doesn’t implement Comparable in a TreeSet, you get a more definitive result: An exception is thrown when the TreeSet attempts to use the object as a Comparable.</p>
<p>SortedSet</p>
<p>The elements in a SortedSet are guaranteed to be in sorted order, which allows additional functionality to be provided with the following methods that are in the SortedSet interface:</p>
<p>Comparator comparator( ): Produces the Comparator used for this Set, or null for</p>
<p>natural ordering.</p>
<p>Object first( ): Produces the lowest element.</p>
<p>Object last( ): Produces the highest element.</p>
<p>SortedSet subSet(fromElement, toElement): Produces a view of this Set with elements from fromElement, inclusive, to toElement, exclusive.</p>
<p>SortedSet headSet(toElement): Produces a view of this Set with elements less than toElement.</p>
<p>SortedSet tailSet(fromElement): Produces a view of this Set with elements greater than or equal to fromElement.</p>
<p>Here’s a simple demonstration:</p>
<p>//: containers/SortedSetDemo.java // What you can do with a TreeSet. import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class SortedSetDemo {</p>
<p>public static void main(String[] args) {</p>
<p>SortedSet&lt;String&gt; sortedSet = new TreeSet&lt;String&gt;(); Collections.addAll(sortedSet,</p>
<p>&quot;one two three four five six seven eight&quot;</p>
<p>.split(&quot; &quot;)); print(sortedSet);</p>
<p>String low = sortedSet.first();</p>
<p>String high = sortedSet.last();</p>
<p>print(low);</p>
<p>print(high);</p>
<p>Iterator&lt;String&gt; it = sortedSet.iterator(); for(int i = 0; i &lt;= 6; i++) { if(i == 3) low = it.next(); if(i == 6) high = it.next(); else it.next();</p>
<p>}</p>
<p>print(low);</p>
<p>print(high);</p>
<p>print(sortedSet.subSet(low, high));</p>
<p>print(sortedSet.headSet(high));</p>
<p>print(sortedSet.tailSet(low));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[eight, five, four, one, seven, six, three, two]</p>
<p>eight</p>
<p>two</p>
<p>one</p>
<p>two</p>
<p>[one, seven, six, three]</p>
<p>[eight, five, four, one, seven, six, three]</p>
<p>[one, seven, six, three, two]</p>
<p>*///:~</p>
<p>Note that SortedSet means &quot;sorted according to the comparison function of the object,&quot; not &quot;insertion order.&quot; Insertion order can be preserved using a LinkedHashSet.</p>
<p>Exercise 9: (2) Use RandomGenerator.String to fill a TreeSet, but use alphabetic ordering. Print the TreeSet to verify the sort order.</p>
<p>Exercise 10: (7) Using a LinkedList as your underlying implementation, define your own SortedSet.</p>
</section>
<section>
<title>
<p>Queues</p></title><empty-line/>
<p>Other than concurrency applications, the only two Java SE5 implementations of Queue are LinkedList and PriorityQueue, which are differentiated by ordering behavior rather than performance. Here’s a basic example that involves most of the Queue implementations (not all of them will work in this example), including the concurrency-based Queues. You place elements in one end and extract them from the other:</p>
<p>//: containers/QueueBehavior.java</p>
<p>// Compares the behavior of some of the queues</p>
<p>import java.util.concurrent.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>public class QueueBehavior { private static int count = 10;</p>
<p>static &lt;T&gt; void test(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen) { for(int i = 0; i &lt; count; i++) queue.offer(gen.next()); while(queue.peek() != null)</p>
<p>System.out.print(queue.remove() + &quot; &quot;);</p>
<p>System.out.println();</p>
<p>}</p>
<p>static class Gen implements Generator&lt;String&gt; {</p>
<p>String[] s = (&quot;one two three four five six seven &quot; +</p>
<p>&quot;eight nine ten&quot;).split(&quot; &quot;); int i;</p>
<p>public String next() { return s[i++]; }</p>
<p>}</p>
<p>public static void main(String[] args) { test(new LinkedList&lt;String&gt;(), new Gen()); test(new PriorityQueue&lt;String&gt;(), new Gen()); test(new ArrayBlockingQueue&lt;String&gt;(count), new Gen()); test(new ConcurrentLinkedQueue&lt;String&gt;(), new Gen()); test(new LinkedBlockingQueue&lt;String&gt;(), new Gen()); test(new PriorityBlockingQueue&lt;String&gt;(), new Gen());</p>
<p>}</p>
<p>} /* Output:</p>
<p>one two three four five six seven eight nine ten eight five four nine one seven six ten three two one    two    three    four    five    six    seven    eight    nine    ten</p>
<p>one    two    three    four    five    six    seven    eight    nine    ten</p>
<p>one    two    three    four    five    six    seven    eight    nine    ten</p>
<p>eight five four nine one seven six ten three two *///:~</p>
<p>You can see that, with the exception of the priority queues, a Queue will produce elements in exactly the same order as they are placed in the Queue.</p>
<subtitle>Priority queues</subtitle>
<p>Priority queues were given a simple introduction in the Holding Your Objects chapter. A more interesting problem is a to-do list, where each object contains a string and a primary and secondary priority value. The ordering of this list is again controlled by implementing Comparable:</p>
<p>//: containers/ToDoList.java</p>
<p>// A more complex use of PriorityQueue.</p>
<p>import java.util.*;</p>
<p>class ToDoList extends PriorityQueue&lt;ToDoList.ToDoItem&gt; { static class ToDoltem implements Comparable&lt;ToDoItem&gt; { private char primary; private int secondary; private String item;</p>
<p>public ToDoItem(String td, char pri, int sec) { primary = pri; secondary = sec; item = td;</p>
<p>}</p>
<p>public int compareTo(ToDoItem arg) { if(primary &gt; arg.primary) return +1;</p>
<p>if(primary == arg.primary) if(secondary &gt; arg.secondary) return +1;</p>
<p>else if(secondary == arg.secondary) return 0; return -1;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return Character.toString(primary) + secondary +    &quot; + item;</p>
<p>}</p>
<p>}</p>
<p>public void add(String td, char pri, int sec) { super.add(new ToDoItem(td, pri, sec));</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>ToDoList toDoList = new ToDoList(); toDoList.add(&quot;Empty trash&quot;, ‘C&apos;, 4); toDoList.add(&quot;Feed dog&quot;, ‘A&apos;, 2); toDoList.add(&quot;Feed bird&quot;, ‘B&apos;, 7); toDoList.add(&quot;Mow lawn&quot;, ‘C&apos;, 3); toDoList.add(&quot;Water lawn&quot;, ‘A&apos;, 1); toDoList.add(&quot;Feed cat&quot;, ‘B&apos;, 1); while(!toDoList.isEmpty())</p>
<p>System.out.println(toDoList.remove());</p>
<p>}</p>
<p>} /* Output:</p>
<p>A1: Water lawn A2: Feed dog B1: Feed cat B7: Feed bird C3: Mow lawn C4: Empty trash *///:~</p>
<p>You can see how the ordering of the items happens automatically because of the priority queue.</p>
<p>Exercise 11: (2) Create a class that contains an Integer that is initialized to a value between o and 100 using java.util.Random. Implement Comparable using this Integer field. Fill a PriorityQueue with objects of your class, and extract the values using poll( ) to show that it produces the expected order.</p>
<subtitle>Deques</subtitle>
<p>A deque (double-ended queue) is like a queue, but you can add and remove elements from either end. There are methods in LinkedList that support deque operations, but there is no explicit interface for a deque in the Java standard libraries. Thus, LinkedList cannot implement this interface and you cannot upcast to a Deque interface as you can to a Queue in the previous example. However, you can create a Deque class using composition, and simply expose the relevant methods from LinkedList:</p>
<p>//: net/mindview/util/Deque.java // Creating a Deque from a LinkedList. package net.mindview.util; import java.util.*;</p>
<p>public class Deque&lt;T&gt; {</p>
<p>private LinkedList&lt;T&gt; deque = new LinkedList&lt;T&gt;(); public void addFirst(T e) { deque.addFirst(e); } public void addLast(T e) { deque.addLast(e); } public T getFirst() { return deque.getFirst(); } public T getLast() { return deque.getLast(); } public T removeFirst() { return deque.removeFirst(); } public T removeLast() { return deque.removeLast(); } public int size() { return deque.size(); } public String toString() { return deque.toString(); }</p>
<p>// And other methods as necessary...</p>
<p>} ///:~</p>
<p>If you put this Deque to use in your own programs, you may discover that you need to add other methods in order to make it practical.</p>
<p>Here’s a simple test of the Deque class:</p>
<p>//: containers/DequeTest.java</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class DequeTest {</p>
<p>static void fillTest(Deque&lt;Integer&gt; deque) { for(int i = 20; i &lt; 27; i++) deque.addFirst(i); for(int i = 50; i &lt; 55; i++) deque.addLast(i);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Deque&lt;Integer&gt; di = new Deque&lt;Integer&gt;();</p>
<p>fillTest(di);</p>
<p>print(di);</p>
<p>while(di.size() != 0)</p>
<p>printnb(di.removeFirst() + &quot; &quot;); print(); fillTest(di); while(di.size() != 0)</p>
<p>printnb(di.removeLast() + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[26, 25,    24, 23, 22,    21, 20, 50,    51,    52, 53, 54]</p>
<p>26 25 24    23 22 21 20    50 51 52 53    54</p>
<p>54 53 52    51 50 20 21    22 23 24 25    26</p>
<p>*///:~</p>
<p>It’s less likely that you’ll put elements in and take them out at both ends, so Deque is not as commonly used as Queue.</p>
<p>Containers in Depth</p>
<p>597</p>
</section>
<section>
<title>
<p>Understanding Maps</p></title><empty-line/>
<p>As you learned in the Holding Your Objects chapter, the basic idea of a map (also called an associative array) is that it maintains key-value associations (pairs) so you can look up a value using a key. The standard Java library contains different basic implementations of Maps: HashMap, TreeMap, LinkedHashMap, WeakHashMap, ConcurrentHashMap, and IdentityHashMap. They all have the same basic Map interface, but they differ in behaviors including efficiency, the order in which the pairs are held and presented, how long the objects are held by the map, how the map works in multithreaded programs, and how key equality is determined. The number of implementations of the Map interface should tell you something about the importance of this tool.</p>
<p>So you can gain a deeper understanding of Maps, it is helpful to look at how an associative array is constructed. Here is an extremely simple implementation:</p>
<p>//: containers/AssociativeArray.java // Associates keys with values. import static net.mindview.util.Print.*;</p>
<p>public class AssociativeArray&lt;K,V&gt; { private Object[][] pairs; private int index;</p>
<p>public AssociativeArray(int length) { pairs = new Object[length][2];</p>
<p>}</p>
<p>public void put(K key, V value) { if(index &gt;= pairs.length)</p>
<p>throw new ArrayIndexOutOfBoundsException(); pairs[index++] = new Object[]{ key, value };</p>
<p>}</p>
<p>@SuppressWarnings(&quot;unchecked&quot;) public V get(K key) {</p>
<p>for(int i = 0; i &lt; index; i++) if(key.equals(pairs[i][0])) return (V)pairs[i][1]; return null; // Did not find key</p>
<p>}</p>
<p>public String toString() {</p>
<p>StringBuilder result = new StringBuilder(); for(int i = 0; i &lt; index; i++) {</p>
<p>result.append(pairs[i][0].toString()); result.append(&quot; : &quot;); result.append(pairs[i][1].toString()); if(i &lt; index - 1) result.append(&quot;\n&quot;);</p>
<p>}</p>
<p>return result.toString();</p>
<p>}</p>
<p>public static void main(String[] args) { AssociativeArray&lt;String,String&gt; map = new AssociativeArray&lt;String,String&gt;(6); map.put(&quot;sky&quot;, &quot;blue&quot;); map.put(&quot;grass&quot;, &quot;green&quot;); map.put(&quot;ocean&quot;, &quot;dancing&quot;); map.put(&quot;tree&quot;, &quot;tall&quot;); map.put(&quot;earth&quot;, &quot;brown&quot;); map.put(&quot;sun&quot;, &quot;warm&quot;); try {</p>
<p>map.put(&quot;extra&quot;, &quot;object&quot;); // Past the end</p>
<p>} catch(ArrayIndexOutOfBoundsException e) { print(&quot;Too many objects!&quot;);</p>
<p>}</p>
<p>print(map);</p>
<p>print(map.get(&quot;ocean&quot;));</p>
<p>}</p>
<p>} /* Output:</p>
<p>Too many objects! sky : blue grass : green ocean : dancing tree : tall earth : brown sun : warm dancing *///:~</p>
<p>The essential methods in an associative array are put( ) and get( ), but for easy display, toString( ) has been overridden to print the key-value pairs. To show that it works, main( ) loads an AssociativeArray with pairs of strings and prints the resulting map, followed by a get( ) of one of the values.</p>
<p>To use the get( ) method, you pass in the key that you want it to look up, and it produces the associated value as the result or returns null if it can’t be found. The get( ) method is using what is possibly the least efficient approach imaginable to locate the value: starting at the top of the array and using equals( ) to compare keys. But the point here is simplicity, not efficiency.</p>
<p>So the above version is instructive, but it isn’t very efficient and it has a fixed size, which is inflexible. Fortunately, the Maps in java.util do not have these problems and can be substituted into the above example.</p>
<p>Exercise 12: (1) Substitute a HashMap, a TreeMap and a LinkedHashMap in AssociativeArray .Java’s main( ).</p>
<p>Exercise 13: (4) Use AssociativeArray Java to create a wordoccurrence counter, mapping String to Integer. Using the net.mindview.util.TextFile utility in this book, open a text file and break up the words in that file using whitespace and punctuation, and count the occurrence of the words in that file.</p>
<subtitle>Performance</subtitle>
<p>Performance is a fundamental issue for maps, and it’s very slow to use a linear search in get( ) when hunting for a key. This is where HashMap speeds things up. Instead of a slow search for the key, it uses a special value called a hash code. The hash code is a way to take some information in the object in question and turn it into a &quot;relatively unique&quot; int for that object. hashCode( ) is a method in the root class Object, so all Java objects can produce a hash code. A HashMap takes the hashCode( ) of the object and uses it to quickly hunt for the key. This results in a dramatic performance improvement.<a l:href="#bookmark81" type="note"><sup>82</sup></a><sup></sup></p>
<p>Here are the basic Map implementations. The asterisk on HashMap indicates that, in the absence of other constraints, this should be your default choice because it is optimized for speed. The other implementations emphasize other characteristics, and are thus not as fast as HashMap.</p>
<table>
<tr><td>HashMap*</td><td>Implementation based on a hash table. (Use this class instead of Hashtable.) Provides constant-time performance for inserting and locating pairs. Performance can be adjusted via constructors that allow you to set the capacity and load factor of the hash table.</td></tr>
<tr><td>LinkedHashMap</td><td>Like a HashMap, but when you iterate through it, you get the pairs in insertion order, or in least-recently-used (LRU) order. Only slightly slower than a HashMap, except when iterating, where it is faster due to the linked list used to maintain the internal ordering.</td></tr>
<tr><td>TreeMap</td><td>Implementation based on a red-black tree. When you view the keys or the pairs, they will be in sorted order (determined by Comparable or Comparator). The point of a TreeMap is that you get the results in sorted order. TreeMap is the only Map with the subMap( ) method, which allows you to return a portion of the tree.</td></tr>
<tr><td>WeakHashMap</td><td>A map of weak keys that allow objects referred to by the map to be released; designed to solve certain types of problems. If no references to a particular key are held outside the map, that key may be garbage collected.</td></tr>
<tr><td>ConcurrentHashMap</td><td>A thread-safe Map which does not involve synchronization locking. This is discussed in the Concurrency chapter.</td></tr>
<tr><td>IdentityHashMap</td><td>A hash map that uses == instead of equals( ) to compare keys. Only for solving special types of problems; not for general use.</td></tr>
</table>
<p>Hashing is the most commonly used way to store elements in a map. Later, you’ll learn how hashing works.</p>
<p>The requirements for the keys used in a Map are the same as for the elements in a Set. You saw these demonstrated in TypesForSets.java. Any key must have an equals( ) method. If the key is used in a hashed Map, it must also have a proper hashCode( ). If the key is used in a TreeMap, it must implement Comparable.</p>
<p>The following example shows the operations available through the Map interface, using the previously defined CountingMapData test data set:</p>
<p>//: containers/Maps.java // Things you can do with Maps. import java.util.concurrent.*; import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Maps {</p>
<p>public static void printKeys(Map&lt;Integer,String&gt; map) { printnb(&quot;Size = &quot; + map.size() + &quot;, &quot;); printnb(&quot;Keys: &quot;);</p>
<p>print(map.keySet()); // Produce a Set of the keys</p>
<p>}</p>
<p>public static void test(Map&lt;Integer,String&gt; map) { print(map.getClass().getSimpleName()); map.putAll(new CountingMapData(25));</p>
<p>// Map has ‘Set’ behavior for keys: map.putAll(new CountingMapData(25)); printKeys(map);</p>
<p>// Producing a Collection of the values: printnb(&quot;Values: &quot;); print(map.values()); print(map);</p>
<p>print(&quot;map.containsKey(11): &quot; + map.containsKey(ll)); print(&quot;map.get(11): &quot; + map.get(ll)); print(&quot;map.containsValue(\&quot;F0\&quot;): &quot;</p>
<p>+ map.containsValue(&quot;F0&quot;));</p>
<p>Integer key = map.keySet().iterator().next();</p>
<p>print(&quot;First key in map: &quot; + key);</p>
<p>map.remove(key);</p>
<p>printKeys(map);</p>
<p>map.clear();</p>
<p>print(&quot;map.isEmpty(): &quot; + map.isEmpty()); map.putAll(new CountingMapData(25));</p>
<p>// Operations on the Set change the Map: map.keySet().removeAll(map.keySet()); print(&quot;map.isEmpty(): &quot; + map.isEmpty());</p>
<p>}</p>
<p>public static void main(String[] args) { test(new HashMap&lt;Integer,String&gt;()); test(new TreeMap&lt;Integer,String&gt;()); test(new LinkedHashMap&lt;Integer,String&gt;()); test(new IdentityHashMap&lt;Integer,String&gt;()); test(new ConcurrentHashMap&lt;Integer,String&gt;()); test(new WeakHashMap&lt;Integer,String&gt;());</p>
<p>}</p>
<p>} /* Output:</p>
<p>HashMap</p>
<p>Size = 25, Keys: [15, 8, 23, 16,    7, 22, 9, 21, 6, 1,    14,    24,    4, 19, 11,</p>
<p>18, 3, 12, 17, 2, 13, 20, 10, 5,    0]</p>
<p>Values: [P0, I0, X0, Q0, H0, W0,    J0, V0, G0, B0, O0,    Y0,    E0,    T0, L0, S0,</p>
<p>D0, M0, R0, C0, N0, U0, K0, F0, A0]</p>
<p>{15=P0, 8=I0, 23=X0, 16=Q0, 7=H0, 22=W0, 9=J0, 21=V0, 6=G0, 1=B0, 14=O0, 24=Y0, 4=E0, 19=T0, 11=L0, 18=S0, 3=D0, 12=M0, 17=R0, 2=C0, 13=N0,</p>
<p>20=U0, 10=K0, 5=F0, 0=A0} map.containsKey(11): true map.get(11): L0 map.containsValue(&quot;F0&quot;): true First key in map: 15</p>
<p>Size = 24, Keys: [8, 23, 16, 7, 22, 9, 21, 6, 1, 14, 24, 4, 19, 11, 18, 3, 12, 17, 2, 13, 20, 10, 5, 0] map.isEmpty(): true map.isEmpty(): true</p>
<p>*///:~</p>
<p>The printKeys( ) method demonstrates how to produce a Collection view of a Map. The keySet( ) method produces a Set backed by the keys in the Map. Because of improved printing support in Java SE5, you can simply print the result of the values( ) method, which produces a Collection containing all the values in the Map. (Note that keys must be unique, but values may contain duplicates.) Since these Collections are backed by the Map, any changes in a Collection will be reflected in the associated Map.</p>
<p>The rest of the program provides simple examples of each Map operation and tests each basic type of Map.</p>
<p>Exercise 14: (3) Show that java.util.Properties works in the above program.</p>
<subtitle>SortedMap</subtitle>
<p>If you have a SortedMap (of which TreeMap is the only one available), the keys are guaranteed to be in sorted order, which allows additional functionality to be provided with these methods in the SortedMap interface:</p>
<p>Comparator comparator( ): Produces the comparator used for this Map, or null for natural ordering.</p>
<p>T firstKey( ): Produces the lowest key.</p>
<p>T lastKey( ): Produces the highest key.</p>
<p>SortedMap subMap(fromKey, toKey): Produces a view of this Map with keys from fromKey, inclusive, to toKey, exclusive.</p>
<p>SortedMap headMap(toKey): Produces a view of this Map with keys less than toKey.</p>
<p>SortedMap tailMap(fromKey): Produces a view of this Map with keys greater than or equal to fromKey.</p>
<p>Here’s an example that’s similar to SortedSetDemo.java and shows this additional behavior of TreeMaps:</p>
<p>//: containers/SortedMapDemo.java</p>
<p>// What you can do with a TreeMap.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class SortedMapDemo {</p>
<p>public static void main(String[] args) {</p>
<p>TreeMap&lt;Integer,String&gt; sortedMap =</p>
<p>new TreeMap&lt;Integer,String&gt;(new CountingMapData(10)); print(sortedMap);</p>
<p>Integer low = sortedMap.firstKey();</p>
<p>Integer high = sortedMap.lastKey();</p>
<p>print(low);</p>
<p>print(high);</p>
<p>Iterator&lt;Integer&gt; it = sortedMap.keySet().iterator(); for(int i = 0; i &lt;= 6; i++) {</p>
<p>if(i == 3) low = it.next(); if(i == 6) high = it.next(); else it.next();</p>
<p>print(low);</p>
<p>print(high);</p>
<p>print(sortedMap.subMap(low, high));</p>
<p>print(sortedMap.headMap(high));</p>
<p>print(sortedMap.tailMap(low));</p>
<p>}</p>
<p>} /* Output:</p>
<p>{0=A0, 1 = B0, 2=C0, 3=D0, 4=E0, 5=F0, 6=G0, 0 9 3 7</p>
<p>7=H0</p>
<p>8=I0</p>
<p>9=J0}</p>
<p>{3=D0, 4=E0, 5=F0 {0=A0, 1 = B0, 2=C0 {3=D0, 4=E0, 5=F0 *///:~</p>
<p>6=G0} 3 = D0, 6=G0,</p>
<p>4=E0, 7 = H0, 5 = F0, 8=I0,</p>
<p>6=G0}</p>
<p>9=J0}</p>
<p>Here, the pairs are stored by key-sorted order. Because there is a sense of order in the TreeMap, the concept of &quot;location&quot; makes sense, so you can have first and last elements and submaps.</p>
<subtitle>LinkedHashMap</subtitle>
<p>The LinkedHashMap hashes everything for speed, but also produces the pairs in insertion order during a traversal (System.out.println( ) iterates through the map, so you see the results of traversal). In addition, a LinkedHashMap can be configured in the constructor to use a leastrecently- used (LRU) algorithm based on accesses, so elements that haven’t been accessed (and thus are candidates for removal) appear at the front of the list. This allows easy creation of programs that do periodic cleanup in order to save space. Here’s a simple example showing both features:</p>
<p>//: containers/LinkedHashMapDemo.java</p>
<p>// What you can do with a LinkedHashMap.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class LinkedHashMapDemo {</p>
<p>public static void main(String[] args) {</p>
<p>LinkedHashMap&lt;Integer,String&gt; linkedMap = new LinkedHashMap&lt;Integer,String&gt;( new CountingMapData(9)); print(linkedMap);</p>
<p>// Least-recently-used order: linkedMap =</p>
<p>new LinkedHashMap&lt;Integer,String&gt;(16, 0.75f, true); linkedMap.putAll(new CountingMapData(9)); print(linkedMap);</p>
<p>for(int i = 0; i &lt; 6; i++) // Cause accesses: linkedMap.get(i); print(linkedMap); linkedMap.get(0); print(linkedMap);</p>
<p>}</p>
<p>} /* Output:</p>
<p>{0=A0, 1=B0, 2=C0, 3=D0, 4=E0, 5=F0, 6=G0, 7 = H0, 8=I0}</p>
<p>{0=A0, 1=B0, 2=C0, 3=D0, 4=E0, 5=F0, 6=G0, 7 = H0, 8=10} {6=G0, 7=H0, 8=I0, 0=A0, 1=B0, 2=C0, 3 = D0, 4=E0, 5=F0} {6=G0, 7=H0, 8=I0, 1=B0, 2=C0, 3=D0, 4=E0, 5 = F0, 0=A0} *///:~</p>
<p>You can see from the output that the pairs are indeed traversed in insertion order, even for the LRU version. However, after the first six items (only) are accessed in the LRU version, the last three items move to the front of the list. Then, when &quot;o&quot; is accessed again, it moves to the back of the list.</p>
</section>
<section>
<title>
<p>Hashing and hash codes</p></title><empty-line/>
<p>The examples in the Holding Your Objects chapter used predefined classes as HashMap keys. These examples worked because the predefined classes had all the necessary wiring to make them behave correctly as keys. A common pitfall occurs when you create your own classes to be used as keys for HashMaps, and forget to put in the necessary wiring. For example, consider a weather predicting system that matches Groundhog objects to Prediction objects. This seems fairly straightforward—you create the two classes, and use Groundhog as the key and Prediction as the value:</p>
<p>//: containers/Groundhog.java</p>
<p>// Looks plausible, but doesn’t work as a HashMap key.</p>
<p>public class Groundhog { protected int number;</p>
<p>public Groundhog(int n) { number = n; } public String toString() {</p>
<p>return &quot;Groundhog #&quot; + number;</p>
<p>}</p>
<p>} ///:~</p>
<p>//: containers/Prediction.java // Predicting the weather with groundhogs. import java.util.*;</p>
<p>public class Prediction {</p>
<p>private static Random rand = new Random(47); private boolean shadow = rand.nextDouble() &gt; 0.5; public String toString() { if(shadow)</p>
<p>return &quot;Six more weeks of Winter!&quot;; else</p>
<p>return &quot;Early Spring!&quot;;</p>
<p>}</p>
<p>} ///:~</p>
<p>//: containers/SpringDetector.java // What will the weather be? import java.lang.reflect.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class SpringDetector {</p>
<p>// Uses a Groundhog or class derived from Groundhog:</p>
<p>public static &lt;T extends Groundhog&gt;</p>
<p>void detectSpring(Class&lt;T&gt; type) throws Exception {</p>
<p>Constructor&lt;T&gt; ghog = type.getConstructor(int.class); Map&lt;Groundhog,Prediction&gt; map =</p>
<p>new HashMap&lt;Groundhog,Prediction&gt;(); for(int i = 0; i &lt; 10; i++)</p>
<p>map.put(ghog.newInstance(i), new Prediction()); print(&quot;map = &quot; + map);</p>
<p>Groundhog gh = ghog.newInstance(3); print(&quot;Looking up prediction for &quot; + gh); if(map.containsKey(gh)) print(map.get(gh)); else</p>
<p>print(&quot;Key not found: &quot; + gh);</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { detectSpring(Groundhog.class);</p>
<p>} /* Output:</p>
<p>map = {Groundhog #3=Early Spring!, Groundhog #7=Early Spring!, Groundhog #5=Early Spring!, Groundhog #9=Six more weeks of Winter!, Groundhog #8=Six more weeks of Winter!, Groundhog #0=Six more weeks of Winter!, Groundhog #6=Early Spring!, Groundhog #4=Six more weeks of Winter!, Groundhog #1=Six more weeks of Winter!, Groundhog #2=Early Spring!} Looking up prediction for Groundhog #3 Key not found: Groundhog #3 *///:~</p>
<p>Each Groundhog is given an identity number, so you can look up a Prediction in the HashMap by saying, &quot;Give me the Prediction associated with Groundhog #3.&quot; The Prediction class contains a boolean that is initialized using java.util.random( ) and a toString( ) that interprets the result for you. The detectSpring( ) method is created using reflection to instantiate and use the class Groundhog or any class derived from Groundhog. This will come in handy later, when we inherit a new type of Groundhog to solve the problem demonstrated here.</p>
<p>A HashMap is filled with Groundhogs and their associated Predictions. The HashMap is printed so that you can see it has been filled. Then a Groundhog with an identity number of 3 is used as a key to look up the prediction for Groundhog #3 (which you can see must be in the Map).</p>
<p>It seems simple enough, but it doesn’t work—it can’t find the key for #3. The problem is that Groundhog is automatically inherited from the common root class Object, and it is Object’s hashCode( ) method that is used to generate the hash code for each object. By default this just uses the address of its object. Thus, the first instance of Groundhog(3) does not produce a hash code equal to the hash code for the second instance of Groundhog(3) that we tried to use as a lookup.</p>
<p>You might think that all you need to do is write an appropriate override for hashCode( ).</p>
<p>But it still won’t work until you’ve done one more thing: override the equals( ) that is also part of Object.equals( ) is used by the HashMap when trying to determine if your key is equal to any of the keys in the table.</p>
<p>A proper equals( ) must satisfy the following five conditions:</p>
<p>1.    Reflexive: For any x, x.equals(x) should return true.</p>
<p>2.    Symmetric: For any x and y, x.equals(y) should return true if and only if y.equals(x) returns true.</p>
<p>3.    Transitive: For any x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.</p>
<p>4.    Consistent: For any x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the object is modified.</p>
<p>5.    For any non-null x, x.equals(null) should return false.</p>
<p>Again, the default Object.equals( ) simply compares object addresses, so one Groundhog(3) is not equal to another Groundhog(3). Thus, to use your own classes as keys in a HashMap, you must override both hashCode( ) and equals( ), as shown in the following solution to the groundhog problem:</p>
<p>//: containers/Groundhog2.java</p>
<p>// A class that’s used as a key in a HashMap // must override hashCode() and equals().</p>
<p>public class Groundhog2 extends Groundhog { public Groundhog2(int n) { super(n); } public int hashCode() { return number; } public boolean equals(Object o) { return o instanceof Groundhog2 &amp;&amp;</p>
<p>(number == ((Groundhog2)o).number);</p>
<p>}</p>
<p>} ///:~</p>
<p>//: containers/SpringDetector2.java // A working key.</p>
<p>public class SpringDetector2 {</p>
<p>public static void main(String[] args) throws Exception { SpringDetector.detectSpring(Groundhog2.class);</p>
<p>}</p>
<p>} /* Output:</p>
<p>map = {Groundhog #2=Early Spring!, Groundhog #4=Six more weeks of Winter!, Groundhog #9=Six more weeks of Winter!, Groundhog #8=Six more weeks of Winter!, Groundhog #6=Early Spring!, Groundhog #1=Six more weeks of Winter!, Groundhog #3=Early Spring!, Groundhog #7=Early Spring!, Groundhog #5=Early Spring!, Groundhog #0=Six more weeks of Winter!}</p>
<p>Looking up prediction for Groundhog #3 Early Spring!</p>
<p>*///:~</p>
<p>Groundhog2.hashCode( ) returns the groundhog number as a hash value. In this example, the programmer is responsible for ensuring that no two groundhogs exist with the same ID number. The hashCode( ) is not required to return a unique identifier (something you’ll understand better later in this chapter), but the equals( ) method must strictly determine whether two objects are equivalent. Here, equals( ) is based on the groundhog number, so if two Groundhog2 objects exist as keys in the HashMap with the same groundhog number, it will fail.</p>
<p>Even though it appears that the equals( ) method is only checking to see whether the argument is an instance of Groundhog2 (using the instanceof keyword, which was explained in the Type Information chapter), the instanceof actually quietly does a second sanity check to see if the object is null, since instanceof produces false if the left-hand argument is null. Assuming it’s the correct type and not null, the comparison is based on the actual number values in each object. You can see from the output that the behavior is now correct.</p>
<p>When creating your own class to use in a HashSet, you must pay attention to the same issues as when it is used as a key in a HashMap.</p>
<subtitle>Understanding hashCodeQ</subtitle>
<p>The preceding example is only a start toward solving the problem correctly. It shows that if you do not override hashCode( ) and equals( ) for your key, the hashed data structure (HashSet, HashMap, LinkedHashSet, or LinkedHashMap) probably won’t deal with your key properly. For a good solution to the problem, however, you need to understand what’s going on inside the hashed data structure.</p>
<p>First, consider the motivation behind hashing: You want to look up an object using another object. But you can also accomplish this with a TreeMap, or you can even implement your own Map. In contrast to a hashed implementation, the following example implements a Map using a pair of ArrayLists. Unlike AssociativeArray.java, this includes a full implementation of the Map interface, which accounts for the entrySet( ) method:</p>
<p>//: containers/SlowMap.java</p>
<p>// A Map implemented with ArrayLists.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>public class SlowMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; { private List&lt;K&gt; keys = new ArrayList&lt;K&gt;(); private List&lt;V&gt; values = new ArrayList&lt;V&gt;(); public V put(K key, V value) {</p>
<p>V oldValue = get(key); // The old value or null if(!keys.contains(key)) { keys.add(key); values.add(value);</p>
<p>} else</p>
<p>values.set(keys.indexOf(key), value); return oldValue;</p>
<p>}</p>
<p>public V get(Object key) { // key is type Object, not K if(!keys.contains(key)) return null;</p>
<p>return values.get(keys.indexOf(key));</p>
<p>}</p>
<p>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</p>
<p>Set&lt;Map.Entry&lt;K,V&gt;&gt; set= new HashSet&lt;Map.Entry&lt;K,V&gt;&gt;();</p>
<p>Iterator&lt;K&gt; ki = keys.iterator();</p>
<p>Iterator&lt;V&gt; vi = values.iterator(); while(ki.hasNext())</p>
<p>set.add(new MapEntry&lt;K,V&gt;(ki.next(), vi.next())); return set;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>SlowMap&lt;String,String&gt; m= new SlowMap&lt;String,String&gt;(); m.putAll(Countries.capitals(15));</p>
<p>System.out.println(m);</p>
<p>System.out.println(m.get(&quot;BULGARIA&quot;));</p>
<p>System.out.println(m.entrySet());</p>
<p>}</p>
<p>} /* Output:</p>
<p>{CAMEROON=Yaounde, CHAD=N&apos;djamena, CONGO=Brazzaville, CAPE VERDE=Praia, ALGERIA=Algiers, COMOROS=Moroni, CENTRAL AFRICAN REPUBLIC=Bangui, BOTSWANA=Gaberone, BURUNDI=Bujumbura, BENIN=Porto-Novo, BULGARIA=Sofia, EGYPT=Cairo, ANGOLA=Luanda, BURKINA FASO=Ouagadougou, DJIBOUTI=Dijibouti}</p>
<p>Sofia</p>
<p>[CAMEROON=Yaounde, CHAD=N&apos;djamena, CONGO=Brazzaville, CAPE VERDE=Praia, ALGERIA=Algiers, COMOROS=Moroni, CENTRAL AFRICAN REPUBLIC=Bangui, BOTSWANA=Gaberone, BURUNDI=Bujumbura, BENIN=Porto-Novo, BULGARIA=Sofia, EGYPT=Cairo, ANGOLA=Luanda, BURKINA FASO=Ouagadougou, DJIBOUTI=Dijibouti]</p>
<p>*///:~</p>
<p>The put( ) method simply places the keys and values in corresponding ArrayLists. In accordance with the Map interface, it must return the old key or null if there was no old key.</p>
<p>Also following the specifications for Map, get( ) produces null if the key is not in the SlowMap. If the key exists, it is used to look up the numerical index indicating its location in the keys List, and this number is used as an index to produce the associated value from the values List. Notice that the type of key is Object in get( ), rather than the</p>
<p>parameterized type K as you might expect (and which was indeed used in AssociativeArray.java). This is a result of the injection of generics into the Java language at such a late date—if generics had been an original feature in the language, get( ) could have specified the type of its parameter.</p>
<p>The Map.entrySet( ) method must produce a set of Map.Entry objects. However, Map.Entry is an interface describing an implementationdependent structure, so if you want to make your own type of Map, you must also define an implementation of Map.Entry:</p>
<p>//: containers/MapEntry.java</p>
<p>// A simple Map.Entry for sample Map implementations. import java.util.*;</p>
<p>public class MapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { private K key; private V value;</p>
<p>public MapEntry(K key, V value) { this.key = key; this.value = value;</p>
<p>}</p>
<p>public K getKey() { return key; } public V getValue() { return value; } public V setValue(V v) {</p>
<p>V result = value; value = v; return result;</p>
<p>}</p>
<p>public int hashCode() {</p>
<p>return (key==null ? 0 : key.hashCode()) <sup>A </sup>(value==null ? 0 : value.hashCode());</p>
<p>}</p>
<p>public boolean equals(Object o) {</p>
<p>if(!(o instanceof MapEntry)) return false;</p>
<p>MapEntry me = (MapEntry)o; return</p>
<p>(key == null ?</p>
<p>me.getKey() == null : key.equals(me.getKey())) &amp;&amp;</p>
<p>(value == null ?</p>
<p>me.getValue()== null : value.equals(me.getValue()));</p>
<p>}</p>
<p>public String toString() { return key + &quot;=&quot; + value; }</p>
<p>} ///:~</p>
<p>Here, a very simple class called MapEntry holds and retrieves the keys and values. This is used in entrySet( ) to produce a Set of key-value pairs. Notice that entrySet( ) uses a HashSet to hold the pairs, and MapEntry takes the simple approach ofjust using key’s hashCode( ). Although this solution is very simple, and appears to work in the trivial test in SlowMap.main( ), it is not a correct implementation because a copy of the keys and values is made. A correct implementation of entrySet( ) will provide a view into the Map, rather than a copy, and this view will allow modification of the original map (which a copy doesn’t). Exercise 16 provides the opportunity to repair the problem.</p>
<p>Note that the equals( ) method in MapEntry must check both keys and values. The meaning of the hashCode( ) method will be described shortly. The String representation of the contents of the SlowMap is automatically produced by the toString( ) method defined in AbstractMap.</p>
<p>In SlowMap.main( ), a SlowMap is loaded and then the contents are displayed. A call to get( ) shows that it works.</p>
<p>Exercise 15: (1) Repeat Exercise 13 using a SlowMap.</p>
<p>Exercise 16: (7) Apply the tests in Maps.java to SlowMap to verify that it works. Fix anything in SlowMap that doesn’t work correctly.</p>
<p>Exercise 17: (2) Implement the rest of the Map interface for SlowMap.</p>
<p>Exercise 18: (3) Using SlowMap.java for inspiration, create a SlowSet.</p>
<subtitle>Hashing for speed</subtitle>
<p>SlowMap.java shows that it’s not that hard to produce a new type of Map. But as the name suggests, a SlowMap isn’t very fast, so you probably wouldn’t use it if you had an alternative available. The problem is in the lookup of the key; the keys are not kept in any particular order, so a simple linear search is used. A linear search is the slowest way to find something.</p>
<p>The whole point of hashing is speed: Hashing allows the lookup to happen quickly. Since the bottleneck is in the speed of the key lookup, one of the solutions to the problem is to keep the keys sorted and then use Collections.binarySearch( ) to perform the lookup (an exercise will walk you through this process).</p>
<p>Hashing goes further by saying that all you want to do is to store the key somewhere in a way that it can be found quickly. The fastest structure in which to store a group of elements is an array, so that will be used for representing the key information (note that I said &quot;key information,&quot; and not the key itself). But because an array cannot be resized, we have a problem: We want to store an indeterminate number of values in the Map, but if the number of keys is fixed by the array size, how can this be?</p>
<p>The answer is that the array will not hold the keys. From the key object, a number will be derived that will index into the array. This number is the hash code, produced by the hashCode( ) method (in computer science parlance, this is the hash function) defined in Object and presumably overridden by your class.</p>
<p>To solve the problem of the fixed-size array, more than one key may produce the same index. That is, there may be collisions. Because of this, it doesn’t matter how big the array is; any key object’s hash code will land somewhere in that array.</p>
<p>So the process of looking up a value starts by computing the hash code and using it to index into the array. If you could guarantee that there were no collisions (which is possible if you have a fixed number of values), then you’d have a perfect hashing junction, but that’s a special case<a l:href="#bookmark82" type="note"><sup>83</sup></a><sup></sup> In all other cases, collisions are handled by external chaining: The array doesn’t point directly to a value, but instead to a list of values. These values are searched in a linear fashion using the equals( ) method. Of course, this aspect of the search is much slower, but if the hash function is good, there will only be a few values in each slot. So instead of searching through the entire list, you quickly jump to a slot where you only have to compare a few entries to find the value. This is much faster, which is why the HashMap is so quick.</p>
<p>Knowing the basics of hashing, you can implement a simple hashed Map:</p>
<p>//: containers/SimpleHashMap.java // A demonstration hashed Map. import java.util.*; import net.mindview.util.*;</p>
<p>public class SimpleHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; {</p>
<p>// Choose a prime number for the hash table // size, to achieve a uniform distribution: static final int SIZE = 997;</p>
<p>// You can’t have a physical array of generics,</p>
<p>// but you can upcast to one:</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>LinkedList&lt;MapEntry&lt;K,V&gt;&gt;[] buckets = new LinkedList[SIZE]; public V put(K key, V value) {</p>
<p>V oldValue = null;</p>
<p>int index = Math.abs(key.hashCode()) % SIZE; if(buckets[index] == null)</p>
<p>buckets[index] = new LinkedList&lt;MapEntry&lt;K,V&gt;&gt;(); LinkedList&lt;MapEntry&lt;K,V&gt;&gt; bucket = buckets[index]; MapEntry&lt;K,V&gt; pair = new MapEntry&lt;K,V&gt;(key, value); boolean found = false;</p>
<p>ListIterator&lt;MapEntry&lt;K,V&gt;&gt; it = bucket.listIterator(); while(it.hasNext()) {</p>
<p>MapEntry&lt;K,V&gt; iPair = it.next(); if(iPair.getKey().equals(key)) { oldValue = iPair.getValue(); it.set(pair); // Replace old with new found = true; break;</p>
<p>}</p>
<p>}</p>
<p>if(!found)</p>
<p>buckets[index].add(pair); return oldValue;</p>
<p>}</p>
<p>public V get(Object key) {</p>
<p>int index = Math.abs(key.hashCode()) % SIZE; if(buckets[index] == null) return null; for(MapEntry&lt;K,V&gt; iPair : buckets[index]) if(iPair.getKey().equals(key)) return iPair.getValue(); return null;</p>
<p>}</p>
<p>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</p>
<p>Set&lt;Map.Entry&lt;K,V&gt;&gt; set= new HashSet&lt;Map.Entry&lt;K,V&gt;&gt;(); for(LinkedList&lt;MapEntry&lt;K,V&gt;&gt; bucket : buckets) { if(bucket == null) continue; for(MapEntry&lt;K,V&gt; mpair : bucket) set.add(mpair);</p>
<p>}</p>
<p>return set;</p>
<p>}</p>
<p>public static void main(String[] args) { SimpleHashMap&lt;String,String&gt; m = new SimpleHashMap&lt;String,String&gt;(); m.putAll(Countries.capitals(25));</p>
<p>System.out.println(m);</p>
<p>System.out.println(m.get(&quot;ERITREA&quot;));</p>
<p>System.out.println(m.entrySet());</p>
<p>}</p>
<p>} /* Output:</p>
<p>{CAMEROON=Yaounde, CONGO=Brazzaville, CHAD=N’djamena, COTE D’IVOIR (IVORY COAST)=Yamoussoukro, CENTRAL AFRICAN REPUBLIC=Bangui, GUINEA=Conakry, BOTSWANA=Gaberone, BISSAU=Bissau, EGYPT=Cairo, ANGOLA=Luanda, BURKINA FASO=Ouagadougou, ERITREA=Asmara, THE GAMBIA=Banjul, KENYA=Nairobi, GABON=Libreville, CAPE VERDE=Praia,</p>
<p>ALGERIA=A!giers, COMOROS=Moroni, EQUATORIAL GUINEA=Malabo, BURUNDI=Bujumbura, BENIN=Porto-Novo, BULGARIA=Sofia, GHANA=Accra, DJIBOUTI=Dijibouti, ETHIOPIA=Addis Ababa}</p>
<p>Asmara</p>
<p>[CAMEROON=Yaounde, CONGO=Brazzaville, CHAD=N&apos;djamena, COTE D&apos;IVOIR (IVORY COAST)=Yamoussoukro, CENTRAL AFRICAN REPUBLIC=Bangui, GUINEA=Conakry, BOTSWANA=Gaberone, BISSAU=Bissau, EGYPT=Cairo, ANGOLA=Luanda, BURKINA FASO=Ouagadougou, ERITREA=Asmara, THE GAMBIA=Banjul, KENYA=Nairobi, GABON=Libreville, CAPE VERDE=Praia, ALGERIA=Algiers, COMOROS=Moroni, EQUATORIAL GUINEA=Malabo, BURUNDI=Bujumbura, BENIN=Porto-Novo, BULGARIA=Sofia, GHANA=Accra, DJIBOUTI=Dijibouti, ETHIOPIA=Addis Ababa]</p>
<p>*///:~</p>
<p>Because the &quot;slots&quot; in a hash table are often referred to as buckets, the array that represents the actual table is called buckets. To promote even distribution, the number of buckets is typically a prime number.<a l:href="#bookmark83" type="note"><sup>84</sup></a><sup></sup> Notice that it is an array of LinkedList, which automatically provides for collisions: Each new item is simply added to the end of the list in a particular bucket. Even though Java will not let you create an array of generics, it is possible to make a reference to such an array. Here, it is convenient to upcast to such an array, to prevent extra casting later in the code.</p>
<p>For a put( ), the hashCode( ) is called for the key and the result is forced to a positive number. To fit the resulting number into the buckets array, the modulus operator is used with the size of that array. If that location is null, it means there are no elements that hash to that location, so a new LinkedList is created to hold the object that just did hash to that location. However, the normal process is to look through the list to see if there are duplicates, and if there are, the old value is put into oldValue and the new value replaces the old. The found flag keeps track of whether an old key-value pair was found and, if not, the new pair is appended to the end of the list.</p>
<p>The get( ) calculates the index into the buckets array in the same fashion as put( ) (this is important in order to guarantee that you end up in the same spot). If a LinkedList exists, it is searched for a match.</p>
<p>Note that this implementation is not meant to be tuned for performance; it is only intended to show the operations performed by a hash map. If you look at the source code for java.util.HashMap, you’ll see a tuned implementation. Also, for simplicity SimpleHashMap uses the same approach to entrySet( ) as did SlowMap, which is oversimplified and will not work for a general-purpose Map.</p>
<p>Exercise 19: (1) Repeat Exercise 13 using a SimpleHashMap.</p>
<p>Exercise 20: (3) Modify SimpleHashMap so that it reports collisions, and test this by adding the same data set twice so that you see collisions.</p>
<p>Exercise 21: (2) Modify SimpleHashMap so that it reports the number of &quot;probes&quot; necessary when collisions occur. That is, how many calls to next( ) must be made on the Iterators that walk the LinkedLists looking for matches?</p>
<p>Exercise 22: (4) Implement the clear( ) and remove( ) methods for SimpleHashMap.</p>
<p>Exercise 23: (3) Implement the rest of the Map interface for SimpleHashMap. Exercise 24: (5) Following the example in SimpleHashMap.java, create and test a SimpleHashSet.</p>
<p>Exercise 25: (6) Instead of using a Listlterator for each bucket, modify MapEntry so that it is a self-contained singly linked list (each MapEntry should have a forward link to the next MapEntry). Modify the rest of the code in SimpleHashMap.java so that this new approach works correctly.</p>
<subtitle>Overriding hashCode()</subtitle>
<p>Now that you understand how hashing works, writing your own hashCode( ) method will make more sense.</p>
<p>First of all, you don’t control the creation of the actual value that’s used to index into the array of buckets. That is dependent on the capacity of the particular HashMap object, and that capacity changes depending on how full the container is, and what the load factor is (this term will be described later). Thus, the value produced by your hashCode( ) will be further processed in order to create the bucket index (in SimpleHashMap, the calculation is just a modulo by the size of the bucket array).</p>
<p>The most important factor in creating a hashCode( ) is that, regardless of when hashCode( ) is called, it produces the same value for a particular object every time it is called. If you end up with an object that produces one hashCode( ) value when it is put( ) into a HashMap and another during a get( ), you won’t be able to retrieve the objects. So if your hashCode( ) depends on mutable data in the object, the user must be made aware that changing the data will produce a different key because it generates a different hashCode( ).</p>
<p>In addition, you will probably nor want to generate a hashCode( ) that is based on unique object information—in particular, the value of this makes a bad hashCode( ) because then you can’t generate a new key identical to the one used to put( ) the original key-value pair. This was the problem that occurred in SpringDetector.java, because the default implementation of hashCode( ) does use the object address. So you’ll want to use information in the object that identifies the object in a meaningful way.</p>
<p>One example can be seen in the String class. Strings have the special characteristic that if a program has several String objects that contain identical character sequences, then those String objects all map to the same memory. So it makes sense that the hashCode( ) produced by two separate instances of the String &quot;hello&quot; should be identical. You can see this in the following program:</p>
<p>//: containers/StringHashCode.java</p>
<p>public class StringHashCode {</p>
<p>public static void main(String[] args) {</p>
<p>String[] hellos = &quot;Hello Hello&quot;.split(&quot; &quot;);</p>
<p>System.out.println(hellos[0].hashCode());</p>
<p>System.out.println(hellos[1].hashCode());</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>69609650</p>
<p>69609650</p>
<p>*///:~</p>
<p>The hashCode( ) for String is clearly based on the contents of the String.</p>
<p>So, for a hashCode( ) to be effective, it must be fast and it must be meaningful; that is, it must generate a value based on the contents of the object. Remember that this value doesn’t have to be unique—you should lean toward speed rather than uniqueness—but between hashCode( ) and equals( ), the identity of the object must be completely resolved.</p>
<p>Because the hashCode( ) is further processed before the bucket index is produced, the range of values is not important; it just needs to generate an int.</p>
<p>There’s one other factor: A good hashCode( ) should result in an even distribution of values. If the values tend to cluster, then the HashMap or HashSet will be more heavily loaded in some areas and will not be as fast as it can be with an evenly distributed hashing function.</p>
<p>In Effective Java™Programming Language Guide (Addison-Wesley, 2001), Joshua Bloch gives a basic recipe for generating a decent hashCode( ):</p>
<p>1.    Store some constant nonzero value, say 17, in an int variable called result.</p>
<p>2.    For each significant field fin your object (that is, each field taken into account by the equals( ) method), calculate an int hash code c for the field:</p>
<table>
<tr><td>Field type</td><td>Calculation</td></tr>
<tr><td>boolean</td><td>c = ( f ? 0 : 1)</td></tr>
<tr><td>byte, char, short, or int</td><td>c = (int)f</td></tr>
<tr><td>long</td><td>c = (int)(f <sup>A</sup> (f&gt;&gt;&gt;32))</td></tr>
<tr><td>float</td><td>c = Float.floatTolntBits(f);</td></tr>
<tr><td>double</td><td>long l = Double.doubleToLongBits(f); c = (int)(i <sup>A</sup> (l&gt;&gt;&gt;32))</td></tr>
<tr><td>Object, where equals( ) calls equals( ) for this field</td><td>c = f.hashCode( )</td></tr>
<tr><td>Array</td><td>Apply above rules to each element</td></tr>
</table>
<p>3.    Combine the hash code(s) computed above: result = 37 * result + c;</p>
<p>4.    Return result.</p>
<p>5.    Look at the resulting hashCode( ) and make sure that equal instances have equal hash codes.</p>
<p>Here’s an example that follows these guidelines:</p>
<p>//: containers/CountedString.java // Creating a good hashCode(). import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class CountedString {</p>
<p>private static List&lt;String&gt; created = new ArrayList&lt;String&gt;();</p>
<p>private String s; private int id = 0; public CountedString(String str) { s = str; created.add(s);</p>
<p>// id is the total number of instances // of this string in use by CountedString: for(String s2 : created) if(s2.equals(s)) id++;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;String: &quot; + s + &quot; id: &quot; + id +</p>
<p>&quot; hashCode(): &quot; + hashCode();</p>
<p>}</p>
<p>public int hashCode() {</p>
<p>// The very simple approach:</p>
<p>// return s.hashCode() * id;</p>
<p>// Using Joshua Bloch’s recipe: int result = 17;</p>
<p>result = 37 * result + s.hashCode(); result = 37 * result + id; return result;</p>
<p>}</p>
<p>public boolean equals(Object o) {</p>
<p>return o instanceof CountedString &amp;&amp; s.equals(((CountedString)o).s) &amp;&amp; id == ((CountedString)o).id;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Map&lt;CountedString,Integer&gt; map =</p>
<p>new HashMap&lt;CountedString,Integer&gt;();</p>
<p>CountedString[] cs = new CountedString[5]; for(int i = 0; i &lt; cs.length; i++) { cs[i] = new CountedString(&quot;hi&quot;); map.put(cs[i], i); // Autobox int -&gt; Integer</p>
<p>}</p>
<p>print(map);</p>
<p>for(CountedString cstring : cs) { print(&quot;Looking up &quot; + cstring); print(map.get(cstring));</p>
<p>}</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>{String: hi id: 4 hashCode(): 146450=3, String: hi id: 1 hashCode(): 146447=0, String: hi id: 3 hashCode(): 146449=2, String: hi id: 5</p>
<table>
<tr><td colspan="2">hashCode():</td><td>: 146451</td><td>=4,</td><td colspan="2">String</td><td>: hi id: 2</td><td>hashCode(): 146448=1}</td></tr>
<tr><td rowspan="5">Looking0Looking1Looking2Looking3Looking4*///:~</td><td>up</td><td>String:</td><td>hi</td><td>id:</td><td>1</td><td>hashCode():</td><td>146447</td></tr>
<tr><td>up</td><td>String:</td><td>hi</td><td>id:</td><td>2</td><td>hashCode():</td><td>146448</td></tr>
<tr><td>up</td><td>String:</td><td>hi</td><td>id:</td><td>3</td><td>hashCode():</td><td>146449</td></tr>
<tr><td>up</td><td>String:</td><td>hi</td><td>id:</td><td>4</td><td>hashCode():</td><td>146450</td></tr>
<tr><td>up</td><td>String:</td><td>hi</td><td>id:</td><td>5</td><td>hashCode():</td><td>146451</td></tr>
</table>
<p>CountedString includes a String and an id that represents the number of CountedString objects that contain an identical String. The counting is accomplished in the constructor by iterating through the static ArrayList where all the Strings are stored.</p>
<p>Both hashCode( ) and equals( ) produce results based on both fields; if they were just based on the String alone or the id alone, there would be duplicate matches for distinct values.</p>
<p>In main( ), several CountedString objects are created using the same String, to show that the duplicates create unique values because of the count id. The HashMap is displayed so that you can see how it is stored internally (no discernible orders), and then each key is looked up individually to demonstrate that the lookup mechanism is working properly.</p>
<p>As a second example, consider the Individual class that was used as the base class for the typeinfo.pet library defined in the Type Information chapter. The Individual class was used in that chapter but the definition has been delayed until this chapter so you could properly understand the implementation:</p>
<p>//: typeinfo/pets/Individual.java package typeinfo.pets;</p>
<p>public class Individual implements Comparable&lt;Individual&gt; { private static long counter = 0; private final long id = counter++; private String name;</p>
<p>public Individual(String name) { this.name = name; }</p>
<p>// ‘name’ is optional: public Individual() {} public String toString() {</p>
<p>return getClass().getSimpleName() +</p>
<p>(name == null ? &quot;&quot; : &quot; &quot; + name);</p>
<p>}</p>
<p>public long id() { return id; } public boolean equals(Object o) { return o instanceof Individual &amp;&amp; id == ((Individual)o).id;</p>
<p>}</p>
<p>public int hashCode() { int result = 17; if(name != null)</p>
<p>result = 37 * result + name.hashCode(); result = 37 * result + (int)id; return result;</p>
<p>}</p>
<p>public int compareTo(Individual arg) {</p>
<p>// Compare by class name first:</p>
<p>String first = getClass().getSimpleName();</p>
<p>String argFirst = arg.getClass().getSimpleName(); int firstCompare = first.compareTo(argFirst); if(firstCompare != 0) return firstCompare;</p>
<p>if(name != null &amp;&amp; arg.name != null) {</p>
<p>int secondCompare = name.compareTo(arg.name); if(secondCompare != 0) return secondCompare;</p>
<p>}</p>
<p>return (arg.id &lt; id ? -1 : (arg.id == id ? 0 : 1));</p>
<p>}</p>
<p>} ///:~</p>
<p>The compareTo( ) method has a hierarchy of comparisons, so that it will produce a sequence that is sorted first by actual type, then by name if there is one, and finally falls back to creation order. Here’s an example that shows how it works:</p>
<p>//: containers/IndividualTest.java</p>
<p>import holding.MapOfList; import typeinfo.pets.*; import java.util.*;</p>
<p>public class IndividualTest {</p>
<p>public static void main(String[] args) {</p>
<p>Set&lt;Individual&gt; pets = new TreeSet&lt;Individual&gt;(); for(List&lt;? extends Pet&gt; lp :</p>
<p>MapOfList.petPeople.values()) for(Pet p : lp) pets.add(p);</p>
<p>System.out.println(pets);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[Cat Elsie May, Cat Pinkola, Cat Shackleton, Cat Stanford aka Stinky el Negro, Cymric Molly, Dog Margrett, Mutt Spot, Pug Louie aka Louis Snorkelstein Dupree, Rat Fizzy, Rat Freckly, Rat Fuzzy]</p>
<p>*///:~</p>
<p>Since all of these pets have names, they are sorted first by type, then by name within their type.</p>
<p>Writing a proper hashCode( ) and equals( ) for a new class can be tricky. You can find tools to help you do this in Apache’s &quot;Jakarta Commons&quot; project</p>
<p>atjakarta.apache.org/commons, under &quot;lang&quot; (this project also has many other potentially useful libraries, and appears to be the Java community’s answer to the C++ community’s <a l:href="http://www.boost.org">www.boost.org</a>).</p>
<p>Exercise 26: (2) Add a char field to CountedString that is also initialized in the constructor, and modify the hashCode( ) and equals( ) methods to include the value of this char.</p>
<p>Exercise 27: (3) Modify the hashCode( ) in CountedString.java by removing the combination with id, and demonstrate that CountedString still works as a key. What is the problem with this approach?</p>
<p>Exercise 28: (4) Modify net/mindview/util/Tuple.java to make it a general-purpose class by adding hashCode( ), equals( ), and implementing Comparable for each type of Tuple.</p>
</section>
<section>
<title>
<p>Choosing an implementation</p></title><empty-line/>
<p>By now you should understand that although there are only four fundamental container types—Map, List, Set, and Queue—there is more than one implementation of each interface. If you need to use the functionality offered by a particular interface, how do you decide which implementation to use?</p>
<p>Each different implementation has its own features, strengths, and weaknesses. For example, you can see in the figure at the beginning of this chapter that the &quot;feature&quot; of Hashtable, Vector, and Stack is that they are legacy classes, so that old code doesn’t break (it’s best if you don’t use those for new code).</p>
<p>The different types of Queues in the Java library are differentiated only by the way they accept and produce values (you’ll see the importance of these in the Concurrency chapter).</p>
<p>The distinction between containers often comes down to what they are &quot;backed by&quot;—that is, the data structures that physically implement the desired interface. For example, because ArrayList and LinkedList implement the List interface, the basic List operations are the same regardless of which one you use. However, ArrayList is backed by an array, and LinkedList is implemented in the usual way for a doubly linked list, as individual objects each containing data along with references to the previous and next elements in the list. Because of this, if you want to do many insertions and removals in the middle of a list, a LinkedList is the appropriate choice. (LinkedList also has additional functionality that is established in AbstractSequentialList.) If not, an ArrayList is typically faster.</p>
<p>As another example, a Set can be implemented as either a TreeSet, a HashSet, or a LinkedHashSet.<sup>9</sup> Each one has different behaviors: HashSet is for typical use and provides raw speed on lookup, LinkedHashSet keeps pairs in insertion order, and TreeSet is backed by TreeMap and is designed to produce a constantly sorted set. You choose the implementation based on the behavior you need.</p>
<p>Sometimes different implementations of a particular container will have operations in common, but the performance of those operations will be different. In this case, you’ll choose between implementations based on how often you use a particular operation, and how fast you need it to be. For cases like this, one way to look at the differences between container implementations is with a performance test.</p>
<subtitle>A performance test framework</subtitle>
<p>To prevent code duplication and to provide consistency among tests, I’ve put the basic functionality of the test process into a framework. The following code establishes a base class from which you create a list of anonymous inner classes, one for each different test. Each of these inner classes is called as part of the testing process. This approach allows you to easily add and remove new kinds of tests.</p>
<p>This is another example of the Template Method design pattern. Although you follow the typical Template Method approach of overriding the method Test.test( ) for each particular test, in this case the core code (that doesn’t change) is in a separate Tester class.<sup>10</sup> The type of container under test is the generic parameter C:</p>
<p>//: containers/Test.java</p>
<p>// Framework for performing timed tests of containers.</p>
<p>public abstract class Test&lt;C&gt; {</p>
<p>String name;</p>
<p>public Test(String name) { this.name = name; }</p>
<p>// Override this method for different tests.</p>
<p>// Returns actual number of repetitions of test. abstract int test(C container, TestParam tp);</p>
<p>} ///:~</p>
<p>Each Test object stores the name of that test. When you call the test( ) method, it must be given the container to be tested along with a &quot;messenger&quot; or &quot;data transfer object&quot; that holds the various parameters for that particular test. The parameters include size, indicating the number of elements in the container, and loops, which controls the number of iterations for that test. These parameters may or may not be used in every test.</p>
<p>Each container will undergo a sequence of calls to test( ), each with a different TestParam, so TestParam also contains static array( ) methods that make it easy to create arrays of TestParam objects. The first version of array( ) takes a variable argument list containing alternating size and loops values, and the second version takes the same kind of list except <a l:href="#bookmark84" type="note"><sup>85</sup></a><sup> <a l:href="#bookmark85" type="note"><sup>86</sup></a></sup></p>
<p>that the values are inside Strings—this way, it can be used to parse commandline arguments:</p>
<p>//: containers/TestParam.java // A &quot;data transfer object.&quot;</p>
<p>public class TestParam { public final int size; public final int loops; public TestParam(int size, int loops) { this.size = size; this.loops = loops;</p>
<p>}</p>
<p>// Create an array of TestParam from a varargs sequence: public static TestParam[] array(int... values) { int size = values.length/2;</p>
<p>TestParam[] result = new TestParam[size]; int n = 0;</p>
<p>for(int i = 0; i &lt; size; i++)</p>
<p>result[i] = new TestParam(values[n++], values[n++]); return result;</p>
<p>}</p>
<p>// Convert a String array to a TestParam array: public static TestParam[] array(String[] values) { int[] vals = new int[values.length]; for(int i = 0; i &lt; vals.length; i++) vals[i] = Integer.decode(values[i]); return array(vals);</p>
<p>}</p>
<p>} ///:~</p>
<p>To use the framework, you pass the container to be tested along with a List of Test objects to a Tester.run( ) method (these are overloaded generic convenience methods which reduce the amount of typing necessary to use them). Tester.run( ) calls the appropriate overloaded constructor, then calls timedTest( ), which executes each test in the list for that container. timedTest( ) repeats each test for each of the TestParam objects in paramList. Because paramList is initialized from the static defaultParams array, you can change the paramList for all tests by reassigning defaultParams, or you can change the paramList for one test by passing in a custom paramList for that test:</p>
<p>//: containers/Tester.java</p>
<p>// Applies Test objects to lists of different containers. import java.util.*;</p>
<p>public class Tester&lt;C&gt; {</p>
<p>public static int fieldWidth = 8;</p>
<p>public static TestParam[] defaultParams= TestParam.array(</p>
<p>10, 5000, 100, 5000, 1000, 5000, 10000, 500);</p>
<p>// Override this to modify pre-test initialization: protected C initialize(int size) { return container; } protected C container; private String headline = &quot;&quot;; private List&lt;Test&lt;C&gt;&gt; tests; private static String stringField() { return &quot;%&quot; + fieldWidth + &quot;s&quot;;</p>
<p>}</p>
<p>private static String numberField() { return &quot;%&quot; + fieldWidth + &quot;d&quot;;</p>
<p>}</p>
<p>private static int sizeWidth = 5;</p>
<p>private static String sizeField = &quot;%&quot; + sizeWidth + &quot;s&quot;; private TestParam[] paramList = defaultParams;</p>
<p>public Tester(C container, List&lt;Test&lt;C&gt;&gt; tests) { this.container = container; this.tests = tests; if(container != null)</p>
<p>headline = container.getClass().getSimpleName();</p>
<p>}</p>
<p>public Tester(C container, List&lt;Test&lt;C&gt;&gt; tests,</p>
<p>TestParam[] paramList) { this(container, tests); this.paramList = paramList;</p>
<p>}</p>
<p>public void setHeadline(String newHeadline) { headline = newHeadline;</p>
<p>}</p>
<p>// Generic methods for convenience :</p>
<p>public static &lt;C&gt; void run(C cntnr, List&lt;Test&lt;C&gt;&gt; tests){ new Tester&lt;C&gt;(cntnr, tests).timedTest();</p>
<p>}</p>
<p>public static &lt;C&gt; void run(C cntnr,</p>
<p>List&lt;Test&lt;C&gt;&gt; tests, TestParam[] paramList) { new Tester&lt;C&gt;(cntnr, tests, paramList).timedTest();</p>
<p>}</p>
<p>private void displayHeader() {</p>
<p>// Calculate width and pad with ‘-’:</p>
<p>int width = fieldWidth * tests.size() + sizeWidth;</p>
<p>int dashLength = width - headline.length() - 1;</p>
<p>StringBuilder head = new StringBuilder(width); for(int i = 0; i &lt; dashLength/2; i++) head.append(‘-’); head.append(‘ ‘); head.append(headline); head.append(‘ ‘);</p>
<p>for(int i = 0; i &lt; dashLength/2; i++) head.append(‘-’);</p>
<p>System.out.println(head);</p>
<p>// Print column headers:</p>
<p>System.out.format(sizeField, &quot;size&quot;); for(Test test : tests)</p>
<p>System.out.format(stringField(), test.name); System.out.println();</p>
<p>}</p>
<p>// Run the tests for this container: public void timedTest() { displayHeader();</p>
<p>for(TestParam param : paramList) {</p>
<p>System.out.format(sizeField, param.size); for(Test&lt;C&gt; test : tests) {</p>
<p>C kontainer = initialize(param.size); long start = System.nanoTime();</p>
<p>// Call the overriden method:</p>
<p>int reps = test.test(kontainer, param);</p>
<p>long duration = System.nanoTime() - start;</p>
<p>long timePerRep = duration / reps; // Nanoseconds</p>
<p>System.out.format(numberField(), timePerRep);</p>
<p>}</p>
<p>System.out.println();</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>The stringField( ) and numberField( ) methods produce formatting strings for outputting the results. The standard width for formatting can be changed by modifying the static fieldWidth value. The displayHeader( ) method formats and prints the header information for each test.</p>
<p>If you need to perform special initialization, override the initialize( ) method. This produces an initialized container object of the appropriate size—you can either modify the existing container object or create a new one. You can see in test( ) that the result is captured in a local reference called kontainer, which allows you to replace the stored member container with a completely different initialized container.</p>
<p>The return value of each Test.test( ) method must be the number of operations performed by that test, which is used to calculate the number of nanoseconds required for each operation. You should be aware that System.nanoTime( ) typically produces values with a granularity that is greater than one (and this granularity will vary with machines and operating systems), and this will produce a certain amount of rattle in the results.</p>
<p>The results may vary from machine to machine; these tests are only intended to compare the performance of the different containers.</p>
<subtitle>Choosing between Lists</subtitle>
<p>Here is a performance test for the most essential of the List operations. For comparison, it also shows the most important Queue operations. Two separate lists of tests are created for testing each class of container. In this case, Queue operations only apply to LinkedLists.</p>
<p>//: containers/ListPerformance.java // Demonstrates performance differences in Lists.</p>
<p>// {Args: 100 500} Small to keep build testing short</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>public class ListPerformance {</p>
<p>static Random rand = new Random(); static int reps = 1000; static List&lt;Test&lt;List&lt;Integer&gt;&gt;&gt; tests = new ArrayList&lt;Test&lt;List&lt;Integer&gt;&gt;&gt;(); static List&lt;Test&lt;LinkedList&lt;Integer&gt;&gt;&gt; qTests = new ArrayList&lt;Test&lt;LinkedList&lt;Integer&gt;&gt;&gt;(); static {</p>
<p>tests.add(new Test&lt;List&lt;Integer&gt;&gt;(&quot;add&quot;) { int test(List&lt;Integer&gt; list, TestParam tp) { int loops = tp.loops; int listSize = tp.size; for(int i = 0; i &lt; loops; i++) { list.clear();</p>
<p>for(int j = 0; j &lt; listSize; j++) list.add(j);</p>
<p>}</p>
<p>return loops * listSize;</p>
<p>}</p>
<p>});</p>
<p>tests.add(new Test&lt;List&lt;Integer&gt;&gt;(&quot;get&quot;) { int test(List&lt;Integer&gt; list, TestParam tp) { int loops = tp.loops * reps; int listSize = list.size(); for(int i = 0; i &lt; loops; i++) list.get(rand.nextInt(listSize)); return loops;</p>
<p>}</p>
<p>});</p>
<p>tests.add(new Test&lt;List&lt;Integer&gt;&gt;(&quot;set&quot;) {</p>
<p>int test(List&lt;Integer&gt; list, TestParam tp) { int loops = tp.loops * reps; int listSize = list.size(); for(int i = 0; i &lt; loops; i++)</p>
<p>list.set(rand.nextInt(listSize), 47); return loops;</p>
<p>}</p>
<p>});</p>
<p>tests.add(new Test&lt;List&lt;Integer&gt;&gt;(&quot;iteradd&quot;) { int test(List&lt;Integer&gt; list, TestParam tp) { final int LOOPS = 1000000; int half = list.size() / 2;</p>
<p>ListIterator&lt;Integer&gt; it = list.listIterator(half); for(int i = 0; i &lt; LOOPS; i++) it.add(47); return LOOPS;</p>
<p>}</p>
<p>});</p>
<p>tests.add(new Test&lt;List&lt;Integer&gt;&gt;(&quot;insert&quot;) { int test(List&lt;Integer&gt; list, TestParam tp) { int loops = tp.loops; for(int i = 0; i &lt; loops; i++)</p>
<p>list.add(5, 47); // Minimize random-access cost return loops;</p>
<p>}</p>
<p>});</p>
<p>tests.add(new Test&lt;List&lt;Integer&gt;&gt;(&quot;remove&quot;) { int test(List&lt;Integer&gt; list, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int i = 0; i &lt; loops; i++) { list.clear();</p>
<p>list.addAll(new CountingIntegerList(size)); while(list.size() &gt; 5)</p>
<p>list.remove(5); // Minimize random-access cost</p>
<p>}</p>
<p>return loops * size;</p>
<p>}</p>
<p>});</p>
<p>// Tests for queue behavior:</p>
<p>qTests.add(new Test&lt;LinkedList&lt;Integer&gt;&gt;(&quot;addFirst&quot;) { int test(LinkedList&lt;Integer&gt; list, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int i = 0; i &lt; loops; i++) { list.clear();</p>
<p>for(int j = 0; j &lt; size; j++) list.addFirst(47);</p>
<p>}</p>
<p>return loops * size;</p>
<p>}</p>
<p>});</p>
<p>qTests.add(new Test&lt;LinkedList&lt;Integer&gt;&gt;(&quot;addLast&quot;) { int test(LinkedList&lt;Integer&gt; list, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int i = 0; i &lt; loops; i++) { list.clear();</p>
<p>for(int j = 0; j &lt; size; j++) list.addLast(47);</p>
<p>}</p>
<p>return loops * size;</p>
<p>}</p>
<p>});</p>
<p>qTests.add(</p>
<p>new Test&lt;LinkedList&lt;Integer&gt;&gt;(&quot;rmFirst&quot;) {</p>
<p>int test(LinkedList&lt;Integer&gt; list, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int i = 0; i &lt; loops; i++) { list.clear();</p>
<p>list.addAll(new CountinglntegerList(size)); while(list.size() &gt; 0) list.removeFirst();</p>
<p>}</p>
<p>return loops * size;</p>
<p>}</p>
<p>});</p>
<p>qTests.add(new Test&lt;LinkedList&lt;Integer&gt;&gt;(&quot;rmLast&quot;) { int test(LinkedList&lt;Integer&gt; list, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int i = 0; i &lt; loops; i++) { list.clear();</p>
<p>list.addAll(new CountingIntegerList(size)); while(list.size() &gt; 0) list.removeLast();</p>
<p>}</p>
<p>return loops * size;</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>static class ListTester extends Tester&lt;List&lt;Integer&gt;&gt; { public ListTester(List&lt;Integer&gt; container, List&lt;Test&lt;List&lt;Integer&gt;&gt;&gt; tests) { super(container, tests);</p>
<p>}</p>
<p>// Fill to the appropriate size before each test: @Override protected List&lt;Integer&gt; initialize(int size){ container.clear();</p>
<p>container.addAll(new CountingIntegerList(size)); return container;</p>
<p>}</p>
<p>// Convenience method:</p>
<p>public static void run(List&lt;Integer&gt; list, List&lt;Test&lt;List&lt;Integer&gt;&gt;&gt; tests) { new ListTester(list, tests).timedTest();</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) { if(args.length &gt; 0)</p>
<p>Tester.defaultParams = TestParam.array(args);</p>
<p>// Can only do these two tests on an array: Tester&lt;List&lt;Integer&gt;&gt; arrayTest =</p>
<p>new Tester&lt;List&lt;Integer&gt;&gt;(null, tests.subList(1, 3)){ // This will be called before each test. It // produces a non-resizeable array-backed list: @Override protected List&lt;Integer&gt; initialize(int size) {</p>
<p>Integer[] ia = Generated.array(Integer.class, new CountingGenerator.Integer(), size); return Arrays.asList(ia);</p>
<p>}</p>
<p>};</p>
<p>arrayTest.setHeadline(&quot;Array as List&quot;); arrayTest.timedTest();</p>
<p>Tester.defaultParams= TestParam.array(</p>
<p>10, 5000, 100, 5000, 1000, 1000, 10000, 200); if(args.length &gt; 0)</p>
<p>Tester.defaultParams = TestParam.array(args); ListTester.run(new ArrayList&lt;Integer&gt;(), tests); ListTester.run(new LinkedList&lt;Integer&gt;(), tests); ListTester.run(new Vector&lt;Integer&gt;(), tests); Tester.fieldWidth = 12; Tester&lt;LinkedList&lt;Integer&gt;&gt; qTest = new Tester&lt;LinkedList&lt;Integer&gt;&gt;( new LinkedList&lt;Integer&gt;(), qTests); qTest.setHeadline(&quot;Queue tests&quot;); qTest.timedTest();</p>
<p>}</p>
<table>
<tr><th colspan="8">} /* Output: (Sample)</th></tr>
<tr><td>— Array</td><td>as</td><td>List</td><td>—</td><td></td><td></td><td></td><td></td></tr>
<tr><td>size</td><td>get</td><td></td><td>set</td><td></td><td></td><td></td><td></td></tr>
<tr><td>10</td><td>130</td><td></td><td>183</td><td></td><td></td><td></td><td></td></tr>
<tr><td>100</td><td>130</td><td></td><td>164</td><td></td><td></td><td></td><td></td></tr>
<tr><td>1000</td><td>129</td><td></td><td>165</td><td></td><td></td><td></td><td></td></tr>
<tr><td>10000</td><td>129</td><td></td><td>165</td><td>ArrayList -</td><td></td><td></td><td></td></tr>
<tr><td>size</td><td>add</td><td></td><td>get</td><td colspan="2">set iteradd</td><td>insert</td><td>remove</td></tr>
<tr><td>10</td><td>121</td><td></td><td>139</td><td>191</td><td>435</td><td>3952</td><td>446</td></tr>
<tr><td>100</td><td>72</td><td></td><td>141</td><td>191</td><td>247</td><td>3934</td><td>296</td></tr>
<tr><td>1000</td><td>98</td><td></td><td>141</td><td>194</td><td>839</td><td>2202</td><td>923</td></tr>
<tr><td>10000</td><td>122</td><td></td><td>144</td><td>190</td><td>6880</td><td>14042</td><td>7333</td></tr>
<tr><td></td><td></td><td></td><td></td><td>LinkedList</td><td></td><td></td><td></td></tr>
<tr><td>size</td><td>add</td><td></td><td>get</td><td colspan="2">set iteradd</td><td>insert</td><td>remove</td></tr>
<tr><td>10</td><td>182</td><td></td><td>164</td><td>198</td><td>658</td><td>366</td><td>262</td></tr>
<tr><td>100</td><td>106</td><td></td><td>202</td><td>230</td><td>457</td><td>108</td><td>201</td></tr>
<tr><td>1000</td><td>133</td><td></td><td>1289</td><td>1353</td><td>430</td><td>136</td><td>239</td></tr>
<tr><td>10000</td><td>172</td><td colspan="2">13648</td><td>13187</td><td>435</td><td>255</td><td>239</td></tr>
<tr><td></td><td></td><td></td><td></td><td>-- Vector --</td><td></td><td></td><td></td></tr>
<tr><td>size</td><td>add</td><td></td><td>get</td><td colspan="2">set iteradd</td><td>insert</td><td>remove</td></tr>
<tr><td>10</td><td>129</td><td></td><td>145</td><td>187</td><td>290</td><td>3635</td><td>253</td></tr>
<tr><td>100</td><td>72</td><td></td><td>144</td><td>190</td><td>263</td><td>3691</td><td>292</td></tr>
<tr><td>1000</td><td>99</td><td></td><td>145</td><td>193</td><td>846</td><td>2162</td><td>927</td></tr>
<tr><td>10000</td><td>108</td><td></td><td>145</td><td>186</td><td>6871</td><td>14730</td><td>7135</td></tr>
<tr><td></td><td></td><td></td><td colspan="2">--- Queue tests</td><td></td><td></td><td></td></tr>
<tr><td>size</td><td colspan="2">addFirst</td><td></td><td>addLast</td><td colspan="2">rmFirst</td><td>rmLast</td></tr>
<tr><td>10</td><td></td><td>199</td><td></td><td>163</td><td></td><td>251</td><td>253</td></tr>
<tr><td>100</td><td></td><td>98</td><td></td><td>92</td><td></td><td>180</td><td>179</td></tr>
<tr><td>1000</td><td></td><td>99</td><td></td><td>93</td><td></td><td>216</td><td>212</td></tr>
<tr><td>10000*///:~</td><td></td><td>111</td><td></td><td>109</td><td></td><td>262</td><td>384</td></tr>
</table>
<p>Each test requires careful thought to ensure that you are producing meaningful results. For example, the &quot;add&quot; test clears the List and then refills it to the specified list size. The call to clear( ) is thus part of the test, and may have an impact on the time, especially for small tests. Although the results here seem fairly reasonable, you could imagine rewriting the test framework so that there is a call to a preparation method (which would, in this case, include the clear( ) call) outside of the timing loop.</p>
<p>Note that for each test, you must accurately calculate the number of operations that occur and return that value from test( ), so the timing is correct.</p>
<p>The &quot;get&quot; and &quot;set&quot; tests both use the random number generator to perform random accesses to the List. In the output, you can see that, for a List backed by an array and for an ArrayList, these accesses are fast and very consistent regardless of the list size, whereas for a LinkedList, the access times grow very significantly for larger lists. Clearly, linked lists are not a good choice if you will be performing many random accesses.</p>
<p>The &quot;iteradd&quot; test uses an iterator in the middle of the list to insert new elements. For an ArrayList this gets expensive as the list gets bigger, but for a LinkedList it is relatively cheap, and constant regardless of size. This makes sense because an ArrayList must create space and copy all its references forward during an insertion. This becomes expensive as the ArrayList gets bigger. A LinkedList only needs to link in a new element, and doesn’t have to modify the rest of the list, so you expect the cost to be roughly the same regardless of the list size.</p>
<p>The &quot;insert&quot; and &quot;remove&quot; tests both use location number 5 as the point of insertion or removal, rather than either end of the List. A LinkedList treats the endpoints of the List specially—this improves the speed when using a LinkedList as a Queue. However, if you add or remove elements in the middle of the list, you include the cost of random access, which we’ve already seen varies with the different List implementations. By performing the insertions and removals at location 5, the cost of the random access should be negligible and we should see only the cost of insertion and removal, but we will not see any specialized optimization for the end of a LinkedList. You can see from the output that the cost of insertion and removal in a LinkedList is quite cheap and doesn’t vary with the list size, but with an ArrayList, insertions especially are very expensive, and the cost increases with list size.</p>
<p>From the Queue tests, you can see how quickly a LinkedList can insert and remove elements from the endpoints of the list, which is optimal for Queue behavior.</p>
<p>Normally, you can just call Tester.run( ), passing the container and the tests list. Here, however, we must override the initialize( ) method so that the List is cleared and refilled before each test—otherwise the List control over the size of the List would be lost during the various tests. ListTester inherits from Tester and performs this initialization using CountingIntegerList. The run( ) convenience method is also overridden. We’d also like to compare array access to container access (primarily against ArrayList). In the first test in main( ), a special Test object is created using an anonymous inner class. The initialize( ) method is overridden to create a new object each time it is called (ignoring the stored container object, so null is the container argument for this Tester constructor). The new object is created using Generated.array( ) (which was defined in the Arrays chapter) and Arrays.asList( ). Only two of the tests can be performed in this case, because you cannot insert or remove elements when using a List backed by an array, so the List.subList( ) method is used to select the desired tests from the tests list.</p>
<p>For random-access get( ) and set( ) operations, a List backed by an array is slightly faster than an ArrayList, but the same operations are dramatically more expensive for a LinkedList because it is not designed for randomaccess operations.</p>
<p>Vector should be avoided; it’s only in the library for legacy code support (the only reason it works in this program is because it was adapted to be a List for forward compatibility).</p>
<p>The best approach is probably to choose an ArrayList as your default and to change to a LinkedList if you need its extra functionality or you discover performance problems due to many insertions and removals from the middle of the list. If you are working with a fixedsized group of elements, either use a List backed by an array (as produced by Arrays.asList( )), or if necessary, an actual array.</p>
<p>CopyOnWriteArrayList is a special implementation of List used in concurrent programming, and will be discussed in the Concurrency chapter.</p>
<p>Exercise 29: (2) Modify ListPerformance.java so that the Lists hold String objects instead of Integers. Use a Generator from the Arrays chapter to create test values.</p>
<p>Exercise 30: (3) Compare the performance of Collections.sort( ) between an ArrayList and a LinkedList.</p>
<p>Exercise 31: (5) Create a container that encapsulates an array of String, and that only allows adding Strings and getting Strings, so that there are no casting issues during use. If the internal array isn’t big enough for the next add, your container should automatically resize it. In main( ), compare the performance of your container with an ArrayList&lt;String&gt;.</p>
<p>Exercise 32: (2) Repeat the previous exercise for a container of int, and compare the performance to an ArrayList&lt;Integer&gt;. In your performance comparison, include the process of incrementing each object in the container.</p>
<p>Exercise 33: (5) Create a FastTraversalLinkedList that internally uses a LinkedList</p>
<p>for rapid insertions and removals, and an ArrayList for rapid traversals and get( ) operations. Test it by modifying ListPerformance.java.</p>
<subtitle>Microbenchmarking dangers</subtitle>
<p>When writing so-called microbenchmarks, you must be careful not to assume too much, and to narrow your tests so that as much as possible they are only timing the items of interest.</p>
<p>You must also be careful to ensure that your tests run long enough to produce interesting data, and take into account that some of the Java HotSpot technologies will only kick in when a program runs for a certain time (this is important to consider for short-running programs, as well).</p>
<p>Results will be different according to the computer and JVM you are using, so you should run these tests yourself to verify that the results are similar to those shown in this book. You should not be so concerned with absolute numbers as with the performance comparisons between one type of container and another.</p>
<p>Also, a profiler may do a better job of performance analysis than you can. Java comes with a profiler (see the supplement at <a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a>) and there are third-party profilers available, both free/open-source and commercial.</p>
<p>A related example concerns Math.random( ). Does it produce a value from zero to one, inclusive or exclusive of the value &quot;1&quot;? In math lingo, is it (0,1), or [0,1], or (0,1] or [0,1)? (The square bracket means &quot;includes,&quot; whereas the parenthesis means &quot;doesn’t include.&quot;) A test program might provide the answer:</p>
<p>//: containers/RandomBounds.java</p>
<p>// Does Math.random() produce 0.0 and 1.0?</p>
<p>// {RunByHand}</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class RandomBounds { static void usage() { print(&quot;Usage:&quot;); print(&quot;\tRandomBounds lower&quot;); print(&quot;\tRandomBounds upper&quot;);</p>
<p>System.exit(l);</p>
<p>}</p>
<p>public static void main(String[] args) { if(args.length != 1) usage(); if(args[0].equals(&quot;lower&quot;)) { while(Math.random() != 0.0)</p>
<p>; // Keep trying</p>
<p>print(&quot;Produced 0.0!&quot;);</p>
<p>else if(args[0].equals(&quot;upper&quot;)) { while(Math.random() != 1.0)</p>
<p>; // Keep trying print(&quot;Produced 1.0!&quot;);</p>
<p>}</p>
<p>else</p>
<p>usage();</p>
<p>}</p>
<p>} ///:~</p>
<p>To run the program, you type a command line of either: java RandomBounds lower or</p>
<p>java RandomBounds upper</p>
<p>In both cases, you are forced to break out of the program manually, so it would appear that Math.random( ) never produces either o.o or l.o. But this is where such an experiment can be deceiving. If you consider that there are about 262 different double fractions between o and 1, the likelihood of reaching any one value experimentally might exceed the lifetime of one computer, or even one experimenter. It turns out that 0.0 is included in the output of Math.random( ). Or, in math lingo, it is [0,1). Thus, you must be careful to analyze your experiments and to understand their limitations.</p>
<subtitle>Choosing between Sets</subtitle>
<p>Depending on the behavior you desire, you can choose a TreeSet, a HashSet, or a LinkedHashSet. The following test program gives an indication of the performance tradeoff between these implementations:</p>
<p>//: containers/SetPerformance.java // Demonstrates performance differences in Sets.</p>
<p>// {Args: 100 5000} Small to keep build testing short import java.util.*;</p>
<p>public class SetPerformance {</p>
<p>static List&lt;Test&lt;Set&lt;Integer&gt;&gt;&gt; tests = new ArrayList&lt;Test&lt;Set&lt;Integer&gt;&gt;&gt;(); static {</p>
<p>tests.add(new Test&lt;Set&lt;Integer&gt;&gt;(&quot;add&quot;) { int test(Set&lt;Integer&gt; set, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int i = 0; i &lt; loops; i++) { set.clear();</p>
<p>for(int j = 0; j &lt; size; j++) set.add(j);</p>
<p>}</p>
<p>return loops * size;</p>
<p>}</p>
<p>});</p>
<p>tests.add(new Test&lt;Set&lt;Integer&gt;&gt;(&quot;contains&quot;) { int test(Set&lt;Integer&gt; set, TestParam tp) { int loops = tp.loops;</p>
<p>int span = tp.size * 2; for(int i = 0; i &lt; loops; i++) for(int j = 0; j &lt; span; j++) set.contains(j); return loops * span;</p>
<p>}</p>
<p>});</p>
<p>tests.add(new Test&lt;Set&lt;Integer&gt;&gt;(&quot;iterate&quot;) { int test(Set&lt;Integer&gt; set, TestParam tp) { int loops = tp.loops * 10; for(int i = 0; i &lt; loops; i++) {</p>
<p>Iterator&lt;Integer&gt; it = set.iterator(); while(it.hasNext()) it.next();</p>
<p>}</p>
<p>return loops * set.size();</p>
<p>}</p>
<p>});</p>
<table>
<tr><td>size</td><td>add</td><td>contains</td><td>iterate</td></tr>
<tr><td>10</td><td>746</td><td>173</td><td>89</td></tr>
<tr><td>100</td><td>501</td><td>264</td><td>68</td></tr>
<tr><td>1000</td><td>714</td><td>410</td><td>69</td></tr>
<tr><td>10000</td><td>1975</td><td>552</td><td>69</td></tr>
<tr><td></td><td colspan="2">----- HashSet -----</td><td></td></tr>
<tr><td>size</td><td>add</td><td>contains</td><td>iterate</td></tr>
<tr><td>10</td><td>308</td><td>91</td><td>94</td></tr>
<tr><td>100</td><td>178</td><td>75</td><td>73</td></tr>
<tr><td>1000</td><td>216</td><td>110</td><td>72</td></tr>
<tr><td>10000</td><td>711</td><td>215</td><td>100</td></tr>
<tr><td colspan="4">LinkedHashSet</td></tr>
</table>
<table>
<tr><td>size</td><td>add</td><td>contains</td><td>iterate</td></tr>
<tr><td>10</td><td>350</td><td>65</td><td>83</td></tr>
<tr><td>100</td><td>270</td><td>74</td><td>55</td></tr>
<tr><td>1000</td><td>303</td><td>111</td><td>54</td></tr>
<tr><td>10000*///:~</td><td>1615</td><td>256</td><td>58</td></tr>
</table>
<p>}</p>
<p>public static void main(String[] args) { if(args.length &gt; 0)</p>
<p>Tester.defaultParams = TestParam.array(args); Tester.fieldWidth = 10;</p>
<p>Tester.run(new TreeSet&lt;Integer&gt;(), tests); Tester.run(new HashSet&lt;Integer&gt;(), tests); Tester.run(new LinkedHashSet&lt;Integer&gt;(), tests);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>------------- TreeSet -------------</p>
<p>The performance of HashSet is generally superior to TreeSet, but especially when adding elements and looking them up, which are the two most important operations. TreeSet exists because it maintains its elements in sorted order, so you use it only when you need a sorted Set. Because of the internal structure necessary to support sorting and because iteration is something you’re more likely to do, iteration is usually faster with a TreeSet than a HashSet.</p>
<p>Note that LinkedHashSet is more expensive for insertions than HashSet; this is because of the extra cost of maintaining the linked list along with the hashed container.</p>
<p>Exercise 34: (1) Modify SetPerformance.java so that the Sets hold String objects instead of Integers. Use a Generator from the Arrays chapter to create test values.</p>
<subtitle>Choosing between Maps</subtitle>
<p>This program gives an indication of the trade-off between Map implementations:</p>
<p>//: containers/MapPerformance.java // Demonstrates performance differences in Maps.</p>
<p>// {Args: 100 5000} Small to keep build testing short import java.util.*;</p>
<p>public class MapPerformance {</p>
<p>static List&lt;Test&lt;Map&lt;Integer,Integer&gt;&gt;&gt; tests = new ArrayList&lt;Test&lt;Map&lt;Integer,Integer&gt;&gt;&gt;(); static {</p>
<p>tests.add(new Test&lt;Map&lt;Integer,Integer&gt;&gt;(&quot;put&quot;) { int test(Map&lt;Integer,Integer&gt; map, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int i = 0; i &lt; loops; i++) { map.clear();</p>
<p>for(int j = 0; j &lt; size; j++) map.put(j, j);</p>
<p>}</p>
<p>return loops * size;</p>
<p>}</p>
<p>});</p>
<p>tests.add(new Test&lt;Map&lt;Integer,Integer&gt;&gt;(&quot;get&quot;) { int test(Map&lt;Integer,Integer&gt; map, TestParam tp) { int loops = tp.loops; int span = tp.size * 2; for(int i = 0; i &lt; loops; i++) for(int j = 0; j &lt; span; j++) map.get(j); return loops * span;</p>
<p>}</p>
<p>});</p>
<p>tests.add(new Test&lt;Map&lt;Integer,Integer&gt;&gt;(&quot;iterate&quot;) { int test(Map&lt;Integer,Integer&gt; map, TestParam tp) { int loops = tp.loops * 10; for(int i = 0; i &lt; loops; i ++) {</p>
<p>Iterator it = map.entrySet().iterator(); while(it.hasNext()) it.next();</p>
<p>}</p>
<p>return loops * map.size();</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>public static void main(String[] args) { if(args.length &gt; 0)</p>
<p>Tester.defaultParams = TestParam.array(args); Tester.run(new TreeMap&lt;Integer,Integer&gt;(), tests); Tester.run(new HashMap&lt;Integer,Integer&gt;(), tests); Tester.run(new LinkedHashMap&lt;Integer,Integer&gt;(),tests); Tester.run(</p>
<p>new IdentityHashMap&lt;Integer,Integer&gt;(), tests); Tester.run(new WeakHashMap&lt;Integer,Integer&gt;(), tests); Tester.run(new Hashtable&lt;Integer,Integer&gt;(), tests);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>---------- TreeMap ----------</p>
<p>size put get iterate</p>
<table>
<tr><td>10</td><td>748</td><td>168</td><td>100</td></tr>
<tr><td>100</td><td>506</td><td>264</td><td>76</td></tr>
<tr><td>1000</td><td>771</td><td>450</td><td>78</td></tr>
<tr><td>10000</td><td>2962</td><td>561</td><td>83</td></tr>
<tr><td></td><td colspan="2">---- HashMap —</td><td></td></tr>
<tr><td>size</td><td>put</td><td>get</td><td>iterate</td></tr>
<tr><td>10</td><td>281</td><td>76</td><td>93</td></tr>
<tr><td>100</td><td>179</td><td>70</td><td>73</td></tr>
<tr><td>1000</td><td>267</td><td>102</td><td>72</td></tr>
<tr><td>10000</td><td>1305</td><td>265</td><td>97</td></tr>
<tr><td></td><td colspan="2">- LinkedHashMap</td><td></td></tr>
<tr><td>size</td><td>put</td><td>get</td><td>iterate</td></tr>
<tr><td>10</td><td>354</td><td>100</td><td>72</td></tr>
<tr><td>100</td><td>273</td><td>89</td><td>50</td></tr>
<tr><td>1000</td><td>385</td><td>222</td><td>56</td></tr>
<tr><td>10000</td><td>2787</td><td>341</td><td>56</td></tr>
<tr><td></td><td colspan="2">IdentityHashMap</td><td></td></tr>
<tr><td>size</td><td>put</td><td>get</td><td>iterate</td></tr>
<tr><td>10</td><td>290</td><td>144</td><td>101</td></tr>
<tr><td>100</td><td>204</td><td>287</td><td>132</td></tr>
<tr><td>1000</td><td>508</td><td>336</td><td>77</td></tr>
<tr><td>10000</td><td>767</td><td>266</td><td>56</td></tr>
<tr><td></td><td colspan="2">-- WeakHashMap -</td><td></td></tr>
<tr><td>size</td><td>put</td><td>get</td><td>iterate</td></tr>
<tr><td>10</td><td>484</td><td>146</td><td>151</td></tr>
<tr><td>100</td><td>292</td><td>126</td><td>117</td></tr>
<tr><td>1000</td><td>411</td><td>136</td><td>152</td></tr>
<tr><td>10000</td><td>2165</td><td>138</td><td>555</td></tr>
<tr><td></td><td colspan="2">— Hashtable --</td><td></td></tr>
<tr><td>size</td><td>put</td><td>get</td><td>iterate</td></tr>
<tr><td>10</td><td>264</td><td>113</td><td>113</td></tr>
<tr><td>100</td><td>181</td><td>105</td><td>76</td></tr>
<tr><td>1000</td><td>260</td><td>201</td><td>80</td></tr>
<tr><td>10000</td><td>1245</td><td>134</td><td>77</td></tr>
</table>
<p>Insertions for all the Map implementations except for IdentityHashMap get significantly slower as the size of the Map gets large. In general, however, lookup is much cheaper than insertion, which is good because you’ll typically be looking items up much more often than you insert them.</p>
<p>Hashtable performance is roughly the same as HashMap. Since HashMap is intended to replace Hashtable, and thus uses the same underlying storage and lookup mechanism (which you will learn about later), this is not too surprising.</p>
<p>A TreeMap is generally slower than a HashMap. As with TreeSet, a TreeMap is a way to create an ordered list. The behavior of a tree is such that it’s always in order and doesn’t have to be specially sorted. Once you fill a TreeMap, you can call keySet( ) to get a Set view of the keys, then toArray( ) to produce an array of those keys. You can then use the static method Arrays.binarySearch( ) to rapidly find objects in your sorted array. Of course, this only makes sense if the behavior of a HashMap is unacceptable, since HashMap is designed to rapidly find keys. Also, you can easily create a HashMap from a TreeMap with a single object creation or call to putAll( ). In the end, when you’re using a Map, your first choice should be HashMap, and only if you need a constantly sorted Map will you need TreeMap.</p>
<p>LinkedHashMap tends to be slower than HashMap for insertions because it maintains the linked list (to preserve insertion order) in addition to the hashed data structure. Because of this list, iteration is faster.</p>
<p>IdentityHashMap has different performance because it uses == rather than equals( ) for comparisons. WeakHashMap is described later in this chapter.</p>
<p>Exercise 35: (1) Modify MapPerformance.java to include tests of SlowMap.</p>
<p>Exercise 36: (5) Modify SlowMap so that instead of two ArrayLists, it holds a single ArrayList of MapEntry objects. Verify that the modified version works correctly. Using MapPerformance.java, test the speed of your new Map. Now change the put( ) method so that it performs a sort( ) after each pair is entered, and modify get( ) to use Collections.binarySearch( ) to look up the key. Compare the performance of the new version with the old ones.</p>
<p>Exercise 37: (2) Modify SimpleHashMap to use ArrayLists instead of LinkedLists. Modify MapPerformance.java to compare the performance of the two implementations.</p>
<p>HashMap performance factors</p>
<p>It’s possible to hand-tune a HashMap to increase its performance for your particular application. So that you can understand performance issues when tuning a HashMap, some terminology is necessary:</p>
<p>Capacity: The number of buckets in the table.</p>
<p>Initial capacity: The number of buckets when the table is created. HashMap and HashSet have constructors that allow you to specify the initial capacity.</p>
<p>Size: The number of entries currently in the table.</p>
<p>Load factor: Size/capacity. A load factor of o is an empty table, 0.5 is a half-full table, etc. A lightly loaded table will have few collisions and so is optimal for insertions and lookups (but will slow down the process of traversing with an iterator). HashMap and HashSet have constructors that allow you to specify the load factor, which means that when this load factor is reached, the container will automatically increase the capacity (the number of buckets) by roughly doubling it and will redistribute the existing objects into the new set of buckets (this is called rehashing).</p>
<p>The default load factor used by HashMap is 0.75 (it doesn’t rehash until the table is three-fourths full). This seems to be a good trade-off between time and space costs. A higher load factor decreases the space required by the table but increases the lookup cost, which is important because lookup is what you do most of the time (including both get( ) and put(</p>
<p>)).</p>
<p>If you know that you’ll be storing many entries in a HashMap, creating it with an appropriately large initial capacity will prevent the overhead of automatic rehashing.<a l:href="#bookmark86" type="note"><sup>87</sup></a><sup></sup></p>
<p>Exercise 38: (3) Look up the HashMap class in the JDK documentation. Create a HashMap, fill it with elements, and determine the load factor. Test the lookup speed with this map, then attempt to increase the speed by making a new HashMap with a larger initial capacity and copying the old map into the new one, then run your lookup speed test again on the new map.</p>
<p>Exercise 39: (6) Add a private rehash( ) method to SimpleHashMap that is invoked when the load factor exceeds 0.75. During rehashing, double the number of buckets, then search for the first prime number greater than that to determine the new number of buckets.</p>
</section>
<section>
<title>
<p>Utilities</p></title><empty-line/>
<p>There are a number of standalone utilities for containers, expressed as static methods inside the java.util.Collections class. You’ve already seen some of these, such as addAll( ), reverseOrder( ) and binarySearch( ). Here are the others (the synchronized and unmodifiable utilities will be covered in sections that follow). In this table, generics are used when they are relevant:</p>
<table>
<tr><td>checkedCollection( Collection&lt;T&gt;, Class&lt;T&gt; type) checkedList(List&lt;T&gt;, Class&lt;T&gt; type) checkedMap(Map&lt;K,V&gt;,Class &lt;K&gt; keyType,Class &lt;V&gt; valueType) checkedSet(Set&lt;T&gt;,Class&lt;T&gt; type)checkedSortedMap(SortedMap&lt;K,V&gt;,Class&lt;K&gt; keyType,Class &lt;V&gt; valueType)checkedSortedSet(SortedSet&lt;T&gt;,Class&lt;T&gt; type)</td><td>Produces a dynamically type-safe view of a Collection, or a specific subtype of Collection. Use this when it’s not possible to use the statically checked version.These were shown in the Generics chapter under the heading &quot;Dynamic type safety.&quot;</td></tr>
<tr><td>max(Collection)min(Collection)</td><td>Produces the maximum or minimum element in the argument using the natural comparison method of the objects in the Collection.</td></tr>
<tr><td>max(Collection, Comparator) min(Collection, Comparator)</td><td>Produces the maximum or minimum element in the Collection using the Comparator.</td></tr>
<tr><td>indexOfSubList(List source, List target)</td><td>Produces starting index of the first place where target appears inside source, or -1 if none occurs.</td></tr>
<tr><td>lastIndexOfSubList(List source, List target)</td><td>Produces starting index of the last place where target appears inside source, or -1 if none occurs.</td></tr>
<tr><td>replaceAll(List&lt;T&gt;, T oldVal, T newVal)</td><td>Replaces all oldVal with newVal.</td></tr>
<tr><td>reverse(List)</td><td>Reverses all the elements in place.</td></tr>
<tr><td>reverseOrder( )reverseOrder(Comparator&lt;T&gt;)</td><td>Returns a Comparator that reverses the natural ordering of a collection of objects that implement Comparable&lt;T&gt;. The second version reverses the order of the supplied Comparator.</td></tr>
</table>
<table>
<tr><td>rotate(List, int distance)</td><td>Moves all elements forward by distance, taking the ones off the end and placing them at the beginning.</td></tr>
<tr><td>shuffle(List) shuffle(List, Random)</td><td>Randomly permutes the specified list. The first form provides its own randomization source, or you may provide your own with the second form.</td></tr>
<tr><td>sort(List&lt;T&gt;) sort(List&lt;T&gt;, Comparator&lt;? super T&gt; c)</td><td>Sorts the List&lt;T&gt; using its natural ordering. The second form allows you to provide a Comparator for sorting.</td></tr>
<tr><td>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</td><td>Copies elements from src to dest.</td></tr>
<tr><td>swap(List, int i, int j)</td><td>Swaps elements at locations i and j in the List. Probably faster than what you’d write by hand.</td></tr>
<tr><td>fill(List&lt;? super T&gt;, T x)</td><td>Replaces all the elements of list with x.</td></tr>
<tr><td>nCopies(int n, T x)</td><td>Returns an immutable List&lt;T&gt; of size n whose references all point to x.</td></tr>
<tr><td>disjoint(Collection, Collection)</td><td>Returns true if the two collections have no elements in common.</td></tr>
<tr><td>frequency(Collection, Object x)</td><td>Returns the number of elements in the Collection equal to x.</td></tr>
<tr><td>emptyList( ) emptyMap( ) emptySet( )</td><td>Returns an immutable empty List, Map, or Set. These are generic, so the resulting Collection will be parameterized to the desired type.</td></tr>
<tr><td>singleton(T x) singletonList(T x) singletonMap(K key, V value)</td><td>Produces an immutable Set&lt;T&gt;, List&lt;T&gt;, or Map&lt;K,V&gt;containing a single entry based on the given argument(s).</td></tr>
<tr><td>list(Enumeration&lt;T&gt; e)</td><td>Produces an ArrayList&lt;T&gt; containing the elements in the order in which they are returned by the (old-style) Enumeration (predecessor to the Iterator). For converting from legacy code.</td></tr>
<tr><td>enumeration(Collection&lt;T&gt;)</td><td>Produces an old-style Enumeration&lt;T&gt; for theargument.</td></tr>
</table>
<p>Note that min( ) and max( ) work with Collection objects, not with Lists, so you don’t need to worry about whether the Collection should be sorted or not. (As mentioned earlier, you do need to sort( ) a List or an array before performing a binarySearch( ).)</p>
<p>Here’s an example showing the basic use of most of the utilities in the above table: //: containers/Utilities.java</p>
<p>// Simple demonstrations of the Collections utilities. import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Utilities {</p>
<p>static List&lt;String&gt; list = Arrays.asList(</p>
<p>&quot;one Two three Four five six one&quot;.split(&quot; &quot;)); public static void main(String[] args) { print(list);</p>
<p>print(&quot;‘list’ disjoint (Four)?: &quot; + Collections.disjoint(list,</p>
<p>Collections.singletonList(&quot;Four&quot;))); print(&quot;max: &quot; + Collections.max(list)); print(&quot;min: &quot; + Collections.min(list)); print(&quot;max w/ comparator: &quot; + Collections.max(list, String.CASE_INSENSITIVE_ORDER)); print(&quot;min w/ comparator: &quot; + Collections.min(list, String.CASE_INSENSITIVE_ORDER));</p>
<p>List&lt;String&gt; sublist =</p>
<p>Arrays.asList(&quot;Four five six&quot;.split(&quot; &quot;)); print(&quot;indexOfSubList: &quot; +</p>
<p>Collections.indexOfSubList(list, sublist)); print(&quot;lastIndexOfSubList: &quot; +</p>
<p>Collections.lastIndexOfSubList(list, sublist)); Collections.replaceAll(list, &quot;one&quot;, &quot;Yo&quot;); print(&quot;replaceAll: &quot; + list); Collections.reverse(list); print(&quot;reverse: &quot; + list);</p>
<p>Collections.rotate(list, 3); print(&quot;rotate: &quot; + list);</p>
<p>List&lt;String&gt; source =</p>
<p>Arrays.asList(&quot;in the matrix&quot;.split(&quot; &quot;)); Collections.copy(list, source); print(&quot;copy: &quot; + list);</p>
<p>Collections.swap(list, 0, list.size() - 1); print(&quot;swap: &quot; + list);</p>
<p>Collections.shuffle(list, new Random(47)); print(&quot;shuffled: &quot; + list);</p>
<p>Collections.fill(list, &quot;pop&quot;); print(&quot;fill: &quot; + list); print(&quot;frequency of ‘pop’: &quot; +</p>
<p>Collections.frequency(list, &quot;pop&quot;));</p>
<p>List&lt;String&gt; dups = Collections.nCopies(3, &quot;snap&quot;); print(&quot;dups: &quot; + dups); print(&quot;‘list’ disjoint ‘dups’?: &quot; + Collections.disjoint(list, dups));</p>
<p>// Getting an old-style Enumeration:</p>
<p>Enumeration&lt;String&gt; e = Collections.enumeration(dups); Vector&lt;String&gt; v = new Vector&lt;String&gt;(); while(e.hasMoreElements())</p>
<p>v.addElement(e.nextElement());</p>
<p>// Converting an old-style Vector // to a List via an Enumeration:</p>
<p>ArrayList&lt;String&gt; arrayList = Collections.list(v.elements()); print(&quot;arrayList: &quot; + arrayList);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[one, Two, three, Four, five, six, one]</p>
<p>‘list’ disjoint (Four)?: false max: three min: Four</p>
<p>max w/ comparator: Two min w/ comparator: five indexOfSubList: 3 lastIndexOfSubList: 3</p>
<p>replaceAH: [Yo, Two, three, Four, five, six, Yo] reverse: [Yo, six, five, Four, three, Two, Yo] rotate: [three, Two, Yo, Yo, six, five, Four] copy: [in, the, matrix, Yo, six, five, Four] swap: [Four, the, matrix, Yo, six, five, in] shuffled: [six, matrix, the, Four, Yo, five, in] fill: [pop, pop, pop, pop, pop, pop, pop] frequency of ‘pop’: 7 dups: [snap, snap, snap]</p>
<p>‘list’ disjoint ‘dups’?: true arrayList: [snap, snap, snap]</p>
<p>*///:~</p>
<p>The output explains the behavior of each utility method. Note the difference in min( ) and max( ) with the String.CASE_INSENSITIVE_ORDER Comparator because of capitalization.</p>
<subtitle>Sorting and searching Lists</subtitle>
<p>Utilities to perform sorting and searching for Lists have the same names and signatures as those for sorting arrays of objects, but are static methods of Collections instead of Arrays. Here’s an example that uses the list data from Utilities.java:</p>
<p>//: containers/ListSortSearch.java</p>
<p>// Sorting and searching Lists with Collections utilities. import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ListSortSearch {</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;String&gt; list =</p>
<p>new ArrayList&lt;String&gt;(Utilities.list); list.addAll(Utilities.list); print(list);</p>
<p>Collections.shuffle(list, new Random(47)); print(&quot;Shuffled: &quot; + list);</p>
<p>// Use a ListIterator to trim off the last elements: ListIterator&lt;String&gt; it = list.listIterator(10); while(it.hasNext()) { it.next(); it.remove();</p>
<p>}</p>
<p>print(&quot;Trimmed: &quot; + list);</p>
<p>Collections.sort(list); print(&quot;Sorted: &quot; + list);</p>
<p>String key = list.get(7);</p>
<p>int index = Collections.binarySearch(list, key); print(&quot;Location of &quot; + key + &quot; is &quot; + index +</p>
<p>&quot;, list.get(&quot; + index + &quot;) = &quot; + list.get(index)); Collections.sort(list, String.CASE_INSENSITIVE_ORDER); print(&quot;Case-insensitive sorted: &quot; + list); key = list.get(7);</p>
<p>index = Collections.binarySearch(list, key, String.CASE_INSENSITIVE_ORDER); print(&quot;Location of &quot; + key + &quot; is &quot; + index +</p>
<p>&quot;, list.get(&quot; + index + &quot;) = &quot; + list.get(index));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[one, Two, three, Four, five, six, one, one, Two, three, Four, five, six, one]</p>
<p>Shuffled: [Four, five, one, one, Two, six, six, three, three, five, Four, Two, one, one]</p>
<p>Trimmed: [Four, five, one, one, Two, six, six, three, three, five] Sorted: [Four, Two, five, five, one, one, six, six, three, three] Location of six is 7, list.get(7) = six</p>
<p>Case-insensitive sorted: [five, five, Four, one, one, six, six, three, three, Two]</p>
<p>Location of three is 7, list.get(7) = three *///:~</p>
<p>Just as when searching and sorting with arrays, if you sort using a Comparator, you must binarySearch( ) using the same Comparator.</p>
<p>This program also demonstrates the shuffle( ) method in Collections, which randomizes the order of a List. A ListIterator is created at a particular location in the shuffled list, and used to remove the elements from that location until the end of the list.</p>
<p>Exercise 40: (5) Create a class containing two String objects and make it Comparable so that the comparison only cares about the first String. Fill an array and an ArrayList with objects of your class, using the RandomGenerator generator. Demonstrate that sorting works properly. Now make a Comparator that only cares about the second String, and demonstrate that sorting works properly. Also perform a binary search using your Comparator.</p>
<p>Exercise 41: (3) Modify the class in the previous exercise so that it will work with HashSets and as a key in HashMaps.</p>
<p>Exercise 42: (2) Modify Exercise 40 so that an alphabetic sort is used.</p>
<p>Making a Collection or Map</p>
<subtitle>unmodifiable</subtitle>
<p>Often it is convenient to create a read-only version of a Collection or Map. The Collections class allows you to do this by passing the original container into a method that hands back a read-only version. There are a number of variations on this method, for Collections (if you can’t treat a Collection as a more specific type), Lists, Sets, and Maps. This example shows the proper way to build read-only versions of each:</p>
<p>//: containers/ReadOnly.java</p>
<p>// Using the Collections.unmodifiable methods.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Readonly {</p>
<p>static Collection&lt;String&gt; data =</p>
<p>new ArrayList&lt;String&gt;(Countries.names(6)); public static void main(String[] args) {</p>
<p>Collection&lt;String&gt; c =</p>
<p>Collections.unmodifiableCollection( new ArrayList&lt;String&gt;(data)); print(c); // Reading is OK //! c.add(&quot;one&quot;); // Can’t change it</p>
<p>List&lt;String&gt; a = Collections.unmodifiableList(</p>
<p>new ArrayList&lt;String&gt;(data));</p>
<p>ListIterator&lt;String&gt; lit = a.listIterator(); print(lit.next()); // Reading is OK //! lit.add(&quot;one&quot;); // Can’t change it</p>
<p>Set&lt;String&gt; s = Collections.unmodifiableSet( new HashSet&lt;String&gt;(data)); print(s); // Reading is OK //! s.add(&quot;one&quot;); // Can’t change it</p>
<p>// For a SortedSet:</p>
<p>Set&lt;String&gt; ss = Collections.unmodifiableSortedSet( new TreeSet&lt;String&gt;(data));</p>
<p>Map&lt;String,String&gt; m = Collections.unmodifiableMap( new HashMap&lt;String,String&gt;(Countries.capitals(6))); print(m); // Reading is OK //! m.put(&quot;Ralph&quot;, &quot;Howdy!&quot;);</p>
<p>// For a SortedMap:</p>
<p>Map&lt;String,String&gt; sm =</p>
<p>Collections.unmodifiableSortedMap(</p>
<p>new TreeMap&lt;String,String&gt;(Countries.capitals(6)));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] ALGERIA</p>
<p>[BULGARIA, BURKINA FASO, BOTSWANA, BENIN, ANGOLA, ALGERIA] {BULGARIA=Sofia, BURKINA FASO=Ouagadougou, BOTSWANA=Gaberone, BENIN=Porto-Novo, ANGOLA=Luanda, ALGERIA=Algiers}</p>
<p>*///:~</p>
<p>Calling the &quot;unmodifiable&quot; method for a particular type does not cause compile-time checking, but once the transformation has occurred, any calls to methods that modify the contents of a particular container will produce an UnsupportedOperationException.</p>
<p>In each case, you must fill the container with meaningful data before you make it read-only. Once it is loaded, the best approach is to replace the existing reference with the reference that is produced by the &quot;unmodifiable&quot; call. That way, you don’t run the risk of accidentally trying to change the contents once you’ve made it unmodifiable. On the other hand, this tool also allows you to keep a modifiable container as private within a class and to return a read-only reference to that container from a method call. So, you can change it from within the class, but everyone else can only read it.</p>
<subtitle>Synchronizing a Collection or Map</subtitle>
<p>The synchronized keyword is an important part of the subject of multithreading, a more complicated topic that will not be introduced until the Concurrency chapter. Here, I shall note only that the Collections class contains a way to automatically synchronize an entire container. The syntax is similar to the &quot;unmodifiable&quot; methods:</p>
<p>//: containers/Synchronization.java</p>
<p>// Using the Collections.synchronized methods.</p>
<p>import java.util.*;</p>
<p>public class Synchronization {</p>
<p>public static void main(String[] args) {</p>
<p>Collection&lt;String&gt; c =</p>
<p>Collections.synchronizedCollection( new ArrayList&lt;String&gt;());</p>
<p>List&lt;String&gt; list = Collections.synchronizedList( new ArrayList&lt;String&gt;());</p>
<p>Set&lt;String&gt; s = Collections.synchronizedSet( new HashSet&lt;String&gt;());</p>
<p>Set&lt;String&gt; ss = Collections.synchronizedSortedSet( new TreeSet&lt;String&gt;());</p>
<p>Map&lt;String,String&gt; m = Collections.synchronizedMap( new HashMap&lt;String,String&gt;());</p>
<p>Map&lt;String,String&gt; sm =</p>
<p>Collections.synchronizedSortedMap( new TreeMap&lt;String,String&gt;());</p>
<p>}</p>
<p>} ///:~</p>
<p>It is best to immediately pass the new container through the appropriate &quot;synchronized&quot; method, as shown above. That way, there’s no chance of accidentally exposing the unsynchronized version.</p>
<p>Fail fast</p>
<p>The Java containers also have a mechanism to prevent more than one process from modifying the contents of a container. The problem occurs if you’re in the middle of iterating through a container, and then some other process steps in and inserts, removes, or changes an object in that container. Maybe you’ve already passed that element in the container, maybe it’s ahead of you, maybe the size of the container shrinks after you call size( )—there are many scenarios for disaster. The Java containers library uses a fail-fast mechanism that looks for any changes to the container other than the ones your process is personally responsible for. If it detects that someone else is modifying the container, it immediately produces a ConcurrentModification- Exception. This is the &quot;fail-fast&quot; aspect—it doesn’t try to detect a problem later on using a more complex algorithm.</p>
<p>It’s quite easy to see the fail-fast mechanism in operation—all you must do is create an iterator and then add something to the collection that the iterator is pointing to, like this:</p>
<p>//: containers/FailFast.java // Demonstrates the &quot;fail-fast&quot; behavior. import java.util.*;</p>
<p>public class FailFast {</p>
<p>public static void main(String[] args) {</p>
<p>Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();</p>
<p>Iterator&lt;String&gt; it = c.iterator(); c.add(&quot;An object&quot;); try {</p>
<p>String s = it.next();</p>
<p>} catch(ConcurrentModificationException e) {</p>
<p>System.out.println(e);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>java.util.ConcurrentModificationException</p>
<p>*///:~</p>
<p>The exception happens because something is placed in the container after the iterator is acquired from the container. The possibility that two parts of the program might modify the same container produces an uncertain state, so the exception notifies you that you should change your code—in this case, acquire the iterator after you have added all the elements to the container.</p>
<p>The ConcurrentHashMap, CopyOnWriteArrayList, and CopyOnWriteArraySet use techniques that avoid ConcurrentModificationExceptions.</p>
</section>
<section>
<title>
<p>Holding references</p></title><empty-line/>
<p>The java.lang.ref library contains a set of classes that allow greater flexibility in garbage collection. These classes are especially useful when you have large objects that may cause memory exhaustion. There are three classes inherited from the abstract class Reference: SoftReference, WeakReference, and PhantomReference. Each of these provides a different level of indirection for the garbage collector if the object in question is only reachable through one of these Reference objects.</p>
<p>If an object is reachable, it means that somewhere in your program the object can be found. This could mean that you have an ordinary reference on the stack that goes right to the object, but you might also have a reference to an object that has a reference to the object in question; there can be many intermediate links. If an object is reachable, the garbage collector cannot release it because it’s still in use by your program. If an object isn’t reachable, there’s no way for your program to use it, so it’s safe to garbage collect that object.</p>
<p>You use Reference objects when you want to continue to hold on to a reference to that object—you want to reach that object—but you also want to allow the garbage collector to release that object. Thus, you have a way to use the object, but if memory exhaustion is imminent, you allow that object to be released.</p>
<p>You accomplish this by using a Reference object as an intermediary (a proxy) between you and the ordinary reference. In addition, there must be no ordinary references to the object (ones that are not wrapped inside Reference objects). If the garbage collector discovers that an object is reachable through an ordinary reference, it will not release that object.</p>
<p>In the order of SoftReference, WeakReference, and PhantomReference, each one is &quot;weaker&quot; than the last and corresponds to a different level of reachability. Soft references are for implementing memory-sensitive caches. Weak references are for implementing &quot;canonicalizing mappings&quot;—where instances of objects can be simultaneously used in multiple places in a program, to save storage—that do not prevent their keys (or values) from being reclaimed. Phantom references are for scheduling pre-mortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism.</p>
<p>With SoftReferences and WeakReferences, you have a choice about whether to place them on a ReferenceQueue (the device used for premortem cleanup actions), but a PhantomReference can only be built on a ReferenceQueue. Here’s a simple demonstration:</p>
<p>//: containers/References.java // Demonstrates Reference objects import java.lang.ref.*; import java.util.*;</p>
<p>class VeryBig {</p>
<p>private static final int SIZE = 10000; private long[] la = new long[SIZE]; private String ident;</p>
<p>public VeryBig(String id) { ident = id; } public String toString() { return ident; } protected void finalize() {</p>
<p>System.out.println(&quot;Finalizing &quot; + ident);</p>
<p>}</p>
<p>} public class References {</p>
<p>private static ReferenceQueue&lt;VeryBig&gt; rq = new ReferenceQueue&lt;VeryBig&gt;(); public static void checkQueue() {</p>
<p>Reference&lt;? extends VeryBig&gt; inq = rq.poll(); if(inq != null)</p>
<p>System.out.println(&quot;In queue: &quot; + inq.get());</p>
<p>}</p>
<p>public static void main(String[] args) { int size = 10;</p>
<p>// Or, choose size via the command line: if(args.length &gt; 0)</p>
<p>size = new Integer(args[0]);</p>
<p>LinkedList&lt;SoftReference&lt;VeryBig&gt;&gt; sa = new LinkedList&lt;SoftReference&lt;VeryBig&gt;&gt;(); for(int i = 0; i &lt; size; i++) {</p>
<p>sa.add(new SoftReference&lt;VeryBig&gt;( new VeryBig(&quot;Soft &quot; + i), rq));</p>
<p>System.out.println(&quot;Just created: &quot; + sa.getLast()); checkQueue();</p>
<p>}</p>
<p>LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; wa = new LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt;(); for(int i = 0; i &lt; size; i++) { wa.add(new WeakReference&lt;VeryBig&gt;( new VeryBig(&quot;Weak &quot; + i), rq));</p>
<p>System.out.println(&quot;Just created: &quot; + wa.getLast()); checkQueue();</p>
<p>}</p>
<p>SoftReference&lt;VeryBig&gt; s =</p>
<p>new SoftReference&lt;VeryBig&gt;(new VeryBig(&quot;Soft&quot;)); WeakReference&lt;VeryBig&gt; w =</p>
<p>new WeakReference&lt;VeryBig&gt;(new VeryBig(&quot;Weak&quot;));</p>
<p>System.gc();</p>
<p>LinkedList&lt;PhantomReference&lt;VeryBig&gt;&gt; pa = new LinkedList&lt;PhantomReference&lt;VeryBig&gt;&gt;(); for(int i = 0; i &lt; size; i++) {</p>
<p>pa.add(new PhantomReference&lt;VeryBig&gt;( new VeryBig(&quot;Phantom &quot; + i), rq));</p>
<p>System.out.println(&quot;Just created: &quot; + pa.getLast()); checkQueue();</p>
<p>}</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>When you run this program (you’ll want to redirect the output into a text file so that you can view the output in pages), you’ll see that the objects are garbage collected, even though you still have access to them through the Reference object (to get the actual object reference, you use get( )). You’ll also see that the ReferenceQueue always produces a Reference containing a null object. To use this, inherit from a particular Reference class and add more useful methods to the new class.</p>
<subtitle>The WeakHashMap</subtitle>
<p>The containers library has a special Map to hold weak references: the WeakHashMap.</p>
<p>This class is designed to make the creation of canonicalized mappings easier. In such a mapping, you are saving storage by creating only one instance of a particular value. When the program needs that value, it looks up the existing object in the mapping and uses that (rather than creating one from scratch). The mapping may make the values as part of its initialization, but it’s more likely that the values are made on demand.</p>
<p>Since this is a storage-saving technique, it’s very convenient that the WeakHashMap allows the garbage collector to automatically clean up the keys and values. You don’t have to do anything special to the keys and values you want to place in the WeakHashMap; these are automatically wrapped in WeakReferences by the map. The trigger to allow cleanup is that the key is no longer in use, as demonstrated here:</p>
<p>//: containers/CanonicalMapping.java // Demonstrates WeakHashMap. import java.util.*;</p>
<p>class Element {</p>
<p>private String ident;</p>
<p>public Element(String id) { ident = id; } public String toString() { return ident; } public int hashCode() { return ident.hashCode(); } public boolean equals(Object r) { return r instanceof Element &amp;&amp; ident.equals(((Element)r).ident);</p>
<p>}</p>
<p>protected void finalize() {</p>
<p>System.out.println(&quot;Finalizing &quot; +</p>
<p>getClass().getSimpleName() + &quot; &quot; + ident);</p>
<p>}</p>
<p>}</p>
<p>class Key extends Element {</p>
<p>public Key(String id) { super(id); }</p>
<p>}</p>
<p>class Value extends Element {</p>
<p>public Value(String id) { super(id); }</p>
<p>}</p>
<p>public class CanonicalMapping {</p>
<p>public static void main(String[] args) { int size = 1000;</p>
<p>// Or, choose size via the command line: if(args.length &gt; 0)</p>
<p>size = new Integer(args[0]);</p>
<p>Key[] keys = new Key[size];</p>
<p>WeakHashMap&lt;Key,Value&gt; map = new WeakHashMap&lt;Key,Value&gt;(); for(int i = 0; i &lt; size; i++) {</p>
<p>Key k = new Key(Integer.toString(i));</p>
<p>Value v = new Value(Integer.toString(i)); if(i % 3 == 0)</p>
<p>keys[i] = k; // Save as &quot;real&quot; references map.put(k, v);</p>
<p>}</p>
<p>System.gc();</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>The Key class must have a hashCode( ) and an equals( ) since it is being used as a key in a hashed data structure. The subject of hashCode( ) was described earlier in this chapter.</p>
<p>When you run the program, you’ll see that the garbage collector will skip every third key, because an ordinary reference to that key has also been placed in the keys array, and thus those objects cannot be garbage collected.</p>
</section>
<section>
<title>
<p>Java 1.0/1.1 containers</p></title><empty-line/>
<p>Unfortunately, a lot of code was written using the Java 1.0/1.1 containers, and even new code is sometimes written using these classes. So although you should never use the old containers when writing new code, you’ll still need to be aware of them. However, the old containers were quite limited, so there’s not that much to say about them, and since they are anachronistic, I will try to refrain from overemphasizing some of their hideous design decisions.</p>
<subtitle>Vector &amp; Enumeration</subtitle>
<p>The only self-expanding sequence in Java 1.0/1.1 was the Vector, so it saw a lot of use. Its flaws are too numerous to describe here (see the 1st edition of this book, available as a free download from <a l:href="http://www.MindView.net">www.MindView.net</a>). Basically, you can think of it as an ArrayList with long, awkward method names. In the revised Java container library, Vector was adapted so that it could work as a Collection and a List. This turns out to be a bit perverse, as it may confuse some people into thinking that Vector has gotten better, when it is actually included only to support older Java code.</p>
<p>The Java 1.0/1.1 version of the iterator chose to invent a new name, &quot;enumeration,&quot; instead of using a term that everyone was already familiar with (&quot;iterator&quot;). The Enumeration interface is smaller than Iterator, with only two methods, and it uses longer method names: boolean hasMoreElements( ) produces true if this enumeration contains more elements, and Object nextElement( ) returns the next element of this enumeration if there are any more (otherwise it throws an exception).</p>
<p>Enumeration is only an interface, not an implementation, and even new libraries sometimes still use the old Enumeration, which is unfortunate but generally harmless.</p>
<p>Even though you should always use Iterator when you can in your own code, you must be prepared for libraries that want to hand you an Enumeration.</p>
<p>In addition, you can produce an Enumeration for any Collection by using the Collections.enumeration( ) method, as seen in this example:</p>
<p>//: containers/Enumerations.java // Java 1.0/1.1 Vector and Enumeration. import java.util.*; import net.mindview.util.*;</p>
<p>public class Enumerations {</p>
<p>public static void main(String[] args) {</p>
<p>Vector&lt;String&gt; v =</p>
<p>new Vector&lt;String&gt;(Countries.names(10));</p>
<p>Enumeration&lt;String&gt; e = v.elements(); while(e.hasMoreElements())</p>
<p>System.out.print(e.nextElement() + &quot;, &quot;);</p>
<p>// Produce an Enumeration from a Collection: e = Collections.enumeration(new ArrayList&lt;String&gt;());</p>
<p>}</p>
<p>} /* Output:</p>
<p>ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO, BURUNDI, CAMEROON, CAPE VERDE, CENTRAL AFRICAN REPUBLIC,</p>
<p>*///:~</p>
<p>To produce an Enumeration, you call elements( ), then you can use it to perform a forward iteration.</p>
<p>The last line creates an ArrayList and uses enumeration( ) to adapt an Enumeration from the ArrayList Iterator. Thus, if you have old code that wants an Enumeration, you can still use the new containers.</p>
<p>Hashtable</p>
<p>As you’ve seen in the performance comparison in this chapter, the basic Hashtable is very similar to the HashMap, even down to the method names. There’s no reason to use Hashtable instead of HashMap in new code.</p>
<p>Stack</p>
<p>The concept of the stack was introduced earlier, with the LinkedList. What’s rather odd about the Java 1.0/1.1 Stack is that instead of using a Vector with composition, Stack is inherited from Vector. So it has all of the characteristics and behaviors of a Vector plus some extra Stack behaviors. It’s difficult to know whether the designers consciously thought that this was an especially useful way of doing things, or whether it was just a naive design; in any event it was clearly not reviewed before it was rushed into distribution, so this bad design is still hanging around (but you shouldn’t use it).</p>
<p>Here’s a simple demonstration of Stack that pushes each String representation of an enum. It also shows how you can just as easily use a LinkedList as a stack, or the Stack class created in the Holding Your Objects chapter:</p>
<p>//: containers/Stacks.java // Demonstration of Stack Class. import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>enum Month { JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE,</p>
<p>JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER }</p>
<p>public class Stacks {</p>
<p>public static void main(String[] args) {</p>
<p>Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); for(Month m : Month.values()) stack.push(m.toString()); print(&quot;stack = &quot; + stack);</p>
<p>// Treating a stack as a Vector: stack.addElement(&quot;The last line&quot;); print(&quot;element 5 = &quot; + stack.elementAt(5)); print(&quot;popping elements:&quot;); while(!stack.empty())</p>
<p>printnb(stack.pop() + &quot; &quot;);</p>
<p>// Using a LinkedList as a Stack:</p>
<p>LinkedList&lt;String&gt; lstack = new LinkedList&lt;String&gt;(); for(Month m : Month.values()) lstack.addFirst(m.toString()); print(&quot;lstack = &quot; + lstack); while(!lstack.isEmpty())</p>
<p>printnb(lstack.removeFirst() + &quot; &quot;);</p>
<p>// Using the Stack class from // the Holding Your Objects Chapter: net.mindview.util.Stack&lt;String&gt; stack2 = new net.mindview.util.Stack&lt;String&gt;(); for(Month m : Month.values()) stack2.push(m.toString());</p>
<p>print(&quot;stack2 = &quot; + stack2); while(!stack2.emptyQ)</p>
<p>);</p>
<p>printnb(stack2.pop() + &quot; &quot;</p>
<p>}</p>
<p>} /* Output:</p>
<p>stack = [JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER] element 5 = JUNE popping elements:</p>
<p>The last line NOVEMBER OCTOBER SEPTEMBER AUGUST JULY JUNE MAY APRIL MARCH FEBRUARY JANUARY lstack = [NOVEMBER, OCTOBER, SEPTEMBER, AUGUST, JULY, JUNE, MAY, APRIL, MARCH, FEBRUARY, JANUARY]</p>
<p>NOVEMBER OCTOBER SEPTEMBER AUGUST JULY JUNE MAY APRIL MARCH FEBRUARY JANUARY stack2 = [NOVEMBER, OCTOBER, SEPTEMBER, AUGUST, JULY, JUNE, MAY, APRIL, MARCH, FEBRUARY, JANUARY]</p>
<p>NOVEMBER OCTOBER SEPTEMBER AUGUST JULY JUNE MAY APRIL MARCH FEBRUARY JANUARY *///:~</p>
<p>A String representation is generated from the Month enum constants, inserted into the Stack with push( ), and later fetched from the top of the stack with a pop( ). To make a point, Vector operations are also performed on the Stack object. This is possible because, by virtue of inheritance, a Stack is a Vector. Thus, all operations that can be performed on a Vector can also be performed on a Stack, such as elementAt( ).</p>
<p>As mentioned earlier, you should use a LinkedList when you want stack behavior, or the net.mindview.util.Stack class created from the LinkedList class.</p>
<subtitle>BitSet</subtitle>
<p>A BitSet is used if you want to efficiently store a lot of on-off information. It’s efficient only from the standpoint of size; if you’re looking for efficient access, it is slightly slower than using a native array.</p>
<p>In addition, the minimum size of the BitSet is that of a long: 64 bits. This implies that if you’re storing anything smaller, like 8 bits, a BitSet will be wasteful; you’re better off creating your own class, or just an array, to hold your flags if size is an issue. (This will only be the case if you’re creating a lot of objects containing lists of on-off information, and should only be decided based on profiling and other metrics. If you make this decision because you just think something is too big, you will end up creating needless complexity and wasting a lot of time.)</p>
<p>A normal container expands as you add more elements, and the BitSet does this as well. The following example shows how the BitSet works:</p>
<p>//: containers/Bits.java // Demonstration of BitSet. import java.util.*;</p>
<p>import static net.mindview.util.Print.*; public class Bits {</p>
<p>public static void printBitSet(BitSet b) { print(&quot;bits: &quot; + b);</p>
<p>StringBuilder bbits = new StringBuilder(); for(int j = 0; j &lt; b.size() ; j++) bbits.append(b.get(j) ? &quot;1&quot; : &quot;0&quot;); print(&quot;bit pattern: &quot; + bbits);</p>
<p>}</p>
<p>public static void main(String[] args) { Random rand = new Random(47);</p>
<p>// Take the LSB of nextInt(): byte bt = (byte)rand.nextInt();</p>
<p>BitSet bb = new BitSet(); for(int i = 7; i &gt;= 0; i--) if(((1 &lt;&lt; i) &amp; bt) != 0) bb.set(i); else</p>
<p>bb.clear(i);</p>
<p>print(&quot;byte value: &quot; + bt); printBitSet(bb);</p>
<p>short st = (short)rand.nextInt(); BitSet bs = new BitSet(); for(int i = 15; i &gt;= 0; i--) if(((1 &lt;&lt; i) &amp; st) != 0) bs.set(i); else</p>
<p>bs.clear(i);</p>
<p>print(&quot;short value: &quot; + st); printBitSet(bs);</p>
<p>int it = rand.nextInt();</p>
<p>BitSet bi = new BitSet(); for(int i = 31; i &gt;= 0; i--) if(((1 &lt;&lt; i) &amp; it) != 0) bi.set(i); else</p>
<p>bi.clear(i);</p>
<p>print(&quot;int value: &quot; + it); printBitSet(bi);</p>
<p>// Test bitsets &gt;= 64 bits: BitSet b127 = new BitSet(); b127.set(127);</p>
<p>print(&quot;set bit 127: &quot; + b127); BitSet b255 = new BitSet(65); b255.set(255);</p>
<p>print(&quot;set bit 255: &quot; + b255);</p>
<p>BitSet b1023 = new BitSet(512);</p>
<p>b1023.set(1023);</p>
<p>b1023.set(1024);</p>
<p>print(&quot;set bit 1023: &quot; + b1023)</p>
<p>}</p>
<p>} /* Output: byte value: -107 bits: {0, 2, 4, 7} bit pattern:</p>
<p>1010100100000000000000000000000000000000000000000000000000000000 short value: 1302 bits: {1, 2, 4, 8, 10} bit pattern:</p>
<p>0110100010100000000000000000000000000000000000000000000000000000 int value: -2014573909</p>
<p>bits: {0, 1, 3, 5, 7, 9, 11, 18, 19, 21, 22, 23, 24, 25, 26, 31} bit pattern:</p>
<p>1101010101010000001101111110000100000000000000000000000000000000</p>
<p>set bit 127: {127}</p>
<p>set bit 255: {255}</p>
<p>set bit 1023: {1023, 1024}</p>
<p>*///:~</p>
<p>The random number generator is used to create a random byte, short, and int, and each one is transformed into a corresponding bit pattern in a BitSet. This works fine because a BitSet is 64 bits, so none of these cause it to increase in size. Then larger BitSets are created. You can see that the BitSet is expanded as necessary.</p>
<p>An EnumSet (see the Enumerated Types chapter) is usually a better choice than a BitSet if you have a fixed set of flags that you can name, because the EnumSet allows you to manipulate the names rather than numerical bit locations, and thus reduces errors. EnumSet also prevents you from accidentally adding new flag locations, which could cause some serious, difficult-to-find bugs. The only reasons you should use BitSet instead of EnumSet is if you don’t know how many flags you will need until run time, or if it is unreasonable to assign names to the flags, or you need one of the special operations in BitSet (see the JDK documentation for BitSet and EnumSet).</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>The containers library is arguably the most important library for an objectoriented language. Most programming will use containers more than any other library components. Some languages (Python, for example) even include the fundamental container components (lists, maps and sets) as built-ins.</p>
<p>As you saw in the Holding Your Objects chapter, it’s possible to do a number of very interesting things using containers, without much effort. However, at some point you’re forced to know more about containers in order to use them properly—in particular, you must know enough about hashing operations to write your own hashCode( ) method (and you must know when it is necessary), and you must know enough about the various container implementations that you can choose the appropriate one for your needs. This chapter covered these concepts and discussed additional useful details about the container library. At this point you should be reasonably well prepared to use the Java containers in your everyday programming tasks.</p>
<p>The design of a containers library is difficult (this is true of most library design problems). In C++, the container classes covered the bases with many different classes. This was better than what was available prior to the C++ container classes (nothing), but it didn’t translate well into Java. At the other extreme, I’ve seen a containers library that consists of a single class, &quot;container,&quot; which acts like both a linear sequence and an associative array at the same time. The Java container library strikes a balance: the full functionality that you expect from a mature container library, but easier to learn and use than the C++ container classes and other similar container libraries. The result can seem a bit odd in places. Unlike some of the decisions made in the early Java libraries, these oddities were not accidents, but carefully considered decisions based on trade-offs in complexity.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>I/O</p></title><empty-line/>
<p>Creating a good input/output (I/O) system is one of the more difficult tasks for a language designer. This is evidenced by the number of different approaches.</p>
<p>The challenge seems to be in covering all possibilities. Not only are there different sources and sinks of I/O that you want to communicate with (files, the console, network connections, etc.), but you need to talk to them in a wide variety of ways (sequential, random-access, buffered, binary, character, by lines, by words, etc.). The Java library designers attacked this problem by creating lots of classes. In fact, there are so many classes for Java’s I/O system that it can be intimidating at first (ironically, the Java I/O design actually prevents an explosion of classes). There was also a significant change in the I/O library after Java i.o, when the original byte-oriented library was supplemented with char-oriented, Unicodebased I/O classes. The nio classes (for &quot;new I/O,&quot; a name we’ll still be using years from now even though they were introduced in JDK 1.4 and so are already &quot;old&quot;) were added for improved performance and functionality. As a result, there are a fair number of classes to learn before you understand enough of Java’s I/O picture that you can use it properly. In addition, it’s rather important to understand the evolution of the I/O library, even if your first reaction is &quot;Don’t bother me with history, just show me how to use it!&quot; The problem is that without the historical perspective, you will rapidly become confused with some of the classes and when you should and shouldn’t use them. This chapter will give you an introduction to the variety of I/O classes in the standard Java library and how to use them.</p>
<section>
<title>
<p>The File class</p></title><empty-line/>
<p>Before getting into the classes that actually read and write data to streams, we’ll look at a library utility that assists you with file directory issues. The File class has a deceiving name; you might think it refers to a file, but it doesn’t. In fact, &quot;FilePath&quot; would have been a better name for the class. It can represent either the name of a particular file or the names of a set of files in a directory. If it’s a set of files, you can ask for that set using the list( ) method, which returns an array of String. It makes sense to return an array rather than one of the flexible container classes, because the number of elements is fixed, and if you want a different directory listing, you just create a different File object. This section shows an example of the use of this class, including the associated FilenameFilter interface.</p>
<subtitle>A directory lister</subtitle>
<p>Suppose you’d like to see a directory listing. The File object can be used in two ways. If you call list( ) with no arguments, you’ll get the full list that the File object contains. However, if you want a restricted list—for example, if you want all of the files with an extension of .Java-then you use a &quot;directory filter,&quot; which is a class that tells how to select the File objects for display. Here’s the example. Note that the result has been effortlessly sorted (alphabetically) using the java.util.Arrays.sort( ) method and the String.CASE_INSENSITIVE_ORDER Comparator:</p>
<p>//: io/DirList.java</p>
<p>// Display a directory listing using regular expressions.</p>
<p>// {Args: &quot;D.*\.java&quot;} import java.util.regex.*; import java.io.*;</p>
<p>import java.util.*;</p>
<p>public class DirList {</p>
<p>public static void main(String[] args) {</p>
<p>File path = new File(&quot;.&quot;);</p>
<p>String[] list; if(args.length == 0) list = path.list(); else</p>
<p>list = path.list(new DirFilter(args[0])); Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); for(String dirltem : list) System.out.println(dirltem);</p>
<p>}</p>
<p>}</p>
<p>class DirFilter implements FilenameFilter { private Pattern pattern; public DirFilter(String regex) { pattern = Pattern.compile(regex);</p>
<p>}</p>
<p>public boolean accept(File dir, String name) { return pattern.matcher(name).matches();</p>
<p>}</p>
<p>} /* Output:</p>
<p>DirectoryDemo.java</p>
<p>DirList.java</p>
<p>DirList2.java</p>
<p>DirList3.java</p>
<p>*///:~</p>
<p>The DirFilter class implements the interface FilenameFilter. Notice how simple the FilenameFilter interface is:</p>
<p>public interface FilenameFilter {</p>
<p>boolean accept(File dir, String name);</p>
<p>}</p>
<p>DirFilter’s sole reason for existence is to provide the accept( ) method to the list( ) method so that list( ) can &quot;call back&quot; accept( ) to determine which file names should be included in the list. Thus, this structure is often referred to as a callback. More specifically, this is an example of the Strategy design pattern, because list( ) implements basic functionality, and you provide the Strategy in the form of a FilenameFilter in order to complete the algorithm necessary for list( ) to provide its service. Because list( ) takes a FilenameFilter object as its argument, it means that you can pass an object of any class that implements FilenameFilter to choose (even at run time) how the list( ) method will behave. The purpose of a Strategy is to provide flexibility in the behavior of code.</p>
<p>The accept( ) method must accept a File object representing the directory that a particular file is found in, and a String containing the name of that file. Remember that the list( ) method is calling accept( ) for each of the file names in the directory object to see which one should be included; this is indicated by the boolean result returned by accept( ).</p>
<p>accept( ) uses a regular expression matcher object to see if the regular expression regex matches the name of the file. Using accept( ), the list( ) method returns an array.</p>
<p>Anonymous inner classes</p>
<p>This example is ideal for rewriting using an anonymous inner class (described in Inner Classes). As a first cut, a method filter( ) is created that returns a reference to a FilenameFilter:</p>
<p>//: io/DirList2.java</p>
<p>// Uses anonymous inner classes.</p>
<p>// {Args: &quot;D.*\.java&quot;} import java.util.regex.*; import java.io.*; import java.util.*;</p>
<p>public class DirList2 {</p>
<p>public static FilenameFilter filter(final String regex) {</p>
<p>// Creation of anonymous inner class: return new FilenameFilter() {</p>
<p>private Pattern pattern = Pattern.compile(regex); public boolean accept(File dir, String name) { return pattern.matcher(name).matches();</p>
<p>}</p>
<p>}; // End of anonymous inner class</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>File path = new File(&quot;.&quot;);</p>
<p>String[] list; if(args.length == 0) list = path.list(); else</p>
<p>list = path.list(filter(args[0]));</p>
<p>Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); for(String dirltem : list)</p>
<p>System.out.println(dirltem);</p>
<p>}</p>
<p>} /* Output:</p>
<p>DirectoryDemo.java</p>
<p>DirList.java</p>
<p>DirList2.java</p>
<p>DirList3.java</p>
<p>*///:~</p>
<p>Note that the argument to filter( ) must be final. This is required by the anonymous inner class so that it can use an object from outside its scope. This design is an improvement because the FilenameFilter class is now tightly bound to DirList2. However, you can take this approach one step further and define the anonymous inner class as an argument to list(), in which case it’s even smaller:</p>
<p>//: io/DirList3.java</p>
<p>// Building the anonymous inner class &quot;in-place.&quot;</p>
<p>// {Args: &quot;D.*\.java&quot;} import java.util.regex.*; import java.io.*; import java.util.*;</p>
<p>public class DirList3 {</p>
<p>public static void main(final String[] args) {</p>
<p>File path = new File(&quot;.&quot;);</p>
<p>String[] list; if(args.length == 0) list = path.list(); else</p>
<p>list = path.list(new FilenameFilter() {</p>
<p>private Pattern pattern = Pattern.compile(args[0]); public boolean accept(File dir, String name) { return pattern.matcher(name).matches();</p>
<p>}</p>
<p>});</p>
<p>Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); for(String dirltem : list)</p>
<p>System.out.println(dirltem);</p>
<p>}</p>
<p>} /* Output:</p>
<p>DirectoryDemo.java</p>
<p>DirList.java</p>
<p>DirList2.java</p>
<p>DirList3.java</p>
<p>*///:~</p>
<p>The argument to main( ) is now final, since the anonymous inner class uses args[0] directly.</p>
<p>This shows you how anonymous inner classes allow the creation of specific, one-off classes to solve problems. One benefit of this approach is that it keeps the code that solves a particular problem isolated in one spot. On the other hand, it is not always as easy to read, so you must use it judiciously.</p>
<p>Exercise 1: (3) Modify DirList.java (or one of its variants) so that the FilenameFilter opens and reads each file (using the net.mindview.util.TextFile utility) and accepts the file based on whether any of the trailing arguments on the command line exist in that file.</p>
<p>Exercise 2: (2) Create a class called SortedDirList with a constructor that takes a File object and builds a sorted directory list from the files at that File. Add to this class two overloaded list( ) methods: the first produces the whole list, and the second produces the subset of the list that matches its argument (which is a regular expression).</p>
<p>Exercise 3: (3) Modify DirList.java (or one of its variants) so that it sums up the file sizes of the selected files.</p>
<subtitle>Directory utilities</subtitle>
<p>A common task in programming is to perform operations on sets of files, either in the local directory or by walking the entire directory tree. It is useful to have a tool that will produce the set of files for you. The following utility class produces either an array of File objects in the local directory using the local( ) method, or a List&lt;File&gt; of the entire directory tree starting at the given directory using walk( ) (File objects are more useful than file names because File objects contain more information). The files are chosen based on the regular expression that you provide:</p>
<p>//: net/mindview/util/Directory.java</p>
<p>// Produce a sequence of File objects that match a</p>
<p>// regular expression in either a local directory,</p>
<p>// or by walking a directory tree. package net.mindview.util; import java.util.regex.*; import java.io.*; import java.util.*;</p>
<p>public final class Directory { public static File[]</p>
<p>local(File dir, final String regex) {</p>
<p>return dir.listFiles(new FilenameFilter() {</p>
<p>private Pattern pattern = Pattern.compile(regex); public boolean accept(File dir, String name) { return pattern.matcher(</p>
<p>new File(name).getName()).matches();</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>public static File[]</p>
<p>local(String path, final String regex) { // Overloaded return local(new File(path), regex);</p>
<p>}</p>
<p>// A two-tuple for returning a pair of objects: public static class TreeInfo implements Iterable&lt;File&gt; { public List&lt;File&gt; files = new ArrayList&lt;File&gt;(); public List&lt;File&gt; dirs = new ArrayList&lt;File&gt;();</p>
<p>// The default iterable element is the file list: public Iterator&lt;File&gt; iterator() { return files.iterator();</p>
<p>}</p>
<p>void addAll(TreeInfo other) { files.addAll(other.files); dirs.addAll(other.dirs);</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;dirs: &quot; + PPrint.pformat(dirs) +</p>
<p>&quot;\n\nfiles: &quot; + PPrint.pformat(files);</p>
<p>}</p>
<p>}</p>
<p>public static TreeInfo</p>
<p>walk(String start, String regex) { // Begin recursion return recurseDirs(new File(start), regex);</p>
<p>}</p>
<p>public static TreeInfo</p>
<p>walk(File start, String regex) { // Overloaded return recurseDirs(start, regex);</p>
<p>}</p>
<p>public static TreeInfo walk(File start) { // Everything return recurseDirs(start, &quot;.*&quot;);</p>
<p>}</p>
<p>public static TreeInfo walk(String start) { return recurseDirs(new File(start), &quot;.*&quot;);</p>
<p>}</p>
<p>static TreeInfo recurseDirs(File startDir, String regex){ TreeInfo result = new TreeInfo(); for(File item : startDir.listFiles()) { if(item.isDirectory()) { result.dirs.add(item);</p>
<p>result.addAll(recurseDirs(item, regex));</p>
<p>} else // Regular file</p>
<p>if(item.getName().matches(regex))</p>
<p>result.files.add(item);</p>
<p>}</p>
<p>return result;</p>
<p>}</p>
<p>// Simple validation test: public static void main(String[] args) { if(args.length == 0)</p>
<p>System.out.println(walk(&quot;.&quot;));</p>
<p>else</p>
<p>for(String arg : args)</p>
<p>System.out.println(walk(arg));</p>
<p>} ///:~</p>
<p>The local( ) method uses a variant of File.list( ) called listFiles( ) that produces an array of File. You can see that it also uses a FilenameFilter. If you need a List instead of an array, you can convert the result yourself using Arrays.asList( ).</p>
<p>The walk( ) method converts the name of the starting directory into a File object and calls recurseDirs( ), which performs a recursive directory walk, collecting more information with each recursion. To distinguish ordinary files from directories, the return value is effectively a &quot;tuple&quot; of objects—a List holding ordinary files, and another holding directories. The fields are intentionally made public here, because the point of Treelnfo is simply to collect the objects together—if you were just returning a List, you wouldn’t make it private, so just because you are returning a pair of objects, it doesn’t mean you need to make them private. Note that Treelnfo implements Iterable&lt;File&gt;, which produces the files, so that you have a &quot;default iteration&quot; over the file list, whereas you can specify directories by saying &quot;.dirs&quot;.</p>
<p>The Treelnfo.toString( ) method uses a &quot;pretty printer&quot; class so that the output is easer to view. The default toString( ) methods for containers print all the elements for a container on a single line. For large collections this can become difficult to read, so you may want to use an alternate formatting. Here’s a tool that adds newlines and indents each element:</p>
<p>//: net/mindview/util/PPrint.java // Pretty-printer for collections package net.mindview.util; import java.util.*;</p>
<p>public class PPrint {</p>
<p>public static String pformat(Collection&lt;?&gt; c) { if(c.size() == 0) return &quot;[]&quot;;</p>
<p>StringBuilder result = new StringBuilder(&quot;[&quot;); for(Object elem : c) { if(c.size() != 1)</p>
<p>result.append(&quot;\n &quot;); result.append(elem);</p>
<p>}</p>
<p>if(c.size() != 1) result.append(&quot;\n&quot;); result.append(&quot;]&quot;); return result.toString();</p>
<p>}</p>
<p>public static void pprint(Collection&lt;?&gt; c) { System.out.println(pformat(c));</p>
<p>}</p>
<p>public static void pprint(Object[] c) {</p>
<p>System.out.println(pformat(Arrays.asList(c)));</p>
<p>}</p>
<p>} ///:~</p>
<p>The pformat( ) method produces a formatted String from a Collection, and the pprint( ) method uses pformat( ) to do its job. Note that the special cases of no elements and a single element are handled differently. There’s also a version of pprint( ) for arrays.</p>
<p>The Directory utility is placed in the net.mindview.util package so that it is easily available. Here’s a sample of how you can use it:</p>
<p>//: io/DirectoryDemo.java</p>
<p>// Sample use of Directory utilities.</p>
<p>import java.io.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class DirectoryDemo {</p>
<p>public static void main(String[] args) {</p>
<p>// All directories:</p>
<p>PPrint.pprint(Directory.walk(&quot;.&quot;).dirs);</p>
<p>// All files beginning with ‘T’ for(File file : Directory.local(&quot;.&quot;, &quot;T.*&quot;)) print(file);</p>
<p>print(&quot;----------------------&quot;);</p>
<p>// All Java files beginning with ‘T’: for(File file : Directory.walk(&quot;.&quot;, &quot;T.*\\.java&quot;)) print(file);</p>
<p>print(&quot;======================&quot;);</p>
<p>// Class files containing &quot;Z&quot; or &quot;z&quot;: for(File file : Directory.walk(&quot;.&quot;,&quot;.*[Zz].*\\.class&quot;)) print(file);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>[.\xfiles]</p>
<p>.\TestEOF.class</p>
<p>.\TestEOF.java</p>
<p>.\TransferTo.class</p>
<p>.\TransferTo.java .\TestEOF.java</p>
<p>.\TransferTo.java</p>
<p>.\xfiles\ThawAlien.java .\FreezeAlien.class</p>
<p>.\GZIPcompress.class</p>
<p>.\ZipCompress.class</p>
<p>*///:~</p>
<p>You may need to refresh your knowledge of regular expressions from the Strings chapter in order to understand the second arguments in local( ) and walk( ).</p>
<p>We can take this a step further and create a tool that will walk directories and process the files within them according to a Strategy object (this is another example of the Strategy design pattern):</p>
<p>//: net/mindview/util/ProcessFiles.java package net.mindview.util; import java.io.*;</p>
<p>public class ProcessFiles { public interface Strategy { void process(File file);</p>
<p>}</p>
<p>private Strategy strategy; private String ext;</p>
<p>public ProcessFiles(Strategy strategy, String ext) { this.strategy = strategy; this.ext = ext;</p>
<p>}</p>
<p>public void start(String[] args) { try {</p>
<p>if(args.length == 0)</p>
<p>processDirectoryTree(new File(&quot;.&quot;)); else</p>
<p>for(String arg : args) {</p>
<p>File fileArg = new File(arg); if(fileArg.isDirectory())</p>
<p>processDirectoryTree(fileArg); else {</p>
<p>// Allow user to leave off extension: if(!arg.endsWith(&quot;.&quot; + ext)) arg += &quot;.&quot; + ext; strategy.process(</p>
<p>new File(arg).getCanonicalFile());</p>
<p>}</p>
<p>}</p>
<p>} catch(IOException e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>public void</p>
<p>processDirectoryTree(File root) throws IOException { for(File file : Directory.walk(</p>
<p>root.getAbsolutePath(), &quot;.*\\.&quot; + ext)) strategy.process(file.getCanonicalFile());</p>
<p>}</p>
<p>// Demonstration of how to use it: public static void main(String[] args) {</p>
<p>new ProcessFiles(new ProcessFiles.Strategy() { public void process(File file) {</p>
<p>System.out.println(file);</p>
<p>}</p>
<p>}, &quot;java&quot;).start(args);</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>The Strategy interface is nested within ProcessFiles, so that if you want to implement it you must implement ProcessFiles.Strategy, which provides more context for the reader. ProcessFiles does all the work of finding the files that have a particular extension (the ext argument to the constructor), and when it finds a matching file, it simply hands it to the Strategy object (which is also an argument to the constructor).</p>
<p>If you don’t give it any arguments, ProcessFiles assumes that you want to traverse all the directories off of the current directory. You can also specify a particular file, with or without the extension (it will add the extension if necessary), or one or more directories.</p>
<p>In main( ) you see a basic example of how to use the tool; it prints the names of all the Java source files according to the command line that you provide.</p>
<p>Exercise 4: (2) Use Directory.walk( ) to sum the sizes of all files in a directory tree whose names match a particular regular expression.</p>
<p>Exercise 5: (1) Modify ProcessFiles.java so that it matches a regular expression rather than a fixed extension.</p>
<subtitle>Checking for and creating directories</subtitle>
<p>The File class is more than just a representation for an existing file or directory. You can also use a File object to create a new directory or an entire directory path if it doesn’t exist. You can also look at the characteristics of files (size, last modification date, read/write), see whether a File object represents a file or a directory, and delete a file. The following example shows some of the other methods available with the File class (see the JDK documentation from <a l:href="http://java.sun.com">http://java.sun.com</a> for the full set): //: io/MakeDirectories.java</p>
<p>// Demonstrates the use of the File class to</p>
<p>// create directories and manipulate files.</p>
<p>// {Args: MakeDirectoriesTest} import java.io.*;</p>
<p>public class MakeDirectories { private static void usage() { System.err.println(</p>
<p>&quot;Usage:MakeDirectories pathl ...\n&quot; + &quot;Creates each path\n&quot; + &quot;Usage:MakeDirectories -d pathl ...\n&quot; + &quot;Deletes each path\n&quot; +</p>
<p>&quot;Usage:MakeDirectories -r pathl path2\n&quot; + &quot;Renames from pathl to path2&quot;); System.exit(l);</p>
<p>}</p>
<p>private static void fileData(File f) { System.out.println(</p>
<p>&quot;Absolute path: &quot; + f.getAbsolutePath() + &quot;\n Can read: &quot; + f.canRead() +</p>
<p>&quot;\n Can write: &quot; + f.canWrite() +</p>
<p>&quot;\n getName: &quot; + f.getName() +</p>
<p>&quot;\n getParent: &quot; + f.getParent() +</p>
<p>&quot;\n getPath: &quot; + f.getPath() +</p>
<p>&quot;\n length: &quot; + f.length() +</p>
<p>&quot;\n lastModified: &quot; + f.lastModified()); if(f.isFile())</p>
<p>System.out.println(&quot;It’s a file&quot;); else if(f.isDirectory())</p>
<p>System.out.println(&quot;It’s a directory&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { if(args.length &lt; l) usage(); if(args[0].equals(&quot;-r&quot;)) { if(args.length != 3) usage();</p>
<p>File</p>
<p>old = new File(args[l]), rname = new File(args[2]); old.renameTo(rname); fileData(old); fileData(rname); return; // Exit main</p>
<p>}</p>
<p>int count = 0; boolean del = false; if(args[0].equals(&quot;-d&quot;)) { count++; del = true;</p>
<p>}</p>
<p>count--;</p>
<p>while(++count &lt; args.length) {</p>
<p>File f = new File(args[count]); if(f.exists()) {</p>
<p>System.out.println(f + &quot; exists&quot;); if(del) {</p>
<p>System.out.println(&quot;deleting...&quot; + f); f.delete();</p>
<p>}</p>
<p>}</p>
<p>else { // Doesn’t exist if(!del) { f.mkdirs();</p>
<p>System.out.println(&quot;created &quot; + f);</p>
<p>}</p>
<p>}</p>
<p>fileData(f);</p>
<p>}</p>
<p>}</p>
<p>} /* Output: (80% match) created MakeDirectoriesTest</p>
<p>Absolute path: d:\aaa-TIJ4\code\io\MakeDirectoriesTest Can read: true Can write: true getName: MakeDirectoriesTest getParent: null getPath: MakeDirectoriesTest length: 0</p>
<p>lastModified: 1101690308831 It’s a directory *///:~</p>
<p>In fileData( ) you can see various file investigation methods used to display information about the file or directory path.</p>
<p>The first method that’s exercised by main( ) is renameTo( ), which allows you to rename (or move) a file to an entirely new path represented by the argument, which is another File object. This also works with directories of any length.</p>
<p>If you experiment with the preceding program, you’ll find that you can make a directory path of any complexity, because mkdirs( ) will do all the work for you.</p>
<p>Exercise 6: (5) Use ProcessFiles to find all the Java source-code files in a particular directory subtree that have been modified after a particular date.</p>
</section>
<section>
<title>
<p>Input and output</p></title><empty-line/>
<p>Programming language I/O libraries often use the abstraction of a stream, which represents any data source or sink as an object capable of producing or receiving pieces of data. The stream hides the details of what happens to the data inside the actual I/O device.</p>
<p>The Java library classes for I/O are divided by input and output, as you can see by looking at the class hierarchy in the JDK documentation. Through inheritance, everything derived from the InputStream or Reader classes has basic methods called read( ) for reading a single byte or an array of bytes. Likewise, everything derived from OutputStream or Writer classes has basic methods called write( ) for writing a single byte or an array of bytes. However, you won’t generally use these methods; they exist so that other classes can use them—these other classes provide a more useful interface. Thus, you’ll rarely create your stream object by using a single class, but instead will layer multiple objects together to provide your desired functionality (this is the Decorator design pattern, as you shall see in this section). The fact that you create more than one object to produce a single stream is the primary reason that Java’s I/O library is confusing.</p>
<p>It’s helpful to categorize the classes by their functionality. In Java l.o, the library designers started by deciding that all classes that had anything to do with input would be inherited from InputStream, and all classes that were associated with output would be inherited from OutputStream.</p>
<p>As is the practice in this book, I will attempt to provide an overview of the classes, but assume that you will use the JDK documentation to determine all the details, such as the exhaustive list of methods of a particular class.</p>
<subtitle>Types of InputStream</subtitle>
<p>InputStream’s job is to represent classes that produce input from different sources. These sources can be:</p>
<p>1.    An array of bytes.</p>
<p>2.    A String obj ect.</p>
<p>3.    A file.</p>
<p>4.    A &quot;pipe,&quot; which works like a physical pipe: You put things in at one end and they come out the other.</p>
<p>5.    A sequence of other streams, so you can collect them together into a single stream.</p>
<p>6.    Other sources, such as an Internet connection. (This is covered in Thinking in Enterprise Java, available at <a l:href="http://www.MindView.net">www.MindView.net</a>.)</p>
<p>Each of these has an associated subclass of InputStream. In addition, the FilterInputStream is also a type of InputStream, to provide a base class for &quot;decorator&quot; classes that attach attributes or useful interfaces to input streams. This is discussed later.</p>
<p>Table I/O-1. Types of InputStream</p>
<table>
<tr><td rowspan="2">Class</td><td rowspan="2">Function</td><td>Constructor arguments</td></tr>
<tr><td>How to use it</td></tr>
<tr><td rowspan="2">ByteArray-InputStream</td><td rowspan="2">Allows a buffer in memory to be used as anInputStream.</td><td>The buffer from which to extract the bytes.</td></tr>
<tr><td>As a source of data: Connect it to a FilterlnputStreamobject to provide a useful interface.</td></tr>
<tr><td rowspan="2">StringBuffer-InputStream</td><td rowspan="2">Converts a String into anInputStream.</td><td>A String. The underlying implementation actually uses a StringBuffer.</td></tr>
<tr><td>As a source of data: Connect it to a FilterlnputStreamobject to provide a useful interface.</td></tr>
<tr><td rowspan="2">File-InputStream</td><td rowspan="2">For reading information from a file.</td><td>A String representing the file name, or a File or FileDescriptor object.</td></tr>
<tr><td>As a source of data: Connect it to a FilterlnputStreamobject to provide a useful interface.</td></tr>
</table>
<table>
<tr><td rowspan="2">Class</td><td rowspan="2">Function</td><td>Constructor arguments</td></tr>
<tr><td>How to use it</td></tr>
<tr><td rowspan="2">Piped-InputStream</td><td rowspan="2">Produces the data that’s being written to the associatedPipedOutput-Stream. Implements the &quot;piping&quot; concept.</td><td>PipedOutputStream</td></tr>
<tr><td>As a source of data in multithreading: Connect it to a FilterlnputStreamobject to provide a useful interface.</td></tr>
<tr><td rowspan="2">Sequence-InputStream</td><td rowspan="2">Converts two or moreInputStreamobjects into a single InputStream.</td><td>Two InputStream objects or an Enumeration for a container of InputStreamobjects.</td></tr>
<tr><td>As a source of data: Connect it to a FilterlnputStreamobject to provide a useful interface.</td></tr>
<tr><td rowspan="2">Filter-InputStream</td><td rowspan="2">Abstract class that is an interface for decorators that provide useful functionality to the otherInputStreamclasses. See Table I/O-3.</td><td>See Table I/O-3.</td></tr>
<tr><td>See Table I/O-3.</td></tr>
</table>
<subtitle>Types of OutputStream</subtitle>
<p>This category includes the classes that decide where your output will go: an array of bytes (but not a String—presumably, you can create one using the array of bytes), a file, or a</p>
<p>&quot;p<sup>i</sup>P<sup>e</sup>.&quot;</p>
<p>In addition, the FilterOutputStream provides a base class for &quot;decorator&quot; classes that attach attributes or useful interfaces to output streams. This is discussed later.</p>
<p>Table I/O-2. Types of OutputStream</p>
<table>
<tr><td rowspan="2">Class</td><td rowspan="2">Function</td><td>Constructor arguments</td></tr>
<tr><td>How to use it</td></tr>
<tr><td rowspan="2">ByteArray-OutputStream</td><td rowspan="2">Creates a buffer in memory. All the data that you send to the stream is placed in this buffer.</td><td>Optional initial size of the buffer.</td></tr>
<tr><td>To designate the destination of your data: Connect it to a FilterOutputStreamobject to provide a useful interface.</td></tr>
<tr><td>File-OutputStream</td><td>For sending information to a file.</td><td>A String representing the file name, or a File or FileDescriptor object.</td></tr>
</table>
<table>
<tr><td rowspan="2">Class</td><td rowspan="2">Function</td><td>Constructor arguments</td></tr>
<tr><td>How to use it</td></tr>
<tr><td></td><td></td><td>To designate the destination of your data: Connect it to a FilterOutputStreamobject to provide a useful interface.</td></tr>
<tr><td rowspan="2">Piped-OutputStream</td><td rowspan="2">Any information you write to this automatically ends up as input for the associatedPipedlnput-Stream. Implements the &quot;piping&quot; concept.</td><td>PipedlnputStream</td></tr>
<tr><td>To designate the destination of your data for multithreading: Connect it to a FilterOutputStreamobject to provide a useful interface.</td></tr>
<tr><td rowspan="2">FilterOutputStream</td><td rowspan="2">Abstract class that is an interface for decorators that provide useful functionality to the otherOutputStreamclasses. See Table1/O-4-</td><td>See Table I/O-4.</td></tr>
<tr><td>See Table I/O-4.</td></tr>
</table>
</section>
<section>
<title>
<p>Adding attributes</p></title><empty-line/>
</section>
<section>
<title>
<p>and useful interfaces</p></title><empty-line/>
<p>Decorators were introduced in the Generics chapter, on page 717. The Java I/O library requires many different combinations of features, and this is the justification for using the Decorator design pattern.<a l:href="#bookmark87" type="note"><sup>88</sup></a><sup></sup> The reason for the existence of the &quot;filter&quot; classes in the Java I/O library is that the abstract &quot;filter&quot; class is the base class for all the decorators. A decorator must have the same interface as the object it decorates, but the decorator can also extend the interface, which occurs in several of the &quot;filter&quot; classes.</p>
<p>There is a drawback to Decorator, however. Decorators give you much more flexibility while you’re writing a program (since you can easily mix and match attributes), but they add complexity to your code. The reason that the Java I/O library is awkward to use is that you must create many classes—the &quot;core&quot; I/O type plus all the decorators—in order to get the single I/O object that you want.</p>
<p>The classes that provide the decorator interface to control a particular InputStream or OutputStream are the FilterlnputStream and FilterOutputStream, which don’t have very intuitive names. FilterlnputStream and FilterOutputStream are derived from the base classes of the I/O library, InputStream and OutputStream, which is a key requirement of the decorator (so that it provides the common interface to all the objects that are being decorated).</p>
<p>Reading from an InputStream with FilterlnputStream</p>
<p>The FilterlnputStream classes accomplish two significantly different things. DatalnputStream allows you to read different types of primitive data as well as String objects. (All the methods start with &quot;read,&quot; such as readByte( ), readFloat( ), etc.) This, along with its companion DataOutputStream, allows you to move primitive data from one place to another via a stream. These &quot;places&quot; are determined by the classes in Table I/O-1.</p>
<p>The remaining FilterlnputStream classes modify the way an InputStream behaves internally: whether it’s buffered or unbuffered, whether it keeps track of the lines it’s reading (allowing you to ask for line numbers or set the line number), and whether you can push back a single character. The last two classes look a lot like support for building a compiler (they were probably added to support the experiment of &quot;building a Java compiler in Java&quot;), so you probably won’t use them in general programming.</p>
<p>You’ll need to buffer your input almost every time, regardless of the I/O device you’re connecting to, so it would have made more sense for the I/O library to have a special case (or simply a method call) for unbuffered input rather than buffered input.</p>
<p>Table I/O-3. Types of FilterlnputStream</p>
<table>
<tr><td rowspan="2">Class</td><td rowspan="2">Function</td><td>Constructorarguments</td></tr>
<tr><td>How to use it</td></tr>
<tr><td rowspan="2">Data-InputStream</td><td rowspan="2">Used in concert with DataOutputStream, soyou can read primitives (int, char, long, etc.) from a stream in a portable fashion.</td><td>InputStream</td></tr>
<tr><td>Contains a full interface to allow you to read primitive types.</td></tr>
<tr><td rowspan="2">Buffered-InputStream</td><td rowspan="2">Use this to prevent a physical read every time you want more data. You’re saying, &quot;Use a buffer.&quot;</td><td>InputStream, with optional buffer size.</td></tr>
<tr><td>This doesn’t provide an interface per se. It just adds buffering to the process. Attach an interface object.</td></tr>
<tr><td rowspan="2">LineNumber-InputStream</td><td rowspan="2">Keeps track of line numbers in the input stream; you can call getLineNumber( ) and setLineNumber (int).</td><td>InputStream</td></tr>
<tr><td>This just adds line numbering, so you’ll probably attach an interface object.</td></tr>
<tr><td rowspan="2">Pushback-InputStream</td><td rowspan="2">Has a one-byte pushback buffer so that you can push back the last character read.</td><td>InputStream</td></tr>
<tr><td>Generally used in the</td></tr>
</table>
<table>
<tr><td rowspan="2">Class</td><td rowspan="2">Function</td><td>Constructorarguments</td></tr>
<tr><td>How to use it</td></tr>
<tr><td></td><td></td><td>scanner for a compiler. You probably won’t use this.</td></tr>
</table>
<p>Writing to an OutputStream with FilterOutputStream</p>
<p>The complement to DatalnputStream is DataOutputStream, which formats each of the primitive types and String objects onto a stream in such a way that any DatalnputStream, on any machine, can read them. All the methods start with &quot;write,&quot; such as writeByte( ), writeFloat( ), etc.</p>
<p>The original intent of PrintStream was to print all of the primitive data types and String objects in a viewable format. This is different from DataOutputStream, whose goal is to put data elements on a stream in a way that DatalnputStream can portably reconstruct them.</p>
<p>The two important methods in PrintStream are print( ) and println( ), which are overloaded to print all the various types. The difference between print( ) and println( ) is that the latter adds a newline when it’s done.</p>
<p>PrintStream can be problematic because it traps all IOExceptions (you must explicitly test the error status with checkError( ), which returns true if an error has occurred). Also, PrintStream doesn’t internationalize properly and doesn’t handle line breaks in a platform-independent way. These problems are solved with PrintWriter, described later.</p>
<p>BufferedOutputStream is a modifier and tells the stream to use buffering so you don’t get a physical write every time you write to the stream. You’ll probably always want to use this when doing output.</p>
<p>Table I/O-4. Types of FilterOutputStream</p>
<table>
<tr><td rowspan="2">Class</td><td rowspan="2">Function</td><td>Constructorarguments</td></tr>
<tr><td>How to use it</td></tr>
<tr><td rowspan="2">Data-OutputStream</td><td rowspan="2">Used in concert with DataInputStream soyou can write primitives (int, char, long, etc.) to a stream in a portable fashion.</td><td>OutputStream</td></tr>
<tr><td>Contains a full interface to allow you to write primitive types.</td></tr>
<tr><td rowspan="2">PrintStream</td><td rowspan="2">For producing formatted output. While DataOutputStream handles the storage of data, PrintStream handles display.</td><td>OutputStream, with optional boolean indicating that the buffer is flushed with every newline.</td></tr>
<tr><td>Should be the &quot;final&quot;</td></tr>
</table>
<table>
<tr><td rowspan="2">Class</td><td rowspan="2">Function</td><td>Constructorarguments</td></tr>
<tr><td>How to use it</td></tr>
<tr><td></td><td></td><td>wrapping for your OutputStreamobject. You’ll probably use this a lot.</td></tr>
<tr><td rowspan="2">Buffered-OutputStream</td><td rowspan="2">Use this to prevent a physical write every time you send a piece of data. You’re saying, &quot;Use a buffer.&quot; You can call flush( ) to flush the buffer.</td><td>OutputStream, with optional buffer size.</td></tr>
<tr><td>This doesn’t provide an interface per se. It just adds buffering to the process. Attach an interface object.</td></tr>
</table>
</section>
<section>
<title>
<p>Readers &amp; Writers</p></title><empty-line/>
<p>Java 1.1 made significant modifications to the fundamental I/O stream library. When you see the Reader and Writer classes, your first thought (like mine) might be that these were meant to replace the InputStream and OutputStream classes. But that’s not the case. Although some aspects of the original streams library are deprecated (if you use them you will receive a warning from the compiler), the InputStream and OutputStream classes still provide valuable functionality in the form of byte-oriented I/O, whereas the Reader and Writer classes provide Unicode-compliant, character-based I/O. In addition:</p>
<p>1.    Java 1.1 added new classes into the InputStream and OutputStream hierarchy, so it’s obvious those hierarchies weren’t being replaced.</p>
<p>2.    There are times when you must use classes from the &quot;byte&quot; hierarchy in combination with classes in the &quot;character&quot; hierarchy. To accomplish this, there are &quot;adapter&quot; classes: InputStreamReader converts an InputStream to a Reader, and OutputStreamWriter converts an OutputStream to a Writer.</p>
<p>The most important reason for the Reader and Writer hierarchies is for internationalization. The old I/O stream hierarchy supports only 8-bit byte streams and doesn’t handle the 16-bit Unicode characters well. Since Unicode is used for internationalization (and Java’s native char is 16-bit Unicode), the Reader and Writer hierarchies were added to support Unicode in all I/O operations. In addition, the new libraries are designed for faster operations than the old.</p>
<subtitle>Sources and sinks of data</subtitle>
<p>Almost all of the original Java I/O stream classes have corresponding Reader and Writer classes to provide native Unicode manipulation. However, there are some places where the byte-oriented InputStreams and OutputStreams are the correct solution; in particular, thejava.util.zip libraries are byte-oriented rather than char-oriented. So the most sensible approach to take is to try to use the Reader and Writer classes whenever you can. You’ll discover the situations when you have to use the byte-oriented libraries because your code won’t compile.</p>
<p>Here is a table that shows the correspondence between the sources and sinks of information (that is, where the data physically comes from or goes to) in the two hierarchies.</p>
<table>
<tr><td>Sources &amp; sinks: Java 1.0 class</td><td>Corresponding Java 1.1 class</td></tr>
<tr><td>InputStream</td><td>Readeradapter:InputStreamReader</td></tr>
<tr><td>OutputStream</td><td>Writeradapter:OutputStreamWriter</td></tr>
<tr><td>F ilelnputStream</td><td>FileReader</td></tr>
<tr><td>F ileOutputStream</td><td>FileWriter</td></tr>
<tr><td>StringBufferlnputStream(deprecated)</td><td>StringReader</td></tr>
<tr><td>(no corresponding class)</td><td>StringWriter</td></tr>
<tr><td>ByteArrayInputStream</td><td>CharArrayReader</td></tr>
<tr><td>ByteArrayOutputStream</td><td>CharArrayWriter</td></tr>
<tr><td>PipedInputStream</td><td>PipedReader</td></tr>
<tr><td>PipedOutputStream</td><td>PipedWriter</td></tr>
</table>
<p>In general, you’ll find that the interfaces for the two different hierarchies are similar, if not identical.</p>
<subtitle>Modifying stream behavior</subtitle>
<p>For InputStreams and OutputStreams, streams were adapted for particular needs using &quot;decorator&quot; subclasses of FilterInputStream and FilterOutputStream. The Reader and Writer class hierarchies continue the use of this idea—but not exactly.</p>
<p>In the following table, the correspondence is a rougher approximation than in the previous table. The difference is because of the class organization; although</p>
<p>BufferedOutputStream is a subclass of FilterOutputStream, BufferedWriter is not a</p>
<p>subclass of FilterWriter (which, even though it is abstract, has no subclasses and so appears to have been put in either as a placeholder or simply so you don’t wonder where it is). However, the interfaces to the classes are quite a close match.</p>
<table>
<tr><td>Filters:Java 1.0 class</td><td>Corresponding Java 1.1 class</td></tr>
<tr><td>F ilterInputStream</td><td>FilterReader</td></tr>
<tr><td>F ilterOutputStream</td><td>FilterWriter (abstract class with no subclasses)</td></tr>
<tr><td>BufferedInputStream</td><td>BufferedReader(also has readLine( ))</td></tr>
<tr><td>BufferedOutputStream</td><td>BufferedWriter</td></tr>
<tr><td>DataInputStream</td><td>Use DataInputStream(except when you need to use readLine( ), when you should use a</td></tr>
</table>
<table>
<tr><td>Filters:Java 1.0 class</td><td>Corresponding Java 1.1 class</td></tr>
<tr><td></td><td>BufferedReader)</td></tr>
<tr><td>PrintStream</td><td>PrintWriter</td></tr>
<tr><td>LineNumberInputStream(deprecated)</td><td>LineNumberReader</td></tr>
<tr><td>StreamTokenizer</td><td>StreamTokenizer(Use the constructor that takes a Reader instead)</td></tr>
<tr><td>PushbacklnputStream</td><td>PushbackReader</td></tr>
</table>
<p>There’s one direction that’s quite clear: Whenever you want to use readLine( ), you shouldn’t do it with a DataInputStream (this is met with a deprecation message at compile time), but instead use a BufferedReader. Other than this, DataInputStream is still a &quot;preferred&quot; member of the I/O library.</p>
<p>To make the transition to using a PrintWriter easier, it has constructors that take any OutputStream object as well as Writer objects. PrintWriter’s formatting interface is virtually the same as PrintStream.</p>
<p>In Java SE5, PrintWriter constructors were added to simplify the creation of files when writing output, as you shall see shortly.</p>
<p>One PrintWriter constructor also has an option to perform automatic flushing, which happens after every println( ) if the constructor flag is set.</p>
<subtitle>Unchanged classes</subtitle>
<p>Some classes were left unchanged between Java 1.0 and Java 1.1:</p>
<p>Java 1.0 classes without corresponding Java 1.1 classes_</p>
<p>DataOutputStream</p>
<p>File</p>
<p>RandomAccessFile</p>
<p>SequenceInputStream</p>
<p>DataOutputStream, in particular, is used without change, so for storing and retrieving data in a transportable format, you use the InputStream and OutputStream hierarchies.</p>
</section>
<section>
<title>
<p>Off by itself:</p></title><empty-line/>
</section>
<section>
<title>
<p>RandomAccessFile</p></title><empty-line/>
<p>RandomAccessFile is used for files containing records of known size so that you can move from one record to another using seek( ), then read or change the records. The records don’t have to be the same size; you just have to determine how big they are and where they are placed in the file.</p>
<p>At first it’s a little bit hard to believe that RandomAccessFile is not part of the InputStream or OutputStream hierarchy. However, it has no association with those hierarchies other than that it happens to implement the DataInput and DataOutput interfaces (which are also implemented by DataInputStream and DataOutputStream). It doesn’t even use any of the functionality of the existing InputStream or OutputStream classes; it’s a completely separate class, written from scratch, with all of its own (mostly native) methods. The reason for this may be that RandomAccessFile has essentially different behavior than the other I/O types, since you can move forward and backward within a file. In any event, it stands alone, as a direct descendant of Object.</p>
<p>Essentially, a RandomAccessFile works like a DataInputStream pasted together with a DataOutputStream, along with the methods getFilePointer( ) to find out where you are in the file, seek( ) to move to a new point in the file, and length( ) to determine the maximum size of the file. In addition, the constructors require a second argument (identical to fopen( ) in C) indicating whether you are just randomly reading (&quot;r&quot;) or reading and writing (&quot;rw&quot;). There’s no support for write-only files, which could suggest that RandomAccessFile might have worked well if it were inherited from DataInputStream.</p>
<p>The seeking methods are available only in RandomAccessFile, which works for files only. BufferedInputStream does allow you to mark( ) a position (whose value is held in a single internal variable) and reset( ) to that position, but this is limited and not very useful.</p>
<p>Most, if not all, of the RandomAccessFile functionality is superseded as of JDK 1.4 with the nio memory-mapped files, which will be described later in this chapter.</p>
</section>
<section>
<title>
<p>Typical uses of I/O streams</p></title><empty-line/>
<p>Although you can combine the I/O stream classes in many different ways, you’ll probably just use a few combinations. The following examples can be used as a basic reference for typical I/O usage.</p>
<p>In these examples, exception handing will be simplified by passing exceptions out to the console, but this is appropriate only in small examples and utilities. In your code you’ll want to consider more sophisticated error-handling approaches.</p>
<subtitle>Buffered input file</subtitle>
<p>To open a file for character input, you use a FileInputReader with a String or a File object as the file name. For speed, you’ll want that file to be buffered so you give the resulting reference to the constructor for a BufferedReader. Since BufferedReader also provides the readLine( ) method, this is your final object and the interface you read from. When readLine( ) returns null, you’re at the end of the file.</p>
<p>//: io/BufferedInputFile.java import java.io.*;</p>
<p>public class BufferedInputFile {</p>
<p>// Throw exceptions to console: public static String</p>
<p>read(String filename) throws IOException {</p>
<p>// Reading input by lines:</p>
<p>BufferedReader in = new BufferedReader( new FileReader(filename));</p>
<p>String s;</p>
<p>StringBuilder sb = new StringBuilder(); while((s = in.readLine())!= null) sb.append(s + &quot;\n&quot;); in.close(); return sb.toString();</p>
<p>}</p>
<p>public static void main(String[] args) throws IOException {</p>
<p>System.out.print(read(&quot;BufferedInputFile.java&quot;));</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>The StringBuilder sb is used to accumulate the entire contents of the file (including newlines that must be added since readLine( ) strips them off). Finally, close( ) is called to close the file.<a l:href="#bookmark88" type="note"><sup>89</sup></a><sup></sup></p>
<p>Exercise 7: (2) Open a text file so that you can read the file one line at a time. Read each line as a String and place that String object into a LinkedList. Print all of the lines in the LinkedList in reverse order.</p>
<p>Exercise 8: (1) Modify Exercise 7 so that the name of the file you read is provided as a command-line argument.</p>
<p>Exercise 9: (1) Modify Exercise 8 to force all the lines in the LinkedList to uppercase and send the results to System.out.</p>
<p>Exercise 10: (2) Modify Exercise 8 to take additional command-line arguments of words to find in the file. Print all lines in which any of the words match.</p>
<p>Exercise 11: (2) In the innerclasses/GreenhouseController.java example, GreenhouseController contains a hard-coded set of events. Change the program so that it reads the events and their relative times from a text file, ((difficulty level 8): Use a Factory Method design pattern to build the events—see Thinking in Patterns (with Java) at <a l:href="http://www.MindView.net">www.MindView.net</a>.)</p>
<subtitle>Input from memory</subtitle>
<p>Here, the String result from BufferedInputFile.read( ) is used to create a StringReader. Then read( ) is used to read each character one at a time and send it out to the console:</p>
<p>//: io/MemoryInput.java import java.io.*;</p>
<p>public class MemoryInput {</p>
<p>public static void main(String[] args) throws IOException {</p>
<p>StringReader in = new StringReader(</p>
<p>BufferedInputFile.read(&quot;MemoryInput.java&quot;)); int c;</p>
<p>while((c = in.read()) != -1)</p>
<p>System.out.print((char)c);</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>Note that read( ) returns the next character as an int and thus it must be cast to a char to print properly.</p>
<subtitle>Formatted memory input</subtitle>
<p>To read &quot;formatted&quot; data, you use a DataInputStream, which is a byteoriented I/O class (rather than char-oriented). Thus you must use all InputStream classes rather than Reader classes. Of course, you can read anything (such as a file) as bytes using InputStream classes, but here a String is used:</p>
<p>//: io/FormattedMemoryInput.java import java.io.*;</p>
<p>public class FormattedMemoryInput { public static void main(String[] args) throws IOException { try {</p>
<p>DataInputStream in = new DataInputStream( new ByteArrayInputStream(</p>
<p>BufferedInputFile.read(</p>
<p>&quot;FormattedMemoryInput.java&quot;).getBytes()));</p>
<p>while(true)</p>
<p>System.out.print((char)in.readByte());</p>
<p>} catch(EOFException e) {</p>
<p>System.err.println(&quot;End of stream&quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>A ByteArrayInputStream must be given an array of bytes. To produce this, String has a getBytes( ) method. The resulting ByteArrayInputStream is an appropriate InputStream to hand to DataInputStream.</p>
<p>If you read the characters from a DataInputStream one byte at a time using readByte( ), any byte value is a legitimate result, so the return value cannot be used to detect the end of input. Instead, you can use the available( ) method to find out how many more characters are available. Here’s an example that shows how to read a file one byte at a time:</p>
<p>//: io/TestEOF.java</p>
<p>// Testing for end of file while reading a byte at a time. import java.io.*;</p>
<p>public class TestEOF {</p>
<p>public static void main(String[] args) throws IOException {</p>
<p>DataInputStream in = new DataInputStream( new BufferedInputStream(</p>
<p>new FileInputStream(&quot;TestEOF.java&quot;))); while(in.available() != 0)</p>
<p>System.out.print((char)in.readByte());</p>
<p>} /* (Execute to see output) *///:~</p>
<p>Note that available( ) works differently depending on what sort of medium you’re reading from; it’s literally &quot;the number of bytes that can be read without blocking.&quot; With a file, this means the whole file, but with a different kind of stream this might not be true, so use it thoughtfully.</p>
<p>You could also detect the end of input in cases like these by catching an exception. However, the use of exceptions for control flow is considered a misuse of that feature.</p>
<subtitle>Basic file output</subtitle>
<p>A FileWriter object writes data to a file. You’ll virtually always want to buffer the output by wrapping it in a BufferedWriter (try removing this wrapping to see the impact on the performance-buffering tends to dramatically increase performance of I/O operations). In this example, it’s decorated as a PrintWriter to provide formatting. The data file created this way is readable as an ordinary text file:</p>
<p>//: io/BasicFileOutput.java import java.io.*;</p>
<p>public class BasicFileOutput {</p>
<p>static String file = &quot;BasicFileOutput.out&quot;; public static void main(String[] args) throws IOException {</p>
<p>BufferedReader in = new BufferedReader( new StringReader(</p>
<p>BufferedInputFile.read(&quot;BasicFileOutput.java&quot;)));</p>
<p>PrintWriter out = new PrintWriter(</p>
<p>new BufferedWriter(new FileWriter(file))); int lineCount = 1;</p>
<p>String s;</p>
<p>while((s = in.readLine()) != null ) out.println(lineCount++ + &quot;: &quot; + s); out.close();</p>
<p>// Show the stored file:</p>
<p>System.out.println(BufferedInputFile.read(file));</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>As the lines are written to the file, line numbers are added. Note that LineNumberReader is not used, because it’s a silly class and you don’t need it. You can see from this example that it’s trivial to keep track of your own line numbers.</p>
<p>When the input stream is exhausted, readLine( ) returns null. You’ll see an explicit close( ) for out, because if you don’t call close( ) for all your output files, you might discover that the buffers don’t get flushed, so the file will be incomplete.</p>
<p>Text file output shortcut</p>
<p>Java SE5 added a helper constructor to PrintWriter so that you don’t have to do all the decoration by hand every time you want to create a text file and write to it. Here’s BasicFileOutput.java rewritten to use this shortcut:</p>
<p>//: io/FileOutputShortcut.java import java.io.*;</p>
<p>public class FileOutputShortcut {</p>
<p>static String file = &quot;FileOutputShortcut.out&quot;; public static void main(String[] args) throws IOException {</p>
<p>BufferedReader in = new BufferedReader( new StringReader(</p>
<p>BufferedInputFile.read(&quot;FileOutputShortcut.java&quot;)));</p>
<p>// Here’s the shortcut:</p>
<p>PrintWriter out = new PrintWriter(file); int lineCount = 1;</p>
<p>String s;</p>
<p>while((s = in.readLine()) != null ) out.println(lineCount++ + &quot;: &quot; + s); out.close();</p>
<p>// Show the stored file:</p>
<p>System.out.println(BufferedInputFile.read(file));</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>You still get buffering, you just don’t have to do it yourself. Unfortunately, other commonly written tasks were not given shortcuts, so typical I/O will still involve a lot of redundant text. However, the TextFile utility that is used in this book, and which will be defined a little later in this chapter, does simplify these common tasks.</p>
<p>Exercise 12: (3) Modify Exercise 8 to also open a text file so you can write text into it. Write the lines in the LinkedList, along with line numbers (do not attempt to use the &quot;LineNumber&quot; classes), out to the file.</p>
<p>Exercise 13: (3) Modify BasicFileOutput.java so that it uses LineNumberReader</p>
<p>to keep track of the line count. Note that it’s much easier to just keep track programmatically.</p>
<p>Exercise 14: (2) Starting with BasicFileOutput.java, write a program that compares the performance of writing to a file when using buffered and unbuffered I/O.</p>
<subtitle>Storing and recovering data</subtitle>
<p>A PrintWriter formats data so that it’s readable by a human. However, to output data for recovery by another stream, you use a DataOutputStream to write the data and a DataInputStream to recover the data. Of course, these streams can be anything, but the following example uses a file, buffered for both reading and writing. DataOutputStream and DataInputStream are byte-oriented and thus require InputStreams and OutputStreams:</p>
<p>//: io/StoringAndRecoveringData.java import java.io.*;</p>
<p>public class StoringAndRecoveringData { public static void main(String[] args) throws IOException {</p>
<p>DataOutputStream out = new DataOutputStream( new BufferedOutputStream(</p>
<p>new FileOutputStream(&quot;Data.txt&quot;))); out.writeDouble(3.14159); out.writeUTF(&quot;That was pi&quot;); out.writeDouble(1.41413); out.writeUTF(&quot;Square root of 2&quot;); out.close();</p>
<p>DataInputStream in = new DataInputStream( new BufferedInputStream(</p>
<p>new FileInputStream(&quot;Data.txt&quot;))); System.out.println(in.readDouble());</p>
<p>// Only readUTF() will recover the // Java-UTF String properly: System.out.println(in.readUTF()); System.out.println(in.readDouble()); System.out.println(in.readUTF());</p>
<p>}</p>
<p>} /* Output:</p>
<p>3.14159 That was pi 1.41413</p>
<p>Square root of 2 *///:~</p>
<p>If you use a DataOutputStream to write the data, then Java guarantees that you can accurately recover the data using a DataInputStream— regardless of what different platforms write and read the data. This is incredibly valuable, as anyone knows who has spent time worrying about platform-specific data issues. That problem vanishes if you have Java on both platforms.<a l:href="#bookmark89" type="note"><sup>90</sup></a><sup></sup></p>
<p>When you are using a DataOutputStream, the only reliable way to write a String so that it can be recovered by a DataInputStream is to use UTF-8 encoding, accomplished in this example using writeUTF( ) and readUTF( ). UTF-8 is a multi-byte format, and the length of encoding varies according to the actual character set in use. If you’re working with ASCII or mostly ASCII characters (which occupy only seven bits), Unicode is a tremendous waste of space and/or bandwidth, so UTF-8 encodes ASCII characters in a single byte, and non-ASCII characters in two or three bytes. In addition, the length of the string is stored in the first two bytes of the UTF-8 string. However, writeUTF( ) and readUTF( ) use a special variation of UTF-8 for Java (which is completely described in the JDK documentation for those methods), so if you read a string written with writeUTF( ) using a non-Java program, you must write special code in order to read the string properly.</p>
<p>With writeUTF( ) and readUTF( ), you can intermingle Strings and other types of data using a DataOutputStream, with the knowledge that the Strings will be properly stored as Unicode and will be easily recoverable with a DataInputStream.</p>
<p>The writeDouble( ) method stores the double number to the stream, and the complementary readDouble( ) method recovers it (there are similar methods for reading and writing the other types). But for any of the reading methods to work correctly, you must know the exact placement of the data item in the stream, since it would be equally possible to read the stored double as a simple sequence of bytes, or as a char, etc. So you must either have a fixed format for the data in the file, or extra information must be stored in the file that you parse to determine where the data is located. Note that object serialization or XML (both described later in this chapter) may be easier ways to store and retrieve complex data structures.</p>
<p>Exercise 15: (4) Look up DataOutputStream and DataInputStream in the JDK</p>
<p>documentation. Starting with StoringAndRecoveringData.java, create a program that stores and then retrieves all the different possible types provided by the DataOutputStream and DataInputStream classes. Verify that the values are stored and retrieved accurately.</p>
<subtitle>Reading and writing</subtitle>
<subtitle>random-access files</subtitle>
<p>Using a RandomAccessFile is like using a combined DataInputStream and</p>
<p>DataOutputStream (because it implements the same interfaces: DataInput and DataOutput). In addition, you can use seek( ) to move about in the file and change the values.</p>
<p>When using RandomAccessFile, you must know the layout of the file so that you can manipulate it properly. RandomAccessFile has specific methods to read and write primitives and UTF-8 strings. Here’s an example:</p>
<p>//: io/UsingRandomAccessFile.java import java.io.*;</p>
<p>public class UsingRandomAccessFile { static String file = &quot;rtest.dat&quot;; static void display() throws IOException {</p>
<p>RandomAccessFile rf = new RandomAccessFile(file, &quot;r&quot;); for(int i = 0; i &lt; 7; i++)</p>
<p>System.out.println(</p>
<p>&quot;Value &quot; + i + &quot;: &quot; + rf.readDouble()); System.out.println(rf.readUTF()); rf.close();</p>
<p>}</p>
<p>public static void main(String[] args) throws IOException {</p>
<p>RandomAccessFile rf = new RandomAccessFile(file, &quot;rw&quot;); for(int i = 0; i &lt; 7; i++) rf.writeDouble(i*1.414); rf.writeUTF(&quot;The end of the file&quot;); rf.close(); display();</p>
<p>rf = new RandomAccessFile(file, &quot;rw&quot;);</p>
<p>rf.seek(5*8);</p>
<p>rf.writeDouble(47.0001);</p>
<p>rf.close();</p>
<p>display();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Value 0: 0.0 Value 1: 1.414 Value 2: 2.828 Value 3: 4.242 Value 4: 5.656 Value 5: 7.069999999999999 Value 6: 8.484 The end of the file Value 0: 0.0 Value 1: 1.414 Value 2: 2.828 Value 3: 4.242 Value 4: 5.656 Value 5: 47.0001 Value 6: 8.484 The end of the file *///:~</p>
<p>The display( ) method opens a file and displays seven elements within as double values. In main( ), the file is created, then opened and modified. Since a double is always eight bytes long, to seek( ) to double number 5 you just multiply 5*8 to produce the seek value.</p>
<p>As previously noted, RandomAccessFile is effectively separate from the rest of the I/O hierarchy, save for the fact that it implements the DataInput and DataOutput interfaces.</p>
<p>It doesn’t support decoration, so you cannot combine it with any of the aspects of the InputStream and OutputStream subclasses. You must assume that a RandomAccessFile is properly buffered since you cannot add that.</p>
<p>The one option you have is in the second constructor argument: You can open a RandomAccessFile to read (&quot;r&quot;) or read and write (&quot;rw&quot;).</p>
<p>You may want to consider using nio memory-mapped files instead of RandomAccessFile.</p>
<p>Exercise 16: (2) Look up RandomAccessFile in the JDK documentation. Starting with UsingRandomAccessFile.java, create a program that stores and then retrieves all the different possible types provided by the RandomAccessFile class. Verify that the values are stored and retrieved accurately.</p>
<subtitle>Piped streams</subtitle>
<p>The PipedInputStream, PipedOutputStream, PipedReader and PipedWriter have been mentioned only briefly in this chapter. This is not to suggest that they aren’t useful, but their value is not apparent until you begin to understand concurrency, since the piped streams are used to communicate between tasks. This is covered along with an example in the Concurrency chapter.</p>
</section>
<section>
<title>
<p>File reading &amp; writing utilities</p></title><empty-line/>
<p>A very common programming task is to read a file into memory, modify it, and then write it out again. One of the problems with the Java I/O library is that it requires you to write quite a bit of code in order to perform these common operations—there are no basic helper functions to do them for you. What’s worse, the decorators make it rather hard to remember how to open files. Thus, it makes sense to add helper classes to your library that will easily perform these basic tasks for you. Java SE5 has added a convenience constructor to PrintWriter so you can easily open a text file for writing. However, there are many other common tasks that you will want to do over and over, and it makes sense to eliminate the redundant code associated with those tasks.</p>
<p>Here’s the TextFile class that has been used in previous examples in this book to simplify reading and writing files. It contains static methods to read and write text files as a single string, and you can create a TextFile object that holds the lines of the file in an ArrayList (so you have all the ArrayList functionality while manipulating the file contents):</p>
<p>//: net/mindview/util/TextFile.java</p>
<p>// Static functions for reading and writing text files as // a single string, and treating a file as an ArrayList. package net.mindview.util; import java.io.*; import java.util.*;</p>
<p>public class TextFile extends ArrayList&lt;String&gt; {</p>
<p>// Read a file as a single string:</p>
<p>public static String read(String fileName) {</p>
<p>StringBuilder sb = new StringBuilder(); try {</p>
<p>BufferedReader in= new BufferedReader(new FileReader( new File(fileName).getAbsoluteFile())); try {</p>
<p>String s;</p>
<p>while((s = in.readLine()) != null) { sb.append(s); sb.append(&quot;\n&quot;);</p>
<p>}</p>
<p>} finally { in.close();</p>
<p>}</p>
<p>} catch(IOException e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>return sb.toString();</p>
<p>}</p>
<p>// Write a single file in one method call: public static void write(String fileName, String text) { try {</p>
<p>PrintWriter out = new PrintWriter(</p>
<p>new File(fileName).getAbsoluteFile()); try {</p>
<p>out.print(text);</p>
<p>} finally { out.close();</p>
<p>}</p>
<p>} catch(IOException e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>// Read a file, split by any regular expression: public TextFile(String fileName, String splitter) { super(Arrays.asList(read(fileName).split(splitter))); // Regular expression split() often leaves an empty // String at the first position: if(get(0).equals(&quot;&quot;)) remove(0);</p>
<p>}</p>
<p>// Normally read by lines: public TextFile(String fileName) { this(fileName, &quot;\n&quot;);</p>
<p>}</p>
<p>public void write(String fileName) { try {</p>
<p>PrintWriter out = new PrintWriter(</p>
<p>new File(fileName).getAbsoluteFile()); try {</p>
<p>for(String item : this) out.println(item);</p>
<p>} finally { out.close();</p>
<p>}</p>
<p>} catch(IOException e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>// Simple test:</p>
<p>public static void main(String[] args) {</p>
<p>String file = read(&quot;TextFile.java&quot;); write(&quot;test.txt&quot;, file);</p>
<p>TextFile text = new TextFile(&quot;test.txt&quot;); text.write(&quot;test2.txt&quot;);</p>
<p>// Break into unique sorted list of words: TreeSet&lt;String&gt; words = new TreeSet&lt;String&gt;( new TextFile(&quot;TextFile.java&quot;, &quot;\\W+&quot;));</p>
<p>// Display the capitalized words: System.out.println(words.headSet(&quot;a&quot;));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[0, ArrayList, Arrays, Break, BufferedReader, BufferedWriter, Clean, Display, File, FileReader, FileWriter, IOException, Normally, Output, PrintWriter, Read, Regular, RuntimeException, Simple, Static, String, StringBuilder, System, TextFile, Tools, TreeSet, W, Write]</p>
<p>*///:~ read( ) appends each line to a StringBuilder, followed by a newline, because that is stripped out during reading. Then it returns a String containing the whole file. write( ) opens and writes the text String to the file.</p>
<p>Notice that any code that opens a file guards the file’s close( ) call in a finally clause to guarantee that the file will be properly closed.</p>
<p>The constructor uses the read( ) method to turn the file into a String, then uses String.split( ) to divide the result into lines along newline boundaries (if you use this class a lot, you may want to rewrite this constructor to improve efficiency). Alas, there is no corresponding &quot;join&quot; method, so the non-static write( ) method must write the lines out by hand.</p>
<p>Because this class is intended to trivialize the process of reading and writing files, all IOExceptions are converted to RuntimeExceptions, so the user doesn’t have to use try-catch blocks. However, you may need to create another version that passes IOExceptions out to the caller.</p>
<p>In main( ), a basic test is performed to ensure that the methods work.</p>
<p>Although this utility did not require much code to create, using it can save a lot of time and make your life easier, as you’ll see in some of the examples later in this chapter.</p>
<p>Another way to solve the problem of reading text files is to use the java.util.Scanner class introduced in Java SE5. However, this is only for reading files, not writing them, and that tool (which you’ll notice is nor in java.io) is primarily designed for creating programming-language scanners or &quot;little languages.&quot;</p>
<p>Exercise 17: (4) Using TextFile and a Map&lt;Character,Integer&gt;, create a program that counts the occurrence of all the different characters in a file. (So if there are 12 occurrences of the letter ‘a’ in the file, the Integer associated with the Character containing ‘a’ in the Map contains ‘12’).</p>
<p>Exercise 18: (1) Modify TextFile.java so that it passes IOExceptions out to the caller.</p>
<subtitle>Reading binary files</subtitle>
<p>This utility is similar to TextFile.java in that it simplifies the process of reading binary files:</p>
<p>//: net/mindview/util/BinaryFile.java // Utility for reading files in binary form. package net.mindview.util; import java.io.*;</p>
<p>public class BinaryFile {</p>
<p>public static byte[] read(File bFile) throws IOException{ BufferedInputStream bf = new BufferedInputStream( new FileInputStream(bFile)); try {</p>
<p>byte[] data = new byte[bf.available()];</p>
<p>bf.read(data); return data;</p>
<p>} finally { bf.close();</p>
<p>}</p>
<p>}</p>
<p>public static byte[]</p>
<p>read(String bFile) throws IOException {</p>
<p>return read(new File(bFile).getAbsoluteFile());</p>
<p>}</p>
<p>} ///:~</p>
<p>One overloaded method takes a File argument; the second takes a String argument, which is the file name. Both return the resulting byte array.</p>
<p>The available( ) method is used to produce the appropriate array size, and this particular version of the overloaded read( ) method fills the array.</p>
<p>Exercise 19: (2) Using BinaryFile and a Map&lt;Byte,Integer&gt;, create a program that counts the occurrence of all the different bytes in a file.</p>
<p>Exercise 20: (4) Using Directory.walk( ) and BinaryFile, verify that all .class files in a directory tree begin with the hex characters ‘CAFEBABE’.</p>
</section>
<section>
<title>
<p>Standard I/O</p></title><empty-line/>
<p>The term standard I/O refers to the Unix concept of a single stream of information that is used by a program (this idea is reproduced in some form in Windows and many other operating systems). All of the program’s input can come from standard input, all of its output can go to standard output, and all of its error messages can be sent to standard error. The value of standard I/O is that programs can easily be chained together, and one program’s standard output can become the standard input for another program. This is a powerful tool.</p>
<subtitle>Reading from standard input</subtitle>
<p>Following the standard I/O model, Java has System.in, System.out, and System.err. Throughout this book, you’ve seen how to write to standard output using System.out, which is already pre-wrapped as a PrintStream object. System.err is likewise a PrintStream, but System.in is a raw InputStream with no wrapping. This means that although you can use System.out and System.err right away, System.in must be wrapped before you can read from it.</p>
<p>You’ll typically read input a line at a time using readLine( ). To do this, wrap System.in in a BufferedReader, which requires you to convert System.in to a Reader using InputStreamReader. Here’s an example that simply echoes each line that you type in:</p>
<p>//: io/Echo.java</p>
<p>// How to read from standard input.</p>
<p>// {RunByHand} import java.io.*;</p>
<p>public class Echo {</p>
<p>public static void main(String[] args) throws IOException {</p>
<p>BufferedReader stdin = new BufferedReader( new InputStreamReader(System.in));</p>
<p>String s;</p>
<p>while((s = stdin.readLine()) != null &amp;&amp; s.length()!= 0) System.out.println(s);</p>
<p>// An empty line or Ctrl-Z terminates the program</p>
<p>} ///:~</p>
<p>The reason for the exception specification is that readLine( ) can throw an IOException. Note that System.in should usually be buffered, as with most streams.</p>
<p>Exercise 21: (1) Write a program that takes standard input and capitalizes all characters, then puts the results on standard output. Redirect the contents of a file into this program (the process of redirection will vary depending on your operating system).</p>
<p>Changing System.out to a PrintWriter</p>
<p>System.out is a PrintStream, which is an OutputStream. PrintWriter has a</p>
<p>constructor that takes an OutputStream as an argument. Thus, if you want, you can convert System.out into a PrintWriter using that constructor:</p>
<p>//: io/ChangeSystemOut.java</p>
<p>// Turn System.out into a PrintWriter.</p>
<p>import java.io.*;</p>
<p>public class ChangeSystemOut {</p>
<p>public static void main(String[] args) {</p>
<p>PrintWriter out = new PrintWriter(System.out, true); out.println(&quot;Hello, world&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Hello, world *///:~</p>
<p>It’s important to use the two-argument version of the PrintWriter constructor and to set the second argument to true in order to enable automatic flushing; otherwise, you may not see the output.</p>
<subtitle>Redirecting standard I/O</subtitle>
<p>The Java System class allows you to redirect the standard input, output, and error I/O streams using simple static method calls:</p>
<p>setIn(InputStream)</p>
<p>setOut(PrintStream)</p>
<p>setErr(PrintStream)</p>
<p>Redirecting output is especially useful if you suddenly start creating a large amount of output on your screen, and it’s scrolling past faster than you can read it.<a l:href="#bookmark90" type="note"><sup>91</sup></a><sup></sup> Redirecting input is valuable for a command-line program in which you want to test a particular user-input sequence repeatedly. Here’s a simple example that shows the use of these methods:</p>
<p>//: io/Redirecting.java</p>
<p>// Demonstrates standard I/O redirection.</p>
<p>import java.io.*;</p>
<p>public class Redirecting {</p>
<p>public static void main(String[] args) throws IOException {</p>
<p>PrintStream console = System.out;</p>
<p>BufferedInputStream in = new BufferedInputStream( new FileInputStream(&quot;Redirecting.java&quot;));</p>
<p>PrintStream out = new PrintStream( new BufferedOutputStream(</p>
<p>new FileOutputStream(&quot;test.out&quot;)));</p>
<p>System.setIn(in);</p>
<p>System.setOut(out);</p>
<p>System.setErr(out);</p>
<p>BufferedReader br = new BufferedReader( new InputStreamReader(System.in));</p>
<p>String s;</p>
<p>while((s = br.readLine()) != null)</p>
<p>System.out.println(s); out.close(); // Remember this!</p>
<p>System.setOut(console);</p>
<p>}</p>
<p>} ///:~</p>
<p>This program attaches standard input to a file and redirects standard output and standard error to another file. Notice that it stores a reference to the original System.out object at the beginning of the program, and restores the system output to that object at the end.</p>
<p>I/O redirection manipulates streams of bytes, not streams of characters; thus, InputStreams and OutputStreams are used rather than Readers and Writers.</p>
</section>
<section>
<title>
<p>Process control</p></title><empty-line/>
<p>You will often need to execute other operating system programs from inside Java, and to control the input and output from such programs. The Java library provides classes to perform such operations.</p>
<p>A common task is to run a program and send the resulting output to the console. This section contains a utility to simplify this task.</p>
<p>Two types of errors can occur with this utility: the normal errors that result in exceptions— for these we will just rethrow a runtime exception—and errors from the execution of the process itself. We want to report these errors with a separate exception:</p>
<p>//: net/mindview/util/OSExecuteException.java package net.mindview.util;</p>
<p>public class OSExecuteException extends RuntimeException { public OSExecuteException(String why) { super(why); }</p>
<p>} ///:~</p>
<p>To run a program, you pass OSExecute.command( ) a command string, which is the same command that you would type to run the program on the console. This command is passed to the java.lang.ProcessBuilder constructor (which requires it as a sequence of String objects), and the resulting ProcessBuilder object is started:</p>
<p>//: net/mindview/util/OSExecute.java // Run an operating system command</p>
<p>// and send the output to the console. package net.mindview.util; import java.io.*;</p>
<p>public class OSExecute {</p>
<p>public static void command(String command) { boolean err = false; try {</p>
<p>Process process =</p>
<p>new ProcessBuilder(command.split(&quot; &quot;)).start();</p>
<p>BufferedReader results = new BufferedReader(</p>
<p>new InputStreamReader(process.getInputStream()));</p>
<p>String s;</p>
<p>while((s = results.readLine())!= null)</p>
<p>System.out.println(s);</p>
<p>BufferedReader errors = new BufferedReader(</p>
<p>new InputStreamReader(process.getErrorStream()));</p>
<p>// Report errors and return nonzero value // to calling process if there are problems: while((s = errors.readLine())!= null) {</p>
<p>System.err.println(s); err = true;</p>
<p>}</p>
<p>} catch(Exception e) {</p>
<p>// Compensate for Windows 2000, which throws an // exception for the default command line: if(!command.startsWith(&quot;CMD /C&quot;)) command(&quot;CMD /C &quot; + command); else</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>if(err)</p>
<p>throw new OSExecuteException(&quot;Errors executing &quot; + command);</p>
<p>}</p>
<p>} ///:~</p>
<p>To capture the standard output stream from the program as it executes, you call getInputStream( ). This is because an InputStream is something we can read from.</p>
<p>The results from the program arrive a line at a time, so they are read using readLine( ). Here the lines are simply printed, but you may also want to capture and return them from command( ).</p>
<p>The program’s errors are sent to the standard error stream, and are captured by calling getErrorStream( ). If there are any errors, they are printed and an OSExecuteException is thrown so the calling program will handle the problem.</p>
<p>Here’s an example that shows how to use OSExecute:</p>
<p>//: io/OSExecuteDemo.java // Demonstrates standard I/O redirection. import net.mindview.util.*;</p>
<p>public class OSExecuteDemo {</p>
<p>public static void main(String[] args) {</p>
<p>OSExecute.command(&quot;javap OSExecuteDemo&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Compiled from &quot;OSExecuteDemo.java&quot;</p>
<p>public class OSExecuteDemo extends java.lang.Object{</p>
<p>public OSExecuteDemo();</p>
<p>public static void main(java.lang.String[]);</p>
<p>*///:~</p>
<p>This uses the javap decompiler (that comes with the JDK) to decompile the program.</p>
<p>Exercise 22: (5) Modify OSExecute.java so that, instead of printing the standard output stream, it returns the results of executing the program as a List of Strings. Demonstrate the use of this new version of the utility.</p>
</section>
<section>
<title>
<p>New I/O</p></title><empty-line/>
<p>The Java &quot;new&quot; I/O library, introduced in JDK 1.4 in the java.nio.* packages, has one goal: speed. In fact, the &quot;old&quot; I/O packages have been reimplemented using nio in order to take advantage of this speed increase, so you will benefit even if you don’t explicitly write code with nio. The speed increase occurs both in file I/O, which is explored here, and in network I/O, which is covered in Thinking in Enterprise Java.</p>
<p>The speed comes from using structures that are closer to the operating system’s way of performing I/O: channels and buffers. You could think of it as a coal mine; the channel is the mine containing the seam of coal (the data), and the buffer is the cart that you send into the mine. The cart comes back full of coal, and you get the coal from the cart. That is, you don’t interact directly with the channel; you interact with the buffer and send the buffer into the channel. The channel either pulls data from the buffer, or puts data into the buffer.</p>
<p>The only kind of buffer that communicates directly with a channel is a ByteBuffer—that is, a buffer that holds raw bytes. If you look at the JDK documentation for java.nio.ByteBuffer, you’ll see that it’s fairly basic: You create one by telling it how much storage to allocate, and there are methods to put and get data, in either raw byte form or as primitive data types. But there’s no way to put or get an object, or even a String. It’s fairly low-level, precisely because this makes a more efficient mapping with most operating systems.</p>
<p>Three of the classes in the &quot;old&quot; I/O have been modified so that they produce a FileChannel: FileInputStream, FileOutputStream, and, for both reading and writing, RandomAccessFile. Notice that these are the byte manipulation streams, in keeping with the low-level nature of nio. The Reader and Writer character-mode classes do not produce channels, but the java.nio.channels.Channels class has utility methods to produce Readers and Writers from channels.</p>
<p>Here’s a simple example that exercises all three types of stream to produce channels that are writeable, read/writeable, and readable:</p>
<p>//: io/GetChannel.java // Getting channels from streams import java.nio.*; import java.nio.channels.*; import java.io.*;</p>
<p>public class GetChannel {</p>
<p>private static final int BSIZE = 1024;</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>// Write a file:</p>
<p>FileChannel fc =</p>
<p>new FileOutputStream(&quot;data.txt&quot;).getChannelQ; fc.write(ByteBuffer.wrap(&quot;Some text &quot;.getBytesQ));</p>
<p>fc.closeQ;</p>
<p>// Add to the end of the file: fc =</p>
<p>new RandomAccessFile(&quot;data.txt&quot;, &quot;rw&quot;).getChannelQ; fc.position(fc.size()); // Move to the end fc.write(ByteBuffer.wrap(&quot;Some more&quot;.getBytes())); fc.close();</p>
<p>// Read the file:</p>
<p>fc = new FileInputStream(&quot;data.txt&quot;).getChannel(); ByteBuffer buff = ByteBuffer.allocate(BSIZE); fc.read(buff); buff.flip();</p>
<p>while(buff.hasRemainingQ)</p>
<p>System.out.print((char)buff.get());</p>
<p>}</p>
<p>} /* Output:</p>
<p>Some text Some more *///:~</p>
<p>For any of the stream classes shown here, getChannel( ) will produce a FileChannel. A channel is fairly basic: You can hand it a ByteBuffer for reading or writing, and you can lock regions of the file for exclusive access (this will be described later).</p>
<p>One way to put bytes into a ByteBuffer is to stuff them in directly using one of the &quot;put&quot; methods, to put one or more bytes, or values of primitive types. However, as seen here, you can also &quot;wrap&quot; an existing byte array in a ByteBuffer using the wrap( ) method. When you do this, the underlying array is not copied, but instead is used as the storage for the generated ByteBuffer. We say that the ByteBuffer is &quot;backed by&quot; the array.</p>
<p>The data.txt file is reopened using a RandomAccessFile. Notice that you can move the FileChannel around in the file; here, it is moved to the end so that additional writes will be appended.</p>
<p>For read-only access, you must explicitly allocate a ByteBuffer using the static allocate( ) method. The goal of nio is to rapidly move large amounts of data, so the size of the ByteBuffer should be significant-in fact, the lK used here is probably quite a bit smaller than you’d normally want to use (you’ll have to experiment with your working application to find the best size).</p>
<p>It’s also possible to go for even more speed by using allocateDirect( ) instead of allocate( ) to produce a &quot;direct&quot; buffer that may have an even higher coupling with the operating system. However, the overhead in such an allocation is greater, and the actual implementation varies from one operating system to another, so again, you must experiment with your working application to discover whether direct buffers will buy you any advantage in speed.</p>
<p>Once you call read( ) to tell the FileChannel to store bytes into the ByteBuffer, you must call flip( ) on the buffer to tell it to get ready to have its bytes extracted (yes, this seems a bit crude, but remember that it’s very low-level and is done for maximum speed). And if we were to use the buffer for further read( ) operations, we’d also have to call clear( ) to prepare it for each read( ). You can see this in a simple file-copying program:</p>
<p>//: io/ChannelCopy.java</p>
<p>// Copying a file using channels and buffers // {Args: ChannelCopy.java test.txt} import java.nio.*; import java.nio.channels.*; import java.io.*;</p>
<p>public class ChannelCopy {</p>
<p>private static final int BSIZE = 1024;</p>
<p>public static void main(String[] args) throws Exception { if(args.length != 2) {</p>
<p>System.out.println(&quot;arguments: sourcefile destfile&quot;); System.exit(l);</p>
<p>}</p>
<p>FileChannel</p>
<p>in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();</p>
<p>ByteBuffer buffer = ByteBuffer.allocate(BSIZE); while(in.read(buffer) != -1) {</p>
<p>buffer.flip(); // Prepare for writing out.write(buffer);</p>
<p>buffer.clear(); // Prepare for reading</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>You can see that one FileChannel is opened for reading, and one for writing. A ByteBuffer is allocated, and when FileChannel.read( ) returns -1 (a holdover, no doubt, from Unix and C), it means that you’ve reached the end of the input. After each read( ), which puts data into the buffer, flip( ) prepares the buffer so that its information can be extracted by the write( ). After the write( ), the information is still in the buffer, and clear( ) resets all the internal pointers so that it’s ready to accept data during another read( ).</p>
<p>The preceding program is not the ideal way to handle this kind of operation, however. Special methods transferTo( ) and transferFrom( ) allow you to connect one channel directly to another:</p>
<p>//: io/TransferTo.java // Using transferTo() between channels // {Args: TransferTo.java TransferTo.txt} import java.nio.channels.*; import java.io.*;</p>
<p>public class TransferTo {</p>
<p>public static void main(String[] args) throws Exception { if(args.length != 2) {</p>
<p>System.out.println(&quot;arguments: sourcefile destfile&quot;); System.exit(l);</p>
<p>}</p>
<p>FileChannel</p>
<p>in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel(); in.transferTo(0, in.size(), out);</p>
<p>// Or:</p>
<p>// out.transferFrom(in, 0, in.size());</p>
<p>}</p>
<p>} ///:~</p>
<p>You won’t do this kind of thing very often, but it’s good to know about.</p>
<subtitle>Converting data</subtitle>
<p>If you look back at GetChannel.java, you’ll notice that, to print the information in the file, we are pulling the data out one byte at a time and casting each byte to a char. This seems a bit primitive—if you look at the java.nio.CharBuffer class, you’ll see that it has a toString( ) method that says, &quot;Returns a string containing the characters in this buffer.&quot; Since a ByteBuffer can be viewed as a CharBuffer with the asCharBuffer( ) method, why not use that? As you can see from the first line in the output statement below, this doesn’t work out:</p>
<p>//: io/BufferToText.java</p>
<p>// Converting text to and from ByteBuffers</p>
<p>import java.nio.*;</p>
<p>import java.nio.channels.*;</p>
<p>import java.nio.charset.*;</p>
<p>import java.io.*;</p>
<p>public class BufferToText {</p>
<p>private static final int BSIZE = 1024;</p>
<p>public static void main(String[] args) throws Exception { FileChannel fc =</p>
<p>new FileOutputStream(&quot;data2.txt&quot;).getChannel(); fc.write(ByteBuffer.wrap(&quot;Some text&quot;.getBytes())); fc.close();</p>
<p>fc = new FileInputStream(&quot;data2.txt&quot;).getChannel();</p>
<p>ByteBuffer buff = ByteBuffer.allocate(BSIZE);</p>
<p>fc.read(buff);</p>
<p>buff.flip();</p>
<p>// Doesn’t work:</p>
<p>System.out.println(buff.asCharBuffer());</p>
<p>// Decode using this system’s default Charset: buff.rewind();</p>
<p>String encoding = System.getProperty(&quot;file.encoding&quot;); System.out.println(&quot;Decoded using &quot; + encoding + &quot;: &quot;</p>
<p>+ Charset.forName(encoding).decode(buff));</p>
<p>// Or, we could encode with something that will print: fc = new FileOutputStream(&quot;data2.txt&quot;).getChannel(); fc.write(ByteBuffer.wrap(</p>
<p>&quot;Some text&quot;.getBytes(&quot;UTF-16BE&quot;))); fc.close();</p>
<p>// Now try reading again:</p>
<p>fc = new FileInputStream(&quot;data2.txt&quot;).getChannel();</p>
<p>buff.clear();</p>
<p>fc.read(buff);</p>
<p>buff.flip();</p>
<p>System.out.println(buff.asCharBuffer());</p>
<p>// Use a CharBuffer to write through:</p>
<p>fc = new FileOutputStream(&quot;data2.txt&quot;).getChannel();</p>
<p>buff = ByteBuffer.allocate(24); // More than needed</p>
<p>buff.asCharBuffer().put(&quot;Some text&quot;);</p>
<p>fc.write(buff);</p>
<p>fc.close();</p>
<p>// Read and display:</p>
<p>fc = new FileInputStream(&quot;data2.txt&quot;).getChannel();</p>
<p>buff.clear();</p>
<p>fc.read(buff);</p>
<p>buff.flip();</p>
<p>System.out.println(buff.asCharBuffer());</p>
<p>}</p>
<p>} /* Output:</p>
<p>????</p>
<p>Decoded using Cp1252: Some text Some text Some text *///:~</p>
<p>The buffer contains plain bytes, and to turn these into characters, we must either encode them as we put them in (so that they will be meaningful when they come out) or decode them as they come out of the buffer. This can be accomplished using the</p>
<p>java.nio.charset.Charset class, which provides tools for encoding into many different types of character sets:</p>
<p>//: io/AvailableCharSets.java // Displays Charsets and aliases import java.nio.charset.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class AvailableCharSets {</p>
<p>public static void main(String[] args) {</p>
<p>SortedMap&lt;String,Charset&gt; charSets =</p>
<p>Charset.availableCharsets();</p>
<p>Iterator&lt;String&gt; it = charSets.keySet().iterator(); while(it.hasNext()) {</p>
<p>String csName = it.next(); printnb(csName);</p>
<p>Iterator aliases =</p>
<p>charSets.get(csName).aliases().iterator(); if(aliases.hasNext()) printnb(&quot;: &quot;); while(aliases.hasNext()) { printnb(aliases.next()); if(aliases.hasNext()) printnb(&quot;, &quot;);</p>
<p>}</p>
<p>print();</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Big5: csBig5</p>
<p>Big5-HKSCS: big5-hkscs, big5hk, big5-hkscs:unicode3.0, big5hkscs, Big5_HKSCS</p>
<p>EUC-JP: eucjis, x-eucjp, csEUCPkdFmtjapanese, eucjp, Extended_UNIX_Code_Packed_Format_for_Japanese, x-euc-jp, euc_jp EUC-KR: ksc5601, 5601, ksc5601_1987, ksc_5601, ksc5601-1987, euc_kr, ks_c_5601-1987, euckr, csEUCKR GB18030: gb18030-2000</p>
<p>GB2312: gb2312-1980, gb2312, EUC_CN, gb2312-80, euc-cn, euccn, x-EUC-CN GBK: windows-936, CP936 *///:~</p>
<p>So, returning to BufferToText.java, if you rewind( ) the buffer (to go back to the beginning of the data) and then use that platform’s default character set to decode( ) the data, the resulting CharBuffer will print to the console just fine. To discover the default character set, use System.getProperty(“file.encodmg&quot;), which produces the string that names the character set. Passing this to Charset.forName( ) produces the Charset object that can be used to decode the string.</p>
<p>Another alternative is to encode( ) using a character set that will result in something printable when the file is read, as you see in the third part of BufferToText.java. Here, UTF-16BE is used to write the text into the file, and when it is read, all you must do is convert it to a CharBuffer, and it produces the expected text.</p>
<p>Finally, you see what happens if you write to the ByteBuffer through a CharBuffer (you’ll learn more about this later). Note that 24 bytes are allocated for the ByteBuffer. Since each char requires two bytes, this is enough for 12 chars, but &quot;Some text&quot; only has 9. The remaining zero bytes still appear in the representation of the CharBuffer produced by its toString( ), as you can see in the output.</p>
<p>Exercise 23: (6) Create and test a utility method to print the contents of a CharBuffer up to the point where the characters are no longer printable.</p>
<subtitle>Fetching primitives</subtitle>
<p>Although a ByteBuffer only holds bytes, it contains methods to produce each of the different types of primitive values from the bytes it contains. This example shows the insertion and extraction of various values using these methods:</p>
<p>//: io/GetData.java</p>
<p>// Getting different representations from a ByteBuffer import java.nio.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class GetData {</p>
<p>private static final int BSIZE = 1024; public static void main(String[] args) {</p>
<p>ByteBuffer bb = ByteBuffer.allocate(BSIZE);</p>
<p>// Allocation automatically zeroes the ByteBuffer: int i = 0;</p>
<p>while(i++ &lt; bb.limit()) if(bb.get() != 0) print(&quot;nonzero&quot;); print(&quot;i = &quot; + i); bb.rewind();</p>
<p>// Store and read a char array: bb.asCharBuffer().put(&quot;Howdy!&quot;); char c;</p>
<p>while((c = bb.getChar()) != 0) printnb(c + &quot; &quot;); print(); bb.rewind();</p>
<p>// Store and read a short:</p>
<p>bb.asShortBuffer().put((short)471142);</p>
<p>print(bb.getShort());</p>
<p>bb.rewind();</p>
<p>// Store and read an int: bb.asIntBuffer().put(99471142); print(bb.getInt()); bb.rewind();</p>
<p>// Store and read a long: bb.asLongBuffer().put(99471142); print(bb.getLong()); bb.rewind();</p>
<p>// Store and read a float: bb.asFloatBuffer().put(99471142); print(bb.getFloat()); bb.rewind();</p>
<p>// Store and read a double: bb.asDoubleBuffer().put(99471142); print(bb.getDouble()); bb.rewind();</p>
<p>}</p>
<p>} /* Output: i = 1025 H o w d y !</p>
<p>12390</p>
<p>99471142</p>
<p>99471142</p>
<p>9.9471144E7</p>
<p>9.9471142E7</p>
<p>After a ByteBuffer is allocated, its values are checked to see whether buffer allocation automatically zeroes the contents—and it does. All 1.024 values are checked (up to the limit( ) of the buffer), and all are zero.</p>
<p>The easiest way to insert primitive values into a ByteBuffer is to get the appropriate &quot;view&quot; on that buffer using asCharBuffer( ), asShortBuffer( ), etc., and then to use that view’s put( ) method. You can see this is the process used for each of the primitive data types. The only one of these that is a little odd is the put( ) for the ShortBuffer, which requires a cast (note that the cast truncates and changes the resulting value). All the other view buffers do not require casting in their put( ) methods.</p>
<subtitle>View buffers</subtitle>
<p>A &quot;view buffer&quot; allows you to look at an underlying ByteBuffer through the window of a particular primitive type. The ByteBuffer is still the actual storage that’s &quot;backing&quot; the view, so any changes you make to the view are reflected in modifications to the data in the ByteBuffer. As seen in the previous example, this allows you to conveniently insert primitive types into a ByteBuffer. A view also allows you to read primitive values from a ByteBuffer, either one at a time (as ByteBuffer allows) or in batches (into arrays). Here’s an example that manipulates ints in a ByteBuffer via an IntBuffer:</p>
<p>//: io/IntBufferDemo.java</p>
<p>// Manipulating ints in a ByteBuffer with an IntBuffer import java.nio.*;</p>
<p>public class IntBufferDemo {</p>
<p>private static final int BSIZE = 1024; public static void main(String[] args) {</p>
<p>ByteBuffer bb = ByteBuffer.allocate(BSIZE);</p>
<p>IntBuffer ib = bb.asIntBuffer();</p>
<p>// Store an array of int:</p>
<p>ib.put(new int[]{ 11, 42, 47, 99, 143, 811, 1016 });</p>
<p>// Absolute location read and write:</p>
<p>System.out.println(ib.get(3)); ib.put(3, 1811);</p>
<p>// Setting a new limit before rewinding the buffer. ib.flip();</p>
<p>while(ib.hasRemainingO) { int i = ib.get();</p>
<p>System.out.println(i);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>99</p>
<p>11</p>
<p>42</p>
<p>47</p>
<p>1811</p>
<p>143</p>
<p>811</p>
<p>1016</p>
<p>*///:~</p>
<p>The overloaded put( ) method is first used to store an array of int. The following get( ) and put( ) method calls directly access an int location in the underlying ByteBuffer. Note that these absolute location accesses are available for primitive types by talking directly to a ByteBuffer, as well.</p>
<p>Once the underlying ByteBuffer is filled with ints or some other primitive type via a view buffer, then that ByteBuffer can be written directly to a channel. You can just as easily read from a channel and use a view buffer to convert everything to a particular type of primitive. Here’s an example that interprets the same sequence of bytes as short, int, float, long, and double by producing different view buffers on the same ByteBuffer:</p>
<p>//: io/ViewBuffers.java import java.nio.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ViewBuffers {</p>
<p>public static void main(String[] args) {</p>
<p>ByteBuffer bb = ByteBuffer.wrap(</p>
<p>new byte[]{ 0, 0, 0, 0, 0, 0, 0, ‘a’ }); bb.rewind();</p>
<p>printnb(&quot;Byte Buffer &quot;); while(bb.hasRemaining())</p>
<p>printnb(bb.position()+ &quot; -&gt; &quot; + bb.get() + &quot;, &quot;); print();</p>
<p>CharBuffer cb =</p>
<p>((ByteBuffer)bb.rewind()).asCharBuffer(); printnb(&quot;Char Buffer &quot;); while(cb.hasRemaining())</p>
<p>printnb(cb.position() + &quot; -&gt; &quot; + cb.get() + &quot;, &quot;); print();</p>
<p>FloatBuffer fb =</p>
<p>((ByteBuffer)bb.rewind()).asFloatBuffer(); printnb(&quot;Float Buffer &quot;); while(fb.hasRemaining())</p>
<p>printnb(fb.position()+ &quot; -&gt; &quot; + fb.get() + &quot;, &quot;); print();</p>
<p>IntBuffer ib =</p>
<p>((ByteBuffer)bb.rewind()).asIntBuffer(); printnb(&quot;Int Buffer &quot;); while(ib.hasRemaining())</p>
<p>printnb(ib.position()+ &quot; -&gt; &quot; + ib.get() + &quot;, &quot;); print();</p>
<p>LongBuffer lb =</p>
<p>((ByteBuffer)bb.rewind()).asLongBuffer(); printnb(&quot;Long Buffer &quot;); while(lb.hasRemaining())</p>
<p>printnb(lb.position()+ &quot; -&gt; &quot; + lb.get() + &quot;, &quot;); print();</p>
<p>ShortBuffer sb =</p>
<p>((ByteBuffer)bb.rewind()).asShortBuffer(); printnb(&quot;Short Buffer &quot;); while(sb.hasRemaining())</p>
<p>printnb(sb.position()+ &quot; -&gt; &quot; + sb.get() + &quot;, &quot;); print();</p>
<p>DoubleBuffer db =</p>
<p>((ByteBuffer)bb.rewind()).asDoubleBuffer(); printnb(&quot;Double Buffer &quot;); while(db.hasRemaining())</p>
<p>printnb(db.position()+ &quot; -&gt; &quot; + db.get() + &quot;, &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Byte Buffer 0 -&gt; 0, 1 -&gt; 0, 2 -&gt; 0, 3 -&gt; 0, 4 -&gt; 0, 5 -&gt; 0, 6 -&gt; 0, 7 -&gt; 97,</p>
<p>Char Buffer 0 -&gt;    , 1 -&gt;    , 2 -&gt;    , 3 -&gt; a,</p>
<p>Float Buffer 0 -&gt; 0.0, 1 -&gt; 1.36E-43,</p>
<p>Int Buffer 0 -&gt; 0, 1 -&gt; 97,</p>
<p>Long Buffer 0 -&gt; 97,</p>
<p>Short Buffer 0 -&gt; 0, 1 -&gt; 0, 2 -&gt; 0, 3 -&gt; 97, Double Buffer 0 -&gt; 4.8E-322,</p>
<p>*///:~</p>
<p>The ByteBuffer is produced by &quot;wrapping&quot; an eight-byte array, which is then displayed via view buffers of all the different primitive types. You can see in the following diagram the way the data appears differently when read from the different types of buffers:</p>
<table>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>97</td></tr>
<tr><td colspan="2"></td><td colspan="2"></td><td colspan="2"></td><td colspan="2">a</td></tr>
<tr><td colspan="2">0</td><td colspan="2">0</td><td colspan="2">0</td><td colspan="2">97</td></tr>
</table>
<p>97</p>
<p>0.0</p>
<p>1.36E-43</p>
<p>97</p>
<p>4.8E-322</p>
<p>bytes</p>
<p>chars</p>
<p>shorts</p>
<p>irits</p>
<p>floats</p>
<p>longs</p>
<p>doubles</p>
<p>This corresponds to the output from the program.</p>
<p>Exercise 24: (1) Modify IntBufferDemo.java to use doubles.</p>
<p>Endians</p>
<p>Different machines may use different byte-ordering approaches to store data. &quot;Big endian&quot; places the most significant byte in the lowest memory address, and &quot;little endian&quot; places the most significant byte in the highest memory address. When storing a quantity that is greater than one byte, like int, float, etc., you may need to consider the byte ordering. A ByteBuffer stores data in big endian form, and data sent over a network always uses big endian order. You can change the endian-ness of a ByteBuffer using order( ) with an argument of ByteOrder.BIG_ENDIAN or ByteOrder.LITTLE_ENDIAN.</p>
<p>Consider a ByteBuffer containing the following two bytes:</p><image l:href="#image24.jpg"/>
<p>If you read the data as a short (ByteBuffer.asShortBuffer( )), you will get the number 97 (00000000 01100001), but if you change to little endian, you will get the number 24832 (01100001 00000000).</p>
<p>Here’s an example that shows how byte ordering is changed in characters depending on the endian setting: //: io/Endians.java</p>
<p>// Endian differences and data storage. import java.nio.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Endians {</p>
<p>public static void main(String[] args) {</p>
<p>ByteBuffer bb = ByteBuffer.wrap(new byte[12]); bb.asCharBufferQ.put(&quot;abcdef&quot;); print(Arrays.toString(bb.array())); bb.rewind();</p>
<p>bb.order(ByteOrder.BIG_ENDIAN);</p>
<p>bb.asCharBuffer().put(&quot;abcdef&quot;);</p>
<p>print(Arrays.toString(bb.array()));</p>
<p>bb.rewind();</p>
<p>bb.order(ByteOrder.LITTLE_ENDIAN);</p>
<p>bb.asCharBuffer().put(&quot;abcdef&quot;);</p>
<p>print(Arrays.toString(bb.array()));</p>
<table>
<tr><th colspan="11">}</th></tr>
<tr><td>} /*</td><td colspan="2">Output</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>[0,</td><td>97,</td><td>0,</td><td>98,</td><td>0,</td><td>99,</td><td>0, 100,</td><td>0,</td><td>101,</td><td>0,</td><td>102]</td></tr>
<tr><td>[0,</td><td>97,</td><td>0,</td><td>98,</td><td>0,</td><td>99,</td><td>0, 100,</td><td>0,</td><td>101,</td><td>0,</td><td>102]</td></tr>
<tr><td>[97,</td><td>0,</td><td>98,</td><td>0,</td><td>99,</td><td>0,</td><td>100, 0,</td><td>101</td><td>, 0,</td><td>102</td><td>, 0]</td></tr>
<tr><td>*///</td><td>:~</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<p>The ByteBuffer is given enough space to hold all the bytes in charArray as an external buffer so that the array( ) method can be called to display the underlying bytes. The array( ) method is &quot;optional,&quot; and you can only call it on a buffer that is backed by an array; otherwise, you’ll get an UnsupportedOperationException.</p>
<p>charArray is inserted into the ByteBuffer via a CharBuffer view. When the underlying bytes are displayed, you can see that the default ordering is the same as the subsequent big endian order, whereas the little endian order swaps the bytes.</p>
<subtitle>Data manipulation with buffers</subtitle>
<p>The following diagram illustrates the relationships between the nio classes, so that you can see how to move and convert data. For example, if you wish to write a byte array to a file, then you wrap the byte array using the ByteBuffer.wrap( ) method, open a channel on the FileOutputStream using the getChannel( ) method, and then write data into FileChannel from this ByteBuffer.</p>
<p>by te []</p>
<p>array()/get(byte[])</p>
<p>char[] ±</p>
<p>wrap(byte[])</p>
<p>array()/get(char[l)</p>
<p>doublet]</p>
<p>4</p>
<p>wrap(char[]) array()/get(double[])</p>
<p>CharBuffier</p>
<p>asCharB uffer() &lt;-</p>
<p>float[]</p>
<p>wrap(double[])</p>
<p>array()/get(float[])</p>
<p>Double Buffer</p>
<p>asDoubleB uffer()</p>
<p>4</p>
<p>FloatBuffer</p>
<p>asFloatBuffer()</p>
<p>int[]</p>
<p>4</p>
<p>wrap(float[]) array( )/get(i nt[ ])</p>
<p>long[]</p>
<p>wrap(int[])</p>
<p>array()/get(long[])</p>
<p>IntBuffer</p>
<p>LongBuffer</p>
<p>asIntBuffer()</p>
<p>asLongBuffer() 4-</p>
<p>short[]</p>
<p>4</p>
<p>wrap(long[])</p>
<p>array()/get(short[])</p>
<p>■&gt;</p>
<p>ShortBuffer</p>
<p>asShortB uffer() 4-</p>
<p>wrap(short[])</p>
<p>Encoding/Decoding using ByteBuffer —---</p>
<p>to an encoded byte stream I ___________________________ encode(CharBuffer) ^    i</p>
<p>Load character set using Charset.forName(&quot;8S59_1&quot;)</p>
<p>Charset</p>
<p>newEncoderQ</p>
<p>CharsetEncoder</p>
<p>CharsetDe coder</p>
<p>newDecoder() _</p>
<p>decode(ByteB uffer) &apos;T&quot;</p>
<p>M a p pe d By te Bu ffe r</p>
<p>&gt; ByteBuffer</p>
<table>
<tr><td colspan="3">Underlying File System or Network</td></tr>
<tr><td>_&gt;</td><td colspan="2">&lt; V</td></tr>
<tr><td colspan="2">FilelnputStream Fil eOutputStream RandomAccessFile</td><td>SocketDatagram Socket Se rverSocket</td></tr>
<tr><td colspan="3">jlgetChannel()FileChannel ^</td></tr>
</table>
<p>Utilities</p>
<p>Channels</p>
<p>write(ByteB uffer)</p>
<p>read(ByteB uffer)</p>
<p>map( FileChannel .MapMode, position, size)</p>
<p>appears in process address space</p>
<p>from an encoded byte stream ■</p>
<p>Note that ByteBuffer is the only way to move data into and out of channels, and that you can only create a standalone primitive-typed buffer, or get one from a ByteBuffer using an &quot;as&quot; method. That is, you cannot convert a primitive-typed buffer to a ByteBuffer. However, since you are able to move primitive data into and out of a ByteBuffer via a view buffer, this is not really a restriction.</p>
<subtitle>Buffer details</subtitle>
<p>A Buffer consists of data and four indexes to access and manipulate this data efficiently: mark, position, limit and capacity. There are methods to set and reset these indexes and to query their value.</p>
<table>
<tr><td>capacity( )</td><td>Returns the buffer’s capacity.</td></tr>
<tr><td>clear( )</td><td>Clears the buffer, sets the position to zero, and limit to capacity. You call this method to overwrite an existing buffer.</td></tr>
<tr><td>flip( )</td><td>Sets limit to position and position to zero. This method is used to prepare the buffer for a read after data has been written into it.</td></tr>
<tr><td>limit( )</td><td>Returns the value of limit.</td></tr>
<tr><td>limit(int lim)</td><td>Sets the value of limit.</td></tr>
<tr><td>mark( )</td><td>Sets mark at position.</td></tr>
<tr><td>position( )</td><td>Returns the value of position.</td></tr>
<tr><td>position(int pos)</td><td>Sets the value of position.</td></tr>
<tr><td>remaining( )</td><td>Returns (limit - position).</td></tr>
<tr><td>hasRemaining( )</td><td>Returns true if there are any elements between position and limit.</td></tr>
</table>
<p>Methods that insert and extract data from the buffer update these indexes to reflect the changes.</p>
<p>This example uses a very simple algorithm (swapping adjacent characters) to scramble and unscramble characters in a CharBuffer:</p>
<p>//: io/UsingBuffers.java import java.nio.*;</p>
<p>import static net.mindview.util.Print.*; public class UsingBuffers {</p>
<p>private static void symmetricScramble(CharBuffer buffer){ while(buffer.hasRemaining()) { buffer.mark(); char cl = buffer.get(); char c2 = buffer.get(); buffer.reset(); buffer.put(c2).put(c1);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) { char[] data = &quot;UsingBuffers&quot;.toCharArray();</p>
<p>ByteBuffer bb = ByteBuffer.allocate(data.length * 2);</p>
<p>CharBuffer cb = bb.asCharBuffer();</p>
<p>cb.put(data);</p>
<p>print(cb.rewind());</p>
<p>symmetricScramble(cb);</p>
<p>print(cb.rewind());</p>
<p>symmetricScramble(cb);</p>
<p>print(cb.rewind());</p>
<p>}</p>
<p>} /* Output:</p>
<p>UsingBuffers</p>
<p>sUniBgfuefsr</p>
<p>UsingBuffers</p>
<p>Although you could produce a CharBuffer directly by calling wrap( ) with a char array, an underlying ByteBuffer is allocated instead, and a CharBuffer is produced as a view on the ByteBuffer. This emphasizes that the goal is always to manipulate a ByteBuffer, since that is what interacts with a channel.</p>
<p>Here’s what the buffer looks like at the entrance of the symmetricScramble( ) method:</p>
<table>
<tr><th colspan="13">03 p</th></tr>
<tr><td colspan="12"></td><td></td></tr>
<tr><td>u</td><td>s</td><td>i</td><td>n</td><td>9</td><td>B</td><td>u</td><td>f</td><td>f</td><td>e</td><td>r</td><td colspan="2">s</td></tr>
<tr><td colspan="2"></td><td colspan="8"></td><td colspan="2"></td><td></td></tr>
<tr><td colspan="13">| p s |    | lim</td></tr>
</table>
<p>The position points to the first element in the buffer, and the capacity and limit point to the last element.</p>
<p>In symmetricScramble( ), the while loop iterates until position is equivalent to limit. The position of the buffer changes when a relative get( ) or put( )</p>
<p>can also call absolute get( ) and put( ) methods that include an index argument, which is the location where the get( ) or put( ) takes place. These methods do not modify the value of the buffer’s position.</p>
<p>When the control enters the while loop, the value of mark is set using a mark( ) call. The state of the buffer is then:</p>
<table>
<tr><th colspan="14">| mar |    | cap</th></tr>
<tr><td></td><td colspan="2"></td><td colspan="8"></td><td colspan="2">V</td><td></td></tr>
<tr><td colspan="2">U</td><td>s</td><td>i</td><td>n</td><td>9</td><td>B</td><td>u</td><td>f</td><td>f</td><td>e</td><td>r</td><td colspan="2">s</td></tr>
<tr><td>7</td><td colspan="2">\-</td><td colspan="8"></td><td colspan="2">-7</td><td></td></tr>
<tr><td colspan="14">| p os |    | lim</td></tr>
</table>
<p>The two relative get( ) calls save the value of the first two characters in variables c1 and c2. After these two calls, the buffer looks like this:</p>
<table>
<tr><th colspan="15">| mar |    | cap</th></tr>
<tr><td></td><td colspan="2"></td><td colspan="9"></td><td colspan="2">V</td><td></td></tr>
<tr><td colspan="2">U</td><td>s</td><td colspan="2">i</td><td>n</td><td>9</td><td>B</td><td>u</td><td>f</td><td>f</td><td>e</td><td>r</td><td colspan="2">s</td></tr>
<tr><td colspan="4">-7</td><td colspan="2"></td><td colspan="6"></td><td colspan="2">-7</td><td></td></tr>
<tr><td colspan="15">pos |    | lim</td></tr>
</table>
<p>To perform the swap, we need to write c2 at position = o and c1 at position = 1. We can either use the absolute put method to achieve this, or set the value of position to mark, which is what reset( ) does:</p>
<table>
<tr><td></td><td colspan="2"></td><td colspan="8"></td><td colspan="2">V</td><td>1՜</td></tr>
<tr><td colspan="2">u</td><td>s</td><td>i</td><td>n</td><td>9</td><td>B</td><td>u</td><td>f</td><td>f</td><td>e</td><td>r</td><td colspan="2">s</td></tr>
<tr><td></td><td colspan="2"></td><td colspan="8"></td><td colspan="2"></td><td></td></tr>
<tr><td colspan="14">lim</td></tr>
</table>
<p>The two put( ) methods write c2 and then c1:</p>
<table>
<tr><td></td><td colspan="2">/</td><td colspan="9"></td><td colspan="2"></td><td></td></tr>
<tr><td colspan="2">s</td><td>U</td><td colspan="2">i</td><td>n</td><td>9</td><td>B</td><td>u</td><td>f</td><td>f</td><td>e</td><td>r</td><td colspan="2">s</td></tr>
<tr><td colspan="4"></td><td colspan="2"></td><td colspan="6"></td><td colspan="2"></td><td></td></tr>
<tr><td colspan="15">lim</td></tr>
</table>
<p>During the next iteration of the loop, mark is set to the current value of position:</p>
<table>
<tr><th colspan="14">mar |    | oap</th></tr>
<tr><td colspan="3">V</td><td colspan="2"></td><td colspan="6"></td><td colspan="2">V</td><td>■-</td></tr>
<tr><td>s</td><td>U</td><td colspan="2">i</td><td>n</td><td>9</td><td>B</td><td>u</td><td>f</td><td>f</td><td>e</td><td>r</td><td colspan="2">s</td></tr>
<tr><td colspan="3">-7</td><td colspan="2">\-</td><td colspan="6"></td><td colspan="2">-7</td><td>\</td></tr>
<tr><td colspan="14">pos |    | lim</td></tr>
</table>
<p>The process continues until the entire buffer is traversed. At the end of the while loop, position is at the end of the buffer. If you print the buffer, only the characters between the position and limit are printed. Thus, if you want to show the entire contents of the buffer, you must set position to the start of the buffer using rewind( ). Here is the state of buffer after the rewind( ) call (the value of mark becomes undefined):</p>
<table>
<tr><th colspan="14">■:=a p</th></tr>
<tr><td colspan="13">V</td><td></td></tr>
<tr><td colspan="2">s</td><td>U</td><td>n</td><td>i</td><td>B</td><td>9</td><td>f</td><td>u</td><td>e</td><td>f</td><td>s</td><td colspan="2">r</td></tr>
<tr><td>-7</td><td colspan="2">\-</td><td colspan="8"></td><td colspan="2">-7</td><td></td></tr>
<tr><td colspan="14">pos 1    1 lim</td></tr>
</table>
<p>When the function symmetricScramble( ) is called again, the CharBuffer undergoes the same process and is restored to its original state.</p>
<subtitle>Memory-mapped files</subtitle>
<p>Memory-mapped files allow you to create and modify files that are too big to bring into memory. With a memory-mapped file, you can pretend that the entire file is in memory and that you can access it by simply treating it as a very large array. This approach greatly simplifies the code you write in order to modify the file. Here’s a small example:</p>
<p>//: io/LargeMappedFiles.java</p>
<p>// Creating a very large file using mapping.</p>
<p>// {RunByHand}</p>
<p>import java.nio.*;</p>
<p>import java.nio.channels.*;</p>
<p>import java.io.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class LargeMappedFiles {</p>
<p>static int length = 0x8FFFFFF; // 128 MB public static void main(String[] args) throws Exception { MappedByteBuffer out =</p>
<p>new RandomAccessFile(&quot;test.dat&quot;, &quot;rw&quot;).getChannel() .map(FileChannel.MapMode.READ_WRITE, 0, length); for(int i = 0; i &lt; length; i++) out.put((byte)’x’); print(&quot;Finished writing&quot;);</p>
<p>for(int i = length/2; i &lt; length/2 + 6; i++) printnb((char)out.get(i));</p>
<p>}</p>
<p>} ///:~</p>
<p>To do both writing and reading, we start with a RandomAccessFile, get a channel for that file, and then call map( ) to produce a MappedByteBuffer, which is a particular kind of direct buffer. Note that you must specify the starting point and the length of the region that you want to map in the file; this means that you have the option to map smaller regions of a large file.</p>
<p>MappedByteBuffer is inherited from ByteBuffer, so it has all of ByteBuffer’s methods. Only the very simple uses of put( ) and get( ) are shown here, but you can also use methods like asCharBuffer( ), etc.</p>
<p>The file created with the preceding program is 128 MB long, which is probably larger than your OS will allow in memory at one time. The file appears to be accessible all at once because only portions of it are brought into memory, and other parts are swapped out. This way a very large file (up to 2 GB) can easily be modified. Note that the file-mapping facilities of the underlying operating system are used to maximize performance.</p>
<p>Performance</p>
<p>Although the performance of &quot;old&quot; stream I/O has been improved by implementing it with nio, mapped file access tends to be dramatically faster. This program does a simple performance comparison:</p>
<p>//: io/MappedIO.java import java.nio.*; import java.nio.channels.*; import java.io.*;</p>
<p>public class MappedIO {</p>
<p>private static int numOfInts = 4000000; private static int numOfUbuffInts = 200000; private abstract static class Tester { private String name;</p>
<p>public Tester(String name) { this.name = name; } public void runTest() {</p>
<p>System.out.print(name + &quot;: &quot;); try {</p>
<p>long start = System.nanoTime(); test();</p>
<p>double duration = System.nanoTime() - start; System.out.format(&quot;%.2f\n&quot;, duration/1.0e9);</p>
<p>} catch(IOException e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>public abstract void test() throws IOException;</p>
<p>private static Tester[] tests = { new Tester(&quot;Stream Write&quot;) {</p>
<p>public void test() throws IOException {</p>
<p>DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(</p>
<p>new FileOutputStream(new File(&quot;temp.tmp&quot;)))); for(int i = 0; i &lt; numOfInts; i++) dos.writelnt(i); dos.close();</p>
<p>}</p>
<p>},</p>
<p>new Tester(&quot;Mapped Write&quot;) {</p>
<p>public void test() throws IOException {</p>
<p>FileChannel fc =</p>
<p>new RandomAccessFile(&quot;temp.tmp&quot;, &quot;rw&quot;) .getChannel();</p>
<p>IntBuffer ib = fc.map(</p>
<p>FileChannel.MapMode.READ_WRITE, 0, fc.size()) .asIntBuffer();</p>
<p>for(int i = 0; i &lt; numOfInts; i++) ib.put(i); fc.close();</p>
<p>}</p>
<p>},</p>
<p>new Tester(&quot;Stream Read&quot;) {</p>
<p>public void test() throws IOException {</p>
<p>DataInputStream dis = new DataInputStream( new BufferedInputStream(</p>
<p>new FileInputStream(&quot;temp.tmp&quot;))); for(int i = 0; i &lt; numOfInts; i++) dis.readInt(); dis.close();</p>
<p>}</p>
<p>},</p>
<p>new Tester(&quot;Mapped Read&quot;) {</p>
<p>public void test() throws IOException {</p>
<p>FileChannel fc = new FileInputStream( new File(&quot;temp.tmp&quot;)).getChannel();</p>
<p>IntBuffer ib = fc.map(</p>
<p>FileChannel.MapMode.READ_ONLY, 0, fc.size()) .asIntBuffer(); while(ib.hasRemaining()) ib.get(); fc.close();</p>
<p>}</p>
<p>},</p>
<p>new Tester(&quot;Stream Read/Write&quot;) {</p>
<p>public void test() throws IOException {</p>
<p>RandomAccessFile raf = new RandomAccessFile( new File(&quot;temp.tmp&quot;), &quot;rw&quot;); raf.writeInt(l);</p>
<p>for(int i = 0; i &lt; numOfUbuffInts; i++) { raf.seek(raf.length() - 4); raf.writeInt(raf.readInt());</p>
<p>}</p>
<p>raf.close();</p>
<p>}</p>
<p>},</p>
<p>new Tester(&quot;Mapped Read/Write&quot;) {</p>
<p>public void test() throws IOException {</p>
<p>FileChannel fc = new RandomAccessFile( new File(&quot;temp.tmp&quot;), &quot;rw&quot;).getChannelQ; IntBuffer ib = fc.map(</p>
<p>FileChannel.MapMode.READ_WRITE, 0, fc.size()) .asIntBuffer(); ib.put(0);</p>
<p>for(int i = 1; i &lt; numOfUbuffInts; i++) ib.put(ib.get(i - 1)); fc.close();</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>public static void main(String[] args) { for(Tester test : tests) test.runTest();</p>
<p>}</p>
<p>} /* Output: (90% match)</p>
<p>Stream Write: 0.56 Mapped Write: 0.12 Stream Read: 0.80 Mapped Read: 0.07 Stream Read/Write: 5.32 Mapped Read/Write: 0.02 *///:~</p>
<p>As seen in earlier examples in this book, runTest( ) is used by the Template Method to create a testing framework for various implementations of test( ) defined in anonymous inner subclasses. Each of these subclasses performs one kind of test, so the test( ) methods also give you a prototype for performing the various I/O activities.</p>
<p>Although a mapped write would seem to use a FileOutputStream, all output in file mapping must use a RandomAccessFile, just as read/write does in the preceding code.</p>
<p>Note that the test( ) methods include the time for initialization of the various I/O objects, so even though the setup for mapped files can be expensive, the overall gain compared to stream I/O is significant.</p>
<p>Exercise 25: (6) Experiment with changing the ByteBuffer.allocate( ) statements in the examples in this chapter to ByteBuffer.allocateDirect( ). Demonstrate performance differences, but also notice whether the startup time of the programs noticeably changes.</p>
<p>Exercise 26: (3) Modify strings/JGrep.java to use Java nio memorymapped files.</p>
<subtitle>File locking</subtitle>
<p>File locking allows you to synchronize access to a file as a shared resource. However, two threads that contend for the same file may be in different JVMs, or one may be a Java thread and the other some native thread in the operating system. The file locks are visible to other operating system processes because Java file locking maps directly to the native operating system locking facility.</p>
<p>Here is a simple example of file locking.</p>
<p>//: io/FileLocking.java import java.nio.channels.*; import java.util.concurrent.*; import java.io.*;</p>
<p>public class FileLocking {</p>
<p>public static void main(String[] args) throws Exception { FileOutputStream fos= new FileOutputStream(&quot;file.txt<sup>M</sup>); FileLock fl = fos.getChannel().tryLock(); if(fl != null) {</p>
<p>System.out.println(&quot;Locked File&quot;);</p>
<p>TimeUnit.MILLISECONDS.sleep(100);</p>
<p>fl.release();</p>
<p>System.out.println(&quot;Released Lock&quot;);</p>
<p>}</p>
<p>fos.close();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Locked File Released Lock *///:~</p>
<p>You get a FileLock on the entire file by calling either tryLock( ) or lock( ) on a FileChannel. (SocketChannel, DatagramChannel, and ServerSocketChannel do</p>
<p>not need locking since they are inherently singleprocess entities; you don’t generally share a network socket between two processes.) tryLock( ) is non-blocking. It tries to grab the lock, but if it cannot (when some other process already holds the same lock and it is not shared), it simply returns from the method call. lock( ) blocks until the lock is acquired, or the thread that invoked lock( ) is interrupted, or the channel on which the lock( ) method is called is closed. A lock is released using FileLock.release( ).</p>
<p>It is also possible to lock a part of the file by using</p>
<p>tryLock(long position, long size, boolean shared)</p>
<p>or</p>
<p>lock(long position, long size, boolean shared)</p>
<p>which locks the region (size - position). The third argument specifies whether this lock is shared.</p>
<p>Although the zero-argument locking methods adapt to changes in the size of a file, locks with a fixed size do not change if the file size changes. If a lock is acquired for a region from position to position+size and the file increases beyond position+size, then the section beyond position+size is not locked. The zero-argument locking methods lock the entire file, even if it grows.</p>
<p>Support for exclusive or shared locks must be provided by the underlying operating system.</p>
<p>If the operating system does not support shared locks and a request is made for one, an exclusive lock is used instead. The type of lock (shared or exclusive) can be queried using FileLock.isShared( ).</p>
<p>Locking portions of a mapped file</p>
<p>As mentioned earlier, file mapping is typically used for very large files. You may need to lock portions of such a large file so that other processes may modify unlocked parts of the file.</p>
<p>This is something that happens, for example, with a database, so that it can be available to many users at once.</p>
<p>Here’s an example that has two threads, each of which locks a distinct portion of a file:</p>
<p>//: io/LockingMappedFiles.java // Locking portions of a mapped file.</p>
<p>// {RunByHand} import java.nio.*; import java.nio.channels.*; import java.io.*;</p>
<p>public class LockingMappedFiles {</p>
<p>static final int LENGTH = 0x8FFFFFF; // 128 MB static FileChannel fc;</p>
<p>public static void main(String[] args) throws Exception { fc =</p>
<p>new RandomAccessFile(&quot;test.dat&quot;, &quot;rw&quot;).getChannel(); MappedByteBuffer out =</p>
<p>fc.map(FileChannel.MapMode.READ_WRITE, 0, LENGTH); for(int i = 0; i &lt; LENGTH; i++) out.put((byte)’x’);</p>
<p>new LockAndModify(out, 0, 0 + LENGTH/3);</p>
<p>new LockAndModify(out, LENGTH/2, LENGTH/2 + LENGTH/4);</p>
<p>}</p>
<p>private static class LockAndModify extends Thread { private ByteBuffer buff; private int start, end;</p>
<p>LockAndModify(ByteBuffer mbb, int start, int end) { this.start = start; this.end = end; mbb.limit(end); mbb.position(start); buff = mbb.slice(); start();</p>
<p>}</p>
<p>public void run() { try {</p>
<p>// Exclusive lock with no overlap:</p>
<p>FileLock fl = fc.lock(start, end, false); System.out.println(&quot;Locked: &quot;+ start +&quot; to &quot;+ end);</p>
<p>// Perform modification: while(buff.position() &lt; buff.limit() - 1) buff.put((byte)(buff.get() + 1)); fl.release();</p>
<p>System.out.println(&quot;Released: &quot;+start+&quot; to &quot;+ end);</p>
<p>} catch(IOException e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>The LockAndModify thread class sets up the buffer region and creates a slice( ) to be modified, and in run( ), the lock is acquired on the file channel (you can’t acquire a lock on the buffer-only the channel). The call to lock( ) is very similar to acquiring a threading lock on an object-you now have a &quot;critical section&quot; with exclusive access to that portion of the file.<a l:href="#bookmark91" type="note"><sup>92</sup></a><sup></sup></p>
<p>The locks are automatically released when the JVM exits, or the channel on which it was acquired is closed, but you can also explicitly call release( ) on the FileLock object, as shown here.</p>
</section>
<section>
<title>
<p>Compression</p></title><empty-line/>
<p>The Java I/O library contains classes to support reading and writing streams in a compressed format. You wrap these around other I/O classes to provide compression functionality.</p>
<p>These classes are not derived from the Reader and Writer classes, but instead are part of the InputStream and OutputStream hierarchies. This is because the compression library works with bytes, not characters. However, you might sometimes be forced to mix the two types of streams. (Remember that you can use InputStreamReader and OutputStream Writer to provide easy conversion between one type and another.)</p>
<table>
<tr><td>Compression class</td><td>Function</td></tr>
<tr><td>CheckedInputStream</td><td>GetCheckSum( ) produces checksum for any InputStream (not just decompression).</td></tr>
<tr><td>CheckedOutputStream</td><td>GetCheckSum( ) produces checksum for any OutputStream (not just compression).</td></tr>
<tr><td>DeflaterOutputStream</td><td>Base class for compression classes.</td></tr>
<tr><td>ZipOutputStream</td><td>A DeflaterOutputStream that compresses data into the Zip file format.</td></tr>
<tr><td>GZIPOutputStream</td><td>A DeflaterOutputStream that compresses data into the GZIP file format.</td></tr>
<tr><td>InflaterInputStream</td><td>Base class for decompression classes.</td></tr>
<tr><td>ZipInputStream</td><td>An InflaterInputStream that decompresses data that has been stored in the Zip file format.</td></tr>
<tr><td>GZIPInputStream</td><td>An InflaterInputStream that decompresses data that has been stored in the GZIP file format.</td></tr>
</table>
<p>Although there are many compression algorithms, Zip and GZIP are possibly the most commonly used. Thus you can easily manipulate your compressed data with the many tools available for reading and writing these formats.</p>
<subtitle>Simple compression with GZIP</subtitle>
<p>The GZIP interface is simple and thus is probably more appropriate when you have a single stream of data that you want to compress (rather than a container of dissimilar pieces of data). Here’s an example that compresses a single file:</p>
<p>//: io/GZIPcompress.java // {Args: GZIPcompress.java} import java.util.zip.*; import java.io.*;</p>
<p>public class GZIPcompress {</p>
<p>public static void main(String[] args) throws IOException { if(args.length == 0) {</p>
<p>System.out.println(</p>
<p>&quot;Usage: \nGZIPcompress file\n&quot; +</p>
<p>&quot;\tUses GZIP compression to compress &quot; +</p>
<p>&quot;the file to test.gz&quot;);</p>
<p>System.exit(l);</p>
<p>}</p>
<p>BufferedReader in = new BufferedReader( new FileReader(args[0]));</p>
<p>BufferedOutputStream out = new BufferedOutputStream( new GZIPOutputStream(</p>
<p>new FileOutputStream(&quot;test.gz&quot;)));</p>
<p>System.out.println(&quot;Writing file&quot;); int c;</p>
<p>while((c = in.read()) != -1) out.write(c); in.close(); out.close();</p>
<p>System.out.println(&quot;Reading file&quot;);</p>
<p>BufferedReader in2 = new BufferedReader( new InputStreamReader(new GZIPInputStream( new FileInputStream(&quot;test.gz&quot;))));</p>
<p>String s;</p>
<p>while((s = in2.readLine()) != null)</p>
<p>System.out.println(s);</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>The use of the compression classes is straightforward; you simply wrap your output stream in a GZIPOutputStream or ZipOutputStream, and your input stream in a GZIPInputStream or ZipInputStream. All else is ordinary I/O reading and writing. This is an example of mixing the char-oriented streams with the byte-oriented streams; in uses the Reader classes, whereas GZIPOutputStream’s constructor can accept only an OutputStream object, not a Writer object. When the file is opened, the GZIPInputStream is converted to a Reader.</p>
<subtitle>Multifile storage with Zip</subtitle>
<p>The library that supports the Zip format is more extensive. With it you can easily store multiple files, and there’s even a separate class to make the process of reading a Zip file easy. The library uses the standard Zip format so that it works seamlessly with all the Zip tools currently downloadable on the Internet. The following example has the same form as the previous example, but it handles as many command-line arguments as you want. In addition, it shows the use of the Checksum classes to calculate and verify the checksum for the file. There are two Checksum types: Adler32 (which is faster) and CRC32 (which is slower but slightly more accurate).</p>
<p>//: io/ZipCompress.java</p>
<p>// Uses Zip compression to compress any</p>
<p>// number of files given on the command line.</p>
<p>// {Args: ZipCompress.java} import java.util.zip.*; import java.io.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ZipCompress {</p>
<p>public static void main(String[] args) throws IOException {</p>
<p>FileOutputStream f = new FileOutputStream(&quot;test.zip&quot;); CheckedOutputStream csum =</p>
<p>new CheckedOutputStream(f, new Adler32());</p>
<p>ZipOutputStream zos = new ZipOutputStream(csum); BufferedOutputStream out = new BufferedOutputStream(zos); zos.setComment(&quot;A test of Java Zipping&quot;);</p>
<p>// No corresponding getComment(), though. for(String arg : args) {</p>
<p>print(&quot;Writing file &quot; + arg);</p>
<p>BufferedReader in =</p>
<p>new BufferedReader(new FileReader(arg)); zos.putNextEntry(new ZipEntry(arg)); int c;</p>
<p>while((c = in.read()) != -1) out.write(c); in.close(); out.flush();</p>
<p>}</p>
<p>out.close();</p>
<p>// Checksum valid only after the file has been closed! print(&quot;Checksum: &quot; + csum.getChecksum().getValue());</p>
<p>// Now extract the files: print(&quot;Reading file&quot;);</p>
<p>FileInputStream fi = new FileInputStream(&quot;test.zip&quot;); CheckedInputStream csumi =</p>
<p>new CheckedInputStream(fi, new Adler32());</p>
<p>ZipInputStream in2 = new ZipInputStream(csumi);</p>
<p>BufferedInputStream bis = new BufferedInputStream(in2);</p>
<p>ZipEntry ze;</p>
<p>while((ze = in2.getNextEntry()) != null) { print(&quot;Reading file &quot; + ze); int x;</p>
<p>while((x = bis.read()) != -1)</p>
<p>System.out.write(x);</p>
<p>}</p>
<p>if(args.length == 1)</p>
<p>print(&quot;Checksum: &quot; + csumi.getChecksum().getValue()); bis.close();</p>
<p>// Alternative way to open and read Zip files:</p>
<p>ZipFile zf = new ZipFile(&quot;test.zip&quot;);</p>
<p>Enumeration e = zf.entries(); while(e.hasMoreElements()) {</p>
<p>ZipEntry ze2 = (ZipEntry)e.nextElement(); print(&quot;File: &quot; + ze2);</p>
<p>// ... and extract the data as before</p>
<p>}</p>
<p>/* if(args.length == 1) */</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>For each file to add to the archive, you must call putNextEntry( ) and pass it a ZipEntry object. The ZipEntry object contains an extensive interface that allows you to get and set all the data available on that particular entry in your Zip file: name, compressed and uncompressed sizes, date, CRC checksum, extra field data, comment, compression method, and whether it’s a directory entry. However, even though the Zip format has a way to set a password, this is not supported in Java’s Zip library. And although CheckedInputStream and CheckedOutputStream support both Adler32 and CRC32 checksums, the ZipEntry class supports only an interface for CRC. This is a restriction of the underlying Zip format, but it might limit you from using the faster Adler32.</p>
<p>To extract files, ZipInputStream has a getNextEntry( ) method that returns the next ZipEntry if there is one. As a more succinct alternative, you can read the file using a</p>
<p>ZipFile object, which has a method entries( ) to return an Enumeration to the ZipEntries.</p>
<p>In order to read the checksum, you must somehow have access to the associated Checksum object. Here, a reference to the CheckedOutputStream and CheckedInputStream</p>
<p>objects is retained, but you could also just hold on to a reference to the Checksum object.</p>
<p>A baffling method in Zip streams is setComment( ). As shown in ZipCompress.java, you can set a comment when you’re writing a file, but there’s no way to recover the comment in the ZipInputStream. Comments appear to be supported fully on an entry-by-entry basis only via ZipEntry. Of course, you are not limited to files when using the GZIP or Zip libraries— you can compress anything, including data to be sent through a network connection.</p>
<subtitle>Java ARchives (JARs)</subtitle>
<p>The Zip format is also used in the JAR (Java ARchive) file format, which is a way to collect a group of files into a single compressed file, just like Zip. However, like everything else in Java, JAR files are cross-platform, so you don’t need to worry about platform issues. You can also include audio and image files as well as class files.</p>
<p>JAR files are particularly helpful when you deal with the Internet. Before JAR files, your Web browser would have to make repeated requests of a Web server in order to download all the files that made up an applet. In addition, each of these files was uncompressed. By combining all of the files for a particular applet into a single JAR file, only one server request is necessary and the transfer is faster because of compression. And each entry in a JAR file can be digitally signed for security.</p>
<p>A JAR file consists of a single file containing a collection of zipped files along with a &quot;manifest&quot; that describes them. (You can create your own manifest file; otherwise, the jar program will do it for you.) You can find out more about JAR manifests in the JDK documentation.</p>
<p>The jar utility that comes with Sun’s JDK automatically compresses the files of your choice. You invoke it on the command line:</p>
<p>jar [options] destination [manifest] inputfile(s)</p>
<p>The options are simply a collection of letters (no hyphen or any other indicator is necessary). Unix/Linux users will note the similarity to the tar options. These are:</p>
<table>
<tr><td>c</td><td>Creates a new or empty archive.</td></tr>
<tr><td>t</td><td>Lists the table of contents.</td></tr>
<tr><td>x</td><td>Extracts all files.</td></tr>
<tr><td>x file</td><td>Extracts the named file.</td></tr>
<tr><td>f</td><td>Says, &quot;I’m going to give you the name of the file.&quot; If you don’t use this, jar assumes that its input will come from standard input, or, if it is creating a file, its output will go to standard output.</td></tr>
<tr><td>m</td><td>Says that the first argument will be the name of the user-created manifest file.</td></tr>
<tr><td>v</td><td>Generates verbose output describing what jar is doing.</td></tr>
</table>
<table>
<tr><td>o</td><td>Only stores the files; doesn’t compress the files (use to create a JAR file that you can put in your classpath).</td></tr>
<tr><td>M</td><td>Doesn’t automatically create a manifest file.</td></tr>
</table>
<p>If a subdirectory is included in the files to be put into the JAR file, that subdirectory is automatically added, including all of its subdirectories, etc. Path information is also preserved.</p>
<p>Here are some typical ways to invoke jar. The following command creates a JAR file called myJarFile.jar that contains all of the class files in the current directory, along with an automatically generated manifest file:</p>
<p>jar cf myJarFile.jar *.class</p>
<p>The next command is like the previous example, but it adds a user-created manifest file called myManifestFile.mf:</p>
<p>jar cmf myJarFile.jar myManifestFile.mf *.class This produces a table of contents of the files in myJarFile.jar: jar tf myJarFile.jar</p>
<p>This adds the &quot;verbose&quot; flag to give more detailed information about the files in myJarFile.jar:</p>
<p>jar tvf myJarFile.jar</p>
<p>Assuming audio, classes, and image are subdirectories, this combines all of the subdirectories into the file myApp.jar. The &quot;verbose&quot; flag is also included to give extra feedback while the jar program is working:</p>
<p>jar cvf myApp.jar audio classes image</p>
<p>If you create a JAR file using the o (zero) option, that file can be placed in your CLASSPATH: CLASSPATH=&quot;libl.jar;lib2.jar;&quot;</p>
<p>Then Java can search lib1.jar and lib2.jar for class files.</p>
<p>The jar tool isn’t as general-purpose as a Zip utility. For example, you can’t add or update files to an existing JAR file; you can create JAR files only from scratch. Also, you can’t move files into a JAR file, erasing them as they are moved. However, a JAR file created on one platform will be transparently readable by the jar tool on any other platform (a problem that sometimes plagues Zip utilities).</p>
<p>As you will see in the Graphical User Interfaces chapter, JAR files are also used to package JavaBeans.</p>
</section>
<section>
<title>
<p>Object serialization</p></title><empty-line/>
<p>When you create an object, it exists for as long as you need it, but under no circumstances does it exist when the program terminates. While this makes sense at first, there are situations in which it would be incredibly useful if an object could exist and hold its information even while the program wasn’t running. Then, the next time you started the program, the object would be there and it would have the same information it had the previous time the program was running. Of course, you can get a similar effect by writing the information to a file or to a database, but in the spirit of making everything an object, it would be quite convenient to declare an object to be &quot;persistent,&quot; and have all the details taken care of for you.</p>
<p>Java’s object serialization allows you to take any object that implements the Serializable interface and turn it into a sequence of bytes that can later be fully restored to regenerate the original object. This is even true across a network, which means that the serialization mechanism automatically compensates for differences in operating systems. That is, you can create an object on a Windows machine, serialize it, and send it across the network to a Unix machine, where it will be correctly reconstructed. You don’t have to worry about the data representations on the different machines, the byte ordering, or any other details.</p>
<p>By itself, object serialization is interesting because it allows you to implement lightweight persistence. Persistence means that an object’s lifetime is not determined by whether a program is executing; the object lives in between invocations of the program. By taking a serializable object and writing it to disk, then restoring that object when the program is reinvoked, you’re able to produce the effect of persistence. The reason it’s called &quot;lightweight&quot; is that you can’t simply define an object using some kind of &quot;persistent&quot; keyword and let the system take care of the details (perhaps this will happen in the future). Instead, you must explicitly serialize and deserialize the objects in your program. If you need a more serious persistence mechanism, consider a tool like Hibernate (<a l:href="http://hibernate.sourceforge.net">http://hibernate.sourceforge.net</a>). For details, see Thinking in Enterprise Java, downloadable from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>Object serialization was added to the language to support two major features. Java’s Remote Method Invocation (RMI) allows objects that live on other machines to behave as if they live on your machine. When messages are sent to remote objects, object serialization is necessary to transport the arguments and return values. RMI is discussed in Thinking in Enterprise Java. Object serialization is also necessary for JavaBeans, described in the Graphical User Interfaces chapter. When a Bean is used, its state information is generally configured at design time. This state information must be stored and later recovered when the program is started; object serialization performs this task.</p>
<p>Serializing an object is quite simple as long as the object implements the Serializable interface (this is a tagging interface and has no methods). When serialization was added to the language, many standard library classes were changed to make them serializable, including all of the wrappers for the primitive types, all of the container classes, and many others. Even Class objects can be serialized.</p>
<p>To serialize an object, you create some sort of OutputStream object and then wrap it inside an ObjectOutputStream object. At this point you need only call writeObject( ), and your object is serialized and sent to the OutputStream (object serialization is byte-oriented, and thus uses the InputStream and OutputStream hierarchies). To reverse the process, you wrap an InputStream inside an ObjectlnputStream and call readObject( ). What comes back is, as usual, a reference to an upcast Object, so you must downcast to set things straight.</p>
<p>A particularly clever aspect of object serialization is that it not only saves an image of your object, but it also follows all the references contained in your object and saves those objects, and follows all the references in each of those objects, etc. This is sometimes referred to as the &quot;web of objects&quot; that a single object can be connected to, and it includes arrays of references to objects as well as member objects. If you had to maintain your own object serialization scheme, maintaining the code to follow all these links could be mindboggling. However, Java object serialization seems to pull it off flawlessly, no doubt using an optimized algorithm that traverses the web of objects. The following example tests the serialization mechanism by making a &quot;worm” of linked objects, each of which has a link to the next segment in the worm as well as an array of references to objects of a different class, Data:</p>
<p>//: io/Worm.java</p>
<p>// Demonstrates object serialization. import java.io.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Data implements Serializable { private int n;</p>
<p>public Data(int n) { this.n = n; }</p>
<p>public String toString() { return Integer.toString(n); }</p>
<p>}</p>
<p>public class Worm implements Serializable { private static Random rand = new Random(47); private Data[] d = {</p>
<p>new Data(rand.nextInt(10)), new Data(rand.nextInt(10)), new Data(rand.nextInt(10))</p>
<p>};</p>
<p>private Worm next; private char c;</p>
<p>// Value of i == number of segments public Worm(int i, char x) {</p>
<p>print(&quot;Worm constructor: &quot; + i); c = x; if(--i &gt; 0)</p>
<p>next = new Worm(i, (char)(x + 1));</p>
<p>}</p>
<p>public Worm() {</p>
<p>print(&quot;Default constructor&quot;);</p>
<p>}</p>
<p>public String toString() {</p>
<p>StringBuilder result = new StringBuilder(&quot;:&quot;); result.append(c); result.append(&quot;(&quot;); for(Data dat : d) result.append(dat); result.append(&quot;)&quot;); if(next != null)</p>
<p>result.append(next); return result.toString();</p>
<p>}</p>
<p>public static void main(String[] args) throws ClassNotFoundException, IOException {</p>
<p>Worm w = new Worm(6, ‘a’); print(&quot;w = &quot; + w);</p>
<p>ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;worm.out&quot;)); out.writeObject(&quot;Worm storage\n&quot;); out.writeObject(w); out.close(); // Also flushes output ObjectInputStream in = new ObjectInputStream( new FileInputStream(&quot;worm.out&quot;));</p>
<p>String s = (String)in.readObject();</p>
<p>Worm w2 = (Worm)in.readObject(); print(s + &quot;w2 = &quot; + w2);</p>
<p>ByteArrayOutputStream bout = new ByteArrayOutputStream();</p>
<p>ObjectOutputStream out2 = new ObjectOutputStream(bout); out2.writeObject(&quot;Worm storage\n&quot;); out2.writeObject(w); out2.flush();</p>
<p>ObjectInputStream in2 = new ObjectInputStream( new ByteArrayInputStream(bout.toByteArray())); s = (String)in2.readObjectQ;</p>
<p>Worm w3 = (Worm)in2.readObject(); print(s + &quot;w3 = &quot; + w3);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Worm constructor: 6 Worm constructor: 5 Worm constructor: 4 Worm constructor: 3 Worm constructor: 2 Worm constructor: 1</p>
<p>w = :a(853):b(119):c(802):d(788):e(199):f(881)</p>
<p>Worm storage</p>
<p>w2 = :a(853):b(119):c(802):d(788):e(199):f(881)</p>
<p>Worm storage</p>
<p>w3 = :a(853):b(119):c(802):d(788):e(199):f(881)</p>
<p>*///:~</p>
<p>To make things interesting, the array of Data objects inside Worm are initialized with random numbers. (This way, you don’t suspect the compiler of keeping some kind of metainformation.) Each Worm segment is labeled with a char that’s automatically generated in the process of recursively generating the linked list of Worms. When you create a Worm, you tell the constructor how long you want it to be. To make the next reference, it calls the Worm constructor with a length of one less, etc. The final next reference is left as null, indicating the end of the Worm.</p>
<p>The point of all this was to make something reasonably complex that couldn’t easily be serialized. The act of serializing, however, is quite simple. Once the ObjectOutputStream is created from some other stream, writeObject( ) serializes the object. Notice the call to writeObject( ) for a String, as well. You can also write all the primitive data types using the same methods as DataOutputStream (they share the same interface).</p>
<p>There are two separate code sections that look similar. The first writes and reads a file, and the second, for variety, writes and reads a ByteArray. You can read and write an object using serialization to any DataInputStream or DataOutputStream, including, as you can see in Thinking in Enterprise Java, a network.</p>
<p>You can see from the output that the deserialized object really does contain all of the links that were in the original object.</p>
<p>Note that no constructor, not even the default constructor, is called in the process of deserializing a Serializable object. The entire object is restored by recovering data from the InputStream.</p>
<p>Exercise 27: (1) Create a Serializable class containing a reference to an object of a second Serializable class. Create an instance of your class, serialize it to disk, then restore it and verify that the process worked correctly.</p>
<subtitle>Finding the class</subtitle>
<p>You might wonder what’s necessary for an object to be recovered from its serialized state. For example, suppose you serialize an object and send it as a file or through a network to another machine. Could a program on the other machine reconstruct the object using only the contents of the file?</p>
<p>The best way to answer this question is (as usual) by performing an experiment. The following file goes in the subdirectory for this chapter:</p>
<p>//: io/Alien.java</p>
<p>// A serializable class.</p>
<p>import java.io.*;</p>
<p>public class Alien implements Serializable {} ///:~</p>
<p>The file that creates and serializes an Alien object goes in the same directory:</p>
<p>//: io/FreezeAlien.java</p>
<p>// Create a serialized output file.</p>
<p>import java.io.*;</p>
<p>public class FreezeAlien {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>ObjectOutput out = new ObjectOutputStream( new FileOutputStream(&quot;X.file&quot;));</p>
<p>Alien quellek = new Alien(); out.writeObject(quellek);</p>
<p>}</p>
<p>} ///:~</p>
<p>Rather than catching and handling exceptions, this program takes the quickand- dirty approach of passing the exceptions out of main( ), so they’ll be reported on the console.</p>
<p>Once the program is compiled and run, it produces a file called X.file in the io directory. The following code is in a subdirectory called xfiles:</p>
<p>//: io/xfiles/ThawAlien.java</p>
<p>// Try to recover a serialized file without the // class of object that’s stored in that file.</p>
<p>// {RunByHand} import java.io.*;</p>
<p>public class ThawAlien {</p>
<p>public static void main(String[] args) throws Exception { ObjectInputStream in = new ObjectInputStream( new FileInputStream(new File(&quot;..&quot;, &quot;X.file&quot;)));</p>
<p>Object mystery = in.readObject(); System.out.println(mystery.getClass());</p>
<p>}</p>
<p>} /* Output: class Alien *///:~</p>
<p>Even opening the file and reading in the object mystery requires the Class object for Alien; the JVM cannot find Alien.class (unless it happens to be in the classpath, which it shouldn’t be in this example). You’ll get a ClassNotFoundException. (Once again, all evidence of alien life vanishes before proof of its existence can be verified!) The JVM must be able to find the associated .class file.</p>
<subtitle>Controlling serialization</subtitle>
<p>As you can see, the default serialization mechanism is trivial to use. But what if you have special needs? Perhaps you have special security issues and you don’t want to serialize portions of your object, or perhaps it just doesn’t make sense for one subobject to be serialized if that part needs to be created anew when the object is recovered.</p>
<p>You can control the process of serialization by implementing the Externalizable interface instead of the Serializable interface. The Externalizable interface extends the Serializable interface and adds two methods, writeExternal( ) and readExternal( ),</p>
<p>that are automatically called for your object during serialization and deserialization so that you can perform your special operations.</p>
<p>The following example shows simple implementations of the Externalizable interface methods. Note that Blipi and Blip2 are nearly identical except for a subtle difference (see if you can discover it by looking at the code):</p>
<p>//: io/Blips.java</p>
<p>// Simple use of Externalizable &amp; a pitfall. import java.io.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Blip1 implements Externalizable { public Blip1() {</p>
<p>print(&quot;Blip1 Constructor&quot;);</p>
<p>}</p>
<p>public void writeExternal(ObjectOutput out) throws IOException { print(&quot;Blip1.writeExternal&quot;);</p>
<p>}</p>
<p>public void readExternal(ObjectInput in)</p>
<p>throws IOException, ClassNotFoundException { print(&quot;Blip1.readExternal&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Blip2 implements Externalizable {</p>
<p>Blip2() {</p>
<p>print(&quot;Blip2 Constructor&quot;);</p>
<p>}</p>
<p>public void writeExternal(ObjectOutput out) throws IOException { print(&quot;Blip2.writeExternal&quot;);</p>
<p>}</p>
<p>public void readExternal(ObjectInput in)</p>
<p>throws IOException, ClassNotFoundException { print(&quot;Blip2.readExternal&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class Blips {</p>
<p>public static void main(String[] args) throws IOException, ClassNotFoundException { print(&quot;Constructing objects:&quot;);</p>
<p>Blip1 b1 = new Blip1();</p>
<p>Blip2 b2 = new Blip2();</p>
<p>ObjectOutputStream o = new ObjectOutputStream( new FileOutputStream(&quot;Blips.out&quot;)); print(&quot;Saving objects:&quot;); o.writeObject(b1);</p>
<p>o.writeObject(b2);</p>
<p>o.closeQ;</p>
<p>// Now get them back:</p>
<p>ObjectInputStream in = new ObjectInputStream( new FileInputStream(&quot;Blips.out&quot;)); print(&quot;Recovering b1:&quot;); b1 = (Blip1)in.readObjectQ;</p>
<p>// OOPS! Throws an exception:</p>
<p>//! print(&quot;Recovering b2:&quot;);</p>
<p>//! b2 = (Blip2)in.readObjectQ;</p>
<p>}</p>
<p>} /* Output:</p>
<p>Constructing objects:</p>
<p>Blip1 Constructor Blip2 Constructor Saving objects:</p>
<p>Blip1.writeExternal Blip2.writeExternal Recovering b1:</p>
<p>Blip1 Constructor Blip1.readExternal *///:~</p>
<p>The reason that the Blip2 object is not recovered is that trying to do so causes an exception. Can you see the difference between Blipi and Blip2? The constructor for Blipi is public, while the constructor for Blip2 is not, and that causes the exception upon recovery. Try making Blip2’s constructor public and removing the //! comments to see the correct results.</p>
<p>When bi is recovered, the Blipi default constructor is called. This is different from recovering a Serializable object, in which the object is constructed entirely from its stored bits, with no constructor calls. With an Externalizable object, all the normal default construction behavior occurs (including the initializations at the point of field definition), and then readExternal( ) is called. You need to be aware of this—in particular, the fact that all the default construction always takes place—to produce the correct behavior in your Externalizable objects.</p>
<p>Here’s an example that shows what you must do to fully store and retrieve an Externalizable object:</p>
<p>//: io/Blip3.java</p>
<p>// Reconstructing an externalizable object. import java.io.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Blip3 implements Externalizable { private int i;</p>
<p>private String s; // No initialization public Blip3() {</p>
<p>print(&quot;Blip3 Constructor&quot;);</p>
<p>// s, i not initialized</p>
<p>}</p>
<p>public Blip3(String x, int a) { print(&quot;Blip3(String x, int a)&quot;); s = x; i = a;</p>
<p>// s &amp; i initialized only in non-default constructor.</p>
<p>}</p>
<p>public String toString() { return s + i; } public void writeExternal(ObjectOutput out) throws IOException {</p>
<p>print(&quot;Blip3.writeExternal&quot;);</p>
<p>// You must do this:</p>
<p>out.writeObject(s);</p>
<p>out.writelnt(i);</p>
<p>}</p>
<p>public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { print(&quot;Blip3.readExternal&quot;);</p>
<p>// You must do this: s = (String)in.readObject(); i = in.readInt();</p>
<p>}</p>
<p>public static void main(String[] args) throws IOException, ClassNotFoundException { print(&quot;Constructing objects:&quot;);</p>
<p>Blip3 b3 = new Blip3(&quot;A String &quot;, 47); print(b3);</p>
<p>ObjectOutputStream o = new ObjectOutputStream( new FileOutputStream(&quot;Blip3.out&quot;)); print(&quot;Saving object:&quot;); o.writeObject(b3); o.close();</p>
<p>// Now get it back:</p>
<p>ObjectInputStream in = new ObjectInputStream( new FileInputStream(&quot;Blip3.out&quot;)); print(&quot;Recovering b3:&quot;); b3 = (Blip3)in.readObject(); print(b3);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Constructing objects:</p>
<p>Blip3(String x, int a)</p>
<p>A String 47 Saving object:</p>
<p>Blip3.writeExternal Recovering b3:</p>
<p>Blip3 Constructor Blip3.readExternal A String 47 *///:~</p>
<p>The fields s and i are initialized only in the second constructor, but not in the default constructor. This means that if you don’t initialize s and i in readExternal( ), s will be null and i will be zero (since the storage for the object gets wiped to zero in the first step of object creation). If you comment out the two lines of code following the phrases &quot;You must do this:&quot; and run the program, you’ll see that when the object is recovered, s is null and i is zero.</p>
<p>If you are inheriting from an Externalizable object, you’ll typically call the base-class versions of writeExternal( ) and readExternal( ) to provide proper storage and retrieval of the base-class components.</p>
<p>So to make things work correctly, you must not only write the important data from the object during the writeExternal( ) method (there is no default behavior that writes any of the member objects for an Externalizable object), but you must also recover that data in the readExternal( ) method. This can be a bit confusing at first because the default construction behavior for an Externalizable object can make it seem like some kind of storage and retrieval takes place automatically. It does not.</p>
<p>Exercise 28 : (2) In Blips.java, copy the file and rename it to BlipCheck.java and</p>
<p>rename the class Blip2 to BlipCheck (making it public and removing the public scope from the class Blips in the process). Remove the //! marks in the file and execute the program, including the offending lines. Next, comment out the default constructor for BlipCheck. Run it and explain why it works. Note that after compiling, you must execute the program with &quot;Java Blips&quot; because the main( ) method is still in the class Blips.</p>
<p>Exercise 29: (2) In Blip3.java, comment out the two lines after the phrases &quot;You must do this:&quot; and run the program. Explain the result and why it differs from when the two lines are in the program.</p>
<p>The transient keyword</p>
<p>When you’re controlling serialization, there might be a particular subobject that you don’t want Java’s serialization mechanism to automatically save and restore. This is commonly the case if that subobject represents sensitive information that you don’t want to serialize, such as a password. Even if that information is private in the object, once it has been serialized, it’s possible for someone to access it by reading a file or intercepting a network transmission.</p>
<p>One way to prevent sensitive parts of your object from being serialized is to implement your class as Externalizable, as shown previously. Then nothing is automatically serialized, and you can explicitly serialize only the necessary parts inside writeExternal( ).</p>
<p>If you’re working with a Serializable object, however, all serialization happens automatically. To control this, you can turn off serialization on a field-by-field basis using the transient keyword, which says, &quot;Don’t bother saving or restoring this—I’ll take care of it.&quot;</p>
<p>For example, consider a Logon object that keeps information about a particular login session. Suppose that, once you verify the login, you want to store the data, but without the password. The easiest way to do this is by implementing Serializable and marking the password field as transient. Here’s what it looks like:</p>
<p>//: io/Logon.java</p>
<p>// Demonstrates the &quot;transient&quot; keyword. import java.util.concurrent.*; import java.io.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Logon implements Serializable { private Date date = new Date(); private String username; private transient String password; public Logon(String name, String pwd) { username = name; password = pwd;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;logon info: \n username: &quot; + username +</p>
<p>&quot;\n date: &quot; + date + &quot;\n password: &quot; + password;</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>Logon a = new Logon(&quot;Hulk&quot;, &quot;myLittlePony&quot;); print(&quot;logon a = &quot; + a);</p>
<p>ObjectOutputStream o = new ObjectOutputStream( new FileOutputStream(&quot;Logon.out&quot;));</p>
<p>o.writeObject(a); o.close();</p>
<p>TimeUnit.SECONDS.sleep(1); // Delay // Now get them back:</p>
<p>ObjectInputStream in = new ObjectInputStream( new FileInputStream(&quot;Logon.out&quot;));</p>
<p>print(&quot;Recovering object at &quot; + new Date()); a = (Logon)in.readObject(); print(&quot;logon a = &quot; + a);</p>
<p>} /* Output: (Sample) logon a = logon info: username: Hulk</p>
<p>date: Sat Nov 19 15:03:26 MST 2005 password: myLittlePony</p>
<p>Recovering object at Sat Nov 19 15:03:28 MST 2005 logon a = logon info: username: Hulk</p>
<p>date: Sat Nov 19 15:03:26 MST 2005 password: null *///:~</p>
<p>You can see that the date and username fields are ordinary (not transient), and thus are automatically serialized. However, the password is transient, so it is not stored to disk; also, the serialization mechanism makes no attempt to recover it. When the object is recovered, the password field is null. Note that while toString( ) assembles a String object using the overloaded’+’ operator, a null reference is automatically converted to the string &quot;null.&quot;</p>
<p>You can also see that the date field is stored to and recovered from disk and not generated anew.</p>
<p>Since Externalizable objects do not store any of their fields by default, the transient keyword is for use with Serializable objects only.</p>
<p>An alternative to Externalizable</p>
<p>If you’re not keen on implementing the Externalizable interface, there’s another approach. You can implement the Serializable interface and add (notice I say &quot;add&quot; and not &quot;override&quot; or &quot;implement&quot;) methods called writeObject( ) and readObject( ) that will automatically be called when the object is serialized and deserialized, respectively. That is, if you provide these two methods, they will be used instead of the default serialization.</p>
<p>The methods must have these exact signatures:</p>
<p>private void writeObject(ObjectOutputStream stream) throws IOException;</p>
<p>private void readObject(ObjectlnputStream stream) throws IOException, ClassNotFoundException</p>
<p>From a design standpoint, things get really weird here. First of all, you might think that because these methods are not part of a base class or the Serializable interface, they ought to be defined in their own interface(s). But notice that they are defined as private, which means they are to be called only by other members of this class. However, you don’t actually call them from other members of this class, but instead the writeObject( ) and readObject( ) methods of the ObjectOutputStream and ObjectInputStream objects call your object’s writeObject( ) and readObject( ) methods. (Notice my tremendous restraint in not launching into a long diatribe about using the same method names here. In a word: confusing.) You might wonder how the ObjectOutputStream and</p>
<p>ObjectInputStream objects have access to private methods of your class. We can only assume that this is part of the serialization magic.<a l:href="#bookmark92" type="note"><sup>93</sup></a><sup></sup></p>
<p>Anything defined in an interface is automatically public, so if writeObject( ) and readObject( ) must be private, then they can’t be part of an interface. Since you must follow the signatures exactly, the effect is the same as if you’re implementing an interface.</p>
<p>It would appear that when you call ObjectOutputStream.writeObject( ), the</p>
<p>Serializable object that you pass it to is interrogated (using reflection, no doubt) to see if it implements its own writeObject( ). If so, the normal serialization process is skipped and the custom writeObject( ) is called. The same situation exists for readObject( ).</p>
<p>There’s one other twist. Inside your writeObject( ), you can choose to perform the default writeObject( ) action by calling defaultWriteObject( ). Likewise, inside readObject( )</p>
<p>you can call defaultReadObject( ). Here is a simple example that demonstrates how you can control the storage and retrieval of a Serializable object:</p>
<p>//: io/SerialCtl.java</p>
<p>// Controlling serialization by adding your own // writeObject() and readObject() methods. import java.io.*;</p>
<p>public class SerialCtl implements Serializable { private String a; private transient String b; public SerialCtl(String aa, String bb) { a = &quot;Not Transient: &quot; + aa; b = &quot;Transient: &quot; + bb;</p>
<p>}</p>
<p>public String toString() { return a + &quot;\n&quot; + b; } private void writeObject(ObjectOutputStream stream) throws IOException {</p>
<p>stream.defaultWriteObject();</p>
<p>stream.writeObject(b);</p>
<p>}</p>
<p>private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { stream.defaultReadObject(); b = (String)stream.readObject();</p>
<p>}</p>
<p>public static void main(String[] args) throws IOException, ClassNotFoundException {</p>
<p>SerialCtl sc = new SerialCtl(&quot;Test1&quot;, &quot;Test2&quot;); System.out.println(&quot;Before:\n&quot; + sc);</p>
<p>ByteArrayOutputStream buf= new ByteArrayOutputStream(); ObjectOutputStream o = new ObjectOutputStream(buf); o.writeObject(sc);</p>
<p>// Now get it back:</p>
<p>ObjectInputStream in = new ObjectInputStream( new ByteArrayInputStream(buf.toByteArray()));</p>
<p>SerialCtl sc2 = (SerialCtl)in.readObject(); System.out.println(&quot;After:\n&quot; + sc2);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Before:</p>
<p>Not Transient: Test1 Transient: Test2 After:</p>
<p>Not Transient: Testl Transient: Test2 *///:~</p>
<p>In this example, one String field is ordinary and the other is transient, to prove that the non-transient field is saved by the defaultWriteObject( ) method and the transient</p>
<p>field is saved and restored explicitly. The fields are initialized inside the constructor rather than at the point of definition to prove that they are not being initialized by some automatic mechanism during deserialization.</p>
<p>If you use the default mechanism to write the non-transient parts of your object, you must call defaultWriteObject( ) as the first operation in writeObject( ), and</p>
<p>defaultReadObject( ) as the first operation in readObject( ). These are strange method calls. It would appear, for example, that you are calling defaultWriteObject( ) for an ObjectOutputStream and passing it no arguments, and yet it somehow turns around and knows the reference to your object and how to write all the non-transient parts. Spooky.</p>
<p>The storage and retrieval of the transient objects uses more familiar code. And yet, think about what happens here. In main( ), a SerialCtl object is created, and then it’s serialized to an ObjectOutputStream. (Notice in this case that a buffer is used instead of a file—it’s all the same to the ObjectOutputStream.) The serialization occurs in the line:</p>
<p>o.writeObject(sc);</p>
<p>The writeObject( ) method must be examining sc to see if it has its own writeObject( ) method. (Not by checking the interface—there isn’t one—or the class type, but by actually hunting for the method using reflection.) If it does, it uses that. A similar approach holds true for readObject( ). Perhaps this was the only practical way that they could solve the problem, but it’s certainly strange.</p>
<p>Versioning</p>
<p>It’s possible that you might want to change the version of a serializable class (objects of the original class might be stored in a database, for example). This is supported, but you’ll probably do it only in special cases, and it requires an extra depth of understanding that we will not attempt to achieve here. The JDK documents downloadable from <a l:href="http://java.sun.com">http://java.sun.com</a> cover this topic quite thoroughly.</p>
<p>You will also notice in the JDK documentation many comments that begin with:</p>
<p>Warning: Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between applications ...</p>
<p>This is because the versioning mechanism is too simple to work reliably in all situations, especially with JavaBeans. They’re working on a correction for the design, and that’s what the warning is about.</p>
<subtitle>Using persistence</subtitle>
<p>It’s quite appealing to use serialization technology to store some of the state of your program so that you can easily restore the program to the current state later. But before you can do this, some questions must be answered. What happens if you serialize two objects that both have a reference to a third object? When you restore those two objects from their serialized state, do you get only one occurrence of the third object? What if you serialize your two objects to separate files and deserialize them in different parts of your code?</p>
<p>Here’s an example that shows the problem:</p>
<p>//: io/MyWorld.java import java.io.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class House implements Serializable {}</p>
<p>class Animal implements Serializable { private String name; private House preferredHouse;</p>
<p>Animal(String nm, House h) { name = nm; preferredHouse = h;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return name + &quot;[&quot; + super.toString() +</p>
<p>&quot;], &quot; + preferredHouse + &quot;\n&quot;;</p>
<p>}</p>
<p>}</p>
<p>public class MyWorld {</p>
<p>public static void main(String[] args) throws IOException, ClassNotFoundException {</p>
<p>House house = new House();</p>
<p>List&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt;(); animals.add(new Animal(&quot;Bosco the dog&quot;, house)); animals.add(new Animal(&quot;Ralph the hamster&quot;, house)); animals.add(new Animal(&quot;Molly the cat&quot;, house)); print(&quot;animals: &quot; + animals);</p>
<p>ByteArrayOutputStream bufl = new ByteArrayOutputStream();</p>
<p>ObjectOutputStream ol = new ObjectOutputStream(bufl);</p>
<p>ol.writeObject(animals);</p>
<p>01. writeObject(animals); // Write a 2nd set // Write to a different stream:</p>
<p>ByteArrayOutputStream buf2 =</p>
<p>new ByteArrayOutputStream();</p>
<p>ObjectOutputStream o2 = new ObjectOutputStream(buf2);</p>
<p>02. writeObject(animals);</p>
<p>// Now get them back:</p>
<p>ObjectInputStream inl = new ObjectInputStream( new ByteArrayInputStream(bufl.toByteArray())); ObjectInputStream in2 = new ObjectInputStream( new ByteArrayInputStream(buf2.toByteArray()));</p>
<p>List</p>
<p>animalsl = (List)inl.readObject(), animals2 = (List)inl.readObject(), animals3 = (List)in2.readObject(); print(&quot;animalsl: &quot; + animalsl); print(&quot;animals2: &quot; + animals2); print(&quot;animals3: &quot; + animals3);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>animals: [Bosco the dog[Animal@addbfl], House@42e8l6 , Ralph the hamster[Animal@9304bl], House@42e8l6 , Molly the cat[Animal@l90dll], House@42e8l6 ]</p>
<p>animalsl: [Bosco the dog[Animal@de6f34], House@l56ee8e , Ralph the hamster[Animal@47b480], House@l56ee8e , Molly the cat[Animal@l9b49e6], House@l56ee8e ]</p>
<p>animals2: [Bosco the dog[Animal@de6f34], House@156ee8e , Ralph the hamster[Animal@47b480], House@156ee8e , Molly the cat[Animal@19b49e6], House@156ee8e ]</p>
<p>animals3: [Bosco the dog[Animal@10d448], House@e0e1c6 , Ralph the hamster[Animal@6ca1c], House@e0e1c6 , Molly the cat[Animal@1bf216a], House@e0e1c6 ]</p>
<p>*///:~</p>
<p>One thing that’s interesting here is that it’s possible to use object serialization to and from a byte array as a way of doing a &quot;deep copy&quot; of any object that’s Serializable. (A deep copy means that you’re duplicating the entire web of objects, rather than just the basic object and its references.) Object copying is covered in depth in the online supplements for this book.</p>
<p>Animal objects contain fields of type House. In main( ), a List of these Animals is created and it is serialized twice to one stream and then again to a separate stream. When these are deserialized and printed, you see the output shown for one run (the objects will be in different memory locations each run).</p>
<p>Of course, you expect that the deserialized objects have different addresses from their originals. But notice that in animals1 and animals2, the same addresses appear, including the references to the House object that both share. On the other hand, when animals3 is recovered, the system has no way of knowing that the objects in this other stream are aliases of the objects in the first stream, so it makes a completely different web of objects.</p>
<p>As long as you’re serializing everything to a single stream, you’ll recover the same web of objects that you wrote, with no accidental duplication of objects. Of course, you can change the state of your objects in between the time you write the first and the last, but that’s your responsibility; the objects will be written in whatever state they are in (and with whatever connections they have to other objects) at the time you serialize them.</p>
<p>The safest thing to do if you want to save the state of a system is to serialize as an &quot;atomic&quot; operation. If you serialize some things, do some other work, and serialize some more, etc., then you will not be storing the system safely. Instead, put all the objects that comprise the state of your system in a single container and simply write that container out in one operation. Then you can restore it with a single method call as well.</p>
<p>The following example is an imaginary computer-aided design (CAD) system that demonstrates the approach. In addition, it throws in the issue of static fields; if you look at the JDK documentation, you’ll see that Class is Serializable, so it should be easy to store the static fields by simply serializing the Class object. That seems like a sensible approach, anyway.</p>
<p>//: io/StoreCADState.java</p>
<p>// Saving the state of a pretend CAD system. import java.io.*; import java.util.*;</p>
<p>abstract class Shape implements Serializable {</p>
<p>public static final int RED = 1, BLUE = 2, GREEN = 3; private int xPos, yPos, dimension; private static Random rand = new Random(47); private static int counter = 0; public abstract void setColor(int newColor); public abstract int getColor(); public Shape(int xVal, int yVal, int dim) { xPos = xVal; yPos = yVal; dimension = dim;</p>
<p>public String toString() { return getClass() +</p>
<p>&quot;color[&quot; + getColor() + &quot;] xPos[&quot; + xPos +</p>
<p>&quot;] yPos[&quot; + yPos + &quot;] dim[&quot; + dimension + &quot;]\n&quot;;</p>
<p>}</p>
<p>public static Shape randomFactory() { int xVal = rand.nextInt(100); int yVal = rand.nextInt(100); int dim = rand.nextInt(100); switch(counter++ % 3) { default:</p>
<p>case 0: return    new Circle(xVal,    yVal,    dim);</p>
<p>case 1: return    new Square(xVal,    yVal,    dim);</p>
<p>case 2: return new Line(xVal, yVal, dim);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class    Circle extends    Shape {</p>
<p>private static int    color = RED;</p>
<p>public Circle(int xVal, int yVal, int dim) { super(xVal, yVal, dim);</p>
<p>}</p>
<p>public void setColor(int newColor) { color = newColor; } public int getColor() { return color; }</p>
<p>}</p>
<p>class Square extends Shape { private static int color;</p>
<p>public Square(int xVal, int yVal, int dim) { super(xVal, yVal, dim); color = RED;</p>
<p>}</p>
<p>public void setColor(int newColor) { color = newColor; } public int getColor() { return color; }</p>
<p>}</p>
<p>class Line extends Shape {</p>
<p>private static int color = RED; public static void</p>
<p>serializeStaticState(ObjectOutputStream os) throws IOException { os.writelnt(color); } public static void</p>
<p>deserializeStaticState(ObjectInputStream os) throws IOException { color = os.readInt(); } public Line(int xVal, int yVal, int dim) { super(xVal, yVal, dim);</p>
<p>}</p>
<p>public void setColor(int newColor) { color = newColor; } public int getColor() { return color; }</p>
<p>}</p>
<p>public class StoreCADState {</p>
<p>public static void main(String[] args) throws Exception { List&lt;Class&lt;? extends Shape&gt;&gt; shapeTypes = new ArrayList&lt;Class&lt;? extends Shape&gt;&gt;();</p>
<p>// Add references to the class objects: shapeTypes.add(Circle.class); shapeTypes.add(Square.class); shapeTypes.add(Line.class);</p>
<p>List&lt;Shape&gt; shapes = new ArrayList&lt;Shape&gt;();</p>
<p>// Make some shapes:</p>
<p>for(int i = 0; i &lt; 10; i++)</p>
<p>shapes.add(Shape.randomFactory());</p>
<p>// Set all the static colors to GREEN: for(int i = 0; i &lt; 10; i++)</p>
<p>((Shape)shapes.get(i)).setColor(Shape.GREEN); // Save the state vector:</p>
<p>ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;CADState.out&quot;)); out.writeObject(shapeTypes); Line.serializeStaticState(out); out.writeObject(shapes);</p>
<p>// Display the shapes: System.out.println(shapes);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[class Circlecolor[3] xPos[58] yPos[55] dim[93]</p>
<p>, class Squarecolor[3] xPos[61] yPos[61] dim[29]</p>
<p>, class Linecolor[3] xPos[68] yPos[0] dim[22]</p>
<p>, class Circlecolor[3] xPos[7] yPos[88] dim[28]</p>
<p>, class Squarecolor[3] xPos[51] yPos[89] dim[9]</p>
<p>, class Linecolor[3] xPos[78] yPos[98] dim[61]</p>
<p>, class Circlecolor[3] xPos[20] yPos[58] dim[16]</p>
<p>, class Squarecolor[3] xPos[40] yPos[11] dim[22]</p>
<p>, class Linecolor[3] xPos[4] yPos[83] dim[6]</p>
<p>, class Circlecolor[3] xPos[75] yPos[10] dim[42]</p>
<p>]</p>
<p>*///:~</p>
<p>The Shape class implements Serializable, so anything that is inherited from Shape is automatically Serializable as well. Each Shape contains data, and each derived Shape class contains a static field that determines the color of all of those types of Shapes.</p>
<p>(Placing a static field in the base class would result in only one field, since static fields are not duplicated in derived classes.) Methods in the base class can be overridden to set the color for the various types (static methods are not dynamically bound, so these are normal methods). The randomFactory( ) method creates a different Shape each time you call it, using random values for the Shape data.</p>
<p>Circle and Square are straightforward extensions of Shape; the only difference is that Circle initializes color at the point of definition and Square initializes it in the constructor. We’ll leave the discussion of Line for later.</p>
<p>In main( ), one ArrayList is used to hold the Class objects and the other to hold the shapes.</p>
<p>Recovering the objects is fairly straightforward:</p>
<p>//: io/RecoverCADState.java</p>
<p>// Restoring the state of the pretend CAD system.</p>
<p>// {RunFirst: StoreCADState} import java.io.*; import java.util.*;</p>
<p>public class RecoverCADState {</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)</p>
<p>public static void main(String[] args) throws Exception { ObjectInputStream in = new ObjectInputStream( new FileInputStream(&quot;CADState.out&quot;));</p>
<p>// Read in the same order they were written:</p>
<p>List&lt;Class&lt;? extends Shape&gt;&gt; shapeTypes =</p>
<p>(List&lt;Class&lt;? extends Shape&gt;&gt;)in.readObject(); Line.deserializeStaticState(in);</p>
<p>List&lt;Shape&gt; shapes = (List&lt;Shape&gt;)in.readObjectQ; System.out.println(shapes);</p>
<p>} /* Output:</p>
<p>[class Circlecolor[1] xPos[58] yPos[55] dim[93]</p>
<p>, class Squarecolor[0] xPos[61] yPos[61] dim[29]</p>
<p>, class Linecolor[3] xPos[68] yPos[0] dim[22]</p>
<p>, class Circlecolor[1] xPos[7] yPos[88] dim[28]</p>
<p>, class Squarecolor[0] xPos[51] yPos[89] dim[9]</p>
<p>, class Linecolor[3] xPos[78] yPos[98] dim[61]</p>
<p>, class Circlecolor[1] xPos[20] yPos[58] dim[16]</p>
<p>, class Squarecolor[0] xPos[40] yPos[11] dim[22]</p>
<p>, class Linecolor[3] xPos[4] yPos[83] dim[6]</p>
<p>, class Circlecolor[1] xPos[75] yPos[10] dim[42]</p>
<p>] *///:~</p>
<p>You can see that the values of xPos, yPos, and dim were all stored and recovered successfully, but there’s something wrong with the retrieval of the static information. It’s all &quot;3&quot; going in, but it doesn’t come out that way. Circles have a value of 1 (RED, which is the definition), and Squares have a value of 0 (remember, they are initialized in the constructor). It’s as if the statics didn’t get serialized at all! That’s right-even though class Class is Serializable, it doesn’t do what you expect. So if you want to serialize statics, you must do it yourself.</p>
<p>This is what the serializeStaticState( ) and deserializeStaticState( ) static methods in Line are for. You can see that they are explicitly called as part of the storage and retrieval process. (Note that the order of writing to the serialize file and reading back from it must be maintained.) Thus to make these programs run correctly, you must:</p>
<p>1.    Add a serializeStaticState( ) and deserializeStaticState( ) to the shapes.</p>
<p>2.    Remove the ArrayList shapeTypes and all code related to it.</p>
<p>3.    Add calls to the new serialize and deserialize static methods in the shapes.</p>
<p>Another issue you might have to think about is security, since serialization also saves private data. If you have a security issue, those fields should be marked as transient. But then you have to design a secure way to store that information so that when you do a restore, you can reset those private variables.</p>
<p>Exercise 30: (1) Repair the program CADState.java as described in the text.</p>
</section>
<section>
<title>
<p>XML</p></title><empty-line/>
<p>An important limitation of object serialization is that it is a Java-only solution: Only Java programs can deserialize such objects. A more interoperable solution is to convert data to XML format, which allows it to be consumed by a large variety of platforms and languages.</p>
<p>Because of its popularity, there are a confusing number of options for programming with XML, including the javax.xml.* libraries distributed with the JDK. I’ve chosen to use Elliotte Rusty Harold’s open-source XOM library (downloads and documentation at <a l:href="http://www.xom.nu">www.xom.nu</a>) because it seems to be the simplest and most straightforward way to produce and modify XML using Java. In addition, XOM emphasizes XML correctness.</p>
<p>As an example, suppose you have Person objects containing first and last names that you’d like to serialize into XML. The following Person class has a getXML( ) method that uses</p>
<p>XOM to produce the Person data converted to an XML Element object, and a constructor that takes an Element and extracts the appropriate Person data (notice that the XML examples are in their own subdirectory):</p>
<p>//: xml/Person.java</p>
<p>// Use the XOM library to write and read XML // {Requires: nu.xom.Node; You must install // the XOM library from <a l:href="http://www.xom.nu">http://www.xom.nu</a> } import nu.xom.*; import java.io.*; import java.util.*;</p>
<p>public class Person {</p>
<p>private String first, last; public Person(String first, String last) { this.first = first; this.last = last;</p>
<p>}</p>
<p>// Produce an XML Element from this Person object: public Element getXML() {</p>
<p>Element person = new Element(&quot;person&quot;);</p>
<p>Element firstName = new Element(&quot;first&quot;); firstName.appendChild(first);</p>
<p>Element lastName = new Element(&quot;last&quot;);</p>
<p>lastName.appendChild(last);</p>
<p>person.appendChild(firstName);</p>
<p>person.appendChild(lastName);</p>
<p>return person;</p>
<p>}</p>
<p>// Constructor to restore a Person from an XML Element: public Person(Element person) {</p>
<p>first= person.getFirstChildElement(&quot;first&quot;).getValue(); last = person.getFirstChildElement(&quot;last&quot;).getValue();</p>
<p>}</p>
<p>public String toString() { return first + &quot; &quot; + last; }</p>
<p>// Make it human-readable: public static void</p>
<p>format(OutputStream os, Document doc) throws Exception {</p>
<p>Serializer serializer= new Serializer(os,&quot;ISO-8859-1&quot;);</p>
<p>serializer.setIndent(4);</p>
<p>serializer.setMaxLength(60);</p>
<p>serializer.write(doc);</p>
<p>serializer.flush();</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>List&lt;Person&gt; people = Arrays.asList( new Person(&quot;Dr. Bunsen&quot;, &quot;Honeydew&quot;), new Person(&quot;Gonzo&quot;, &quot;The Great&quot;), new Person(&quot;Phillip J.&quot;, &quot;Fry&quot;));</p>
<p>System.out.println(people);</p>
<p>Element root = new Element(&quot;people&quot;); for(Person p : people)</p>
<p>root.appendChild(p.getXML());</p>
<p>Document doc = new Document(root); format(System.out, doc);</p>
<p>format(new BufferedOutputStream(new FileOutputStream( &quot;People.xml&quot;)), doc);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[Dr. Bunsen Honeydew, Gonzo The Great, Phillip J. Fry]</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</p>
<p>&lt;people&gt;</p>
<p>&lt;person&gt;</p>
<p>&lt;first&gt;Dr. Bunsen&lt;/first&gt; &lt;last&gt;Honeydew&lt;/last&gt; &lt;/person&gt;</p>
<p>&lt;person&gt;</p>
<p>&lt;first&gt;Gonzo&lt;/first&gt; &lt;last&gt;The Great&lt;/last&gt; &lt;/person&gt;</p>
<p>&lt;person&gt;</p>
<p>&lt;first&gt;Phillip J.&lt;/first&gt; &lt;last&gt;Fry&lt;/last&gt;</p>
<p>&lt;/person&gt;</p>
<p>&lt;/people&gt;</p>
<p>*///:~</p>
<p>The XOM methods are fairly self-explanatory and can be found in the XOM documentation. XOM also contains a Serializer class that you can see used in the format( ) method to turn the XML into a more readable form. If you just call toXML( ) you’ll get everything run together, so the Serializer is a convenient tool.</p>
<p>Deserializing Person objects from an XML file is also simple:</p>
<p>//: xml/People.java</p>
<p>// {Requires: nu.xom.Node; You must install // the XOM library from <a l:href="http://www.xom.nu">http://www.xom.nu</a> }</p>
<p>// {RunFirst: Person} import nu.xom.*; import java.util.*;</p>
<p>public class People extends ArrayList&lt;Person&gt; { public People(String fileName) throws Exception {</p>
<p>Document doc = new Builder().build(fileName);</p>
<p>Elements elements =</p>
<p>doc.getRootElement().getChildElements(); for(int i = 0; i &lt; elements.size(); i++) add(new Person(elements.get(i)));</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>People p = new People(&quot;People.xml&quot;);</p>
<p>System.out.println(p);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[Dr. Bunsen Honeydew, Gonzo The Great, Phillip J. Fry]</p>
<p>*///:~</p>
<p>The People constructor opens and reads a file using XOM’s Builder.build( ) method, and the getChildElements( ) method produces an Elements list (not a standard Java List, but an object that only has a size( ) and get( ) method—Harold did not want to force people to use Java SE5, but still wanted a type-safe container). Each Element in this list represents a Person object, so it is handed to the second Person constructor. Note that this requires that you know ahead of time the exact structure of your XML file, but this is often true with these kinds of problems. If the structure doesn’t match what you expect, XOM will throw an exception. It’s also possible for you to write more complex code that will explore the XML document rather than making assumptions about it, for cases when you have less concrete information about the incoming XML structure.</p>
<p>In order to get these examples to compile, you will have to put the JAR files from the XOM distribution into your classpath.</p>
<p>This has only been a brief introduction to XML programming with Java and the XOM library; for more information see <a l:href="http://www.xom.nu">www.xom.nu</a>.</p>
<p>Exercise 31: (2) Add appropriate address information to Person.java and People.java.</p>
<p>Exercise 32: (4) Using a Map&lt;String,Integer&gt; and the</p>
<p>net.mindview.util.TextFile utility, write a program that counts the occurrence of words in a file (use &quot;\\W+&quot; as the second argument to the TextFile constructor). Store the results as an XML file.</p>
</section>
<section>
<title>
<p>Preferences</p></title><empty-line/>
<p>The Preferences API is much closer to persistence than it is to object serialization, because it automatically stores and retrieves your information. However, its use is restricted to small and limited data sets—you can only hold primitives and Strings, and the length of each stored String can’t be longer than 8K (not tiny, but you don’t want to build anything serious with it, either). As the name suggests, the Preferences API is designed to store and retrieve user preferences and program-configuration settings.</p>
<p>Preferences are key-value sets (like Maps) stored in a hierarchy of nodes. Although the node hierarchy can be used to create complicated structures, it’s typical to create a single node named after your class and store the information there. Here’s a simple example:</p>
<p>//: io/PreferencesDemo.java</p>
<p>import java.util.prefs.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class PreferencesDemo {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>Preferences prefs = Preferences</p>
<p>.userNodeForPackage(PreferencesDemo.class); prefs.put(&quot;Location&quot;, &quot;Oz&quot;); prefs.put(&quot;Footwear&quot;, &quot;Ruby Slippers&quot;); prefs.putInt(&quot;Companions&quot;, 4); prefs.putBoolean(&quot;Are there witches?&quot;, true); int usageCount = prefs.getInt(&quot;UsageCount&quot;, 0); usageCount++;</p>
<p>prefs.putInt(&quot;UsageCount&quot;, usageCount); for(String key : prefs.keys())</p>
<p>print(key + &quot;: &quot;+ prefs.get(key, null));</p>
<p>// You must always provide a default value: print(&quot;How many companions does Dorothy have? &quot; + prefs.getInt(&quot;Companions&quot;, 0));</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Location: Oz</p>
<p>Footwear: Ruby Slippers</p>
<p>Companions: 4</p>
<p>Are there witches?: true</p>
<p>UsageCount: 53</p>
<p>How many companions does Dorothy have? 4 *///:~</p>
<p>Here, userNodeForPackage( ) is used, but you could also choose</p>
<p>systemNodeForPackage( ); the choice is somewhat arbitrary, but the idea is that &quot;user&quot; is for individual user preferences, and &quot;system&quot; is for general installation configuration. Since main( ) is static, PreferencesDemo.class is used to identify the node, but inside a nonstatic method, you’ll usually use getClass( ). You don’t need to use the current class as the node identifier, but that’s the usual practice.</p>
<p>Once you create the node, it’s available for either loading or reading data. This example loads the node with various types of items and then gets the keys( ). These come back as a String[], which you might not expect if you’re used to the keys( ) method in the collections library. Notice the second argument to get( ). This is the default value that is produced if there isn’t any entry for that key value. While iterating through a set of keys, you always know there’s an entry, so using null as the default is safe, but normally you’ll be fetching a named key, as in:</p>
<p>prefs.getInt(&quot;Companions&quot;, 0));</p>
<p>In the normal case, you’ll want to provide a reasonable default value. In fact, a typical idiom is seen in the lines:</p>
<p>int usageCount = prefs.getInt(&quot;UsageCount&quot;, 0); usageCount++;</p>
<p>prefs.putInt(&quot;UsageCount&quot;, usageCount);</p>
<p>This way, the first time you run the program, the UsageCount will be zero, but on subsequent invocations it will be nonzero.</p>
<p>When you run PreferencesDemo.java you’ll see that the UsageCount does indeed increment every time you run the program, but where is the data stored? There’s no local file that appears after the program is run the first time. The Preferences API uses appropriate system resources to accomplish its task, and these will vary depending on the OS. In Windows, the registry is used (since it’s already a hierarchy of nodes with key-value pairs). But the whole point is that the information is magically stored for you so that you don’t have to worry about how it works from one system to another.</p>
<p>There’s more to the Preferences API than shown here. Consult the JDK documentation, which is fairly understandable, for further details.</p>
<p>Exercise 33: (2) Write a program that displays the current value of a directory called &quot;base directory&quot; and prompts you for a new value. Use the Preferences API to store the value.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>The Java I/O stream library does satisfy the basic requirements: You can perform reading and writing with the console, a file, a block of memory, or even across the Internet. With inheritance, you can create new types of input and output objects. And you can even add a simple extensibility to the kinds of objects a stream will accept by redefining the toString( ) method that’s automatically called when you pass an object to a method that’s expecting a String (Java’s limited &quot;automatic type conversion&quot;).</p>
<p>There are questions left unanswered by the documentation and design of the I/O stream library. For example, it would have been nice if you could say that you want an exception thrown if you try to overwrite a file when opening it for output-some programming systems allow you to specify that you want to open an output file, but only if it doesn’t already exist.</p>
<p>In Java, it appears that you are supposed to use a File object to determine whether a file exists, because if you open it as a FileOutputStream or FileWriter, it will always get overwritten.</p>
<p>The I/O stream library brings up mixed feelings; it does much of the job and it’s portable. But if you don’t already understand the Decorator design pattern, the design is not intuitive, so there’s extra overhead in learning and teaching it. It’s also incomplete; for example, I shouldn’t have to write utilities like TextFile (the new Java SE5 PrintWriter is a step in the right direction here, but is only a partial solution). There has been a big improvement in</p>
<p>Java SE5: They’ve finally added the kind of output formatting that virtually every other language has always supported.</p>
<p>Once you do understand the Decorator pattern and begin using the library in situations that require its flexibility, you can begin to benefit from this design, at which point its cost in extra lines of code may not bother you as much.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Enumerated Types</p></title><empty-line/>
<p>The enum keyword allows you to create a new type with a restricted set of named values, and to treat those values as regular program components. This turns out to be very useful.<sup>1</sup></p>
<p>Enumerations were introduced briefly at the end of Initialization &amp; Cleanup. However, now that you understand some of the deeper issues in Java, we can take a more detailed look at the Java SE5 enumeration feature. You’ll see that there are some very interesting things that you can do with enums, but this chapter should also give you more insight into other language features that you’ve now seen, such as generics and reflection. You’ll also learn a few more design patterns.</p>
<section>
<title>
<p>Basic enum features</p></title><empty-line/>
<p>As shown in Initialization &amp; Cleanup, you can step through the list of enum constants by calling values( ) on the enum. The values( ) method produces an array of the enum constants in the order in which they were declared, so you can use the resulting array in (for example) a foreach loop.</p>
<p>When you create an enum, an associated class is produced for you by the compiler. This class is automatically inherited from java.lang.Enum, which provides certain capabilities that you can see in this example:</p>
<p>//: enumerated/EnumClass.java // Capabilities of the Enum class import static net.mindview.util.Print.*;</p>
<p>enum Shrubbery { GROUND, CRAWLING, HANGING }</p>
<p>public class EnumClass {</p>
<p>public static void main(String[] args) { for(Shrubbery s : Shrubbery.values()) { print(s + &quot; ordinal: &quot; + s.ordinal()); printnb(s.compareTo(Shrubbery.CRAWLING) + &quot; &quot;); printnb(s.equals(Shrubbery.CRAWLING) + &quot; &quot;); print(s == Shrubbery.CRAWLING); print(s.getDeclaringClass()); print(s.name());</p>
<p>print(&quot;----------------------&quot;);</p>
<p>}</p>
<p>// Produce an enum value from a string name: for(String s : &quot;HANGING CRAWLING GROUND&quot;.split(&quot; &quot;)) {</p>
<p>Shrubbery shrub = Enum.valueOf(Shrubbery.class, s); print(shrub);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>GROUND ordinal: 0 -1 false false class Shrubbery</p>
<p>Joshua Bloch was extremely helpful in developing this chapter.</p>
<p>GROUND</p>
<p>CRAWLING ordinal: 1 0 true true class Shrubbery CRAWLING</p>
<p>HANGING ordinal: 2 1 false false class Shrubbery HANGING</p>
<p>HANGING</p>
<p>CRAWLING</p>
<p>GROUND</p>
<p>*///:~</p>
<p>The ordinal( ) method produces an int indicating the declaration order of each enum instance, starting from zero. You can always safely compare enum instances using ==, and equals( ) and hashCode( ) are automatically created for you. The Enum class is Comparable, so there’s a compareTo( ) method, and it is also Serializable.</p>
<p>If you call getDeclaringClass( ) on an enum instance, you’ll find out the enclosing enum class.</p>
<p>The name( ) method produces the name exactly as it is declared, and this is what you get with toString( ), as well. valueOf( ) is a static member of Enum, and produces the enum instance that corresponds to the String name you pass to it, or throws an exception if there’s no match.</p>
<subtitle>Using static imports with enums</subtitle>
<p>Consider a variation of Burrito.java from the Initialization &amp; Cleanup chapter:</p>
<p>//: enumerated/Spiciness.java package enumerated;</p>
<p>public enum Spiciness {</p>
<p>NOT, MILD, MEDIUM, HOT, FLAMING } ///:~</p>
<p>//: enumerated/Burrito.java package enumerated;</p>
<p>import static enumerated.Spiciness.*;</p>
<p>public class Burrito {</p>
<p>Spiciness degree;</p>
<p>public Burrito(Spiciness degree) { this.degree = degree;} public String toString() { return &quot;Burrito is &quot;+ degree;} public static void main(String[] args) {</p>
<p>System.out.println(new Burrito(NOT));</p>
<p>System.out.println(new Burrito(MEDIUM));</p>
<p>System.out.println(new Burrito(HOT));</p>
<p>}</p>
<p>} /* Output:</p>
<p>Burrito is NOT Burrito is MEDIUM Burrito is HOT *///:~</p>
<p>The static import brings all the enum instance identifiers into the local namespace, so they don’t need to be qualified. Is this a good idea, or is it better to be explicit and qualify all enum instances? It probably depends on the complexity of your code. The compiler certainly won’t let you use the wrong type, so your only concern is whether the code will be confusing to the reader. In many situations it will probably be fine but you should evaluate it on an individual basis.</p>
<p>Note that it is not possible to use this technique if the enum is defined in the same file or the default package (apparently there were some arguments within Sun about whether to allow this).</p>
</section>
<section>
<title>
<p>Adding methods to an enum</p></title><empty-line/>
<p>Except for the fact that you can’t inherit from it, an enum can be treated much like a regular class. This means that you can add methods to an enum. It’s even possible for an enum to have a main( ).</p>
<p>You may want to produce different descriptions for an enumeration than the default toString( ), which simply produces the name of that enum instance, as you’ve seen. To do this, you can provide a constructor to capture extra information, and additional methods to provide an extended description, like this:</p>
<p>//: enumerated/OzWitch.java // The witches in the land of Oz. import static net.mindview.util.Print.*;</p>
<p>public enum OzWitch {</p>
<p>// Instances must be defined first, before methods:</p>
<p>WEST(&quot;Miss Gulch, aka the Wicked Witch of the West&quot;),</p>
<p>NORTH(&quot;Glinda, the Good Witch of the North&quot;),</p>
<p>EAST(&quot;Wicked Witch of the East, wearer of the Ruby &quot; +</p>
<p>&quot;Slippers, crushed by Dorothy’s house&quot;),</p>
<p>SOUTH(&quot;Good by inference, but missing&quot;); private String description;</p>
<p>// Constructor must be package or private access: private OzWitch(String description) { this.description = description;</p>
<p>}</p>
<p>public String getDescription() { return description; } public static void main(String[] args) { for(OzWitch witch : OzWitch.values())</p>
<p>print(witch + &quot;: &quot; + witch.getDescription());</p>
<p>}</p>
<p>} /* Output:</p>
<p>WEST: Miss Gulch, aka the Wicked Witch of the West NORTH: Glinda, the Good Witch of the North</p>
<p>EAST: Wicked Witch of the East, wearer of the Ruby Slippers, crushed by Dorothy’s house</p>
<p>SOUTH: Good by inference, but missing *///:~</p>
<p>Notice that if you are going to define methods you must end the sequence of enum instances with a semicolon. Also, Java forces you to define the instances as the first thing in the enum. You’ll get a compile-time error if you try to define them after any of the methods or fields.</p>
<p>The constructor and methods have the same form as a regular class, because with a few restrictions this is a regular class. So you can do pretty much anything you want with enums (although you’ll usually keep them pretty ordinary).</p>
<p>Although the constructor has been made private here as an example, it doesn’t make much difference what access you use—the constructor can only be used to create the enum instances that you declare inside the enum definition; the compiler won’t let you use it to create any new instances once the enum definition is complete.</p>
<subtitle>Overriding enum methods</subtitle>
<p>Here’s another approach to producing different string values for enumerations. In this case, the instance names are OK but we want to reformat them for display. Overriding the toString( ) method for an enum is the same as overriding it for a regular class:</p>
<p>//: enumerated/SpaceShip.java public enum Spaceship {</p>
<p>SCOUT, CARGO, TRANSPORT, CRUISER, BATTLESHIP, MOTHERSHIP; public String toString() {</p>
<p>String id = name();</p>
<p>String lower = id.substring(1).toLowerCase(); return id.charAt(0) + lower;</p>
<p>}</p>
<p>public static void main(String[] args) { for(SpaceShip s : values()) {</p>
<p>System.out.println(s);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Scout</p>
<p>Cargo</p>
<p>Transport</p>
<p>Cruiser</p>
<p>Battleship</p>
<p>Mothership</p>
<p>*///:~</p>
<p>The toString( ) method gets the Spaceship name by calling name( ), and modifies the result so that only the first letter is capitalized.</p>
</section>
<section>
<title>
<p>enums in switch statements</p></title><empty-line/>
<p>One very convenient capability of enums is the way that they can be used in switch statements. Ordinarily, a switch only works with an integral value, but since enums have an established integral order and the order of an instance can be produced with the ordinal( ) method (apparently the compiler does something like this), enums can be used in switch statements.</p>
<p>Although normally you must qualify an enum instance with its type, you do not have to do this in a case statement. Here’s an example that uses an enum to create a little state machine:</p>
<p>//: enumerated/TrafficLight.java</p>
<p>// Enums in switch statements.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>// Define an enum type:</p>
<p>enum Signal { GREEN, YELLOW, RED, }</p>
<p>public class TrafficLight {</p>
<p>Signal color = Signal.RED; public void change() {</p>
<p>switch(color) {</p>
<p>// Note that you don’t have to say Signal.RED // in the case statement: case RED:    color = Signal.GREEN;</p>
<p>break;</p>
<p>case GREEN:    color = Signal.YELLOW;</p>
<p>break;</p>
<p>case YELLOW: color = Signal.RED; break;</p>
<p>}</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;The traffic light is &quot; + color;</p>
<p>}</p>
<p>public static void main(String[] args) { TrafficLight t = new TrafficLight(); for(int i = 0; i &lt; 7; i++) { print(t); t.change();</p>
<p>}</p>
<table>
<tr><th colspan="5">}</th></tr>
<tr><td>} /*</td><td>Output:</td><td></td><td></td><td></td></tr>
<tr><td>The</td><td>traffic</td><td>light</td><td>is</td><td>RED</td></tr>
<tr><td>The</td><td>traffic</td><td>light</td><td>is</td><td>GREEN</td></tr>
<tr><td>The</td><td>traffic</td><td>light</td><td>is</td><td>YELLOW</td></tr>
<tr><td>The</td><td>traffic</td><td>light</td><td>is</td><td>RED</td></tr>
<tr><td>The</td><td>traffic</td><td>light</td><td>is</td><td>GREEN</td></tr>
<tr><td>The</td><td>traffic</td><td>light</td><td>is</td><td>YELLOW</td></tr>
<tr><td>The</td><td>traffic</td><td>light</td><td>is</td><td>RED</td></tr>
<tr><td>*///</td><td>:~</td><td></td><td></td><td></td></tr>
</table>
<p>The compiler does not complain that there is no default statement inside the switch, but that’s not because it notices that you have case statements for each Signal instance. If you comment out one of the case statements it still won’t complain. This means you will have to pay attention and ensure that you cover all the cases on your own. On the other hand, if you are calling return from case statements, the compiler will complain if you don’t have a default—even if you’ve covered all the possible values of the enum.</p>
<p>Exercise 1: (2) Use a static import to modify TrafficLight.java so you don’t have to qualify the enum instances.</p>
</section>
<section>
<title>
<p>The mystery of values()</p></title><empty-line/>
<p>As noted earlier, all enum classes are created for you by the compiler and extend the Enum class. However, if you look at Enum, you’ll see that there is no values( ) method, even though we’ve been using it. Are there any other &quot;hidden&quot; methods? We can write a small reflection program to find out:</p>
<p>//: enumerated/Reflection.java</p>
<p>// Analyzing enums using reflection.</p>
<p>import java.lang.reflect.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>enum Explore { HERE, THERE }</p>
<p>public class Reflection {</p>
<p>public static Set&lt;String&gt; analyze(Class&lt;?&gt; enumClass) { print(&quot;-----Analyzing &quot; + enumClass + &quot; -----&quot;);</p>
<p>print(&quot;Interfaces:&quot;);</p>
<p>for(Type t : enumClass.getGenericInterfaces()) print(t);</p>
<p>print(&quot;Base: &quot; + enumClass.getSuperclass()); print(&quot;Methods: &quot;);</p>
<p>Set&lt;String&gt; methods = new TreeSet&lt;String&gt;(); for(Method m : enumClass.getMethods()) methods.add(m.getName()); print(methods); return methods;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Set&lt;String&gt; exploreMethods = analyze(Explore.class);</p>
<p>Set&lt;String&gt; enumMethods = analyze(Enum.class); print(&quot;Explore.containsAll(Enum)? &quot; +</p>
<p>exploreMethods.containsAll(enumMethods)); printnb(&quot;Explore.removeAll(Enum): &quot;); exploreMethods.removeAll(enumMethods); print(exploreMethods);</p>
<p>// Decompile the code for the enum:</p>
<p>OSExecute.command(&quot;javap Explore&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>----- Analyzing class Explore -----</p>
<p>Interfaces:</p>
<p>Base: class java.lang.Enum Methods:</p>
<p>[compareTo, equals, getClass, getDeclaringClass, hashCode, name, notify, notifyAll, ordinal, toString, valueOf, values, wait]</p>
<p>----- Analyzing class java.lang.Enum -----</p>
<p>Interfaces:</p>
<p>java.lang.Comparable&lt;E&gt; interface java.io.Serializable Base: class java.lang.Object Methods:</p>
<p>[compareTo, equals, getClass, getDeclaringClass, hashCode, name, notify, notifyAll, ordinal, toString, valueOf, wait]</p>
<p>Explore.containsAll(Enum)? true Explore.removeAll(Enum): [values]</p>
<p>Compiled from &quot;Reflection.java&quot; final class Explore extends java.lang.Enum{ public static final Explore HERE; public static final Explore THERE; public static final Explore[] values(); public static Explore valueOf(java.lang.String); static {};</p>
<p>}</p>
<p>*///:~</p>
<p>So the answer is that values( ) is a static method that is added by the compiler. You can see that valueOf( ) is also added to Explore in the process of creating the enum. This is slightly confusing, because there’s also a valueOf( ) that is part of the Enum class, but that method has two arguments and the added method only has one. However, the use of the Set method here is only looking at method names, and not signatures, so after calling Explore.removeAll(Enum), the only thing that remains is [values].</p>
<p>In the output, you can see that Explore has been made final by the compiler, so you cannot inherit from an enum. There’s also a static initialization clause, which as you’ll see later can be redefined.</p>
<p>Because of erasure (described in the Generics chapter), the decompiler does not have full information about Enum, so it shows the base class of Explore as a raw Enum rather than the actual Enum&lt;Explore&gt;.</p>
<p>Because values( ) is a static method inserted into the enum definition by the compiler, if you upcast an enum type to Enum, the values( ) method will not be available. Notice, however, that there is a getEnumConstants( ) method in Class, so even if values( ) is not part of the interface of Enum, you can still get the enum instances via the Class object:</p>
<p>//: enumerated/UpcastEnum.java</p>
<p>// No values() method if you upcast an enum</p>
<p>enum Search { HITHER, YON }</p>
<p>public class UpcastEnum {</p>
<p>public static void main(String[] args) {</p>
<p>Search[] vals = Search.values();</p>
<p>Enum e = Search.HITHER; // Upcast // e.values(); // No values() in Enum for(Enum en : e.getClass().getEnumConstants()) System.out.println(en);</p>
<p>}</p>
<p>} /* Output:</p>
<p>HITHER</p>
<p>YON</p>
<p>*///:~</p>
<p>Because getEnumConstants( ) is a method of Class, you can call it for a class that has no enumerations:</p>
<p>//: enumerated/NonEnum.java</p>
<p>public class NonEnum {</p>
<p>public static void main(String[] args) {</p>
<p>Class&lt;Integer&gt; intClass = Integer.class; try {</p>
<p>for(Object en : intClass.getEnumConstants()) System.out.println(en);</p>
<p>} catch(Exception e) {</p>
<p>System.out.println(e);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>java.lang.NullPointerException</p>
<p>*///:~</p>
<p>However, the method returns null, so you get an exception if you try to use the result.</p>
</section>
<section>
<title>
<p>Implements, not inherits</p></title><empty-line/>
<p>We’ve established that all enums extend java.lang.Enum. Since Java does not support multiple inheritance, this means that you cannot create an enum via inheritance:</p>
<p>enum NotPossible extends Pet { ... // Won’t work</p>
<p>However, it is possible to create an enum that implements one or more interfaces:</p>
<p>//: enumerated/cartoons/Enumlmplementation.java // An enum can implement an interface package enumerated.cartoons; import java.util.*; import net.mindview.util.*;</p>
<p>enum CartoonCharacter</p>
<p>implements Generator&lt;CartoonCharacter&gt; {</p>
<p>SLAPPY, SPANKY, PUNCHY, SILLY, BOUNCY, NUTTY, BOB; private Random rand = new Random(47); public CartoonCharacter next() {</p>
<p>return values()[rand.nextInt(values().length)];</p>
<p>}</p>
<p>}</p>
<p>public class EnumImplementation {</p>
<p>public static &lt;T&gt; void printNext(Generator&lt;T&gt; rg) { System.out.print(rg.next() + &quot;, &quot;);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>// Choose any instance:</p>
<p>CartoonCharacter cc = CartoonCharacter.BOB; for(int i = 0; i &lt; 10; i++) printNext(cc);</p>
<p>}</p>
<p>} /* Output:</p>
<p>BOB, PUNCHY, BOB, SPANKY, NUTTY, PUNCHY, SLAPPY, NUTTY, NUTTY, SLAPPY, *///:~</p>
<p>The result is slightly odd, because to call a method you must have an instance of the enum to call it on. However, a CartoonCharacter can now be accepted by any method that takes a Generator; for example, printNext( ).</p>
<p>Exercise 2: (2) Instead of implementing an interface, make next( ) a static method. What are the benefits and drawbacks of this approach?</p>
</section>
<section>
<title>
<p>Random selection</p></title><empty-line/>
<p>Many of the examples in this chapter require random selection from among enum instances, as you saw in CartoonCharacter.next( ). It’s possible to generalize this task using generics and put the result in the common library:</p>
<p>//: net/mindview/util/Enums.java package net.mindview.util; import java.util.*;</p>
<p>public class Enums {</p>
<p>private static Random rand = new Random(47);</p>
<p>public static &lt;T extends Enum&lt;T&gt;&gt; T random(Class&lt;T&gt; ec) { return random(ec.getEnumConstants());</p>
<p>}</p>
<p>public static &lt;T&gt; T random(T[] values) { return values[rand.nextInt(values.length)];</p>
<p>}</p>
<p>} ///:~</p>
<p>The rather odd syntax &lt;T extends Enum&lt;T&gt;&gt; describes T as an enum instance. By passing in Class&lt;T&gt;, we make the class object available, and the array of enum instances can thus be produced. The overloaded random( ) method only needs to know that it is getting a T[] because it doesn’t need to perform Enum operations; it only needs to select an array element at random. The return type is the exact type of the enum.</p>
<p>Here’s a simple test of the random( ) method:</p>
<p>//: enumerated/RandomTest.java import net.mindview.util.*;</p>
<p>enum Activity { SITTING, LYING, STANDING, HOPPING,</p>
<p>RUNNING, DODGING, JUMPING, FALLING, FLYING }</p>
<p>public class RandomTest {</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 20; i++)</p>
<p>System.out.print(Enums.random(Activity.class) + &quot; &quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>STANDING FLYING RUNNING STANDING RUNNING STANDING LYING DODGING SITTING RUNNING HOPPING HOPPING HOPPING RUNNING STANDING LYING FALLING RUNNING FLYING LYING *///:~</p>
<p>Although Enums is a small class, you’ll see that it prevents a fair amount of duplication in this chapter. Duplication tends to produce mistakes, so eliminating duplication is a useful pursuit.</p>
</section>
<section>
<title>
<p>Using interfaces for organization</p></title><empty-line/>
<p>The inability to inherit from an enum can be a bit frustrating at times. The motivation for inheriting from an enum comes partly from wanting to extend the number of elements in the original enum, and partly from wanting to create subcategories by using subtypes.</p>
<p>You can achieve categorization by grouping the elements together inside an interface and creating an enumeration based on that interface. For example, suppose you have different classes of food that you’d like to create as enums, but you’d still like each one to be a type of Food. Here’s what it looks like:</p>
<p>//: enumerated/menu/Food.java</p>
<p>// Subcategorization of enums within interfaces. package enumerated.menu;</p>
<p>public interface Food {</p>
<p>enum Appetizer implements Food {</p>
<p>SALAD, SOUP, SPRING_ROLLS;</p>
<p>}</p>
<p>enum MainCourse implements Food {</p>
<p>LASAGNE, BURRITO, PAD_THAI,</p>
<p>LENTILS, HUMMOUS, VINDALOO;</p>
<p>}</p>
<p>enum Dessert implements Food {</p>
<p>TIRAMISU, GELATO, BLACK_FOREST_CAKE,</p>
<p>FRUIT, CREME_CARAMEL;</p>
<p>}</p>
<p>enum Coffee implements Food {</p>
<p>BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,</p>
<p>LATTE, CAPPUCCINO, TEA, HERB_TEA;</p>
<p>}</p>
<p>} ///:~</p>
<p>Since the only subtyping available for an enum is that of interface implementation, each nested enum implements the surrounding interface Food. Now it’s possible to say that &quot;everything is a type of Food&quot; as you can see here:</p>
<p>//: enumerated/menu/TypeOfFood.java</p>
<p>package enumerated.menu;</p>
<p>import static enumerated.menu.Food.*;</p>
<p>public class TypeOfFood {</p>
<p>public static void main(String[] args) {</p>
<p>Food food = Appetizer.SALAD; food = MainCourse.LASAGNE; food = Dessert.GELATO; food = Coffee.CAPPUCCINO;</p>
<p>}</p>
<p>} ///:~</p>
<p>The upcast to Food works for each enum type that implements Food, so they are all types of Food.</p>
<p>An interface, however, is not as useful as an enum when you want to deal with a set of types. If you want to have an &quot;enum of enums&quot; you can create a surrounding enum with one instance for each enum in Food:</p>
<p>//: enumerated/menu/Course.java package enumerated.menu;</p>
<p>import net.mindview.util.*;</p>
<p>public enum Course {</p>
<p>APPETIZER(Food.Appetizer.class),</p>
<p>MAINCOURSE(Food.MainCourse.class),</p>
<p>DESSERT(Food.Dessert.class),</p>
<p>COFFEE(Food.Coffee.class); private Food[] values;</p>
<p>private Course(Class&lt;? extends Food&gt; kind) { values = kind.getEnumConstants();</p>
<p>}</p>
<p>public Food randomSelection() { return Enums.random(values);</p>
<p>}</p>
<p>} ///:~</p>
<p>Each of the above enums takes the corresponding Class object as a constructor argument, from which it can extract and store all the enum instances using getEnumConstants( ). These instances are later used in randomSelection( ), so now we can create a randomly generated meal by selecting one Food item from each Course: //: enumerated/menu/Meal.java package enumerated.menu;</p>
<p>public class Meal {</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 5; i++) {</p>
<p>for(Course course : Course.values()) { Food food = course.randomSelection(); System.out.println(food);</p>
<p>}</p>
<p>System.out.println(&quot; —&quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>SPRING_ROLLS</p>
<p>VINDALOO</p>
<p>FRUIT</p>
<p>DECAF_COFFEE</p>
<p>SOUP</p>
<p>VINDALOO</p>
<p>FRUIT</p>
<p>TEA</p>
<p>SALAD</p>
<p>BURRITO</p>
<p>FRUIT</p>
<p>TEA</p>
<p>SALAD</p>
<p>BURRITO</p>
<p>CREME_CARAMEL</p>
<p>LATTE</p>
<p>SOUP</p>
<p>BURRITO</p>
<p>TIRAMISU</p>
<p>ESPRESSO *///:~</p>
<p>In this case, the value of creating an enum of enums is to iterate through each Course. Later, in the VendingMachine.java example, you’ll see another approach to categorization which is dictated by different constraints.</p>
<p>Another, more compact, approach to the problem of categorization is to nest enums within enums, like this:</p>
<p>//: enumerated/SecurityCategory.java // More succinct subcategorization of enums. import net.mindview.util.*;</p>
<p>enum SecurityCategory {</p>
<p>STOCK(Security.Stock.class), BOND(Security.Bond.class);</p>
<p>Security[] values;</p>
<p>SecurityCategory(Class&lt;? extends Security&gt; kind) { values = kind.getEnumConstants();</p>
<p>}</p>
<p>interface Security {</p>
<p>enum Stock implements Security { SHORT, LONG, MARGIN } enum Bond implements Security { MUNICIPAL, JUNK }</p>
<p>}</p>
<p>public Security randomSelection() { return Enums.random(values);</p>
<p>}</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 10; i++) {</p>
<p>SecurityCategory category =</p>
<p>Enums.random(SecurityCategory.class);</p>
<p>System.out.println(category + &quot;: &quot; + category.randomSelection());</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>BOND: MUNICIPAL BOND: MUNICIPAL STOCK: MARGIN STOCK: MARGIN BOND: JUNK STOCK: SHORT STOCK: LONG STOCK: LONG BOND: MUNICIPAL BOND: JUNK *///:~</p>
<p>The Security interface is necessary to collect the contained enums together as a common type. These are then categorized into the enums within SecurityCategory.</p>
<p>If we take this approach with the Food example, the result is:</p>
<p>//: enumerated/menu/Meal2.java package enumerated.menu; import net.mindview.util.*;</p>
<p>public enum Meal2 {</p>
<p>APPETIZER(Food.Appetizer.class),</p>
<p>MAINCOURSE(Food.MainCourse.class),</p>
<p>DESSERT(Food.Dessert.class),</p>
<p>COFFEE(Food.Coffee.class); private Food[] values;</p>
<p>private Meal2(Class&lt;? extends Food&gt; kind) {</p>
<p>values = kind.getEnumConstants();</p>
<p>public interface Food {</p>
<p>enum Appetizer implements Food {</p>
<p>SALAD, SOUP, SPRING_ROLLS;</p>
<p>}</p>
<p>enum MainCourse implements Food {</p>
<p>LASAGNE, BURRITO, PAD_THAI,</p>
<p>LENTILS, HUMMOUS, VINDALOO;</p>
<p>}</p>
<p>enum Dessert implements Food {</p>
<p>TIRAMISU, GELATO, BLACK_FOREST_CAKE,</p>
<p>FRUIT, CREME_CARAMEL;</p>
<p>}</p>
<p>enum Coffee implements Food {</p>
<p>BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,</p>
<p>LATTE, CAPPUCCINO, TEA, HERB_TEA;</p>
<p>}</p>
<p>}</p>
<p>public Food randomSelection() { return Enums.random(values);</p>
<p>}</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 5; i++) {</p>
<p>for(Meal2 meal : Meal2.values()) {</p>
<p>Food food = meal.randomSelection();</p>
<p>System.out.println(food);</p>
<p>}</p>
<p>System.out.println(&quot; —&quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* Same output as Meal.java *///:~</p>
<p>In the end, it’s only a reorganization of the code but it may produce a clearer structure in some cases.</p>
<p>Exercise 3: (1) Add a new Course to Course.java and demonstrate that it works in Meal.java.</p>
<p>Exercise 4: (1) Repeat the above exercise for Meal2.java.</p>
<p>Exercise 5: (4) Modify control/VowelsAndConsonants.java so that it uses three enum types: VOWEL, SOMETIMES_A_VOWEL, and CONSONANT. The enum</p>
<p>constructor should take the various letters that describe that particular category. Hint: Use varargs, and remember that varargs automatically creates an array for you.</p>
<p>Exercise 6: (3) Is there any special benefit in nesting Appetizer, MainCourse, Dessert, and Coffee inside Food rather than making them standalone enums that just happen to implement Food?</p>
</section>
<section>
<title>
<p>Using EnumSet instead of flags</p></title><empty-line/>
<p>A Set is a kind of collection that only allows one of each type of object to be added. Of course, an enum requires that all its members be unique, so it would seem to have set behavior, but since you can’t add or remove elements it’s not very useful as a set. The EnumSet was added to Java SE5 to work in concert with enums to create a replacement for traditional int-based &quot;bit flags.&quot; Such flags are used to indicate some kind of on-off information, but you end up manipulating bits rather than concepts, so it’s easy to write confusing code.</p>
<p>The EnumSet is designed for speed, because it must compete effectively with bit flags (operations will be typically much faster than a HashSet). Internally, it is represented by (if possible) a single long that is treated as a bit-vector, so it’s extremely fast and efficient. The benefit is that you now have a much more expressive way to indicate the presence or absence of a binary feature, without having to worry about performance.</p>
<p>The elements of an EnumSet must come from a single enum. A possible example uses an enum of positions in a building where alarm sensors are present:</p>
<p>//: enumerated/AlarmPoints.java package enumerated; public enum AlarmPoints {</p>
<p>STAIR1, STAIR2, LOBBY, OFFICE1, OFFICE2, OFFICE3,</p>
<p>OFFICE4, BATHROOM, UTILITY, KITCHEN } ///:~</p>
<p>The EnumSet can be used to keep track of the alarm status:</p>
<p>//: enumerated/EnumSets.java // Operations on EnumSets package enumerated; import java.util.*;</p>
<p>import static enumerated.AlarmPoints.*; import static net.mindview.util.Print.*;</p>
<p>public class EnumSets {</p>
<p>public static void main(String[] args) {</p>
<p>EnumSet&lt;AlarmPoints&gt; points =</p>
<p>EnumSet.noneOf(AlarmPoints.class); // Empty set points.add(BATHROOM); print(points);</p>
<p>points.addAll(EnumSet.of(STAIR1, STAIR2, KITCHEN)); print(points);</p>
<p>points = EnumSet.allOf(AlarmPoints.class); points.removeAll(EnumSet.of(STAIR1, STAIR2, KITCHEN)); print(points);</p>
<p>points.removeAll(EnumSet.range(OFFICE1, OFFICE4)); print(points);</p>
<p>points = EnumSet.complementOf(points); print(points);</p>
<p>}</p>
<p>} /* Output:</p>
<p>[BATHROOM]</p>
<p>[STAIR1, STAIR2, BATHROOM, KITCHEN]</p>
<p>[LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM, UTILITY]</p>
<p>[LOBBY, BATHROOM, UTILITY]</p>
<p>[STAIR1, STAIR2, OFFICE1, OFFICE2, OFFICE3, OFFICE4, KITCHEN]</p>
<p>*///:~</p>
<p>A static import is used to simplify the use of the enum constants. The method names are fairly self-explanatory, and you can find the full details in the JDK documentation. When you look at this documentation, you’ll see something interesting—the of( ) method has been overloaded both with varargs and with individual methods taking two through five explicit arguments. This is an indication of the concern for performance with EnumSet, because a single of( ) method using varargs could have solved the problem, but it’s slightly less efficient than having explicit arguments. Thus, if you call of( ) with two through five arguments you will get the explicit (slightly faster) method calls, but if you call it with one argument or more than five, you will get the varargs version of of( ). Notice that if you call it with one argument, the compiler will not construct the varargs array and so there is no extra overhead for calling that version with a single argument.</p>
<p>EnumSets are built on top of longs, a long is 64 bits, and each enum instance requires one bit to indicate presence or absence. This means you can have an EnumSet for an enum of up to 64 elements without going beyond the use of a single long. What happens if you have more than 64 elements in your enum?</p>
<p>//: enumerated/BigEnumSet.java import java.util.*;</p>
<p>public class BigEnumSet {</p>
<p>enum Big { A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10,</p>
<p>public static void main(String[] args) {</p>
<p>EnumSet&lt;Big&gt; bigEnumSet = EnumSet.allOf(Big.class); System.out.println(bigEnumSet);</p>
<p>}</p>
<p>} /* Output:</p>
<p>*///:~</p>
<p>The EnumSet clearly has no problem with an enum that has more than 64 elements, so we may presume that it adds another long when necessary.</p>
<p>Exercise 7: (3) Find the source code for EnumSet and explain how it works.</p>
</section>
<section>
<title>
<p>Using EnumMap</p></title><empty-line/>
<p>An EnumMap is a specialized Map that requires that its keys be from a single enum. Because of the constraints on an enum, an EnumMap can be implemented internally as an array. Thus they are extremely fast, so you can freely use EnumMaps for enum-based lookups.</p>
<p>You can only call put( ) for keys that are in your enum, but other than that it’s like using an ordinary Map.</p>
<p>Here’s an example that demonstrates the use of the Command design pattern. This pattern starts with an interface containing (typically) a single method, and creates multiple implementations with different behavior for that method. You install Command objects, and your program calls them when necessary:</p>
<p>//: enumerated/EnumMaps.java // Basics of EnumMaps. package enumerated; import java.util.*;</p>
<p>import static enumerated.AlarmPoints.*; import static net.mindview.util.Print.*;</p>
<p>interface Command { void action(); }</p>
<p>public class EnumMaps {</p>
<p>public static void main(String[] args) { EnumMap&lt;AlarmPoints,Command&gt; em =</p>
<p>new EnumMap&lt;AlarmPoints,Command&gt;(AlarmPoints.class); em.put(KITCHEN, new Command() {</p>
<p>public void action() { print(&quot;Kitchen fire!&quot;); }</p>
<p>});</p>
<p>em.put(BATHROOM, new Command() {</p>
<p>public void action() { print(&quot;Bathroom alert!&quot;); }</p>
<p>});</p>
<p>for(Map.Entry&lt;AlarmPoints,Command&gt; e : em.entrySet()) { printnb(e.getKey() + &quot;: &quot;); e.getValue().action();</p>
<p>}</p>
<p>try { // If there’s no value for a particular key: em.get(UTILITY).action();</p>
<p>} catch(Exception e) { print(e);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>BATHROOM: Bathroom alert!</p>
<p>KITCHEN: Kitchen fire! java.lang.NullPointerException *///:~</p>
<p>Just as with EnumSet, the order of elements in the EnumMap is determined by their order of definition in the enum.</p>
<p>The last part of main( ) shows that there is always a key entry for each of the enums, but the value is null unless you have called put( ) for that key.</p>
<p>One advantage of EnumMap over constant-specific methods (described next) is that an EnumMap allows you to change the value objects, whereas you’ll see that constant-specific methods are fixed at compile time.</p>
<p>As you’ll see later in the chapter, EnumMaps can be used to perform multiple dispatching for situations where you have multiple types of enums interacting with each other.</p>
</section>
<section>
<title>
<p>Constant-specific methods</p></title><empty-line/>
<p>Java enums have a very interesting feature that allows you to give each enum instance different behavior by creating methods for each one. To do this, you define one or more abstract methods as part of the enum, then define the methods for each enum instance. For example:</p>
<p>//: enumerated/ConstantSpecificMethod.java import java.util.*; import java.text.*;</p>
<p>public enum ConstantSpecificMethod {</p>
<p>DATE_TIME {</p>
<p>String getInfo() { return</p>
<p>DateFormat.getDateInstance().format(new Date());</p>
<p>}</p>
<p>},</p>
<p>CLASSPATH {</p>
<p>String getInfo() {</p>
<p>return System.getenv(&quot;CLASSPATH&quot;);</p>
<p>},</p>
<p>VERSION {</p>
<p>String getInfo() {</p>
<p>return System.getProperty(&quot;java.version&quot;);</p>
<p>}</p>
<p>};</p>
<p>abstract String getInfo(); public static void main(String[] args) { for(ConstantSpecificMethod csm : values()) System.out.println(csm.getInfo());</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>You can look up and call methods via their associated enum instance. This is often called table-driven code (and note the similarity to the aforementioned Command pattern).</p>
<p>In object-oriented programming, different behavior is associated with different classes. Because each instance of an enum can have its own behavior via constant-specific methods, this suggests that each instance is a distinct type. In the above example, each enum instance is being treated as the &quot;base type&quot; ConstantSpecificMethod but you get polymorphic behavior with the method call getInfo( ).</p>
<p>However, you can only take the similarity so far. You cannot treat enum instances as class types:</p>
<p>//: enumerated/NotClasses.java // {Exec: javap -c LikeClasses} import static net.mindview.util.Print.*;</p>
<p>enum LikeClasses {</p>
<p>WINKEN { void behavior() { print(&quot;Behavior1&quot;); } },</p>
<p>BLINKEN { void behavior() { print(&quot;Behavior2&quot;); } },</p>
<p>NOD { void behavior() { print(&quot;Behavior3&quot;); } }; abstract void behavior();</p>
<p>}</p>
<p>public class NotClasses {</p>
<p>// void f1(LikeClasses.WINKEN instance) {} // Nope } /* Output:</p>
<p>Compiled from &quot;NotClasses.java&quot;</p>
<p>abstract class LikeClasses extends java.lang.Enum{ public    static    final    LikeClasses    WINKEN;</p>
<p>public    static    final    LikeClasses    BLINKEN;</p>
<p>public    static    final    LikeClasses    NOD;</p>
<p>*///:~</p>
<p>In f1( ), you can see that the compiler doesn’t allow you to use an enum instance as a class type, which makes sense if you consider the code generated by the compiler-each enum element is a static final instance of LikeClasses.</p>
<p>Also, because they are static, enum instances of inner enums do not behave like ordinary inner classes; you cannot access non-static fields or methods in the outer class.</p>
<p>As a more interesting example, consider a car wash. Each customer is given a menu of choices for their wash, and each option performs a different action. A constant-specific method can be associated with each option, and an EnumSet can be used to hold the customer’s selections:</p>
<p>//: enumerated/CarWash.java import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class CarWash { public enum Cycle {</p>
<p>UNDERBODY {</p>
<p>}</p>
<p>}</p>
<p>void action() { print(&quot;Spraying the underbody&quot;)</p>
<p>},</p>
<p>WHEELWASH {</p>
<p>void action() { print(&quot;Washing the wheels&quot;); }</p>
<p>},</p>
<p>PREWASH {</p>
<p>void action() { print(&quot;Loosening the dirt&quot;); }</p>
<p>},</p>
<p>BASIC {</p>
<p>void action() { print(&quot;The basic wash&quot;); }</p>
<p>},</p>
<p>HOTWAX {</p>
<p>void action() { print(&quot;Applying hot wax&quot;); }</p>
<p>},</p>
<p>RINSE {</p>
<p>void action() { print(&quot;Rinsing&quot;); }</p>
<p>},</p>
<p>BLOWDRY {</p>
<p>void action() { print(&quot;Blowing dry&quot;); }</p>
<p>};</p>
<p>abstract void action();</p>
<p>}</p>
<p>EnumSet&lt;Cycle&gt; cycles =</p>
<p>EnumSet.of(Cycle.BASIC, Cycle.RINSE); public void add(Cycle cycle) { cycles.add(cycle); } public void washCar() { for(Cycle c : cycles) c.action();</p>
<p>}</p>
<p>public String toString() { return cycles.toString(); public static void main(String[] args) {</p>
<p>CarWash wash = new CarWash();</p>
<p>print(wash);</p>
<p>wash.washCar();</p>
<p>// Order of addition is unimportant: wash.add(Cycle.BLOWDRY);</p>
<p>wash.add(Cycle.BLOWDRY); // Duplicates ignored</p>
<p>wash.add(Cycle.RINSE);</p>
<p>wash.add(Cycle.HOTWAX);</p>
<p>print(wash);</p>
<p>wash.washCar();</p>
<p>}</p>
<p>} /* Output: [BASIC, RINSE]</p>
<p>The basic wash Rinsing</p>
<p>[BASIC, HOTWAX, RINSE, BLOWDRY]</p>
<p>The basic wash Applying hot wax Rinsing Blowing dry *///:~</p>
<p>The syntax for defining a constant-specific method is effectively that of an anonymous inner class, but more succinct.</p>
<p>This example also shows more characteristics of EnumSets. Since it’s a set, it will only hold one of each item, so duplicate calls to add( ) with the same argument are ignored (this makes sense, since you can only flip a bit &quot;on&quot; once). Also, the order that you add enum instances is unimportant—the output order is determined by the declaration order of the enum.</p>
<p>Is it possible to override constant-specific methods, instead of implementing an abstract method? Yes, as you can see here:</p>
<p>//: enumerated/OverrideConstantSpecific.java import static net.mindview.util.Print.*;</p>
<p>public enum OverrideConstantSpecific {</p>
<p>NUT, BOLT,</p>
<p>WASHER {</p>
<p>void f() { print(&quot;Overridden method&quot;); }</p>
<p>};</p>
<p>void f() { print(&quot;default behavior&quot;); } public static void main(String[] args) {</p>
<p>for(OverrideConstantSpecific ocs : values()) { printnb(ocs + &quot;: &quot;); ocs.f();</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>NUT: default behavior BOLT: default behavior WASHER: Overridden method *///:~</p>
<p>Although enums do prevent certain types of code, in general you should experiment with them as if they were classes.</p>
<p>Chain of Responsibility with enums</p>
<p>In the Chain of Responsibility design pattern, you create a number of different ways to solve a problem and chain them together. When a request occurs, it is passed along the chain until one of the solutions can handle the request.</p>
<p>You can easily implement a simple Chain of Responsibility with constantspecific methods. Consider a model of a post office, which tries to deal with each piece of mail in the most general way possible, but has to keep trying until it ends up treating the mail as a dead letter. Each attempt can be thought of as a Strategy (another design pattern), and the entire list together is a Chain of Responsibility.</p>
<p>We start by describing a piece of mail. All the different characteristics of interest can be expressed using enums. Because the Mail objects will be randomly generated, the easiest way to reduce the probability of (for example) a piece of mail being given a YES for GeneralDelivery is to create more non-YES instances, so the enum definitions look a little funny at first.</p>
<p>Within Mail, you’ll see randomMail( ), which creates random pieces of test mail. The generator( ) method produces an Iterable object that uses randomMail( ) to produce a number of mail objects, one each time you call next( ) via the iterator. This construct allows the simple creation of a foreach loop by calling Mail.generator( ):</p>
<p>//: enumerated/PostOffice.java // Modeling a post office.</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Mail {</p>
<p>// The NO’s lower the probability of random selection: enum GeneralDelivery {YES,NO1,NO2,NO3,NO4,NO5} enum Scannability {UNSCANNABLE,YES1,YES2,YES3,YES4} enum Readability {ILLEGIBLE,YES1,YES2,YES3,YES4} enum Address {INCORRECT,OK1,OK2,OK3,OK4,OK5,OK6} enum ReturnAddress {MISSING,OK1,OK2,OK3,OK4,OK5} GeneralDelivery generalDelivery;</p>
<p>Scannability scannability;</p>
<p>Readability readability;</p>
<p>Address address;</p>
<p>ReturnAddress returnAddress; static long counter = 0; long id = counter++;</p>
<p>public String toString() { return &quot;Mail &quot; + id; } public String details() { return toString() +</p>
<p>&quot;, General Delivery: &quot; + generalDelivery +</p>
<p>&quot;, Address Scanability: &quot; + scannability +</p>
<p>&quot;, Address Readability: &quot; + readability +</p>
<p>&quot;, Address Address: &quot; + address +</p>
<p>&quot;, Return address: &quot; + returnAddress;</p>
<p>}</p>
<p>// Generate test Mail:</p>
<p>public static Mail randomMail() {</p>
<p>Mail m = new Mail();</p>
<p>m.generalDelivery= Enums.random(GeneralDelivery.class); m.scannability = Enums.random(Scannability.class); m.readability = Enums.random(Readability.class); m.address = Enums.random(Address.class); m.returnAddress = Enums.random(ReturnAddress.class); return m;</p>
<p>}</p>
<p>public static Iterable&lt;Mail&gt; generator(final int count) { return new Iterable&lt;Mail&gt;() { int n = count;</p>
<p>public Iterator&lt;Mail&gt; iterator() { return new Iterator&lt;Mail&gt;() {</p>
<p>public boolean hasNext() { return n-- &gt; 0; } public Mail next() { return randomMail(); } public void remove() { // Not implemented throw new UnsupportedOperationException();</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>}</p>
<p>public class PostOffice { enum MailHandler {</p>
<p>GENERAL_DELIVERY {</p>
<p>boolean handle(Mail m) { switch(m.generalDelivery) { case YES:</p>
<p>print(&quot;Using general delivery for &quot; + m); return true; default: return false;</p>
<p>}</p>
<p>},</p>
<p>MACHINE_SCAN {</p>
<p>boolean handle(Mail m) { switch(m.scannability) {</p>
<p>case UNSCANNABLE: return false; default:</p>
<p>switch(m.address) {</p>
<p>case INCORRECT: return false; default:</p>
<p>print(&quot;Delivering &quot;+ m + &quot; automatically&quot;); return true;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>},</p>
<p>VISUAL_INSPECTION {</p>
<p>boolean handle(Mail m) { switch(m.readability) {</p>
<p>case ILLEGIBLE: return false; default:</p>
<p>switch(m.address) {</p>
<p>case INCORRECT: return false; default:</p>
<p>print(&quot;Delivering &quot; + m + &quot; normally&quot;); return true;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>},</p>
<p>RETURN_TO_SENDER {</p>
<p>boolean handle(Mail m) { switch(m.returnAddress) { case MISSING: return false; default:</p>
<p>print(&quot;Returning &quot; + m + &quot; to sender&quot;); return true;</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>abstract boolean handle(Mail m);</p>
<p>}</p>
<p>static void handle(Mail m) {</p>
<p>for(MailHandler handler : MailHandler.values()) if(handler.handle(m)) return;</p>
<p>print(m + &quot; is a dead letter&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { for(Mail mail : Mail.generator(10)) { print(mail.details()); handle(mail); print(&quot;*****&quot;);</p>
<p>}</p>
<p>}</p>
<p>} /* Output:</p>
<p>Mail 0, General Delivery: NO2, Address Scanability: UNSCANNABLE, Address Readability: YES3, Address Address: OKI, Return address: OKI Delivering Mail 0 normally</p>
<p>Mail 1, General Delivery: NO5, Address Scanability: YES3, Address Readability: ILLEGIBLE, Address Address: OK5, Return address: OKI Delivering Mail 1 automatically</p>
<p>Mail 2 Readab Using</p>
<table>
<tr><td>, Gene</td><td>ral Delive</td><td>ry:</td><td>YES,</td><td>Add</td><td>re</td><td>ss</td><td>Scanab</td><td>ility:</td><td>YES3</td><td>, Add</td><td>ress</td><td></td></tr>
<tr><td>ility:</td><td>YES1, Add</td><td>res</td><td>s Add</td><td>ress</td><td></td><td>OK1</td><td>, Retu</td><td>rn add</td><td>ress:</td><td>OK5</td><td></td><td></td></tr>
<tr><td>genera</td><td>l delivery</td><td>fo</td><td>r Mai</td><td>l 2</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>, Gene</td><td>ral Delive</td><td>ry:</td><td>NO4,</td><td>Add</td><td>re</td><td>ss</td><td>Scanab</td><td>ility:</td><td>YES3</td><td>, Add</td><td>ress</td><td></td></tr>
<tr><td>ility:</td><td>YES1, Add</td><td>res</td><td>s Add</td><td>ress</td><td></td><td colspan="2">INCORRECT</td><td>, Retu</td><td colspan="2">rn address</td><td>: OK4</td><td></td></tr>
<tr><td>ing Ma</td><td>il 3 to se</td><td>nde</td><td>r</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>, Gene</td><td>ral Delive</td><td>ry:</td><td>NO4,</td><td>Add</td><td>re</td><td>ss</td><td>Scanab</td><td>ility:</td><td colspan="3">UNSCANNABLE, Add</td><td>ress</td></tr>
<tr><td>ility:</td><td>YES1, Add</td><td>res</td><td>s Add</td><td>ress</td><td></td><td colspan="2">INCORRECT</td><td>, Retu</td><td colspan="2">rn address</td><td>: OK2</td><td></td></tr>
<tr><td>ing Ma</td><td>il 4 to se</td><td>nde</td><td>r</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>, Gene</td><td>ral Delive</td><td>ry:</td><td>NO3,</td><td>Add</td><td>re</td><td>ss</td><td>Scanab</td><td>ility:</td><td>YES1</td><td>, Add</td><td>ress</td><td></td></tr>
<tr><td>ility:</td><td>ILLEGIBLE</td><td colspan="2">, Addres</td><td colspan="3">s Address</td><td>: OK4,</td><td colspan="2">Return add</td><td>ress:</td><td>OK2</td><td></td></tr>
<tr><td colspan="3">ring Mail 5 automat</td><td colspan="2">ically</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>, Gene</td><td>ral Delive</td><td>ry:</td><td>YES,</td><td>Add</td><td>re</td><td>ss</td><td>Scanab</td><td>ility:</td><td>YES4</td><td>, Add</td><td>ress</td><td></td></tr>
<tr><td>ility:</td><td>ILLEGIBLE</td><td colspan="2">, Addres</td><td colspan="3">s Address</td><td>: OK4,</td><td colspan="2">Return add</td><td>ress:</td><td>OK4</td><td></td></tr>
<tr><td>genera</td><td>l delivery</td><td>fo</td><td>r Mai</td><td>l 6</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>, Gene</td><td>ral Delive</td><td>ry:</td><td>YES,</td><td>Add</td><td>re</td><td>ss</td><td>Scanab</td><td>ility:</td><td>YES3</td><td>, Add</td><td>ress</td><td></td></tr>
<tr><td>ility:</td><td>YES4, Add</td><td>res</td><td>s Add</td><td>ress</td><td></td><td>OK2</td><td>, Retu</td><td>rn add</td><td>ress:</td><td>MISS</td><td>ING</td><td></td></tr>
<tr><td>genera</td><td>l delivery</td><td>fo</td><td>r Mai</td><td>l 7</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>, Gene</td><td>ral Delive</td><td>ry:</td><td>NO3,</td><td>Add</td><td>re</td><td>ss</td><td>Scanab</td><td>ility:</td><td>YES1</td><td>, Add</td><td>ress</td><td></td></tr>
<tr><td>ility:</td><td>YES3, Add</td><td>res</td><td>s Add</td><td>ress</td><td></td><td colspan="2">INCORRECT</td><td>, Retu</td><td colspan="2">rn address</td><td>: MISSI</td><td>NG</td></tr>
<tr><td>is a</td><td>dead lette</td><td>r</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>, Gene</td><td>ral Delive</td><td>ry:</td><td>NO1,</td><td>Add</td><td>re</td><td>ss</td><td>Scanab</td><td>ility:</td><td colspan="3">UNSCANNABLE, Add</td><td>ress</td></tr>
<tr><td>ility:</td><td>YES2, Add</td><td>res</td><td>s Add</td><td>ress</td><td></td><td>OK1</td><td>, Retu</td><td>rn add</td><td>ress:</td><td>OK4</td><td></td><td></td></tr>
<tr><td colspan="13">ring Mail 9 normally</td></tr>
</table>
<p>Mail 3 Readab Return</p>
<p>Mail 4 Readab Return</p>
<p>Mail 5 Readab Delive</p>
<p>Mail 6 Readab Using</p>
<p>Mail 7 Readab Using</p>
<p>Mail 8 Readab Mail 8</p>
<p>Mail 9 Readab Delive</p>
<p>The Chain of Responsibility is expressed in enum MailHandler, and the order of the enum definitions determines the order in which the strategies are attempted on each piece of mail. Each strategy is tried in turn until one succeeds or they all fail, in which case you have a dead letter.</p>
<p>Exercise 8: (6) Modify PostOffice.java so it has the ability to forward mail.</p>
<p>Exercise 9: (5) Modify class PostOffice so that it uses an EnumMap. Project:<a l:href="#bookmark93" type="note"><sup>94</sup></a><sup></sup></p>
<p>Specialized languages like Prolog use backward chaining in order to solve problems like this. Using PostOffice.java for inspiration, research such languages and develop a program that allows new &quot;rules&quot; to be easily added to the system.</p>
<subtitle>State machines with enums</subtitle>
<p>Enumerated types can be ideal for creating state machines. A state machine can be in a finite number of specific states. The machine normally moves from one state to the next based on an input, but there are also transient states; the machine moves out of these as soon as their task is performed.</p>
<p>There are certain allowable inputs for each state, and different inputs change the state of the machine to different new states. Because enums restrict the set of possible cases, they are quite useful for enumerating the different states and inputs.</p>
<p>Each state also typically has some kind of associated output.</p>
<p>A vending machine is a good example of a state machine. First, we define the various inputs in an enum:</p>
<p>//: enumerated/Input.java package enumerated; import java.util.*;</p>
<p>public enum Input {</p>
<p>NICKEL(5), DIME(10), QUARTER(25), DOLLAR(100),</p>
<p>TOOTHPASTE(200), CHIPS(75), SODA(100), SOAP(50),</p>
<p>ABORT_TRANSACTION {</p>
<p>public int amount() { // Disallow</p>
<p>throw new RuntimeException(&quot;ABORT.amount()&quot;);</p>
<p>}</p>
<p>},</p>
<p>STOP { // This must be the last instance. public int amount() { // Disallow</p>
<p>throw new RuntimeException(&quot;SHUT_DOWN.amount()&quot;);</p>
<p>}</p>
<p>};</p>
<p>int value; // In cents</p>
<p>Input(int value) { this.value = value; }</p>
<p>Input() {}</p>
<p>int amount() { return value; }; // In cents static Random rand = new Random(47); public static Input randomSelection() {</p>
<p>// Don’t include STOP:</p>
<p>return values()[rand.nextInt(values().length - 1)];</p>
<p>}</p>
<p>} ///:~</p>
<p>Note that two of the Inputs have an associated amount, so amount( ) is defined in the interface. However, it is inappropriate to call amount( ) for the other two Input types, so they throw an exception if you call amount( ). Although this is a bit of an odd setup (define a method in an interface, then throw an exception if you call it for certain implementations), it is imposed upon us because of the constraints of enums.</p>
<p>The VendingMachine will react to these inputs by first categorizing them via the Category enum, so that it can switch on the categories. This example shows how enums make code clearer and easier to manage:</p>
<p>//: enumerated/VendingMachine.java</p>
<p>// {Args: VendingMachineInput.txt}</p>
<p>package enumerated;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static enumerated.Input.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>enum Category {</p>
<p>MONEY(NICKEL, DIME, QUARTER, DOLLAR),</p>
<p>ITEM_SELECTION(TOOTHPASTE, CHIPS, SODA, SOAP), QUIT_TRANSACTION(ABORT_TRANSACTION),</p>
<p>SHUT_DOWN(STOP); private Input[] values;</p>
<p>Category(Input... types) { values = types; } private static EnumMap&lt;Input,Category&gt; categories = new EnumMap&lt;Input,Category&gt;(Input.class); static {</p>
<p>for(Category c : Category.class.getEnumConstants()) for(Input type : c.values) categories.put(type, c);</p>
<p>}</p>
<p>public static Category categorize(Input input) { return categories.get(input);</p>
<p>}</p>
<p>}</p>
<p>public class VendingMachine {</p>
<p>private static State state = State.RESTING; private static int amount = 0; private static Input selection = null; enum StateDuration { TRANSIENT } // Tagging enum enum State {</p>
<p>RESTING {</p>
<p>void next(Input input) {</p>
<p>switch(Category.categorize(input)) { case MONEY:</p>
<p>amount += input.amount(); state = ADDING_MONEY; break;</p>
<p>case SHUT_DOWN: state = TERMINAL; default:</p>
<p>}</p>
<p>}</p>
<p>},</p>
<p>ADDING_MONEY {</p>
<p>void next(Input input) {</p>
<p>switch(Category.categorize(input)) { case MONEY:</p>
<p>amount += input.amount(); break;</p>
<p>case ITEM_SELECTION: selection = input; if(amount &lt; selection.amount())</p>
<p>print(&quot;Insufficient money for &quot; + selection); else state = DISPENSING; break;</p>
<p>case QUIT_TRANSACTION: state = GIVING_CHANGE; break;</p>
<p>case SHUT_DOWN: state = TERMINAL; default:</p>
<p>}</p>
<p>}</p>
<p>},</p>
<p>DISPENSING(StateDuration.TRANSIENT) { void next() {</p>
<p>print(&quot;here is your &quot; + selection); amount -= selection.amount(); state = GIVING_CHANGE;</p>
<p>}</p>
<p>},</p>
<p>GIVING_CHANGE(StateDuration.TRANSIENT) { void next() {</p>
<p>if(amount &gt; 0) {</p>
<p>print(&quot;Your change: &quot; + amount); amount = 0;</p>
<p>state = RESTING;</p>
<p>}</p>
<p>},</p>
<p>TERMINAL { void output() { print(&quot;Halted&quot;); } }; private boolean isTransient = false;</p>
<p>State() {}</p>
<p>State(StateDuration trans) { isTransient = true; } void next(Input input) {</p>
<p>throw new RuntimeException(&quot;Only call &quot; +</p>
<p>&quot;next(Input input) for non-transient states&quot;);</p>
<p>}</p>
<p>void next() {</p>
<p>throw new RuntimeException(&quot;Only call next() for &quot; + &quot;StateDuration.TRANSIENT states&quot;);</p>
<p>}</p>
<p>void output() { print(amount); }</p>
<p>}</p>
<p>static void run(Generator&lt;Input&gt; gen) { while(state != State.TERMINAL) { state.next(gen.next()); while(state.isTransient) state.next(); state.output();</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Generator&lt;Input&gt; gen = new RandomInputGenerator(); if(args.length == 1)</p>
<p>gen = new FileInputGenerator(args[0]); run(gen);</p>
<p>}</p>
<p>}</p>
<p>// For a basic sanity check:</p>
<p>class RandomInputGenerator implements Generator&lt;Input&gt; { public Input next() { return Input.randomSelection(); }</p>
<p>}</p>
<p>// Create Inputs from a file of ‘;’-separated strings: class FileInputGenerator implements Generator&lt;Input&gt; { private Iterator&lt;String&gt; input; public FileInputGenerator(String fileName) { input = new TextFile(fileName, &quot;;&quot;).iterator();</p>
<p>}</p>
<p>public Input next() { if(!input.hasNext()) return null;</p>
<p>return Enum.valueOf(Input.class, input.next().trim());</p>
<p>}</p>
<p>} /* Output:</p>
<p>25</p>
<p>50</p>
<p>75</p>
<p>here is your CHIPS 0</p>
<p>100</p>
<p>200</p>
<p>here is your TOOTHPASTE 0</p>
<p>25</p>
<p>SODA</p>
<table>
<tr><td>35</td><td></td></tr>
<tr><td>Your change: 02535</td><td>35</td></tr>
<tr><td>Insufficient35607075</td><td>money</td></tr>
<tr><td>Insufficient75</td><td>money</td></tr>
<tr><td>Your change: 0Halted*///:~</td><td>75</td></tr>
</table>
<p>SODA</p>
<p>Because selecting among enum instances is most often accomplished with a switch statement (notice the extra effort that the language goes to in order to make a switch on enums easy), one of the most common questions to ask when you are organizing multiple enums is &quot;What do I want to switch on?&quot; Here, it’s easiest to work back from the VendingMachine by noting that in each State, you need to switch on the basic categories of input action: money being inserted, an item being selected, the transaction being aborted, and the machine being turned off. However, within those categories, you have different types of money that can be inserted and different items that can be selected. The Category enum groups the different types of Input so that the categorize( ) method can produce the appropriate Category inside a switch. This method uses an EnumMap to efficiently and safely perform the lookup.</p>
<p>If you study class VendingMachine, you can see how each state is different, and responds differently to input. Also note the two transient states; in run( ) the machine waits for an Input and doesn’t stop moving through states until it is no longer in a transient state.</p>
<p>The VendingMachine can be tested in two ways, by using two different Generator objects. The RandomInputGenerator just keeps producing inputs, everything except SHUT_DOWN. By running this for a long time you get a kind of sanity check to help ensure that the machine will not wander into a bad state. The FilelnputGenerator takes a file describing inputs in text form, turns them into enum instances, and creates Input objects. Here’s the text file used to produce the output shown above:</p>
<p>QUARTER; QUARTER; QUARTER; CHIPS;</p>
<p>DOLLAR; DOLLAR; TOOTHPASTE;</p>
<p>QUARTER; DIME; ABORT_TRANSACTION;</p>
<p>QUARTER; DIME; SODA;</p>
<p>QUARTER; DIME; NICKEL; SODA;</p>
<p>ABORT_TRANSACTION;</p>
<p>STOP;</p>
<p>///:~</p>
<p>One limitation to this design is that the fields in VendingMachine that are accessed by enum State instances must be static, which means you can only have a single VendingMachine instance. This may not be that big of an issue if you think about an actual (embedded Java) implementation, since you are likely to have only one application per machine.</p>
<p>Exercise 10: (7) Modify class VendingMachine (only) using EnumMap so that one program can have multiple instances of VendingMachine.</p>
<p>Exercise 11: (7) In a real vending machine you will want to easily add and change the type of vended items, so the limits imposed by an enum on Input are impractical (remember that enums are for a restricted set of types). Modify VendingMachine.java so that the vended items are represented by a class instead of being part of Input, and initialize an Array List of these objects from a text file (using net.mindview.util.TextFile).</p>
<p>Project<sup>3</sup> Design the vending machine using internationalization, so that one machine can easily be adapted to all countries.</p>
</section>
<section>
<title>
<p>Multiple dispatching</p></title><empty-line/>
<p>When you are dealing with multiple interacting types, a program can get particularly messy. For example, consider a system that parses and executes mathematical expressions. You want to say Number.plus(Number), Number.multiply(Number), etc., where Number is the base class for a family of numerical objects. But when you say a.plus(b), and you don’t know the exact type of either a or b, how can you get them to interact properly?</p>
<p>The answer starts with something you probably don’t think about: Java only performs single dispatching. That is, if you are performing an operation on more than one object whose type is unknown, Java can invoke the dynamic binding mechanism on only one of those types. This doesn’t solve the problem described here, so you end up detecting some types manually and effectively producing your own dynamic binding behavior.</p>
<p>The solution is called multiple dispatching. (In this case, there will be only two dispatches, which is referred to as double dispatching.) Polymorphism can only occur via method calls, so if you want double dispatching, there must be two method calls: the first to determine the first unknown type, and the second to determine the second unknown type. With multiple dispatching, you must have a virtual call for each of the types—if you are working with two different type hierarchies that are interacting, you’ll need a virtual call in each hierarchy. Generally, you’ll set up a configuration such that a single method call produces more than one virtual method call and thus services more than one type in the process. To get this effect, you need to work with more than one method: You’ll need a method call for each dispatch. The methods in the following example (which implements the &quot;paper, scissors, rock&quot; game, traditionally called RoShamBo) are called compete( ) and eval( ) and are both members of the same type. They produce one of three possible outcomes:<a l:href="#bookmark94" type="note"><sup>95</sup></a><sup> <a l:href="#bookmark95" type="note"><sup>96</sup></a></sup> //: enumerated/Outcome.java package enumerated;</p>
<p>public enum Outcome { WIN, LOSE, DRAW } ///:~ //: enumerated/RoShamBol.java</p>
<p>// Demonstration of multiple dispatching.</p>
<p>package enumerated;</p>
<p>import java.util.*;</p>
<p>import static enumerated.Outcome.*;</p>
<p>interface</p>
<p>Outcome</p>
<p>Outcome</p>
<p>Outcome</p>
<p>Outcome</p>
<p>Item {</p>
<p>compete(Item it); eval(Paper p); eval(Scissors s); eval(Rock r);</p>
<p>class Paper implements Item {</p>
<p>public Outcome compete(Item it) { return it.eval(this); } public Outcome eval(Paper p) { return DRAW; } public Outcome eval(Scissors s) { return WIN; } public Outcome eval(Rock r) { return LOSE; } public String toString() { return &quot;Paper&quot;; }</p>
<p>}</p>
<p>class Scissors implements Item {</p>
<p>public Outcome compete(Item it) { return it.eval(this); } public Outcome eval(Paper p) { return LOSE; } public Outcome eval(Scissors s) { return DRAW; } public Outcome eval(Rock r) { return WIN; } public String toString() { return &quot;Scissors&quot;; }</p>
<p>}</p>
<p>class Rock implements Item {</p>
<p>public Outcome compete(Item it) { return it.eval(this); } public Outcome eval(Paper p) { return WIN; } public Outcome eval(Scissors s) { return LOSE; } public Outcome eval(Rock r) { return DRAW; } public String toString() { return &quot;Rock&quot;; }</p>
<p>}</p>
<p>public class RoShamBol { static final int SIZE = 20; private static Random rand = new Random(47); public static Item newItem() { switch(rand.nextInt(3)) { default:</p>
<p>case    0:    return    new    Scissors();</p>
<p>case    1:    return    new    Paper();</p>
<p>case    2:    return    new    Rock();</p>
<p>}</p>
<p>}</p>
<p>public static void match(Item a, Item b) { System.out.println(</p>
<p>a + &quot; vs. &quot; + b + &quot;: &quot; + a.compete(b));</p>
<p>}</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; SIZE; i++) match(newItem(), newItem());</p>
<p>}</p>
<p>} /* Output:</p>
<p>Rock vs. Rock: DRAW Paper vs. Rock: WIN Paper vs. Rock: WIN Paper vs. Rock: WIN Scissors vs. Paper: WIN Scissors vs. Scissors: DRAW Scissors vs. Paper: WIN Rock vs. Paper: LOSE Paper vs. Paper: DRAW Rock vs. Paper: LOSE Paper vs. Scissors: LOSE Paper vs. Scissors: LOSE Rock vs. Scissors: WIN Rock vs. Paper: LOSE Paper vs. Rock: WIN Scissors vs. Paper: WIN Paper vs. Scissors: LOSE</p>
<p>Paper vs. Scissors: LOSE Paper vs. Scissors: LOSE Paper vs. Scissors: LOSE *///:~</p>
<p>Item is the interface for the types that will be multiply dispatched. RoShamBoi.match( ) takes two Item objects and begins the doubledispatching process by calling the Item.compete( ) function. The virtual mechanism determines the type of a, so it wakes up inside the compete( ) function of a’s concrete type. The compete( ) function performs the second dispatch by calling eval( ) on the remaining type. Passing itself (this) as an argument to eval( ) produces a call to the overloaded eval( ) function, thus preserving the type information of the first dispatch. When the second dispatch is completed, you know the exact types of both Item objects.</p>
<p>It requires a lot of ceremony to set up multiple dispatching, but keep in mind that the benefit is the syntactic elegance achieved when making the callinstead of writing awkward code to determine the type of one or more objects during a call, you simply say, &quot;You two! I don’t care what types you are, interact properly with each other!&quot; Make sure this kind of elegance is important to you before embarking on multiple dispatching, however.</p>
<subtitle>Dispatching with enums</subtitle>
<p>Performing a straight translation of RoShamBo1.java into an enum-based solution is problematic because enum instances are not types, so the overloaded eval( ) methods won’t work—you can’t use enum instances as argument types. However, there are a number of different approaches to implementing multiple dispatching which benefit from enums.</p>
<p>One approach uses a constructor to initialize each e n um instance with a &quot;row&quot; of outcomes; taken together this produces a kind of lookup table:</p>
<p>//: enumerated/RoShamBo2.java</p>
<p>// Switching one enum on another.</p>
<p>package enumerated;</p>
<p>import static enumerated.Outcome.*;</p>
<p>public enum RoShamBo2 implements Competitor&lt;RoShamBo2&gt; {</p>
<p>PAPER(DRAW, LOSE, WIN),</p>
<p>SCISSORS(WIN, DRAW, LOSE),</p>
<p>ROCK(LOSE, WIN, DRAW);</p>
<p>private Outcome vPAPER, vSCISSORS, vROCK;</p>
<p>RoShamBo2(Outcome paper,Outcome scissors,Outcome rock) { this.vPAPER = paper; this.vSCISSORS = scissors; this.vROCK = rock;</p>
<p>}</p>
<p>public Outcome compete(RoShamBo2 it) { switch(it) { default:</p>
<p>case PAPER: return vPAPER; case SCISSORS: return vSCISSORS; case ROCK: return vROCK;</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>RoShamBo.play(RoShamBo2.class, 20);</p>
<p>}</p>
<p>} /* Output:</p>
<p>ROCK vs. ROCK: DRAW SCISSORS vs. ROCK: LOSE SCISSORS vs. ROCK: LOSE</p>
<p>SCISSORS vs. ROCK: LOSE PAPER vs. SCISSORS: LOSE PAPER vs. PAPER: DRAW PAPER vs. SCISSORS: LOSE ROCK vs. SCISSORS: WIN SCISSORS vs. SCISSORS: DRAW ROCK vs. SCISSORS: WIN SCISSORS vs. PAPER: WIN SCISSORS vs. PAPER: WIN ROCK vs. PAPER: LOSE ROCK vs. SCISSORS: WIN SCISSORS vs. ROCK: LOSE PAPER vs. SCISSORS: LOSE SCISSORS vs. PAPER: WIN SCISSORS vs. PAPER: WIN SCISSORS vs. PAPER: WIN SCISSORS vs. PAPER: WIN</p>
<p>Once both types have been determined in compete( ), the only action is the return of the resulting Outcome. However, you could also call another method, even (for example) via a Command object that was assigned in the constructor.</p>
<p>RoShamBo2.java is much smaller and more straightforward than the original example, and thus easier to keep track of. Notice that you’re still using two dispatches to determine the type of both objects. In RoShamBo1.java, both dispatches were performed using virtual method calls, but here, only the first dispatch uses a virtual method call. The second dispatch uses a switch, but is safe because the enum limits the choices in the switch statement.</p>
<p>The code that drives the enum has been separated out so that it can be used in the other examples. First, the Competitor interface defines a type that competes with another Competitor:</p>
<p>//: enumerated/Competitor.java // Switching one enum on another. package enumerated;</p>
<p>public interface Competitor&lt;T extends Competitor&lt;T&gt;&gt; {</p>
<p>Outcome compete(T competitor);</p>
<p>} ///:~</p>
<p>Then we define two static methods (static to avoid having to specify the parameter type explicitly). First, match( ) calls compete( ) for one Competitor vs. another, and you can see that in this case the type parameter only needs to be a Competitor&lt;T&gt;. But in play( ), the type parameter must be both an Enum&lt;T&gt; because it is used in Enums.random( ), and a Competitor&lt;T&gt; because it is passed to match( ):</p>
<p>//: enumerated/RoShamBo.java // Common tools for RoShamBo examples. package enumerated; import net.mindview.util.*;</p>
<p>public class RoShamBo {</p>
<p>public static &lt;T extends Competitor&lt;T&gt;&gt; void match(T a, T b) {</p>
<p>System.out.println(</p>
<p>a + &quot; vs. &quot; + b + &quot;: &quot; + a.compete(b));</p>
<p>}</p>
<p>public static &lt;T extends Enum&lt;T&gt; &amp; Competitor&lt;T&gt;&gt; void play(Class&lt;T&gt; rsbClass, int size) { for(int i = 0; i &lt; size; i++)</p>
<p>match(</p>
<p>Enums.random(rsbC!ass),Enums.random(rsbClass));</p>
<p>} ///:~</p>
<p>The play( ) method does not have a return value that involves the type parameter T, so it seems like you might use wildcards inside the Class&lt;T&gt; type instead of using the leading parameter description. However, wildcards cannot extend more than one base type, so we must use the above expression.</p>
<subtitle>Using constant-specific methods</subtitle>
<p>Because constant-specific methods allow you to provide different method implementations for each enum instance, they might seem like a perfect solution for setting up multiple dispatching. But even though they can be given different behavior in this way, enum instances are not types, so you cannot use them as argument types in method signatures. The best you can do for this example is to set up a switch statement:</p>
<p>//: enumerated/RoShamBo3.java</p>
<p>// Using constant-specific methods.</p>
<p>package enumerated;</p>
<p>import static enumerated.Outcome.*;</p>
<p>public enum RoShamBo3 implements Competitor&lt;RoShamBo3&gt; {</p>
<p>PAPER {</p>
<p>public Outcome compete(RoShamBo3 it) { switch(it) {</p>
<p>default: // To placate the compiler case PAPER: return DRAW; case SCISSORS: return LOSE; case ROCK: return WIN;</p>
<p>}</p>
<p>}</p>
<p>},</p>
<p>SCISSORS {</p>
<p>public Outcome compete(RoShamBo3 it) { switch(it) { default:</p>
<p>case PAPER: return WIN; case SCISSORS: return DRAW; case ROCK: return LOSE;</p>
<p>}</p>
<p>}</p>
<p>},</p>
<p>ROCK {</p>
<p>public Outcome compete(RoShamBo3 it) { switch(it) { default:</p>
<p>case PAPER: return LOSE; case SCISSORS: return WIN; case ROCK: return DRAW;</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>public abstract Outcome compete(RoShamBo3 it); public static void main(String[] args) {</p>
<p>RoShamBo.play(RoShamBo3.class, 20);</p>
<p>}</p>
<p>} /* Same output as RoShamBo2.java *///:~</p>
<p>Although this is functional and not unreasonable, the solution of RoShamBo2.java seems to require less code when adding a new type, and thus seems more straightforward.</p>
<p>However, RoShamBo3.java can be simplified and compressed:</p>
<p>//: enumerated/RoShamBo4.java package enumerated;</p>
<p>public enum RoShamBo4 implements Competitor&lt;RoShamBo4&gt; {</p>
<p>ROCK {</p>
<p>public Outcome compete(RoShamBo4 opponent) { return compete(SCISSORS, opponent);</p>
<p>}</p>
<p>},</p>
<p>SCISSORS {</p>
<p>public Outcome compete(RoShamBo4 opponent) { return compete(PAPER, opponent);</p>
<p>}</p>
<p>},</p>
<p>PAPER {</p>
<p>public Outcome compete(RoShamBo4 opponent) { return compete(ROCK, opponent);</p>
<p>}</p>
<p>};</p>
<p>Outcome compete(RoShamBo4 loser, RoShamBo4 opponent) { return ((opponent == this) ? Outcome.DRAW : ((opponent == loser) ? Outcome.WIN</p>
<p>: Outcome.LOSE));</p>
<p>}</p>
<p>public static void main(String[] args) { RoShamBo.play(RoShamBo4.class, 20);</p>
<p>}</p>
<p>} /* Same output as RoShamBo2.java *///:~</p>
<p>Here, the second dispatch is performed by the two-argument version of compete( ), which performs a sequence of comparisons and is thus similar to the action of a switch. It’s smaller, but a bit confusing. For a large system this confusion can become debilitating.</p>
<subtitle>Dispatching with EnumMaps</subtitle>
<p>It’s possible to perform a &quot;true&quot; double dispatch using the EnumMap class, which is specifically designed to work very efficiently with enums. Since the goal is to switch on two unknown types, an EnumMap of EnumMaps can be used to produce the double dispatch:</p>
<p>//: enumerated/RoShamBo5.java</p>
<p>// Multiple dispatching using an EnumMap of EnumMaps.</p>
<p>package enumerated;</p>
<p>import java.util.*;</p>
<p>import static enumerated.Outcome.*;</p>
<p>enum RoShamBo5 implements Competitor&lt;RoShamBo5&gt; {</p>
<p>PAPER, SCISSORS, ROCK;</p>
<p>static EnumMap&lt;RoShamBo5,EnumMap&lt;RoShamBo5,Outcome&gt;&gt; table = new EnumMap&lt;RoShamBo5,</p>
<p>EnumMap&lt;RoShamBo5,Outcome&gt;&gt;(RoShamBo5.class); static {</p>
<p>for(RoShamBo5 it : RoShamBo5.values()) table.put(it,</p>
<p>new EnumMap&lt;RoShamBo5,Outcome&gt;(RoShamBo5.class)); initRow(PAPER, DRAW, LOSE, WIN);</p>
<p>initRow(SCISSORS, WIN, DRAW, LOSE); initRow(ROCK, LOSE, WIN, DRAW);</p>
<p>static void initRow(RoShamBo5 it,</p>
<p>Outcome vPAPER, Outcome vSCISSORS, Outcome vROCK) { EnumMap&lt;RoShamBo5,Outcome&gt; row =</p>
<p>RoShamBo5.table.get(it); row.put(RoShamBo5.PAPER, vPAPER); row.put(RoShamBo5.SCISSORS, vSCISSORS); row.put(RoShamBo5.ROCK, vROCK);</p>
<p>}</p>
<p>public Outcome compete(RoShamBo5 it) { return table.get(this).get(it);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>RoShamBo.play(RoShamBo5.class, 20);</p>
<p>}</p>
<p>} /* Same output as RoShamBo2.java *///:~</p>
<p>The EnumMap is initialized using a static clause; you can see the table-like structure of the calls to initRow( ). Notice the compete( ) method, where you can see both dispatches happening in a single statement.</p>
<subtitle>Using a 2-D array</subtitle>
<p>We can simplify the solution even more by noting that each enum instance has a fixed value (based on its declaration order) and that ordinal( ) produces this value. A two-dimensional array mapping the competitors onto the outcomes produces the smallest and most straightforward solution (and possibly the fastest, although remember that EnumMap uses an internal array):</p>
<p>//: enumerated/RoShamBo6.java</p>
<p>// Enums using &quot;tables&quot; instead of multiple dispatch.</p>
<p>package enumerated;</p>
<p>import static enumerated.Outcome.*;</p>
<p>enum RoShamBo6 implements Competitor&lt;RoShamBo6&gt; {</p>
<p>PAPER, SCISSORS, ROCK;</p>
<p>private static Outcome[][] table = {</p>
<p>{ DRAW, LOSE, WIN }, // PAPER { WIN, DRAW, LOSE }, // SCISSORS { LOSE, WIN, DRAW }, // ROCK</p>
<p>};</p>
<p>public Outcome compete(RoShamBo6 other) {</p>
<p>return table[this.ordinal()][other.ordinal()];</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>RoShamBo.play(RoShamBo6.class, 20);</p>
<p>}</p>
<p>} ///:~</p>
<p>The table has exactly the same order as the calls to initRow( ) in the previous example.</p>
<p>The small size of this code holds great appeal over the previous examples, partly because it seems much easier to understand and modify but also because it just seems more straightforward. However, it’s not quite as &quot;safe&quot; as the previous examples because it uses an array. With a larger array, you might get the size wrong, and if your tests do not cover all possibilities something could slip through the cracks.</p>
<p>All of these solutions are different types of tables, but it’s worth exploring the expression of the tables to find the one that fits best. Note that even though the above solution is the most compact, it is also fairly rigid because it can only produce a constant output given constant inputs. However, there’s nothing that prevents you from having table produce a function object. For certain types of problems, the concept of &quot;table-driven code&quot; can be very powerful.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>Even though enumerated types are not terribly complex in themselves, this chapter was postponed until later in the book because of what you can do with enums in combination with features like polymorphism, generics, and reflection.</p>
<p>Although they are significantly more sophisticated than enums in C or C++, enums are still a &quot;small&quot; feature, something the language has survived (a bit awkwardly) without for many years. And yet this chapter shows the valuable impact that a &quot;small&quot; feature can have— sometimes it gives you just the right leverage to solve a problem elegantly and clearly, and as I have been saying throughout this book, elegance is important, and clarity may make the difference between a successful solution and one that fails because others cannot understand it.</p>
<p>On the subject of clarity, an unfortunate source of confusion comes from the poor choice in Java 1.0 of the term &quot;enumeration&quot; instead of the common and well-accepted term &quot;iterator&quot; to indicate an object that selects each element of a sequence (as shown in Collections). Some languages even refer to enumerated data types as &quot;enumerators!&quot; This mistake has since been rectified in Java, but the Enumeration interface could not, of course, simply be removed and so is still hanging around in old (and sometimes new!) code, the library, and documentation.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Annotations</p></title><empty-line/>
<p>Annotations (also known as metadata) provide a formalized way to add information to your code so that you can easily use that data at some later point.<sup>1</sup></p>
<p>Annotations are partly motivated by a general trend toward combining metadata with source-code files, instead of keeping it in external documents. They are also a response to feature pressure from other languages like C#.</p>
<p>Annotations are one of the fundamental language changes introduced in Java SE5. They provide information that you need to fully describe your program, but that cannot be expressed in Java. Thus, annotations allow you to store extra information about your program in a format that is tested and verified by the compiler. Annotations can be used to generate descriptor files or even new class definitions and help ease the burden of writing &quot;boilerplate&quot; code. Using annotations, you can keep this metadata in the Java source code, and have the advantage of cleaner looking code, compile-time type checking and the annotation API to help build processing tools for your annotations. Although a few types of metadata come predefined in Java SE5, in general the kind of annotations you add and what you do with them are entirely up to you.</p>
<p>The syntax of annotations is reasonably simple and consists mainly of the addition of the @ symbol to the language. Java SE5 contains three generalpurpose built-in annotations, defined in java.lang:</p>
<p>•    @Override, to indicate that a method definition is intended to override a method in the base class. This generates a compiler error if you accidentally misspell the method name or give an improper signature.<a l:href="#bookmark96" type="note"><sup>97</sup></a><sup> <a l:href="#bookmark97" type="note"><sup>98</sup></a></sup></p>
<p>•    @Deprecated, to produce a compiler warning if this element is used.</p>
<p>•    @SuppressWarnings, to turn off inappropriate compiler warnings. This annotation is allowed but not supported in earlier releases of Java SE5 (it was ignored).</p>
<p>Four additional annotation types support the creation of new annotations; you will learn about these in this chapter.</p>
<p>Anytime you create descriptor classes or interfaces that involve repetitive work, you can usually use annotations to automate and simplify the process. Much of the extra work in Enterprise JavaBeans (EJBs), for example, is eliminated through the use of annotations in EJB3.0.</p>
<p>Annotations can replace existing systems like XDoclet, which is an independent doclet tool (see the supplement at <a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a>) that is specifically designed for creating annotation-style doclets. In contrast, annotations are true language constructs and hence are structured, and are type-checked at compile time. Keeping all the information in the actual source code and not in comments makes the code neater and easier to maintain. By using and extending the annotation API and tools, or with external bytecode manipulation libraries as you will see in this chapter, you can perform powerful inspection and manipulation of your source code as well as the bytecode.</p>
<section>
<title>
<p>Basic syntax</p></title><empty-line/>
<p>In the example below, the method testExecute( ) is annotated with @Test. This doesn’t do anything by itself, but the compiler will ensure that you have a definition for the @Test annotation in your build path. As you will see later in the chapter, you can create a tool which runs this method for you via reflection.</p>
<p>//: annotations/Testable.java</p>
<p>package annotations;</p>
<p>import net.mindview.atunit.*;</p>
<p>public class Testable { public void execute() {</p>
<p>System.out.println(&quot;Executing..&quot;);</p>
<p>}</p>
<p>@Test void testExecute() { execute(); }</p>
<p>} ///:~</p>
<p>Annotated methods are no different from other methods. The @Test annotation in this example can be used in combination with any of the modifiers like public or static or void. Syntactically, annotations are used in much the same way as modifiers.</p>
<subtitle>Defining annotations</subtitle>
<p>Here is the definition of the annotation above. You can see that annotation definitions look a lot like interface definitions. In fact, they compile to class files like any other Java interface:</p>
<p>//: net/mindview/atunit/Test.java // The @Test tag. package net.mindview.atunit; import java.lang.annotation.*;</p>
<p>@Target(ElementType.METHOD)</p>
<p>@Retention(RetentionPolicy.RUNTIME) public @interface Test {} ///:~</p>
<p>Apart from the @ symbol, the definition of @Test is much like that of an empty interface. An annotation definition also requires the meta-annotations @Target and (@Retention. @Target defines where you can apply this annotation (a method or a field, for example). @Retention defines whether the annotations are available in the source code (SOURCE), in the class files (CLASS), or at run time (RUNTIME).</p>
<p>Annotations will usually contain elements to specify values in your annotations. A program or tool can use these parameters when processing your annotations. Elements look like interface methods, except that you can declare default values.</p>
<p>An annotation without any elements, such as @Test above, is called a marker annotation.</p>
<p>Here is a simple annotation that tracks use cases in a project. Programmers annotate each method or set of methods which fulfill the requirements of a particular use case. A project manager can get an idea of project progress by counting the implemented use cases, and developers maintaining the project can easily find use cases if they need to update or debug business rules within the system.</p>
<p>//: annotations/UseCase.java import java.lang.annotation.*;</p>
<p>@Target(ElementType.METHOD)</p>
<p>@Retention(RetentionPolicy.RUNTIME) public @interface UseCase { public int id();</p>
<p>public String description() default &quot;no description&quot;;</p>
<p>} ///:~</p>
<p>Notice that id and description resemble method declarations. Because id is type-checked by the compiler, it is a reliable way of linking a tracking database to the use case document and the source code. The element description has a default value which is picked up by the annotation processor if no value is specified when a method is annotated.</p>
<p>Here is a class with three methods annotated as use cases:</p>
<p>//: annotations/PasswordUtils.java import java.util.*;</p>
<p>public class PasswordUtils {</p>
<p>@UseCase(id = 47, description =</p>
<p>&quot;Passwords must contain at least one numeric&quot;) public boolean validatePassword(String password) { return (password.matches(&quot;\\w*\\d\\w*&quot;));</p>
<p>}</p>
<p>@UseCase(id = 48)</p>
<p>public String encryptPassword(String password) { return new StringBuilder(password).reverse().toString();</p>
<p>}</p>
<p>@UseCase(id = 49, description =</p>
<p>&quot;New passwords can’t equal previously used ones&quot;) public boolean checkForNewPassword(</p>
<p>List&lt;String&gt; prevPasswords, String password) { return !prevPasswords.contains(password);</p>
<p>}</p>
<p>} ///:~</p>
<p>The values of the annotation elements are expressed as name-value pairs in parentheses after the @UseCase declaration. The annotation for encryptPassword( ) is not passed a value for the description element here, so the default value defined in the ©interface UseCase will appear when the class is run through an annotation processor.</p>
<p>You could imagine using a system like this in order to &quot;sketch&quot; out your system, and then filling in the functionality as you build it.</p>
<subtitle>Meta-annotations</subtitle>
<p>There are currently only three standard annotations (described earlier) and four metaannotations defined in the Java language. The meta-annotations are for annotating annotations:</p>
<table>
<tr><td>@Target</td><td>Where this annotation can be applied. The possible</td></tr>
<tr><td></td><td>ElementType arguments are:</td></tr>
<tr><td></td><td>CONSTRUCTOR: Constructor declaration</td></tr>
<tr><td></td><td>FIELD: Field declaration (includes enum constants)</td></tr>
<tr><td></td><td>LOCAL VARIABLE: Local variable declaration</td></tr>
<tr><td></td><td>METHOD: Method declaration</td></tr>
</table>
<table>
<tr><td></td><td>PACKAGE: Package declaration PARAMETER: Parameter declaration TYPE: Class, interface (including annotation type), or enum declaration</td></tr>
<tr><td>@ Retention</td><td>How long the annotation information is kept. The possible RetentionPolicy arguments are: SOURCE: Annotations are discarded by the compiler.CLASS: Annotations are available in the class file by the compiler but can be discarded by the VM. RUNTIME: Annotations are retained by the VM at run time, so they may be read reflectively.</td></tr>
<tr><td>@Documented</td><td>Include this annotation in the Javadocs.</td></tr>
<tr><td>@Inherited</td><td>Allow subclasses to inherit parent annotations.</td></tr>
</table>
<p>Most of the time, you will be defining your own annotations and writing your own processors to deal with them.</p>
</section>
<section>
<title>
<p>Writing annotation processors</p></title><empty-line/>
<p>Without tools to read them, annotations are hardly more useful than comments. An important part of the process of using annotations is to create and use annotation processors. Java SE5 provides extensions to the reflection API to help you create these tools. It also provides an external tool called apt to help you parse Java source code with annotations.</p>
<p>Here is a very simple annotation processor that reads the annotated PasswordUtils class and uses reflection to look for @UseCase tags. Given a list of id values, it lists the use cases it finds and reports any that are missing:</p>
<p>//: annotations/UseCaseTracker.java import java.lang.reflect.*; import java.util.*;</p>
<p>public class UseCaseTracker { public static void</p>
<p>trackUseCases(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl) { for(Method m : cl.getDeclaredMethods()) {</p>
<p>UseCase uc = m.getAnnotation(UseCase.class); if(uc != null) {</p>
<p>System.out.println(&quot;Found Use Case:&quot; + uc.id() +</p>
<p>&quot; &quot; + uc.description()); useCases.remove(new Integer(uc.id()));</p>
<p>}</p>
<p>}</p>
<p>for(int i : useCases) {</p>
<p>System.out.println(&quot;Warning: Missing use case-&quot; + i);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>List&lt;Integer&gt; useCases = new ArrayList&lt;Integer&gt;(); Collections.addAll(useCases, 47, 48, 49, 50); trackUseCases(useCases, PasswordUtils.class);</p>
<p>}</p>
<p>} /* Output:</p>
<p>Found Use Case:47 Passwords must contain at least one numeric Found Use Case:48 no description</p>
<p>Found Use Case:49 New passwords can’t equal previously used ones Warning: Missing use case-50 *///:~</p>
<p>This uses both the reflection method getDeclaredMethods( ) and the method getAnnotation( ), which comes from the AnnotatedElement interface (classes like Class, Method and Field all implement this interface). This method returns the annotation object of the specified type, in this case &quot;UseCase.&quot; If there are no annotations of that particular type on the annotated method, a null value is returned. The element values are extracted by calling id( ) and description( ). Remember that no description was specified in the annotation for the encryptPassword( ) method, so the processor above finds the default value &quot;no description&quot; when it calls the description( ) method on that particular annotation.</p>
<subtitle>Annotation elements</subtitle>
<p>The @UseCase tag defined in UseCase.java contains the int element id and String element description. Here is a list of the allowed types for annotation elements:</p>
<p>•    All primitives (int, float, boolean etc.)</p>
<p>•    String</p>
<p>•    Class</p>
<p>•    Enums</p>
<p>•    Annotations</p>
<p>•    Arrays of any of the above</p>
<p>The compiler will report an error if you try to use any other types. Note that you are not allowed to use any of the wrapper classes, but because of autoboxing this isn’t really a limitation. You can also have elements that are themselves annotations. As you will see a bit later, nested annotations can be very helpful.</p>
<subtitle>Default value constraints</subtitle>
<p>The compiler is quite picky about default element values. No element can have an unspecified value. This means that elements must either have default values or values provided by the class that uses the annotation.</p>
<p>There is another restriction, which is that none of the non-primitive type elements are allowed to take null as a value, either when declared in the source code or when defined as a default value in the annotation interface. This makes it hard to write a processor that acts on the presence or absence of an element, because every element is effectively present in every annotation declaration. You can get around this by checking for specific values, like empty strings or negative values:</p>
<p>//: annotations/SimulatingNull.java import java.lang.annotation.*;</p>
<p>@Target(ElementType.METHOD)</p>
<p>@Retention(RetentionPolicy.RUNTIME) public @interface SimulatingNull { public int id() default -1; public String description() default &quot;&quot;;</p>
<p>} ///:~</p>
<p>This is a typical idiom in annotation definitions.</p>
<subtitle>Generating external files</subtitle>
<p>Annotations are especially useful when working with frameworks that require some sort of additional information to accompany your source code. Technologies like Enterprise JavaBeans (prior to EJB3) require numerous interfaces and deployment descriptors which are &quot;boilerplate&quot; code, defined in the same way for every bean. Web services, custom tag libraries and object/relational mapping tools like Toplink and Hibernate often require XML descriptors that are external to the code. After defining a Java class, the programmer must undergo the tedium of respecifying information like the name, package and so on-information that already exists in the original class. Whenever you use an external descriptor file, you end up with two separate sources of information about a class, which usually leads to code synchronization problems. This also requires that programmers working on the project must know about editing the descriptor as well as how to write Java programs.</p>
<p>Suppose you want to provide basic object/relational mapping functionality to automate the creation of a database table in order to store a JavaBean. You could use an XML descriptor file to specify the name of the class, each member, and information about its database mapping. Using annotations, however, you can keep all of the information in the JavaBean source file. To do this, you need annotations to define the name of the database table associated with the bean, the columns, and the SQL types to map to the bean’s properties.</p>
<p>Here is an annotation for a bean that tells the annotation processor that it should create a database table:</p>
<p>//: annotations/database/DBTable.java package annotations.database; import java.lang.annotation.*;</p>
<p>@Target(ElementType.TYPE) // Applies to classes only</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>public @interface DBTable {</p>
<p>public String name() default &quot;&quot;;</p>
<p>} ///:~</p>
<p>Each ElementType that you specify in the @Target annotation is a restriction that tells the compiler that your annotation can only be applied to that particular type. You can specify a single value of the enum ElementType, or you can specify a comma-separated list of any combination of values. If you want to apply the annotation to any ElementType, you can leave out the @Target annotation altogether, although this is uncommon.</p>
<p>Note that @DBTable has a name( ) element so that the annotation can supply a name for the database table that the processor will create.</p>
<p>Here are the annotations for the JavaBean fields:</p>
<p>//: annotations/database/Constraints.java package annotations.database; import java.lang.annotation.*;</p>
<p>@Target(ElementType.FIELD)</p>
<p>@Retention(RetentionPolicy.RUNTIME) public @interface Constraints {</p>
<p>boolean primaryKey() default false; boolean allowNull() default true; boolean unique() default false;</p>
<p>} ///:~</p>
<p>//: annotations/database/SQLString.java package annotations.database; import java.lang.annotation.*;</p>
<p>@Target(ElementType.FIELD)</p>
<p>@Retention(RetentionPolicy.RUNTIME) public @interface SQLString { int value() default 0;</p>
<p>String name() default &quot;&quot;;</p>
<p>Constraints constraints() default @Constraints;</p>
<p>} ///:~</p>
<p>//: annotations/database/SQLInteger.java package annotations.database; import java.lang.annotation.*;</p>
<p>@Target(ElementType.FIELD)</p>
<p>@Retention(RetentionPolicy.RUNTIME) public @interface SQLInteger {</p>
<p>String name() default</p>
<p>Constraints constraints() default @Constraints;</p>
<p>} ///:~</p>
<p>The @Constraints annotation allows the processor to extract the metadata about the database table. This represents a small subset of the constraints generally offered by databases, but it gives you the general idea. The elements primaryKey( ), allowNulK ) and unique( ) are given sensible default values so that in most cases a user of the annotation won’t have to type too much.</p>
<p>The other two (@interfaces define SQL types. Again, for this framework to be more useful, you need to define an annotation for each additional SQL type. Here, two types will be enough.</p>
<p>These types each have a name( ) element and a constraints( ) element. The latter makes use of the nested annotation feature to embed the information about the column type’s database constraints. Note that the default value for the contraints( ) element is @Constraints. Since there are no element values specified in parentheses after this annotation type, the default value of constraints( ) is actually an @Constraints annotation with its own default values set. To make a nested @Constraints annotation with uniqueness set to true by default, you can define its element like this:</p>
<p>//: annotations/database/Uniqueness.java // Sample of nested annotations package annotations.database;</p>
<p>public @interface Uniqueness {</p>
<p>Constraints constraints()</p>
<p>default @Constraints(unique=true);</p>
<p>} ///:~</p>
<p>Here is a simple bean that uses these annotations:</p>
<p>//: annotations/database/Member.java package annotations.database;</p>
<p>@DBTable(name = &quot;MEMBER&quot;) public class Member {</p>
<p>@SQLString(30) String firstName;</p>
<p>@SQLString(50) String lastName;</p>
<p>@SQLInteger Integer age;</p>
<p>@SQLString(value = 30,</p>
<p>constraints = @Constraints(primaryKey = true))</p>
<p>String handle; static int memberCount;</p>
<p>public String getHandle() { return handle; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public String toString() { return handle; } public Integer getAge() { return age; }</p>
<p>} ///:~</p>
<p>The @DBTable class annotation is given the value &quot;MEMBER&quot;, which will be used as the table name. The bean properties, firstName and lastName, are both annotated with @SQLStrings and have element values of 30 and 50, respectively. These annotations are interesting for two reasons: First, they use the default value on the nested (@Constraints annotation, and second, they use a shortcut feature. If you define an element on an annotation with the name value, then as long as it is the only element type specified you don’t need to use the name-value pair syntax; you can just specify the value in parentheses.</p>
<p>This can be applied to any of the legal element types. Of course this limits you to naming your element &quot;value&quot; but in the case above, it does allow for the semantically meaningful and easy-to-read annotation specification:</p>
<p>@SQLString(30)</p>
<p>The processor will use this value to set the size of the SQL column that it will create.</p>
<p>As neat as the default-value syntax is, it quickly becomes complex. Look at the annotation on the field handle. This has an @SQLString annotation, but it also needs to be a primary key on the database, so the element type primaryKey must be set on the nested @Constraint annotation. This is where it gets messy. You are now forced to use the rather long-winded namevalue pair form for this nested annotation, respecifying the element name and the @interface name. But because the specially named element value is no longer the only element value being specified, you can’t use the shortcut form. As you can see, the result is not pretty.</p>
<p>Alternative solutions</p>
<p>There are other ways of creating annotations for this task. You could, for example, have a single annotation class called @TableColumn with an enum element which defines values like STRING, INTEGER, FLOAT, etc. This eliminates the need for an @interface for each SQL type, but makes it impossible to qualify your types with additional elements like size, or precision, which is probably more useful.</p>
<p>You could also use a String element to describe the actual SQL type, e.g., &quot;VARCHAR(30)&quot; or &quot;INTEGER&quot;. This does allow you to qualify the types, but it ties up the mapping from Java type to SQL type in your code, which is not good design. You don’t want to have to recompile classes if you change databases; it would be more elegant just to tell your annotation processor that you are using a different &quot;flavor&quot; of SQL, and it let it take that into account when processing the annotations.</p>
<p>A third workable solution is to use two annotation types together, @Constraints and the relevant SQL type (for example, @SQLInteger), to annotate the desired field. This is slightly messy but the compiler allows as many different annotations as you like on an annotation target. Note that when using multiple annotations, you cannot use the same annotation twice.</p>
<subtitle>Annotations don&apos;t support inheritance</subtitle>
<p>You cannot use the extends keyword with @interfaces. This is a pity, because an elegant solution would have been to define an annotation @TableColumn, as suggested above, with a nested annotation of type @SQLType. That way, you could inherit all your SQL types, like @SQLInteger and @SQLString, from @SQLType. This would reduce typing and neaten the syntax. There doesn’t seem to be any suggestion of annotations supporting inheritance in future releases, so the examples above seem to be the best you can do under the circumstances.</p>
<subtitle>Implementing the processor</subtitle>
<p>Here is an example of an annotation processor which reads in a class file, checks for its database annotations and generates the SQL command for making the database:</p>
<p>//: annotations/database/TableCreator.java // Reflection-based annotation processor.</p>
<p>// {Args: annotations.database.Member}</p>
<p>package annotations.database; import java.lang.annotation.*; import java.lang.reflect.*; import java.util.*;</p>
<p>public class TableCreator {</p>
<p>public static void main(String[] args) throws Exception { if(args.length &lt; 1) {</p>
<p>System.out.println(&quot;arguments: annotated classes&quot;); System.exit(0);</p>
<p>}</p>
<p>for(String className : args) {</p>
<p>Class&lt;?&gt; cl = Class.forName(className);</p>
<p>DBTable dbTable = cl.getAnnotation(DBTable.class); if(dbTable == null) {</p>
<p>System.out.println(</p>
<p>&quot;No DBTable annotations in class &quot; + className); continue;</p>
<p>}</p>
<p>String tableName = dbTable.name();</p>
<p>// If the name is empty, use the Class name: if(tableName.length() &lt; 1)</p>
<p>tableName = cl.getName().toUpperCase();</p>
<p>List&lt;String&gt; columnDefs = new ArrayList&lt;String&gt;(); for(Field field : cl.getDeclaredFields()) {</p>
<p>String columnName = null;</p>
<p>Annotation[] anns = field.getDeclaredAnnotations(); if(anns.length &lt; 1)</p>
<p>continue; // Not a db table column if(anns[0] instanceof SQLInteger) {</p>
<p>SQLInteger sInt = (SQLInteger) anns[0];</p>
<p>// Use field name if name not specified if(sInt.name().length() &lt; 1)</p>
<p>columnName = field.getName().toUpperCase(); else</p>
<p>columnName = sInt.name(); columnDefs.add(columnName + &quot; INT&quot; + getConstraints(sInt.constraints()));</p>
<p>}</p>
<p>if(anns[0] instanceof SQLString) {</p>
<p>SQLString sString = (SQLString) anns[0];</p>
<p>// Use field name if name not specified. if(sString.name().length() &lt; 1)</p>
<p>columnName = field.getName().toUpperCase(); else</p>
<p>columnName = sString.name(); columnDefs.add(columnName + &quot; VARCHAR(&quot; + sString.value() + &quot;)&quot; + getConstraints(sString.constraints()));</p>
<p>}</p>
<p>StringBuilder createCommand = new StringBuilder( &quot;CREATE TABLE &quot; + tableName + &quot;(&quot;); for(String columnDef : columnDefs)</p>
<p>createCommand.append(&quot;\n &quot; + columnDef + &quot;,&quot;); // Remove trailing comma</p>
<p>String tableCreate = createCommand.substring(</p>
<p>0, createCommand.length() - 1) + &quot;);&quot;; System.out.println(&quot;Table Creation SQL for &quot; + className + &quot; is :\n&quot; + tableCreate);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>private static String getConstraints(Constraints con) {</p>
<p>String constraints = &quot;&quot;; if(!con.allowNullQ)</p>
<p>constraints += &quot; NOT NULL&quot;; if(con.primaryKey())</p>
<p>constraints += &quot; PRIMARY KEY&quot;; if(con.unique())</p>
<p>constraints += &quot; UNIQUE&quot;; return constraints;</p>
<p>}</p>
<p>} /* Output:</p>
<p>Table Creation SQL for annotations.database.Member is : CREATE TABLE MEMBER(</p>
<p>FIRSTNAME VARCHAR(30));</p>
<p>Table Creation SQL for annotations.database.Member is : CREATE TABLE MEMBER(</p>
<p>FIRSTNAME VARCHAR(30),</p>
<p>LASTNAME VARCHAR(50));</p>
<p>Table Creation SQL for annotations.database.Member is : CREATE TABLE MEMBER(</p>
<p>FIRSTNAME VARCHAR(30),</p>
<p>LASTNAME VARCHAR(50),</p>
<p>AGE INT);</p>
<p>Table Creation SQL for annotations.database.Member is : CREATE TABLE MEMBER(</p>
<p>FIRSTNAME VARCHAR(30),</p>
<p>LASTNAME VARCHAR(50),</p>
<p>AGE INT,</p>
<p>HANDLE VARCHAR(30) PRIMARY KEY);</p>
<p>*///:~</p>
<p>The main( ) method cycles through each of the class names on the command line. Each class is loaded using forName( ) and checked to see if it has the @DBTable annotation on it with getAnnotation(DBTable.class). If it does, then the table name is found and stored. All of the fields in the class are then loaded and checked using getDeclaredAnnotations(</p>
<p>). This method returns an array of all of the defined annotations for a particular method. The instanceof operator is used to determine if these annotations are of type @SQLInteger and @SQLString, and in each case the relevant String fragment is then created with the name of the table column. Note that because there is no inheritance of annotation interfaces, using getDeclaredAnnotations( ) is the only way you can approximate polymorphic behavior.</p>
<p>The nested @Constraint annotation is passed to the getConstraints( ) which builds up a String containing the SQL constraints.</p>
<p>It is worth mentioning that the technique shown above is a somewhat naive way of defining an object/relational mapping. Having an annotation of type @DBTable which takes the table name as a parameter forces you to recompile your Java code if you want to change the table name. This might not be desirable. There are many available frameworks for mapping objects to relational databases, and more and more of them are making use of annotations.</p>
<p>Exercise 1: (2) Implement more SQL types in the database example.</p>
<p>Project<sup>3</sup> Modify the database example so that it connects and interacts with a real database using JDBC.</p>
<p>Project: Modify the database example so that it creates conformant XML files rather than writing SQL code. <a l:href="#bookmark98" type="note"><sup>99</sup></a><sup></sup></p>
</section>
<section>
<title>
<p>Using apt to process annotations</p></title><empty-line/>
<p>The annotation processing tool apt is Sun’s first version of a tool that aids the processing of annotations. Because it is an early incarnation, the tool is still a little primitive, but it has features which can make your life easier.</p>
<p>Like javac, apt is designed to be run on Java source files rather than compiled classes. By default, apt compiles the source files when it has finished processing them. This is useful if you are automatically creating new source files as part of your build process. In fact, apt checks newly created source files for annotations and compiles them all in the same pass.</p>
<p>When your annotation processor creates a new source file, that file is itself checked for annotations in a new round (as it is referred to in the documentation) of processing. The tool will continue round after round of processing until no more source files are being created. It then compiles all of the source files.</p>
<p>Each annotation you write will need its own processor, but the apt tool can easily group several annotation processors together. It allows you to specify multiple classes to be processed, which is a lot easier than having to iterate through File classes yourself. You can also add listeners to receive notification of when an annotation processing round is complete.</p>
<p>At the time of this writing, apt is not available as an Ant task (see the supplement at <a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a>), but it can obviously be run as an external task from Ant in the meantime. In order to compile the annotation processors in this section you must have tools.jar in your classpath; this library also contains the the com.sun.mirror.* interfaces.</p>
<p>apt works by using an AnnotationProcessorFactory to create the right kind of annotation processor for each annotation it finds. When you run apt, you specify either a factory class or a classpath where it can find the factories it needs. If you don’t do this, apt will embark on an arcane discovery process, the details of which can be found in the Developing an Annotation Processor section of Sun’s documentation.</p>
<p>When you create an annotation processor for use with apt, you can’t use the reflection features in Java because you are working with source code, not compiled classes.<a l:href="#bookmark99" type="note"><sup>100</sup></a><sup></sup> The mirror API<a l:href="#bookmark100" type="note"><sup>101</sup></a><sup></sup> solves this problem by allowing you to view methods, fields and types in uncompiled source code.</p>
<p>Here is an annotation that can be used to extract the public methods from a class and turn them into an interface:</p>
<p>//: annotations/ExtractInterface.java // APT-based annotation processing. package annotations; import java.lang.annotation.*;</p>
<p>@Target(E!ementType.TYPE)</p>
<p>@Retention(RetentionPolicy.SOURCE) public @interface ExtractInterface { public String value();</p>
<p>} ///:~</p>
<p>The RetentionPolicy is SOURCE because there is no point in keeping this annotation in the class file after we have extracted the interface from the class. The following class provides a public method which can become part of a useful interface:</p>
<p>//: annotations/Multiplier.java // APT-based annotation processing. package annotations;</p>
<p>@ExtractInterface(&quot;IMultiplier&quot;) public class Multiplier {</p>
<p>public int multiply(int x, int y) { int total = 0; for(int i = 0; i &lt; x; i++) total = add(total, y); return total;</p>
<p>}</p>
<p>private int add(int x, int y) { return x + y; } public static void main(String[] args) {</p>
<p>Multiplier m = new Multiplier();</p>
<p>System.out.println(&quot;11*16 = &quot; + m.multiply(11, 16));</p>
<p>}</p>
<p>} /* Output:</p>
<p>11*16 = 176 *///:~</p>
<p>The Multiplier class (which only works with positive integers) has a multiply( ) method which calls the private add( ) method numerous times to perform multiplication. The add( ) method is not public, so is not part of the interface. The annotation is given the value of IMultiplier, which is the name of the interface to create.</p>
<p>Now you need a processor to do the extraction:</p>
<p>//: annotations/InterfaceExtractorProcessor.java // APT-based annotation processing.</p>
<p>// {Exec: apt -factory</p>
<p>// annotations.InterfaceExtractorProcessorFactory</p>
<p>// Multiplier.java -s ../annotations}</p>
<p>package annotations;</p>
<p>import com.sun.mirror.apt.*;</p>
<p>import com.sun.mirror.declaration.*;</p>
<p>import java.io.*;</p>
<p>import java.util.*;</p>
<p>public class InterfaceExtractorProcessor implements AnnotationProcessor { private final AnnotationProcessorEnvironment env; private ArrayList&lt;MethodDeclaration&gt; interfaceMethods = new ArrayList&lt;MethodDeclaration&gt;(); public InterfaceExtractorProcessor(</p>
<p>AnnotationProcessorEnvironment env) { this.env = env; } public void process() {</p>
<p>for(TypeDeclaration typeDecl :</p>
<p>env.getSpecifiedTypeDeclarations()) {</p>
<p>ExtractInterface annot =</p>
<p>typeDecl.getAnnotation(ExtractInterface.class); if(annot == null) break;</p>
<p>for(MethodDeclaration m : typeDecl.getMethods()) if(m.getModifiers().contains(Modifier.PUBLIC) &amp;&amp; !(m.getModifiers().contains(Modifier.STATIC))) interfaceMethods.add(m); if(interfaceMethods.size() &gt; 0) {</p>
<p>try {</p>
<p>PrintWriter writer =</p>
<p>env.getFiler().createSourceFile(annot.value()); writer.println(&quot;package &quot; +</p>
<p>typeDecl.getPackage().getQualifiedName() +&quot;;&quot;); writer.println(&quot;public interface &quot; + annot.value() + &quot; {&quot;);</p>
<p>for(MethodDeclaration m : interfaceMethods) { writer.print(&quot; public &quot;); writer.print(m.getReturnType() + &quot; &quot;); writer.print(m.getSimpleName() + &quot; (&quot;); int i = 0;</p>
<p>for(ParameterDeclaration parm : m.getParameters()) { writer.print(parm.getType() + &quot; &quot; + parm.getSimpleName()); if(++i &lt; m.getParameters().size()) writer.print(&quot;, &quot;);</p>
<p>}</p>
<p>writer.println(&quot;);&quot;);</p>
<p>}</p>
<p>writer.println(&quot;}&quot;);</p>
<p>writer.close();</p>
<p>} catch(IOException ioe) {</p>
<p>throw new RuntimeException(ioe);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>The process( ) method is where all the work is done. The MethodDeclaration class and its getModifiers( ) method are used to identify the public methods (but ignore the static ones) of the class being processed. If any are found, they are stored in an ArrayList and used to create the methods of a new interface definition in a .java file.</p>
<p>Notice that an AnnotationProcessorEnvironment object is passed into the constructor. You can query this object for all of the types (class definitions) that the apt tool is processing, and you can use it to get a Messager object and a Filer object. The Messager enables you to report messages to the user, e.g., any errors that might have occurred with the processing and where they are in the source code. The Filer is a kind of PrintWriter through which you will create new files. The main reason that you use a Filer object, rather than a plain PrintWriter, is that it allows apt to keep track of any new files that you create, so it can check them for annotations and compile them if it needs to.</p>
<p>You will also see that the method createSourceFile( ) opens an ordinary output stream with the correct name for your Java class or interface. There isn’t any support for creating Java language constructs, so you have to generate the Java source code using the somewhat primitive print( ) and println( ) methods. This means making sure that your brackets match up and that your code is syntactically correct.</p>
<p>process( ) is called by the apt tool, which needs a factory to provide the right processor:</p>
<p>//: annotations/InterfaceExtractorProcessorFactory.java</p>
<p>// APT-based annotation processing.</p>
<p>package annotations;</p>
<p>import com.sun.mirror.apt.*;</p>
<p>import com.sun.mirror.declaration.*;</p>
<p>import java.util.*;</p>
<p>public class InterfaceExtractorProcessorFactory</p>
<p>implements AnnotationProcessorFactory { public AnnotationProcessor getProcessorFor( Set&lt;AnnotationTypeDeclaration&gt; atds,</p>
<p>AnnotationProcessorEnvironment env) { return new InterfaceExtractorProcessor(env);</p>
<p>}</p>
<p>public Collection&lt;String&gt; supportedAnnotationTypes() { return</p>
<p>Collections.singleton(&quot;annotations.ExtractInterface&quot;);</p>
<p>}</p>
<p>public Collection&lt;String&gt; supportedOptions() { return Collections.emptySet();</p>
<p>}</p>
<p>} ///:~</p>
<p>There are only three methods on the AnnotationProcessorFactory interface. As you can see, the one which provides the processor is getProcessorFor( ), which takes a Set of type declarations (the Java classes that the apt tool is being run against), and the AnnotationProcessorEnvironment object, which you have already seen being passed through to the processor. The other two methods, supportedAnnotationTypes( ) and supportedOptions( ), are there so you can check that you have processors for all of the annotations found by apt and that you support all options specified at the command prompt. The getProcessorFor( ) method is particularly important because if you don’t return the full class name of your annotation type in the String collection, apt will warn you that there is no relevant processor and exit without doing anything.</p>
<p>The processor and factory are in the package annotations, so for the directory structure above, the command line is embedded in the ‘Exec’ comment tag at the beginning of InterfaceExtractorProcessor.java. This tells apt to use the factory class defined above and process the file Multiplier.java. The -s option specifies that any new files must be created in the directory annotations. The generated IMultiplier.java file, as you might guess by looking at the println( ) statements in the processor above, looks like this:</p>
<p>package annotations;</p>
<p>public interface IMultiplier {</p>
<p>public int multiply (int x, int y);</p>
<p>}</p>
<p>This file will also be compiled by apt, so you will see the file IMultiplier.class in the same directory.</p>
<p>Exercise 2: (3) Add support for division to the interface extractor.</p>
</section>
<section>
<title>
<p>Using the Visitor pattern with apt</p></title><empty-line/>
<p>Processing annotations can become complex. The example above is a relatively simple annotation processor and only interprets one annotation, but still requires a fair amount of complexity to make it work. To prevent the complexity from scaling up badly when you have more annotations and more processors, the mirror API provides classes to support the Visitor design pattern. Visitor is one of the classic design patterns from the book Design Patterns by Gamma et al., and you can also find a more a detailed explanation in Thinking in Patterns.</p>
<p>A Visitor traverses a data structure or collection of objects, performing an operation on each one. The data structure need not be ordered, and the operation that you perform on each object will be specific to its type. This decouples the operations from the objects themselves, meaning that you can add new operations without adding methods to the class definitions.</p>
<p>This makes it useful for processing annotations, because a Java class can be thought of as a collection of objects such as TypeDeclarations, FieldDeclarations, MethodDeclarations, and so on. When you use the apt tool with the Visitor pattern, you provide a Visitor class which has a method for handling each type of declaration that you visit. Thus you can implement appropriate behavior for annotations on methods, classes, fields and so on.</p>
<p>Here is the SQL table generator again, this time using a factory and a processor that makes use of the Visitor pattern:</p>
<p>//: annotations/database/TableCreationProcessorFactory.java // The database example using Visitor.</p>
<p>// {Exec: apt -factory</p>
<p>// annotations.database.TableCreationProcessorFactory</p>
<p>// database/Member.java -s database}</p>
<p>package annotations.database;</p>
<p>import com.sun.mirror.apt.*;</p>
<p>import com.sun.mirror.declaration.*;</p>
<p>import com.sun.mirror.util.*;</p>
<p>import java.util.*;</p>
<p>import static com.sun.mirror.util.DeclarationVisitors.*;</p>
<p>public class TableCreationProcessorFactory implements AnnotationProcessorFactory { public AnnotationProcessor getProcessorFor( Set&lt;AnnotationTypeDeclaration&gt; atds,</p>
<p>AnnotationProcessorEnvironment env) { return new TableCreationProcessor(env);</p>
<p>}</p>
<p>public Collection&lt;String&gt; supportedAnnotationTypes() { return Arrays.asList(</p>
<p>&quot;annotations.database.DBTable&quot;,</p>
<p>&quot;annotations.database.Constraints&quot;,</p>
<p>&quot;annotations.database.SQLString&quot;,</p>
<p>&quot;annotations.database.SQLInteger&quot;);</p>
<p>}</p>
<p>public Collection&lt;String&gt; supportedOptions() { return Collections.emptySet();</p>
<p>}</p>
<p>private static class TableCreationProcessor implements AnnotationProcessor { private final AnnotationProcessorEnvironment env; private String sql = &quot;&quot;; public TableCreationProcessor(</p>
<p>AnnotationProcessorEnvironment env) { this.env = env;</p>
<p>}</p>
<p>public void process() {</p>
<p>for(TypeDeclaration typeDecl :</p>
<p>env.getSpecifiedTypeDeclarations()) { typeDecl.accept(getDeclarationScanner( new TableCreationVisitor(), NO_OP)); sql = sql.substring(0, sql.length() - 1) + &quot;);&quot;; System.out.println(&quot;creation SQL is :\n&quot; + sql); sql = &quot;&quot;;</p>
<p>}</p>
<p>}</p>
<p>private class TableCreationVisitor extends SimpleDeclarationVisitor { public void visitClassDeclaration(</p>
<p>ClassDeclaration d) {</p>
<p>DBTable dbTable = d.getAnnotation(DBTable.class);</p>
<p>if(dbTable != null) { sq! += &quot;CREATE TABLE sql += (dbTable.name().length() &lt; 1)</p>
<p>? d.getSimpleName().toUpperCase()</p>
<p>: dbTable.name(); sql += &quot; (&quot;;</p>
<p>}</p>
<p>}</p>
<p>public void visitFieldDeclaration(</p>
<p>FieldDeclaration d) {</p>
<p>String columnName = &quot;&quot;;</p>
<p>if(d.getAnnotation(SQLInteger.class) != null) {</p>
<p>SQLInteger sInt = d.getAnnotation(</p>
<p>SQLInteger.class);</p>
<p>// Use field name if name not specified if(sInt.name().length() &lt; 1)</p>
<p>columnName = d.getSimpleName().toUpperCase(); else</p>
<p>columnName = sInt.name(); sql += &quot;\n    &quot; + columnName + &quot; INT&quot; +</p>
<p>getConstraints(sInt.constraints()) + &quot;,&quot;;</p>
<p>}</p>
<p>if(d.getAnnotation(SQLString.class) != null) {</p>
<p>SQLString sString = d.getAnnotation(</p>
<p>SQLString.class);</p>
<p>// Use field name if name not specified. if(sString.name().length() &lt; 1)</p>
<p>columnName = d.getSimpleName().toUpperCase(); else</p>
<p>columnName = sString.name(); sql += &quot;\n    &quot; + columnName + &quot; VARCHAR(&quot; +</p>
<p>sString.value() + &quot;)&quot; +</p>
<p>getConstraints(sString.constraints()) + &quot;,&quot;;</p>
<p>}</p>
<p>}</p>
<p>private String getConstraints(Constraints con) {</p>
<p>String constraints = &quot;&quot;; if(!con.allowNull())</p>
<p>constraints += &quot; NOT NULL&quot;; if(con.primaryKey())</p>
<p>constraints += &quot; PRIMARY KEY&quot;; if(con.unique())</p>
<p>constraints += &quot; UNIQUE&quot;; return constraints;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>The output is identical to the previous DBTable example.</p>
<p>The processor and the visitor are inner classes in this example. Note that the process( ) method only adds the visitor class and initializes the SQL string.</p>
<p>Both parameters of getDeclarationScanner( ) are visitors; the first is used before each declaration is visited and the second is used afterwards. This processor only needs the previsit visitor, so NO_OP is given as the second parameter. This is a static field in the DeclarationVisitor interface, which is a DeclarationVisitor that doesn’t do anything.</p>
<p>TableCreationVisitor extends SimpleDeclarationVisitor, overriding the two methods visitClassDeclaration( ) and visitFieldDeclaration( ). The</p>
<p>SimpleDeclarationVisitor is an adapter that implements all of the methods on the Declaration Visitor interface, so you can concentrate on the ones you need. In visitClassDeclaration( ), the ClassDeclaration object is checked for the DBTable annotation, and if it is there, the first part of the SQL creation String is initialized. In visitFieldDeclaration( ), the field declaration is queried for its field annotations and the information is extracted in much the same way as it was in the original example, earlier in the chapter.</p>
<p>This may seem like a more complicated way of doing things, but it produces a more scalable solution. If the complexity of your annotation processor increases, then writing your own standalone processor as in the earlier example would soon become quite complicated.</p>
<p>Exercise 3: (2) Add support for more SQL types to TableCreationProcessorFactory.java.</p>
</section>
<section>
<title>
<p>Annotation-based unit testing</p></title><empty-line/>
<p>Unit testing is the practice of creating one or more tests for each method in a class, in order to regularly test the portions of a class for correct behavior. The most popular tool used for unit testing in Java is called JUnit; at the time of this writing, JUnit was in the process of being updated to JUnit version 4, in order to incorporate annotations.<a l:href="#bookmark101" type="note"><sup>102</sup></a><sup> <a l:href="#bookmark102" type="note"><sup>103</sup></a></sup> One of the main problems with preannotation versions of JUnit is the amount of &quot;ceremony&quot; necessary in order to set up and run JUnit tests. This has been reduced over time, but annotations will move testing closer to &quot;the simplest unit testing system that can possibly work.&quot;</p>
<p>With pre-annotation versions of JUnit, you must create a separate class to hold your unit tests. With annotations we can include the unit tests inside the class to be tested, and thus reduce the time and trouble of unit testing to a minimum. This approach has the additional benefit of being able to test private methods as easily as public ones.</p>
<p>Since this example test framework is annotation-based, it’s called @Unit. The most basic form of testing, and one which you will probably use much of the time, only needs the @Test annotation to indicate which methods should be tested. One option is for the test methods to take no arguments and return a boolean to indicate success or failure. You can use any name you like for test methods. Also, @Unit test methods can have any access that you’d like, including private.</p>
<p>To use @Unit, all you need to do is import net.mindview.atunit,<sup>7</sup> mark the appropriate methods and fields with @Unit test tags (which you’ll learn about in the following examples) and then have your build system run @Unit on the resulting class. Here’s a simple example:</p>
<p>//: annotations/AtUnitExamplel.java package annotations; import net.mindview.atunit.*; import net.mindview.util.*;</p>
<p>public class AtUnitExamplel { public String methodOne() { return &quot;This is methodOne&quot;;</p>
<p>}</p>
<p>public int methodTwo() {</p>
<p>System.out.println(&quot;This is methodTwo&quot;); return 2;</p>
<p>@Test boolean methodOneTest() {</p>
<p>return methodOne().equals(&quot;This is methodOne&quot;);</p>
<p>}</p>
<p>@Test boolean m2() { return methodTwo() == 2; }</p>
<p>@Test private boolean m3() { return true; }</p>
<p>// Shows output for failure:</p>
<p>@Test boolean failureTest() { return false; }</p>
<p>@Test boolean anotherDisappointment() { return false; } public static void main(String[] args) throws Exception { OSExecute.command(</p>
<p>&quot;java net.mindview.atunit.AtUnit AtUnitExamplel&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>annotations.AtUnitExamplel . methodOneTest . m2 This is methodTwo</p>
<p>. m3</p>
<p>. failureTest (failed)</p>
<p>. anotherDisappointment (failed)</p>
<p>(5 tests)</p>
<p>&gt;&gt;&gt; 2 FAILURES &lt;&lt;&lt;</p>
<p>annotations.AtUnitExamplel: failureTest annotations.AtUnitExamplel: anotherDisappointment *///:~</p>
<p>Classes to be @Unit tested must be placed in packages.</p>
<p>The @Test annotation preceding the methods methodOneTest( ), m2( ), m3( ), failureTest( ) and anotherDisappointment( ) tells @Unit to run these methods as unit tests. It will also ensure that those methods take no arguments and return a boolean or void. Your only responsibility when you write the unit test is to determine whether the test succeeds or fails and returns true or false, respectively (for methods that return boolean).</p>
<p>If you’re familiar with JUnit, you’ll also note @Unit’s more informative output—you can see the test that’s currently being run so the output from that test is more useful, and at the end it tells you the classes and tests that caused failures.</p>
<p>You’re not forced to embed test methods inside your classes, if that doesn’t work for you. The easiest way to create non-embedded tests is with inheritance:</p>
<p>//: annotations/AtUnitExternalTest.java // Creating non-embedded tests. package annotations; import net.mindview.atunit.*; import net.mindview.util.*;</p>
<p>public class AtUnitExternalTest extends AtUnitExamplel {</p>
<p>@Test boolean _methodOne() {</p>
<p>return methodOne().equals(&quot;This is methodOne&quot;);</p>
<p>}</p>
<p>@Test boolean _methodTwo() { return methodTwo() == 2; } public static void main(String[] args) throws Exception { OSExecute.command(</p>
<p>&quot;java net.mindview.atunit.AtUnit AtUnitExternalTest&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>annotations.AtUnitExternalTest . methodOne</p>
<p>OK (2 tests)</p>
<p>*///:~</p>
<p>This example also demonstrates the value of flexible naming (in contrast to JUnit’s requirement to start all your tests with the word &quot;test&quot;). Here, @Test methods that are directly testing another method are given the name of that method starting with an underscore (I’m not suggesting that this is an ideal style, just showing a possibility).</p>
<p>You can also use composition to create non-embedded tests:</p>
<p>//: annotations/AtUnitComposition.java // Creating non-embedded tests. package annotations; import net.mindview.atunit.*; import net.mindview.util.*;</p>
<p>public class AtUnitComposition {</p>
<p>AtUnitExample1 testObject = new AtUnitExample1();</p>
<p>@Test boolean _methodOne() { return</p>
<p>testObject.methodOneQ.equals(&quot;This is methodOne&quot;);</p>
<p>}</p>
<p>@Test boolean _methodTwo() {</p>
<p>return testObject.methodTwo() == 2;</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { OSExecute.command(</p>
<p>&quot;java net.mindview.atunit.AtUnit AtUnitComposition&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>annotations.AtUnitComposition . _methodOne</p>
<p>. _methodTwo This is methodTwo</p>
<p>OK (2 tests)</p>
<p>*///:~</p>
<p>A new member testObject is created for each test, since an AtUnitComposition object is created for each test.</p>
<p>There are no special &quot;assert&quot; methods as there are in JUnit, but the second form of the @Test method allows you to return void (or boolean, if you still want to return true or false in this case). To test for success, you can use Java assert statements. Java assertions normally have to be enabled with the -ea flag on the java command line, but @Unit automatically enables them. To indicate failure, you can even use an exception. One of the @Unit design goals is to require as little additional syntax as possible, and Java’s assert and exceptions are all that is necessary to report errors. A failed assert or an exception that emerges from the test method is treated as a failed test, but @Unit does not halt in this case—it continues until all the tests are run. Here’s an example:</p>
<p>//: annotations/AtUnitExample2.java</p>
<p>// Assertions and exceptions can be used in @Tests.</p>
<p>package annotations;</p>
<p>import java.io.*;</p>
<p>import net.mindview.atunit.*;</p>
<p>import net.mindview.util.*;</p>
<p>public class AtUnitExample2 { public String methodOne() {</p>
<p>public int methodTwo() {</p>
<p>System.out.println(&quot;This is methodTwo&quot;); return 2;</p>
<p>}</p>
<p>@Test void assertExample() {</p>
<p>assert methodOne().equals(&quot;This is methodOne&quot;);</p>
<p>}</p>
<p>@Test void assertFailureExample() { assert 1 == 2: &quot;What a surprise!&quot;;</p>
<p>}</p>
<p>@Test void exceptionExample() throws IOException { new FileInputStream(&quot;nofile.txt&quot;); // Throws</p>
<p>}</p>
<p>@Test boolean assertAndReturn() {</p>
<p>// Assertion with message:</p>
<p>assert methodTwo() == 2: &quot;methodTwo must equal 2&quot;; return methodOne().equals(&quot;This is methodOne&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { OSExecute.command(</p>
<p>&quot;java net.mindview.atunit.AtUnit AtUnitExample2&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>annotations.AtUnitExample2</p>
<p>. assertExample</p>
<p>. assertFailureExample java.lang.AssertionError: What a surprise! (failed)</p>
<p>. exceptionExample java.io.FileNotFoundException: nofile.txt (The system cannot find the file specified)</p>
<p>(failed)</p>
<p>. assertAndReturn This is methodTwo (4 tests)</p>
<p>&gt;&gt;&gt; 2 FAILURES &lt;&lt;&lt;</p>
<p>annotations.AtUnitExample2: assertFailureExample</p>
<p>annotations.AtUnitExample2: exceptionExample *///:~</p>
<p>Here’s an example using non-embedded tests with assertions, performing some simple tests of java.util.HashSet:</p>
<p>//: annotations/HashSetTest.java package annotations; import java.util.*; import net.mindview.atunit.*; import net.mindview.util.*;</p>
<p>public class HashSetTest {</p>
<p>HashSet&lt;String&gt; testObject = new HashSet&lt;String&gt;();</p>
<p>@Test void initialization() { assert testObject.isEmpty();</p>
<p>}</p>
<p>@Test void _contains() { testObject.add(&quot;one&quot;); assert testObject.contains(&quot;one&quot;);</p>
<p>}</p>
<p>@Test void _remove() { testObject.add(&quot;one&quot;); testObject.remove(&quot;one&quot;);</p>
<p>assert testObject.isEmpty();</p>
<p>{</p>
<p>public static void main(String[] args) throws Exception OSExecute.command(</p>
<p>&quot;java net.mindview.atunit.AtUnit HashSetTest&quot;);</p>
<p>}</p>
<p>} /* Output: annotations.HashSetTest . initialization . _remove . contains</p>
<p>OK (3 tests) *///:~</p>
<p>The inheritance Exercise 4: Exercise 5: Exercise 6: Exercise 7:</p>
<p>approach would seem to be simpler, in the absence of other constraints. (3) Verify that a new testObject is created before each test.</p>
<p>(1) Modify the above example to use the inheritance approach.</p>
<p>(1) Test LinkedList using the approach shown in HashSetTest.j ava. (1) Modify the previous exercise to use the inheritance approach.</p>
<p>For each unit test, @Unit creates an object of the class under test using the default constructor. The test is called for that object, and then the object is discarded to prevent side effects from leaking into other unit tests. This relies on the default constructor to create the objects. If you don’t have a default constructor or you need more sophisticated construction for objects, you create a static method to build the object and attach the @TestObjectCreate annotation, like this:</p>
<p>//: annotations/AtUnitExample3.java package annotations; import net.mindview.atunit.*; import net.mindview.util.*;</p>
<p>public class AtUnitExample3 { private int n;</p>
<p>public AtUnitExample3(int n) { this.n = n; } public int getN() { return n; } public String methodOne() { return &quot;This is methodOne&quot;;</p>
<p>}</p>
<p>public int methodTwo() {</p>
<p>System.out.println(&quot;This is methodTwo&quot;); return 2;</p>
<p>}</p>
<p>@TestObjectCreate static AtUnitExample3 create() { return new AtUnitExample3(47);</p>
<p>}</p>
<p>@Test boolean initialization() { return n == 47; }</p>
<p>@Test boolean methodOneTest() {</p>
<p>return methodOne().equals(&quot;This is methodOne&quot;);</p>
<p>}</p>
<p>@Test boolean m2() { return methodTwo() == 2; } public static void main(String[] args) throws Exception { OSExecute.command(</p>
<p>&quot;java net.mindview.atunit.AtUnit AtUnitExample3&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>annotations.AtUnitExample3 . initialization . methodOneTest . m2 This is methodTwo</p>
<p>OK (3 tests)</p>
<p>*///:~</p>
<p>The @TestObjectCreate method must be static and must return an object of the type that you’re testing—the @Unit program will ensure that this is true.</p>
<p>Sometimes you need additional fields to support your unit testing. The @TestProperty annotation can be used to tag fields that are only used for unit testing (so that they can be removed before you deliver the product to the client). Here’s an example that reads values from a String that is broken up using the String.split( ) method. This input is used to produce test objects:</p>
<p>//: annotations/AtUnitExample4.java</p>
<p>package annotations;</p>
<p>import java.util.*;</p>
<p>import net.mindview.atunit.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class AtUnitExample4 {</p>
<p>static String theory = &quot;All brontosauruses &quot; +</p>
<p>&quot;are thin at one end, much MUCH thicker in the &quot; +</p>
<p>&quot;middle, and then thin again at the far end.&quot;; private String word;</p>
<p>private Random rand = new Random(); // Time-based seed public AtUnitExample4(String word) { this.word = word; } public String getWord() { return word; } public String scrambleWord() {</p>
<p>List&lt;Character&gt; chars = new ArrayList&lt;Character&gt;(); for(Character c : word.toCharArray()) chars.add(c);</p>
<p>Collections.shuffle(chars, rand);</p>
<p>StringBuilder result = new StringBuilder(); for(char ch : chars) result.append(ch); return result.toString();</p>
<p>}</p>
<p>@TestProperty static List&lt;String&gt; input =</p>
<p>Arrays.asList(theory.split(&quot; &quot;));</p>
<p>@TestProperty</p>
<p>static Iterator&lt;String&gt; words = input.iterator();</p>
<p>@TestObjectCreate static AtUnitExample4 create() { if(words.hasNext())</p>
<p>return new AtUnitExample4(words.next()); else</p>
<p>return null;</p>
<p>}</p>
<p>@Test boolean words() {</p>
<p>print(..... + getWord() + .....);</p>
<p>return getWord().equals(&quot;are&quot;);</p>
<p>}</p>
<p>@Test boolean scramble1() {</p>
<p>// Change to a specific seed to get verifiable results: rand = new Random(47);</p>
<p>print(..... + getWord() + .....);</p>
<p>String scrambled = scrambleWord(); print(scrambled);</p>
<p>return scrambled.equals(&quot;lAl&quot;);</p>
<p>@Test boolean scramble2() { rand = new Random(74);</p>
<p>print(..... + getWord() + .....);</p>
<p>String scrambled = scrambleWord(); print(scrambled);</p>
<p>return scrambled.equals(&quot;tsaeborornussu&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { System.out.println(&quot;starting&quot;);</p>
<p>OSExecute.command(</p>
<p>&quot;java net.mindview.atunit.AtUnit AtUnitExample4&quot;);</p>
<p>}</p>
<p>} /* Output: starting</p>
<p>annotations.AtUnitExample4 . scramblel ‘All’ lAl</p>
<p>. scramble2 ‘brontosauruses’ tsaeborornussu</p>
<p>. words ‘are’</p>
<p>OK (3 tests)</p>
<p>*///:~</p>
<p>@TestProperty can also be used to tag methods that may be used during testing, but are not tests themselves.</p>
<p>Note that this program relies on the execution order of the tests, which is in general not a good practice.</p>
<p>If your test object creation performs initialization that requires later cleanup, you can optionally add a static @TestObjectCleanup method to perform cleanup when you are finished with the test object. In this example, @TestObjectCreate opens a file to create each test object, so the file must be closed before the test object is discarded:</p>
<p>//: annotations/AtUnitExample5.java package annotations; import java.io.*; import net.mindview.atunit.*; import net.mindview.util.*;</p>
<p>public class AtUnitExample5 { private String text;</p>
<p>public AtUnitExample5(String text) { this.text = text; } public String toString() { return text; }</p>
<p>@TestProperty static PrintWriter output;</p>
<p>@TestProperty static int counter;</p>
<p>@TestObjectCreate static AtUnitExample5 create() {</p>
<p>String id = Integer.toString(counter++); try {</p>
<p>output = new PrintWriter(&quot;Test&quot; + id + &quot;.txt&quot;);</p>
<p>} catch(IOException e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>return new AtUnitExample5(id);</p>
<p>}</p>
<p>@TestObjectCleanup static void cleanup(AtUnitExample5 tobj) {</p>
<p>System.out.println(&quot;Running cleanup&quot;); output.close();</p>
<p>@Test boolean test1() { output.print(&quot;test1&quot;); return true;</p>
<p>}</p>
<p>@Test boolean test2() { output.print(&quot;test2&quot;); return true;</p>
<p>}</p>
<p>@Test boolean test3() { output.print(&quot;test3&quot;); return true;</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { OSExecute.command(</p>
<p>&quot;java net.mindview.atunit.AtUnit AtUnitExample5&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>annotations.AtUnitExample5</p>
<p>. test1</p>
<p>Running cleanup</p>
<p>. test2</p>
<p>Running cleanup</p>
<p>. test3</p>
<p>Running cleanup</p>
<p>OK (3 tests)</p>
<p>*///:~</p>
<p>You can see from the output that the cleanup method is automatically run after each test.</p>
<subtitle>Using @Unit with generics</subtitle>
<p>Generics pose a special problem, because you can’t &quot;test generically.&quot; You must test for a specific type parameter or set of parameters. The solution is simple: Inherit a test class from a specified version of the generic class.</p>
<p>Here’s a simple implementation of a stack:</p>
<p>//: annotations/StackL.java // A stack built on a linkedList. package annotations; import java.util.*;</p>
<p>public class StackL&lt;T&gt; {</p>
<p>private LinkedList&lt;T&gt; list = new LinkedList&lt;T&gt;(); public void push(T v) { list.addFirst(v); } public T top() { return list.getFirst(); } public T pop() { return list.removeFirst(); }</p>
<p>} ///:~</p>
<p>To test a String version, inherit a test class from StackL&lt;String&gt;:</p>
<p>//: annotations/StackLStringTest.java // Applying @Unit to generics. package annotations; import net.mindview.atunit.*; import net.mindview.util.*;</p>
<p>public class StackLStringTest extends StackL&lt;String&gt; {</p>
<p>@Test void _push() { push(&quot;one&quot;);</p>
<p>assert top().equals(&quot;one&quot;); push(&quot;two&quot;);</p>
<p>assert top().equals(&quot;two&quot;);</p>
<p>}</p>
<p>@Test void _pop() { push(&quot;one&quot;); push(&quot;two&quot;);</p>
<p>assert pop().equals(&quot;two&quot;); assert pop().equals(&quot;one&quot;);</p>
<p>}</p>
<p>@Test void _top() { push(&quot;A&quot;); push(&quot;B&quot;);</p>
<p>assert top().equals(&quot;B&quot;); assert top().equals(&quot;B&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { OSExecute.command(</p>
<p>&quot;java net.mindview.atunit.AtUnit StackLStringTest&quot;);</p>
<p>}</p>
<p>} /* Output:</p>
<p>annotations.StackLStringTest . _push . _pop . _top</p>
<p>OK (3 tests)</p>
<p>*///:~</p>
<p>The only potential drawback to inheritance is that you lose the ability to access private methods in the class under test. If this is a problem, you can either make the method in question protected, or add a non-private @TestProperty method that calls the private method (the @TestProperty method will then be stripped out of the production code by the AtUnitRemover tool that is shown later in this chapter).</p>
<p>Exercise 8: (2) Create a class with a private method and add a non-private @TestProperty method as described above. Call this method in your test code.</p>
<p>Exercise 9: (2) Write basic @Unit tests for HashMap.</p>
<p>Exercise 10: (2) Select an example from elsewhere in the book and add @Unit tests.</p>
<subtitle>No &quot;suites&quot; necessary</subtitle>
<p>One of the big advantages of @Unit over JUnit is that &quot;suites&quot; are unnecessary. In JUnit, you need to somehow tell the unit testing tool what it is that you need to test, and this requires the introduction of &quot;suites&quot; to group tests together so that JUnit can find them and run the tests.</p>
<p>@Unit simply searches for class files containing the appropriate annotations, and then executes the @Test methods. Much of my goal with the @Unit testing system is to make it incredibly transparent, so that people can begin using it by simply adding @Test methods, with no other special code or knowledge like that required by JUnit and many other unit testing frameworks. It’s hard enough to write tests without adding any new hurdles, so @Unit tries to make it trivial. This way, you’re more likely to actually write the tests.</p>
<subtitle>Implementing @Unit</subtitle>
<p>First, we need to define all the annotation types. These are simple tags, and have no fields. The @Test tag was defined at the beginning of the chapter, and here are the rest of the annotations:</p>
<p>//: net/mindview/atunit/TestObjectCreate.java // The @Unit @TestObjectCreate tag. package net.mindview.atunit; import java.lang.annotation.*;</p>
<p>@Target(ElementType.METHOD)</p>
<p>@Retention(RetentionPolicy.RUNTIME) public @interface TestObjectCreate {} ///:~</p>
<p>//: net/mindview/atunit/TestObjectCleanup.java // The @Unit @TestObjectCleanup tag. package net.mindview.atunit; import java.lang.annotation.*;</p>
<p>@Target(ElementType.METHOD)</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>public @interface TestObjectCleanup {} ///:~</p>
<p>//: net/mindview/atunit/TestProperty.java // The @Unit @TestProperty tag. package net.mindview.atunit; import java.lang.annotation.*;</p>
<p>// Both fields and methods may be tagged as properties: @Target({ElementType.FIELD, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface TestProperty {} ///:~</p>
<p>All the tests have RUNTIME retention because the @Unit system must discover the tests in compiled code.</p>
<p>To implement the system that runs the tests, we use reflection to extract the annotations. The program uses this information to decide how to build the test objects and run tests on them. Because of annotations this is surprisingly small and straightforward:</p>
<p>//: net/mindview/atunit/AtUnit.java</p>
<p>// An annotation-based unit-test framework.</p>
<p>// {RunByHand}</p>
<p>package net.mindview.atunit;</p>
<p>import java.lang.reflect.*;</p>
<p>import java.io.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class AtUnit implements ProcessFiles.Strategy { static Class&lt;?&gt; testClass;</p>
<p>static List&lt;String&gt; failedTests= new ArrayList&lt;String&gt;(); static long testsRun = 0; static long failures = 0;</p>
<p>public static void main(String[] args) throws Exception { ClassLoader.getSystemClassLoader()</p>
<p>.setDefaultAssertionStatus(true); // Enable asserts new ProcessFiles(new AtUnit(), &quot;class&quot;).start(args);</p>
<p>if(failures == 0)</p>
<p>print(&quot;OK (&quot; + testsRun + &quot; tests)&quot;); else {</p>
<p>print(&quot;(&quot; + testsRun + &quot; tests)&quot;); print(&quot;\n&gt;&gt;&gt; &quot; + failures + &quot; FAILURE&quot; +</p>
<p>(failures &gt; 1 ? &quot;S&quot; : &quot;&quot;) + &quot; &lt;&lt;&lt;&quot;); for(String failed : failedTests) print(&quot; &quot; + failed);</p>
<p>}</p>
<p>}</p>
<p>public void process(File cFile) { try {</p>
<p>String cName = ClassNameFinder.thisClass( BinaryFile.read(cFile)); if(!cName.contains(&quot;.&quot;))</p>
<p>return; // Ignore unpackaged classes testClass = Class.forName(cName);</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>TestMethods testMethods = new TestMethods();</p>
<p>Method creator = null;</p>
<p>Method cleanup = null;</p>
<p>for(Method m : testClass.getDeclaredMethods()) { testMethods.addlfTestMethod(m); if(creator == null)</p>
<p>creator = checkForCreatorMethod(m); if(cleanup == null)</p>
<p>cleanup = checkForCleanupMethod(m);</p>
<p>}</p>
<p>if(testMethods.size() &gt; 0) { if(creator == null) try {</p>
<p>if(!Modifier.isPublic(testClass</p>
<p>.getDeclaredConstructor().getModifiers())) { print(&quot;Error: &quot; + testClass +</p>
<p>&quot; default constructor must be public&quot;); System.exit(l);</p>
<p>}</p>
<p>} catch(NoSuchMethodException e) {</p>
<p>// Synthesized default constructor; OK</p>
<p>}</p>
<p>print(testClass.getName());</p>
<p>}</p>
<p>for(Method m : testMethods) {</p>
<p>printnb(&quot; . &quot; + m.getName() + &quot; &quot;); try {</p>
<p>Object testObject = createTestObject(creator); boolean success = false; try {</p>
<p>if(m.getReturnType().equals(boolean.class)) success = (Boolean)m.invoke(testObject); else {</p>
<p>m.invoke(testObject);</p>
<p>success = true; // If no assert fails</p>
<p>}</p>
<p>} catch(InvocationTargetException e) {</p>
<p>// Actual exception is inside e: print(e.getCause());</p>
<p>}</p>
<p>print(success ? &quot;&quot; : &quot;(failed)&quot;);</p>
<p>testsRun++;</p>
<p>if(!success) {</p>
<p>failures++;</p>
<p>failedTests.add(testClass.getName() +</p>
<p>&quot; + m.getName());</p>
<p>if(cleanup != null)</p>
<p>cleanup.invoke(testObject, testObject);</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>static class TestMethods extends ArrayList&lt;Method&gt; { void addIfTestMethod(Method m) {</p>
<p>if(m.getAnnotation(Test.class) == null) return;</p>
<p>if(!(m.getReturnType().equals(boolean.class) || m.getReturnType().equals(void.class))) throw new RuntimeException(&quot;@Test method&quot; +</p>
<p>&quot; must return boolean or void&quot;); m.setAccessible(true); // In case it’s private, etc. add(m);</p>
<p>}</p>
<p>}</p>
<p>private static Method checkForCreatorMethod(Method m) { if(m.getAnnotation(TestObjectCreate.class) == null) return null;</p>
<p>if(!m.getReturnType().equals(testClass))</p>
<p>throw new RuntimeException(&quot;@TestObjectCreate &quot; + &quot;must return instance of Class to be tested&quot;); if((m.getModifiers() &amp;</p>
<p>java.lang.reflect.Modifier.STATIC) &lt; 1) throw new RuntimeException(&quot;@TestObjectCreate &quot; + &quot;must be static.&quot;); m.setAccessible(true); return m;</p>
<p>}</p>
<p>private static Method checkForCleanupMethod(Method m) { if(m.getAnnotation(TestObjectCleanup.class) == null) return null;</p>
<p>if(!m.getReturnType().equals(void.class))</p>
<p>throw new RuntimeException(&quot;@TestObjectCleanup &quot; + &quot;must return void&quot;); if((m.getModifiers() &amp;</p>
<p>java.lang.reflect.Modifier.STATIC) &lt; 1) throw new RuntimeException(&quot;@TestObjectCleanup &quot; + &quot;must be static.&quot;);</p>
<p>if(m.getParameterTypes().length == 0 || m.getParameterTypes()[0] != testClass) throw new RuntimeException(&quot;@TestObjectCleanup &quot; + &quot;must take an argument of the tested type.&quot;); m.setAccessible(true); return m;</p>
<p>}</p>
<p>private static Object createTestObject(Method creator) { if(creator != null) { try {</p>
<p>return creator.invoke(testClass);</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(&quot;Couldn’t run &quot; + &quot;@TestObject (creator) method.&quot;);</p>
<p>}</p>
<p>} else { // Use the default constructor: try {</p>
<p>return testClass.newInstance();</p>
<p>} catch(Exception e) {</p>
<p>+</p>
<p>throw new RuntimeException(&quot;Couldn’t create a &quot;test object. Try using a @TestObject method.&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>AtUnit.java uses the ProcessFiles tool in net.mindview.util. The AtUnit class implements ProcessFiles.Strategy, which comprises the method process( ). This way, an instance of AtUnit can be passed to the ProcessFiles constructor. The second constructor argument tells ProcessFiles to look for all files that have &quot;class&quot; extensions.</p>
<p>If you do not provide a command-line argument, the program will traverse the current directory tree. You may also provide multiple arguments which can be either class files (with or without the .class extension) or directories. Since @Unit will automatically find the testable classes and methods, no &quot;suite” mechanism is necessary.<a l:href="#bookmark103" type="note"><sup>104</sup></a><sup></sup></p>
<p>One of the problems that AtUnit.java must solve when it discovers class files is that the actual qualified class name (including package) is not evident from the class file name. In order to discover this information, the class file must be analyzed, which is not trivial, but not impossible, either.<a l:href="#bookmark104" type="note"><sup>105</sup></a><sup></sup> So the first thing that happens when a .class file is found is that it is opened and its binary data is read and handed to ClassNameFinder.thisClass( ). Here, we are moving into the realm of &quot;bytecode engineering,&quot; because we are actually analyzing the contents of a class file:</p>
<p>//: net/mindview/atunit/ClassNameFinder.java</p>
<p>package net.mindview.atunit;</p>
<p>import java.io.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ClassNameFinder {</p>
<p>public static String thisClass(byte[] classBytes) { Map&lt;Integer,Integer&gt; offsetTable = new HashMap&lt;Integer,Integer&gt;();</p>
<p>Map&lt;Integer,String&gt; classNameTable = new HashMap&lt;Integer,String&gt;(); try {</p>
<p>DataInputStream data = new DataInputStream( new ByteArrayInputStream(classBytes)); int magic = data.readInt(); // 0xcafebabe int minorVersion = data.readShort(); int majorVersion = data.readShort(); int constant_pool_count = data.readShort(); int[] constant_pool = new int[constant_pool_count]; for(int i = 1; i &lt; constant_pool_count; i++) { int tag = data.read(); int tableSize; switch(tag) { case 1: // UTF</p>
<p>int length = data.readShort(); char[] bytes = new char[length]; for(int k = 0; k &lt; bytes.length; k++) bytes[k] = (char)data.read();</p>
<p>String className = new String(bytes); classNameTable.put(i, className); break;</p>
<p>case 5: // LONG case 6: // DOUBLE</p>
<p>data.readLong(); // discard 8 bytes i++; // Special skip necessary break;</p>
<p>case 7: // CLASS</p>
<p>int offset = data.readShort(); offsetTable.put(i, offset); break;</p>
<p>case 8: // STRING</p>
<p>data.readShort(); // discard 2 bytes break;</p>
<table>
<tr><td>case</td><td>3:</td><td>//</td><td>INTEGER</td></tr>
<tr><td>case</td><td>4:</td><td>//</td><td>FLOAT</td></tr>
<tr><td>case</td><td>9:</td><td>//</td><td>FIELD REF</td></tr>
<tr><td>case</td><td>10:</td><td>//</td><td>METHOD REF</td></tr>
<tr><td>case</td><td>11:</td><td>//</td><td>INTERFACE METHOD REF</td></tr>
<tr><td>case</td><td>12:</td><td>//</td><td>NAME AND TYPE</td></tr>
</table>
<p>data.readInt(); // discard 4 bytes; break; default:</p>
<p>throw new RuntimeException(&quot;Bad tag &quot; + tag);</p>
<p>}</p>
<p>}</p>
<p>short access_flags = data.readShort(); int this_class = data.readShort(); int super_class = data.readShort(); return classNameTable.get(</p>
<p>offsetTable.get(this_class)).replace(‘/’, ‘.’);</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>// Demonstration:</p>
<p>public static void main(String[] args) throws Exception { if(args.length &gt; 0) { for(String arg : args)</p>
<p>print(thisClass(BinaryFile.read(new File(arg))));</p>
<p>} else</p>
<p>// Walk the entire tree:</p>
<p>for(File klass : Directory.walk(&quot;.&quot;, &quot;.*\\.class&quot;)) print(thisClass(BinaryFile.read(klass)));</p>
<p>}</p>
<p>} ///:~</p>
<p>Although it’s not possible to go into full detail here, each class file follows a particular format and I’ve tried to use meaningful field names for the pieces of data that are picked out of the ByteArraylnputStream; you can also see the size of each piece by the length of the read performed on the input stream. For example, the first 32 bits of any class file is always the &quot;magic number&quot; hex 0xcafebabe,<sup>10</sup> and the next two shorts are version information. The constant pool contains the constants for the program and so is of variable size; the next short tells how big it is, so that an appropriate-sized array can be allocated. Each entry in the constant pool may be a fixed-size or variablesized value, so we must examine the tag that begins each one to find out what to do with it—that’s the switch statement. Here, we are not trying to accurately analyze all the data in the class file, but merely to step through and store the pieces of interest, so you’ll notice that a fair amount of data is discarded. Information about classes is stored in the classNameTable and the offsetTable. After the constant pool is read, the this_class information can be found, which is an index into the offsetTable, which produces an index into the classNameTable, which produces the class name.</p>
<p>Back in AtUnit.java, process( ) now has the class name and can look to see if it contains a ‘.’, which means it’s in a package. Unpackaged classes are ignored. If a class is in a package, the standard class loader is used to load the class with Class.forName( ). Now the class can be analyzed for @Unit annotations.</p>
<p>We only need to look for three things: @Test methods, which are stored in a TestMethods list, and whether there’s an @TestObjectCreate and @TestObjectCleanup method. These are discovered through the associated method calls that you see in the code, which look for the annotations.</p>
<p>If any @Test methods have been found, the name of the class is printed so the viewer can see what’s happening, and then each test is executed. This means printing the method name, then calling createTestObject( ), which will use the @TestObjectCreate method if one exists, or will fall back to the default constructor otherwise. Once the test object has been created, the test method is invoked upon that object. If the test returns a boolean, the result is captured. If not, we assume success if there is no exception (which would happen in the case of a failed assert or any other kind of exception). If an exception is thrown, the exception information is printed to show the cause. If any failure occurs, the failure count is increased and the class name and method are added to failedTests so these can be reported at the end of the run.</p>
<p>Exercise 11: (5) Add an @TestNote annotation to @Unit, so that the accompanying note is simply displayed during testing.</p>
<subtitle>Removing test code</subtitle>
<p>Although in many projects it won’t make a difference if you leave the test code in the deliverable (especially if you make all the test methods private, which you can do if you like), in some cases you will want to strip out the test code either to keep the deliverable small or so that it is not exposed to the client.</p>
<p>This requires more sophisticated bytecode engineering than it is comfortable to do by hand. However, the open-source Javassist library<a l:href="#bookmark105" type="note"><sup>106</sup></a><sup></sup> brings bytecode engineering into the realm of the possible. The following program takes an optional -r flag as its first argument; if you provide the flag it will remove the @Test annotations, and if you do not it will simply display the @Test annotations. ProcessFiles is also used here to traverse the files and directories of your choosing:</p>
<p>//: net/mindview/atunit/AtUnitRemover.java</p>
<p>// Displays @Unit annotations in compiled class files. If</p>
<p>// first argument is &quot;-r&quot;, @Unit annotations are removed.</p>
<p>// {Args: ..}</p>
<p>// {Requires: javassist.bytecode.ClassFile;</p>
<p>// You must install the Javassist library from</p>
<p>// <a l:href="http://sourceforge.net/projects/jboss/">http://sourceforge.net/projects/jboss/</a> }</p>
<p>package net.mindview.atunit;</p>
<p>import javassist.*;</p>
<p>import javassist.expr.*;</p>
<p>import javassist.bytecode.*;</p>
<p>import javassist.bytecode.annotation.*;</p>
<p>import java.io.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class AtUnitRemover implements ProcessFiles.Strategy {</p>
<p>private static boolean remove = false;</p>
<p>public static void main(String[] args) throws Exception { if(args.length &gt; 0 &amp;&amp; args[0].equals(&quot;-r&quot;)) { remove = true;</p>
<p>String[] nargs = new String[args.length - 1]; System.arraycopy(args, 1, nargs, 0, nargs.length); args = nargs;</p>
<p>}</p>
<p>new ProcessFiles(</p>
<p>new AtUnitRemover(), &quot;class&quot;).start(args);</p>
<p>}</p>
<p>public void process(File cFile) { boolean modified = false; try {</p>
<p>String cName = ClassNameFinder.thisClass(</p>
<p>BinaryFile.read(cFile));</p>
<p>if(!cName.contains(&quot;.&quot;))</p>
<p>return; // Ignore unpackaged classes ClassPool cPool = ClassPool.getDefault();</p>
<p>CtClass ctClass = cPool.get(cName);</p>
<p>for(CtMethod method : ctClass.getDeclaredMethods()) {</p>
<p>MethodInfo mi = method.getMethodInfo();</p>
<p>AnnotationsAttribute attr = (AnnotationsAttribute) mi.getAttribute(AnnotationsAttribute.visibleTag); if(attr == null) continue;</p>
<p>for(Annotation ann : attr.getAnnotations()) { if(ann.getTypeName()</p>
<p>.startsWith(&quot;net.mindview.atunit&quot;)) { print(ctClass.getName() + &quot; Method: &quot;</p>
<p>+ mi.getName() + &quot; &quot; + ann); if(remove) {</p>
<p>ctClass.removeMethod(method); modified = true;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Fields are not removed in this version (see text). if(modified)</p>
<p>ctClass.toBytecode(new DataOutputStream( new FileOutputStream(cFile))); ctClass.detach();</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>The ClassPool is a kind of picture of all the classes in the system that you are modifying. It guarantees the consistency of all the modified classes. You must get each CtClass from the ClassPool, similar to the way the class loader and Class.forName( ) load classes into the JVM.</p>
<p>The CtClass contains the bytecodes for a class object and allows you to produce information about the class and to manipulate the code in the class. Here, we call</p>
<p>getDeclaredMethods( ) (just like Java’s reflection mechanism) and get a MethodInfo object from each CtMethod object. From this, we can look at the annotations. If a method has an annotation in the net.mindview.atunit package, that method is removed.</p>
<p>If the class has been modified, the original class file is overwritten with the new class.</p>
<p>At the time of this writing, the &quot;remove&quot; functionality in Javassist had recently been added,<a l:href="#bookmark106" type="note"><sup>107</sup></a><sup> </sup>and we discovered that removing @TestProperty fields turns out to be more complex than removing methods. Because there may be static initialization operations that refer to those fields, you cannot simply remove them. So the above version of the code only removes @Unit methods. However, you should check the Javassist Web site for updates; field removal should eventually be possible. In the meantime, note that the external testing method shown in AtUnitExternalTest.java allows all tests to be removed by simply deleting the class file created by the test code.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>Annotations are a welcome addition to Java. They are a structured and typechecked means of adding metadata to your code without rendering it unreadable and messy. They can help remove the tedium of writing deployment descriptors and other generated files. The fact that the @deprecated Javadoc tag has been superseded by the @Deprecated annotation is just one indication of how much better suited annotations are for describing information about classes than are comments.</p>
<p>Only a small handful of annotations come with Java SE5. This means that, if you can’t find a library elsewhere, you will be creating annotations and the associated logic to do this. With the apt tool, you can compile newly generated files in one step, easing the build process, but currently there is little more in the mirror API than some basic functionality to help you identify the elements of Java class definitions. As you’ve seen, Javassist can be used for bytecode engineering, or you can hand-code your own bytecode manipulation tools.</p>
<p>This situation will certainly improve, and providers of APIs and frameworks will start providing annotations as part of their toolkits. As you can imagine by seeing the @Unit system, it is very likely that annotations will cause significant changes in our Java programming experience.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Concurrency</p></title><empty-line/>
<p>Up to this point, you’ve been learning about sequential programming. Everything in a program happens one step at a time.</p>
<p>A large subset of programming problems can be solved using sequential programming. For some problems, however, it becomes convenient or even essential to execute several parts of a program in parallel, so that those portions either appear to be executing concurrently, or if multiple processors are available, actually do execute simultaneously.</p>
<p>Parallel programming can produce great improvements in program execution speed, provide an easier model for designing certain types of programs, or both. However, becoming adept at concurrent programming theory and techniques is a step up from everything you’ve learned so far in this book, and is an intermediate to advanced topic. This chapter can only serve as an introduction, and you should by no means consider yourself a good concurrent programmer even if you understand this chapter thoroughly.</p>
<p>As you shall see, the real problem with concurrency occurs when tasks that are executing in parallel begin to interfere with each other. This can happen in such a subtle and occasional manner that it’s probably fair to say that concurrency is &quot;arguably deterministic but effectively nondeterministic.&quot; That is, you can make an argument to conclude that it’s possible to write concurrent programs that, through care and code inspection, work correctly. In practice, however, it’s much easier to write concurrent programs that only appear to work, but given the right conditions, will fail. These conditions may never actually occur, or occur so infrequently that you never see them during testing. In fact, you may not be able to write test code that will generate failure conditions for your concurrent program. The resulting failures will often only occur occasionally, and as a result they appear in the form of customer complaints. This is one of the strongest arguments for studying concurrency: If you ignore it, you’re likely to get bitten.</p>
<p>Concurrency thus seems fraught with peril, and if that makes you a bit fearful, this is probably a good thing. Although Java SE5 has made significant improvements in concurrency, there are still no safety nets like compile-time verification or checked exceptions to tell you when you make a mistake. With concurrency, you’re on your own, and only by being both suspicious and aggressive can you write multithreaded code in Java that will be reliable.</p>
<p>People sometimes suggest that concurrency is too advanced to include in a book that introduces the language. They argue that concurrency is a discrete topic that can be treated independently, and the few cases where it appears in daily programming (such as graphical user interfaces) can be handled with special idioms. Why introduce such a complex topic if you can avoid it?</p>
<p>Alas, if only it were so. Unfortunately, you don’t get to choose when threads will appear in your Java programs. Just because you never start a thread yourself doesn’t mean you’ll be able to avoid writing threaded code. For example, Web systems are one of the most common Java applications, and the basic Web library class, the servlet, is inherently multithreaded— this is essential because Web servers often contain multiple processors, and concurrency is an ideal way to utilize these processors. As simple as a servlet might seem, you must understand concurrency issues in order to use servlets properly. The same goes for graphical user interface programming, as you shall see in the Graphical User Interfaces chapter. Although the Swing and SWT libraries both have mechanisms for thread safety, it’s hard to know how to use these properly without understanding concurrency.</p>
<p>Java is a multithreaded language, and concurrency issues are present whether you are aware of them or not. As a result, there are many Java programs in use that either just work by accident, or work most of the time and mysteriously break every now and again because of undiscovered concurrency flaws. Sometimes this breakage is benign, but sometimes it means the loss of valuable data, and if you aren’t at least aware of concurrency issues, you may end up assuming the problem is somewhere else rather than in your software. These kinds of issues can also be exposed or amplified if a program is moved to a multiprocessor system. Basically, knowing about concurrency makes you aware that apparently correct programs can exhibit incorrect behavior.</p>
<p>Concurrent programming is like stepping into a new world and learning a new language, or at least a new set of language concepts. Understanding concurrent programming is on the same order of difficulty as understanding object-oriented programming. If you apply some effort, you can fathom the basic mechanism, but it generally takes deep study and understanding to develop a true grasp of the subject. The goal of this chapter is to give you a solid foundation in the basics of concurrency so that you can understand the concepts and write reasonable multithreaded programs. Be aware that you can easily become overconfident. If you are writing anything complex, you will need to study dedicated books on the topic.</p>
<section>
<title>
<p>The many faces of concurrency</p></title><empty-line/>
<p>A primary reason why concurrent programming can be confusing is that there is more than one problem to solve using concurrency, and more than one approach to implementing concurrency, and no clean mapping between the two issues (and often a blurring of the lines all around). As a result, you’re forced to understand all issues and special cases in order to use concurrency effectively.</p>
<p>The problems that you solve with concurrency can be roughly classified as &quot;speed&quot; and &quot;design manageability.&quot;</p>
<subtitle>Faster execution</subtitle>
<p>The speed issue sounds simple at first: If you want a program to run faster, break it into pieces and run each piece on a separate processor. Concurrency is a fundamental tool for multiprocessor programming. Now, with Moore’s Law running out of steam (at least for conventional chips), speed improvements are appearing in the form of multicore processors rather than faster chips. To make your programs run faster, you’ll have to learn to take advantage of those extra processors, and that’s one thing that concurrency gives you.</p>
<p>If you have a multiprocessor machine, multiple tasks can be distributed across those processors, which can dramatically improve throughput. This is often the case with powerful multiprocessor Web servers, which can distribute large numbers of user requests across CPUs in a program that allocates one thread per request.</p>
<p>However, concurrency can often improve the performance of programs running on a single processor.</p>
<p>This can sound a bit counterintuitive. If you think about it, a concurrent program running on a single processor should actually have more overhead than if all the parts of the program ran sequentially, because of the added cost of the so-called context switch (changing from one task to another). On the surface, it would appear to be cheaper to run all the parts of the program as a single task and save the cost of context switching.</p>
<p>The issue that can make a difference is blocking. If one task in your program is unable to continue because of some condition outside of the control of the program (typically I/O), we say that the task or the thread blocks. Without concurrency, the whole program comes to a stop until the external condition changes. If the program is written using concurrency, however, the other tasks in the program can continue to execute when one task is blocked, so the program continues to move forward. In fact, from a performance standpoint, it makes no sense to use concurrency on a single-processor machine unless one of the tasks might block.</p>
<p>A very common example of performance improvements in single-processor systems is event-driven programming. Indeed, one of the most compelling reasons for using concurrency is to produce a responsive user interface. Consider a program that performs some long-running operation and thus ends up ignoring user input and being unresponsive. If you have a &quot;quit&quot; button, you don’t want to be forced to poll it in every piece of code you write. This produces awkward code, without any guarantee that a programmer won’t forget to perform the check. Without concurrency, the only way to produce a responsive user interface is for all tasks to periodically check for user input. By creating a separate thread of execution to respond to user input, even though this thread will be blocked most of the time, the program guarantees a certain level of responsiveness.</p>
<p>The program needs to continue performing its operations, and at the same time it needs to return control to the user interface so that the program can respond to the user. But a conventional method cannot continue performing its operations and at the same time return control to the rest of the program. In fact, this sounds like an impossibility, as if the CPU must be in two places at once, but this is precisely the illusion that concurrency provides (in the case of multiprocessor systems, this is more than just an illusion).</p>
<p>One very straightforward way to implement concurrency is at the operating system level, using processes. A process is a self-contained program running within its own address space. A multitasking operating system can run more than one process (program) at a time by periodically switching the CPU from one process to another, while making it look as if each process is chugging along on its own. Processes are very attractive because the operating system usually isolates one process from another so they cannot interfere with each other, which makes programming with processes relatively easy. In contrast, concurrent systems like the one used in Java share resources like memory and I/O, so the fundamental difficulty in writing multithreaded programs is coordinating the use of these resources between different thread-driven tasks, so that they cannot be accessed by more than one task at a time.</p>
<p>Here’s a simple example that utilizes operating system processes. While writing a book, I regularly make multiple redundant backup copies of the current state of the book. I make a copy into a local directory, one onto a memory stick, one onto a Zip disk, and one onto a remote FTP site. To automate this process, I wrote a small program (in Python, but the concepts are the same) which zips the book into a file with a version number in the name and then performs the copies. Initially, I performed all the copies sequentially, waiting for each one to complete before starting the next one. But then I realized that each copy operation took a different amount of time depending on the I/O speed of the medium. Since I was using a multitasking operating system, I could start each copy operation as a separate process and let them run in parallel, which speeds up the execution of the entire program. While one process is blocked, another one can be moving forward.</p>
<p>This is an ideal example of concurrency. Each task executes as a process in its own address space, so there’s no possibility of interference between tasks. More importantly, there’s no need for the tasks to communicate with each other because they’re all completely independent. The operating system minds all the details of ensuring proper file copying. As a result, there’s no risk and you get a faster program, effectively for free.</p>
<p>Some people go so far as to advocate processes as the only reasonable approach to concurrency,<sup>1</sup> but unfortunately there are generally quantity and overhead limitations to processes that prevent their applicability across the concurrency spectrum.</p>
<p>Some programming languages are designed to isolate concurrent tasks from each other. These are generally called/imcft’onaZ languages, where each function call produces no side effects (and so cannot interfere with other functions) and can thus be driven as an independent task. Erlang is one such language, and it includes safe mechanisms for one task to communicate with another. If you find that a portion of your program must make heavy use of concurrency and you are running into excessive problems trying to build that portion, you may want to consider creating that part of your program in a dedicated concurrency language like Erlang.</p>
<p>Java took the more traditional approach of adding support for threading on top of a sequential language.<a l:href="#bookmark107" type="note"><sup>108</sup></a><sup> <a l:href="#bookmark108" type="note"><sup>109</sup></a></sup> Instead of forking external processes in a multitasking operating system, threading creates tasks within the single process represented by the executing program. One advantage that this provided was operating system transparency, which was an important design goal for Java. For example, the pre-OSX versions of the Macintosh operating system (a reasonably important target for the first versions of Java) did not support multitasking. Unless multithreading had been added to Java, any concurrent Java programs wouldn’t have been portable to the Macintosh and similar platforms, thus breaking the &quot;write once/run everywhere&quot; requirement.<a l:href="#bookmark109" type="note"><sup>110</sup></a><sup></sup></p>
<subtitle>Improving code design</subtitle>
<p>A program that uses multiple tasks on a single-CPU machine is still just doing one thing at a time, so it must be theoretically possible to write the same program without using any tasks. However, concurrency provides an important organizational benefit: The design of your program can be greatly simplified. Some types of problems, such as simulation, are difficult to solve without support for concurrency.</p>
<p>Most people have seen at least one form of simulation, as either a computer game or computer-generated animations within movies. Simulations generally involve many interacting elements, each with &quot;a mind of its own.&quot; Although you may observe that, on a single-processor machine, each simulation element is being driven forward by that one processor, from a programming standpoint it’s much easier to pretend that each simulation element has its own processor and is an independent task.</p>
<p>A full-fledged simulation may involve a very large number of tasks, corresponding to the fact that each element in a simulation can act independently—this includes doors and rocks, not just elves and wizards. Multithreaded systems often have a relatively small size limit on the number of threads available, sometimes on the order of tens or hundreds. This number may vary outside the control of the program—it may depend on the platform, or in the case of Java, the version of the JVM. In Java, you can generally assume that you will not have enough threads available to provide one for each element in a large simulation.</p>
<p>A typical approach to solving this problem is the use of cooperative multithreading. Java’s threading is preemptive, which means that a scheduling mechanism provides time slices for each thread, periodically interrupting a thread and context switching to another thread so that each one is given a reasonable amount of time to drive its task. In a cooperative system, each task voluntarily gives up control, which requires the programmer to consciously insert some kind of yielding statement into each task. The advantage to a cooperative system is twofold: Context switching is typically much cheaper than with a preemptive system, and there is theoretically no limit to the number of independent tasks that can be running at once. When you are dealing with a large number of simulation elements, this can be the ideal solution. Note, however, that some cooperative systems are not designed to distribute tasks across processors, which can be very limiting.</p>
<p>At the other extreme, concurrency is a very useful model—because it’s what is actually happening—when you are working with modern messaging systems, which involve many independent computers distributed across a network. In this case, all the processes are running completely independently of each other, and there’s not even an opportunity to share resources. However, you must still synchronize the information transfer between processes so that the entire messaging system doesn’t lose information or incorporate information at incorrect times. Even if you don’t plan to use concurrency very much in your immediate future, it’s helpful to understand it just so you can grasp messaging architectures, which are becoming more predominant ways to create distributed systems.</p>
<p>Concurrency imposes costs, including complexity costs, but these are usually outweighed by improvements in program design, resource balancing, and user convenience. In general, threads enable you to create a more loosely coupled design; otherwise, parts of your code would be forced to pay explicit attention to tasks that would normally be handled by threads.</p>
</section>
<section>
<title>
<p>Basic threading</p></title><empty-line/>
<p>Concurrent programming allows you to partition a program into separate, independently running tasks. Using multithreading, each of these independent tasks (also called subtasks) is driven by a thread of execution. A thread is a single sequential flow of control within a process. A single process can thus have multiple concurrently executing tasks, but you program as if each task has the CPU to itself. An underlying mechanism divides up the CPU time for you, but in general, you don’t need to think about it.</p>
<p>The threading model is a programming convenience to simplify juggling several operations at the same time within a single program: The CPU will pop around and give each task some of its time.<a l:href="#bookmark110" type="note"><sup>111</sup></a><sup></sup> Each task has the consciousness of constantly having the CPU to itself, but the CPU’s time is being sliced among all the tasks (except when the program is actually running on multiple CPUs). One of the great things about threading is that you are abstracted away from this layer, so your code does not need to know whether it is running on a single CPU or many. Thus, using threads is a way to create transparently scalable programs—if a program is running too slowly, you can easily speed it up by adding CPUs to your computer.</p>
<p>Multitasking and multithreading tend to be the most reasonable ways to utilize multiprocessor systems.</p>
<subtitle>Defining tasks</subtitle>
<p>A thread drives a task, so you need a way to describe that task. This is provided by the Runnable interface. To define a task, simply implement Runnable and write a run( ) method to make the task do your bidding.</p>
<p>For example, the following Liftoff task displays the countdown before liftoff:</p>
<p>//: concurrency/LiftOff.java // Demonstration of the Runnable interface.</p>
<p>public class Liftoff implements Runnable { protected int countDown = 10; // Default private static int taskCount = 0; private final int id = taskCount++; public LiftOff() {} public LiftOff(int countDown) { this.countDown = countDown;</p>
<p>}</p>
<p>public String status() { return &quot;#&quot; + id + &quot;(&quot; +</p>
<p>(countDown &gt; 0 ? countDown : &quot;Liftoff!&quot;) + &quot;), &quot;;</p>
<p>}</p>
<p>public void run() {</p>
<p>while(countDown-- &gt; 0) {</p>
<p>System.out.print(status());</p>
<p>Thread.yield();</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>The identifier id distinguishes between multiple instances of the task. It is final because it is not expected to change once it is initialized.</p>
<p>A task’s run( ) method usually has some kind of loop that continues until the task is no longer necessary, so you must establish the condition on which to break out of this loop (one option is to simply return from run( )). Often, run( ) is cast in the form of an infinite loop, which means that, barring some factor that causes run( ) to terminate, it will continue forever (later in the chapter you’ll see how to safely terminate tasks).</p>
<p>The call to the static method Thread.yield( ) inside run( ) is a suggestion to the thread scheduler (the part of the Java threading mechanism that moves the CPU from one thread to the next) that says, &quot;I’ve done the important parts of my cycle and this would be a good time to switch to another task for a while.&quot; It’s completely optional, but it is used here because it tends to produce more interesting output in these examples: You’re more likely to see evidence of tasks being swapped in and out.</p>
<p>In the following example, the task’s run( ) is not driven by a separate thread; it is simply called directly in main( ) (actually, this is using a thread: the one that is always allocated for main( )):</p>
<p>//: concurrency/MainThread.java</p>
<p>public class MainThread {</p>
<p>public static void main(String[] args) {</p>
<p>Liftoff launch = new LiftOff(); launch.run();</p>
<p>}</p>
<p>} /* Output:</p>
<p>#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),</p>
<p>*///:~</p>
<p>When a class is derived from Runnable, it must have a run( ) method, but that’s nothing special—it doesn’t produce any innate threading abilities. To achieve threading behavior, you must explicitly attach a task to a thread.</p>
<subtitle>The Thread class</subtitle>
<p>The traditional way to turn a Runnable object into a working task is to hand it to a Thread constructor. This example shows how to drive a Liftoff object using a Thread:</p>
<p>//: concurrency/BasicThreads.java</p>
<p>// The most basic use of the Thread class.</p>
<p>public class BasicThreads {</p>
<p>public static void main(String[] args) {</p>
<p>Thread t = new Thread(new LiftOff()); t.start();</p>
<p>System.out.println(&quot;Waiting for LiftOff&quot;);</p>
<p>}</p>
<p>} /* Output: (90% match)</p>
<p>Waiting for LiftOff</p>
<p>#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),</p>
<p>*///:~</p>
<p>A Thread constructor only needs a Runnable object. Calling a Thread object’s start( ) will perform the necessary initialization for the thread and then call that Runnable’s run( ) method to start the task in the new thread. Even though start( ) appears to be making a call to a long-running method, you can see from the output—the &quot;Waiting for Liftoff message appears before the countdown has completed—that start( ) quickly returns. In effect, you have made a method call to LiftOff.run( ), and that method has not yet finished, but because LiftOff.run( ) is being executed by a different thread, you can still perform other operations in the main( ) thread. (This ability is not restricted to the main( ) thread—any thread can start another thread.) Thus, the program is running two methods at once— main( ) and LiftOff.run( ). run( ) is the code that is executed &quot;simultaneously&quot; with the other threads in a program.</p>
<p>You can easily add more threads to drive more tasks. Here, you can see how all the tasks run in concert with one another:<a l:href="#bookmark111" type="note"><sup>112</sup></a><sup></sup></p>
<p>//: concurrency/MoreBasicThreads.java // Adding more threads.</p>
<p>public class MoreBasicThreads {</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 5; i++)</p>
<p>new Thread(new LiftOff()).start();</p>
<p>System.out.println(&quot;Waiting for LiftOff&quot;);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Waiting for LiftOff</p>
<table>
<tr><td>#0(9),</td><td>#1(9),</td><td>#2(9),</td><td>#3(9),</td><td>#4(9)</td><td>, #0(8), #1(8),</td><td>#2(8),</td><td>#3(8), #4</td><td>(8)</td></tr>
<tr><td>#0(7),</td><td>#1(7),</td><td>#2(7),</td><td>#3(7),</td><td>#4(7)</td><td>, #0(6), #1(6),</td><td>#2(6),</td><td>#3(6), #4</td><td>(6)</td></tr>
<tr><td>#0(5),</td><td>#1(5),</td><td>#2(5),</td><td>#3(5),</td><td>#4(5)</td><td>, #0(4), #1(4),</td><td>#2(4),</td><td>#3(4), #4</td><td>(4)</td></tr>
<tr><td>#0(3),</td><td>#1(3),</td><td>#2(3),</td><td>#3(3),</td><td>#4(3)</td><td>, #0(2), #1(2),</td><td>#2(2),</td><td>#3(2), #4</td><td>(2)</td></tr>
<tr><td>#0(1),</td><td>#1(1),</td><td>#2(1),</td><td>#3(1),</td><td>#4(1)</td><td>, #0(Liftoff!),</td><td colspan="2">#1(Liftoff!),</td><td></td></tr>
<tr><td colspan="2">#2(Liftoff!),</td><td colspan="2">#3(Liftoff!),</td><td>#4(Li</td><td>ftoff!),</td><td></td><td></td><td></td></tr>
<tr><td colspan="9">*///:~</td></tr>
</table>
<p>The output shows that the execution of the different tasks is mixed together as the threads are swapped in and out. This swapping is automatically controlled by the thread scheduler. If</p>
<p>you have multiple processors on your machine, the thread scheduler will quietly distribute the threads among the processors.<a l:href="#bookmark112" type="note"><sup>113</sup></a><sup></sup></p>
<p>The output for one run of this program will be different from that of another, because the thread-scheduling mechanism is not deterministic. In fact, you may see dramatic differences in the output of this simple program between one version of the JDK and the next. For example, an earlier JDK didn’t timeslice very often, so thread l might loop to extinction first, then thread 2 would go through all of its loops, etc. This was virtually the same as calling a routine that would do all the loops at once, except that starting up all those threads is more expensive. Later JDKs seem to produce better time-slicing behavior, so each thread seems to get more regular service. Generally, these kinds of JDK behavioral changes have not been mentioned by Sun, so you cannot plan on any consistent threading behavior. The best approach is to be as conservative as possible while writing threaded code.</p>
<p>When main( ) creates the Thread objects, it isn’t capturing the references for any of them. With an ordinary object, this would make it fair game for garbage collection, but not with a Thread. Each Thread &quot;registers&quot; itself so there is actually a reference to it someplace, and the garbage collector can’t clean it up until the task exits its run( ) and dies. You can see from the output that the tasks are indeed running to conclusion, so a thread creates a separate thread of execution that persists after the call to start( ) completes.</p>
<p>Exercise 1: (2) Implement a Runnable. Inside run( ), print a message, and then call yield( ). Repeat this three times, and then return from run( ). Put a startup message in the constructor and a shutdown message when the task terminates. Create a number of these tasks and drive them using threads.</p>
<p>Exercise 2: (2) Following the form of generics/Fibonacci.java, create a task that produces a sequence of n Fibonacci numbers, where n is provided to the constructor of the task. Create a number of these tasks and drive them using threads.</p>
<subtitle>Using Executors</subtitle>
<p>Java SE5 java.util.concurrent Executors simplify concurrent programming by managing Thread objects for you. Executors provide a layer of indirection between a client and the execution of a task; instead of a client executing a task directly, an intermediate object executes the task. Executors allow you to manage the execution of asynchronous tasks without having to explicitly manage the lifecycle of threads. Executors are the preferred method for starting tasks in Java SE5/6.</p>
<p>We can use an Executor instead of explicitly creating Thread objects in MoreBasicThreads.java. A LiftOff object knows how to run a specific task; like the Command design pattern, it exposes a single method to be executed. An ExecutorService (an Executor with a service lifecycle—e.g., shutdown) knows how to build the appropriate context to execute Runnable objects. In the following example, the CachedThreadPool creates one thread per task. Note that an ExecutorService object is created using a static Executors method which determines the kind of Executor it will be:</p>
<p>//: concurrency/CachedThreadPool.java import java.util.concurrent.*;</p>
<p>public class CachedThreadPool {</p>
<p>public static void main(String[] args) {</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; 5; i++) exec.execute(new LiftOff());</p>
<p>exec.shutdown();</p>
<table>
<tr><th colspan="8">} /* Output: (Sample)</th></tr>
<tr><td>#0(9),</td><td>#0(8), #1(9),</td><td>#2(9),</td><td>#3(9)</td><td>, #4(9),</td><td>#0(7),</td><td>#1(8), #2(8), #3</td><td>(8)</td></tr>
<tr><td>#4(8),</td><td>#0(6), #1(7),</td><td>#2(7),</td><td>#3(7)</td><td>, #4(7),</td><td>#0(5),</td><td>#1(6), #2(6), #3</td><td>(6)</td></tr>
<tr><td>#4(6),</td><td>#0(4), #1(5),</td><td>#2(5),</td><td>#3(5)</td><td>, #4(5),</td><td>#0(3),</td><td>#1(4), #2(4), #3</td><td>(4)</td></tr>
<tr><td>#4(4),</td><td>#0(2), #1(3),</td><td>#2(3),</td><td>#3(3)</td><td>, #4(3),</td><td>#0(1),</td><td>#1(2), #2(2), #3</td><td>(2)</td></tr>
<tr><td>#4(2),</td><td>#0(Liftoff!),</td><td>#1(1),</td><td>#2(1)</td><td>, #3(1),</td><td>#4(1),</td><td>#1(Liftoff!),</td><td></td></tr>
<tr><td colspan="3">#2(Liftoff!), #3(Liftoff!),</td><td>#4(Li</td><td>ftoff!),</td><td></td><td></td><td></td></tr>
</table>
<p>Very often, a single Executor can be used to create and manage all the tasks in your system.</p>
<p>The call to shutdown( ) prevents new tasks from being submitted to that Executor. The current thread (in this case, the one driving main( )) will continue to run all tasks submitted before shutdown( ) was called. The program will exit as soon as all the tasks in the Executor finish.</p>
<p>You can easily replace the CachedThreadPool in the previous example with a different type of Executor. A FixedThreadPool uses a limited set of threads to execute the submitted tasks: //: concurrency/FixedThreadPool.java import java.util.concurrent.*;</p>
<p>public class FixedThreadPool {</p>
<p>public static void main(String[] args) {</p>
<p>// Constructor argument is number of threads: ExecutorService exec = Executors.newFixedThreadPool(5); for(int i = 0; i &lt; 5; i++) exec.execute(new LiftOff()); exec.shutdown();</p>
<table>
<tr><th colspan="10">}} /* Output: (Sample)</th></tr>
<tr><td>#0(9),</td><td>#0(8),</td><td>#1(9),</td><td>#2(9),</td><td>#3(9),</td><td>#4(9),</td><td>#0(7),</td><td>#1(8),</td><td>#2(8),</td><td>#3(8)</td></tr>
<tr><td>#4(8),</td><td>#0(6),</td><td>#1(7),</td><td>#2(7),</td><td>#3(7),</td><td>#4(7),</td><td>#0(5),</td><td>#1(6),</td><td>#2(6),</td><td>#3(6)</td></tr>
<tr><td>#4(6),</td><td>#0(4),</td><td>#1(5),</td><td>#2(5),</td><td>#3(5),</td><td>#4(5),</td><td>#0(3),</td><td>#1(4),</td><td>#2(4),</td><td>#3(4)</td></tr>
<tr><td>#4(4),</td><td>#0(2),</td><td>#1(3),</td><td>#2(3),</td><td>#3(3),</td><td>#4(3),</td><td>#0(1),</td><td>#1(2),</td><td>#2(2),</td><td>#3(2)</td></tr>
<tr><td>#4(2),</td><td colspan="2">#0(Liftoff!),</td><td>#1(1),</td><td>#2(1),</td><td>#3(1),</td><td>#4(1),</td><td colspan="2">#1(Liftoff!),</td><td></td></tr>
<tr><td colspan="10">#2(Liftoff!), #3(Liftoff!), #4(Liftoff!), *///:~</td></tr>
</table>
<p>With the FixedThreadPool, you do expensive thread allocation once, up front, and you thus limit the number of threads. This saves time because you aren’t constantly paying for thread creation overhead for every single task. Also, in an event-driven system, event handlers that require threads can be serviced as quickly as you want by simply fetching threads from the pool. You don’t overrun the available resources because the FixedThreadPool uses a bounded number of Thread objects.</p>
<p>Note that in any of the thread pools, existing threads are automatically reused when possible.</p>
<p>Although this book will use CachedThreadPools, consider using FixedThreadPools in production code. A CachedThreadPool will generally create as many threads as it needs during the execution of a program and then will stop creating new threads as it recycles the old ones, so it’s a reasonable first choice as an Executor. Only if this approach causes problems do you need to switch to a FixedThreadPool.</p>
<p>A SingleThreadExecutor is like a FixedThreadPool with a size of one thread.<a l:href="#bookmark113" type="note"><sup>114</sup></a><sup></sup> This is useful for anything you want to run in another thread continually (a long-lived task), such as a task that listens to incoming socket connections. It is also handy for short tasks that you want to run in a thread— for example, small tasks that update a local or remote log, or for an eventdispatching thread.</p>
<p>If more than one task is submitted to a SingleThreadExecutor, the tasks will be queued and each task will run to completion before the next task is begun, all using the same thread. In the following example, you’ll see each task completed, in the order in which it was submitted, before the next one is begun. Thus, a SingleThreadExecutor serializes the tasks that are submitted to it, and maintains its own (hidden) queue of pending tasks.</p>
<p>//: concurrency/SingleThreadExecutor.java import java.util.concurrent.*;</p>
<p>public class SingleThreadExecutor {</p>
<p>public static void main(String[] args) {</p>
<p>ExecutorService exec =</p>
<p>Executors.newSingleThreadExecutor(); for(int i = 0; i &lt; 5; i++) exec.execute(new LiftOff()); exec.shutdown();</p>
<table>
<tr><th colspan="11">}</th></tr>
<tr><td>} /* #0(9)</td><td>Output: , #0(8)</td><td>, #0(7)</td><td>, #0(6)</td><td>, #0(5)</td><td>, #0(4),</td><td>#0(3),</td><td>#0(2),</td><td>#0(1),</td><td></td><td></td></tr>
<tr><td colspan="2">#0(Liftoff!)</td><td>, #1(9)</td><td>, #1(8)</td><td>, #1(7)</td><td>, #1(6),</td><td>#1(5),</td><td>#1(4),</td><td>#1(3),</td><td>#1</td><td>(2)</td></tr>
<tr><td>#1(1)</td><td>, #1(Li</td><td>ftoff!)</td><td>, #2(9)</td><td>, #2(8)</td><td>, #2(7),</td><td>#2(6),</td><td>#2(5),</td><td>#2(4),</td><td>#2</td><td>(3)</td></tr>
<tr><td>#2(2)</td><td>, #2(1)</td><td>, #2(Li</td><td>ftoff!)</td><td>, #3(9)</td><td>, #3(8),</td><td>#3(7),</td><td>#3(6),</td><td>#3(5),</td><td>#3</td><td>(4)</td></tr>
<tr><td>#3(3)#4(4)*///:</td><td>, #3(2) , #4(3)</td><td>, #3(1) , #4(2)</td><td>, #3(Li , #4(1)</td><td>ftoff!) , #4(Li</td><td>, #4(9), ftoff!),</td><td>#4(8),</td><td>#4(7),</td><td>#4(6),</td><td>#4</td><td>(5)</td></tr>
</table>
<p>As another example, suppose you have a number of threads running tasks that use the file system. You can run these tasks with a SingleThreadExecutor to ensure that only one task at a time is running from any thread. This way, you don’t need to deal with synchronizing on the shared resource (and you won’t clobber the file system in the meantime). Sometimes a better solution is to synchronize on the resource (which you’ll learn about later in this chapter), but a SingleThreadExecutor lets you skip the trouble of getting coordinated properly just to prototype something. By serializing tasks, you can eliminate the need to serialize the objects.</p>
<p>Exercise 3: (1) Repeat Exercise 1 using the different types of executors shown in this section.</p>
<p>Exercise 4: (1) Repeat Exercise 2 using the different types of executors shown in this section.</p>
<subtitle>Producing return values from tasks</subtitle>
<p>A Runnable is a separate task that performs work, but it doesn’t return a value. If you want the task to produce a value when it’s done, you can implement the Callable interface rather than the Runnable interface. Callable, introduced in Java SE5, is a generic with a type parameter representing the return value from the method call( ) (instead of run( )), and must be invoked using an ExecutorService submit( ) method. Here’s a simple example:</p>
<p>//: concurrency/CallableDemo.java import java.util.concurrent.*; import java.util.*;</p>
<p>class TaskWithResult implements Callable&lt;String&gt; { private int id;</p>
<p>public TaskWithResult(int id) { this.id = id;</p>
<p>}</p>
<p>public String call() {</p>
<p>return &quot;result of TaskWithResult &quot; + id;</p>
<p>}</p>
<p>}</p>
<p>public class CallableDemo {</p>
<p>public static void main(String[] args) {</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); ArrayList&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;Future&lt;String&gt;&gt;(); for(int i = 0; i &lt; 10; i++)</p>
<p>results.add(exec.submit(new TaskWithResult(i))); for(Future&lt;String&gt; fs : results) try {</p>
<p>// get() blocks until completion: System.out.println(fs.get());</p>
<p>} catch(InterruptedException e) { System.out.println(e); return;</p>
<p>} catch(ExecutionException e) {</p>
<p>System.out.println(e);</p>
<p>} finally {</p>
<p>exec.shutdown();</p>
<p>}</p>
<table>
<tr><th colspan="4">}</th></tr>
<tr><td colspan="3">} /* Output:</td><td></td></tr>
<tr><td>result</td><td>of</td><td>TaskWithResult</td><td>0</td></tr>
<tr><td>result</td><td>of</td><td>TaskWithResult</td><td>1</td></tr>
<tr><td>result</td><td>of</td><td>TaskWithResult</td><td>2</td></tr>
<tr><td>result</td><td>of</td><td>TaskWithResult</td><td>3</td></tr>
<tr><td>result</td><td>of</td><td>TaskWithResult</td><td>4</td></tr>
<tr><td>result</td><td>of</td><td>TaskWithResult</td><td>5</td></tr>
<tr><td>result</td><td>of</td><td>TaskWithResult</td><td>6</td></tr>
<tr><td>result</td><td>of</td><td>TaskWithResult</td><td>7</td></tr>
<tr><td>result</td><td>of</td><td>TaskWithResult</td><td>8</td></tr>
<tr><td>result</td><td>of</td><td>TaskWithResult</td><td>9</td></tr>
<tr><td>*///:~</td><td></td><td></td><td></td></tr>
</table>
<p>The submit( ) method produces a Future object, parameterized for the particular type of result returned by the Callable. You can query the Future with isDone( ) to see if it has completed. When the task is completed and has a result, you can call get( ) to fetch the result. You can simply call get( ) without checking isDone( ), in which case get( ) will block until the result is ready. You can also call get( ) with a timeout, or isDone( ) to see if the task has completed, before trying to call get( ) to fetch the result.</p>
<p>The overloaded Executors.callable( ) method takes a Runnable and produces a Callable. ExecutorService has some &quot;invoke&quot; methods that run collections of Callable objects.</p>
<p>Exercise 5: (2) Modify Exercise 2 so that the task is a Callable that sums the values of all the Fibonacci numbers. Create several tasks and display the results.</p>
<subtitle>Sleeping</subtitle>
<p>A simple way to affect the behavior of your tasks is by calling sleep( ) to cease (block) the execution of that task for a given time. In the LiftOff class, if you replace the call to yield( ) with a call to sleep( ), you get the following: //: concurrency/SleepingTask.java // Calling sleep() to pause for a while. import java.util.concurrent.*;</p>
<p>public class SleepingTask extends LiftOff { public void run() { try {</p>
<p>while(countDown-- &gt; 0) {</p>
<p>System.out.print(status());</p>
<p>// Old-style:</p>
<p>// Thread.sleep(100);</p>
<p>// Java SE5/6-style: TimeUnit.MILLISECONDS.sleep(100);</p>
<p>}</p>
<p>} catch(InterruptedException e) { System.err.println(&quot;Interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; 5; i++)</p>
<p>exec.execute(new SleepingTask()); exec.shutdown();</p>
<p>}</p>
<p>} /* Output:</p>
<p>#0(9),    #1(9),    #2(9),    #3(9),    #4(9),    #0(8),    #1(8),</p>
<p>#0(7),    #1(7),    #2(7),    #3(7),    #4(7),    #0(6),    #1(6),</p>
<p>#0(5),    #1(5),    #2(5),    #3(5),    #4(5),    #0(4),    #1(4),</p>
<p>#0(3),    #1(3),    #2(3),    #3(3),    #4(3),    #0(2),    #1(2),</p>
<p>#0(1),    #1(1),    #2(1),    #3(1),    #4(1),    #0(Liftoff!),</p>
<p>#2(Liftoff!), #3(Liftoff!), #4(Liftoff!),</p>
<p>#2(8), #3(8), #4(8), #2(6), #3(6), #4(6), #2(4), #3(4), #4(4), #2(2), #3(2), #4(2), #1(Liftoff!),</p>
<p>*///:~</p>
<p>The call to sleep( ) can throw an InterruptedException, and you can see that this is caught in run( ). Because exceptions won’t propagate across threads back to main( ), you must locally handle any exceptions that arise within a task.</p>
<p>Java SE5 introduced the more explicit version of sleep( ) as part of the TimeUnit class, as shown in the above example. This provides better readability by allowing you to specify the units of the sleep( ) delay. TimeUnit can also be used to perform conversions, as you shall see later in the chapter.</p>
<p>Depending on your platform, you may notice that the tasks run in &quot;perfectly distributed&quot; order-zero through four, then back to zero again. This makes sense because, after each print statement, each task goes to sleep (it blocks), which allows the thread scheduler to switch to another thread, driving another task. However, the sequential behavior relies on the underlying threading mechanism, which is different from one operating system to another, so you cannot rely on it. If you must control the order of execution of tasks, your best bet is to use synchronization controls (described later) or, in some cases, not to use threads at all, but instead to write your own cooperative routines that hand control to each other in a specified order.</p>
<p>Exercise 6: (2) Create a task that sleeps for a random amount of time between 1 and 10 seconds, then displays its sleep time and exits. Create and run a quantity (given on the command line) of these tasks.</p>
<subtitle>Priority</subtitle>
<p>The priority of a thread conveys the importance of a thread to the scheduler. Although the order in which the CPU runs a set of threads is indeterminate, the scheduler will lean toward running the waiting thread with the highest priority first. However, this doesn’t mean that threads with lower priority aren’t run (so you can’t get deadlocked because of priorities). Lower-priority threads just tend to run less often.</p>
<p>The vast majority of the time, all threads should run at the default priority. Trying to manipulate thread priorities is usually a mistake.</p>
<p>Here’s an example that demonstrates priority levels. You can read the priority of an existing thread with getPriority( ) and change it at any time with setPriority( ).</p>
<p>//: concurrency/SimplePriorities.java // Shows the use of thread priorities. import java.util.concurrent.*;</p>
<p>public class SimplePriorities implements Runnable { private int countDown = 5;</p>
<p>private volatile double d; // No optimization private int priority;</p>
<p>public SimplePriorities(int priority) { this.priority = priority;</p>
<p>}</p>
<p>public String toString() {</p>
<p>return Thread.currentThread() + &quot;: &quot; + countDown;</p>
<p>}</p>
<p>public void run() {</p>
<p>Thread.currentThread().setPriority(priority); while(true) {</p>
<p>// An expensive, interruptable operation: for(int i = 1; i &lt; 100000; i++) { d += (Math.PI + Math.E) / (double)i; if(i % 1000 == 0)</p>
<p>Thread.yield();</p>
<p>}</p>
<p>System.out.println(this); if(--countDown == 0) return;</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; 5; i++) exec.execute(</p>
<p>new SimplePriorities(Thread.MIN_PRIORITY)); exec.execute(</p>
<p>new SimplePriorities(Thread.MAX_PRIORITY)); exec.shutdown();</p>
<p>}</p>
<p>} /* Output: (70% match)</p>
<p>Thread[pool-1-thread-6,10,main]: 5 Thread[pool-1-thread-6,10,main]: 4 Thread[pool-1-thread-6,10,main]: 3 Thread[pool-1-thread-6,10,main]: 2 Thread[pool-1-thread-6,10,main]: 1</p>
<p>Thread[pool-1-thread-3,1,main]: 5 Thread[pool-1-thread-2,1,main]: 5 Thread[pool-1-thread-1,1,main]: 5 Thread[pool-1-thread-5,1,main]: 5 Thread[pool-1-thread-4,1,main]: 5</p>
<p>*///:~</p>
<p>toString( ) is overridden to use Thread.toString( ), which prints the thread name, the priority level, and the &quot;thread group&quot; that the thread belongs to. You can set the thread name yourself via the constructor; here it’s automatically generated as pool-1-thread-1, pool-1-thread-2, etc. The overridden toString( ) also shows the countdown value of the task. Notice that you can get a reference to the Thread object that is driving a task, inside that task, by calling Thread.currentThread( ).</p>
<p>You can see that the priority level of the last thread is at the highest level, and all the rest of the threads are at the lowest level. Note that the priority is set at the beginning of run( ); setting it in the constructor would do no good since the Executor has not begun the task at that point.</p>
<p>Inside run( ), 100,000 repetitions of a rather expensive floating point calculation are performed, involving double addition and division. The variable d is volatile to try to ensure that no compiler optimizations are performed. Without this calculation, you don’t see the effect of setting the priority levels. (Try it: Comment out the for loop containing the double calculations.) With the calculation, you see that the thread with MAX_PRIORITY is given a higher preference by the thread scheduler. (At least, this was the behavior on a Windows XP machine.) Even though printing to the console is also an expensive behavior, you won’t see the priority levels that way, because console printing doesn’t get interrupted (otherwise, the console display would get garbled during threading), whereas the math calculation can be interrupted. The calculation takes long enough that the scheduling mechanism jumps in, swaps tasks, and pays attention to the priorities so that high-priority threads get preference. However, to ensure that a context switch occurs, yield( ) statements are regularly called.</p>
<p>Although the JDK has 10 priority levels, this doesn’t map well to many operating systems.</p>
<p>For example, Windows has 7 priority levels that are not fixed, so the mapping is indeterminate. Sun’s Solaris has 231 levels. The only portable approach is to stick to MAX_PRIORITY, NORM_PRIORITY, and MIN_PRIORITY when you’re adjusting priority levels.</p>
<subtitle>Yielding</subtitle>
<p>If you know that you’ve accomplished what you need to during one pass through a loop in your run( ) method, you can give a hint to the threadscheduling mechanism that you’ve done enough and that some other task might as well have the CPU. This hint (and it is a hint—there’s no guarantee your implementation will listen to it) takes the form of the yield( ) method. When you call yield( ), you are suggesting that other threads of the same priority might be run.</p>
<p>LiftOff.java uses yield( ) to produce well-distributed processing across the various LiftOff tasks. Try commenting out the call to Thread.yield( ) in LiftOff.run( ) to see the difference. In general, however, you can’t rely on yield( ) for any serious control or tuning of your application. Indeed, yield( ) is often used incorrectly.</p>
<subtitle>Daemon threads</subtitle>
<p>A &quot;daemon&quot; thread is intended to provide a general service in the background as long as the program is running, but is not part of the essence of the program. Thus, when all of the nondaemon threads complete, the program is terminated, killing all daemon threads in the process. Conversely, if there are any non-daemon threads still running, the program doesn’t terminate. There is, for instance, a non-daemon thread that runs main( ).</p>
<p>//: concurrency/SimpleDaemons.java</p>
<p>// Daemon threads don’t prevent the program from ending.</p>
<p>import java.util.concurrent.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class SimpleDaemons implements Runnable { public void run() { try {</p>
<p>while(true) {</p>
<p>TimeUnit.MILLISECONDS.sleep(100); print(Thread.currentThread() + &quot; &quot; + this);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;sleep() interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>{</p>
<p>public static void main(String[] args) throws Exception for(int i = 0; i &lt; 10; i++) {</p>
<p>Thread daemon = new Thread(new SimpleDaemons()); daemon.setDaemon(true); // Must call before start() daemon.start();</p>
<p>}</p>
<p>print(&quot;All daemons started&quot;); TimeUnit.MILLISECONDS.sleep(175);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>All daemons started</p>
<p>SimpleDaemons@530daa</p>
<p>SimpleDaemons@a62fc3</p>
<p>SimpleDaemons@89ae9e</p>
<p>SimpleDaemons@1270b73</p>
<p>SimpleDaemons@60aeb0</p>
<p>SimpleDaemons@16caf43</p>
<p>SimpleDaemons@66848c</p>
<p>SimpleDaemons@8813f2</p>
<p>SimpleDaemons@1d58aae</p>
<p>SimpleDaemons@83cc67</p>
<p>Thread[Thread-0,5,main]</p>
<p>Thread[Thread-1,5,main]</p>
<p>Thread[Thread-2,5,main]</p>
<p>Thread[Thread-3,5,main]</p>
<p>Thread[Thread-4,5,main]</p>
<p>Thread[Thread-5,5,main]</p>
<p>Thread[Thread-6,5,main]</p>
<p>Thread[Thread-7,5,main]</p>
<p>Thread[Thread-8,5,main]</p>
<p>Thread[Thread-9,5,main] *///:~</p>
<p>You must set the thread to be a daemon by calling setDaemon( ) before it is started.</p>
<p>There’s nothing to keep the program from terminating once main( ) finishes its job, since there are nothing but daemon threads running. So that you can see the results of starting all the daemon threads, the main( ) thread is briefly put to sleep. Without this, you see only some of the results from the creation of the daemon threads. (Try sleep( ) calls of various lengths to see this behavior.)</p>
<p>SimpleDaemons.java creates explicit Thread objects in order to set their daemon flag. It is possible to customize the attributes (daemon, priority, name) of threads created by Executors by writing a custom ThreadFactory:</p>
<p>//: net/mindview/util/DaemonThreadFactory.java package net.mindview.util; import java.util.concurrent.*;</p>
<p>public class DaemonThreadFactory implements ThreadFactory { public Thread newThread(Runnable r) {</p>
<p>Thread t = new Thread(r); t.setDaemon(true); return t;</p>
<p>}</p>
<p>} ///:~</p>
<p>The only difference from an ordinary ThreadFactory is that this one sets the daemon status to true. You can now pass a new DaemonThreadFactory as an argument to Executors.newCachedThreadPool( ):</p>
<p>//: concurrency/DaemonFromFactory.java</p>
<p>// Using a Thread Factory to create daemons.</p>
<p>import java.util.concurrent.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class DaemonFromFactory implements Runnable { public void run() { try {</p>
<p>while(true) {</p>
<p>TimeUnit.MILLISECONDS.sleep(100); print(Thread.currentThread() + &quot; &quot; + this);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool( new DaemonThreadFactory()); for(int i = 0; i &lt; 10; i++)</p>
<p>exec.execute(new DaemonFromFactory()); print(&quot;All daemons started&quot;);</p>
<p>TimeUnit.MILLISECONDS.sleep(500); // Run for a while</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>Each of the static ExecutorService creation methods is overloaded to take a ThreadFactory object that it will use to create new threads.</p>
<p>We can take this one step further and create a DaemonThreadPoolExecutor utility:</p>
<p>//: net/mindview/util/DaemonThreadPoolExecutor.java package net.mindview.util; import java.util.concurrent.*;</p>
<p>public class DaemonThreadPoolExecutor extends ThreadPoolExecutor {</p>
<p>public DaemonThreadPoolExecutor() {</p>
<p>super(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), new DaemonThreadFactory());</p>
<p>}</p>
<p>} ///:~</p>
<p>To get the values for the constructor base-class call, I simply looked at the Executors.java source code.</p>
<p>You can find out if a thread is a daemon by calling isDaemon( ). If a thread is a daemon, then any threads it creates will automatically be daemons, as the following example demonstrates: //: concurrency/Daemons.java</p>
<p>// Daemon threads spawn other daemon threads.</p>
<p>import java.util.concurrent.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Daemon implements Runnable { private Thread[] t = new Thread[10]; public void run() {</p>
<p>for(int i = 0; i &lt; t.length; i++) { t[i] = new Thread(new DaemonSpawn()); t[i].start();</p>
<p>printnb(&quot;DaemonSpawn &quot; + i + &quot; started, &quot;);</p>
<p>}</p>
<p>for(int i = 0; i &lt; t.length; i++)</p>
<p>printnb(&quot;t[&quot; + i + &quot;].isDaemon() = &quot; + t[i].isDaemon() + &quot;, &quot;); while(true)</p>
<p>Thread.yield();</p>
<p>}</p>
<p>}</p>
<p>class DaemonSpawn implements Runnable { public void run() { while(true)</p>
<p>Thread.yield();</p>
<p>}</p>
<p>}</p>
<p>public class Daemons {</p>
<p>public static void main(String[] args) throws Exception { Thread d = new Thread(new Daemon()); d.setDaemon(true); d.start();</p>
<p>printnb(&quot;d.isDaemon() = &quot; + d.isDaemon() + &quot;, &quot;);</p>
<p>// Allow the daemon threads to // finish their startup processes: TimeUnit.SECONDS.sleep(1);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>d.isDaemon() = true, DaemonSpawn 0 started, DaemonSpawn 1 started, DaemonSpawn 2 started, DaemonSpawn 3 started, DaemonSpawn 4 started, DaemonSpawn 5 started, DaemonSpawn 6 started, DaemonSpawn 7 started, DaemonSpawn 8 started, DaemonSpawn 9 started, t[0].isDaemon() =    true,</p>
<p>t[1].isDaemon()    =    true,    t[2].isDaemon()    =    true,    t[3].isDaemon()    =    true,</p>
<p>t[4].isDaemon()    =    true,    t[5].isDaemon()    =    true,    t[6].isDaemon()    =    true,</p>
<p>t[7].isDaemon()    =    true,    t[8].isDaemon()    =    true,    t[9].isDaemon()    =    true,</p>
<p>*///:~</p>
<p>The Daemon thread is set to daemon mode. It then spawns a bunch of other threads—which are nor explicitly set to daemon mode—to show that they are daemons anyway. Then Daemon goes into an infinite loop that calls yield( ) to give up control to the other processes.</p>
<p>You should be aware that daemon threads will terminate their run( ) methods without executing finally clauses:</p>
<p>//: concurrency/DaemonsDontRunFinally.java</p>
<p>// Daemon threads don’t run the finally clause</p>
<p>import java.util.concurrent.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class ADaemon implements Runnable { public void run() { try {</p>
<p>print(&quot;Starting ADaemon&quot;);</p>
<p>TimeUnit.SECONDS.sleep(l);</p>
<p>} catch(InterruptedException e) {</p>
<p>print(&quot;Exiting via InterruptedException&quot;);</p>
<p>} finally {</p>
<p>print(&quot;This should always run?&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class DaemonsDontRunFinally {</p>
<p>public static void main(String[] args) throws Exception { Thread t = new Thread(new ADaemon()); t.setDaemon(true); t.start();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Starting ADaemon *///:~</p>
<p>When you run this program, you’ll see that the finally clause is not executed, but if you comment out the call to setDaemon( ), you’ll see that the finally clause is executed.</p>
<p>This behavior is correct, even if you don’t expect it based on the previous promises given for finally. Daemons are terminated &quot;abruptly&quot; when the last of the non-daemons terminates. So as soon as main( ) exits, the JVM shuts down all the daemons immediately, without any of the formalities you might have come to expect. Because you cannot shut daemons down in a nice fashion, they are rarely a good idea. Non-daemon Executors are generally a better approach, since all the tasks controlled by an Executor can be shut down at once. As you shall see later in the chapter, shutdown in this case proceeds in an orderly fashion.</p>
<p>Exercise 7: (2) Experiment with different sleep times in Daemons.java to see what happens.</p>
<p>Exercise 8: (1) Modify MoreBasicThreads.java so that all the threads are daemon threads, and verify that the program ends as soon as main( ) is able to exit.</p>
<p>Exercise 9: (3) Modify SimplePriorities.java so that a custom ThreadFactory sets the priorities of the threads.</p>
<subtitle>Coding variations</subtitle>
<p>In the examples that you’ve seen so far, the task classes all implement Runnable. In very simple cases, you may want to use the alternative approach of inheriting directly from Thread, like this:</p>
<p>//: concurrency/SimpleThread.java // Inheriting directly from the Thread class.</p>
<p>public class SimpleThread extends Thread { private int countDown = 5; private static int threadCount = 0;</p>
<p>public SimpleThread() {</p>
<p>// Store the thread name:</p>
<p>super(Integer.toString(++threadCount));</p>
<p>start();</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;#&quot; + getName() + &quot;(&quot; + countDown + &quot;), &quot;</p>
<p>}</p>
<p>public void run() { while(true) {</p>
<p>System.out.print(this); if(--countDown == 0) return;</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 5; i++) new SimpleThread();</p>
<p>}</p>
<p>} /* Output:</p>
<p>#1(5), #1(4), #1(3), #1(2), #1(1), #2(5), #2(4), #2(3), #2(2), #2(1), #3(5), #3(4), #3(3), #3(2), #3(1), #4(5), #4(4), #4(3), #4(2), #4(1), #5(5), #5(4), #5(3), #5(2), #5(1),</p>
<p>*///:~</p>
<p>You give the Thread objects specific names by calling the appropriate Thread constructor. This name is retrieved in toString( ) using getName( ).</p>
<p>Another idiom that you may see is that of the self-managed Runnable:</p>
<p>//: concurrency/SelfManaged.java</p>
<p>// A Runnable containing its own driver Thread.</p>
<p>public class SelfManaged implements Runnable { private int countDown = 5; private Thread t = new Thread(this); public SelfManaged() { t.start(); } public String toString() {</p>
<p>return Thread.currentThread().getName() +</p>
<p>&quot;(&quot; + countDown + &quot;), &quot;;</p>
<p>}</p>
<p>public void run() { while(true) {</p>
<p>System.out.print(this); if(--countDown == 0) return;</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) { for(int i = 0; i &lt; 5; i++) new SelfManaged();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Thread-0(5), Thread-0(4), Thread-0(3), Thread-0(2), Thread-0(1), Thread-1(5), Thread-1(4), Thread-1(3), Thread-1(2), Thread-1(1), Thread-2(5), Thread-2(4), Thread-2(3), Thread-2(2), Thread-2(1), Thread-3(5), Thread-3(4), Thread-3(3), Thread-3(2), Thread-3(1), Thread-4(5), Thread-4(4), Thread-4(3), Thread-4(2), Thread-4(1),</p>
<p>*///:~</p>
<p>This is not especially different from inheriting from Thread except that the syntax is slightly more awkward. However, implementing an interface does allow you to inherit from a different class, whereas inheriting from Thread does not.</p>
<p>Notice that start( ) is called within the constructor. This example is quite simple and therefore probably safe, but you should be aware that starting threads inside a constructor can be quite problematic, because another task might start executing before the constructor has completed, which means the task may be able to access the object in an unstable state. This is yet another reason to prefer the use of Executors to the explicit creation of Thread objects.</p>
<p>Sometimes it makes sense to hide your threading code inside your class by using an inner class, as shown here:</p>
<p>//: concurrency/ThreadVariations.java // Creating threads with inner classes. import java.util.concurrent.*; import static net.mindview.util.Print.*;</p>
<p>// Using a named inner class: class InnerThread1 {</p>
<p>private int countDown = 5;</p>
<p>private Inner inner;</p>
<p>private class Inner extends Thread {</p>
<p>Inner(String name) { super(name); start();</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(true) { print(this);</p>
<p>if(--countDown == 0) return; sleep(10);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>public String toString() {</p>
<p>return getName() + &quot;: &quot; + countDown;</p>
<p>}</p>
<p>}</p>
<p>public InnerThread1(String name) { inner = new Inner(name);</p>
<p>}</p>
<p>}</p>
<p>// Using an anonymous inner class: class InnerThread2 {</p>
<p>private int countDown = 5; private Thread t;</p>
<p>public InnerThread2(String name) { t = new Thread(name) { public void run() { try {</p>
<p>while(true) { print(this);</p>
<p>if(--countDown == 0) return; sleep(10);</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>print(&quot;sleep() interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>public String toString() {</p>
<p>return getName() + &quot;: &quot; + countDown;</p>
<p>}</p>
<p>};</p>
<p>t.start();</p>
<p>}</p>
<p>}</p>
<p>// Using a named Runnable implementation: class InnerRunnablel {</p>
<p>private int countDown = 5; private Inner inner;</p>
<p>private class Inner implements Runnable {</p>
<p>Thread t;</p>
<p>Inner(String name) {</p>
<p>t = new Thread(this, name); t.start();</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(true) { print(this);</p>
<p>if(--countDown == 0) return; TimeUnit.MILLISECONDS.sleep(10);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;sleep() interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>public String toString() {</p>
<p>return t.getName() + &quot;: &quot; + countDown;</p>
<p>}</p>
<p>}</p>
<p>public InnerRunnable1(String name) { inner = new Inner(name);</p>
<p>}</p>
<p>}</p>
<p>// Using an anonymous Runnable implementation: class InnerRunnable2 {</p>
<p>private int countDown = 5; private Thread t;</p>
<p>public InnerRunnable2(String name) { t = new Thread(new Runnable() { public void run() { try {</p>
<p>while(true) { print(this);</p>
<p>if(--countDown == 0) return; TimeUnit.MILLISECONDS.sleep(10);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;sleep() interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>public String toString() {</p>
<p>return Thread.currentThread().getName() + &quot;: &quot; + countDown;</p>
<p>}</p>
<p>}, name);</p>
<p>// A separate method to run some code as a task: class ThreadMethod {</p>
<p>private int countDown = 5; private Thread t; private String name;</p>
<p>public ThreadMethod(String name) { this.name = name; } public void runTask() { if(t == null) {</p>
<p>t = new Thread(name) { public void run() { try {</p>
<p>while(true) { print(this);</p>
<p>if(--countDown == 0) return; sleep(10);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;sleep() interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>public String toString() {</p>
<p>return getName() + &quot;: &quot; + countDown;</p>
<p>}</p>
<p>};</p>
<p>t.start();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class ThreadVariations {</p>
<p>public static void main(String[] args) { new InnerThread1(&quot;InnerThread1&quot;); new InnerThread2(&quot;InnerThread2&quot;); new InnerRunnable1(&quot;InnerRunnable1&quot;); new InnerRunnable2(&quot;InnerRunnable2&quot;); new ThreadMethod(&quot;ThreadMethod&quot;).runTask();</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>InnerThreadi creates a named inner class that extends Thread, and makes an instance of this inner class inside the constructor. This makes sense if the inner class has special capabilities (new methods) that you need to access in other methods. However, most of the time the reason for creating a thread is only to use the Thread capabilities, so it’s not necessary to create a named inner class. InnerThread2 shows the alternative: An anonymous inner subclass of Thread is created inside the constructor and is upcast to a Thread reference t. If other methods of the class need to access t, they can do so through the Thread interface, and they don’t need to know the exact type of the object.</p>
<p>The third and fourth classes in the example repeat the first two classes, but they use the Runnable interface rather than the Thread class.</p>
<p>The ThreadMethod class shows the creation of a thread inside a method. You call the method when you’re ready to run the thread, and the method returns after the thread begins. If the thread is only performing an auxiliary operation rather than being fundamental to the class, this is probably a more useful and appropriate approach than starting a thread inside the constructor of the class.</p>
<p>Exercise 10: (4) Modify Exercise 5 following the example of the ThreadMethod class, so that runTask( ) takes an argument of the number of Fibonacci numbers to sum, and each time you call runTask( ) it returns the Future produced by the call to submit( ).</p>
<subtitle>Terminology</subtitle>
<p>As the previous section shows, you have choices in how you implement concurrent programs in Java, and these choices can be confusing. Often the problem comes from the terminology that’s used in describing concurrent program technology, especially where threads are involved.</p>
<p>You should see by now that there’s a distinction between the task that’s being executed and the thread that drives it; this distinction is especially clear in the Java libraries because you don’t really have any control over the Thread class (and this separation is even clearer with executors, which take care of the creation and management of threads for you). You create tasks and somehow attach a thread to your task so that the thread will drive that task.</p>
<p>In Java, the Thread class by itself does nothing. It drives the task that it’s given. Yet threading literature invariably uses language like &quot;the thread performs this or that action.&quot; The impression that you get is that the thread is the task, and when I first encountered Java threads, this impression was so strong that I saw a clear &quot;is-a&quot; relationship, which said to me that I should obviously inherit a task from a Thread. Add to this the poor choice of name for the Runnable interface, which I think would have been much better named &quot;Task.&quot; If the interface is clearly nothing more than a generic encapsulation of its methods, then the &quot;it-does-this-thing-able&quot; naming approach is appropriate, but if it intends to express a higher concept, like Task, then the concept name is more helpful.</p>
<p>The problem is that the levels of abstraction are mixed together. Conceptually, we want to create a task that runs independently of other tasks, so we ought to be able to define a task, and then say &quot;go,&quot; and not worry about details. But physically, threads can be expensive to create, so you must conserve and manage them. Thus it makes sense from an implementation standpoint to separate tasks from threads. In addition, Java threading is based on the low-level pthreads approach which comes from C, where you are immersed in, and must thoroughly understand, the nuts and bolts of everything that’s going on. Some of this low-level nature has trickled through into the Java implementation, so to stay at a higher level of abstraction, you must use discipline when writing code (I will try to demonstrate that discipline in this chapter).</p>
<p>To clarify these discussions, I shall attempt to use the term &quot;task&quot; when I am describing the work that is being done, and &quot;thread&quot; only when I am referring to the specific mechanism that’s driving the task. Thus, if you are discussing a system at a conceptual level, you could just use the term &quot;task&quot; without mentioning the driving mechanism at all.</p>
<subtitle>Joining a thread</subtitle>
<p>One thread may call join( ) on another thread to wait for the second thread to complete before proceeding. If a thread calls t.join( ) on another thread t, then the calling thread is suspended until the target thread t finishes (when t.isAlive( ) is false).</p>
<p>You may also call join( ) with a timeout argument (in either milliseconds or milliseconds and nanoseconds) so that if the target thread doesn’t finish in that period of time, the call to join( ) returns anyway.</p>
<p>The call to join( ) may be aborted by calling interrupt( ) on the calling thread, so a try-catch clause is required.</p>
<p>All of these operations are shown in the following example:</p>
<p>//: concurrency/Joining.java</p>
<p>// Understanding join().</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Sleeper extends Thread { private int duration;</p>
<p>public Sleeper(String name, int sleepTime) { super(name); duration = sleepTime; start();</p>
<p>}</p>
<p>public void run() { try {</p>
<p>sleep(duration);</p>
<p>} catch(InterruptedException e) {</p>
<p>print(getName() + &quot; was interrupted. &quot; + &quot;isInterrupted(): &quot; + isInterrupted()); return;</p>
<p>}</p>
<p>print(getName() + &quot; has awakened&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Joiner extends Thread { private Sleeper sleeper;</p>
<p>public Joiner(String name, Sleeper sleeper) { super(name); this.sleeper = sleeper; start();</p>
<p>}</p>
<p>public void run() { try {</p>
<p>sleeper.join();</p>
<p>} catch(InterruptedException e) { print(&quot;Interrupted&quot;);</p>
<p>}</p>
<p>print(getName() + &quot; join completed&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class Joining {</p>
<p>public static void main(String[] args) { Sleeper</p>
<p>sleepy = new Sleeper(&quot;Sleepy&quot;, 1500), grumpy = new Sleeper(&quot;Grumpy&quot;, 1500); Joiner</p>
<p>dopey = new Joiner(&quot;Dopey&quot;, sleepy), doc = new Joiner(&quot;Doc&quot;, grumpy); grumpy.interrupt();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Grumpy was interrupted. isInterrupted(): false Doc join completed Sleepy has awakened Dopey join completed *///:~</p>
<p>A Sleeper is a thread that goes to sleep for a time specified in its constructor. In run( ), the call to sleep( ) may terminate when the time expires, but it may also be interrupted. Inside the catch clause, the interruption is reported, along with the value of isInterrupted( ).</p>
<p>When another thread calls interrupt( ) on this thread, a flag is set to indicate that the thread has been interrupted. However, this flag is cleared when the exception is caught, so the result will always be false inside the catch clause. The flag is used for other situations where a thread may examine its interrupted state apart from the exception.</p>
<p>A Joiner is a task that waits for a Sleeper to wake up by calling join( ) on the Sleeper object. In main( ), each Sleeper has a Joiner, and you can see in the output that if the Sleeper either is interrupted or ends normally, the Joiner completes in conjunction with the Sleeper.</p>
<p>Note that the Java SE5 java.util.concurrent libraries contain tools such as CyclicBarrier (demonstrated later in this chapter) that may be more appropriate than join( ), which was part of the original threading library.</p>
<subtitle>Creating responsive user interfaces</subtitle>
<p>As stated earlier, one of the motivations for using threading is to create a responsive user interface. Although we won’t get to graphical interfaces until the Graphical User Interfaces chapter, the following example is a simple mock-up of a console-based user interface. The example has two versions: one that gets stuck in a calculation and thus can never read console input, and a second that puts the calculation inside a task and thus can be performing the calculation and listening for console input.</p>
<p>//: concurrency/ResponsiveUI.java // User interface responsiveness.</p>
<p>// {RunByHand}</p>
<p>class UnresponsiveUI {</p>
<p>private volatile double d = 1; public UnresponsiveUI() throws Exception { while(d &gt; 0)</p>
<p>d = d + (Math.PI + Math.E) / d;</p>
<p>System.in.read(); // Never gets here</p>
<p>}</p>
<p>}</p>
<p>public class ResponsiveUI extends Thread { private static volatile double d = 1; public ResponsiveUI() { setDaemon(true); start();</p>
<p>}</p>
<p>public void run() { while(true) {</p>
<p>d = d + (Math.PI + Math.E) / d;</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>//! new UnresponsiveUI(); // Must kill this process new ResponsiveUI();</p>
<p>System.in.read();</p>
<p>System.out.println(d); // Shows progress</p>
<p>}</p>
<p>} ///:~</p>
<p>UnresponsiveUI performs a calculation inside an infinite while loop, so it can obviously never reach the console input line (the compiler is fooled into believing that the input line is reachable by the while conditional). If you uncomment the line that creates an UnresponsiveUI, you’ll have to kill the process to get out.</p>
<p>To make the program responsive, put the calculation inside a run( ) method to allow it to be preempted, and when you press the Enter key, you’ll see that the calculation has indeed been running in the background while waiting for your user input.</p>
<subtitle>Thread groups</subtitle>
<p>A thread group holds a collection of threads. The value of thread groups can be summed up by a quote from Joshua Bloch,<a l:href="#bookmark114" type="note"><sup>115</sup></a><sup></sup> the software architect who, while he was at Sun, fixed and greatly improved the Java collections library in JDK 1.2 (among other contributions):</p>
<p>&quot;Thread groups are best viewed as an unsuccessful experiment, and you may simply ignore their existence.&quot;</p>
<p>If you’ve spent time and energy trying to figure out the value of thread groups (as I have), you may wonder why there was not some more official announcement from Sun on the topic—the same question can be asked about any number of other changes that have happened to Java over the years. The Nobel laureate economist Joseph Stiglitz has a philosophy of life that would seem to apply here.<a l:href="#bookmark115" type="note"><sup>116</sup></a><sup></sup> It’s called The Theory of Escalating Commitment:</p>
<p>&quot;The cost of continuing mistakes is borne by others, while the cost of admitting mistakes is borne by yourself.&quot;</p>
<subtitle>Catching exceptions</subtitle>
<p>Because of the nature of threads, you can’t catch an exception that has escaped from a thread. Once an exception gets outside of a task’s run( ) method, it will propagate out to the console unless you take special steps to capture such errant exceptions. Before Java SE5, you used thread groups to catch these exceptions, but with Java SE5 you can solve the problem with Executors, and thus you no longer need to know anything about thread groups (except to understand legacy code; see Thinking in Java, 2ndEdition, downloadable from <a l:href="http://www.MindView.net">www.MindView.net</a>, for details about thread groups).</p>
<p>Here’s a task that always throws an exception which propagates outside of its run( ) method, and a main( ) that shows what happens when you run it:</p>
<p>//: concurrency/ExceptionThread.java</p>
<p>// {ThrowsException}</p>
<p>import java.util.concurrent.*;</p>
<p>public class ExceptionThread implements Runnable { public void run() {</p>
<p>throw new RuntimeException();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new ExceptionThread());</p>
<p>}</p>
<p>} ///:~</p>
<p>The output is (after trimming some qualifiers to fit): java.lang.RuntimeException</p>
<p>at ExceptionThread.run(ExceptionThread.java:7) at ThreadPoo!Executor$Worker.runTask(Unknown Source) at ThreadPoo!Executor$Worker.run(Unknown Source) at Java.lang.Thread.run(Unknown Source)</p>
<p>Encompassing the body of main within a try-catch block is unsuccessful:</p>
<p>//: concurrency/NaiveExceptionHandling.java</p>
<p>// {ThrowsException}</p>
<p>import java.util.concurrent.*;</p>
<p>public class NaiveExceptionHandling { public static void main(String[] args) { try {</p>
<p>ExecutorService exec =</p>
<p>Executors.newCachedThreadPool(); exec.execute(new ExceptionThread());</p>
<p>} catch(RuntimeException ue) {</p>
<p>// This statement will NOT execute!</p>
<p>System.out.println(&quot;Exception has been handled!&quot;);</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>This produces the same result as the previous example: an uncaught exception.</p>
<p>To solve the problem, we change the way the Executor produces threads. Thread.UncaughtExceptionHandler is a new interface in Java SE5; it allows you to attach an exception handler to each Thread object.</p>
<p>Thread.UncaughtExceptionHandler.uncaughtException( ) is automatically called when that thread is about to die from an uncaught exception. To use it, we create a new type of ThreadFactory which attaches a new Thread.UncaughtExceptionHandler to each new Thread object it creates. We pass that factory to the Executors method that creates a new ExecutorService:</p>
<p>//: concurrency/CaptureUncaughtException.java import java.util.concurrent.*;</p>
<p>class ExceptionThread2 implements Runnable { public void run() {</p>
<p>Thread t = Thread.currentThread();</p>
<p>System.out.println(&quot;run() by &quot; + t);</p>
<p>System.out.println(</p>
<p>&quot;eh = &quot; + t.getUncaughtExceptionHandler()); throw new RuntimeException();</p>
<p>}</p>
<p>}</p>
<p>class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {</p>
<p>public void uncaughtException(Thread t, Throwable e) { System.out.println(&quot;caught &quot; + e);</p>
<p>}</p>
<p>}</p>
<p>class HandlerThreadFactory implements ThreadFactory { public Thread newThread(Runnable r) {</p>
<p>System.out.println(this + &quot; creating new Thread&quot;);</p>
<p>Thread t = new Thread(r);</p>
<p>System.out.println(&quot;created &quot; + t); t.setUncaughtExceptionHandler(</p>
<p>new MyUncaughtExceptionHandler()); System.out.println(</p>
<p>&quot;eh = &quot; + t.getUncaughtExceptionHandler()); return t;</p>
<p>}</p>
<p>}</p>
<p>public class CaptureUncaughtException { public static void main(String[] args) {</p>
<p>ExecutorService exec = Executors.newCachedThreadPool( new HandlerThreadFactory()); exec.execute(new ExceptionThread2());</p>
<p>}</p>
<p>} /* Output: (90% match)</p>
<p>HandlerThreadFactory@de6ced creating new Thread created Thread[Thread-0,5,main] eh = MyUncaughtExceptionHandler@1fb8ee3 run() by Thread[Thread-0,5,main] eh = MyUncaughtExceptionHandler@1fb8ee3 caught java.lang.RuntimeException *///:~</p>
<p>Additional tracing has been added to verify that the threads created by the factory are given the new UncaughtExceptionHandler. You can see that the uncaught exceptions are now being captured by uncaughtException.</p>
<p>The above example allows you to set the handler on a case-by-case basis. If you know that you’re going to use the same exception handler everywhere, an even simpler approach is to set the default uncaught exception handler, which sets a static field inside the Thread class:</p>
<p>//: concurrency/SettingDefaultHandler.java import java.util.concurrent.*;</p>
<p>public class SettingDefaultHandler {</p>
<p>public static void main(String[] args) { Thread.setDefaultUncaughtExceptionHandler( new MyUncaughtExceptionHandler());</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new ExceptionThread());</p>
<p>}</p>
<p>} /* Output:</p>
<p>caught java.lang.RuntimeException *///:~</p>
<p>This handler is only called if there is no per-thread uncaught exception handler. The system checks for a per-thread version, and if it doesn’t find one it checks to see if the thread group specializes its uncaughtException( ) method; if not, it calls the defaultUncaughtExceptionHandler.</p>
</section>
<section>
<title>
<p>Sharing resources</p></title><empty-line/>
<p>You can think of a single-threaded program as one lonely entity moving around through your problem space and doing one thing at a time. Because there’s only one entity, you never have to think about the problem of two entities trying to use the same resource at the same time: problems such as two people trying to park in the same space, walk through a door at the same time, or even talk at the same time.</p>
<p>With concurrency, things aren’t lonely anymore, but you now have the possibility of two or more tasks interfering with each other. If you don’t prevent such a collision, you’ll have two tasks trying to access the same bank account at the same time, print to the same printer, adjust the same valve, and so on.</p>
<subtitle>Improperly accessing resources</subtitle>
<p>Consider the following example, where one task generates even numbers and other tasks consume those numbers. Here, the only job of the consumer tasks is to check the validity of the even numbers.</p>
<p>First we’ll define EvenChecker, the consumer task, since it will be reused in all the subsequent examples. To decouple EvenChecker from the various types of generators that we will experiment with, we’ll create an abstract class called IntGenerator, which contains the minimum necessary methods that EvenChecker must know about: that it has a next( ) method and that it can be canceled. This class doesn’t implement the Generator interface, because it must produce an int, and generics don’t support primitive parameters.</p>
<p>//: concurrency/IntGenerator.java</p>
<p>public abstract class IntGenerator {</p>
<p>private volatile boolean canceled = false; public abstract int next();</p>
<p>// Allow this to be canceled:</p>
<p>public void cancel() { canceled = true; }</p>
<p>public boolean isCanceled() { return canceled; }</p>
<p>} ///:~</p>
<p>IntGenerator has a cancel( ) method to change the state of a boolean canceled flag and isCanceled( ) to see whether the object has been canceled. Because the canceled flag is a boolean, it is atomic, which means that simple operations like assignment and value return happen without the possibility of interruption, so you can’t see the field in an intermediate state in the midst of those simple operations. The canceled flag is also volatile in order to ensure visibility. You’ll learn about atomicity and visibility later in this chapter.</p>
<p>Any IntGenerator can be tested with the following EvenChecker class:</p>
<p>//: concurrency/EvenChecker.java import java.util.concurrent.*;</p>
<p>public class EvenChecker implements Runnable { private IntGenerator generator; private final int id;</p>
<p>public EvenChecker(IntGenerator g, int ident) { generator = g; id = ident;</p>
<p>}</p>
<p>public void run() {</p>
<p>while(!generator.isCanceled()) { int val = generator.next(); if(val % 2 != 0) {</p>
<p>System.out.println(val + &quot; not even!&quot;); generator.cancel(); // Cancels all EvenCheckers</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Test any type of IntGenerator:</p>
<p>public static void test(IntGenerator gp, int count) { System.out.println(&quot;Press Control-C to exit&quot;);</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; count; i++)</p>
<p>exec.execute(new EvenChecker(gp, i)); exec.shutdown();</p>
<p>// Default value for count: public static void test(IntGenerator gp) { test(gp, 10);</p>
<p>}</p>
<p>} ///:~</p>
<p>Note that in this example the class that can be canceled is not Runnable. Instead, all the EvenChecker tasks that depend on the IntGenerator object test it to see whether it’s been canceled, as you can see in run( ). This way, the tasks that share the common resource (the IntGenerator) watch that resource for the signal to terminate. This eliminates the so-called race condition, where two or more tasks race to respond to a condition and thus collide or otherwise produce inconsistent results. You must be careful to think about and protect against all the possible ways a concurrent system can fail. For example, a task cannot depend on another task, because task shutdown order is not guaranteed. Here, by making tasks depend on a nontask object, we eliminate the potential race condition.</p>
<p>The test( ) method sets up and performs a test of any type of IntGenerator by starting a number of EvenCheckers that use the same IntGenerator. If the IntGenerator causes a failure, test( ) will report it and return; otherwise, you must press Control-C to terminate it.</p>
<p>EvenChecker tasks constantly read and test the values from their associated IntGenerator. Note that if generator.isCanceled( ) is true, run( ) returns, which tells the Executor in EvenChecker.test( ) that the task is complete. Any EvenChecker task can call cancel( ) on its associated IntGenerator, which will cause all other EvenCheckers using that IntGenerator to gracefully shut down. In later sections, you’ll see that Java contains more general mechanisms for termination of threads.</p>
<p>The first IntGenerator we’ll look at has a next( ) that produces a series of even values:</p>
<p>//: concurrency/EvenGenerator.java // When threads collide.</p>
<p>public class EvenGenerator extends IntGenerator { private int currentEvenValue = 0; public int next() {</p>
<p>++currentEvenValue; // Danger point here!</p>
<p>++currentEvenValue; return currentEvenValue;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>EvenChecker.test(new EvenGenerator());</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Press Control-C to exit 89476993 not even!</p>
<p>89476993 not even!</p>
<p>*///:~</p>
<p>It’s possible for one task to call next( ) after another task has performed the first increment of currentEvenValue but not the second (at the place in the code commented &quot;Danger point here!&quot;). This puts the value into an &quot;incorrect&quot; state. To prove that this can happen, EvenChecker.test( ) creates a group of EvenChecker objects to continually read the output of an EvenGenerator and test to see if each one is even. If not, the error is reported and the program is shut down.</p>
<p>This program will eventually fail because the EvenChecker tasks are able to access the information in EvenGenerator while it’s in an &quot;incorrect&quot; state. However, it may not detect</p>
<p>the problem until the EvenGenerator has completed many cycles, depending on the particulars of your operating system and other implementation details. If you want to see it fail much faster, try putting a call to yield( ) between the first and second increments. This is part of the problem with multithreaded programs—they can appear to be correct even when there’s a bug, if the probability for failure is very low.</p>
<p>It’s important to note that the increment operation itself requires multiple steps, and the task can be suspended by the threading mechanism in the midst of an increment—that is, increment is not an atomic operation in Java. So even a single increment isn’t safe to do without protecting the task.</p>
<subtitle>Resolving shared resource contention</subtitle>
<p>The previous example shows a fundamental problem when you are using threads: You never know when a thread might be run. Imagine sitting at a table with a fork, about to spear the last piece of food on a platter, and as your fork reaches for it, the food suddenly vanishes— because your thread was suspended and another diner came in and ate the food. That’s the problem you’re dealing with when writing concurrent programs. For concurrency to work, you need some way to prevent two tasks from accessing the same resource, at least during critical periods.</p>
<p>Preventing this kind of collision is simply a matter of putting a lock on a resource when one task is using it. The first task that accesses a resource must lock it, and then the other tasks cannot access that resource until it is unlocked, at which time another task locks and uses it, and so on. If the front seat of the car is the limited resource, the child who shouts &quot;shotgun!&quot; acquires the lock (for the duration of that trip).</p>
<p>To solve the problem of thread collision, virtually all concurrency schemes serialize access to shared resources. This means that only one task at a time is allowed to access the shared resource. This is ordinarily accomplished by putting a clause around a piece of code that only allows one task at a time to pass through that piece of code. Because this clause produces mutual exclusion, a common name for such a mechanism is mutex.</p>
<p>Consider the bathroom in your house; multiple people (tasks driven by threads) may each want to have exclusive use of the bathroom (the shared resource). To access the bathroom, a person knocks on the door to see if it’s available. If so, they enter and lock the door. Any other task that wants to use the bathroom is &quot;blocked&quot; from using it, so those tasks wait at the door until the bathroom is available.</p>
<p>The analogy breaks down a bit when the bathroom is released and it comes time to give access to another task. There isn’t actually a line of people, and we don’t know for sure who gets the bathroom next, because the thread scheduler isn’t deterministic that way. Instead, it’s as if there is a group of blocked tasks milling about in front of the bathroom, and when the task that has locked the bathroom unlocks it and emerges, the one that happens to be nearest the door at the moment goes in. As noted earlier, suggestions can be made to the thread scheduler via yield( ) and setPriority( ), but these suggestions may not have much of an effect, depending on your platform and JVM implementation.</p>
<p>To prevent collisions over resources, Java has built-in support in the form of the synchronized keyword. When a task wishes to execute a piece of code guarded by the synchronized keyword, it checks to see if the lock is available, then acquires it, executes the code, and releases it.</p>
<p>The shared resource is typically just a piece of memory in the form of an object, but may also be a file, an I/O port, or something like a printer. To control access to a shared resource, you first put it inside an object. Then any method that uses the resource can be made synchronized. If a task is in a call to one of the synchronized methods, all other tasks are blocked from entering any of the synchronized methods of that object until the first task returns from its call.</p>
<p>In production code, you’ve already seen that you should make the data elements of a class private and access that memory only through methods. You can prevent collisions by declaring those methods synchronized, like this:</p>
<p>synchronized void f() { /* ... */ } synchronized void g() { /* ... */ }</p>
<p>All objects automatically contain a single lock (also referred to as a monitor). When you call any synchronized method, that object is locked and no other synchronized method of that object can be called until the first one finishes and releases the lock. For the preceding methods, if f( ) is called for an object by one task, a different task cannot call f( ) or g( ) for the same object until f( ) is completed and releases the lock. Thus, there is a single lock that is shared by all the synchronized methods of a particular object, and this lock can be used to prevent object memory from being written by more than one task at a time.</p>
<p>Note that it’s especially important to make fields private when working with concurrency; otherwise the synchronized keyword cannot prevent another task from accessing a field directly, and thus producing collisions.</p>
<p>One task may acquire an object’s lock multiple times. This happens if one method calls a second method on the same object, which in turn calls another method on the same object, etc. The JVM keeps track of the number of times the object has been locked. If the object is unlocked, it has a count of zero. As a task acquires the lock for the first time, the count goes to one. Each time the same task acquires another lock on the same object, the count is incremented. Naturally, multiple lock acquisition is only allowed for the task that acquired the lock in the first place. Each time the task leaves a synchronized method, the count is decremented, until the count goes to zero, releasing the lock entirely for use by other tasks.</p>
<p>There’s also a single lock per class (as part of the Class object for the class), so that synchronized static methods can lock each other out from simultaneous access of static data on a class-wide basis.</p>
<p>When should you synchronize? Apply Brian’s Rule of Synchronization:<a l:href="#bookmark116" type="note"><sup>117</sup></a><sup></sup></p>
<p>If you are writing a variable that might next be read by another thread, or reading a variable that might have last been written by another thread, you must use synchronization, and further, both the reader and the writer must synchronize using the same monitor lock.</p>
<p>If you have more than one method in your class that deals with the critical data, you must synchronize all relevant methods. If you synchronize only one of the methods, then the others are free to ignore the object lock and can be called with impunity. This is an important point: Every method that accesses a critical shared resource must be synchronized or it won’t work right.</p>
<p>Synchronizing the EvenGenerator</p>
<p>By adding synchronized to EvenGenerator.java, we can prevent the undesirable thread access:</p>
<p>//: concurrency/SynchronizedEvenGenerator.java</p>
<p>public class</p>
<p>SynchronizedEvenGenerator extends IntGenerator { private int currentEvenValue = 0; public synchronized int next() {</p>
<p>++currentEvenValue;</p>
<p>Thread.yield(); // Cause failure faster</p>
<p>++currentEvenValue;</p>
<p>return currentEvenValue;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>EvenChecker.test(new SynchronizedEvenGenerator());</p>
<p>}</p>
<p>} ///:~</p>
<p>A call to Thread.yield( ) is inserted between the two increments, to raise the likelihood of a context switch while currentEvenValue is in an odd state. Because the mutex prevents more than one task at a time in the critical section, this will not produce a failure, but calling yield( ) is a helpful way to promote a failure if it’s going to happen.</p>
<p>The first task that enters next( ) acquires the lock, and any further tasks that try to acquire the lock are blocked from doing so until the first task releases the lock. At that point, the scheduling mechanism selects another task that is waiting on the lock. This way, only one task at a time can pass through the code that is guarded by the mutex.</p>
<p>Exercise 11: (3) Create a class containing two data fields, and a method that manipulates those fields in a multistep process so that, during the execution of that method, those fields are in an &quot;improper state&quot; (according to some definition that you establish). Add methods to read the fields, and create multiple threads to call the various methods and show that the data is visible in its &quot;improper state.&quot; Fix the problem using the synchronized keyword.</p>
<p>Using explicit Lock objects</p>
<p>The Java SE5 java.util.concurrent library also contains an explicit mutex mechanism defined in java.util.concurrent.locks. The Lock object must be explicitly created, locked and unlocked; thus, it produces less elegant code than the built-in form. However, it is more flexible for solving certain types of problems. Here is SynchronizedEvenGenerator.java rewritten to use explicit Locks:</p>
<p>//: concurrency/MutexEvenGenerator.java // Preventing thread collisions with mutexes.</p>
<p>// {RunByHand}</p>
<p>import java.util.concurrent.locks.*;</p>
<p>public class MutexEvenGenerator extends IntGenerator { private int currentEvenValue = 0; private Lock lock = new ReentrantLock(); public int next() { lock.lock(); try {</p>
<p>++currentEvenValue;</p>
<p>Thread.yield(); // Cause failure faster</p>
<p>++currentEvenValue;</p>
<p>return currentEvenValue;</p>
<p>} finally { lock.unlock();</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>EvenChecker.test(new MutexEvenGenerator());</p>
<p>}</p>
<p>} ///:~</p>
<p>MutexEvenGenerator adds a mutex called lock and uses the lock( ) and unlock( )</p>
<p>methods to create a critical section within next( ). When you are using Lock objects, it is important to internalize the idiom shown here: Right after the call to lock( ), you must place a try-finally statement with unlock( ) in the finally clause—this is the only way to guarantee that the lock is always released. Note that the return statement must occur inside the try clause to ensure that the unlock( ) doesn’t happen too early and expose the data to a second task.</p>
<p>Although the try-finally requires more code than using the synchronized keyword, it also represents one of the advantages of explicit Lock objects. If something fails using the synchronized keyword, an exception is thrown, but you don’t get the chance to do any cleanup in order to maintain your system in a good state. With explicit Lock objects, you can maintain proper state in your system using the finally clause.</p>
<p>In general, when you are using synchronized, there is less code to write, and the opportunity for user error is greatly reduced, so you’ll usually only use the explicit Lock objects when you’re solving special problems. For example, with the synchronized keyword, you can’t try and fail to acquire a lock, or try to acquire a lock for a certain amount of time and then give up—to do this, you must use the concurrent library:</p>
<p>//: concurrency/AttemptLocking.java // Locks in the concurrent library allow you // to give up on trying to acquire a lock. import java.util.concurrent.*; import java.util.concurrent.locks.*;</p>
<p>public class AttemptLocking {</p>
<p>private ReentrantLock lock = new ReentrantLock(); public void untimed() {</p>
<p>boolean captured = lock.tryLock(); try {</p>
<p>System.out.println(&quot;tryLock(): &quot; + captured);</p>
<p>} finally { if(captured) lock.unlock();</p>
<p>}</p>
<p>}</p>
<p>public void timed() {</p>
<p>boolean captured = false; try {</p>
<p>captured = lock.tryLock(2, TimeUnit.SECONDS);</p>
<p>} catch(InterruptedException e) { throw new RuntimeException(e);</p>
<p>}</p>
<p>try {</p>
<p>System.out.println(&quot;tryLock(2, TimeUnit.SECONDS): &quot; + captured);</p>
<p>} finally { if(captured) lock.unlock();</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>final AttemptLocking al = new AttemptLocking(); al.untimed(); // True -- lock is available al.timed();    // True -- lock is available // Now create a separate task to grab the lock: new Thread() {</p>
<p>{ setDaemon(true); } public void run() { al.lock.lock();</p>
<p>System.out.println(&quot;acquired&quot;);</p>
<p>}</p>
<p>}.start();</p>
<p>Thread.yield(); // Give the 2nd task a chance al.untimed(); // False -- lock grabbed by task al.timed(); // False -- lock grabbed by task</p>
<p>}</p>
<p>} /* Output: tryLock(): true</p>
<p>tryLock(2, TimeUnit.SECONDS): true acquired</p>
<p>tryLock(): false</p>
<p>tryLock(2, TimeUnit.SECONDS): false</p>
<p>*///:~</p>
<p>A ReentrantLock allows you to try and fail to acquire the lock, so that if someone else already has the lock, you can decide to go off and do something else rather than waiting until it is free, as you can see in the untimed( ) method. In timed( ), an attempt is made to acquire the lock which can fail after 2 seconds (note the use of the Java SE5 TimeUnit class to specify units). In main( ), a separate Thread is created as an anonymous class, and it acquires the lock so that the untimed( ) and timed( ) methods have something to contend with.</p>
<p>The explicit Lock object also gives you finer-grained control over locking and unlocking than does the built-in synchronized lock. This is useful for implementing specialized synchronization structures, such as hand-overhand locking (also called lock coupling), used for traversing the nodes of a linked list—the traversal code must capture the lock of the next node before it releases the current node’s lock.</p>
<subtitle>Atomicity and volatility</subtitle>
<p>An incorrect piece of lore that is often repeated in Java threading discussions is, &quot;Atomic operations do not need to be synchronized.&quot; An atomic operation is one that cannot be interrupted by the thread scheduler; if the operation begins, then it will run to completion before the possibility of a context switch. Relying on atomicity is tricky and dangerous—you should only try to use atomicity instead of synchronization if you are a concurrency expert, or you have help from such an expert. If you think you’re smart enough to play with this kind of fire, take this test:</p>
<p>The Goetz Test<sup>11</sup>: If you can write a high-performance JVM for a modern microprocessor, then you are qualified to think about whether you can avoid synchronizing.<a l:href="#bookmark117" type="note"><sup>118</sup></a><sup> <a l:href="#bookmark118" type="note"><sup>119</sup></a></sup></p>
<p>It’s useful to know about atomicity, and to know that, along with other advanced techniques, it was used to implement some of the more clever java.util.concurrent library components. But strongly resist the urge to rely on it yourself; see Brian’s Rule of Synchronization, presented earlier.</p>
<p>Atomicity applies to &quot;simple operations&quot; on primitive types except for longs and doubles. Reading and writing primitive variables other than long and double is guaranteed to go to and from memory as indivisible (atomic) operations. However, the JVM is allowed to perform reads and writes of 64- bit quantities (long and double variables) as two separate 32-bit operations, raising the possibility that a context switch could happen in the middle of a read or write, and then different tasks could see incorrect results (this is sometimes called word tearing, because you might see the value after only part of it has been changed). However, you do get atomicity (for simple assignments and returns) if you use the volatile keyword when defining a long or double variable (note that volatile was not working properly before Java SE5). Different JVMs are free to provide stronger guarantees, but you should not rely on platform-specific features.</p>
<p>Atomic operations are thus not interruptible by the threading mechanism. Expert programmers can take advantage of this to write lock-free code, which does not need to be synchronized. But even this is an oversimplification. Sometimes, even when it seems like an atomic operation should be safe, it may not be. Readers of this book will typically not be able to pass the aforementioned Goetz Test, and will thus not be qualified to try to replace synchronization with atomic operations. Trying to remove synchronization is usually a sign of premature optimization, and will cause you a lot of trouble, probably without gaining much, or anything.</p>
<p>On multiprocessor systems (which are now appearing in the form of multicore processors— multiple CPUs on a single chip), visibility rather than atomicity is much more of an issue than on single-processor systems. Changes made by one task, even if they’re atomic in the sense of not being interruptible, might not be visible to other tasks (the changes might be temporarily stored in a local processor cache, for example), so different tasks will have a different view of the application’s state. The synchronization mechanism, on the other hand, forces changes by one task on a multiprocessor system to be visible across the application. Without synchronization, it’s indeterminate when changes become visible.</p>
<p>The volatile keyword also ensures visibility across the application. If you declare a field to be volatile, this means that as soon as a write occurs for that field, all reads will see the change. This is true even if local caches are involved—volatile fields are immediately written through to main memory, and reads occur from main memory.</p>
<p>It’s important to understand that atomicity and volatility are distinct concepts. An atomic operation on a non-volatile field will not necessarily be flushed to main memory, and so another task that reads that field will not necessarily see the new value. If multiple tasks are accessing a field, that field should be volatile; otherwise, the field should only be accessed via synchronization. Synchronization also causes flushing to main memory, so if a field is completely guarded by synchronized methods or blocks, it is not necessary to make it volatile.</p>
<p>Any writes that a task makes will be visible to that task, so you don’t need to make a field volatile if it is only seen within a task.</p>
<p>volatile doesn’t work when the value of a field depends on its previous value (such as incrementing a counter), nor does it work on fields whose values are constrained by the values of other fields, such as the lower and upper bound of a Range class which must obey the constraint lower &lt;= upper.</p>
<p>It’s typically only safe to use volatile instead of synchronized if the class has only one mutable field. Again, your first choice should be to use the synchronized keyword—that’s the safest approach, and trying to do anything else is risky.</p>
<p>What qualifies as an atomic operation? Assignment and returning the value in a field will usually be atomic. However, in C++ even the following might be atomic:</p>
<p>i++;    // Might be atomic in C++</p>
<p>i +=2; // Might be atomic in C++</p>
<p>But in C++, this depends on the compiler and processor. You’re unable to write crossplatform code in C++ that relies on atomicity, because C++ doesn’t have a consistent memory model, as Java does (in Java SEs).<a l:href="#bookmark119" type="note"><sup>120</sup></a><sup></sup></p>
<p>In Java, the above operations are definitely not atomic, as you can see from the JVM instructions produced by the following methods:</p>
<p>//: concurrency/Atomicity.java // {Exec: javap -c Atomicity}</p>
<table>
<tr><th colspan="4">public class Atomicity { int i;</th></tr>
<tr><td>void f1()</td><td>{ i++; }</td><td></td><td></td></tr>
<tr><td>void f2()</td><td>{ i += 3; }</td><td></td><td></td></tr>
<tr><td>} /* Output</td><td>(Sample)</td><td></td><td></td></tr>
<tr><td>void f1();</td><td></td><td></td><td></td></tr>
<tr><td>Code:</td><td></td><td></td><td></td></tr>
<tr><td>0:</td><td>aload_0</td><td></td><td></td></tr>
<tr><td>1:</td><td>dup</td><td></td><td></td></tr>
<tr><td>2:</td><td>getfield</td><td>#2;</td><td>//Field i:I</td></tr>
<tr><td>5:</td><td>iconst_1</td><td></td><td></td></tr>
<tr><td>6:</td><td>iadd</td><td></td><td></td></tr>
<tr><td>7:</td><td>putfield</td><td>#2;</td><td>//Field i:I</td></tr>
<tr><td>10:</td><td>return</td><td></td><td></td></tr>
<tr><td>&lt;OQ_—h KJ</td><td></td><td></td><td></td></tr>
<tr><td>Code:</td><td></td><td></td><td></td></tr>
<tr><td>0:</td><td>aload_0</td><td></td><td></td></tr>
<tr><td>1:</td><td>dup</td><td></td><td></td></tr>
<tr><td>2:</td><td>getfield</td><td>#2;</td><td>//Field i:I</td></tr>
<tr><td>5:</td><td>iconst_3</td><td></td><td></td></tr>
<tr><td>6:</td><td>iadd</td><td></td><td></td></tr>
<tr><td>7:</td><td>putfield</td><td>#2;</td><td>//Field i:I</td></tr>
<tr><td>10:</td><td>return</td><td></td><td></td></tr>
<tr><td>*///:~</td><td></td><td></td><td></td></tr>
</table>
<p>Each instruction produces a &quot;get&quot; and a &quot;put,&quot; with instructions in between. So in between getting and putting, another task could modify the field, and thus the operations are not atomic.</p>
<p>If you blindly apply the idea of atomicity, you see that getValue( ) in the following program fits the description:</p>
<p>//: concurrency/AtomicityTest.java import java.util.concurrent.*;</p>
<p>public class AtomicityTest implements Runnable { private int i = 0; public int getValue() { return i; }</p>
<p>private synchronized void evenIncrement() { i++; i++; } public void run() { while(true)</p>
<p>evenIncrement();</p>
<p>} public static void main(String[] args) {</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); AtomicityTest at = new AtomicityTest(); exec.execute(at); while(true) {</p>
<p>int val = at.getValue(); if(val % 2 != 0) {</p>
<p>System.out.println(val);</p>
<p>System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>191583767</p>
<p>*///:~</p>
<p>However, the program will find non-even values and terminate. Although return i is indeed an atomic operation, the lack of synchronization allows the value to be read while the object is in an unstable intermediate state. On top of this, since i is also not volatile, there will be visibility problems. Both getValue( ) and evenIncrement( ) must be synchronized. Only concurrency experts are qualified to attempt optimizations in situations like this; again, you should apply Brian’s Rule of Synchronization.</p>
<p>As a second example, consider something even simpler: a class that produces serial numbers.<a l:href="#bookmark120" type="note"><sup>121</sup></a><sup></sup> Each time nextSerialNumber( ) is called, it must return a unique value to the caller:</p>
<p>//: concurrency/SerialNumberGenerator.java</p>
<p>public class SerialNumberGenerator {</p>
<p>private static volatile int serialNumber = 0; public static int nextSerialNumber() {</p>
<p>return serialNumber++; // Not thread-safe</p>
<p>}</p>
<p>} ///:~</p>
<p>SerialNumberGenerator is about as simple a class as you can imagine, and if you’re coming from C++ or some other low-level background, you might expect the increment to be an atomic operation, because a C++ increment can often be implemented as a microprocessor instruction (although not in any reliable, cross-platform fashion). As noted before, however, a Java increment is not atomic and involves both a read and a write, so there’s room for threading problems even in such a simple operation. As you shall see, volatility isn’t actually the issue here; the real problem is that nextSerialNumber( ) accesses a shared, mutable value without synchronizing.</p>
<p>The serialNumber field is volatile because it is possible for each thread to have a local stack and maintain copies of some variables there. If you define a variable as volatile, it tells the compiler not to do any optimizations that would remove reads and writes that keep the field in exact synchronization with the local data in the threads. In effect, reads and writes go directly to memory, and are not cached, volatile also restricts compiler reordering of accesses during optimization. However, volatile doesn’t affect the fact that an increment isn’t an atomic operation.</p>
<p>Basically, you should make a field volatile if that field could be simultaneously accessed by multiple tasks, and at least one of those accesses is a write. For example, a field that is used as a flag to stop a task must be declared volatile; otherwise, that flag could be cached in a</p>
<p>register, and when you make changes to the flag from outside the task, the cached value wouldn’t be changed and the task wouldn’t know it should stop.</p>
<p>To test SerialNumberGenerator, we need a set that doesn’t run out of memory, in case it takes a long time to detect a problem. The CircularSet shown here reuses the memory used to store ints, with the assumption that by the time you wrap around, the possibility of a collision with the overwritten values is minimal. The add( ) and contains( ) methods are synchronized to prevent thread collisions:</p>
<p>//: concurrency/SerialNumberChecker.java // Operations that may seem safe are not,</p>
<p>// when threads are present.</p>
<p>// {Args: 4}</p>
<p>import java.util.concurrent.*;</p>
<p>// Reuses storage so we don’t run out of memory: class CircularSet { private int[] array; private int len; private int index = 0; public CircularSet(int size) { array = new int[size]; len = size;</p>
<p>// Initialize to a value not produced // by the SerialNumberGenerator: for(int i = 0; i &lt; size; i++) array[i] = -1;</p>
<p>}</p>
<p>public synchronized void add(int i) { array[index] = i;</p>
<p>// Wrap index and write over old elements: index = ++index % len;</p>
<p>}</p>
<p>public synchronized boolean contains(int val) { for(int i = 0; i &lt; len; i++)</p>
<p>if(array[i] == val) return true; return false;</p>
<p>}</p>
<p>}</p>
<p>public class SerialNumberChecker { private static final int SIZE = 10; private static CircularSet serials = new CircularSet(1000); private static ExecutorService exec =</p>
<p>Executors.newCachedThreadPool(); static class SerialChecker implements Runnable { public void run() { while(true) { int serial =</p>
<p>SerialNumberGenerator.nextSerialNumber(); if(serials.contains(serial)) {</p>
<p>System.out.println(&quot;Duplicate: &quot; + serial);</p>
<p>System.exit(0);</p>
<p>}</p>
<p>serials.add(serial);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { for(int i = 0; i &lt; SIZE; i++)</p>
<p>exec.execute(new SerialChecker());</p>
<p>// Stop after n seconds if there’s an argument: if(args.length &gt; 0) {</p>
<p>TimeUnit.SECONDS.sleep(new Integer(args[0])); System.out.println(&quot;No duplicates detected&quot;); System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Duplicate: 8468656 *///:~</p>
<p>SerialNumberChecker contains a static CircularSet that holds all the serial numbers that have been produced, and a nested SerialChecker class that ensures the serial numbers are unique. By creating multiple tasks to contend over serial numbers, you’ll discover that the tasks eventually get a duplicate serial number, if you let it run long enough. To solve the problem, add the synchronized keyword to nextSerialNumber( ).</p>
<p>The atomic operations that are supposed to be safe are the reading and assignment of primitives. However, as seen in AtomicityTest.java, it’s still easily possible to use an atomic operation that accesses your object while it’s in an unstable intermediate state. Making assumptions about this issue is tricky and dangerous. The most sensible thing to do is just to follow Brian’s Rule of Synchronization.</p>
<p>Exercise 12: (3) Repair AtomicityTest.java using the synchronized keyword. Can you demonstrate that it is now correct?</p>
<p>Exercise 13: (1) Repair SerialNumberChecker.java using the synchronized</p>
<p>keyword. Can you demonstrate that it is now correct?</p>
<subtitle>Atomic classes</subtitle>
<p>Java SE5 introduces special atomic variable classes such as Atomiclnteger, AtomicLong, AtomicReference, etc. that provide an atomic conditional update operation of the form:</p>
<p>boolean compareAndSet(expectedValue, updateValue);</p>
<p>These are for fine-tuning to use machine-level atomicity that is available on some modern processors, so you generally don’t need to worry about using them. Occasionally they come in handy for regular coding, but again when performance tuning is involved. For example, we can rewrite AtomicityTest.java to use Atomiclnteger:</p>
<p>//: concurrency/AtomiclntegerTest.java import java.util.concurrent.*; import java.util.concurrent.atomic.*; import java.util.*;</p>
<p>public class AtomicIntegerTest implements Runnable { private Atomiclnteger i = new AtomicInteger(0); public int getValue() { return i.get(); } private void evenIncrement() { i.addAndGet(2); } public void run() { while(true)</p>
<p>evenIncrement();</p>
<p>}</p>
<p>public static void main(String[] args) { new Timer().schedule(new TimerTask() { public void run() {</p>
<p>System.err.println(&quot;Aborting&quot;);</p>
<p>System.exit(0);</p>
<p>}, 5000); // Terminate after 5 seconds ExecutorService exec = Executors.newCachedThreadPool(); AtomicIntegerTest ait = new AtomicIntegerTest(); exec.execute(ait); while(true) {</p>
<p>int val = ait.getValue(); if(val % 2 != 0) {</p>
<p>System.out.println(val);</p>
<p>System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} ///:~</p>
<p>Here we’ve eliminated the synchronized keyword by using AtomicInteger instead. Because the program doesn’t fail, a Timer is added to automatically abort after 5 seconds.</p>
<p>Here is MutexEvenGenerator.java rewritten to use Atomiclnteger:</p>
<p>//: concurrency/AtomicEvenGenerator.java</p>
<p>// Atomic classes are occasionally useful in regular code.</p>
<p>// {RunByHand}</p>
<p>import java.util.concurrent.atomic.*;</p>
<p>public class AtomicEvenGenerator extends IntGenerator { private AtomicInteger currentEvenValue = new AtomicInteger(0); public int next() {</p>
<p>return currentEvenValue.addAndGet(2);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>EvenChecker.test(new AtomicEvenGenerator());</p>
<p>}</p>
<p>} ///:~</p>
<p>Again, all other forms of synchronization have been eliminated by using AtomicInteger.</p>
<p>It should be emphasized that the Atomic classes were designed to build the classes in java.util.concurrent, and that you should use them in your own code only under special circumstances, and even then only when you can ensure that there are no other possible problems. It’s generally safer to rely on locks (either the synchronized keyword or explicit Lock objects).</p>
<p>Exercise 14: (4) Demonstrate that java.util.Timer scales to large numbers by creating a program that generates many Timer objects that perform some simple task when the timeout completes.</p>
<subtitle>Critical sections</subtitle>
<p>Sometimes, you only want to prevent multiple thread access to part of the code inside a method instead of the entire method. The section of code you want to isolate this way is called a critical section and is created using the synchronized keyword. Here, synchronized is used to specify the object whose lock is being used to synchronize the enclosed code:</p>
<p>synchronized(syncObject) {</p>
<p>// This code can be accessed</p>
<p>// by only one task at a time</p>
<p>This is also called a synchronized block; before it can be entered, the lock must be acquired on syncObject. If some other task already has this lock, then the critical section cannot be entered until the lock is released. The following example compares both synchronization approaches by showing how the time available for other tasks to access an object is significantly increased by using a synchronized block instead of synchronizing an entire method. In addition, it shows how an unprotected class can be used in a multithreaded situation if it is controlled and protected by another class:</p>
<p>//: concurrency/CriticalSection.java</p>
<p>// Synchronizing blocks instead of entire methods. Also</p>
<p>// demonstrates protection of a non-thread-safe class</p>
<p>// with a thread-safe one.</p>
<p>package concurrency;</p>
<p>import java.util.concurrent.*;</p>
<p>import java.util.concurrent.atomic.*;</p>
<p>import java.util.*;</p>
<p>class Pair { // Not thread-safe private int x, y; public Pair(int x, int y) { this.x = x; this.y = y;</p>
<p>}</p>
<p>return &quot;x: &quot; + x + &quot;, y:    &quot; + y;</p>
<p>}</p>
<p>public class PairValuesNotEqualException extends RuntimeException {</p>
<p>public PairValuesNotEqualException() {</p>
<p>super(&quot;Pair values not equal: &quot; + Pair.this);</p>
<p>}</p>
<p>}</p>
<p>// Arbitrary invariant -- both variables must be equal: public void checkState() { if(x != y)</p>
<p>throw new PairValuesNotEqualException();</p>
<p>}</p>
<p>}</p>
<p>// Protect a Pair inside a thread-safe class: abstract class PairManager {</p>
<p>AtomicInteger checkCounter = new AtomicInteger(0); protected Pair p = new Pair(); private List&lt;Pair&gt; storage =</p>
<p>Collections.synchronizedList(new ArrayList&lt;Pair&gt;()); public synchronized Pair getPair() {</p>
<p>// Make a copy to keep the original safe: return new Pair(p.getX(), p.getY());</p>
<p>}</p>
<p>// Assume this is a time consuming operation protected void store(Pair p) { storage.add(p); try {</p>
<p>TimeUnit.MILLISECONDS.sleep(50);</p>
<p>} catch(InterruptedException ignore) {}</p>
<p>public abstract void increment();</p>
<p>}</p>
<p>// Synchronize the entire method: class PairManagerl extends PairManager { public synchronized void increment() { p.incrementX(); p.incrementY(); store(getPair());</p>
<p>}</p>
<p>}</p>
<p>// Use a critical section: class PairManager2 extends PairManager { public void increment() {</p>
<p>Pair temp;</p>
<p>synchronized(this) { p.incrementX(); p.incrementY(); temp = getPair();</p>
<p>}</p>
<p>store(temp);</p>
<p>}</p>
<p>}</p>
<p>class PairManipulator implements Runnable { private PairManager pm; public PairManipulator(PairManager pm) { this.pm = pm;</p>
<p>}</p>
<p>public void run() { while(true)</p>
<p>pm.increment();</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;Pair: &quot; + pm.getPair() +</p>
<p>&quot; checkCounter = &quot; + pm.checkCounter.get();</p>
<p>}</p>
<p>}</p>
<p>class PairChecker implements Runnable { private PairManager pm; public PairChecker(PairManager pm) { this.pm = pm;</p>
<p>}</p>
<p>public void run() { while(true) {</p>
<p>pm.checkCounter.incrementAndGet();</p>
<p>pm.getPair().checkState();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class CriticalSection {</p>
<p>// Test the two different approaches: static void</p>
<p>testApproaches(PairManager pmanl, PairManager pman2) { ExecutorService exec = Executors.newCachedThreadPool(); PairManipulator</p>
<p>pml = new PairManipulator(pmanl), pm2 = new PairManipulator(pman2);</p>
<p>PairChecker</p>
<p>pcheckl = new PairChecker(pmanl), pcheck2 = new PairChecker(pman2); exec.execute(pml); exec.execute(pm2); exec.execute(pcheckl); exec.execute(pcheck2); try {</p>
<p>TimeUnit.MILLISECONDS.sleep(500);</p>
<p>} catch(InterruptedException e) {</p>
<p>System.out.println(&quot;Sleep interrupted&quot;);</p>
<p>}</p>
<p>System.out.println(&quot;pm1: &quot; + pml + &quot;\npm2: &quot; + pm2); System.exit(0);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>PairManager</p>
<p>pmanl =    new    PairManagerl(),</p>
<p>pman2 =    new    PairManager2();</p>
<p>testApproaches(pmanl, pman2);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>pml:    Pair: x:    l5,    y: l5 checkCounter    =    272565</p>
<p>pm2:    Pair: x:    l6,    y: l6 checkCounter    =    3956974</p>
<p>*///:~</p>
<p>As noted, Pair is not thread-safe because its invariant (admittedly arbitrary) requires that both variables maintain the same values. In addition, as seen earlier in this chapter, the increment operations are not thread-safe, and because none of the methods are synchronized, you can’t trust a Pair object to stay uncorrupted in a threaded program.</p>
<p>You can imagine that someone hands you the non-thread-safe Pair class, and you need to use it in a threaded environment. You do this by creating the PairManager class, which holds a Pair object and controls all access to it. Note that the only public methods are getPair( ), which is synchronized, and the abstract increment( ). Synchronization for increment( ) will be handled when it is implemented.</p>
<p>The structure of PairManager, where functionality implemented in the base class uses one or more abstract methods defined in derived classes, is called a Template Method in Design Patterns parlance.<a l:href="#bookmark121" type="note"><sup>122</sup></a><sup></sup> Design patterns allow you to encapsulate change in your code; here, the part that is changing is the method increment( ). In PairManager1 the entire increment( ) method is synchronized, but in PairManager2 only part of increment( ) is synchronized by using a synchronized block. Note that the synchronized keyword is not part of the method signature and thus may be added during overriding.</p>
<p>The store( ) method adds a Pair object to a synchronized ArrayList, so this operation is thread safe. Thus, it doesn’t need to be guarded, and is placed outside of the synchronized block in PairManager2.</p>
<p>PairManipulator is created to test the two different types of PairManagers by calling increment( ) in a task while a PairChecker is run from another task. To trace how often it is able to run the test, PairChecker increments checkCounter every time it is successful. In main( ), two PairManipulator objects are created and allowed to run for a while, after which the results of each PairManipulator are shown.</p>
<p>Although you will probably see a lot of variation in output from one run to the next, in general you will see that PairManager1.increment( ) does not allow the PairChecker nearly as much access as PairManager2.increment( ), which has the synchronized</p>
<p>block and thus provides more unlocked time. This is typically the reason to use a synchronized block instead of synchronizing the whole method: to allow other tasks more access (as long as it is safe to do so).</p>
<p>You can also use explicit Lock objects to create critical sections:</p>
<p>//: concurrency/ExplicitCriticalSection.java</p>
<p>// Using explicit Lock objects to create critical sections.</p>
<p>package concurrency;</p>
<p>import java.util.concurrent.locks.*;</p>
<p>// Synchronize the entire method: class ExplicitPairManager1 extends PairManager { private Lock lock = new ReentrantLock(); public synchronized void increment() { lock.lock(); try {</p>
<p>p.incrementX();</p>
<p>p.incrementY();</p>
<p>store(getPair());</p>
<p>} finally {</p>
<p>lock.unlock();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Use a critical section:</p>
<p>class ExplicitPairManager2 extends PairManager { private Lock lock = new ReentrantLock(); public void increment() {</p>
<p>Pair temp; lock.lock(); try {</p>
<p>p.incrementX(); p.incrementY(); temp = getPair();</p>
<p>} finally { lock.unlock();</p>
<p>}</p>
<p>store(temp);</p>
<p>}</p>
<p>}</p>
<p>public class ExplicitCriticalSection {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>PairManager</p>
<p>pman1 = new ExplicitPairManager1(), pman2 = new ExplicitPairManager2(); CriticalSection.testApproaches(pman1, pman2);</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>pm1: Pair: x: 15, y: 15 checkCounter = 174035 pm2: Pair: x: 16, y: 16 checkCounter = 2608588 *///:~</p>
<p>This reuses most of CriticalSection.java and creates new PairManager types that use explicit Lock objects. ExplicitPairManager2 shows the creation of a critical section using a Lock object; the call to store( ) is outside of the critical section.</p>
<subtitle>Synchronizing on other objects</subtitle>
<p>A synchronized block must be given an object to synchronize upon, and usually the most sensible object to use is just the current object that the method is being called for: synchronized(this), which is the approach taken in PairManager2. That way, when the lock is acquired for the synchronized block, other synchronized methods and critical sections in the object cannot be called. So the effect of the critical section, when synchronizing on this, is simply to reduce the scope of synchronization.</p>
<p>Sometimes you must synchronize on another object, but if you do this you must ensure that all relevant tasks are synchronizing on the same object. The following example demonstrates that two tasks can enter an object when the methods in that object synchronize on different locks:</p>
<p>//: concurrency/SyncObject.java // Synchronizing on another object. import static net.mindview.util.Print.*;</p>
<p>class DualSynch {</p>
<p>private Object syncObject = new Object(); public synchronized void f() { for(int i = 0; i &lt; 5; i++) { print(&quot;fQ&quot;);</p>
<p>Thread.yield();</p>
<p>}</p>
<p>}</p>
<p>public void g() {</p>
<p>synchronized(syncObject) { for(int i = 0; i &lt; 5; i++) { print(&quot;gO&quot;);</p>
<p>Thread.yield();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class SyncObject {</p>
<p>public static void main(String[] args) { final DualSynch ds = new DualSynch(); new Thread() {</p>
<p>public void run() { ds.f();</p>
<p>}</p>
<p>}.start();</p>
<p>ds.g();</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>g()</p>
<p>f()</p>
<p>g()</p>
<p>f()</p>
<p>g()</p>
<p>f()</p>
<p>g()</p>
<p>f()</p>
<p>g()</p>
<p>f()</p>
<p>*///:~</p>
<p>DualSync.f( ) synchronizes on this (by synchronizing the entire method), and g( ) has a synchronized block that synchronizes on syncObject. Thus, the two synchronizations are independent. This is demonstrated in main( ) by creating a Thread that calls f( ). The main( ) thread is used to call g( ). You can see from the output that both methods are running at the same time, so neither one is blocked by the synchronization of the other.</p>
<p>Exercise 15: (1) Create a class with three methods containing critical sections that all synchronize on the same object. Create multiple tasks to demonstrate that only one of these methods can run at a time. Now modify the methods so that each one synchronizes on a different object and show that all three methods can be running at once.</p>
<p>Exercise 16: (1) Modify Exercise 15 to use explicit Lock objects.</p>
<subtitle>Thread local storage</subtitle>
<p>A second way to prevent tasks from colliding over shared resources is to eliminate the sharing of variables. Thread local storage is a mechanism that automatically creates different storage for the same variable, for each different thread that uses an object. Thus, if you have five threads using an object with a variable x, thread local storage generates five different pieces of storage for x. Basically, they allow you to associate state with a thread.</p>
<p>The creation and management of thread local storage is taken care of by the java.lang.ThreadLocal class, as seen here:</p>
<p>//: concurrency/ThreadLocalVariableHolder.java // Automatically giving each thread its own storage. import java.util.concurrent.*; import java.util.*;</p>
<p>class Accessor implements Runnable { private final int id; public Accessor(int idn) { id = idn; } public void run() {</p>
<p>while(!Thread.currentThread().isInterrupted()) { ThreadLocalVariableHolder.increment();</p>
<p>System.out.println(this);</p>
<p>Thread.yield();</p>
<p>}</p>
<p>}</p>
<p>public String toString() { return &quot;#&quot; + id + &quot;: &quot; +</p>
<p>ThreadLocalVariableHolder.get();</p>
<p>}</p>
<p>}</p>
<p>public class ThreadLocalVariableHolder {</p>
<p>private static ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;() {</p>
<p>private Random rand = new Random(47); protected synchronized Integer initialValue() { return rand.nextInt(10000);</p>
<p>}</p>
<p>};</p>
<p>public static void increment() { value.set(value.get() + 1);</p>
<p>}</p>
<p>public static int get() { return value.get(); } public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; 5; i++)</p>
<p>exec.execute(new Accessor(i));</p>
<p>TimeUnit.SECONDS.sleep(3); // Run for a while exec.shutdownNow();    // All Accessors will quit</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>#0: 9259</p>
<table>
<tr><td>#1</td><td>556</td></tr>
<tr><td>#2</td><td>6694</td></tr>
<tr><td>#3</td><td>1862</td></tr>
<tr><td>#4</td><td>962</td></tr>
<tr><td>#0</td><td>9260</td></tr>
<tr><td>#1</td><td>557</td></tr>
<tr><td>#2</td><td>6695</td></tr>
<tr><td>#3</td><td>1863</td></tr>
<tr><td>#4</td><td>963</td></tr>
<tr><td colspan="2">*///:~</td></tr>
</table>
<p>ThreadLocal objects are usually stored as static fields. When you create a ThreadLocal object, you are only able to access the contents of the object using the get( ) and set( ) methods. The get( ) method returns a copy of the object that is associated with that thread, and set( ) inserts its argument into the object stored for that thread, returning the old object that was in storage. The increment( ) and get( ) methods demonstrate this in ThreadLocalVariableHolder. Notice that increment( ) and get( ) are not synchronized, because ThreadLocal guarantees that no race condition can occur.</p>
<p>When you run this program, you’ll see evidence that the individual threads are each allocated their own storage, since each one keeps its own count even though there’s only one ThreadLocalVariableHolder object.</p>
</section>
<section>
<title>
<p>Terminating tasks</p></title><empty-line/>
<p>In some of the previous examples, cancel( ) and isCanceled( ) methods are placed in a class that is seen by all tasks. The tasks check isCanceled( ) to determine when to terminate themselves. This is a reasonable approach to the problem. However, in some situations the task must be terminated more abruptly. In this section, you’ll learn about the issues and problems of such termination.</p>
<p>First, let’s look at an example that not only demonstrates the termination problem but also is an additional example of resource sharing.</p>
<subtitle>The ornamental garden</subtitle>
<p>In this simulation, the garden committee would like to know how many people enter the garden each day through its multiple gates. Each gate has a turnstile or some other kind of counter, and after the turnstile count is incremented, a shared count is incremented that represents the total number of people in the garden.</p>
<p>//: concurrency/OrnamentalGarden.java import java.util.concurrent.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Count {</p>
<p>private int count = 0;</p>
<p>private Random rand = new Random(47);</p>
<p>// Remove the synchronized keyword to see counting fail: public synchronized int increment() { int temp = count;</p>
<p>if(rand.nextBoolean()) // Yield half the time Thread.yield(); return (count = ++temp);</p>
<p>}</p>
<p>public synchronized int value() { return count; }</p>
<p>class Entrance implements Runnable {</p>
<p>private static Count count = new Count(); private static List&lt;Entrance&gt; entrances = new ArrayList&lt;Entrance&gt;(); private int number = 0;</p>
<p>// Doesn’t need synchronization to read: private final int id;</p>
<p>private static volatile boolean canceled = false;</p>
<p>// Atomic operation on a volatile field: public static void cancel() { canceled = true; } public Entrance(int id) { this.id = id;</p>
<p>// Keep this task in a list. Also prevents // garbage collection of dead tasks: entrances.add(this);</p>
<p>}</p>
<p>public void run() { while(!canceled) { synchronized(this) {</p>
<p>++number;</p>
<p>}</p>
<p>print(this + &quot; Total: &quot; + count.increment()); try {</p>
<p>TimeUnit.MILLISECONDS.sleep(100);</p>
<p>} catch(InterruptedException e) { print(&quot;sleep interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>print(&quot;Stopping &quot; + this);</p>
<p>}</p>
<p>public synchronized int getValue() { return number; } public String toString() {</p>
<p>return &quot;Entrance &quot; + id + &quot;: &quot; + getValue();</p>
<p>}</p>
<p>public static int getTotalCount() { return count.value();</p>
<p>}</p>
<p>public static int sumEntrances() { int sum = 0;</p>
<p>for(Entrance entrance : entrances) sum += entrance.getValue(); return sum;</p>
<p>}</p>
<p>}</p>
<p>public class OrnamentalGarden {</p>
<p>public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; 5; i++)</p>
<p>exec.execute(new Entrance(i));</p>
<p>// Run for a while, then stop and collect the data: TimeUnit.SECONDS.sleep(3);</p>
<p>Entrance.cancel();</p>
<p>exec.shutdown();</p>
<p>if(!exec.awaitTermination(250, TimeUnit.MILLISECONDS)) print(&quot;Some tasks were not terminated!&quot;); print(&quot;Total: &quot; + Entrance.getTotalCount()); print(&quot;Sum of Entrances: &quot; + Entrance.sumEntrances());</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<table>
<tr><td>Entrance</td><td>0:</td><td>1</td><td>Total:</td><td>1</td></tr>
<tr><td>Entrance</td><td>2</td><td>1</td><td>Total:</td><td>3</td></tr>
<tr><td>Entrance</td><td>1:</td><td>1</td><td>Total:</td><td>2</td></tr>
<tr><td>Entrance</td><td>4</td><td>1</td><td>Total:</td><td>5</td></tr>
<tr><td>Entrance</td><td>3</td><td>1</td><td>Total:</td><td>4</td></tr>
<tr><td>Entrance</td><td>2:</td><td>2</td><td>Total:</td><td>6</td></tr>
<tr><td>Entrance</td><td>4:</td><td>2</td><td>Total:</td><td>7</td></tr>
<tr><td>Entrance</td><td>0:</td><td>2</td><td>Total:</td><td>8</td></tr>
<tr><td>Entrance</td><td>3:</td><td>29</td><td>Total</td><td>143</td></tr>
<tr><td>Entrance</td><td>0:</td><td>29</td><td>Total</td><td>144</td></tr>
<tr><td>Entrance</td><td>4:</td><td>29</td><td>Total</td><td>145</td></tr>
<tr><td>Entrance</td><td>2:</td><td>30</td><td>Total</td><td>147</td></tr>
<tr><td>Entrance</td><td>1:</td><td>30</td><td>Total</td><td>146</td></tr>
<tr><td>Entrance</td><td>0:</td><td>30</td><td>Total</td><td>149</td></tr>
<tr><td>Entrance</td><td>3:</td><td>30</td><td>Total</td><td>148</td></tr>
<tr><td>Entrance</td><td>4:</td><td>30</td><td>Total</td><td>150</td></tr>
</table>
<table>
<tr><td>Stopping</td><td>Entrance</td><td>2:</td><td>30</td></tr>
<tr><td>Stopping</td><td>Entrance</td><td>1:</td><td>30</td></tr>
<tr><td>Stopping</td><td>Entrance</td><td>0:</td><td>30</td></tr>
<tr><td>Stopping</td><td>Entrance</td><td>3:</td><td>30</td></tr>
<tr><td>Stopping</td><td>Entrance</td><td>4:</td><td>30</td></tr>
<tr><td colspan="4">Total: 150Sum of Entrances: 150 *///:~</td></tr>
</table>
<p>A single Count object keeps the master count of garden visitors, and is stored as a static field in the Entrance class. Count.increment( ) and Count.value( ) are synchronized</p>
<p>to control access to the count field. The increment( ) method uses a Random object to cause a yield( ) roughly half the time, in between fetching count into temp and incrementing and storing temp back into count. If you comment out the synchronized keyword on increment( ), the program breaks because multiple tasks will be accessing and modifying count simultaneously (the yield( ) causes the problem to happen more quickly).</p>
<p>Each Entrance task keeps a local value number containing the number of visitors that have passed through that particular entrance. This provides a double check against the count object to make sure that the proper number of visitors is being recorded. Entrance.run( ) simply increments number and the count object and sleeps for 100 milliseconds.</p>
<p>Because Entrance.canceled is a volatile boolean flag which is only read and assigned (and is never read in combination with other fields), it’s possible to get away without synchronizing access to it. If you have any doubts about something like this, it’s always better to use synchronized.</p>
<p>This program goes to quite a bit of extra trouble to shut everything down in a stable fashion. Part of the reason for this is to show just how careful you must be when terminating a multithreaded program, and part of the reason is to demonstrate the value of interrupt( ), which you will learn about shortly.</p>
<p>After 3 seconds, main( ) sends the static cancel( ) message to Entrance, then calls shutdown( ) for the exec object, and then calls awaitTermination( ) on exec. ExecutorService.awaitTermination( ) waits for each task to complete, and if they all complete before the timeout value, it returns true, otherwise it returns false to indicate that not all tasks have completed. Although this causes each task to exit its run( ) method and therefore terminate as a task, the Entrance objects are still valid because, in the constructor, each Entrance object is stored in a static List&lt;Entrance&gt; called entrances. Thus, sumEntrances( ) is still working with valid Entrance objects.</p>
<p>As this program runs, you will see the total count and the count at each entrance displayed as people walk through a turnstile. If you remove the synchronized declaration on Count.increment( ), you’ll notice that the total number of people is not what you expect it to be. The number of people counted by each turnstile will be different from the value in count. As long as the mutex is there to synchronize access to the Count, things work correctly. Keep in mind that Count.increment( ) exaggerates the potential for failure by using temp and yield( ). In real threading problems, the possibility for failure may be statistically small, so you can easily fall into the trap of believing that things are working correctly. Just as in the example above, there are likely to be hidden problems that haven’t occurred to you, so be exceptionally diligent when reviewing concurrent code.</p>
<p>Exercise 17: (2) Create a radiation counter that can have any number of remote sensors.</p>
<subtitle>Terminating when blocked</subtitle>
<p>Entrance.run( ) in the previous example includes a call to sleep( ) in its loop. We know that sleep( ) will eventually wake up and the task will reach the top of the loop, where it has an opportunity to break out of that loop by checking the cancelled flag. However, sleep( ) is just one situation where a task is blocked from executing, and sometimes you must terminate a task that’s blocked.</p>
<p>Thread states</p>
<p>A thread can be in any one of four states:</p>
<p>1.    New: A thread remains in this state only momentarily, as it is being created. It allocates any necessary system resources and performs initialization. At this point it becomes eligible to receive CPU time. The scheduler will then transition this thread to the runnable or blocked state.</p>
<p>2.    Runnable: This means that a thread can be run when the time-slicing mechanism has CPU cycles available for the thread. Thus, the thread might or might not be running at any moment, but there’s nothing to prevent it from being run if the scheduler can arrange it. That is, it’s not dead or blocked.</p>
<p>3.    Blocked: The thread can be run, but something prevents it. While a thread is in the blocked state, the scheduler will simply skip it and not give it any CPU time. Until a thread reenters the runnable state, it won’t perform any operations.</p>
<p>4.    Dead: A thread in the dead or terminated state is no longer schedulable and will not receive any CPU time. Its task is completed, and it is no longer runnable. One way for a task to die is by returning from its run( ) method, but a task’s thread can also be interrupted, as you’ll see shortly.</p>
<p>Becoming blocked</p>
<p>A task can become blocked for the following reasons:</p>
<p>•    You’ve put the task to sleep by calling sleep(milliseconds), in which case it will not be run for the specified time.</p>
<p>•    You’ve suspended the execution of the thread with wait( ). It will not become runnable again until the thread gets the notify( ) or notifyAll( ) message (or the equivalent signal( ) or signalAll( ) for the Java SE5 java.util.concurrent library tools). We’ll examine these in a later section.</p>
<p>•    The task is waiting for some I/O to complete.</p>
<p>•    The task is trying to call a synchronized method on another object, and that object’s lock is not available because it has already been acquired by another task.</p>
<p>In old code, you may also see suspend( ) and resume( ) used to block and unblock threads, but these are deprecated in modern Java (because they are deadlock-prone), and so will not be examined in this book. The stop( ) method is also deprecated, because it doesn’t release the locks that the thread has acquired, and if the objects are in an inconsistent state (&quot;damaged&quot;), other tasks can view and modify them in that state. The resulting problems can be subtle and difficult to detect.</p>
<p>The problem we need to look at now is this: Sometimes you want to terminate a task that is in a blocked state. If you can’t wait for it to get to a point in the code where it can check a state value and decide to terminate on its own, you have to force the task out of its blocked state.</p>
<subtitle>Interruption</subtitle>
<p>As you might imagine, it’s much messier to break out of the middle of a Runnable.run( ) method than it is to wait for that method to get to a test of a &quot;cancel&quot; flag, or to some other place where the programmer is ready to leave the method. When you break out of a blocked task, you might need to clean up resources. Because of this, breaking out of the middle of a task’s run( ) is more like throwing an exception than anything else, so in Java threads, exceptions are used for this kind of abort.<a l:href="#bookmark122" type="note"><sup>123</sup></a><sup></sup> (This walks the fine edge of being an inappropriate use of exceptions, because it means you are often using them for control flow.) To return to a known good state when terminating a task this way, you must carefully consider the execution paths of your code and write your catch clause to properly clean everything up.</p>
<p>So that you can terminate a blocked task, the Thread class contains the interrupt( ) method. This sets the interrupted status for that thread. A thread with its interrupted status set will throw an InterruptedException if it is already blocked or if it attempts a blocking operation. The interrupted status will be reset when the exception is thrown or if the task calls Thread.interrupted( ). As you’ll see, Thread.interrupted( ) provides a second way to leave your run( ) loop, without throwing an exception.</p>
<p>To call interrupt( ), you must hold a Thread object. You may have noticed that the new concurrent library seems to avoid the direct manipulation of Thread objects and instead tries to do everything through Executors. If you call shutdownNow( ) on an Executor, it will send an interrupt( ) call to each of the threads it has started. This makes sense because you’ll usually want to shut down all the tasks for a particular Executor at once, when you’ve finished part of a project or a whole program. However, there are times when you may want to only interrupt a single task. If you’re using Executors, you can hold on to the context of a task when you start it by calling submit( ) instead of execute( ). submit( ) returns a generic Future&lt;?&gt;, with an unspecified parameter because you won’t ever call get( ) on it— the point of holding this kind of Future is that you can call cancel( ) on it and thus use it to interrupt a particular task. If you pass true to cancel( ), it has permission to call interrupt( ) on that thread in order to stop it; thus cancel( ) is a way to interrupt individual threads started with an Executor.</p>
<p>Here’s an example that shows the basics of interrupt( ) using Executors:</p>
<p>//: concurrency/Interrupting.java</p>
<p>// Interrupting a blocked thread. import java.util.concurrent.*; import java.io.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class SleepBlocked implements Runnable { public void run() { try {</p>
<p>TimeUnit.SECONDS.sleep(100);</p>
<p>} catch(InterruptedException e) { print(&quot;InterruptedException&quot;);</p>
<p>}</p>
<p>print(&quot;Exiting SleepBlocked.run()&quot;);</p>
<p>}</p>
<p>}</p>
<p>class IOBlocked implements Runnable { private InputStream in;</p>
<p>public IOBlocked(InputStream is) { in = is; } public void run() { try {</p>
<p>print(&quot;Waiting for read():&quot;); in.read();</p>
<p>} catch(IOException e) {</p>
<p>if(Thread.currentThread().isInterrupted()) { print(&quot;Interrupted from blocked I/O&quot;);</p>
<p>} else {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>print(&quot;Exiting IOBlocked.run()&quot;);</p>
<p>}</p>
<p>}</p>
<p>class SynchronizedBlocked implements Runnable { public synchronized void f() {</p>
<p>while(true) // Never releases lock Thread.yield();</p>
<p>}</p>
<p>public SynchronizedBlocked() { new Thread() {</p>
<p>public void run() {</p>
<p>f(); // Lock acquired by this thread</p>
<p>}</p>
<p>}.start();</p>
<p>}</p>
<p>public void run() {</p>
<p>print(&quot;Trying to call f()&quot;); f();</p>
<p>print(&quot;Exiting SynchronizedBlocked.run()&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class Interrupting {</p>
<p>private static ExecutorService exec = Executors.newCachedThreadPool(); static void test(Runnable r) throws InterruptedException{ Future&lt;?&gt; f = exec.submit(r); TimeUnit.MILLISECONDS.sleep(100); print(&quot;Interrupting &quot; + r.getClass().getName()); f.cancel(true); // Interrupts if running print(&quot;Interrupt sent to &quot; + r.getClass().getName());</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { test(new SleepBlocked()); test(new IOBlocked(System.in)); test(new SynchronizedBlocked()); TimeUnit.SECONDS.sleep(3); print(&quot;Aborting with System.exit(0)&quot;);</p>
<p>System.exit(0); // ... since last 2 interrupts failed</p>
<p>}</p>
<p>} /* Output: (95% match)</p>
<p>Interrupting SleepBlocked InterruptedException Exiting SleepBlocked.run()</p>
<p>Interrupt sent to SleepBlocked Waiting for read():</p>
<p>Interrupting IOBlocked Interrupt sent to IOBlocked Trying to call f()</p>
<p>Interrupting SynchronizedBlocked Interrupt sent to SynchronizedBlocked Aborting with System.exit(0)</p>
<p>*///:~</p>
<p>Each task represents a different kind of blocking. SleepBlock is an example of interruptible blocking, whereas IOBlocked and SynchronizedBlocked are uninterruptible blocking.<a l:href="#bookmark123" type="note"><sup>124</sup></a><sup> </sup>The program proves that I/O and waiting on a synchronized lock are not interruptible, but you can also anticipate this by looking at the code—no InterruptedException handler is required for either I/O or attempting to call a synchronized method.</p>
<p>The first two classes are straightforward: The run( ) method calls sleep( ) in the first class and read( ) in the second. To demonstrate SynchronizedBlocked, however, we must first acquire the lock. This is accomplished in the constructor by creating an instance of an anonymous Thread class that acquires the object lock by calling f( ) (the thread must be different from the one driving run( ) for SynchronizedBlock because one thread can acquire an object lock multiple times). Since f( ) never returns, that lock is never released. SynchronizedBlock.run( ) attempts to call f( ) and is blocked waiting for the lock to be released.</p>
<p>You’ll see from the output that you can interrupt a call to sleep( ) (or any call that requires you to catch InterruptedException). However, you cannot interrupt a task that is trying to acquire a synchronized lock or one that is trying to perform I/O. This is a little disconcerting, especially if you’re creating a task that performs I/O, because it means that I/O has the potential of locking your multithreaded program. Especially for Web-based programs, this is a concern.</p>
<p>A heavy-handed but sometimes effective solution to this problem is to close the underlying resource on which the task is blocked:</p>
<p>//: concurrency/CloseResource.java // Interrupting a blocked task by // closing the underlying resource.</p>
<p>// {RunByHand} import java.net.*; import java.util.concurrent.*; import java.io.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class CloseResource {</p>
<p>public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InputStream socketInput =</p>
<p>new Socket(&quot;localhost&quot;, 8080).getInputStream(); exec.execute(new IOBlocked(socketlnput)); exec.execute(new IOBlocked(System.in)); TimeUnit.MILLISECONDS.sleep(100); print(&quot;Shutting down all threads&quot;); exec.shutdownNow();</p>
<p>TimeUnit.SECONDS.sleep(l);</p>
<p>print(&quot;Closing &quot; + socketInput.getClass().getName()); socketInput.close(); // Releases blocked thread TimeUnit.SECONDS.sleep(l);</p>
<p>print(&quot;Closing &quot; + System.in.getClass().getName()); System.in.close(); // Releases blocked thread</p>
<p>}</p>
<p>} /* Output: (85% match)</p>
<p>Waiting for read():</p>
<p>Waiting for read():</p>
<p>Shutting down all threads Closing java.net.SocketInputStream Interrupted from blocked I/O Exiting IOBlocked.run()</p>
<p>Closing java.io.BufferedInputStream Exiting IOBlocked.run()</p>
<p>*///:~</p>
<p>After shutdownNow( ) is called, the delays before calling close( ) on the two input streams emphasize that the tasks unblock once the underlying resource is closed. It’s interesting to note that the interrupt( ) appears when you are closing the Socket but not when closing System.in.</p>
<p>Fortunately, the nio classes introduced in the I/O chapter provide for more civilized interruption of I/O. Blocked nio channels automatically respond to interrupts:</p>
<p>//: concurrency/NIOInterruption.java</p>
<p>// Interrupting a blocked NIO channel.</p>
<p>import java.net.*;</p>
<p>import java.nio.*;</p>
<p>import java.nio.channels.*;</p>
<p>import java.util.concurrent.*;</p>
<p>import java.io.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class NIOBlocked implements Runnable { private final SocketChannel sc;</p>
<p>public NIOBlocked(SocketChannel sc) { this.sc = sc; } public void run() { try {</p>
<p>print(&quot;Waiting for read() in &quot; + this); sc.read(ByteBuffer.allocate(1));</p>
<p>} catch(ClosedByInterruptException e) { print(&quot;ClosedByInterruptException&quot;);</p>
<p>} catch(AsynchronousCloseException e) { print(&quot;AsynchronousCloseException&quot;);</p>
<p>} catch(IOException e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>print(&quot;Exiting NIOBlocked.run() &quot; + this);</p>
<p>}</p>
<p>public class NIOInterruption {</p>
<p>public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InetSocketAddress isa =</p>
<p>new InetSocketAddress(&quot;localhost&quot;, 8080); SocketChannel sc1 = SocketChannel.open(isa); SocketChannel sc2 = SocketChannel.open(isa);</p>
<p>Future&lt;?&gt; f = exec.submit(new NIOBlocked(scl)); exec.execute(new NIOBlocked(sc2)); exec.shutdown();</p>
<p>TimeUnit.SECONDS.sleep(l);</p>
<p>// Produce an interrupt via cancel: f.cancel(true);</p>
<p>TimeUnit.SECONDS.sleep(l);</p>
<p>// Release the block by closing the channel: sc2.close();</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Waiting for read() in NIOBlocked@7a84e4</p>
<p>Waiting for read() in NIOBlocked@15c7850</p>
<p>ClosedByInterruptException</p>
<p>Exiting NIOBlocked.run() NIOBlocked@15c7850</p>
<p>AsynchronousCloseException</p>
<p>Exiting NIOBlocked.run() NIOBlocked@7a84e4</p>
<p>*///:~</p>
<p>As shown, you can also close the underlying channel to release the block, although this should rarely be necessary. Note that using execute( ) to start both tasks and calling e.shutdownNow( ) will easily terminate everything; capturing the Future in the example above was only necessary to send the interrupt to one thread and not the other.<a l:href="#bookmark124" type="note"><sup>125</sup></a><sup></sup></p>
<p>Exercise 18: (2) Create a non-task class with a method that calls sleep( ) for a long interval. Create a task that calls the method in the non-task class. In main( ), start the task, then call interrupt( ) to terminate it. Make sure that the task shuts down safely.</p>
<p>Exercise 19: (4) Modify OrnamentalGarden.java so that it uses interrupt( ).</p>
<p>Exercise 20: (1) Modify CachedThreadPool.java so that all tasks receive an interrupt( ) before they are completed.</p>
<p>Blocked by a mutex</p>
<p>As you saw in Interrupting.java, if you try to call a synchronized method on an object whose lock has already been acquired, the calling task will be suspended (blocked) until the lock becomes available. The following example shows how the same mutex can be multiply acquired by the same task:</p>
<p>//: concurrency/MultiLock.java</p>
<p>// One thread can reacquire the same lock.</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class MultiLock {</p>
<p>public synchronized void f1(int count) { if(count-- &gt; 0) {</p>
<p>print(&quot;f1() calling f2() with count &quot; + count); f2(count);</p>
<p>public synchronized void f2(int count) { if(count-- &gt; 0) {</p>
<p>print(&quot;f2() calling f1() with count &quot; + count); fl(count);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { final MultiLock multiLock = new MultiLock(); new Thread() {</p>
<p>public void run() { multiLock.f1(10);</p>
<p>}</p>
<p>}.start();</p>
<table>
<tr><th colspan="6">}</th></tr>
<tr><td>} /*</td><td>Output:</td><td></td><td></td><td></td><td></td></tr>
<tr><td>f1()</td><td>calling</td><td>—h KJ</td><td>with</td><td>count</td><td>9</td></tr>
<tr><td>f2()</td><td>calling</td><td>f1()</td><td>with</td><td>count</td><td>8</td></tr>
<tr><td>f1()</td><td>calling</td><td>—h KJ</td><td>with</td><td>count</td><td>7</td></tr>
<tr><td>f2()</td><td>calling</td><td>f1()</td><td>with</td><td>count</td><td>6</td></tr>
<tr><td>f1()</td><td>calling</td><td>—h KJ</td><td>with</td><td>count</td><td>5</td></tr>
<tr><td>f2()</td><td>calling</td><td>f1()</td><td>with</td><td>count</td><td>4</td></tr>
<tr><td>f1()</td><td>calling</td><td>—h KJ</td><td>with</td><td>count</td><td>3</td></tr>
<tr><td>f2()</td><td>calling</td><td>f1()</td><td>with</td><td>count</td><td>2</td></tr>
<tr><td>f1()</td><td>calling</td><td>—h KJ</td><td>with</td><td>count</td><td>1</td></tr>
<tr><td>f2()*///</td><td>calling</td><td>f1()</td><td>with</td><td>count</td><td>0</td></tr>
</table>
<p>In main( ), a Thread is created to call f1( ), then f1( ) and f2( ) call each other until the count becomes zero. Since the task has already acquired the multiLock object lock inside the first call to f1( ), that same task is reacquiring it in the call to f2( ), and so on. This makes sense because one task should be able to call other synchronized methods within the same object; that task already holds the lock.</p>
<p>As observed previously with uninterruptible I/O, anytime that a task can be blocked in such a way that it cannot be interrupted, you have the potential to lock up a program. One of the features added in the Java SE5 concurrency libraries is the ability for tasks blocked on ReentrantLocks to be interrupted, unlike tasks blocked on synchronized methods or critical sections:</p>
<p>//: concurrency/Interrupting2.java</p>
<p>// Interrupting a task blocked with a ReentrantLock. import java.util.concurrent.*; import java.util.concurrent.locks.*; import static net.mindview.util.Print.*;</p>
<p>class BlockedMutex {</p>
<p>private Lock lock = new ReentrantLock(); public BlockedMutex() {</p>
<p>// Acquire it right away, to demonstrate interruption // of a task blocked on a ReentrantLock: lock.lock();</p>
<p>}</p>
<p>public void f() { try {</p>
<p>// This will never be available to a second task lock.lockInterruptibly(); // Special call print(&quot;lock acquired in f()&quot;);</p>
<p>} catch(InterruptedException e) {</p>
<p>print(&quot;Interrupted from lock acquisition in f()&quot;);</p>
<p>class Blocked2 implements Runnable {</p>
<p>BlockedMutex blocked = new BlockedMutex(); public void run() {</p>
<p>print(&quot;Waiting for f() in BlockedMutex&quot;); blocked.f();</p>
<p>print(&quot;Broken out of blocked call&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class Interrupting2 {</p>
<p>public static void main(String[] args) throws Exception { Thread t = new Thread(new Blocked2()); t.start();</p>
<p>TimeUnit.SECONDS.sleep(l);</p>
<p>System.out.println(&quot;Issuing t.interrupt()&quot;); t.interrupt();</p>
<p>}</p>
<p>} /* Output:</p>
<p>Waiting for f() in BlockedMutex Issuing t.interrupt()</p>
<p>Interrupted from lock acquisition in f()</p>
<p>Broken out of blocked call *///:~</p>
<p>The class BlockedMutex has a constructor that acquires the object’s own Lock and never releases it. For that reason, if you try to call f( ) from a second task (different from the one that created the BlockedMutex), you will always be blocked because the Mutex cannot be acquired. In Blocked2, the run( ) method will be stopped at the call to blocked.f( ). When you run the program, you’ll see that, unlike an I/O call, interrupt( ) can break out of a call that’s blocked by a mutex.<a l:href="#bookmark125" type="note"><sup>126</sup></a><sup></sup></p>
<subtitle>Checking for an interrupt</subtitle>
<p>Note that when you call interrupt( ) on a thread, the only time that the interrupt occurs is when the task enters, or is already inside, a blocking operation (except, as you’ve seen, in the case of uninterruptible I/O or blocked synchronized methods, in which case there’s nothing you can do). But what if you’ve written code that may or may not make such a blocking call, depending on the conditions in which it is run? If you can only exit by throwing an exception on a blocking call, you won’t always be able to leave the run( ) loop. Thus, if you call interrupt( ) to stop a task, your task needs a second way to exit in the event that your run( ) loop doesn’t happen to be making any blocking calls.</p>
<p>This opportunity is presented by the interrupted status, which is set by the call to interrupt( ). You check for the interrupted status by calling interrupted( ). This not only tells you whether interrupt( ) has been called, it also clears the interrupted status. Clearing the interrupted status ensures that the framework will not notify you twice about a task being interrupted. You will be notified via either a single InterruptedException or a single successful Thread.interrupted( ) test. If you want to check again to see whether you were interrupted, you can store the result when you call Thread.interrupted( ).</p>
<p>The following example shows the typical idiom that you should use in your run( ) method to handle both blocked and non-blocked possibilities when the interrupted status is set:</p>
<p>//: concurrency/InterruptingIdiom.java // General idiom for interrupting a task.</p>
<p>// {Args: 1100}</p>
<p>import java.util.concurrent.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class NeedsCleanup { private final int id; public NeedsCleanup(int ident) { id = ident;</p>
<p>print(&quot;NeedsCleanup &quot; + id);</p>
<p>}</p>
<p>public void cleanup() {</p>
<p>print(&quot;Cleaning up &quot; + id);</p>
<p>}</p>
<p>}</p>
<p>class Blocked3 implements Runnable { private volatile double d = 0.0; public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>// point1</p>
<p>NeedsCleanup n1 = new NeedsCleanup(1);</p>
<p>// Start try-finally immediately after definition // of n1, to guarantee proper cleanup of n1: try {</p>
<p>print(&quot;Sleeping&quot;);</p>
<p>TimeUnit.SECONDS.sleep(1);</p>
<p>// point2</p>
<p>NeedsCleanup n2 = new NeedsCleanup(2);</p>
<p>// Guarantee proper cleanup of n2: try {</p>
<p>print(&quot;Calculating&quot;);</p>
<p>// A time-consuming, non-blocking operation: for(int i = 1; i &lt; 2500000; i++) d = d + (Math.PI + Math.E) / d; print(&quot;Finished time-consuming operation&quot;);</p>
<p>} finally { n2.cleanup();</p>
<p>}</p>
<p>} finally { n1.cleanup();</p>
<p>}</p>
<p>}</p>
<p>print(&quot;Exiting via while() test&quot;);</p>
<p>} catch(InterruptedException e) {</p>
<p>print(&quot;Exiting via InterruptedException&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class InterruptingIdiom {</p>
<p>public static void main(String[] args) throws Exception { if(args.length != 1) {</p>
<p>print(&quot;usage: java InterruptingIdiom delay-in-mS&quot;); System.exit(1);</p>
<p>}</p>
<p>Thread t = new Thread(new Blocked3()); t.start();</p>
<p>TimeUnit.MILLISECONDS.sleep(new Integer(args[0])); t.interrupt();</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>NeedsCleanup 1 Sleeping NeedsCleanup 2 Calculating</p>
<p>Finished time-consuming operation</p>
<p>Cleaning up 2</p>
<p>Cleaning up 1</p>
<p>NeedsCleanup 1</p>
<p>Sleeping</p>
<p>Cleaning up 1</p>
<p>Exiting via InterruptedException *///:~</p>
<p>The NeedsCleanup class emphasizes the necessity of proper resource cleanup if you leave the loop via an exception. Note that all NeedsCleanup resources created in Blocked3.run( ) must be immediately followed by try-finally clauses to guarantee that the cleanup( ) method is always called.</p>
<p>You must give the program a command-line argument which is the delay time in milliseconds before it calls interrupt( ). By using different delays, you can exit Blocked3.run( ) at different points in the loop: in the blocking sleep( ) call, and in the non-blocking mathematical calculation. You’ll see that if interrupt( ) is called after the comment &quot;point2&quot; (during the non-blocking operation), first the loop is completed, then all the local objects are destroyed, and finally the loop is exited at the top via the while statement. However, if interrupt( ) is called between &quot;pointi&quot; and &quot;point2&quot; (after the while statement but before or during the blocking operation sleep( )), the task exits via the InterruptedException, the first time a blocking operation is attempted. In that case, only the NeedsCleanup objects that have been created up to the point where the exception is thrown are cleaned up, and you have the opportunity to perform any other cleanup in the catch clause.</p>
<p>A class designed to respond to an interrupt( ) must establish a policy to ensure that it will remain in a consistent state. This generally means that the creation of all objects that require cleanup must be followed by try-finally clauses so that cleanup will occur regardless of how the run( ) loop exits. Code like this can work well, but alas, due to the lack of automatic destructor calls in Java, it relies on the client programmer to write the proper try-finally clauses.</p>
</section>
<section>
<title>
<p>Cooperation between tasks</p></title><empty-line/>
<p>As you’ve seen, when you use threads to run more than one task at a time, you can keep one task from interfering with another task’s resources by using a lock (mutex) to synchronize the behavior of the two tasks. That is, if two tasks are stepping on each other over a shared resource (usually memory), you use a mutex to allow only one task at a time to access that resource.</p>
<p>With that problem solved, the next step is to learn how to make tasks cooperate with each other, so that multiple tasks can work together to solve a problem. Now the issue is not about interfering with one another, but rather about working in unison, since portions of such problems must be solved before other portions can be solved. It’s much like project planning: The footings for the house must be dug first, but the steel can be laid and the concrete forms can be built in parallel, and both of those tasks must be finished before the concrete foundation can be poured. The plumbing must be in place before the concrete slab can be poured, the concrete slab must be in place before you start framing, and so on. Some of these tasks can be done in parallel, but certain steps require all tasks to be completed before you can move ahead.</p>
<p>The key issue when tasks are cooperating is handshaking between those tasks. To accomplish this handshaking, we use the same foundation: the mutex, which in this case guarantees that only one task can respond to a signal. This eliminates any possible race conditions. On top of the mutex, we add a way for a task to suspend itself until some external state changes (e.g., &quot;The plumbing is now in place&quot;), indicating that it’s time for that task to move forward. In this section, we’ll look at the issues of handshaking between tasks, which is safely implemented using the Object methods wait( ) and notifyAll( ). The Java SE5 concurrency library also provides Condition objects with await( ) and signal( ) methods. We’ll see the problems that can arise, and their solutions.</p>
<subtitle>wait() and notifyAll()</subtitle>
<p>wait( ) allows you to wait for a change in some condition that is outside the control of the forces in the current method. Often, this condition will be changed by another task. You don’t want to idly loop while testing the condition inside your task; this is called busy waiting, and it’s usually a bad use of CPU cycles. So wait( ) suspends the task while waiting for the world to change, and only when a notify( ) or notifyAll( ) occurs—suggesting that something of interest may have happened—does the task wake up and check for changes. Thus, wait( ) provides a way to synchronize activities between tasks.</p>
<p>It’s important to understand that sleep( ) does not release the object lock when it is called, and neither does yield( ). On the other hand, when a task enters a call to wait( ) inside a method, that thread’s execution is suspended, and the lock on that object is released. Because wait( ) releases the lock, it means that the lock can be acquired by another task, so other synchronized methods in the (now unlocked) object can be called during a wait( ). This is essential, because those other methods are typically what cause the change that makes it interesting for the suspended task to reawaken. Thus, when you call wait( ), you’re saying, &quot;I’ve done all I can right now, so I’m going to wait right here, but I want to allow other synchronized operations to take place if they can.&quot;</p>
<p>There are two forms of wait( ). One version takes an argument in milliseconds that has the same meaning as in sleep( ): &quot;Pause for this period of time.&quot; But unlike with sleep( ), with wait(pause):</p>
<p>1.    The object lock is released during the wait( ).</p>
<p>2.    You can also come out of the wait( ) due to a notify( ) or notifyAll( ), in addition to letting the clock run out.</p>
<p>The second, more commonly used form of wait( ) takes no arguments. This wait( ) continues indefinitely until the thread receives a notify( ) or notifyAll( ).</p>
<p>One fairly unique aspect of wait( ), notify( ), and notifyAll( ) is that these methods are part of the base class Object and not part of Thread. Although this seems a bit strange at first—to have something that’s exclusively for threading as part of the universal base class— it’s essential because these methods manipulate the lock that’s also part of every object. As a result, you can put a wait( ) inside any synchronized method, regardless of whether that class extends Thread or implements Runnable. In fact, the only place you can call wait( ), notify( ), or notifyAll( ) is within a synchronized method or block (sleep( ) can be called within non-synchronized methods since it doesn’t manipulate the lock). If you call any of these within a method that’s not synchronized, the program will compile, but when you run it, you’ll get an IllegalMonitorStateException with the somewhat nonintuitive message &quot;current thread not owner.&quot; This message means that the task calling wait( ), notify( ), or notifyAll( ) must &quot;own&quot; (acquire) the lock for the object before it can call any of those methods.</p>
<p>You can ask another object to perform an operation that manipulates its own lock. To do this, you must first capture that object’s lock. For example, if you want to send notifyAll( ) to an object x, you must do so inside a synchronized block that acquires the lock for x:</p>
<p>synchronized(x) { x.notifyAll();</p>
<p>}</p>
<p>Let’s look at a simple example. WaxOMatic.java has two processes: one to apply wax to a Car and one to polish it. The polishing task cannot do its job until the application task is finished, and the application task must wait until the polishing task is finished before it can put on another coat of wax. Both WaxOn and WaxOff use the Car object, which uses wait( ) and notifyAll( ) to suspend and restart tasks while they’re waiting for a condition to change:</p>
<p>//: concurrency/waxomatic/WaxOMatic.java</p>
<p>// Basic task cooperation.</p>
<p>package concurrency.waxomatic;</p>
<p>import java.util.concurrent.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Car {</p>
<p>private boolean waxOn = false; public synchronized void waxed() { waxOn = true; // Ready to buff notifyAll();</p>
<p>}</p>
<p>public synchronized void buffed() {</p>
<p>waxOn = false; // Ready for another coat of wax notifyAll();</p>
<p>}</p>
<p>public synchronized void waitForWaxing() throws InterruptedException { while(waxOn == false) wait();</p>
<p>}</p>
<p>public synchronized void waitForBuffing() throws InterruptedException { while(waxOn == true) wait();</p>
<p>}</p>
<p>}</p>
<p>class WaxOn implements Runnable { private Car car;</p>
<p>public WaxOn(Car c) { car = c; } public void run() { try {</p>
<p>while(!Thread.interrupted()) { printnb(&quot;Wax On! &quot;);</p>
<p>TimeUnit.MILLISECONDS.sleep(200);</p>
<p>car.waxed();</p>
<p>car.waitForBuffing();</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Exiting via interrupt&quot;);</p>
<p>}</p>
<p>print(&quot;Ending Wax On task&quot;);</p>
<p>}</p>
<p>}</p>
<p>class WaxOff implements Runnable { private Car car;</p>
<p>public WaxOff(Car c) { car = c; } public void run() { try {</p>
<p>while(!Thread.interrupted()) { car.waitForWaxing(); printnb(&quot;Wax Off! &quot;);</p>
<p>TimeUnit.MILLISECONDS.sleep(200);</p>
<p>car.buffed();</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Exiting via interrupt&quot;);</p>
<p>}</p>
<p>print(&quot;Ending Wax Off task&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class WaxOMatic {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>Car car = new Car();</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new WaxOff(car)); exec.execute(new WaxOn(car));</p>
<p>TimeUnit.SECONDS.sleep(5); // Run for a while... exec.shutdownNow(); // Interrupt all tasks</p>
<p>}</p>
<p>} /* Output: (95% match)</p>
<p>Wax On! Wax Off!    Wax    On! Wax Off!    Wax    On! Wax Off!    Wax    On! Wax Off!    Wax</p>
<p>On! Wax Off! Wax    On!    Wax Off! Wax    On!    Wax Off! Wax    On!    Wax Off! Wax    On!</p>
<p>Wax Off! Wax On!    Wax    Off! Wax On!    Wax    Off! Wax On!    Wax    Off! Wax On!</p>
<p>Exiting via interrupt</p>
<p>Ending Wax On task</p>
<p>Exiting via interrupt</p>
<p>Ending Wax Off task</p>
<p>*///:~</p>
<p>Here, Car has a single boolean waxOn, which indicates the state of the waxing-polishing process.</p>
<p>In waitForWaxing( ), the waxOn flag is checked, and if it is false, the calling task is suspended by calling wait( ). It’s important that this occur in a synchronized method, where the task has acquired the lock. When you call wait( ), the thread is suspended and the lock is released. It is essential that the lock be released because, to safely change the state of the object (for example, to change waxOn to true, which must happen if the suspended task is to ever continue), that lock must be available to be acquired by some other task. In this example, when another task calls waxed( ) to indicate that it’s time to do something, the lock must be acquired in order to change waxOn to true. Afterward, waxed( ) calls notifyAll( ), which wakes up the task that was suspended in the call to wait( ). In order for the task to wake up from a wait( ), it must first reacquire the lock that it released when it entered the wait( ). The task will not wake up until that lock becomes available.<a l:href="#bookmark126" type="note"><sup>127</sup></a><sup></sup></p>
<p>WaxOn.run( ) represents the first step in the process of waxing the car, so it performs its operation: a call to sleep( ) to simulate the time necessary for waxing. It then tells the car that waxing is complete, and calls waitForBuffing( ), which suspends this task with a wait( ) until the WaxOff task calls buffed( ) for the car, changing the state and calling notifyAll( ). WaxOff.run( ), on the other hand, immediately moves into waitForWaxing( ) and is thus suspended until the wax has been applied by WaxOn and waxed( ) is called. When you run this program, you can watch this two-step process repeat itself as control is handed back and forth between the two tasks. After five seconds, interrupt( ) halts both threads; when you call shutdownNow( ) for an ExecutorService, it calls interrupt( ) for all the tasks it is controlling.</p>
<p>The previous example emphasizes that you must surround a wait( ) with a while loop that checks the condition(s) of interest. This is important because:</p>
<p>•    You may have multiple tasks waiting on the same lock for the same reason, and the first task that wakes up might change the situation (even if you don’t do this someone might inherit from your class and do it). If that is the case, this task should be suspended again until its condition of interest changes.</p>
<p>•    By the time this task awakens from its wait( ), it’s possible that some other task will have changed things such that this task is unable to perform or is uninterested in performing its operation at this time. Again, it should be resuspended by calling wait( ) again.</p>
<p>•    It’s also possible that tasks could be waiting on your object’s lock for different reasons (in which case you must use notifyAll( )). In this case, you need to check whether you’ve been woken up for the right reason, and if not, call wait( ) again.</p>
<p>Thus, it’s essential that you check for your particular condition of interest, and go back into wait( ) if that condition is not met. This is idiomatically written using a while.</p>
<p>Exercise 21: (2) Create two Runnables, one with a run( ) that starts and calls wait( ). The second class should capture the reference of the first Runnable object. Its run( ) should call notifyAll( ) for the first task after some number of seconds have passed so that the first task can display a message. Test your classes using an Executor.</p>
<p>Exercise 22: (4) Create an example of a busy wait. One task sleeps for a while and then sets a flag to true. The second task watches that flag inside a while loop (this is the busy wait) and when the flag becomes true, sets it back to false and reports the change to the console. Note how much wasted time the program spends inside the busy wait, and create a second version of the program that uses wait( ) instead of the busy wait.</p>
<p>Missed Signals</p>
<p>When two threads are coordinated using notify( )/wait( ) or notifyAll( )/wait( ), it’s possible to miss a signal. Suppose T1 is a thread that notifies T2, and that the two threads are implemented using the following (flawed) approach:</p>
<p>T1:</p>
<p>synchronized(sharedMonitor) {</p>
<p>&lt;setup condition for T2&gt; sharedMonitor.notify();</p>
<p>}</p>
<p>T2:</p>
<p>while(someCondition) {</p>
<p>// Point 1</p>
<p>synchronized(sharedMonitor) { sharedMonitor.wait();</p>
<p>}</p>
<p>}</p>
<p>The &lt;setup condition for T2&gt; is an action to prevent T2 from calling wait( ), if it hasn’t already.</p>
<p>Assume that T2 evaluates someCondition and finds it true. At Point 1, the thread scheduler might switch to T1. T1 executes its setup, and then calls notify( ). When T2 continues executing, it is too late for T2 to realize that the condition has been changed in the meantime, and it will blindly enter wait( ). The notify( ) will be missed and T2 will wait indefinitely for the signal that was already sent, producing deadlock.</p>
<p>The solution is to prevent the race condition over the someCondition variable. Here is the correct approach for T2:</p>
<p>synchronized(sharedMonitor) { while(someCondition) sharedMonitor.wait();</p>
<p>}</p>
<p>Now, if T1 executes first, when control returns back to T2 it will figure out that the condition has changed, and will not enter wait( ). Conversely, if T2 executes first, it will enter wait( ) and later be awakened by T1. Thus, the signal cannot be missed.</p>
<subtitle>notify() vs. notifyAll()</subtitle>
<p>Because more than one task could technically be in a wait( ) on a single Car object, it is safer to call notifyAll( ) rather than just notify( ). However, the structure of the above program is such that only one task will actually be in a wait( ), so you could use notify( ) instead of notifyAll( ).</p>
<p>Using notify( ) instead of notifyAll( ) is an optimization. Only one task of the possible many that are waiting on a lock will be awoken with notify( ), so you must be certain that the right task will wake up if you try to use notify( ). In addition, all tasks must be waiting on the same condition in order for you to use notify( ), because if you have tasks that are waiting on different conditions, you don’t know if the right one will wake up. If you use notify( ), only one task must benefit when the condition changes. Finally, these constraints must always be true for all possible subclasses. If any of these rules cannot be met, you must use notifyAll( ) rather than notify( ).</p>
<p>One of the confusing statements often made in discussions of Java threading is that notifyAll( ) wakes up &quot;all waiting tasks.&quot; Does this mean that any task that is in a wait( ), anywhere in the program, is awoken by any call to notifyAll( )? In the following example, the code associated with Task2 shows that this is not true—in fact, only the tasks that are waiting on a particular lock are awoken when notifyAll( ) is called/or that lock:</p>
<p>//: concurrency/NotifyVsNotifyAll.java import java.util.concurrent.*; import java.util.*;</p>
<p>class Blocker {</p>
<p>synchronized void waitingCall() { try {</p>
<p>while(!Thread.interrupted()) { wait();</p>
<p>System.out.print(Thread.currentThread() + &quot; &quot;);</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>// OK to exit this way</p>
<p>}</p>
<p>}</p>
<p>synchronized void prod() { notify(); } synchronized void prodAH() { notifyAH(); }</p>
<p>class Task implements Runnable {</p>
<p>static Blocker blocker = new Blocker(); public void run() { blocker.waitingCall(); }</p>
<p>}</p>
<p>class Task2 implements Runnable {</p>
<p>// A separate Blocker object:</p>
<p>static Blocker blocker = new Blocker();</p>
<p>public void run() { blocker.waitingCall(); }</p>
<p>}</p>
<p>public class NotifyVsNotifyAll {</p>
<p>public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; 5; i++) exec.execute(new Task()); exec.execute(new Task2());</p>
<p>Timer timer = new Timer(); timer.scheduleAtFixedRate(new TimerTask() { boolean prod = true; public void run() { if(prod) {</p>
<p>System.out.print(&quot;\nnotify() &quot;);</p>
<p>Task.blocker.prod(); prod = false;</p>
<p>} else {</p>
<p>System.out.print(&quot;\nnotifyAll() &quot;);</p>
<p>Task.blocker.prodAll(); prod = true;</p>
<p>}</p>
<p>}</p>
<p>}, 400, 400); // Run every .4 second TimeUnit.SECONDS.sleep(5); // Run for a while... timer.cancel();</p>
<p>System.out.println(&quot;\nTimer canceled&quot;); TimeUnit.MILLISECONDS.sleep(500); System.out.print(&quot;Task2.blocker.prodAll() &quot;); Task2.blocker.prodAll();</p>
<p>TimeUnit.MILLISECONDS.sleep(500);</p>
<p>System.out.println(&quot;\nShutting down&quot;); exec.shutdownNow(); // Interrupt all tasks</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>notify() Thread[pool-1-thread-1,5,main]</p>
<p>notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-</p>
<p>5.5, main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</p>
<p>notify() Thread[pool-1-thread-1,5,main]</p>
<p>notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-</p>
<p>2.5, main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</p>
<p>notify() Thread[pool-1-thread-1,5,main]</p>
<p>notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-</p>
<p>5.5, main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</p>
<p>notify() Thread[pool-1-thread-1,5,main]</p>
<p>notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-</p>
<p>2.5, main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</p>
<p>notify() Thread[pool-1-thread-1,5,main]</p>
<p>notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-</p>
<p>5.5, main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</p>
<p>notify() Thread[pool-1-thread-1,5,main]</p>
<p>notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-</p>
<p>2.5, main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</p>
<p>Timer canceled</p>
<p>Task2.blocker.prodAll() Thread[pool-1-thread-6,5,main]</p>
<p>Shutting down *///:~</p>
<p>Task and Task2 each have their own Blocker object, so each Task object blocks on Task.blocker, and each Task2 object blocks on Task2.blocker. In main( ), a</p>
<p>java.util.Timer object is set up to execute its run( ) method every 4/10 of a second, and that run( ) alternates between calling notify( ) and notifyAll( ) on Task.blocker via the &quot;prod&quot; methods.</p>
<p>From the output, you can see that even though a Task2 object exists and is blocked on Task2.blocker, none of the notify( ) or notifyAll( ) calls on Task.blocker causes the Task2 object to wake up. Similarly, at the end of main( ), cancel( ) is called for the timer, and even though the timer is canceled, the first five tasks are still running and still blocked in their calls to Task.blocker.waitingCall( ). The output from the call to Task2.blocker.prodAll( ) does nor include any of the tasks waiting on the lock in Task.blocker.</p>
<p>This also makes sense if you look at prod( ) and prodAll( ) in Blocker. These methods are synchronized, which means that they acquire their own lock, so when they call notify( ) or notifyAll( ), it’s logical that they are only calling it for that lock—and thus only wake up tasks that are waiting on that particular lock.</p>
<p>Blocker.waitingCall( ) is simple enough that you could just say for(;;) instead of while(!Thread.interrupted( )), and achieve the same effect in this case, because in this example there’s no difference between leaving the loop with an exception and leaving it by checking the interrupted( ) flag— the same code is executed in both cases. As a matter of form, however, this example checks interrupted( ), because there are two different ways of leaving the loop. If, sometime later, you decide to add more code to the loop, you risk introducing an error if you don’t cover both paths of exit from the loop.</p>
<p>Exercise 23: (7) Demonstrate that WaxOMatic.java works successfully when you use notify( ) instead of notifyAll( ).</p>
<subtitle>Producers and consumers</subtitle>
<p>Consider a restaurant that has one chef and one waitperson. The waitperson must wait for the chef to prepare a meal. When the chef has a meal ready, the chef notifies the waitperson, who then gets and delivers the meal and goes back to waiting. This is an example of task cooperation: The chef represents the producer, and the waitperson represents the consumer. Both tasks must handshake with each other as meals are produced and consumed, and the system must shut down in an orderly fashion. Here is the story modeled in code:</p>
<p>//: concurrency/Restaurant.java</p>
<p>// The producer-consumer approach to task cooperation.</p>
<p>import java.util.concurrent.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Meal {</p>
<p>private final int orderNum;</p>
<p>public Meal(int orderNum) { this.orderNum = orderNum; } public String toString() { return &quot;Meal &quot; + orderNum; }</p>
<p>class WaitPerson implements Runnable { private Restaurant restaurant;</p>
<p>public WaitPerson(Restaurant r) { restaurant = r; } public void run() { try {</p>
<p>while(!Thread.interrupted()) { synchronized(this) {</p>
<p>while(restaurant.meal == null)</p>
<p>wait(); // ... for the chef to produce a meal</p>
<p>}</p>
<p>print(&quot;Waitperson got &quot; + restaurant.meal); synchronized(restaurant.chef) { restaurant.meal = null;</p>
<p>restaurant.chef.notifyAll(); // Ready for another</p>
<p>}</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;WaitPerson interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class Chef implements Runnable { private Restaurant restaurant; private int count = 0;</p>
<p>public Chef(Restaurant r) { restaurant = r; } public void run() { try {</p>
<p>while(!Thread.interrupted()) { synchronized(this) {</p>
<p>while(restaurant.meal != null)</p>
<p>wait(); // ... for the meal to be taken</p>
<p>}</p>
<p>if(++count == 10) {</p>
<p>print(&quot;Out of food, closing&quot;); restaurant.exec.shutdownNow();</p>
<p>}</p>
<p>printnb(&quot;Order up! &quot;); synchronized(restaurant.waitPerson) { restaurant.meal = new Meal(count); restaurant.waitPerson.notifyAll();</p>
<p>}</p>
<p>TimeUnit.MILLISECONDS.sleep(100);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Chef interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class Restaurant {</p>
<p>Meal meal;</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); WaitPerson waitPerson = new WaitPerson(this);</p>
<p>Chef chef = new Chef(this); public Restaurant() { exec.execute(chef); exec.execute(waitPerson);</p>
<p>{</p>
<table>
<tr><td></td><td colspan="2">public</td><td>stat</td><td>ic</td><td>void</td><td>main</td><td colspan="2">(Stri</td><td>ng</td></tr>
<tr><td></td><td colspan="2">new</td><td colspan="3">Restaurant();</td><td></td><td></td><td></td><td></td></tr>
<tr><td>}</td><td>;/* 1</td><td colspan="2">Output:</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>O</td><td>rder</td><td>up</td><td>! Wai</td><td>tpe</td><td>rson</td><td>got</td><td>Me</td><td>al</td><td>1</td></tr>
<tr><td>O</td><td>rder</td><td>up</td><td>! Wai</td><td>tpe</td><td>rson</td><td>got</td><td>Me</td><td>al</td><td>2</td></tr>
<tr><td>O</td><td>rder</td><td>up</td><td>! Wai</td><td>tpe</td><td>rson</td><td>got</td><td>Me</td><td>al</td><td>3</td></tr>
<tr><td>O</td><td>rder</td><td>up</td><td>! Wai</td><td>tpe</td><td>rson</td><td>got</td><td>Me</td><td>al</td><td>4</td></tr>
<tr><td>O</td><td>rder</td><td>up</td><td>! Wai</td><td>tpe</td><td>rson</td><td>got</td><td>Me</td><td>al</td><td>5</td></tr>
<tr><td>O</td><td>rder</td><td>up</td><td>! Wai</td><td>tpe</td><td>rson</td><td>got</td><td>Me</td><td>al</td><td>6</td></tr>
<tr><td>O</td><td>rder</td><td>up</td><td>! Wai</td><td>tpe</td><td>rson</td><td>got</td><td>Me</td><td>al</td><td>7</td></tr>
<tr><td>O</td><td>rder</td><td>up</td><td>! Wai</td><td>tpe</td><td>rson</td><td>got</td><td>Me</td><td>al</td><td>8</td></tr>
<tr><td>O</td><td>rder</td><td>up</td><td>! Wai</td><td>tpe</td><td>rson</td><td>got</td><td>Me</td><td>al</td><td>9</td></tr>
<tr><td colspan="10">Out of food, closing WaitPerson interrupted Order up! Chef interrupted</td></tr>
</table>
<p>The Restaurant is the focal point for both the WaitPerson and the Chef. Both must know what Restaurant they are working for because they must place or fetch the meal from the restaurant’s &quot;meal window,&quot; restaurant.meal. In run( ), the WaitPerson goes into wait( ) mode, stopping that task until it is woken up with a notifyAll( ) from the Chef. Since this is a very simple program, we know that only one task will be waiting on the WaitPerson’s lock: the WaitPerson task itself. For this reason, it’s theoretically possible to call notify( ) instead of notifyAll( ). However, in more complex situations, multiple tasks may be waiting on a particular object lock, so you don’t know which task should be awakened. Thus, it’s safer to call notifyAll( ), which wakes up all the tasks waiting on that lock. Each task must then decide whether the notification is relevant.</p>
<p>Once the Chef delivers a Meal and notifies the WaitPerson, the Chef waits until the WaitPerson collects the meal and notifies the Chef, who can then produce the next Meal.</p>
<p>Notice that the wait( ) is wrapped in a while( ) statement that is testing for the same thing that is being waited for. This seems a bit strange at first—if you’re waiting for an order, once you wake up, the order must be available, right? As noted earlier, the problem is that in a concurrent application, some other task might swoop in and grab the order while the WaitPerson is waking up. The only safe approach is to always use the following idiom for a wait( ) (within proper synchronization, of course, and programming against the possibility of missed signals):</p>
<p>while(conditionlsNotMet)</p>
<p>wait();</p>
<p>This guarantees that the condition will be met before you get out of the wait loop, and if you have been notified of something that doesn’t concern the condition (as can happen with notifyAll( )), or the condition changes before you get fully out of the wait loop, you are guaranteed to go back into waiting.</p>
<p>Observe that the call to notifyAll( ) must first capture the lock on waitPerson. The call to wait( ) in WaitPerson.run( ) automatically releases the lock, so this is possible. Because the lock must be owned in order for notifyAll( ) to be called, it’s guaranteed that two tasks trying to call notifyAll( ) on one object won’t step on each other’s toes.</p>
<p>Both run( ) methods are designed for orderly shutdown by enclosing the entire run( ) with a try block. The catch clause closes right before the closing brace of the run( ) method, so if the task receives an InterruptedException, it ends immediately after catching the exception.</p>
<p>In Chef, note that after calling shutdownNow( ) you could simply return from run( ), and normally that’s what you should do. However, it’s a little more interesting to do it this way. Remember that shutdownNow( ) sends an interrupt( ) to all the tasks that the ExecutorService started. But in the case of the Chef, the task doesn’t shut down immediately upon getting the interrupt( ), because the interrupt only throws InterruptedException as the task attempts to enter an (interruptible) blocking operation. Thus, you’ll see &quot;Order up!&quot; displayed first, and then the InterruptedException is thrown when the Chef attempts to call sleep( ). If you remove the call to sleep( ), the task will get to the top of the run( ) loop and exit because of the Thread.interrupted( ) test, without throwing an exception.</p>
<p>The preceding example has only a single spot for one task to store an object so that another task can later use that object. However, in a typical producerconsumer implementation, you use a first-in, first-out queue in order to store the objects being produced and consumed. You’ll learn more about such queues later in this chapter.</p>
<p>Exercise 24: (1) Solve a single-producer, single-consumer problem using wait( ) and notifyAll( ). The producer must not overflow the receiver’s buffer, which can happen if the producer is faster than the consumer. If the consumer is faster than the producer, then it must not read the same data more than once. Do not assume anything about the relative speeds of the producer or consumer.</p>
<p>Exercise 25: (1) In the Chef class in Restaurant.java, return from run( ) after calling shutdownNow( ) and observe the difference in behavior.</p>
<p>Exercise 26: (8) Add a BusBoy class to Restaurant.java. After the meal is delivered, the WaitPerson should notify the BusBoy to clean up.</p>
<p>Using explicit Lock and Condition objects</p>
<p>There are additional, explicit tools in the Java SE5 java.util.concurrent library that can be used to rewrite WaxOMatic.java. The basic class that uses a mutex and allows task suspension is the Condition, and you can suspend a task by calling await( ) on a Condition. When external state changes take place that might mean that a task should continue processing, you notify the task by calling signal( ), to wake up one task, or signalAll( ), to wake up all tasks that have suspended themselves on that Condition object (as with notifyAll( ), signalAll( ) is the safer approach).</p>
<p>Here’s WaxOMatic.java rewritten to contain a Condition that it uses to suspend a task inside waitForWaxing( ) or waitForBuffing( ):</p>
<p>//: concurrency/waxomatic2/WaxOMatic2.java // Using Lock and Condition objects. package concurrency.waxomatic2; import java.util.concurrent.*; import java.util.concurrent.locks.*; import static net.mindview.util.Print.*;</p>
<p>class Car {</p>
<p>private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); private boolean waxOn = false; public void waxed() { lock.lock(); try {</p>
<p>waxOn = true; // Ready to buff condition.signalAll();</p>
<p>} finally {</p>
<p>lock.unlock();</p>
<p>public void buffed() { lock.lock(); try {</p>
<p>waxOn = false; // Ready for another coat of wax condition.signalAll();</p>
<p>} finally { lock.unlock();</p>
<p>}</p>
<p>}</p>
<p>public void waitForWaxing() throws InterruptedException { lock.lock(); try {</p>
<p>while(waxOn == false) condition.await();</p>
<p>} finally { lock.unlock();</p>
<p>}</p>
<p>}</p>
<p>public void waitForBuffing() throws InterruptedException{ lock.lock(); try {</p>
<p>while(waxOn == true) condition.await();</p>
<p>} finally { lock.unlock();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class WaxOn implements Runnable { private Car car;</p>
<p>public WaxOn(Car c) { car = c; } public void run() { try {</p>
<p>while(!Thread.interrupted()) { printnb(&quot;Wax On! &quot;); TimeUnit.MILLISECONDS.sleep(200); car.waxed(); car.waitForBuffing();</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Exiting via interrupt&quot;);</p>
<p>}</p>
<p>print(&quot;Ending Wax On task&quot;);</p>
<p>}</p>
<p>}</p>
<p>class WaxOff implements Runnable { private Car car;</p>
<p>public WaxOff(Car c) { car = c; } public void run() { try {</p>
<p>while(!Thread.interrupted()) { car.waitForWaxing(); printnb(&quot;Wax Off! &quot;); TimeUnit.MILLISECONDS.sleep(200); car.buffed();</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Exiting via interrupt&quot;);</p>
<p>print(&quot;Ending Wax Off task&quot;);</p>
<p>public class WaxOMatic2 {</p>
<p>public static void main(String[] args) throws Exception { Car car = new Car();</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new WaxOff(car)); exec.execute(new WaxOn(car));</p>
<p>TimeUnit.SECONDS.sleep(5);</p>
<p>exec.shutdownNow();</p>
<table>
<tr><th colspan="17">}} /* Output: (90% match)</th></tr>
<tr><td>Wax</td><td>On!</td><td>Wax</td><td>Off!</td><td>Wax</td><td>On!</td><td>Wax</td><td>Off!</td><td>Wax</td><td>On!</td><td>Wax</td><td>Off!</td><td>Wax</td><td>On!</td><td>Wax</td><td>Off!</td><td>Wax</td></tr>
<tr><td>On!</td><td colspan="2">Wax Off!</td><td>Wax</td><td>On!</td><td colspan="2">Wax Off!</td><td>Wax</td><td>On!</td><td colspan="2">Wax Off!</td><td>Wax</td><td>On!</td><td colspan="2">Wax Off!</td><td>Wax</td><td>On!</td></tr>
<tr><td>Wax</td><td>Off</td><td>Wax</td><td>On!</td><td>Wax</td><td>Off</td><td>Wax</td><td>On!</td><td>Wax</td><td>Off</td><td>Wax</td><td>On!</td><td>Wax</td><td>Off</td><td>Wax</td><td>On!</td><td></td></tr>
<tr><td colspan="17">Exiting via interrupt Ending Wax Off task Exiting via interrupt Ending Wax On task *///:~</td></tr>
</table>
<p>In Car’s constructor, a single Lock produces a Condition object which is used to manage inter-task communication. However, the Condition object contains no information about the state of the process, so you need to manage additional information to indicate process state, which is the boolean waxOn.</p>
<p>Each call to lock( ) must immediately be followed by a try-finally clause to guarantee that unlocking happens in all cases. As with the built-in versions, a task must own the lock before it can call await( ), signal( ) or signalAll( ).</p>
<p>Notice that this solution is more complex than the previous one, and the complexity doesn’t gain you anything in this case. The Lock and Condition objects are only necessary for more difficult threading problems.</p>
<p>Exercise 27: (2) Modify Restaurant.java to use explicit Lock and Condition objects.</p>
<subtitle>Producer-consumers and queues</subtitle>
<p>The wait( ) and notifyAll( ) methods solve the problem of task cooperation in a rather low-level fashion, handshaking every interaction. In many cases, you can move up a level of abstraction and solve task cooperation problems using a synchronized queue, which only allows one task at a time to insert or remove an element. This is provided for you in the java.util.concurrent.BlockingQueue interface, which has a number of standard implementations. You’ll usually use the LinkedBlockingQueue, which is an unbounded queue; the ArrayBlockingQueue has a fixed size, so you can only put so many elements in it before it blocks.</p>
<p>These queues also suspend a consumer task if that task tries to get an object from the queue and the queue is empty, and resume when more elements become available. Blocking queues can solve a remarkable number of problems in a much simpler and more reliable fashion than wait( ) and notifyAll( ).</p>
<p>Here’s a simple test that serializes the execution of LiftOff objects. The consumer is LiftOffRunner, which pulls each LiftOff object off the BlockingQueue and runs it</p>
<p>directly. (That is, it uses its own thread by calling run( ) explicitly rather than starting up a new thread for each task.)</p>
<p>//: concurrency/TestBlockingQueues.java // {RunByHand}</p>
<p>import java.util.concurrent.*; import java.io.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class LiftOffRunner implements Runnable { private BlockingQueue&lt;LiftOff&gt; rockets; public LiftOffRunner(BlockingQueue&lt;LiftOff&gt; queue) { rockets = queue;</p>
<p>}</p>
<p>public void add(LiftOff lo) { try {</p>
<p>rockets.put(lo);</p>
<p>} catch(InterruptedException e) { print(&quot;Interrupted during put()&quot;);</p>
<p>}</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>LiftOff rocket = rockets.take(); rocket.run(); // Use this thread</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Waking from take()&quot;);</p>
<p>}</p>
<p>print(&quot;Exiting LiftOffRunner&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class TestBlockingQueues { static void getkey() { try {</p>
<p>// Compensate for Windows/Linux difference in the // length of the result produced by the Enter key: new BufferedReader(</p>
<p>new InputStreamReader(System.in)).readLine();</p>
<p>} catch(java.io.IOException e) { throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>static void getkey(String message) { print(message); getkey();</p>
<p>}</p>
<p>static void</p>
<p>test(String msg, BlockingQueue&lt;LiftOff&gt; queue) { print(msg);</p>
<p>LiftOffRunner runner = new LiftOffRunner(queue);</p>
<p>Thread t = new Thread(runner); t.start();</p>
<p>for(int i = 0; i &lt; 5; i++) runner.add(new LiftOff(5)); getkey(&quot;Press ‘Enter&apos; (&quot; + msg + &quot;)&quot;); t.interrupt();</p>
<p>print(&quot;Finished &quot; + msg + &quot; test&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>test(&quot;LinkedBlockingQueue&quot;, // Unlimited size</p>
<p>new LinkedBlockingQueue&lt;LiftOff&gt;()); test(&quot;ArrayB!ockingQueue&quot;, // Fixed size new ArrayB!ockingQueue&lt;LiftOff&gt;(3)); test(&quot;SynchronousQueue&quot;, // Size of 1 new SynchronousQueue&lt;LiftOff&gt;());</p>
<p>}</p>
<p>} ///:~</p>
<p>The tasks are placed on the BlockingQueue by main( ) and are taken off the BlockingQueue by the LiftOffRunner. Notice that LiftOffRunner can ignore synchronization issues because they are solved by the BlockingQueue.</p>
<p>Exercise 28: (3) Modify TestBlockingQueues.java by adding a new task that places LiftOff on the BlockingQueue, instead of doing it in main( ).</p>
<p>BlockingQueues of toast</p>
<p>As an example of the use of BlockingQueues, consider a machine that has three tasks: one to make toast, one to butter the toast, and one to put jam on the buttered toast. We can run the toast through BlockingQueues between processes:</p>
<p>//: concurrency/ToastOMatic.java // A toaster that uses queues. import java.util.concurrent.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*; class Toast {</p>
<p>public enum Status { DRY, BUTTERED, JAMMED }</p>
<p>private Status status = Status.DRY;</p>
<p>private final int id;</p>
<p>public Toast(int idn) { id = idn; }</p>
<p>public void butter() { status = Status.BUTTERED; }</p>
<p>public void jam() { status = Status.JAMMED; }</p>
<p>public Status getStatus() { return status; }</p>
<p>public int getId() { return id; }</p>
<p>public String toString() {</p>
<p>return &quot;Toast &quot; + id + &quot;: &quot; + status;</p>
<p>}</p>
<p>}</p>
<p>class ToastQueue extends LinkedBlockingQueue&lt;Toast&gt; {}</p>
<p>class Toaster implements Runnable { private ToastQueue toastQueue; private int count = 0; private Random rand = new Random(47); public Toaster(ToastQueue tq) { toastQueue = tq; } public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>TimeUnit.MILLISECONDS.sleep(</p>
<p>100 + rand.nextInt(500));</p>
<p>// Make toast</p>
<p>Toast t = new Toast(count++); print(t);</p>
<p>// Insert into queue toastQueue.put(t);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Toaster interrupted&quot;);</p>
<p>print(&quot;Toaster off&quot;);</p>
<p>// Apply butter to toast:</p>
<p>class Butterer implements Runnable {</p>
<p>private ToastQueue dryQueue, butteredQueue; public Butterer(ToastQueue dry, ToastQueue buttered) { dryQueue = dry; butteredQueue = buttered;</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>// Blocks until next piece of toast is available:</p>
<p>Toast t = dryQueue.take();</p>
<p>t.butter();</p>
<p>print(t);</p>
<p>butteredQueue.put(t);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Butterer interrupted&quot;);</p>
<p>}</p>
<p>print(&quot;Butterer off&quot;);</p>
<p>}</p>
<p>}</p>
<p>// Apply jam to buttered toast: class Jammer implements Runnable {</p>
<p>private ToastQueue butteredQueue, finishedQueue; public Jammer(ToastQueue buttered, ToastQueue finished) { butteredQueue = buttered; finishedQueue = finished;</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>// Blocks until next piece of toast is available:</p>
<p>Toast t = butteredQueue.take();</p>
<p>t.jam();</p>
<p>print(t);</p>
<p>finishedQueue.put(t);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Jammer interrupted&quot;);</p>
<p>}</p>
<p>print(&quot;Jammer off&quot;);</p>
<p>}</p>
<p>}</p>
<p>// Consume the toast: class Eater implements Runnable { private ToastQueue finishedQueue; private int counter = 0; public Eater(ToastQueue finished) { finishedQueue = finished;</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>// Blocks until next piece of toast is available: Toast t = finishedQueue.take();</p>
<p>// Verify that the toast is coming in order,</p>
<p>// and that all pieces are getting jammed: if(t.getId() != counter++ ||</p>
<p>t.getStatus() != Toast.Status.JAMMED) { print(&quot;&gt;&gt;&gt;&gt; Error: &quot; + t);</p>
<p>System.exit(1);</p>
<p>} else</p>
<p>print(&quot;Chomp! &quot; + t);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Eater interrupted&quot;);</p>
<p>}</p>
<p>print(&quot;Eater off&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class ToastOMatic {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>ToastQueue dryQueue = new ToastQueue(),</p>
<p>butteredQueue = new ToastQueue(), finishedQueue = new ToastQueue();</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new Toaster(dryQueue)); exec.execute(new Butterer(dryQueue, butteredQueue)); exec.execute(new Jammer(butteredQueue, finishedQueue)); exec.execute(new Eater(finishedQueue));</p>
<p>TimeUnit.SECONDS.sleep(5);</p>
<p>exec.shutdownNow();</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>Toast is an excellent example of the value of enums. Note that there is no explicit synchronization (using Lock objects or the synchronized keyword) because the synchronization is implicitly managed by the queues (which synchronize internally) and by the design of the system-each piece of Toast is only operated on by one task at a time. Because the queues block, processes suspend and resume automatically. You can see that the simplification produced by BlockingQueues can be quite dramatic. The coupling between the classes that would exist with explicit wait( ) and notifyAll( ) statements is eliminated because each class communicates only with its BlockingQueues.</p>
<p>Exercise 29: (8) Modify ToastOMatic.java to create peanut butter and jelly on toast sandwiches using two separate assembly lines (one for peanut butter, the second for jelly, then merging the two lines).</p>
<subtitle>Using pipes for I/O between tasks</subtitle>
<p>It’s often useful for tasks to communicate with each other using I/O. Threading libraries may provide support for inter-task I/O in the form of pipes. These exist in the Java I/O library as the classes PipedWriter (which allows a task to write into a pipe) and PipedReader (which allows a different task to read from the same pipe). This can be thought of as a variation of the producer-consumer problem, where the pipe is the canned solution. The pipe is basically a blocking queue, which existed in versions of Java before BlockingQueue was introduced.</p>
<p>Here’s a simple example in which two tasks use a pipe to communicate:</p>
<p>//: concurrency/PipedIO.java // Using pipes for inter-task I/O import java.util.concurrent.*;</p>
<p>import java.io.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Sender implements Runnable { private Random rand = new Random(47); private PipedWriter out = new PipedWriter(); public PipedWriter getPipedWriter() { return out; } public void run() { try {</p>
<p>while(true)</p>
<p>for(char c = ‘A’; c &lt;= ‘z’; c++) { out.write(c);</p>
<p>TimeUnit.MILLISECONDS.sleep(rand.nextInt(500));</p>
<p>}</p>
<p>} catch(IOException e) {</p>
<p>print(e + &quot; Sender write exception&quot;);</p>
<p>} catch(InterruptedException e) {</p>
<p>print(e + &quot; Sender sleep interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class Receiver implements Runnable { private PipedReader in;</p>
<p>public Receiver(Sender sender) throws IOException { in = new PipedReader(sender.getPipedWriter());</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(true) {</p>
<p>// Blocks until characters are there: printnb(&quot;Read: &quot; + (char)in.read() + &quot;, &quot;);</p>
<p>}</p>
<p>} catch(IOException e) {</p>
<p>print(e + &quot; Receiver read exception&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class PipedIO {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>Sender sender = new Sender();</p>
<p>Receiver receiver = new Receiver(sender);</p>
<p>ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>exec.execute(sender);</p>
<p>exec.execute(receiver);</p>
<p>TimeUnit.SECONDS.sleep(4);</p>
<p>exec.shutdownNow();</p>
<p>}</p>
<p>} /* Output: (65% match)</p>
<p>Read: A, Read: B, Read: C, Read: D, Read: E, Read: F, Read: G, Read: H, Read: I, Read: J, Read: K, Read: L, Read: M,</p>
<p>java.lang.InterruptedException: sleep interrupted Sender sleep interrupted</p>
<p>java.io.InterruptedIOException Receiver read exception *///:~</p>
<p>Sender and Receiver represent tasks that need to communicate with each other. Sender creates a PipedWriter, which is a standalone object, but inside Receiver the creation of PipedReader must be associated with a PipedWriter in the constructor. The Sender puts data into the Writer and sleeps for a random amount of time. However, Receiver has no sleep( ) or wait( ). But when it does a read( ), the pipe automatically blocks when there is no more data.</p>
<p>Notice that the sender and receiver are started in main( ), after the objects are completely constructed. If you don’t start completely constructed objects, the pipe can produce inconsistent behavior on different platforms. (Note that BlockingQueues are more robust and easier to use.)</p>
<p>An important difference between a PipedReader and normal I/O is seen when shutdownNow( ) is called—the PipedReader is interruptible, whereas if you changed, for example, the in.read( ) call to System.in.read( ), the interrupt( ) would fail to break out of the read( ) call.</p>
<p>Exercise 30: (1) Modify PipedIO.java to use a BlockingQueue instead of a pipe.</p>
</section>
<section>
<title>
<p>Deadlock</p></title><empty-line/>
<p>Now you understand an object can have synchronized methods or other forms of locking that prevent tasks from accessing that object until the mutex is released. You’ve also learned that tasks can become blocked. Thus it’s possible for one task to get stuck waiting for another task, which in turn waits for another task, and so on, until the chain leads back to a task waiting on the first one. You get a continuous loop of tasks waiting on each other, and no one can move. This is called deadlock.<a l:href="#bookmark127" type="note"><sup>128</sup></a><sup></sup></p>
<p>If you try running a program and it deadlocks right away, you can immediately track down the bug. The real problem is when your program seems to be working fine but has the hidden potential to deadlock. In this case, you may get no indication that deadlocking is a possibility, so the flaw will be latent in your program until it unexpectedly happens to a customer (in a way that will almost certainly be difficult to reproduce). Thus, preventing deadlock through careful program design is a critical part of developing concurrent systems.</p>
<p>The dining philosophers problem, invented by Edsger Dijkstra, is the classic demonstration of deadlock. The basic description specifies five philosophers (but the example shown here will allow any number). These philosophers spend part of their time thinking and part of their time eating. While they are thinking, they don’t need any shared resources, but they eat using a limited number of utensils. In the original problem description, the utensils are forks, and two forks are required to get spaghetti from a bowl in the middle of the table, but it seems to make more sense to say that the utensils are chopsticks. Clearly, each philosopher will require two chopsticks in order to eat.</p>
<p>A difficulty is introduced into the problem: As philosophers, they have very little money, so they can only afford five chopsticks (more generally, the same number of chopsticks as philosophers). These are spaced around the table between them. When a philosopher wants to eat, that philosopher must pick up the chopstick to the left and the one to the right. If the philosopher on either side is using a desired chopstick, our philosopher must wait until the necessary chopsticks become available.</p>
<p>//: concurrency/Chopstick.java // Chopsticks for dining philosophers.</p>
<p>public class Chopstick {</p>
<p>private boolean taken = false; public synchronized</p>
<p>void take() throws InterruptedException {</p>
<p>while(taken) wait(); taken = true;</p>
<p>public synchronized void drop() { taken = false; notifyAll();</p>
<p>}</p>
<p>} ///:~</p>
<p>No two Philosophers can successfully take( ) the same Chopstick at the same time. In addition, if the Chopstick has already been taken by one Philosopher, another can wait( ) until the Chopstick becomes available when the current holder calls drop( ).</p>
<p>When a Philosopher task calls take( ), that Philosopher waits until the taken flag is false (until the Philosopher currently holding the Chopstick releases it). Then the task sets the taken flag to true to indicate that the new Philosopher now holds the Chopstick. When this Philosopher is finished with the Chopstick, it calls drop( ) to change the flag and notifyAll( ) any other Philosophers that may be wait( )ing for the Chopstick.</p>
<p>//: concurrency/Philosopher.java // A dining philosopher import java.util.concurrent.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class Philosopher implements Runnable { private Chopstick left; private Chopstick right; private final int id; private final int ponderFactor; private Random rand = new Random(47); private void pause() throws InterruptedException { if(ponderFactor == 0) return;</p>
<p>TimeUnit.MILLISECONDS.sleep(</p>
<p>rand.nextInt(ponderFactor * 250));</p>
<p>}</p>
<p>public Philosopher(Chopstick left, Chopstick right, int ident, int ponder) { this.left = left; this.right = right; id = ident;</p>
<p>ponderFactor = ponder;</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted()) { print(this + &quot; &quot; + &quot;thinking&quot;); pause();</p>
<p>// Philosopher becomes hungry print(this + &quot; &quot; + &quot;grabbing right&quot;); right.take();</p>
<p>print(this + &quot; &quot; + &quot;grabbing left&quot;); left.take();</p>
<p>print(this + &quot; &quot; + &quot;eating&quot;);</p>
<p>pause();</p>
<p>right.drop();</p>
<p>left.drop();</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>print(this + &quot; &quot; + &quot;exiting via interrupt&quot;);</p>
<p>}</p>
<p>public String toString() { return &quot;Philosopher &quot; + id; }</p>
<p>} ///:~</p>
<p>In Philosopher.run( ), each Philosopher just thinks and eats continuously. The pause( ) method sleeps( ) for a random period if the ponderFactor is nonzero. Using this, you see the Philosopher thinking for a randomized amount of time, then trying to take( ) the right and left Chopsticks, eating for a randomized amount of time, and then doing it again.</p>
<p>Now we can set up a version of the program that will deadlock:</p>
<p>//: concurrency/DeadlockingDiningPhilosophers.java // Demonstrates how deadlock can be hidden in a program.</p>
<p>// {Args: 0 5 timeout} import java.util.concurrent.*;</p>
<p>public class DeadlockingDiningPhilosophers {</p>
<p>public static void main(String[] args) throws Exception { int ponder = 5; if(args.length &gt; 0)</p>
<p>ponder = Integer.parseInt(args[0]); int size = 5; if(args.length &gt; 1)</p>
<p>size = Integer.parseInt(args[1]);</p>
<p>ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>Chopstick[] sticks = new Chopstick[size]; for(int i = 0; i &lt; size; i++) sticks[i] = new Chopstick(); for(int i = 0; i &lt; size; i++) exec.execute(new Philosopher(</p>
<p>sticks[i], sticks[(i+1) % size], i, ponder)); if(args.length == 3 &amp;&amp; args[2].equals(&quot;timeout&quot;)) TimeUnit.SECONDS.sleep(5); else {</p>
<p>System.out.println(&quot;Press ‘Enter’ to quit&quot;);</p>
<p>System.in.read();</p>
<p>}</p>
<p>exec.shutdownNow();</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>You will observe that if the Philosophers spend very little time thinking, they will all be competing for the Chopsticks while they try to eat, and deadlock will happen much more quickly.</p>
<p>The first command-line argument adjusts the ponder factor, to affect the amount of time each Philosopher spends thinking. If you have lots of Philosophers or they spend a lot of time thinking, you may never see deadlock even though it remains a possibility. A commandline argument of zero tends to make the program deadlock fairly quickly.</p>
<p>Note that the Chopstick objects do not need internal identifiers; they are identified by their position in the array sticks. Each Philosopher constructor is given a reference to a left and right Chopstick object. Every Philosopher except the last one is initialized by situating that Philosopher between the next pair of Chopstick objects. The last Philosopher is given the zeroth Chopstick for its right Chopstick, so the round table is completed. That’s because the last Philosopher is sitting right next to the first one, and they both share that zeroth Chopstick. Now it’s possible for all the Philosophers to be trying to eat, waiting on the Philosopher next to them to put down its Chopstick. This will make the program deadlock.</p>
<p>If your Philosophers are spending more time thinking than eating, then they have a much lower probability of requiring the shared resources (Chopsticks), and thus you can convince yourself that the program is deadlock free (using a nonzero ponder value, or a large number of Philosophers), even though it isn’t. This example is interesting precisely because it demonstrates that a program can appear to run correctly but actually be able to deadlock.</p>
<p>To repair the problem, you must understand that deadlock can occur if four conditions are simultaneously met:</p>
<p>1.    Mutual exclusion. At least one resource used by the tasks must not be shareable. In this case, a Chopstick can be used by only one Philosopher at a time.</p>
<p>2.    At least one task must be holding a resource and waiting to acquire a resource currently held by another task. That is, for deadlock to occur, a Philosopher must be holding one Chopstick and waiting for another one.</p>
<p>3.    A resource cannot be preemptively taken away from a task. Tasks only release resources as a normal event. Our Philosophers are polite and they don’t grab Chopsticks from other Philosophers.</p>
<p>4.    A circular wait can happen, whereby a task waits on a resource held by another task, which in turn is waiting on a resource held by another task, and so on, until one of the tasks is waiting on a resource held by the first task, thus gridlocking everything. In DeadlockingDiningPhilosophers.java, the circular wait happens because each Philosopher tries to get the right Chopstick first and then the left.</p>
<p>Because all these conditions must be met to cause deadlock, you only need to prevent one of them from occurring to prohibit deadlock. In this program, the easiest way to prevent deadlock is to break the fourth condition. This condition happens because each Philosopher is trying to pick up its Chopsticks in a particular sequence: first right, then left. Because of that, it’s possible to get into a situation where each of them is holding its right Chopstick and waiting to get the left, causing the circular wait condition. However, if the last Philosopher is initialized to try to get the left chopstick first and then the right, that Philosopher will never prevent the Philosopher on the immediate right from picking up their its chopstick. In this case, the circular wait is prevented. This is only one solution to the problem, but you could also solve it by preventing one of the other conditions (see advanced threading books for more details):</p>
<p>//: concurrency/FixedDiningPhilosophers.java // Dining philosophers without deadlock.</p>
<p>// {Args: 5 5 timeout} import java.util.concurrent.*;</p>
<p>public class FixedDiningPhilosophers {</p>
<p>public static void main(String[] args) throws Exception { int ponder = 5; if(args.length &gt; 0)</p>
<p>ponder = Integer.parseInt(args[0]); int size = 5; if(args.length &gt; 1)</p>
<p>size = Integer.parseInt(args[1]);</p>
<p>ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>Chopstick[] sticks = new Chopstick[size]; for(int i = 0; i &lt; size; i++) sticks[i] = new Chopstick(); for(int i = 0; i &lt; size; i++) if(i &lt; (size-1))</p>
<p>exec.execute(new Philosopher(</p>
<p>sticks[i], sticks[i+1], i, ponder));</p>
<p>else</p>
<p>exec.execute(new Philosopher(</p>
<p>sticks[0], sticks[i], i, ponder)); if(args.length == 3 &amp;&amp; args[2].equals(&quot;timeout&quot;)) TimeUnit.SECONDS.sleep(5); else {</p>
<p>System.out.println(&quot;Press ‘Enter’ to quit&quot;);</p>
<p>System.in.read();</p>
<p>}</p>
<p>exec.shutdownNow();</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>By ensuring that the last Philosopher picks up and puts down the left Chopstick before the right, we remove the deadlock, and the program will run smoothly.</p>
<p>There is no language support to help prevent deadlock; it’s up to you to avoid it by careful design. These are not comforting words to the person who’s trying to debug a deadlocking program.</p>
<p>Exercise 31: (8) Change DeadlockingDiningPhilosophers.java so that when a philosopher is done with its chopsticks, it drops them into a bin. When a philosopher wants to eat, it takes the next two available chopsticks from the bin. Does this eliminate the possibility of deadlock? Can you reintroduce deadlock by simply reducing the number of available chopsticks?</p>
</section>
<section>
<title>
<p>New library components</p></title><empty-line/>
<p>The java.util.concurrent library in Java SE5 introduces a significant number of new classes designed to solve concurrency problems. Learning to use these can help you produce simpler and more robust concurrent programs.</p>
<p>This section includes a representative set of examples of various components, but a few of the components—ones that you may be less likely to use and encounter—are not discussed here.</p>
<p>Because these components solve various problems, there is no clear way to organize them, so I shall attempt to start with simpler examples and proceed through examples of increasing complexity.</p>
<subtitle>CountDownLatch</subtitle>
<p>This is used to synchronize one or more tasks by forcing them to wait for the completion of a set of operations being performed by other tasks.</p>
<p>You give an initial count to a CountDownLatch object, and any task that calls await( ) on that object will block until the count reaches zero. Other tasks may call countDown( ) on the object to reduce the count, presumably when a task finishes its job. A CountDownLatch is designed to be used in a one-shot fashion; the count cannot be reset.</p>
<p>If you need a version that resets the count, you can use a CyclicBarrier instead.</p>
<p>The tasks that call countDown( ) are not blocked when they make that call. Only the call to await( ) is blocked until the count reaches zero.</p>
<p>A typical use is to divide a problem into n independently solvable tasks and create a CountDownLatch with a value of n. When each task is finished it calls countDown( ) on the latch. Tasks waiting for the problem to be solved call await( ) on the latch to hold themselves back until it is completed. Here’s a skeleton example that demonstrates this technique:</p>
<p>//: concurrency/CountDownLatchDemo.java import java.util.concurrent.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>// Performs some portion of a task: class TaskPortion implements Runnable { private static int counter = 0; private final int id = counter++; private static Random rand = new Random(47); private final CountDownLatch latch;</p>
<p>TaskPortion(CountDownLatch latch) { this.latch = latch;</p>
<p>}</p>
<p>public void run() { try {</p>
<p>doWork();</p>
<p>latch.countDown();</p>
<p>} catch(InterruptedException ex) {</p>
<p>// Acceptable way to exit</p>
<p>}</p>
<p>}</p>
<p>public void doWork() throws InterruptedException { TimeUnit.MILLISECONDS.sleep(rand.nextInt(2000));</p>
<p>print(this + &quot;completed&quot;);</p>
<p>public String toString() {</p>
<p>return String.format(&quot;%1$-3d &quot;, id);</p>
<p>}</p>
<p>}</p>
<p>// Waits on the CountDownLatch: class WaitingTask implements Runnable { private static int counter = 0; private final int id = counter++; private final CountDownLatch latch;</p>
<p>WaitingTask(CountDownLatch latch) { this.latch = latch;</p>
<p>}</p>
<p>public void run() { try {</p>
<p>latch.await();</p>
<p>print(&quot;Latch barrier passed for &quot; + this);</p>
<p>} catch(InterruptedException ex) { print(this + &quot; interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>public String toString() {</p>
<p>return String.format(&quot;WaitingTask %1$-3d &quot;, id);</p>
<p>}</p>
<p>}</p>
<p>public class CountDownLatchDemo { static final int SIZE = 100;</p>
<p>public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>// All must share a single CountDownLatch object:</p>
<p>CountDownLatch latch = new CountDownLatch(SIZE); for(int i = 0; i &lt; 10; i++)</p>
<p>exec.execute(new WaitingTask(latch)); for(int i = 0; i &lt; SIZE; i++)</p>
<p>exec.execute(new TaskPortion(latch)); print(&quot;Launched all tasks&quot;);</p>
<p>exec.shutdown(); // Quit when all tasks complete</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>TaskPortion sleeps for a random period to simulate the completion of part of the task, and WaitingTask indicates a part of the system that must wait until the initial portion of the problem is complete. All tasks work with the same single CountDownLatch, which is defined in main( ).</p>
<p>Exercise 32: (7) Use a CountDownLatch to solve the problem of correlating the results from the Entrances in OrnamentalGarden.java. Remove the unnecessary code from the new version of the example.</p>
<p>Library thread safety</p>
<p>Notice that TaskPortion contains a static Random object, which means that multiple tasks may be calling Random.nextInt( ) at the same time. Is this safe?</p>
<p>If there is a problem, it can be solved in this case by giving TaskPortion its own Random object—that is, by removing the static specifier. But the question remains for Java standard library methods in general: Which ones are thread-safe and which ones aren’t?</p>
<p>Unfortunately, the JDK documentation is not forthcoming on this point. It happens that Random.nextInt( ) is thread-safe, but alas, you shall have to discover this on a case-bycase basis, using either a Web search or by inspecting the Java library code. This is not a particularly good situation for a programming language that was, at least in theory, designed to support concurrency.</p>
<subtitle>CyclicBarrier</subtitle>
<p>A CyclicBarrier is used in situations where you want to create a group of tasks to perform work in parallel, and then wait until they are all finished before moving on to the next step (something like join( ), it would seem). It brings all the parallel tasks into alignment at the barrier so you can move forward in unison. This is very similar to the CountDownLatch, except that a CountDownLatch is a one-shot event, whereas a CyclicBarrier can be reused over and over.</p>
<p>I’ve been fascinated with simulations from the beginning of my experience with computers, and concurrency is a key factor of making simulations possible. The very first program that I can remember writing<a l:href="#bookmark128" type="note"><sup>129</sup></a><sup></sup> was a simulation: a horse-racing game written in BASIC called (because of the file name limitations) HOSRAC.BAS. Here is the object-oriented, threaded version of that program, utilizing a CyclicBarrier:</p>
<p>//: concurrency/HorseRace.java // Using CyclicBarriers. import java.util.concurrent.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Horse implements Runnable { private static int counter = 0; private final int id = counter++; private int strides = 0;</p>
<p>private static Random rand = new Random(47); private static CyclicBarrier barrier; public Horse(CyclicBarrier b) { barrier = b; } public synchronized int getStrides() { return strides; } public void run() { try {</p>
<p>while(!Thread.interrupted()) { synchronized(this) {</p>
<p>strides += rand.nextInt(3); // Produces 0, 1 or 2</p>
<p>}</p>
<p>barrier.await();</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>// A legitimate way to exit } catch(BrokenBarrierException e) {</p>
<p>// This one we want to know about throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>public String toString() { return &quot;Horse &quot; + id + &quot; &quot;; } public String tracks() {</p>
<p>StringBuilder s = new StringBuilder(); for(int i = 0; i &lt; getStrides(); i++) s.append(&quot;*&quot;); s.append(id); return s.toString();</p>
<p>public class HorseRace {</p>
<p>static final int FINISH_LINE = 75;</p>
<p>private List&lt;Horse&gt; horses = new ArrayList&lt;Horse&gt;(); private ExecutorService exec =</p>
<p>Executors.newCachedThreadPool(); private CyclicBarrier barrier;</p>
<p>public HorseRace(int nHorses, final int pause) {</p>
<p>barrier = new CyclicBarrier(nHorses, new Runnable() { public void run() {</p>
<p>StringBuilder s = new StringBuilder();</p>
<p>for(int i = 0; i &lt; FINISH_LINE; i++)</p>
<p>s.append(&quot;=&quot;); // The fence on the racetrack print(s);</p>
<p>for(Horse horse : horses) print(horse.tracks()); for(Horse horse : horses)</p>
<p>if(horse.getStrides() &gt;= FINISH_LINE) {</p>
<p>print(horse + &quot;won!&quot;);</p>
<p>exec.shutdownNow();</p>
<p>return;</p>
<p>}</p>
<p>try {</p>
<p>TimeUnit.MILLISECONDS.sleep(pause);</p>
<p>} catch(InterruptedException e) {</p>
<p>print(&quot;barrier-action sleep interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>});</p>
<p>for(int i = 0; i &lt; nHorses; i++) {</p>
<p>Horse horse = new Horse(barrier);</p>
<p>horses.add(horse);</p>
<p>exec.execute(horse);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) { int nHorses = 7; int pause = 200;</p>
<p>if(args.length &gt; 0) { // Optional argument int n = new Integer(args[0]); nHorses = n &gt; 0 ? n : nHorses;</p>
<p>}</p>
<p>if(args.length &gt; 1) { // Optional argument int p = new Integer(args[1]); pause = p &gt; -1 ? p : pause;</p>
<p>}</p>
<p>new HorseRace(nHorses, pause);</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>A CyclicBarrier can be given a &quot;barrier action,&quot; which is a Runnable that is automatically executed when the count reaches zero—this is another distinction between CyclicBarrier and CountdownLatch. Here, the barrier action is created as an anonymous class that is handed to the constructor of CyclicBarrier. <a l:href="#bookmark129" type="note"><sup>130</sup></a><sup></sup></p>
<p>Once all the tasks have passed the barrier, it is automatically ready for the next round.</p>
<p>To give it the effect of very simple animation, make the size of your console window small enough so that only the horses show.</p>
<subtitle>DelayQueue</subtitle>
<p>This is an unbounded BlockingQueue of objects that implement the Delayed interface. An object can only be taken from the queue when its delay has expired. The queue is sorted so that the object at the head has a delay that has expired for the longest time. If no delay has expired, then there is no head element and poll( ) will return null (because of this, you cannot place null elements in the queue).</p>
<p>Here’s an example where the Delayed objects are themselves tasks, and the DelayedTaskConsumer takes the most &quot;urgent&quot; task (the one that has been expired for the longest time) off the queue and runs it. Note that DelayQueue is thus a variation of a priority queue.</p>
<p>//: concurrency/DelayQueueDemo.java import java.util.concurrent.*; import java.util.*;</p>
<p>import static java.util.concurrent.TimeUnit.*; import static net.mindview.util.Print.*;</p>
<p>class DelayedTask implements Runnable, Delayed { private static int counter = 0; private final int id = counter++; private final int delta; private final long trigger;</p>
<p>protected static List&lt;DelayedTask&gt; sequence = new ArrayList&lt;DelayedTask&gt;(); public DelayedTask(int delayInMilliseconds) { delta = delayInMilliseconds; trigger = System.nanoTime() +</p>
<p>NANOSECONDS.convert(delta, MILLISECONDS); sequence.add(this);</p>
<p>}</p>
<p>public long getDelay(TimeUnit unit) { return unit.convert(</p>
<p>trigger - System.nanoTime(), NANOSECONDS);</p>
<p>}</p>
<p>public int compareTo(Delayed arg) {</p>
<p>DelayedTask that = (DelayedTask)arg; if(trigger &lt; that.trigger) return -1; if(trigger &gt; that.trigger) return 1; return 0;</p>
<p>}</p>
<p>public void run() { printnb(this + &quot; &quot;); } public String toString() {</p>
<p>return String.format(&quot;[%1$-4d]&quot;, delta) +</p>
<p>&quot; Task &quot; + id;</p>
<p>}</p>
<p>public String summary() {</p>
<p>return &quot;(&quot; + id + &quot;:&quot; + delta + &quot;)&quot;;</p>
<p>}</p>
<p>public static class EndSentinel extends DelayedTask { private ExecutorService exec;</p>
<p>public EndSentinel(int delay, ExecutorService e) { super(delay); exec = e;</p>
<p>public void run() {</p>
<p>for(DelayedTask pt : sequence) { printnb(pt.summary() + &quot; &quot;);</p>
<p>}</p>
<p>print();</p>
<p>print(this + &quot; Calling shutdownNow()&quot;); exec.shutdownNow();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class DelayedTaskConsumer implements Runnable { private DelayQueue&lt;DelayedTask&gt; q;</p>
<p>public DelayedTaskConsumer(DelayQueue&lt;DelayedTask&gt; q) { this.q = q;</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted())</p>
<p>q.take().run(); // Run task with the current thread } catch(InterruptedException e) {</p>
<p>// Acceptable way to exit</p>
<p>}</p>
<p>print(&quot;Finished DelayedTaskConsumer&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class DelayQueueDemo {</p>
<p>public static void main(String[] args) {</p>
<p>Random rand = new Random(47);</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); DelayQueue&lt;DelayedTask&gt; queue = new DelayQueue&lt;DelayedTask&gt;();</p>
<p>// Fill with tasks that have random delays: for(int i = 0; i &lt; 20; i++)</p>
<p>queue.put(new DelayedTask(rand.nextInt(5000)));</p>
<p>// Set the stopping point</p>
<p>queue.add(new DelayedTask.EndSentinel(5000, exec)); exec.execute(new DelayedTaskConsumer(queue));</p>
<p>}</p>
<p>} /* Output:</p>
<p>[128 ]    Task    11 [200 ] Task 7    [429 ]    Task    5 [520 ] Task 18 [555 ]    Task 1</p>
<p>[961 ]    Task    4 [998 ] Task 16    [1207]    Task    9 [1693] Task 2 [1809] Task 14</p>
<p>[1861]    Task    3 [2278] Task 15    [3288]    Task    10 [3551] Task 12 [4258]    Task 0</p>
<p>[4258]    Task    19 [4522] Task 8    [4589]    Task    13 [4861] Task 17 [4868]    Task 6</p>
<p>(0:4258) (1:555) (2:1693) (3:1861) (4:961) (5:429) (6:4868) (7:200) (8:4522) (9:1207) (10:3288) (11:128) (12:3551) (13:4589) (14:1809) (15:2278) (16:998) (17:4861) (18:520) (19:4258) (20:5000)</p>
<p>[5000] Task 20 Calling shutdownNow()</p>
<p>Finished DelayedTaskConsumer *///:~</p>
<p>DelayedTask contains a List&lt;DelayedTask&gt; called sequence that preserves the order in which the tasks were created, so that we can see that sorting does in fact take place.</p>
<p>The Delayed interface has one method, getDelay( ), which tells how long it is until the delay time expires or how long ago the delay time has expired. This method forces us to use the TimeUnit class because that’s the argument type. This turns out to be a very convenient class because you can easily convert units without doing any calculations. For example, the value of delta is stored in milliseconds, but the Java SE5 method System.nanoTime( )</p>
<p>produces time in nanoseconds. You can convert the value of delta by saying what units it is in and what units you want it to be in, like this:</p>
<p>NANOSECONDS.convert(delta, MILLISECONDS);</p>
<p>In getDelay( ), the desired units are passed in as the unit argument, and you use this to convert the time difference from the trigger time to the units requested by the caller, without even knowing what those units are (this is a simple example of the Strategy design pattern, where part of the algorithm is passed in as an argument).</p>
<p>For sorting, the Delayed interface also inherits the Comparable interface, so compareTo( ) must be implemented so that it produces a reasonable comparison. toString( ) and summary( ) provide output formatting, and the nested EndSentinel class provides a way to shut everything down by placing it as the last element in the queue.</p>
<p>Note that because DelayedTaskConsumer is itself a task, it has its own Thread which it can use to run each task that comes out of the queue. Since the tasks are being performed in queue priority order, there’s no need in this example to start separate threads to run the DelayedTasks.</p>
<p>You can see from the output that the order in which the tasks are created has no effect on execution order—instead, the tasks are executed in delay order as expected.</p>
<subtitle>PriorityBlockingQueue</subtitle>
<p>This is basically a priority queue that has blocking retrieval operations. Here’s an example where the objects in the priority queue are tasks that emerge from the queue in priority order. A PrioritizedTask is given a priority number to provide this order:</p>
<p>//: concurrency/PriorityBlockingQueueDemo.java import java.util.concurrent.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class PrioritizedTask implements Runnable, Comparable&lt;PrioritizedTask&gt; { private Random rand = new Random(47); private static int counter = 0; private final int id = counter++; private final int priority;</p>
<p>protected static List&lt;PrioritizedTask&gt; sequence = new ArrayList&lt;PrioritizedTask&gt;(); public PrioritizedTask(int priority) { this.priority = priority; sequence.add(this);</p>
<p>}</p>
<p>public int compareTo(PrioritizedTask arg) { return priority &lt; arg.priority ? 1 :</p>
<p>(priority &gt; arg.priority ? -1 : 0);</p>
<p>}</p>
<p>public void run() { try {</p>
<p>TimeUnit.MILLISECONDS.sleep(rand.nextInt(250));</p>
<p>} catch(InterruptedException e) {</p>
<p>// Acceptable way to exit</p>
<p>}</p>
<p>print(this);</p>
<p>}</p>
<p>public String toString() {</p>
<p>return String.format(&quot;[%1$-3d]&quot;, priority) +</p>
<p>&quot; Task &quot; + id;</p>
<p>public String summary() {</p>
<p>return &quot;(&quot; + id + &quot;:&quot; + priority + &quot;)&quot;;</p>
<p>}</p>
<p>public static class EndSentinel extends PrioritizedTask { private ExecutorService exec; public EndSentinel(ExecutorService e) {</p>
<p>super(-l); // Lowest priority in this program exec = e;</p>
<p>}</p>
<p>public void run() { int count = 0;</p>
<p>for(PrioritizedTask pt : sequence) { printnb(pt.summary()); if(++count % 5 == 0) print();</p>
<p>}</p>
<p>print();</p>
<p>print(this + &quot; Calling shutdownNow()&quot;); exec.shutdownNow();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class PrioritizedTaskProducer implements Runnable { private Random rand = new Random(47); private Queue&lt;Runnable&gt; queue; private ExecutorService exec; public PrioritizedTaskProducer(</p>
<p>Queue&lt;Runnable&gt; q, ExecutorService e) { queue = q;</p>
<p>exec = e; // Used for EndSentinel</p>
<p>}</p>
<p>public void run() {</p>
<p>// Unbounded queue; never blocks.</p>
<p>// Fill it up fast with random priorities: for(int i = 0; i &lt; 20; i++) {</p>
<p>queue.add(new PrioritizedTask(rand.nextInt(10))); Thread.yield();</p>
<p>}</p>
<p>// Trickle in highest-priority jobs: try {</p>
<p>for(int i = 0; i &lt; 10; i++) {</p>
<p>TimeUnit.MILLISECONDS.sleep(250); queue.add(new PrioritizedTask(10));</p>
<p>}</p>
<p>// Add jobs, lowest priority first: for(int i = 0; i &lt; 10; i++)</p>
<p>queue.add(new PrioritizedTask(i));</p>
<p>// A sentinel to stop all the tasks: queue.add(new PrioritizedTask.EndSentinel(exec));</p>
<p>} catch(InterruptedException e) {</p>
<p>// Acceptable way to exit</p>
<p>}</p>
<p>print(&quot;Finished PrioritizedTaskProducer&quot;);</p>
<p>}</p>
<p>}</p>
<p>class PrioritizedTaskConsumer implements Runnable { private PriorityBlockingQueue&lt;Runnable&gt; q; public PrioritizedTaskConsumer(</p>
<p>PriorityBlockingQueue&lt;Runnable&gt; q) { this.q = q;</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted())</p>
<p>// Use current thread to run the task: q.take().run();</p>
<p>} catch(InterruptedException e) {</p>
<p>// Acceptable way to exit</p>
<p>}</p>
<p>print(&quot;Finished PrioritizedTaskConsumer&quot;);</p>
<p>}</p>
<p>}</p>
<p>public class PriorityBlockingQueueDemo {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>Random rand = new Random(47);</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); PriorityBlockingQueue&lt;Runnable&gt; queue = new PriorityBlockingQueue&lt;Runnable&gt;(); exec.execute(new PrioritizedTaskProducer(queue, exec)); exec.execute(new PrioritizedTaskConsumer(queue));</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>As with the previous example, the creation sequence of the PrioritizedTask objects is remembered in the sequence List, for comparison with the actual order of execution. The run( ) method sleeps for a short random time and prints the object information, and the EndSentinel provides the same functionality as before while guaranteeing that it is the last object in the queue.</p>
<p>The PrioritizedTaskProducer and PrioritizedTaskConsumer connect to each other through a PriorityBlockingQueue. Because the blocking nature of the queue provides all the necessary synchronization, notice that no explicit synchronization is necessary—you don’t have to think about whether the queue has any elements in it when you’re reading from it, because the queue will simply block the reader when it is out of elements.</p>
<subtitle>The greenhouse controller with ScheduledExecutor</subtitle>
<p>The Inner Classes chapter introduced the example of a control system applied to a hypothetical greenhouse, turning various facilities on or off or otherwise adjusting them. This can be seen as a kind of concurrency problem, with each desired greenhouse event as a task that is run at a predefined time. The ScheduledThreadPoolExecutor provides just the service necessary to solve the problem. Using either schedule( ) (to run a task once) or scheduleAtFixedRate( ) (to repeat a task at a regular interval), you set up Runnable objects to be executed at some time in the future. Compare the following with the approach used in the Inner Classes chapter to notice how much simpler it is when you can use a predefined tool like ScheduledThreadPoolExecutor:</p>
<p>//: concurrency/GreenhouseScheduler.java // Rewriting innerclasses/GreenhouseController.java // to use a ScheduledThreadPoolExecutor.</p>
<p>// {Args: 5000}</p>
<p>import java.util.concurrent.*; import java.util.*;</p>
<p>public class GreenhouseScheduler {</p>
<p>private volatile boolean light = false; private volatile boolean water = false; private String thermostat = &quot;Day&quot;; public synchronized String getThermostat() { return thermostat;</p>
<p>}</p>
<p>public synchronized void setThermostat(String value) { thermostat = value;</p>
<p>}</p>
<p>ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(10); public void schedule(Runnable event, long delay) {</p>
<p>scheduler.schedule(event,delay,TimeUnit.MILLISECONDS);</p>
<p>}</p>
<p>public void</p>
<p>repeat(Runnable event, long initialDelay, long period) { scheduler.scheduleAtFixedRate(</p>
<p>event, initialDelay, period, TimeUnit.MILLISECONDS);</p>
<p>}</p>
<p>class LightOn implements Runnable { public void run() {</p>
<p>// Put hardware control code here to // physically turn on the light. System.out.println(&quot;Turning on lights&quot;); light = true;</p>
<p>}</p>
<p>}</p>
<p>class LightOff implements Runnable { public void run() {</p>
<p>// Put hardware control code here to // physically turn off the light. System.out.println(&quot;Turning off lights&quot;); light = false;</p>
<p>}</p>
<p>}</p>
<p>class WaterOn implements Runnable { public void run() {</p>
<p>// Put hardware control code here. System.out.println(&quot;Turning greenhouse water on&quot;); water = true;</p>
<p>}</p>
<p>}</p>
<p>class WaterOff implements Runnable { public void run() {</p>
<p>// Put hardware control code here. System.out.println(&quot;Turning greenhouse water off&quot;); water = false;</p>
<p>}</p>
<p>}</p>
<p>class ThermostatNight implements Runnable { public void run() {</p>
<p>// Put hardware control code here. System.out.println(&quot;Thermostat to night setting&quot;); setThermostat(&quot;Night&quot;);</p>
<p>}</p>
<p>}</p>
<p>class ThermostatDay implements Runnable { public void run() {</p>
<p>// Put hardware control code here. System.out.println(&quot;Thermostat to day setting&quot;); setThermostat(&quot;Day&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class Terminate implements Runnable { public void run() {</p>
<p>System.out.println(&quot;Terminating&quot;);</p>
<p>scheduler.shutdownNow();</p>
<p>// Must start a separate task to do this job,</p>
<p>// since the scheduler has been shut down: new Thread() {</p>
<p>public void run() {</p>
<p>for(DataPoint d : data)</p>
<p>System.out.println(d);</p>
<p>}</p>
<p>}.start();</p>
<p>}</p>
<p>}</p>
<p>// New feature: data collection static class DataPoint { final Calendar time; final float temperature; final float humidity;</p>
<p>public DataPoint(Calendar d, float temp, float hum) { time = d;</p>
<p>temperature = temp; humidity = hum;</p>
<p>}</p>
<p>public String toString() { return time.getTime() +</p>
<p>String.format(</p>
<p>&quot; temperature: %1$.1f humidity: %2$.2f&quot;, temperature, humidity);</p>
<p>}</p>
<p>}</p>
<p>private Calendar lastTime = Calendar.getInstance();</p>
<p>{ // Adjust date to the half hour lastTime.set(Calendar.MINUTE, 30); lastTime.set(Calendar.SECOND, 00);</p>
<p>}</p>
<p>private float lastTemp = 65.0f; private int tempDirection = +1; private float lastHumidity = 50.0f; private int humidityDirection = +1; private Random rand = new Random(47);</p>
<p>List&lt;DataPoint&gt; data = Collections.synchronizedList( new ArrayList&lt;DataPoint&gt;()); class CollectData implements Runnable { public void run() {</p>
<p>System.out.println(&quot;Collecting data&quot;); synchronized(GreenhouseScheduler.this) {</p>
<p>// Pretend the interval is longer than it is: lastTime.set(Calendar.MINUTE,</p>
<p>lastTime.get(Calendar.MINUTE) + 30);</p>
<p>// One in 5 chances of reversing the direction: if(rand.nextInt(5) == 4)</p>
<p>tempDirection = -tempDirection;</p>
<p>// Store previous value: lastTemp = lastTemp +</p>
<p>tempDirection * (1.0f + rand.nextFloat()); if(rand.nextInt(5) == 4)</p>
<p>humidityDirection = -humidityDirection; lastHumidity = lastHumidity +</p>
<p>humidityDirection * rand.nextFloat();</p>
<p>// Calendar must be cloned, otherwise all // DataPoints hold references to the same lastTime.</p>
<p>// For a basic object like Calendar, clone() is OK. data.add(new DataPoint((Calendar)lastTime.clone(), lastTemp, lastHumidity));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>GreenhouseScheduler gh = new GreenhouseScheduler(); gh.schedule(gh.new Terminate(), 5000);</p>
<p>// Former &quot;Restart&quot; class not necessary: gh.repeat(gh.new Bell(), 0, 1000); gh.repeat(gh.new ThermostatNight(), 0, 2000); gh.repeat(gh.new LightOn(), 0, 200); gh.repeat(gh.new LightOff(), 0, 400); gh.repeat(gh.new WaterOn(), 0, 600); gh.repeat(gh.new WaterOff(), 0, 800); gh.repeat(gh.new ThermostatDay(), 0, 1400); gh.repeat(gh.new CollectData(), 500, 500);</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>This version reorganizes the code and adds a new feature: collecting temperature and humidity readings in the greenhouse. A DataPoint holds and displays a single piece of data, while CollectData is the scheduled task that generates simulated data and adds it to the List&lt;DataPoint&gt; in Greenhouse each time it is run.</p>
<p>Notice the use of both volatile and synchronized in appropriate places to prevent tasks from interfering with each other. All the methods in the List that holds DataPoints are synchronized using the java.util.Collections utility synchronizedList( ) when the List is created.</p>
<p>Exercise 33: (7) Modify GreenhouseScheduler.java so that it uses a DelayQueue instead of a ScheduledExecutor.</p>
<subtitle>Semaphore</subtitle>
<p>A normal lock (from concurrent.locks or the built-in synchronized lock) only allows one task at a time to access a resource. A counting semaphore allows n tasks to access the resource at the same time. You can also think of a semaphore as handing out &quot;permits&quot; to use a resource, although no actual permit objects are used.</p>
<p>As an example, consider the concept of the object pool, which manages a limited number of objects by allowing them to be checked out for use, and then checked back in again when the user is finished. This functionality can be encapsulated in a generic class:</p>
<p>//: concurrency/Pool.java</p>
<p>// Using a Semaphore inside a Pool, to restrict // the number of tasks that can use a resource. import java.util.concurrent.*; import java.util.*;</p>
<p>public class Pool&lt;T&gt; { private int size;</p>
<p>private List&lt;T&gt; items = new ArrayList&lt;T&gt;(); private volatile boolean[] checkedOut; private Semaphore available; public Pool(Class&lt;T&gt; classObject, int size) {</p>
<p>this.size = size;</p>
<p>checkedOut = new boolean[size];</p>
<p>available = new Semaphore(size, true);</p>
<p>// Load pool with objects that can be checked out: for(int i = 0; i &lt; size; ++i) try {</p>
<p>// Assumes a default constructor: items.add(classObject.newInstance());</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>public T checkOut() throws InterruptedException { available.acquire(); return getItem();</p>
<p>}</p>
<p>public void checkIn(T x) { if(releaseItem(x)) available.release();</p>
<p>}</p>
<p>private synchronized T getItem() { for(int i = 0; i &lt; size; ++i) if(!checkedOut[i]) { checkedOut[i] = true; return items.get(i);</p>
<p>}</p>
<p>return null; // Semaphore prevents reaching here</p>
<p>}</p>
<p>private synchronized boolean releaseItem(T item) { int index = items.indexOf(item); if(index == -1) return false; // Not in the list if(checkedOut[index]) { checkedOut[index] = false; return true;</p>
<p>}</p>
<p>return false; // Wasn’t checked out</p>
<p>}</p>
<p>} ///:~</p>
<p>In this simplified form, the constructor uses newInstance( ) to load the pool with objects. If you need a new object, you call checkOut( ), and when you’re finished with an object, you hand it to checkIn( ).</p>
<p>The boolean checkedOut array keeps track of the objects that are checked out, and is managed by the getItem( ) and releaseItem( ) methods. These, in turn, are guarded by the Semaphore available, so that, in checkOut( ), available blocks the progress of the call if there are no more semaphore permits available (which means there are no more objects in the pool). In checkIn( ), if the object being checked in is valid, a permit is returned to the semaphore.</p>
<p>To create an example, we can use Fat, a type of object that is expensive to create because its constructor takes time to run:</p>
<p>//: concurrency/Fat.java</p>
<p>// Objects that are expensive to create.</p>
<p>public class Fat {</p>
<p>private volatile double d; // Prevent optimization private static int counter = 0; private final int id = counter++; public Fat() {</p>
<p>// Expensive, interruptible operation: for(int i = 1; i &lt; 10000; i++) {</p>
<p>d += (Math.PI + Math.E) / (double)i;</p>
<p>}</p>
<p>}</p>
<p>public void operation() { System.out.println(this); } public String toString() { return &quot;Fat id: &quot; + id; }</p>
<p>} ///:~</p>
<p>We’ll pool these objects to limit the impact of this constructor. We can test the Pool class by creating a task that will check out Fat objects, hold them for a while, and then check them back in:</p>
<p>//: concurrency/SemaphoreDemo.java // Testing the Pool class import java.util.concurrent.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>// A task to check a resource out of a pool: class CheckoutTask&lt;T&gt; implements Runnable { private static int counter = 0; private final int id = counter++; private Pool&lt;T&gt; pool; public CheckoutTask(Pool&lt;T&gt; pool) { this.pool = pool;</p>
<p>}</p>
<p>public void run() { try {</p>
<p>T item = pool.checkOut(); print(this + &quot;checked out &quot; + item);</p>
<p>TimeUnit.SECONDS.sleep(l); print(this +&quot;checking in &quot; + item); pool.checkln(item);</p>
<p>} catch(InterruptedException e) {</p>
<p>// Acceptable way to terminate</p>
<p>}</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;CheckoutTask &quot; + id + &quot; &quot;;</p>
<p>}</p>
<p>}</p>
<p>public class SemaphoreDemo { final static int SIZE = 25;</p>
<p>public static void main(String[] args) throws Exception { final Pool&lt;Fat&gt; pool =</p>
<p>new Pool&lt;Fat&gt;(Fat.class, SIZE);</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; SIZE; i++)</p>
<p>exec.execute(new CheckoutTask&lt;Fat&gt;(pool)); print(&quot;All CheckoutTasks created&quot;);</p>
<p>List&lt;Fat&gt; list = new ArrayList&lt;Fat&gt;(); for(int i = 0; i &lt; SIZE; i++) {</p>
<p>Fat f = pool.checkOut();</p>
<p>printnb(i + &quot;: main() thread checked out &quot;);</p>
<p>f.operation();</p>
<p>list.add(f);</p>
<p>}</p>
<p>Future&lt;?&gt; blocked = exec.submit(new Runnable() { public void run() { try {</p>
<p>// Semaphore prevents additional checkout,</p>
<p>// so call is blocked: pool.checkOut();</p>
<p>} catch(InterruptedException e) { print(&quot;checkOut() Interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>});</p>
<p>TimeUnit.SECONDS.sleep(2);</p>
<p>blocked.cancel(true); // Break out of blocked call print(&quot;Checking in objects in &quot; + list); for(Fat f : list) pool.checkln(f); for(Fat f : list)</p>
<p>pool.checkln(f); // Second checkin ignored exec.shutdown();</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>In main( ), a Pool is created to hold Fat objects, and a set of CheckoutTasks begins exercising the Pool. Then the main( ) thread begins checking out Fat objects, and not checking them back in. Once it has checked out all the objects in the pool, no more checkouts will be allowed by the Semaphore. The run( ) method of blocked is thus blocked, and after two seconds the cancel( ) method is called to break out of the Future. Note that redundant checkins are ignored by the Pool.</p>
<p>This example relies on the client of the Pool to be rigorous and to voluntarily check items back in, which is the simplest solution when it works. If you cannot always rely on this, Thinking in Patterns (at <a l:href="http://www.MindView.net">www.MindView.net</a>) contains further explorations of ways to manage the objects that have been checked out of object pools.</p>
<subtitle>Exchanger</subtitle>
<p>An Exchanger is a barrier that swaps objects between two tasks. When the tasks enter the barrier, they have one object, and when they leave, they have the object that was formerly held by the other task. Exchangers are typically used when one task is creating objects that are expensive to produce and another task is consuming those objects; this way, more objects can be created at the same time as they are being consumed.</p>
<p>To exercise the Exchanger class, we’ll create producer and consumer tasks which, via generics and Generators, will work with any kind of object, and then we’ll apply these to the Fat class. The ExchangerProducer and ExehangerConsumer use a List&lt;T&gt; as the object to be exchanged; each one contains an Exchanger for this List&lt;T&gt;. When you call the Exchanger.exchange( ) method, it blocks until the partner task calls its exchange( ) method, and when both exchange( ) methods have completed, the List&lt;T&gt; has been swapped:</p>
<p>//: concurrency/ExchangerDemo.java import java.util.concurrent.*; import java.util.*; import net.mindview.util.*;</p>
<p>class ExchangerProducer&lt;T&gt; implements Runnable { private Generator&lt;T&gt; generator; private Exchanger&lt;List&lt;T&gt;&gt; exchanger; private List&lt;T&gt; holder;</p>
<p>ExchangerProducer(Exchanger&lt;List&lt;T&gt;&gt; exchg,</p>
<p>Generator&lt;T&gt; gen, List&lt;T&gt; holder) { exchanger = exchg;</p>
<p>generator = gen; this.holder = holder;</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>for(int i = 0; i &lt; ExchangerDemo.size; i++) holder.add(generator.next());</p>
<p>// Exchange full for empty: holder = exchanger.exchange(holder);</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>// OK to terminate this way.</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class ExchangerConsumer&lt;T&gt; implements Runnable { private Exchanger&lt;List&lt;T&gt;&gt; exchanger; private List&lt;T&gt; holder; private volatile T value;</p>
<p>ExchangerConsumer(Exchanger&lt;List&lt;T&gt;&gt; ex, List&lt;T&gt; holder){ exchanger = ex; this.holder = holder;</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>holder = exchanger.exchange(holder); for(T x : holder) {</p>
<p>value = x; // Fetch out value</p>
<p>holder.remove(x); // OK for CopyOnWriteArrayList</p>
<p>}</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>// OK to terminate this way.</p>
<p>}</p>
<p>System.out.println(&quot;Final value: &quot; + value);</p>
<p>}</p>
<p>}</p>
<p>public class ExchangerDemo { static int size = 10; static int delay = 5; // Seconds</p>
<p>public static void main(String[] args) throws Exception { if(args.length &gt; 0)</p>
<p>size = new Integer(args[0]); if(args.length &gt; 1)</p>
<p>delay = new Integer(args[1]);</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); Exchanger&lt;List&lt;Fat&gt;&gt; xc = new Exchanger&lt;List&lt;Fat&gt;&gt;(); List&lt;Fat&gt;</p>
<p>producerList = new CopyOnWriteArrayList&lt;Fat&gt;(), consumerList = new CopyOnWriteArrayList&lt;Fat&gt;(); exec.execute(new ExchangerProducer&lt;Fat&gt;(xc,</p>
<p>BasicGenerator.create(Fat.class), producerList)); exec.execute(</p>
<p>new ExchangerConsumer&lt;Fat&gt;(xc,consumerList)); TimeUnit.SECONDS.sleep(delay); exec.shutdownNow();</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Final value: Fat id: 29999</p>
<p>In main( ), a single Exchanger is created for both tasks to use, and two CopyOnWriteArrayLists are created for swapping. This particular variant of List can tolerate the remove( ) method being called while the list is being traversed, without throwing a ConcurrentModificationException. The ExchangerProducer fills a List, then swaps the full list for the empty one that the ExchangerConsumer hands it. Because of the Exchanger, the filling of one list and consuming of the other list can happen simultaneously.</p>
<p>Exercise 34: (1) Modify ExchangerDemo.java to use your own class instead of Fat.</p>
</section>
<section>
<title>
<p>Simulation</p></title><empty-line/>
<p>One of the most interesting and exciting uses of concurrency is to create simulations. Using concurrency, each component of a simulation can be its own task, and this makes a simulation much easier to program. Many video games and CGI animations in movies are simulations, and HorseRace.java and GreenhouseScheduler.java, shown earlier, could also be considered simulations.</p>
<subtitle>Bank teller simulation</subtitle>
<p>This classic simulation can represent any situation where objects appear randomly and require a random amount of time to be served by a limited number of servers. It’s possible to build the simulation to determine the ideal number of servers.</p>
<p>In this example, each bank customer requires a certain amount of service time, which is the number of time units that a teller must spend on the customer to serve that customer’s needs. The amount of service time will be different for each customer and will be determined randomly. In addition, you won’t know how many customers will be arriving in each interval, so this will also be determined randomly.</p>
<p>//: concurrency/BankTellerSimulation.java // Using queues and multithreading.</p>
<p>// {Args: 5}</p>
<p>import java.util.concurrent.*; import java.util.*;</p>
<p>// Read-only objects don’t require synchronization: class Customer {</p>
<p>private final int serviceTime; public Customer(int tm) { serviceTime = tm; } public int getServiceTime() { return serviceTime; } public String toString() {</p>
<p>return &quot;[&quot; + serviceTime + &quot;]&quot;;</p>
<p>}</p>
<p>}</p>
<p>// Teach the customer line to display itself: class CustomerLine extends ArrayBlockingQueue&lt;Customer&gt; { public CustomerLine(int maxLineSize) { super(maxLineSize);</p>
<p>}</p>
<p>public String toString() { if(this.size() == 0) return &quot;[Empty]&quot;;</p>
<p>StringBuilder result = new StringBuilder(); for(Customer customer : this) result.append(customer); return result.toString();</p>
<p>}</p>
<p>}</p>
<p>// Randomly add customers to a queue: class CustomerGenerator implements Runnable { private CustomerLine customers; private static Random rand = new Random(47); public CustomerGenerator(CustomerLine cq) { customers = cq;</p>
<p>}</p>
<p>public void run() {</p>
<p>try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>TimeUnit.MILLISECONDS.sleep(rand.nextInt(300)); customers.put(new Customer(rand.nextInt(1000)));</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>System.out.println(&quot;CustomerGenerator interrupted&quot;);</p>
<p>}</p>
<p>System.out.println(&quot;CustomerGenerator terminating&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Teller implements Runnable, Comparable&lt;Teller&gt; { private static int counter = 0; private final int id = counter++;</p>
<p>// Customers served during this shift: private int customersServed = 0; private CustomerLine customers; private boolean servingCustomerLine = true; public Teller(CustomerLine cq) { customers = cq; } public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>Customer customer = customers.take(); TimeUnit.MILLISECONDS.sleep( customer.getServiceTime()); synchronized(this) { customersServed++; while(!servingCustomerLine) wait();</p>
<p>}</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>System.out.println(this + &quot;interrupted&quot;);</p>
<p>}</p>
<p>System.out.println(this + &quot;terminating&quot;);</p>
<p>}</p>
<p>public synchronized void doSomethingElse() { customersServed = 0; servingCustomerLine = false;</p>
<p>}</p>
<p>public synchronized void serveCustomerLine() {</p>
<p>assert !servingCustomerLine:&quot;already serving: &quot; + this;</p>
<p>servingCustomerLine = true;</p>
<p>notifyAll();</p>
<p>}</p>
<p>public String toString() { return &quot;Teller &quot; + id + &quot; &quot;; } public String shortString() { return &quot;T&quot; + id; }</p>
<p>// Used by priority queue:</p>
<p>public synchronized int compareTo(Teller other) {</p>
<p>return customersServed &lt; other.customersServed ? -1 : (customersServed == other.customersServed ? 0 : 1);</p>
<p>}</p>
<p>}</p>
<p>class TellerManager implements Runnable { private ExecutorService exec; private CustomerLine customers; private PriorityQueue&lt;Teller&gt; workingTellers = new PriorityQueue&lt;Teller&gt;(); private Queue&lt;Teller&gt; tellersDoingOtherThings = new LinkedList&lt;Teller&gt;(); private int adjustmentPeriod;</p>
<p>private static Random rand = new Random(47); public TellerManager(ExecutorService e,</p>
<p>CustomerLine customers, int adjustmentPeriod) { exec = e;</p>
<p>this.customers = customers; this.adjustmentPeriod = adjustmentPeriod;</p>
<p>// Start with a single teller:</p>
<p>Teller teller = new Teller(customers);</p>
<p>exec.execute(teller);</p>
<p>workingTellers.add(teller);</p>
<p>}</p>
<p>public void adjustTellerNumber() {</p>
<p>// This is actually a control system. By adjusting // the numbers, you can reveal stability issues in // the control mechanism.</p>
<p>// If line is too long, add another teller: if(customers.size() / workingTellers.size() &gt; 2) {</p>
<p>// If tellers are on break or doing // another job, bring one back: if(tellersDoingOtherThings.size() &gt; 0) {</p>
<p>Teller teller = tellersDoingOtherThings.remove();</p>
<p>teller.serveCustomerLine();</p>
<p>workingTellers.offer(teller);</p>
<p>return;</p>
<p>}</p>
<p>// Else create (hire) a new teller</p>
<p>Teller teller = new Teller(customers);</p>
<p>exec.execute(teller);</p>
<p>workingTellers.add(teller);</p>
<p>return;</p>
<p>}</p>
<p>// If line is short enough, remove a teller: if(workingTellers.size() &gt; 1 &amp;&amp;</p>
<p>customers.size() / workingTellers.size() &lt; 2) reassignOneTeller();</p>
<p>// If there is no line, we only need one teller: if(customers.size() == 0)</p>
<p>while(workingTellers.size() &gt; 1) reassignOneTeller();</p>
<p>}</p>
<p>// Give a teller a different job or a break: private void reassignOneTeller() {</p>
<p>Teller teller = workingTellers.poll();</p>
<p>teller.doSomethingElse();</p>
<p>tellersDoingOtherThings.offer(teller);</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>TimeUnit.MILLISECONDS.sleep(adjustmentPeriod);</p>
<p>adjustTellerNumber();</p>
<p>System.out.print(customers + &quot; { &quot;); for(Teller teller : workingTellers)</p>
<p>System.out.print(teller.shortString() + &quot; &quot;); System.out.println(&quot;}&quot;);</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>System.out.println(this + &quot;interrupted&quot;);</p>
<p>}</p>
<p>System.out.println(this + &quot;terminating&quot;);</p>
<p>}</p>
<p>public String toString() { return &quot;TellerManager &quot;; }</p>
<p>}</p>
<p>public class BankTellerSimulation { static final int MAX_LINE_SIZE = 50; static final int ADJUSTMENT_PERIOD = 1000; public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>// If line is too long, customers will leave:</p>
<p>CustomerLine customers =</p>
<p>new CustomerLine(MAX_LINE_SIZE); exec.execute(new CustomerGenerator(customers));</p>
<p>// Manager will add and remove tellers as necessary: exec.execute(new TellerManager(</p>
<p>exec, customers, ADJUSTMENT_PERIOD)); if(args.length &gt; 0) // Optional argument</p>
<p>TimeUnit.SECONDS.sleep(new Integer(args[0])); else {</p>
<p>System.out.println(&quot;Press ‘Enter’ to quit&quot;); System.in.read();</p>
<p>}</p>
<p>exec.shutdownNow();</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>[429][200][207] { T0 T1 }</p>
<p>[861][258][140][322] { T0 T1 }</p>
<p>[575][342][804][826][896][984] { T0 T1 T2 }</p>
<p>[984][810][141][12][689][992][976][368][395][354] { T0 T1 T2 T3 } Teller 2 interrupted Teller 2 terminating Teller 1 interrupted Teller 1 terminating TellerManager interrupted TellerManager terminating Teller 3 interrupted Teller 3 terminating Teller 0 interrupted Teller 0 terminating CustomerGenerator interrupted CustomerGenerator terminating *///:~</p>
<p>The Customer objects are very simple, containing only a final int field. Because these objects never change, they are read-only objects and they do not require synchronization or the use of volatile. On top of that, each Teller task only removes one Customer at a time from the input queue, and works on that Customer until it is complete, so a Customer will only be accessed by one task at a time, anyway.</p>
<p>CustomerLine represents a single line that the customers wait in before being served by a Teller. This is just an ArrayBlockingQueue that has a toString( ) that prints the results in the desired fashion.</p>
<p>A CustomerGenerator is attached to a CustomerLine and puts Customers onto the queue at randomized intervals.</p>
<p>A Teller takes Customers off of the CustomerLine and processes them one at a time, keeping track of the number of Customers it has served during that particular shift. It can be told to doSomethingElse( ) when there aren’t enough customers, and to serveCustomerLine( ) when lots of customers show up. To choose the next teller to put back on the line, the compareTo( ) method looks at the number of customers served so that a PriorityQueue can automatically put the least-worked teller at the forefront.</p>
<p>The TellerManager is the hub of activity. It keeps track of all the tellers and what’s going on with the customers. One of the interesting things about this simulation is that it attempts to discover the optimum number of tellers for a given customer flow. You can see this in the adjustTeUerNumber( ), which is a control system to add and remove tellers in a stable fashion. All control systems have stability issues; if they react too quickly to a change, they are unstable, and if they react too slowly, the system moves to one of its extremes.</p>
<p>Exercise 35: (8) Modify BankTellerSimulation.java so that it represents Web clients making requests of a fixed number of servers. The goal is to determine the load that the group of servers can handle.</p>
<subtitle>The restaurant simulation</subtitle>
<p>This simulation fleshes out the simple Restaurant.java example shown earlier in this chapter by adding more simulation components, such as Orders and Plates, and it reuses the menu classes from the Enumerated Types chapter.</p>
<p>It also introduces the Java SE5 SynchronousQueue, which is a blocking queue that has no internal capacity, so each put( ) must wait for a take( ), and vice versa. It’s as if you were handing an object to someone—there’s no table to put it on, so it only works if that person is holding a hand out, ready to receive the object. In this example, the SynchronousQueue represents the place setting in front of a diner, to enforce the idea that only one course can be served at a time.</p>
<p>The rest of the classes and functionality of this example either follow from the structure of Restaurant.java or are intended to be a fairly direct mapping from the operations of an actual restaurant:</p>
<p>//: concurrency/restaurant2/RestaurantWithQueues.java // {Args: 5}</p>
<p>package concurrency.restaurant2; import enumerated.menu.*; import java.util.concurrent.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>// This is given to the waiter, who gives it to the chef: class Order { // (A data-transfer object) private static int counter = 0; private final int id = counter++; private final Customer customer; private final WaitPerson waitPerson; private final Food food;</p>
<p>public Order(Customer cust, WaitPerson wp, Food f) { customer = cust; waitPerson = wp; food = f;</p>
<p>}</p>
<p>public Food item() { return food; } public Customer getCustomer() { return customer; } public WaitPerson getWaitPerson() { return waitPerson; } public String toString() {</p>
<p>return &quot;Order: &quot; + id + &quot; item: &quot; + food +</p>
<p>&quot; for: &quot; + customer +</p>
<p>&quot; served by: &quot; + waitPerson;</p>
<p>}</p>
<p>}</p>
<p>// This is what comes back from the chef:</p>
<p>class Plate {</p>
<p>private final Order order; private final Food food; public Plate(Order ord, Food f) { order = ord; food = f;</p>
<p>}</p>
<p>public Order getOrder() { return order; }</p>
<p>public Food getFood() { return food; }</p>
<p>public String toString() { return food.toString(); }</p>
<p>}</p>
<p>class Customer implements Runnable { private static int counter = 0; private final int id = counter++; private final WaitPerson waitPerson;</p>
<p>// Only one course at a time can be received: private SynchronousQueue&lt;Plate&gt; placeSetting = new SynchronousQueue&lt;Plate&gt;(); public Customer(WaitPerson w) { waitPerson = w; } public void</p>
<p>deliver(Plate p) throws InterruptedException {</p>
<p>// Only blocks if customer is still // eating the previous course: placeSetting.put(p);</p>
<p>}</p>
<p>public void run() {</p>
<p>for(Course course : Course.values()) {</p>
<p>Food food = course.randomSelection(); try {</p>
<p>waitPerson.placeOrder(this, food);</p>
<p>// Blocks until course has been delivered: print(this + &quot;eating &quot; + placeSetting.take());</p>
<p>} catch(InterruptedException e) { print(this + &quot;waiting for &quot; + course + &quot; interrupted&quot;); break;</p>
<p>}</p>
<p>}</p>
<p>print(this + &quot;finished meal, leaving&quot;);</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;Customer &quot; + id + &quot; &quot;;</p>
<p>}</p>
<p>}</p>
<p>class WaitPerson implements Runnable { private static int counter = 0; private final int id = counter++; private final Restaurant restaurant;</p>
<p>BlockingQueue&lt;Plate&gt; filledOrders = new LinkedBlockingQueue&lt;Plate&gt;(); public WaitPerson(Restaurant rest) { restaurant = rest; } public void placeOrder(Customer cust, Food food) { try {</p>
<p>// Shouldn’t actually block because this is // a LinkedBlockingQueue with no size limit: restaurant.orders.put(new Order(cust, this, food));</p>
<p>} catch(InterruptedException e) {</p>
<p>print(this + &quot; placeOrder interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>public void run() {</p>
<p>try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>// Blocks until a course is ready Plate plate = filledOrders.take(); print(this + &quot;received &quot; + plate +</p>
<p>&quot; delivering to &quot; + plate.getOrder().getCustomer()); plate.getOrder().getCustomer().deliver(plate);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(this + &quot; interrupted&quot;);</p>
<p>}</p>
<p>print(this + &quot; off duty&quot;);</p>
<p>}</p>
<p>public String toString() {</p>
<p>return &quot;WaitPerson &quot; + id + &quot; &quot;;</p>
<p>}</p>
<p>}</p>
<p>class Chef implements Runnable { private static int counter = 0; private final int id = counter++; private final Restaurant restaurant; private static Random rand = new Random(47); public Chef(Restaurant rest) { restaurant = rest; } public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>// Blocks until an order appears:</p>
<p>Order order = restaurant.orders.take();</p>
<p>Food requestedItem = order.item();</p>
<p>// Time to prepare order:</p>
<p>TimeUnit.MILLISECONDS.sleep(rand.nextInt(500)); Plate plate = new Plate(order, requestedItem); order.getWaitPerson().filledOrders.put(plate);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(this + &quot; interrupted&quot;);</p>
<p>}</p>
<p>print(this + &quot; off duty&quot;);</p>
<p>}</p>
<p>public String toString() { return &quot;Chef &quot; + id + &quot; &quot;; }</p>
<p>}</p>
<p>class Restaurant implements Runnable { private List&lt;WaitPerson&gt; waitPersons = new ArrayList&lt;WaitPerson&gt;(); private List&lt;Chef&gt; chefs = new ArrayList&lt;Chef&gt;(); private ExecutorService exec; private static Random rand = new Random(47); BlockingQueue&lt;Order&gt;</p>
<p>orders = new LinkedBlockingQueue&lt;Order&gt;(); public Restaurant(ExecutorService e, int nWaitPersons, int nChefs) { exec = e;</p>
<p>for(int i = 0; i &lt; nWaitPersons; i++) {</p>
<p>WaitPerson waitPerson = new WaitPerson(this);</p>
<p>waitPersons.add(waitPerson);</p>
<p>exec.execute(waitPerson);</p>
<p>}</p>
<p>for(int i = 0; i &lt; nChefs; i++) {</p>
<p>Chef chef = new Chef(this); chefs.add(chef);</p>
<p>exec.execute(chef);</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>// A new customer arrives; assign a WaitPerson: WaitPerson wp = waitPersons.get( rand.nextInt(waitPersons.size()));</p>
<p>Customer c = new Customer(wp); exec.execute(c);</p>
<p>TimeUnit.MILLISECONDS.sleep(100);</p>
<p>}</p>
<p>} catch(InterruptedException e) { print(&quot;Restaurant interrupted&quot;);</p>
<p>}</p>
<p>print(&quot;Restaurant closing&quot;);</p>
<p>}</p>
<p>} public class RestaurantWithQueues {</p>
<p>public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); Restaurant restaurant = new Restaurant(exec, 5, 2); exec.execute(restaurant); if(args.length &gt; 0) // Optional argument</p>
<p>TimeUnit.SECONDS.sleep(new Integer(args[0])); else {</p>
<p>print(&quot;Press ‘Enter’ to quit&quot;);</p>
<p>System.in.read();</p>
<p>}</p>
<p>exec.shutdownNow();</p>
<p>}</p>
<p>} /* Output:</p>
<p>(Sample)</p>
<p>WaitPerson Customer 1 WaitPerson Customer 0 WaitPerson Customer 1 WaitPerson Customer 2 WaitPerson Customer 3 WaitPerson Customer 0 WaitPerson</p>
<p>0</p>
<p>ea</p>
<p>3</p>
<p>ea</p>
<p>0</p>
<p>ea</p>
<p>3</p>
<p>ea</p>
<p>1</p>
<p>ea</p>
<p>3</p>
<p>ea</p>
<p>0</p>
<p>received SPRING_ROLLS delivering to Customer 1 ting SPRING_ROLLS</p>
<p>received SPRING_ROLLS delivering to Customer 0 ting SPRING_ROLLS</p>
<p>received BURRITO delivering to Customer 1 ting BURRITO</p>
<p>received SPRING_ROLLS delivering to Customer 2 ting SPRING_ROLLS</p>
<p>received SOUP delivering to Customer 3 ting SOUP</p>
<p>received VINDALOO delivering to Customer 0 ting VINDALOO</p>
<p>received FRUIT delivering to Customer 1</p>
<p>*///:~</p>
<p>One very important thing to observe about this example is the management of complexity using queues to communicate between tasks. This single technique greatly simplifies the process of concurrent programming by inverting the control: The tasks do not directly interfere with each other. Instead, the tasks send objects to each other via queues. The receiving task handles the object, treating it as a message rather than having the message inflicted upon it. If you follow this technique whenever you can, you stand a much better chance of building robust concurrent systems.</p>
<p>Exercise 36: (10) Modify RestaurantWithQueues.java so there’s one OrderTicket</p>
<p>object per table. Change order to orderTicket, and add a Table class, with multiple Customers per table.</p>
<subtitle>Distributing work</subtitle>
<p>Here’s a simulation example that brings together many of the concepts in this chapter. Consider a hypothetical robotic assembly line for automobiles. Each Car will be built in several stages, starting with chassis creation, followed by the attachment of the engine, drive train, and wheels.</p>
<p>//: concurrency/CarBuilder.java // A complex example of tasks working together. import java.util.concurrent.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Car {</p>
<p>private final int id; private boolean</p>
<p>engine = false, driveTrain = false, wheels = false; public Car(int idn) { id = idn; }</p>
<p>// Empty Car object: public Car() { id = -1; }</p>
<p>public synchronized int getId() { return id; } public synchronized void addEngine() { engine = true; } public synchronized void addDriveTrain() { driveTrain = true;</p>
<p>}</p>
<p>public synchronized void addWheels() { wheels = true; } public synchronized String toString() {</p>
<p>return &quot;Car &quot; + id + &quot; [&quot; + &quot; engine: &quot; + engine + &quot; driveTrain: &quot; + driveTrain + &quot; wheels: &quot; + wheels + &quot; ]&quot;;</p>
<p>}</p>
<p>}</p>
<p>class CarQueue extends LinkedBlockingQueue&lt;Car&gt; {}</p>
<p>class ChassisBuilder implements Runnable { private CarQueue carQueue; private int counter = 0;</p>
<p>public ChassisBuilder(CarQueue cq) { carQueue = cq; } public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>TimeUnit.MILLISECONDS.sleep(500);</p>
<p>// Make chassis:</p>
<p>Car c = new Car(counter++); print(&quot;ChassisBuilder created &quot; + c);</p>
<p>// Insert into queue carQueue.put(c);</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>print(&quot;Interrupted: ChassisBuilder&quot;);</p>
<p>}</p>
<p>print(&quot;ChassisBuilder off&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Assembler implements Runnable {</p>
<p>private CarQueue chassisQueue, finishingQueue; private Car car;</p>
<p>private CyclicBarrier barrier = new CyclicBarrier(4); private RobotPool robotPool;</p>
<p>public Assembler(CarQueue cq, CarQueue fq, RobotPool rp){ chassisQueue = cq; finishingQueue = fq; robotPool = rp;</p>
<p>}</p>
<p>public Car car() { return car; }</p>
<p>public CyclicBarrier barrier() { return barrier; } public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>// Blocks until chassis is available: car = chassisQueue.take();</p>
<p>// Hire robots to perform work: robotPool.hire(EngineRobot.class, this); robotPool.hire(DriveTrainRobot.class, this); robotPool.hire(WheelRobot.class, this); barrier.await(); // Until the robots finish // Put car into finishingQueue for further work finishingQueue.put(car);</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>print(&quot;Exiting Assembler via interrupt&quot;);</p>
<p>} catch(BrokenBarrierException e) {</p>
<p>// This one we want to know about throw new RuntimeException(e);</p>
<p>}</p>
<p>print(&quot;Assembler off&quot;);</p>
<p>}</p>
<p>}</p>
<p>class Reporter implements Runnable { private CarQueue carQueue;</p>
<p>public Reporter(CarQueue cq) { carQueue = cq; } public void run() { try {</p>
<p>while(!Thread.interrupted()) { print(carQueue.take());</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>print(&quot;Exiting Reporter via interrupt&quot;);</p>
<p>}</p>
<p>print(&quot;Reporter off&quot;);</p>
<p>}</p>
<p>}</p>
<p>abstract class Robot implements Runnable { private RobotPool pool; public Robot(RobotPool p) { pool = p; } protected Assembler assembler;</p>
<p>public Robot assignAssembler(Assembler assembler) { this.assembler = assembler; return this;</p>
<p>}</p>
<p>private boolean engage = false; public synchronized void engage() { engage = true; notifyAll();</p>
<p>}</p>
<p>// The part of run() that’s different for each robot: abstract protected void performService(); public void run() { try {</p>
<p>powerDown(); // Wait until needed</p>
<p>while(!Thread.interrupted()) { performService();</p>
<p>assembler.barrier().await(); // Synchronize // We’re done with that job... powerDown();</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>print(&quot;Exiting &quot; + this + &quot; via interrupt&quot;);</p>
<p>} catch(BrokenBarrierException e) {</p>
<p>// This one we want to know about throw new RuntimeException(e);</p>
<p>}</p>
<p>print(this + &quot; off&quot;);</p>
<p>}</p>
<p>private synchronized void powerDown() throws InterruptedException { engage = false;</p>
<p>assembler = null; // Disconnect from the Assembler // Put ourselves back in the available pool: pool.release(this);</p>
<p>while(engage == false) // Power down wait();</p>
<p>}</p>
<p>public String toString() { return getClass().getName(); }</p>
<p>}</p>
<p>class EngineRobot extends Robot {</p>
<p>public EngineRobot(RobotPool pool) { super(pool); } protected void performService() { print(this + &quot; installing engine&quot;); assembler.car().addEngine();</p>
<p>}</p>
<p>}</p>
<p>class DriveTrainRobot extends Robot {</p>
<p>public DriveTrainRobot(RobotPool pool) { super(pool); } protected void performService() {</p>
<p>print(this + &quot; installing DriveTrain&quot;); assembler.car().addDriveTrain();</p>
<p>}</p>
<p>}</p>
<p>class WheelRobot extends Robot {</p>
<p>public WheelRobot(RobotPool pool) { super(pool); } protected void performService() { print(this + &quot; installing Wheels&quot;); assembler.car().addWheels();</p>
<p>}</p>
<p>}</p>
<p>class RobotPool {</p>
<p>// Quietly prevents identical entries: private Set&lt;Robot&gt; pool = new HashSet&lt;Robot&gt;(); public synchronized void add(Robot r) { pool.add(r); notifyAll();</p>
<p>}</p>
<p>public synchronized void</p>
<p>hire(Class&lt;? extends Robot&gt; robotType, Assembler d) throws InterruptedException { for(Robot r : pool)</p>
<p>if(r.getClass().equals(robotType)) { pool.remove(r);</p>
<p>r.assignAssembler(d);</p>
<p>r.engage(); // Power it up to do the task return;</p>
<p>wait(); // None available</p>
<p>hire(robotType, d); // Try again, recursively</p>
<p>}</p>
<p>public synchronized void release(Robot r) { add(r); }</p>
<p>}</p>
<p>public class CarBuilder {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>CarQueue chassisQueue = new CarQueue(),</p>
<p>finishingQueue = new CarQueue();</p>
<p>ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>RobotPool robotPool = new RobotPool(); exec.execute(new EngineRobot(robotPool)); exec.execute(new DriveTrainRobot(robotPool)); exec.execute(new WheelRobot(robotPool)); exec.execute(new Assembler(</p>
<p>chassisQueue, finishingQueue, robotPool)); exec.execute(new Reporter(finishingQueue));</p>
<p>// Start everything running by producing chassis: exec.execute(new ChassisBuilder(chassisQueue)); TimeUnit.SECONDS.sleep(7); exec.shutdownNow();</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>The Cars are transported from one place to another via a CarQueue, which is a type of LinkedBlockingQueue. A ChassisBuilder creates an unadorned Car and places it on a CarQueue. The Assembler takes the Car off a CarQueue and hires Robots to work on it. A CyclicBarrier allows the Assembler to wait until all the Robots are finished, at which time it puts the Car onto the outgoing CarQueue to be transported to the next operation. The consumer of the final CarQueue is a Reporter object, which just prints the Car to show that the tasks have been properly completed.</p>
<p>The Robots are managed in a pool, and when work needs to be done, the appropriate Robot is hired from the pool. After the work is completed, the Robot returns to the pool.</p>
<p>In main( ), all the necessary objects are created and the tasks are initialized, with the ChassisBuilder begun last to start the process. (However, because of the behavior of the LinkedBlockingQueue, it wouldn’t matter if it were started first.) Note that this program follows all the guidelines regarding object and task lifetime presented in this chapter, and so the shutdown process is safe.</p>
<p>You’ll notice that Car has all of its methods synchronized. As it turns out, in this example this is redundant, because within the factory the Cars move through the queues and only one task can work on a car at a time. Basically, the queues force serialized access to the Cars. But this is exactly the kind of trap you can fall into—you can say &quot;Let’s try to optimize by not synchronizing the Car class because it doesn’t look like it needs it here.&quot; But later, when this system is connected to another which does need the Car to be synchronized, it breaks.</p>
<p>Brian Goetz comments:</p>
<p>It’s much easier to say, &quot;Car might be used from multiple threads, so let’s make it thread-safe in the obvious way.&quot; The way I characterize this approach is: At public parks, you will find guard rails where there is a steep drop, and you may find signs that say, &quot;Don’t lean on the guard rail.&quot; Of course, the real purpose of this rule is not to</p>
<p>prevent you from leaning on the rail—it is to prevent you from falling off the cliff. But &quot;Don’t lean on the rail&quot; is a much easier rule to follow than &quot;Don’t fall off the cliff&quot;</p>
<p>Exercise 37: (2) Modify CarBuilder.java to add another stage to the car-building process, whereby you add the exhaust system, body, and fenders. As with the second stage, assume these processes can be performed simultaneously by robots.</p>
<p>Exercise 38: (3) Using the approach in CarBuilder.java, model the house-building story that was given in this chapter.</p>
</section>
<section>
<title>
<p>Performance tuning</p></title><empty-line/>
<p>A significant number of classes in Java SEs’s java.util.concurrent library exist to provide performance improvements. When you peruse the concurrent library, it can be difficult to discern which classes are intended for regular use (such as BlockingQueues) and which ones are only for improving performance. In this section we will look at some of the issues and classes surrounding performance tuning.</p>
<subtitle>Comparing mutex technologies</subtitle>
<p>Now that Java includes the old synchronized keyword along with the new Java SE5 Lock and Atomic classes, it is interesting to compare the different approaches so that we can understand more about the value of each and where to use them.</p>
<p>The naive approach is to try a simple test on each approach, like this:</p>
<p>//: concurrency/SimpleMicroBenchmark.java // The dangers of microbenchmarking. import java.util.concurrent.locks.*;</p>
<p>abstract class Incrementable { protected long counter = 0; public abstract void increment();</p>
<p>}</p>
<p>class SynchronizingTest extends Incrementable {</p>
<p>public synchronized void increment() { ++counter; }</p>
<p>}</p>
<p>class LockingTest extends Incrementable { private Lock lock = new ReentrantLock(); public void increment() { lock.lock(); try {</p>
<p>++counter;</p>
<p>} finally { lock.unlock();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class SimpleMicroBenchmark { static long test(Incrementable incr) { long start = System.nanoTime(); for(long i = 0; i &lt; 10000000L; i++) incr.increment(); return System.nanoTime() - start;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>long synchTime = test(new SynchronizingTest()); long lockTime = test(new LockingTest()); System.out.printf(&quot;synchronized: %1$10d\n&quot;, synchTime); System.out.printf(&quot;Lock:    %1$10d\n&quot;, lockTime);</p>
<p>System.out.printf(&quot;Lock/synchronized = %1$.3f&quot;, (double)lockTime/(double)synchTime);</p>
<p>}</p>
<p>} /* Output: (75% match) synchronized:    244919117</p>
<p>Lock:    939098964</p>
<p>Lock/synchronized = 3.834</p>
<p>You can see from the output that calls to the synchronized method appear to be faster than using a ReentrantLock. What’s happened here?</p>
<p>This example demonstrates the dangers of so-called &quot;microbenchmarking.&quot;<a l:href="#bookmark130" type="note"><sup>131</sup></a><sup></sup> This term generally refers to performance testing a feature in isolation, out of context. Of course, you must still write tests to verify assertions like &quot;Lock is much faster than synchronized.&quot; But you need an awareness of what’s really happening during compilation and run time when you write these kinds of tests.</p>
<p>There are a number of problems with the above example. First and foremost, we will only see the true performance difference if the mutexes are under contention, so there must be multiple tasks trying to access the mutexed code sections. In the above example, each mutex is tested by the single main( ) thread, in isolation.</p>
<p>Secondly, it’s possible that the compiler can perform special optimizations when it sees the synchronized keyword, and perhaps even notice that this program is single-threaded. The compiler might even identify that the counter is simply being incremented a fixed number of times, and just precalculate the result. Different compilers and runtime systems vary, so it’s hard to know exactly what will happen, but we need to prevent the possibility that the compiler can predict the outcome.</p>
<p>To create a valid test, we must make the program more complex. First we need multiple tasks, and not just tasks that change internal values, but also tasks that read those values (otherwise the optimizer may recognize that the values are never being used). In addition, the calculation must be complex and unpredictable enough that the compiler will have no chance to perform aggressive optimizations. This will be accomplished by pre-loading a large array of random ints (pre-loading to reduce the impact of calls to Random.nextInt( ) on the main loops) and using those values in a summation:</p>
<p>//: concurrency/SynchronizationComparisons.java // Comparing the performance of explicit Locks // and Atomics versus the synchronized keyword. import java.util.concurrent.*; import java.util.concurrent.atomic.*; import java.util.concurrent.locks.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>abstract class Accumulator {</p>
<p>public static long cycles = 50000L;</p>
<p>// Number of Modifiers and Readers during each test: private static final int N = 4; public static ExecutorService exec =</p>
<p>Executors.newFixedThreadPool(N*2); private static CyclicBarrier barrier = new CyclicBarrier(N*2 + 1); protected volatile int index = 0; protected volatile long value = 0; protected long duration = 0; protected String id = &quot;error&quot;; protected final static int SIZE = 100000; protected static int[] preLoaded = new int[SIZE]; static {</p>
<p>// Load the array of random numbers:</p>
<p>Random rand = new Random(47); for(int i = 0; i &lt; SIZE; i++) preLoaded[i] = rand.nextInt();</p>
<p>public abstract void accumulate(); public abstract long read(); private class Modifier implements Runnable { public void run() {</p>
<p>for(long i = 0; i &lt; cycles; i++) accumulate(); try {</p>
<p>barrier.await();</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>private class Reader implements Runnable { private volatile long value; public void run() {</p>
<p>for(long i = 0; i &lt; cycles; i++) value = read(); try {</p>
<p>barrier.await();</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public void timedTest() {</p>
<p>long start = System.nanoTime(); for(int i = 0; i &lt; N; i++) { exec.execute(new Modifier()); exec.execute(new Reader());</p>
<p>}</p>
<p>try {</p>
<p>barrier.await();</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>duration = System.nanoTime() - start; printf(&quot;%-13s: %13d\n&quot;, id, duration);</p>
<p>}</p>
<p>public static void</p>
<p>report(Accumulator accl, Accumulator acc2) {</p>
<p>printf(&quot;%-22s: %.2f\n&quot;, accl.id + &quot;/&quot; + acc2.id, (double)acc1.duration/(double)acc2.duration);</p>
<p>}</p>
<p>}</p>
<p>class BaseLine extends Accumulator {</p>
<p>{ id = &quot;BaseLine&quot;; } public void accumulate() { value += preLoaded[index++]; if(index &gt;= SIZE) index = 0;</p>
<p>}</p>
<p>public long read() { return value; }</p>
<p>}</p>
<p>class SynchronizedTest extends Accumulator {</p>
<p>{ id = &quot;synchronized&quot;; } public synchronized void accumulate() { value += preLoaded[index++];</p>
<p>if(index &gt;= SIZE) index = 0;</p>
<p>public synchronized long read() { return value;</p>
<p>}</p>
<p>}</p>
<p>class LockTest extends Accumulator {</p>
<p>{ id = &quot;Lock&quot;; }</p>
<p>private Lock lock = new ReentrantLock(); public void accumulate() { lock.lock(); try {</p>
<p>value += preLoaded[index++]; if(index &gt;= SIZE) index = 0;</p>
<p>} finally { lock.unlock();</p>
<p>}</p>
<p>}</p>
<p>public long read() { lock.lock(); try {</p>
<p>return value;</p>
<p>} finally { lock.unlock();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class AtomicTest extends Accumulator {</p>
<p>{ id = &quot;Atomic&quot;; }</p>
<p>private AtomicInteger index = new AtomicInteger(0); private AtomicLong value = new AtomicLong(0); public void accumulate() {</p>
<p>// Oops! Relying on more than one Atomic at // a time doesn’t work. But it still gives us // a performance indicator: int i = index.getAndIncrement(); value.getAndAdd(preLoaded[i]); if(++i &gt;= SIZE) index.set(0);</p>
<p>}</p>
<p>public long read() { return value.get(); }</p>
<p>}</p>
<p>public class SynchronizationComparisons { static BaseLine baseLine = new BaseLine(); static SynchronizedTest synch = new SynchronizedTest(); static LockTest lock = new LockTest(); static AtomicTest atomic = new AtomicTest(); static void test() {</p>
<p>print(&quot;============================&quot;);</p>
<p>printf(&quot;%-12s : %13d\n&quot;, &quot;Cycles&quot;, Accumulator.cycles);</p>
<p>baseLine.timedTest();</p>
<p>synch.timedTest();</p>
<p>lock.timedTest();</p>
<p>atomic.timedTest();</p>
<p>Accumulator.report(synch, baseLine); Accumulator.report(lock, baseLine); Accumulator.report(atomic, baseLine); Accumulator.report(synch, lock); Accumulator.report(synch, atomic); Accumulator.report(lock, atomic);</p>
<p>public static void main(String[] args) { int iterations = 5; // Default</p>
<p>if(args.length &gt; 0) // Optionally change iterations iterations = new Integer(args[0]);</p>
<p>// The first time fills the thread pool:</p>
<p>print(&quot;Warmup&quot;);</p>
<p>baseLine.timedTest();</p>
<p>// Now the initial test doesn’t include the cost // of starting the threads for the first time.</p>
<p>// Produce multiple data points: for(int i = 0; i &lt; iterations; i++) { test();</p>
<p>Accumulator.cycles *= 2;</p>
<p>}</p>
<p>Accumulator.exec.shutdown();</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Warmup</p>
<p>BaseLine :    34237033</p>
<table>
<tr><td>Cycles :</td><td></td><td>50000</td></tr>
<tr><td>BaseLine :</td><td colspan="2">20966632</td></tr>
<tr><td>synchronized :</td><td colspan="2">24326555</td></tr>
<tr><td>Lock :</td><td colspan="2">53669950</td></tr>
<tr><td>Atomic :</td><td colspan="2">30552487</td></tr>
<tr><td colspan="2">synchronized/BaseLine</td><td>1.16</td></tr>
<tr><td>Lock/BaseLine</td><td></td><td>2.56</td></tr>
<tr><td colspan="2">Atomic/BaseLine</td><td>1.46</td></tr>
<tr><td colspan="2">synchronized/Lock</td><td>0.45</td></tr>
<tr><td colspan="2">synchronized/Atomic</td><td>0.79</td></tr>
<tr><td>Lock/Atomic</td><td></td><td>1.76</td></tr>
<tr><td>Cycles :</td><td colspan="2">100000</td></tr>
<tr><td>BaseLine :</td><td colspan="2">41512818</td></tr>
<tr><td>synchronized :</td><td colspan="2">43843003</td></tr>
<tr><td>Lock :</td><td colspan="2">87430386</td></tr>
<tr><td>Atomic :</td><td colspan="2">51892350</td></tr>
<tr><td colspan="2">synchronized/BaseLine</td><td>1.06</td></tr>
<tr><td>Lock/BaseLine</td><td></td><td>2.11</td></tr>
<tr><td colspan="2">Atomic/BaseLine</td><td>1.25</td></tr>
<tr><td colspan="2">synchronized/Lock</td><td>0.50</td></tr>
<tr><td colspan="2">synchronized/Atomic</td><td>0.84</td></tr>
<tr><td>Lock/Atomic</td><td></td><td>1.68</td></tr>
<tr><td>Cycles :</td><td colspan="2">200000</td></tr>
<tr><td>BaseLine :</td><td colspan="2">80176670</td></tr>
<tr><td>synchronized :</td><td colspan="2">5455046661</td></tr>
<tr><td>Lock :</td><td colspan="2">177686829</td></tr>
<tr><td>Atomic :</td><td colspan="2">101789194</td></tr>
<tr><td colspan="2">synchronized/BaseLine</td><td>68.0</td></tr>
<tr><td>Lock/BaseLine</td><td></td><td>2.22</td></tr>
<tr><td colspan="2">Atomic/BaseLine</td><td>1.27</td></tr>
<tr><td colspan="2">synchronized/Lock</td><td>30.7</td></tr>
<tr><td colspan="2">synchronized/Atomic</td><td>53.5</td></tr>
<tr><td>Lock/Atomic</td><td></td><td>1.75</td></tr>
</table>
<p>400000</p>
<p>160383513</p>
<p>780052493</p>
<p>362187652</p>
<p>202030984</p>
<p>Cycles</p>
<p>BaseLine</p>
<p>synchronized</p>
<p>Lock</p>
<p>Atomic synchronized/BaseLine : 4.86</p>
<p>Lock/BaseLine : 2.26 Atomic/BaseLine : 1.26 synchronized/Lock : 2.15 synchronized/Atomic : 3.86 Lock/Atomic : 1.79</p>
<p>Cycles BaseLine synchronized Lock Atomic synchronized/Base Lock/BaseLine Atomic/BaseLine synchronized/Lock synchronized/Atom Lock/Atomic *///:~</p>
<p>3200000</p>
<p>1285664519</p>
<p>96336767661</p>
<p>2846988654</p>
<p>1590545726</p>
<p>Line</p>
<p>ic</p>
<p>74.93</p>
<p>2.21</p>
<p>1.24</p>
<p>33.84</p>
<p>60.57</p>
<p>1.79</p>
<table>
<tr><td>Cycles</td><td colspan="2">800000</td></tr>
<tr><td>BaseLine :</td><td colspan="2">322064955</td></tr>
<tr><td>synchronized :</td><td colspan="2">336155014</td></tr>
<tr><td>Lock :</td><td colspan="2">704615531</td></tr>
<tr><td>Atomic</td><td colspan="2">393231542</td></tr>
<tr><td colspan="2">synchronized/BaseLine</td><td>1.04</td></tr>
<tr><td>Lock/BaseLine</td><td></td><td>2.19</td></tr>
<tr><td colspan="2">Atomic/BaseLine</td><td>1.22</td></tr>
<tr><td colspan="2">synchronized/Lock</td><td>0.47</td></tr>
<tr><td colspan="2">synchronized/Atomic</td><td>0.85</td></tr>
<tr><td>Lock/Atomic</td><td></td><td>1.79</td></tr>
<tr><td>Cycles :</td><td colspan="2">1600000</td></tr>
<tr><td>BaseLine :</td><td colspan="2">650004120</td></tr>
<tr><td>synchronized :</td><td colspan="2">52235762925</td></tr>
<tr><td>Lock :</td><td colspan="2">1419602771</td></tr>
<tr><td>Atomic :</td><td colspan="2">796950171</td></tr>
<tr><td colspan="2">synchronized/BaseLine</td><td>80.3</td></tr>
<tr><td>Lock/BaseLine</td><td></td><td>2.18</td></tr>
<tr><td colspan="2">Atomic/BaseLine</td><td>1.23</td></tr>
<tr><td colspan="2">synchronized/Lock</td><td>36.8</td></tr>
<tr><td colspan="2">synchronized/Atomic</td><td>65.5</td></tr>
<tr><td>Lock/Atomic</td><td></td><td>1.78</td></tr>
</table>
<p>This program uses the Template Method design pattern<a l:href="#bookmark131" type="note"><sup>132</sup></a><sup></sup> to put all the common code in the base class and isolate all the varying code in the derivedclass implementations of accumulate( ) and read( ). In each of the derived classes SynchronizedTest, LockTest, and AtomicTest, you can see how accumulate( ) and read( ) express different ways of implementing mutual exclusion.</p>
<p>In this program, tasks are executed via a FixedThreadPool in an attempt to keep all the thread creation at the beginning, and prevent any extra cost during the tests. Just to make sure, the initial test is duplicated and the first result is discarded because it includes the initial thread creation.</p>
<p>A CyclicBarrier is necessary because we want to make sure all the tasks have completed before declaring each test complete.</p>
<p>A static clause is used to pre-load the array of random numbers, before any tests begin. This way, if there is any overhead to generating random numbers, we won’t see it during the test.</p>
<p>Each time accumulate( ) is called, it moves to the next place in the array preLoaded (wrapping to the beginning of the array) and adds another randomly generated number to value. The multiple Modifier and Reader tasks provide contention on the Accumulator object.</p>
<p>Notice that in AtomicTest, I observe that the situation is too complex to try to use Atomic objects—basically, if more than one Atomic object is involved, you will probably be forced to give up and use more conventional mutexes (the JDK documentation specifically states that using Atomic objects only works when the critical updates for an object are confined to a single variable). However, the test is left in place so that you can still get a feel for the performance benefit of Atomic objects.</p>
<p>In main( ), the test is run repeatedly and you can decide to ask for more than five repetitions (the default). For each repetition, the number of test cycles is doubled, so you can see how the different mutexes behave when running for longer and longer times. As you can see from the output, the results are rather surprising. For the first four iterations, the synchronized keyword seems to be more efficient than using a Lock or an Atomic. But suddenly, a threshold is crossed and synchronized seems to become quite inefficient, while Lock and Atomic seem to roughly maintain their proportion to the BaseLine test, and therefore become much more efficient than synchronized.</p>
<p>Keep in mind that this program only gives an indication of the differences between the various mutex approaches, and the output above only indicates these differences on my particular machine under my particular circumstances. As you can see if you experiment with it, there can be significant shifts in behavior when different numbers of threads are used and when the program is run for longer periods of time. Some hotspot runtime optimizations are not invoked until a program has been running for several minutes, and in the case of server programs, several hours.</p>
<p>That said, it is fairly clear that using Lock is usually significantly more efficient than using synchronized, and it also appears that the overhead of synchronized varies widely, while Locks are relatively consistent.</p>
<p>Does this mean you should never use the synchronized keyword? There are two factors to consider: First, in SynchronizationComparisons.java, the bodies of the mutexed methods are extremely small. In general, this is a good practice—only mutex the sections that you absolutely must. However, in practice the mutexed sections may be larger than those in the above example, and so the percentage of time in the body will probably be significantly bigger than the overhead of entering and exiting the mutex, and could overwhelm any benefit of speeding up the mutex. Of course, the only way to know is— when you’re tuning for performance, no sooner—to try the different approaches and see what impact they have.</p>
<p>Second, it’s clear from reading the code in this chapter that the synchronized keyword produces much more readable code than the lock try/finally-unlock idiom that Locks require, and that’s why this chapter primarily uses the synchronized keyword. As I’ve stated elsewhere in this book, code is read much more than it is written—when programming, it is more important to communicate with other humans than it is to communicate with the computer—and so readability of code is critical. As a result, it makes sense to start with the synchronized keyword and only change to Lock objects when you are tuning for performance.</p>
<p>Finally, it’s nice when you can use the Atomic classes in your concurrent program, but be aware that, as we saw in SynchronizationComparisons.java, Atomic objects are only useful in very simple cases, generally when you only have one Atomic object that’s being modified and when that object is independent from all other objects. It’s safer to start with more traditional mutexing approaches and only attempt to change to Atomic later, if performance requirements dictate.</p>
<subtitle>Lock-free containers</subtitle>
<p>As emphasized in the Holding Your Objects chapter, containers are a fundamental tool in all programming, and this includes concurrent programming. For this reason, early containers like Vector and Hashtable had many synchronized methods, which caused unacceptable overhead when they were not being used in multithreaded applications. In Java 1.2, the new containers library was unsynchronized, and the Collections class was given various static &quot;synchronized&quot; decoration methods to synchronize the different types of containers.</p>
<p>Although this was an improvement because it gave you a choice about whether you use synchronization with your container, the overhead is still based on synchronized locking. Java SE5 has added new containers specifically to increase thread-safe performance, using clever techniques to eliminate locking.</p>
<p>The general strategy behind these lock-free containers is this: Modifications to the containers can happen at the same time that reads are occurring, as long as the readers can only see the results of completed modifications. A modification is performed on a separate copy of a portion of the data structure (or sometimes a copy of the whole thing), and this copy is invisible during the modification process. Only when the modification is complete is the modified structure atomically swapped with the &quot;main&quot; data structure, and after that readers will see the modification.</p>
<p>In CopyOnWriteArrayList, a write will cause a copy of the entire underlying array to be created. The original array is left in place so that reads can safely occur while the copied array is being modified. When the modification is complete, an atomic operation swaps the new array in so that new reads will see the new information. One of the benefits of CopyOnWriteArrayList is that it does not throw ConcurrentModificationException when multiple iterators are traversing and modifying the list, so you don’t have to write special code to protect against such exceptions, as you’ve had to do in the past.</p>
<p>CopyOnWriteArraySet uses CopyOnWriteArrayList to achieve its lock-free behavior.</p>
<p>ConcurrentHashMap and ConcurrentLinkedQueue use similar techniques to allow concurrent reads and writes, but only portions of the container are copied and modified rather than the entire container. However, readers will still not see any modifications before they are complete. ConcurrentHashMap doesn’t throw ConcurrentModificationExceptions.</p>
<p>Performance issues</p>
<p>As long as you are primarily reading from a lock-free container, it will be much faster than its synchronized counterpart because the overhead of acquiring and releasing locks is eliminated. This is still true for a small number of writes to a lock-free container, but it would be interesting to get an idea of what &quot;small&quot; means. This section will produce a rough idea of the performance differences of these containers under different conditions.</p>
<p>I’ll start with a generic framework for performing tests on any type of container, including Maps. The generic parameter C represents the container type:</p>
<p>//: concurrency/Tester.java</p>
<p>// Framework to test performance of concurrency containers. import java.util.concurrent.*; import net.mindview.util.*;</p>
<p>public abstract class Tester&lt;C&gt; { static int testReps = 10; static int testCycles = 1000; static int containerize = 1000;</p>
<p>abstract C containerInitializer(); abstract void startReadersAndWriters();</p>
<p>C testContainer;</p>
<p>String testId; int nReaders; int nWriters;</p>
<p>volatile long readResult = 0; volatile long readTime = 0; volatile long writeTime = 0;</p>
<p>CountDownLatch endLatch; static ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>Integer[] writeData;</p>
<p>Tester(String testId, int nReaders, int nWriters) { this.testId = testId + &quot; &quot; +</p>
<p>nReaders + &quot;r &quot; + nWriters + &quot;w&quot;; this.nReaders = nReaders; this.nWriters = nWriters; writeData = Generated.array(Integer.class,</p>
<p>new RandomGenerator.Integer(), containerSize); for(int i = 0; i &lt; testReps; i++) { runTest(); readTime = 0; writeTime = 0;</p>
<p>}</p>
<p>}</p>
<p>void runTest() {</p>
<p>endLatch = new CountDownLatch(nReaders + nWriters); testContainer = containerInitializer(); startReadersAndWriters(); try {</p>
<p>endLatch.await();</p>
<p>} catch(InterruptedException ex) {</p>
<p>System.out.println(&quot;endLatch interrupted&quot;);</p>
<p>}</p>
<p>System.out.printf(&quot;%-27s %14d %14d\n&quot;, testId, readTime, writeTime); if(readTime != 0 &amp;&amp; writeTime != 0) System.out.printf(&quot;%-27s %14d\n&quot;,</p>
<p>&quot;readTime + writeTime =&quot;, readTime + writeTime);</p>
<p>}</p>
<p>abstract class TestTask implements Runnable { abstract void test(); abstract void putResults(); long duration; public void run() {</p>
<p>long startTime = System.nanoTime(); test();</p>
<p>duration = System.nanoTime() - startTime; synchronized(Tester.this) { putResults();</p>
<p>}</p>
<p>endLatch.countDown();</p>
<p>}</p>
<p>}</p>
<p>public static void initMain(String[] args) { if(args.length &gt; 0)</p>
<p>testReps = new Integer(args[0]); if(args.length &gt; 1)</p>
<p>testCycles = new Integer(args[1]); if(args.length &gt; 2)</p>
<p>containerSize = new Integer(args[2]); System.out.printf(&quot;%-27s %14s %14s\n&quot;,</p>
<p>&quot;Type&quot;, &quot;Read time&quot;, &quot;Write time&quot;);</p>
<p>} ///:~</p>
<p>The abstract method containerInitializer( ) returns the initialized container to be tested, which is stored in the field testContainer. The other abstract method, startReadersAndWriters( ), starts the reader and writer tasks that will read and modify the container under test. Different tests are run with varying number of readers and writers to see the effects of lock contention (for the synchronized containers) and writes (for the lock-free containers).</p>
<p>The constructor is given various information about the test (the argument identifiers should be self-explanatory), then it calls the runTest( ) method repetitions times. runTest( ) creates a CountDownLatch (so the test can know when all the tasks are complete), initializes the container, then calls startReadersAndWriters( ) and waits until they all complete.</p>
<p>Each &quot;Reader&quot; or &quot;Writer&quot; class is based on TestTask, which measures the duration of its abstract test( ) method, then calls putResults( ) inside a synchronized block to store the results.</p>
<p>To use this framework (in which you’ll recognize the Template Method design pattern), we must inherit from Tester for the particular container type we wish to test, and provide appropriate Reader and Writer classes:</p>
<p>//: concurrency/ListComparisons.java</p>
<p>// {Args: 1 10 10} (Fast verification check during build)</p>
<p>// Rough comparison of thread-safe List performance.</p>
<p>import java.util.concurrent.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>abstract class ListTest extends Tester&lt;List&lt;Integer&gt;&gt; {</p>
<p>ListTest(String testId, int nReaders, int nWriters) { super(testId, nReaders, nWriters);</p>
<p>}</p>
<p>class Reader extends TestTask { long result = 0; void test() {</p>
<p>for(long i = 0; i &lt; testCycles; i++)</p>
<p>for(int index = 0; index &lt; containerSize; index++) result += testContainer.get(index);</p>
<p>}</p>
<p>void putResults() { readResult += result; readTime += duration;</p>
<p>}</p>
<p>}</p>
<p>class Writer extends TestTask { void test() {</p>
<p>for(long i = 0; i &lt; testCycles; i++)</p>
<p>for(int index = 0; index &lt; containerSize; index++) testContainer.set(index, writeData[index]);</p>
<p>}</p>
<p>void putResults() { writeTime += duration;</p>
<p>}</p>
<p>}</p>
<p>void startReadersAndWriters() { for(int i = 0; i &lt; nReaders; i++) exec.execute(new Reader());</p>
<p>for(int i = 0; i &lt; nWriters; i++) exec.execute(new Writer());</p>
<p>class SynchronizedArrayListTest extends ListTest {</p>
<p>List&lt;Integer&gt; containerInitializer() { return Collections.synchronizedList( new ArrayList&lt;Integer&gt;(</p>
<p>new CountinglntegerList(containerSize)));</p>
<p>}</p>
<p>SynchronizedArrayListTest(int nReaders, int nWriters) { super(&quot;Synched ArrayList&quot;, nReaders, nWriters);</p>
<p>}</p>
<p>}</p>
<p>class CopyOnWriteArrayListTest extends ListTest {</p>
<p>List&lt;Integer&gt; containerInitializer() {</p>
<p>return new CopyOnWriteArrayList&lt;Integer&gt;( new CountingIntegerList(containerSize));</p>
<p>}</p>
<p>CopyOnWriteArrayListTest(int nReaders, int nWriters) { super(&quot;CopyOnWriteArrayList&quot;, nReaders, nWriters);</p>
<p>}</p>
<p>}</p>
<p>public class ListComparisons {</p>
<p>public static void main(String[] args) { Tester.initMain(args); new SynchronizedArrayListTest(10, 0); new SynchronizedArrayListTest(9, 1); new SynchronizedArrayListTest(5, 5); new CopyOnWriteArrayListTest(10, 0); new CopyOnWriteArrayListTest(9, 1); new CopyOnWriteArrayListTest(5, 5); Tester.exec.shutdown();</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Read time 232158294700 198947618203 223866231602 117367305062 249543918570 758386889 741305671 877450908 212763075 68180227375</p>
<p>Write time 0</p>
<p>24918613399</p>
<p>132176613508</p>
<p>0</p>
<p>136145237</p>
<p>67967464300</p>
<p>Type</p>
<p>Synched ArrayList 10r 0w Synched ArrayList 9r 1w readTime + writeTime =</p>
<p>Synched ArrayList 5r 5w readTime + writeTime =</p>
<p>CopyOnWriteArrayList 10r 0w CopyOnWriteArrayList 9r 1w readTime + writeTime =</p>
<p>CopyOnWriteArrayList 5r 5w readTime + writeTime = *///:~</p>
<p>In ListTest, the Reader and Writer classes perform the specific actions for a List&lt;Integer&gt;. In Reader.putResults( ), the duration is stored but so is the result, to</p>
<p>prevent the calculations from being optimized away. startReadersAndWriters( ) is then defined to create and execute the specific Readers and Writers.</p>
<p>Once ListTest is created, it must be further inherited to override containerInitializer( ) to create and initialize the specific test containers.</p>
<p>In main( ), you can see variations on the tests with different numbers of readers and writers. You can change the test variables using command-line arguments because of the call to Tester.initMain(args).</p>
<p>The default behavior is to run each test 10 times; this helps stabilize the output, which can change because of JVM activities like hotspot optimization and garbage collection.<a l:href="#bookmark132" type="note"><sup>133</sup></a><sup></sup> The sample output that you see has been edited to show only the last iteration from each test. From the output, you can see that a synchronized ArrayList has roughly the same performance regardless of the number of readers and writers—readers contend with other readers for locks in the same way that writers do. The CopyOnWriteArrayList, however, is dramatically faster when there are no writers, and is still significantly faster when there are five writers. It would appear that you can be fairly liberal with the use of CopyOnWriteArrayList; the impact of writing to the list does not appear to overtake the impact of synchronizing the entire list for a while. Of course, you must try the two different approaches in your specific application to know for sure which one is best.</p>
<p>Again, note that this isn’t close to being a good benchmark for absolute numbers, and your numbers will almost certainly be different. The goal is just to give you an idea of the relative behaviors of the two types of container.</p>
<p>Since CopyOnWriteArraySet uses CopyOnWriteArrayList, its behavior will be similar and it doesn’t need a separate test here.</p>
<p>Comparing Map implementations</p>
<p>We can use the same framework to get a rough idea of the performance of a synchronized HashMap compared to a ConcurrentHashMap:</p>
<p>//: concurrency/MapComparisons.java</p>
<p>// {Args: 1 10 10} (Fast verification check during build)</p>
<p>// Rough comparison of thread-safe Map performance. import java.util.concurrent.*; import java.util.*; import net.mindview.util.*;</p>
<p>abstract class MapTest</p>
<p>extends Tester&lt;Map&lt;Integer,Integer&gt;&gt; {</p>
<p>MapTest(String testId, int nReaders, int nWriters) { super(testId, nReaders, nWriters);</p>
<p>}</p>
<p>class Reader extends TestTask { long result = 0; void test() {</p>
<p>for(long i = 0; i &lt; testCycles; i++)</p>
<p>for(int index = 0; index &lt; containerSize; index++) result += testContainer.get(index);</p>
<p>}</p>
<p>void putResults() { readResult += result; readTime += duration;</p>
<p>}</p>
<p>}</p>
<p>class Writer extends TestTask { void test() {</p>
<p>for(long i = 0; i &lt; testCycles; i++)</p>
<p>for(int index = 0; index &lt; containerSize; index++) testContainer.put(index, writeData[index]);</p>
<p>}</p>
<p>void putResults() { writeTime += duration;</p>
<p>}</p>
<p>void startReadersAndWriters() { for(int i = 0; i &lt; nReaders; i++) exec.execute(new Reader()); for(int i = 0; i &lt; nWriters; i++) exec.execute(new Writer());</p>
<p>}</p>
<p>}</p>
<p>class SynchronizedHashMapTest extends MapTest { Map&lt;Integer,Integer&gt; containerInitializer() { return Collections.synchronizedMap( new HashMap&lt;Integer,Integer&gt;(</p>
<p>MapData.map(</p>
<p>new CountingGenerator.Integer(), new CountingGenerator.Integer(), containerSize)));</p>
<p>}</p>
<p>SynchronizedHashMapTest(int nReaders, int nWriters) { super(&quot;Synched HashMap&quot;, nReaders, nWriters);</p>
<p>}</p>
<p>} class ConcurrentHashMapTest extends MapTest { Map&lt;Integer,Integer&gt; containerInitializer() { return new ConcurrentHashMap&lt;Integer,Integer&gt;( MapData.map(</p>
<p>new CountingGenerator.Integer(),</p>
<p>new CountingGenerator.Integer(), containerSize));</p>
<p>}</p>
<p>ConcurrentHashMapTest(int nReaders, int nWriters) { super(&quot;ConcurrentHashMap&quot;, nReaders, nWriters);</p>
<p>}</p>
<p>} public class MapComparisons {</p>
<p>public static void main(String[] args) { Tester.initMain(args); new SynchronizedHashMapTest(10, 0); new SynchronizedHashMapTest(9, 1); new SynchronizedHashMapTest(5, 5); new ConcurrentHashMapTest(10, 0); new ConcurrentHashMapTest(9, 1); new ConcurrentHashMapTest(5, 5); Tester.exec.shutdown();</p>
<p>}</p>
<p>} /* Output: (Sample)</p>
<p>Read time 306052025049 428319156207 476016503775 243956877760 487968880962 23352654318 18833089400 20374942624 12037625732 23888114831</p>
<p>Write time 0</p>
<p>47697347568</p>
<p>244012003202</p>
<p>0</p>
<p>1541853224</p>
<p>11850489099</p>
<p>Type</p>
<p>Synched HashMap 10r 0w Synched HashMap 9r 1w readTime + writeTime =</p>
<p>Synched HashMap 5r 5w readTime + writeTime =</p>
<p>ConcurrentHashMap 10r 0w ConcurrentHashMap 9r 1w readTime + writeTime =</p>
<p>ConcurrentHashMap 5r 5w readTime + writeTime = *///:~</p>
<p>The impact of adding writers to a ConcurrentHashMap is even less evident than for a CopyOnWriteArrayList, but the ConcurrentHashMap uses a different technique that clearly minimizes the impact of writes.</p>
<subtitle>Optimistic locking</subtitle>
<p>Although Atomic objects perform atomic operations like decrementAndGet( ), some Atomic classes also allow you to perform what is called &quot;optimistic locking.&quot; This means that you do not actually use a mutex when you are performing a calculation, but after the calculation is finished and you’re ready to update the Atomic object, you use a method called compareAndSet( ). You hand it the old value and the new value, and if the old value doesn’t agree with the value it finds in the Atomic object, the operation fails—this means that some other task has modified the object in the meantime. Remember that we would ordinarily use a mutex (synchronized or Lock) to prevent more than one task modifying an object at the same time, but here we are &quot;optimistic&quot; by leaving the data unlocked and hoping that no other task comes along and modifies it. Again, all this is done in the name of performance—by using an Atomic instead of synchronized or Lock, you might gain performance benefits.</p>
<p>What happens if the compareAndSet( ) operation fails? This is where it gets tricky, and where you are limited in applying this technique only to problems that can be molded to the requirements. If compareAndSet( ) fails, you must decide what to do; this is very important because if you can’t do something to recover, then you cannot use this technique and must use conventional mutexes instead. Perhaps you can retry the operation and it will be OK if you get it the second time. Or perhaps it’s OK just to ignore the failure—in some simulations, if a data point is lost, it will eventually be made up in the grand scheme of things (of course, you must understand your model well enough to know whether this is true).</p>
<p>Consider a fictitious simulation that consists of 100,000 &quot;genes&quot; of length 30; perhaps this is the beginning of some kind of genetic algorithm. Suppose that for each &quot;evolution&quot; of the genetic algorithm, some very expensive calculations take place, so you decide to use a multiprocessor machine to distribute the tasks and improve performance. In addition, you use Atomic objects instead of Lock objects to prevent mutex overhead. (Naturally, you only produced this solution after first writing the code in the simplest way that could possibly work, using the synchronized keyword. Once you had the program running, only then did you discover that it was too slow, and begin applying performance techniques!) Because of the nature of your model, if there’s a collision during a calculation, the task that discovers the collision can just ignore it and not update its value. Here’s what it looks like:</p>
<p>//: concurrency/FastSimulation.java import java.util.concurrent.*; import java.util.concurrent.atomic.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class FastSimulation {</p>
<p>static final int N_ELEMENTS = 100000; static final int N_GENES = 30; static final int N_EVOLVERS = 50; static final AtomicInteger[][] GRID = new AtomicInteger[N_ELEMENTS][N_GENES]; static Random rand = new Random(47); static class Evolver implements Runnable { public void run() {</p>
<p>while(!Thread.interrupted()) {</p>
<p>// Randomly select an element to work on: int element = rand.nextInt(N_ELEMENTS); for(int i = 0; i &lt; N_GENES; i++) { int previous = element - 1; if(previous &lt; 0) previous = N_ELEMENTS - 1; int next = element + 1; if(next &gt;= N_ELEMENTS) next = 0; int oldvalue = GRID[element][i].get();</p>
<p>// Perform some kind of modeling calculation: int newvalue = oldvalue +</p>
<p>GRID[previous][i].get() + GRID[next][i].get(); newvalue /= 3; // Average the three values if(!GRID[element][i]</p>
<p>.compareAndSet(oldvalue, newvalue)) {</p>
<p>// Policy here to deal with failure. Here, we // just report it and ignore it; our model // will eventually deal with it. print(&quot;Old value changed from &quot; + oldvalue);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; N_ELEMENTS; i++) for(int j = 0; j &lt; N_GENES; j++)</p>
<p>GRID[i][j] = new AtomicInteger(rand.nextInt(1000)); for(int i = 0; i &lt; N_EVOLVERS; i++) exec.execute(new Evolver());</p>
<p>TimeUnit.SECONDS.sleep(5);</p>
<p>exec.shutdownNow();</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>The elements are all placed inside an array with the assumption that this will help performance (this assumption will be tested in an exercise). Each Evolver object averages its value with the one before and after it, and if there’s a failure when it goes to update, it simply prints the value and goes on. Note that no mutexes appear in the program.</p>
<p>Exercise 39: (6) Does FastSimulation.java make reasonable assumptions? Try changing the array to ordinary ints instead of AtomicInteger and using Lock mutexes. Compare the performance between the two versions of the program.</p>
<subtitle>ReadWriteLocks</subtitle>
<p>ReadWriteLocks optimize the situation where you write to a data structure relatively infrequently, but multiple tasks read from it often. The ReadWriteLock allows you to have many readers at one time as long as no one is attempting to write. If the write lock is held, then no readers are allowed until the write lock is released.</p>
<p>It’s completely uncertain whether a ReadWriteLock will improve the performance of your program, and it depends on issues like how often data is being read compared to how often it is being modified, the time of the read and write operations (the lock is more complex, so short operations will not see the benefits), how much thread contention there is, and whether you are running on a multiprocessor machine. Ultimately, the only way to know whether a ReadWriteLock will benefit your program is to try it out.</p>
<p>Here’s an example showing only the most basic use of ReadWriteLocks:</p>
<p>//: concurrency/ReaderWriterList.java import java.util.concurrent.*; import java.util.concurrent.locks.*; import java.util.*;</p>
<p>import static net.mindview.util.Print.*; public class ReaderWriterList&lt;T&gt; {</p>
<p>private ArrayList&lt;T&gt; lockedList;</p>
<p>// Make the ordering fair: private ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true); public ReaderWriterList(int size, T initialValue) { lockedList = new ArrayList&lt;T&gt;(</p>
<p>Collections.nCopies(size, initialValue));</p>
<p>}</p>
<p>public T set(int index, T element) {</p>
<p>Lock wlock = lock.writeLock();</p>
<p>wlock.lock();</p>
<p>try {</p>
<p>return lockedList.set(index, element);</p>
<p>} finally {</p>
<p>wlock.unlock();</p>
<p>}</p>
<p>}</p>
<p>public T get(int index) {</p>
<p>Lock rlock = lock.readLock();</p>
<p>rlock.lock();</p>
<p>try {</p>
<p>// Show that multiple readers // may acquire the read lock: if(lock.getReadLockCount() &gt; 1) print(lock.getReadLockCount()); return lockedList.get(index);</p>
<p>} finally {</p>
<p>rlock.unlock();</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) throws Exception { new ReaderWriterListTest(30, 1);</p>
<p>}</p>
<p>}</p>
<p>class ReaderWriterListTest {</p>
<p>ExecutorService exec = Executors.newCachedThreadPool(); private final static int SIZE = 100; private static Random rand = new Random(47); private ReaderWriterList&lt;Integer&gt; list = new ReaderWriterList&lt;Integer&gt;(SIZE, 0); private class Writer implements Runnable { public void run() { try {</p>
<p>for(int i = 0; i &lt; 20; i++) { // 2 second test list.set(i, rand.nextInt()); TimeUnit.MILLISECONDS.sleep(100);</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>// Acceptable way to exit</p>
<p>}</p>
<p>print(&quot;Writer finished, shutting down&quot;); exec.shutdownNow();</p>
<p>}</p>
<p>}</p>
<p>private class Reader implements Runnable { public void run() { try {</p>
<p>while(!Thread.interrupted()) { for(int i = 0; i &lt; SIZE; i++) { list.get(i);</p>
<p>TimeUnit.MILLISECONDS.sleep(1);</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>// Acceptable way to exit</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public ReaderWriterListTest(int readers, int writers) { for(int i = 0; i &lt; readers; i++) exec.execute(new Reader()); for(int i = 0; i &lt; writers; i++) exec.execute(new Writer());</p>
<p>}</p>
<p>} /* (Execute to see output) *///:~</p>
<p>A ReaderWriterList can hold a fixed number of any type. You must give the constructor the desired size of the list and an initial object to populate the list with. The set( ) method acquires the write lock in order to call the underlying ArrayList. set( ), and the get( ) method acquires the read lock in order to call ArrayList.get( ). In addition, get( ) checks to see if more than one reader has acquired the read lock and, if so, displays that number to demonstrate that multiple readers may acquire the read lock.</p>
<p>To test the ReaderWriterList, ReaderWriterListTest creates both reader and writer tasks for a ReaderWriterList&lt;Integer&gt;. Notice that there are far fewer writes than reads.</p>
<p>If you look at the JDK documentation for ReentrantReadWriteLock, you’ll see that there are a number of other methods available, as well as issues of &quot;fairness&quot; and &quot;policy decisions.&quot; This is a rather sophisticated tool, and one to use only when you are casting about for ways to improve performance. Your first draft of your program should use straightforward synchronization, and only if necessary should you introduce ReadWriteLock.</p>
<p>Exercise 40: (6) Following the example of ReaderWriterList.java, create a ReaderWriterMap using a HashMap. Investigate its performance by modifying MapComparisons.java. How does it compare to a synchronized HashMap and a ConcurrentHashMap?</p>
</section>
<section>
<title>
<p>Active objects</p></title><empty-line/>
<p>After working your way through this chapter, you may observe that threading in Java seems very complex and difficult to use correctly. In addition, it can seem a bit counterproductive— although tasks work in parallel, you must invest great effort to implement techniques that prevent those tasks from interfering with each other.</p>
<p>If you’ve ever written assembly language, writing threaded programs has a similar feel: Every detail matters, you’re responsible for everything, and there’s no safety net in the form of compiler checking.</p>
<p>Could there be a problem with the threading model itself? After all, it comes relatively unchanged from the world of procedural programming. Perhaps there is a different model for concurrency that is a better fit for objectoriented programming.</p>
<p>One alternative approach is called active objects or actors.<a l:href="#bookmark133" type="note"><sup>134</sup></a><sup></sup>The reason the objects are called &quot;active&quot; is that each object maintains its own worker thread and message queue, and all requests to that object are enqueued, to be run one at a time. So with active objects, we</p>
<p>serialize messages rather than methods, which means we no longer need to guard against problems that happen when a task is interrupted midway through its loop.</p>
<p>When you send a message to an active object, that message is transformed into a task that goes on the object’s queue to be run at some later point. The Java SE5 Future comes in handy for implementing this scheme. Here’s a simple example that has two methods which enqueue method calls:</p>
<p>//: concurrency/ActiveObjectDemo.java</p>
<p>// Can only pass constants, immutables, &quot;disconnected</p>
<p>// objects,&quot; or other active objects as arguments</p>
<p>// to asynch methods.</p>
<p>import java.util.concurrent.*;</p>
<p>import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>public class ActiveObjectDemo { private ExecutorService ex =</p>
<p>Executors.newSingleThreadExecutor(); private Random rand = new Random(47);</p>
<p>// Insert a random delay to produce the effect // of a calculation time: private void pause(int factor) { try {</p>
<p>TimeUnit.MILLISECONDS.sleep(</p>
<p>100 + rand.nextInt(factor));</p>
<p>} catch(InterruptedException e) { print(&quot;sleep() interrupted&quot;);</p>
<p>}</p>
<p>}</p>
<p>public Future&lt;Integer&gt;</p>
<p>calculateInt(final int x, final int y) { return ex.submit(new Callable&lt;Integer&gt;() { public Integer call() {</p>
<p>print(&quot;starting &quot; + x + &quot; + &quot; + y);</p>
<p>pause(500);</p>
<p>return x + y;</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>public Future&lt;Float&gt;</p>
<p>calculateFloat(final float x, final float y) { return ex.submit(new Callable&lt;Float&gt;() { public Float call() {</p>
<p>print(&quot;starting &quot; + x + &quot; + &quot; + y);</p>
<p>pause(2000);</p>
<p>return x + y;</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>public void shutdown() { ex.shutdown(); } public static void main(String[] args) {</p>
<p>ActiveObjectDemo d1 = new ActiveObjectDemo();</p>
<p>// Prevents ConcurrentModificationException:</p>
<p>List&lt;Future&lt;?&gt;&gt; results =</p>
<p>new CopyOnWriteArrayList&lt;Future&lt;?&gt;&gt;(); for(float f = 0.0f; f &lt; 1.0f; f += 0.2f) results.add(d1.calculateFloat(f, f)); for(int i = 0; i &lt; 5; i++)</p>
<p>results.add(d1.calculateInt(i, i)); print(&quot;All asynch calls made&quot;); while(results.size() &gt; 0) {</p>
<p>for(Future&lt;?&gt; f : results) if(f.isDone()) { try {</p>
<p>print(f.get());</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>results.remove(f);</p>
<p>}</p>
<p>}</p>
<p>d1.shutdown();</p>
<table>
<tr><th colspan="5">}} /* Output: (85% match)</th></tr>
<tr><td colspan="2">All asynch</td><td colspan="3">calls made</td></tr>
<tr><td>starting</td><td>0.</td><td>0</td><td>+</td><td>0.0</td></tr>
<tr><td>starting0.0</td><td>0.</td><td>2</td><td>+</td><td>0.2</td></tr>
<tr><td>starting0.4</td><td>0.</td><td>4</td><td>+</td><td>0.4</td></tr>
<tr><td>starting0.8</td><td>0.</td><td>6</td><td>+</td><td>0.6</td></tr>
<tr><td>starting1.2</td><td>0.</td><td>8</td><td>+</td><td>0.8</td></tr>
<tr><td>starting1.6</td><td>0</td><td>+</td><td>0</td><td></td></tr>
<tr><td>starting0</td><td>1</td><td>+</td><td>1</td><td></td></tr>
<tr><td>starting2</td><td>2</td><td>+</td><td>2</td><td></td></tr>
<tr><td>starting4</td><td>3</td><td>+</td><td>3</td><td></td></tr>
<tr><td>starting</td><td>4</td><td>+</td><td>4</td><td></td></tr>
<tr><td colspan="5">68*///:~</td></tr>
</table>
<p>The &quot;single thread executor&quot; produced by the call to</p>
<p>Executors.newSingleThreadExecutor( ) maintains its own unbounded blocking queue, and has only one thread taking tasks off the queue and running them to completion. All we need to do in calculateInt( ) and calculateFloat( ) is to submit( ) a new Callable object in response to a method call, thus converting method calls into messages. The method body is contained within the call( ) method in the anonymous inner class. Notice that the return value of each active object method is a Future with a generic parameter that is the actual return type of the method. This way, the method call returns almost immediately, and the caller uses the Future to discover when the task completes and to collect the actual return value. This handles the most complex case, but if the call has no return value, then the process is simplified.</p>
<p>In main( ), a List&lt;Future&lt;?&gt;&gt; is created to capture the Future objects returned by the calculateFloat( ) and calculateInt( ) messages sent to the active object. This list is polled using isDone( ) for each Future, which is removed from the List when it completes and its results are processed. Notice that the use of CopyOnWriteArrayList removes the need to copy the List in order to prevent ConcurrentModificationExceptions.</p>
<p>In order to inadvertently prevent coupling between threads, any arguments to pass to an active-object method call must be either read-only, other active objects, or disconnected objects (my term), which are objects that have no connection to any other task (this is hard to enforce because there’s no language support for it).</p>
<p>With active objects:</p>
<p>1.    Each object has its own worker thread.</p>
<p>2.    Each object maintains total control of its own fields (which is somewhat more rigorous than normal classes, which only have the option of guarding their fields).</p>
<p>3.    All communication between active objects happens in the form of messages between those objects.</p>
<p>4.    All messages between active objects are enqueued.</p>
<p>The results are quite compelling. Since a message from one active object to another can only be blocked by the delay in enqueuing it, and because that delay is always very short and is not dependent on any other objects, the sending of a message is effectively unblockable (the worst that will happen is a short delay). Since an active-object system only communicates via messages, two objects cannot be blocked while contending to call a method on another object, and this means that deadlock cannot occur, which is a big step forward. Because the worker thread within an active object only executes one message at a time, there is no resource contention and you don’t have to worry about synchronizing methods. Synchronization still happens, but it happens on the message level, by enqueuing the method calls so that only one can happen at a time.</p>
<p>Unfortunately, without direct compiler support, the coding approach shown above is too cumbersome. However, progress is occurring in the field of active objects and actors, and more interestingly, in the field called agent-based programming. Agents are effectively active objects, but agent systems also support transparency across networks and machines. It would not surprise me if agent-based programming becomes the eventual successor to objectoriented programming, because it combines objects with a relatively easy concurrency solution.</p>
<p>You can find more information about active objects, actors and agents by searching the Web. In particular, some of the ideas behind active objects come from C.A.R. Hoare’s theory of Communicating Sequential Processes (CSP).</p>
<p>Exercise 41: (6) Add a message handler to ActiveObjectDemo.java that has no return value, and call this within main( ).</p>
<p>Exercise 42: (7) Modify WaxOMatic.java so that it implements active objects.</p>
<p>Project:<sup>27</sup> Use annotations and Javassist to create a class annotation @Active that transforms the target class into an active object.</p>
<p><sup>27</sup> Projects are suggestions to be used (for example) as term projects. Solutions to projects are not included in the solution guide.</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>The goal of this chapter was to give you the foundations of concurrent programming with Java threads, so that you understand that:</p>
<p>1.    You can run multiple independent tasks.</p>
<p>2.    You must consider all the possible problems when these tasks shut down.</p>
<p>3.    Tasks can interfere with each other over shared resources. The mutex (lock) is the basic tool used to prevent these collisions.</p>
<p>4.    Tasks can deadlock if they are not carefully designed.</p>
<p>It is vital to learn when to use concurrency and when to avoid it. The main reasons to use it are:</p>
<p>•    To manage a number of tasks whose intermingling will use the computer more efficiently (including the ability to transparently distribute the tasks across multiple CPUs).</p>
<p>•    To allow better code organization.</p>
<p>•    To be more convenient for the user.</p>
<p>The classic example of resource balancing is to use the CPU during I/O waits. Better code organization is typically seen in simulations. The classic example of user convenience is to monitor a &quot;stop&quot; button during long downloads.</p>
<p>An additional advantage to threads is that they provide &quot;light&quot; execution context switches (on the order of 100 instructions) rather than &quot;heavy&quot; process context switches (thousands of instructions). Since all threads in a given process share the same memory space, a light context switch changes only program execution and local variables. A process change—the heavy context switch—must exchange the full memory space.</p>
<p>The main drawbacks to multithreading are:</p>
<p>1.    Slowdown occurs while threads are waiting for shared resources.</p>
<p>2.    Additional CPU overhead is required to manage threads.</p>
<p>3.    Unrewarded complexity arises from poor design decisions.</p>
<p>4.    Opportunities are created for pathologies such as starving, racing, deadlock, and livelock (multiple threads working individual tasks that the ensemble can’t finish).</p>
<p>5.    Inconsistencies occur across platforms. For instance, while developing some of the examples for this book, I discovered race conditions that quickly appeared on some computers but that wouldn’t appear on others. If you develop a program on the latter, you might get badly surprised when you distribute it.</p>
<p>One of the biggest difficulties with threads occurs because more than one task might be sharing a resource—such as the memory in an object—and you must make sure that multiple tasks don’t try to read and change that resource at the same time. This requires judicious use of the available locking mechanisms (for example, the synchronized keyword). These are essential tools, but they must be understood thoroughly because they can quietly introduce deadlock situations.</p>
<p>In addition, there’s an art to the application of threads. Java is designed to allow you to create as many objects as you need to solve your problem—at least in theory. (Creating millions of objects for an engineering finite-element analysis, for example, might not be practical in Java without the use of the Flyweight design pattern.) However, it seems that there is an upper bound to the number of threads you’ll want to create, because at some number, threads seem to become balky. This critical point can be hard to detect and will often depend on the OS and JVM; it can be less than a hundred or in the thousands. As you will often create only a handful of threads to solve a problem, this is typically not much of a limit, but in a more general design it becomes a constraint that might force you to add a cooperative concurrency scheme.</p>
<p>Regardless of how simple threading can seem using a particular language or library, consider it a black art. There’s always something that can bite you when you least expect it. The reason that the dining philosophers problem is interesting is that it can be adjusted so that deadlock rarely happens, giving you the impression that everything is copacetic.</p>
<p>In general, use threading carefully and sparingly. If your threading issues get large and complex, consider using a language like Erlang. This is one of several functional languages that are specialized for threading. It may be possible to use such a language for the portions of your program that demand threading, if you are doing lots of it, and if it’s complicated enough to justify this approach.</p>
<subtitle>Further reading</subtitle>
<p>Unfortunately, there is a lot of misleading information about concurrency— this emphasizes how confusing it can be, and how easy it is to think that you understand the issues (I know, because I’ve been under the impression that I’ve understood threading numerous times in the past, and I have no doubt that there will be more epiphanies for me in the future). There’s always a bit of sleuthing required when you pick up a new document about concurrency, to try to understand how much the writer does and doesn’t understand. Here are some books that I think I can safely say are reliable:</p>
<p>Java Concurrency in Practice, by Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea (Addison-Wesley, 2006). Basically, the &quot;who’s who&quot; in the Java threading world.</p>
<p>Concurrent Programming in Java, Second Edition, by Doug Lea (Addison-Wesley, 2000). Although this book significantly predates Java SE5, much of Doug’s work became the new java.util.concurrent libraries, so this book is essential for a complete understanding of concurrency issues. It goes beyond Java concurrency and discusses current thinking across languages and technologies. Although it can be obtuse in places, it merits rereading several times (preferably with months in between in order to internalize the information). Doug is one of the few people in the world who actually understand concurrency, so this is a worthwhile endeavor.</p>
<p>The Java Language Specification, Third Edition (Chapter 17), by Gosling, Joy,</p>
<p>Steele, and Bracha (Addison-Wesley, 2005). The technical specification, conveniently available as an electronic document: <a l:href="http://java.sun.com/docs/books/jls">http://java.sun.com/docs/books/jls</a>.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Graphical User Interfaces</p></title><empty-line/>
<p>A fundamental design guideline is &quot;Make simple things easy, and difficult things possible.&quot;<sup>1</sup></p>
<p>The original design goal of the graphical user interface (GUI) library in Java l.o was to allow the programmer to build a GUI that looks good on all platforms. That goal was not achieved. Instead, the Java l.o Abstract Windowing Toolkit (AWT) produced a GUI that looked equally mediocre on all systems. In addition, it was restrictive; you could use only four fonts and you couldn’t access any of the more sophisticated GUI elements that exist in your operating system. The Java 1.0 AWT programming model was also awkward and non-object-oriented. A student in one of my seminars (who had been at Sun during the creation of Java) explained why: The original AWT had been conceived, designed, and implemented in a month. Certainly a marvel of productivity, and also an object lesson in why design is important.</p>
<p>The situation improved with the Java 1.1 AWT event model, which takes a much clearer, object-oriented approach, along with the addition of JavaBeans, a component programming model that is oriented toward the easy creation of visual programming environments. Java 2 (JDK 1.2) finished the transformation away from the old Java 1.0 AWT by essentially replacing everything with the Java Foundation Classes (JFC), the GUI portion of which is called &quot;Swing.&quot; These are a rich set of easy-to-use, easy-to-understand JavaBeans that can be dragged and dropped (as well as hand programmed) to create a reasonable GUI. The &quot;revision 3&quot; rule of the software industry (a product isn’t good until revision 3) seems to hold true with programming languages as well.</p>
<p>This chapter introduces the modern Java Swing library and makes the reasonable assumption that Swing is Sun’s final destination GUI library for Java.<a l:href="#bookmark134" type="note"><sup>135</sup></a><sup> <a l:href="#bookmark135" type="note"><sup>136</sup></a></sup> If for some reason you need to use the original &quot;old&quot; AWT (because you’re supporting old code or you have browser limitations), you can find that introduction in the 1st edition of this book, downloadable at <a l:href="http://www.MindView.net">www.MindView.net</a>. Note that some AWT components remain in Java, and in some situations you must use them.</p>
<p>Please be aware that this is not a comprehensive glossary of either all the Swing components or all the methods for the described classes. What you see here is intended to be a simple introduction. The Swing library is vast, and the goal of this chapter is only to get you started with the essentials and comfortable with the concepts. If you need to do more than what you see here, then Swing can probably give you what you want if you’re willing to do the research.</p>
<p>I assume here that you have downloaded and installed the JDK documentation from <a l:href="http://java.sun.com">http://java.sun.com</a> and will browse the javax.swing classes in that documentation to see the full details and methods of the Swing library. You can also search the Web, but the best place to start is Sun’s own Swing Tutorial at <a l:href="http://java.sun.com/docs/books/tutorial/uiswing">http://java.sun.com/docs/books/tutorial/uiswing</a>.</p>
<p>There are numerous (rather thick) books dedicated solely to Swing, and you’ll want to go to those if you need more depth, or if you want to modify the default Swing behavior.</p>
<p>As you learn about Swing, you’ll discover:</p>
<p>1.    Swing is a much improved programming model compared to many other languages and development environments (not to suggest that it’s perfect, but a step forward on the path). JavaBeans (introduced toward the end of this chapter) is the framework for that library.</p>
<p>2.    &quot;GUI builders&quot; (visual programming environments) are a de rigueur aspect of a complete Java development environment. JavaBeans and Swing allow the GUI builder to write code for you as you place components onto forms using graphical tools. This rapidly speeds development during GUI building, and also allows for greater experimentation and thus the ability to try out more designs and presumably come up with better ones.</p>
<p>3.    Because Swing is reasonably straightforward, even if you do use a GUI builder rather than coding by hand, the resulting code should still be comprehensible. This solves a big problem with GUI builders from the past, which could easily generate unreadable code.</p>
<p>Swing contains all the components that you expect to see in a modern UI: everything from buttons that contain pictures to trees and tables. It’s a big library, but it’s designed to have appropriate complexity for the task at hand; if something is simple, you don’t have to write much code, but as you try to do more complex things, your code becomes proportionally more complex.</p>
<p>Much of what you’ll like about Swing might be called &quot;orthogonality of use.&quot; That is, once you pick up the general ideas about the library, you can usually apply them everywhere. Primarily because of the standard naming conventions, while I was writing these examples I could usually guess successfully at the method names. This is certainly a hallmark of good library design. In addition, you can generally plug components into other components and things will work correctly.</p>
<p>Keyboard navigation is automatic; you can run a Swing application without using the mouse, and this doesn’t require any extra programming. Scrolling support is effortless; you simply wrap your component in a JScrollPane as you add it to your form. Features such as tool tips typically require a single line of code to use.</p>
<p>For portability, Swing is written entirely in Java.</p>
<p>Swing also supports a rather radical feature called &quot;pluggable look and feel,&quot; which means that the appearance of the UI can be dynamically changed to suit the expectations of users working under different platforms and operating systems. It’s even possible (albeit difficult) to invent your own look and feel. You can find some of these on the Web.<a l:href="#bookmark136" type="note"><sup>137</sup></a><sup></sup></p>
<p>Despite all of its positive aspects, Swing is not for everyone nor has it solved all the user interface problems that its designers intended. At the end of the chapter, we’ll look at two alternative solutions to Swing: the IBM-sponsored SWT, developed for the Eclipse editor but freely available as an open-source, standalone GUI library, and Macromedia’s Flex tool for developing Flash client-side front ends for Web applications.</p>
<section>
<title>
<p>Applets</p></title><empty-line/>
<p>When Java first appeared, much of the brouhaha around the language came from the applet, a program that can be delivered across the Internet to run (inside a so-called sandbox, for security) in a Web browser. People foresaw the Java applet as the next stage in the evolution of the Internet, and many of the original books on Java assumed that the reason you were interested in the language was that you wanted to write applets.</p>
<p>For various reasons, this revolution never happened. A large part of the problem was that most machines don’t include the necessary Java software to run applets, and downloading and installing a 10 MB package in order to run something you’ve casually encountered on the Web is not something most users are willing to do. Many users are even frightened by the idea. Java applets as a client-side application delivery system never achieved critical mass, and although you will still occasionally see an applet, they have generally been relegated to the backwaters of computing.</p>
<p>This doesn’t mean that applets are not an interesting and valuable technology. If you are in a situation where you can ensure that users have a JRE installed (such as inside a corporate environment), then applets (or JNLP/Java Web Start, described later in this chapter) might be the perfect way to distribute client programs and automatically update everyone’s machine without the usual cost and effort of distributing and installing new software.</p>
<p>You’ll find an introduction to the technology of applets in the online supplements to this book at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
<section>
<title>
<p>Swing basics</p></title><empty-line/>
<p>Most Swing applications will be built inside a basic JFrame, which creates the window in whatever operating system you’re using. The title of the window can be set using the JFrame constructor, like this:</p>
<p>//: gui/HelloSwing.java import javax.swing.*;</p>
<p>public class HelloSwing {</p>
<p>public static void main(String[] args) {</p>
<p>JFrame frame = new JFrame(&quot;Hello Swing&quot;); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(300, 100); frame.setVisible(true);</p>
<p>}</p>
<p>} ///:~</p>
<p>setDefaultCloseOperation( ) tells the JFrame what to do when the user executes a shutdown maneuver. The EXIT_ON_CLOSE constant tells it to exit the program. Without this call, the default behavior is to do nothing, so the application wouldn’t close.</p>
<p>setSize( ) sets the size of the window in pixels.</p>
<p>Notice the last line:</p>
<p>frame.setVisible(true);</p>
<p>Without this, you won’t see anything on the screen.</p>
<p>We can make things a little more interesting by adding a JLabel to the JFrame:</p>
<p>//: gui/HelloLabel.java import javax.swing.*; import java.util.concurrent.*;</p>
<p>public class HelloLabel {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>JFrame frame = new JFrame(&quot;Hello Swing&quot;);</p>
<p>JLabel label = new JLabel(&quot;A Label&quot;); frame.add(label);</p>
<p>frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</p>
<p>frame.setSize(300, 100);</p>
<p>frame.setVisible(true);</p>
<p>TimeUnit.SECONDS.sleep(l); label.setText(&quot;Hey! This is Different!&quot;);</p>
<p>}</p>
<p>} ///:~</p>
<p>After one second, the text of the JLabel changes. While this is entertaining and safe for such a trivial program, it’s really not a good idea for the main( ) thread to write directly to the GUI components. Swing has its own thread dedicated to receiving UI events and updating the screen. If you start manipulating the screen with other threads, you can have the collisions and deadlock described in the Concurrency chapter.</p>
<p>Instead, other threads—like main( ), here—should submit tasks to be executed by the Swing event dispatch thread.<a l:href="#bookmark137" type="note"><sup>138</sup></a><sup></sup> You do this by handing a task to SwingUtilities.invokeLater( ), which puts it on the event queue to be (eventually) executed by the event dispatch thread. If we do this with the previous example, it looks like this:</p>
<p>//: gui/SubmitLabelManipulationTask.java</p>
<p>import javax.swing.*;</p>
<p>import java.util.concurrent.*;</p>
<p>public class SubmitLabelManipulationTask {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>JFrame frame = new JFrame(&quot;Hello Swing&quot;); final JLabel label = new JLabel(&quot;A Label&quot;); frame.add(label);</p>
<p>frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</p>
<p>frame.setSize(300, 100);</p>
<p>frame.setVisible(true);</p>
<p>TimeUnit.SECONDS.sleep(l);</p>
<p>SwingUtilities.invokeLater(new Runnable() { public void run() {</p>
<p>label.setText(&quot;Hey! This is Different!&quot;);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>} ///:~</p>
<p>Now you are no longer manipulating the JLabel directly. Instead, you submit a Runnable, and the event dispatch thread will do the actual manipulation, when it gets to that task in the event queue. And when it’s executing this Runnable, it’s not doing anything else, so there won’t be any collisions—if all the code in your program follows this approach of submitting manipulations through SwingUtilities.invokeLater( ). This includes starting the program itself—main( ) should not call the Swing methods as it does in the above program, but instead should submit a task to the event queue.<a l:href="#bookmark138" type="note"><sup>139</sup></a><sup></sup> So the properly written program will look something like this:</p>
<p>//: gui/SubmitSwingProgram.java</p>
<p>import javax.swing.*;</p>
<p>import java.util.concurrent.*;</p>
<p>public class SubmitSwingProgram extends JFrame {</p>
<p>JLabel label;</p>
<p>public SubmitSwingProgram() { super(&quot;Hello Swing&quot;); label = new JLabel(&quot;A Label&quot;); add(label);</p>
<p>setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</p>
<p>setSize(300, 100);</p>
<p>setVisible(true);</p>
<p>}</p>
<p>static SubmitSwingProgram ssp;</p>
<p>public static void main(String[] args) throws Exception { SwingUtilities.invokeLater(new Runnable() {</p>
<p>public void run() { ssp = new SubmitSwingProgram(); }</p>
<p>});</p>
<p>TimeUnit.SECONDS.sleep(l);</p>
<p>SwingUtilities.invokeLater(new Runnable() { public void run() {</p>
<p>ssp.label.setText(&quot;Hey! This is Different!&quot;);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>} ///:~</p>
<p>Notice that the call to sleep( ) is not inside the constructor. If you put it there, the original JLabel text never appears, for one thing, because the constructor doesn’t complete until after the sleep( ) finishes and the new label is inserted. But if sleep( ) is inside the constructor, or inside any UI operation, it means that you’re halting the event dispatch thread during the sleep( ), which is generally a bad idea.</p>
<p>Exercise 1: (1) Modify HelloSwing.java to prove to yourself that the application will not close without the call to setDefaultCloseOperation( ).</p>
<p>Exercise 2: (2) Modify HelloLabel.java to show that label addition is dynamic, by adding a random number of labels.</p>
<subtitle>A display framework</subtitle>
<p>We can combine the ideas above and reduce redundant code by creating a display framework for use in the Swing examples in the rest of this chapter:</p>
<p>//: net/mindview/util/SwingConsole.java // Tool for running Swing demos from the // console, both applets and JFrames. package net.mindview.util; import javax.swing.*;</p>
<p>public class SwingConsole { public static void</p>
<p>run(final JFrame f, final int width, final int height) { SwingUtilities.invokeLater(new Runnable() { public void run() {</p>
<p>f.setTitle(f.getClass().getSimpleName()); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setSize(width, height); f.setVisible(true);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>} ///:~</p>
<p>This is a tool you may want to use yourself, so it’s placed in the library net.mindview.util. To use it, your application must be in a JFrame (which all the examples in this book are). The static run( ) method sets the title of the window to the simple class name of the JFrame.</p>
<p>Exercise 3: (3) Modify SubmitSwingProgram.java so that it uses SwingConsole.</p>
</section>
<section>
<title>
<p>Making a button</p></title><empty-line/>
<p>Making a button is quite simple: You just call the JButton constructor with the label you want on the button. You’ll see later that you can do fancier things, like putting graphic images on buttons.</p>
<p>Usually, you’ll want to create a field for the button inside your class so that you can refer to it later.</p>
<p>The JButton is a component—its own little window—that will automatically get repainted as part of an update. This means that you don’t explicitly paint a button or any other kind of control; you simply place them on the form and let them automatically take care of painting themselves. You’ll usually place a button on a form inside the constructor:</p>
<p>//: gui/Buttonl.java</p>
<p>// Putting buttons on a Swing application. import javax.swing.*; import java.awt.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class Buttonl extends JFrame { private JButton</p>
<p>bl = new JButton(&quot;Button 1&quot;), b2 = new JButton(&quot;Button 2&quot;); public Button1() {</p>
<p>setLayout(new FlowLayout());</p>
<p>add(bl);</p>
<p>add(b2);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new Button1(), 200, 100);</p>
<p>}</p>
<p>} ///:~</p>
<p>Something new has been added here: Before any elements are placed on the JFrame, it is given a &quot;layout manager,&quot; of type FlowLayout. The layout manager is the way that the pane implicitly decides where to place controls on a form. The normal behavior of a JFrame is to use the BorderLayout, but that won’t work here because (as you will learn later in this chapter) it defaults to covering each control entirely with every new one that is added.</p>
<p>However, FlowLayout causes the controls to flow evenly onto the form, left to right and top to bottom.</p>
<p>Exercise 4: (1) Verify that without the setLayout( ) call in Buttoni.java, only one button will appear in the resulting program.</p>
</section>
<section>
<title>
<p>Capturing an event</p></title><empty-line/>
<p>If you compile and run the preceding program, nothing happens when you press the buttons. This is where you must step in and write some code to determine what will happen. The basis of event-driven programming, which comprises a lot of what a GUI is about, is connecting events to the code that responds to those events.</p>
<p>The way this is accomplished in Swing is by cleanly separating the interface (the graphical components) from the implementation (the code that you want to run when an event happens to a component). Each Swing component can report all the events that might happen to it, and it can report each kind of event individually. So if you’re not interested in, for example, whether the mouse is being moved over your button, you don’t register your interest in that event. It’s a very straightforward and elegant way to handle event-driven programming, and once you understand the basic concepts, you can easily use Swing components that you haven’t seen before—in fact, this model extends to anything that can be classified as a JavaBean (discussed later in the chapter).</p>
<p>At first, we will just focus on the main event of interest for the components being used. In the case of a JButton, this &quot;event of interest&quot; is that the button is pressed. To register your interest in a button press, you call the JButton’s addActionListener( ) method. This method expects an argument that is an object that implements the ActionListener interface. That interface contains a single method called actionPerformed( ). So to attach code to a JButton, implement the ActionListener interface in a class, and register an object of that class with the JButton via addActionListener( ). The actionPerformed( ) method will then be called when the button is pressed (this is normally referred to as a callback).</p>
<p>But what should the result of pressing that button be? We’d like to see something change on the screen, so a new Swing component will be introduced: the JTextField. This is a place where text can be typed by the end user or, in this case, inserted by the program. Although there are a number of ways to create a JTextField, the simplest is just to tell the constructor how wide you want that field to be. Once the JTextField is placed on the form, you can modify its contents by using the setText( ) method (there are many other methods in JTextField, but you must look these up in the JDK documentation from <a l:href="http://java.sun.com">http://java.sun.com</a>). Here is what it looks like:</p>
<p>//: gui/Button2.java // Responding to button presses. import javax.swing.*; import java.awt.*; import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class Button2 extends JFrame { private JButton</p>
<p>b1 = new JButton(&quot;Button 1&quot;), b2 = new JButton(&quot;Button 2&quot;); private JTextField txt = new JTextField(10); class ButtonListener implements ActionListener { public void actionPerformed(ActionEvent e) {</p>
<p>String name = ((JButton)e.getSource()).getText(); txt.setText(name);</p>
<p>}</p>
<p>private ButtonListener bl = new ButtonListener();</p>
<p>public Button2() {</p>
<p>bl.addActionListener(bl);</p>
<p>b2.addActionListener(bl);</p>
<p>setLayout(new FlowLayout());</p>
<p>add(bl);</p>
<p>add(b2);</p>
<p>add(txt);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new Button2(), 200, 150);</p>
<p>}</p>
<p>} ///:~</p>
<p>Creating a JTextField and placing it on the canvas takes the same steps as for JButtons or for any Swing component. The difference in the preceding program is in the creation of the aforementioned ActionListener class ButtonListener. The argument to actionPerformed( ) is of type ActionEvent, which contains all the information about the event and where it came from. In this case, I wanted to describe the button that was pressed; getSource( ) produces the object where the event originated, and I assumed (using a cast) that the object is a JButton. getText( ) returns the text that’s on the button, and this is placed in the JTextField to prove that the code was actually called when the button was pressed.</p>
<p>In the constructor, addActionListener( ) is used to register the ButtonListener object with both the buttons.</p>
<p>It is often more convenient to code the ActionListener as an anonymous inner class, especially since you tend to use only a single instance of each listener class. Button2.java can be modified to use an anonymous inner class as follows:</p>
<p>//: gui/Button2b.java</p>
<p>// Using anonymous inner classes.</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class Button2b extends JFrame {</p>
<p>private JButton</p>
<p>bl = new JButton(&quot;Button 1&quot;), b2 = new JButton(&quot;Button 2&quot;);</p>
<p>private JTextField txt = new JTextField(10);</p>
<p>private ActionListener bl = new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>String name = ((JButton)e.getSource()).getText(); txt.setText(name);</p>
<p>}</p>
<p>};</p>
<p>public Button2b() {</p>
<p>bl.addActionListener(bl);</p>
<p>b2.addActionListener(bl);</p>
<p>setLayout(new FlowLayout());</p>
<p>add(bl);</p>
<p>add(b2);</p>
<p>add(txt);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new Button2b(), 200, l50);</p>
<p>} ///:~</p>
<p>The approach of using an anonymous inner class will be preferred (when possible) for the examples in this book.</p>
<p>Exercise 5: (4) Create an application using the SwingConsole class. Include one text field and three buttons. When you press each button, make different text appear in the text field.</p>
</section>
<section>
<title>
<p>Text areas</p></title><empty-line/>
<p>A JTextArea is like a JTextField except that it can have multiple lines and has more functionality. A particularly useful method is append( ); with this you can easily pour output into the JTextArea. Because you can scroll backwards, this is an improvement over command-line programs that print to standard output. As an example, the following program fills a JTextArea with the output from the Countries generator in the Containers in Depth chapter:</p>
<p>//: gui/TextArea.java</p>
<p>// Using the JTextArea control.</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class TextArea extends JFrame { private JButton</p>
<p>b = new JButton(&quot;Add Data&quot;), c = new JButton(&quot;Clear Data&quot;); private JTextArea t = new JTextArea(20, 40); private Map&lt;String,String&gt; m = new HashMap&lt;String,String&gt;(); public TextArea() {</p>
<p>// Use up all the data: m.putAll(Countries.capitals());</p>
<p>b. addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>for(Map.Entry me : m.entrySet())</p>
<p>t.append(me.getKey() + &quot;: &quot;+ me.getValue()+&quot;\n&quot;);</p>
<p>}</p>
<p>});</p>
<p>c. addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>t.setText(&quot;&quot;);</p>
<p>}</p>
<p>});</p>
<p>setLayout(new FlowLayout()); add(new JScrollPane(t)); add(b); add(c);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new TextArea(), 475, 425);</p>
<p>}</p>
<p>} ///:~</p>
<p>In the constructor, the Map is filled with all the countries and their capitals. Note that for both buttons, the ActionListener is created and added without defining an intermediate variable, since you never need to refer to that listener again during the program. The &quot;Add Data&quot; button formats and appends all the data, and the &quot;Clear Data&quot; button uses setText( ) to remove all the text from the JTextArea.</p>
<p>As the JTextArea is added to the JFrame, it is wrapped in a JScrollPane to control scrolling when too much text is placed on the screen. That’s all you must do in order to produce full scrolling capabilities. Having tried to figure out how to do the equivalent in some other GUI programming environments, I am very impressed with the simplicity and good design of components like JScrollPane.</p>
<p>Exercise 6: (7) Turn strings/TestRegularExpression.java into an interactive Swing program that allows you to put an input string in one JTextArea and a regular expression in a JTextField. The results should be displayed in a second JTextArea.</p>
<p>Exercise 7: (5) Create an application using SwingConsole, and add all the Swing components that have an addActionListener( ) method. (Look these up in the JDK documentation from <a l:href="http://java.sun.com">http://java.sun.com</a>. Hint: Search for addActionListener( ) using the index.) Capture their events and display an appropriate message for each inside a text field.</p>
<p>Exercise 8: (6) Almost every Swing component is derived from Component, which has a setCursor( ) method. Look this up in the JDK documentation. Create an application and change the cursor to one of the stock cursors in the Cursor class.</p>
</section>
<section>
<title>
<p>Controlling layout</p></title><empty-line/>
<p>The way that you place components on a form in Java is probably different from any other GUI system you’ve used. First, it’s all code; there are no &quot;resources&quot; that control placement of components. Second, the way components are placed on a form is controlled not by absolute positioning but by a &quot;layout manager&quot; that decides how the components lie based on the order that you add( ) them. The size, shape, and placement of components will be remarkably different from one layout manager to another. In addition, the layout managers adapt to the dimensions of your applet or application window, so if the window dimension is changed, the size, shape, and placement of the components can change in response.</p>
<p>JApplet, JFrame, JWindow, JDialog, JPanel, etc., can all contain and display Components. In Container, there’s a method called setLayout( ) that allows you to choose a different layout manager. In this section we’ll explore the various layout managers by placing buttons in them (since that’s the simplest thing to do). These examples won’t capture the button events because they are only intended to show how the buttons are laid out.</p>
<subtitle>BorderLayout</subtitle>
<p>Unless you tell it otherwise, a JFrame will use BorderLayout as its default layout scheme. Without any other instruction, this takes whatever you add( ) to it and places it in the center, stretching the object all the way out to the edges.</p>
<p>BorderLayout has the concept of four border regions and a center area. When you add something to a panel that’s using a BorderLayout, you can use the overloaded add( ) method that takes a constant value as its first argument. This value can be any of the following:</p>
<table>
<tr><td>BorderLayout.NORTH</td><td>Top</td></tr>
<tr><td>BorderLayout.SOUTH</td><td>Bottom</td></tr>
<tr><td>BorderLayout.EAST</td><td>Right</td></tr>
<tr><td>BorderLayout.WEST</td><td>Left</td></tr>
<tr><td>BorderLayout.CENTER</td><td>Fill the middle, up to the other components or to the edges</td></tr>
</table>
<p>If you don’t specify an area to place the object, it defaults to CENTER.</p>
<p>In this example, the default layout is used, since JFrame defaults to BorderLayout:</p>
<p>//: gui/BorderLayout1.java // Demonstrates BorderLayout. import javax.swing.*; import java.awt.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class BorderLayout1 extends JFrame { public BorderLayout1() {</p>
<p>add(BorderLayout.NORTH, new JButton(&quot;North&quot;)); add(BorderLayout.SOUTH, new JButton(&quot;South&quot;)); add(BorderLayout.EAST, new JButton(&quot;East&quot;)); add(BorderLayout.WEST, new JButton(&quot;West&quot;)); add(BorderLayout.CENTER, new JButton(&quot;Center&quot;));</p>
<p>}</p>
<p>public static void main(String[] args) { run(new BorderLayout1(), 300, 250);</p>
<p>}</p>
<p>} ///:~</p>
<p>For every placement but CENTER, the element that you add is compressed to fit in the smallest amount of space along one dimension while it is stretched to the maximum along the other dimension. CENTER, however, spreads out in both dimensions to occupy the middle.</p>
<subtitle>FlowLayout</subtitle>
<p>This simply &quot;flows&quot; the components onto the form, from left to right until the top space is full, then moves down a row and continues flowing.</p>
<p>Here’s an example that sets the layout manager to FlowLayout and then places buttons on the form. You’ll notice that with FlowLayout, the components take on their &quot;natural&quot; size. A JButton, for example, will be the size of its string.</p>
<p>//: gui/FlowLayout1.java // Demonstrates FlowLayout. import javax.swing.*; import java.awt.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class FlowLayout1 extends JFrame { public FlowLayout1() {</p>
<p>setLayout(new FlowLayout()); for(int i = 0; i &lt; 20; i++)</p>
<p>add(new JButton(&quot;Button &quot; + i));</p>
<p>}</p>
<p>public static void main(String[] args) { run(new FlowLayout1(), 300, 300);</p>
<p>}</p>
<p>} ///:~</p>
<p>All components will be compacted to their smallest size in a FlowLayout, so you might get a little bit of surprising behavior. For example, because a JLabel will be the size of its string, attempting to right-justify its text yields an unchanged display when using FlowLayout.</p>
<p>Notice that if you resize the window, the layout manager will reflow the components accordingly.</p>
<p>GridLayout</p>
<p>A GridLayout allows you to build a table of components, and as you add them, they are placed left to right and top to bottom in the grid. In the constructor, you specify the number of rows and columns that you need, and these are laid out in equal proportions.</p>
<p>//: gui/GridLayoutl.java // Demonstrates GridLayout. import javax.swing.*; import java.awt.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class GridLayoutl extends JFrame { public GridLayout1() {</p>
<p>setLayout(new GridLayout(7,3)); for(int i = 0; i &lt; 20; i++)</p>
<p>add(new JButton(&quot;Button &quot; + i));</p>
<p>}</p>
<p>public static void main(String[] args) { run(new GridLayout1(), 300, 300);</p>
<p>}</p>
<p>} ///:~</p>
<p>In this case there are 21 slots but only 20 buttons. The last slot is left empty because no &quot;balancing&quot; goes on with a GridLayout.</p>
<p>GridBagLayout</p>
<p>The GridBagLayout provides you with tremendous control in deciding exactly how the regions of your window will lay themselves out and reformat themselves when the window is resized. However, it’s also the most complicated layout manager, and is quite difficult to understand. It is intended primarily for automatic code generation by a GUI builder (GUI builders might use GridBagLayout instead of absolute placement). If your design is so complicated that you feel you need to use GridBagLayout, then you should be using a GUI builder tool to generate that design. If you feel you must know the intricate details, I’ll refer you to one of the dedicated Swing books as a starting point.</p>
<p>As an alternative, you may want to consider TableLayout, which is not part of the Swing library but which can be downloaded from <a l:href="http://java.sun.com">http://java.sun.com</a>. This component is layered on top of GridBagLayout and hides most of its complexity, so it can greatly simplify this approach.</p>
<subtitle>Absolute positioning</subtitle>
<p>It is also possible to set the absolute position of the graphical components:</p>
<p>1.    Set a null layout manager for your Container: setLayout(null).</p>
<p>2.    Call setBounds( ) or reshape( ) (depending on the language version) for each component, passing a bounding rectangle in pixel coordinates. You can do this in the constructor or in paint( ), depending on what you want to achieve.</p>
<p>Some GUI builders use this approach extensively, but this is usually not the best way to generate code.</p>
<subtitle>BoxLayout</subtitle>
<p>Because people had so much trouble understanding and working with GridBagLayout, Swing also includes BoxLayout, which gives you many of the benefits of GridBagLayout without the complexity. You can often use it when you need to do hand-coded layouts (again, if your design becomes too complex, use a GUI builder that generates layouts for you). BoxLayout allows you to control the placement of components either vertically or horizontally, and to control the space between the components using something called &quot;struts and glue.&quot; You can find some basic examples of BoxLayout in the online supplements for this book at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<subtitle>The best approach?</subtitle>
<p>Swing is powerful; it can get a lot done with a few lines of code. The examples shown in this book are quite simple, and for learning purposes it makes sense to write them by hand. You can actually accomplish quite a bit by combining simple layouts. At some point, however, it stops making sense to hand-code GUI forms; it becomes too complicated and is not a good use of your programming time. The Java and Swing designers oriented the language and libraries to support GUI-building tools, which have been created for the express purpose of making your programming experience easier. As long as you understand what’s going on with layouts and how to deal with events (described next), it’s not particularly important that you actually know the details of how to lay out components by hand; let the appropriate tool do that for you (Java is, after all, designed to increase programmer productivity).</p>
</section>
<section>
<title>
<p>The Swing event model</p></title><empty-line/>
<p>In the Swing event model, a component can initiate (&quot;fire&quot;) an event. Each type of event is represented by a distinct class. When an event is fired, it is received by one or more &quot;listeners,&quot; which act on that event. Thus, the source of an event and the place where the event is handled can be separate. Since you typically use Swing components as they are, but need to write custom code that is called when the components receive an event, this is an excellent example of the separation of interface from implementation.</p>
<p>Each event listener is an object of a class that implements a particular type of listener interface. So as a programmer, all you do is create a listener object and register it with the component that’s firing the event. This registration is performed by calling an addXXXListener( ) method in the event-firing component, in which &quot;XXX&quot; represents the type of event listened for. You can easily know what types of events can be handled by noticing the names of the &quot;addListener&quot; methods, and if you try to listen for the wrong events, you’ll discover your mistake at compile time. You’ll see later in the chapter that</p>
<p>JavaBeans also use the names of the &quot;addListener&quot; methods to determine what events a Bean can handle.</p>
<p>All of your event logic, then, will go inside a listener class. When you create a listener class, the sole restriction is that it must implement the appropriate interface. You can create a global listener class, but this is a situation in which inner classes tend to be quite useful, not only because they provide a logical grouping of your listener classes inside the UI or business logic classes they are serving, but also because an inner-class object keeps a reference to its parent object, which provides a nice way to call across class and subsystem boundaries.</p>
<p>All the examples so far in this chapter have been using the Swing event model, but the remainder of this section will fill out the details of that model.</p>
<subtitle>Event and listener types</subtitle>
<p>All Swing components include addXXXListener( ) and removeXXXListener( )</p>
<p>methods so that the appropriate types of listeners can be added and removed from each component. You’ll notice that the &quot;XXX&quot; in each case also represents the argument for the method, for example, addMyListener(MyListener m). The following table includes the basic associated events, listeners, and methods, along with the basic components that support those particular events by providing the addXXXListener( ) and removeXXXListener( ) methods. You should keep in mind that the event model is designed to be extensible, so you may encounter other events and listener types that are not covered in this table.</p>
<table>
<tr><td>Event, listener interface, and add- and remove-methods</td><td>Components supporting this event</td></tr>
<tr><td>ActionEvent ActionListener addActionListener( ) removeActionListener( )</td><td>JButton, JList, JTextField, JMenuItem and its derivatives including JCheckBoxMenuItem, JMenu, andJRadioButtonMenuItem</td></tr>
<tr><td>AdjustmentEvent AdjustmentListener addAdjustmentListener( ) removeAdjustmentListener( )</td><td>JScrollbarand anything you create that implements the Adjustable interface</td></tr>
<tr><td>ComponentEvent ComponentListener addComponentListener( ) removeComponentListener( )</td><td>*Component and its derivatives, including JButton, JCheckBox, JComboBox, Container, JPanel, JApplet, JScrollPane, Window, JDialog, JFileDialog, JFrame, JLabel, JList, JScrollbar, JTextArea, and JTextField</td></tr>
<tr><td>ContainerEvent addContainerListener( ) removeContainerListener( )</td><td>Container and its derivatives, JScrollPane, Window, JDialog, JFileDialog, and JFrame</td></tr>
<tr><td>FocusEvent FocusListener addFocusListener( ) removeFocusListener( )</td><td>Component and derivatives*</td></tr>
<tr><td>KeyEvent KeyListener addKeyListener( ) removeKeyListener( )</td><td>Component and derivatives*</td></tr>
</table>
<table>
<tr><td>Event, listener interface, and add- and remove-methods</td><td>Components supporting this event</td></tr>
<tr><td>MouseEvent (for both clicks and motion)MouseListener addMouseListener( ) removeMouseListener( )</td><td>Component and derivatives*</td></tr>
<tr><td>MouseEvent<sup>6</sup> (for both clicks and motion)MouseMotionListener addMouseMotionListener( ) removeMouseMotionListener( )</td><td>Component and derivatives*</td></tr>
<tr><td>WindowEvent WindowListener addWindowListener( ) removeWindowListener( )</td><td>Window and its derivatives, including JDialog, JFileDialog, and JFrame</td></tr>
<tr><td>ItemEvent ItemListener addItemListener( ) removeItemListener( )</td><td>JCheckBox, JCheckBoxMenuItem, JComboBox, JList, and anything that implements the ItemSelectable interface</td></tr>
<tr><td>TextEvent TextListener addTextListener( ) removeTextListener( )</td><td>Anything derived from JTextComponent, including JTextArea and JTextField</td></tr>
</table>
<p>You can see that each type of component supports only certain types of events. It turns out to be rather tedious to look up all the events supported by each component. A simpler approach is to modify the ShowMethods.java program from the Type Information chapter so that it displays all the event listeners supported by any Swing component that you enter.</p>
<p>The Type Information chapter introduced reflection and used that feature to look up methods for a particular class—either the entire list of methods or a subset of those whose names match a keyword that you provide. The magic of reflection is that it can automatically show you all the methods for a class without forcing you to walk up the inheritance hierarchy, examining the base classes at each level. Thus, it provides a valuable timesaving tool for programming; because the names of most Java methods are made nicely verbose and descriptive, you can search for the method names that contain a particular word of interest. When you find what you think you’re looking for, check the JDK documentation.</p>
<p>Here is the more useful GUI version of ShowMethods.java, specialized to look for the &quot;addListener&quot; methods in Swing components:</p>
<p>//: gui/ShowAddListeners.java</p>
<p>// Display the &quot;addXXXListener&quot; methods of any Swing class.</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import java.lang.reflect.*;</p>
<p>import java.util.regex.*;</p>
<p>import static net.mindview.util.SwingConsole.*; public class ShowAddListeners extends JFrame {</p>
<p><sup>6</sup> There is no MouseMotionEvent even though it seems like there ought to be. Clicking and motion is combined into MouseEvent, so this second appearance of MouseEvent in the table is not an error.</p>
<p>private JTextField name = new JTextField(25); private JTextArea results = new JTextArea(40, 65); private static Pattern addListener =</p>
<p>Pattern.compile(&quot;(add\\w+?Listener\\(.*?\\))&quot;); private static Pattern qualifier =</p>
<p>Pattern.compile(&quot;\\w+\\.&quot;); class NameL implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) {</p>
<p>String nm = name.getText().trim(); if(nm.length() == 0) {</p>
<p>results.setText(&quot;No match&quot;); return;</p>
<p>}</p>
<p>Class&lt;?&gt; kind; try {</p>
<p>kind = Class.forName(&quot;javax.swing.&quot; + nm);</p>
<p>} catch(ClassNotFoundException ex) { results.setText(&quot;No match&quot;); return;</p>
<p>}</p>
<p>Method[] methods = kind.getMethods();</p>
<p>results.setText(&quot;&quot;);</p>
<p>for(Method m : methods) {</p>
<p>Matcher matcher =</p>
<p>addListener.matcher(m.toString());</p>
<p>if(matcher.find())</p>
<p>results.append(qualifier.matcher(</p>
<p>matcher.group(1)).replaceAll(&quot;&quot;) + &quot;\n&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public ShowAddListeners() {</p>
<p>NameL nameListener = new NameL(); name.addActionListener(nameListener);</p>
<p>JPanel top = new JPanel();</p>
<p>top.add(new JLabel(&quot;Swing class name (press Enter):&quot;)); top.add(name);</p>
<p>add(BorderLayout.NORTH, top); add(new JScrollPane(results));</p>
<p>// Initial data and test: name.setText(&quot;JTextArea&quot;); nameListener.actionPerformed( new ActionEvent(&quot;&quot;, 0 ,&quot;&quot;));</p>
<p>}</p>
<p>public static void main(String[] args) { run(new ShowAddListeners(), 500, 400);</p>
<p>}</p>
<p>} ///:~</p>
<p>You enter the Swing class name that you want to look up in the name JTextField. The results are extracted using regular expressions, and displayed in a JTextArea.</p>
<p>You’ll notice that there are no buttons or other components to indicate that you want the search to begin. That’s because the JTextField is monitored by an ActionListener. Whenever you make a change and press Enter, the list is immediately updated. If the text field isn’t empty, it is used inside Class.forName( ) to try to look up the class. If the name is incorrect, Class.forName( ) will fail, which means that it throws an exception. This is trapped, and the JTextArea is set to &quot;No match.&quot; But if you type in a correct name (capitalization counts), Class.forName( ) is successful, and getMethods( ) will return an array of Method objects.</p>
<p>Two regular expressions are used here. The first, addListener, looks for &quot;add&quot; followed by any word characters, followed by &quot;Listener&quot; and the argument list in parentheses. Notice that this whole regular expression is surrounded by non-escaped parentheses, which means it will be accessible as a regular expression &quot;group&quot; when it matches. Inside NameL.ActionPerformed( ), a Matcher is created by passing each Method object to the Pattern.matcher( ) method. When find( ) is called for this Matcher object, it returns true only if a match occurs, and in that case you can select the first matching parenthesized group by calling group(1). This string still contains qualifiers, so to strip them off, the qualifier Pattern object is used just as it was in ShowMethods.java.</p>
<p>At the end of the constructor, an initial value is placed in name and the action event is run to provide a test with initial data.</p>
<p>This program is a convenient way to investigate the capabilities of a Swing component. Once you know which events a particular component supports, you don’t need to look anything up to react to that event. You simply:</p>
<p>1.    Take the name of the event class and remove the word &quot;Event.&quot; Add the word &quot;Listener&quot; to what remains. This is the listener interface you must implement in your inner class.</p>
<p>2.    Implement the interface above and write out the methods for the events you want to capture. For example, you might be looking for mouse movements, so you write code for the mouseMoved( ) method of the MouseMotionListener interface. (You must implement the other methods, of course, but there’s often a shortcut for this, which you’ll see soon.)</p>
<p>3.    Create an object of the listener class in Step 2. Register it with your component with the method produced by prefixing &quot;add&quot; to your listener name. For example, addMouseMotionListener( ).</p>
<p>Here are some of the listener interfaces:</p>
<table>
<tr><td>Listener interface w/ adapter</td><td>Methods in interface</td></tr>
<tr><td>ActionListener</td><td>actionPerformed(ActionEvent)</td></tr>
<tr><td>AdjustmentListener</td><td>adjustmentValueChanged(AdjustmentEvent)</td></tr>
<tr><td>ComponentListenerComponentAdapter</td><td>componentHidden(ComponentEvent)componentShown(ComponentEvent)componentMoved(ComponentEvent)componentResized(ComponentEvent)</td></tr>
<tr><td>ContainerListenerContainerAdapter</td><td>componentAdded(ContainerEvent)componentRemoved(ContainerEvent)</td></tr>
<tr><td>FocusListenerFocusAdapter</td><td>focusGained(FocusEvent)focusLost(FocusEvent)</td></tr>
<tr><td>KeyListenerKeyAdapter</td><td>keyPressed(KeyEvent)keyReleased(KeyEvent)keyTyped(KeyEvent)</td></tr>
<tr><td>MouseListenerMouseAdapter</td><td>mouseClicked(MouseEvent)mouseEntered(MouseEvent)mouseExited(MouseEvent)mousePressed(MouseEvent)mouseReleased(MouseEvent)</td></tr>
</table>
<table>
<tr><td>Listener interface w/ adapter</td><td>Methods in interface</td></tr>
<tr><td>MouseMotionListenerMouseMotionAdapter</td><td>mouseDragged(MouseEvent)mouseMoved(MouseEvent)</td></tr>
<tr><td>WindowListenerWindowAdapter</td><td>windowOpened(WindowEvent)windowClosing(WindowEvent)windowClosed(WindowEvent)windowActivated(WindowEvent)windowDeactivated(WindowEvent)windowIconified(WindowEvent)windowDeiconified(WindowEvent)</td></tr>
<tr><td>ItemListener</td><td>itemStateChanged(ItemEvent)</td></tr>
</table>
<p>This is not an exhaustive listing, partly because the event model allows you to create your own event types and associated listeners. Thus, you’ll regularly come across libraries that have invented their own events, and the knowledge gained in this chapter will allow you to figure out how to use these events.</p>
<p>Using listener adapters for simplicity</p>
<p>In the table above, you can see that some listener interfaces have only one method. These are trivial to implement. However, the listener interfaces that have multiple methods can be less pleasant to use. For example, if you want to capture a mouse click (that isn’t already captured for you, for example, by a button), then you need to write a method for mouseClicked( ). But since MouseListener is an interface, you must implement all of the other methods even if they don’t do anything. This can be annoying.</p>
<p>To solve the problem, some (but not all) of the listener interfaces that have more than one method are provided with adapters, the names of which you can see in the table above. Each adapter provides default empty methods for each of the interface methods. When you inherit from the adapter, you override only the methods you need to change. For example, the typical MouseListener you’ll use looks like this:</p>
<p>class MyMouseListener extends MouseAdapter { public void mouseClicked(MouseEvent e) {</p>
<p>// Respond to mouse click...</p>
<p>}</p>
<p>}</p>
<p>The whole point of the adapters is to make the creation of listener classes easy.</p>
<p>There is a downside to adapters, however, in the form of a pitfall. Suppose you write a MouseAdapter like the previous one:</p>
<p>class MyMouseListener extends MouseAdapter { public void MouseClicked(MouseEvent e) {</p>
<p>// Respond to mouse click...</p>
<p>}</p>
<p>}</p>
<p>This doesn’t work, but it will drive you crazy trying to figure out why, since everything will compile and run fine—except that your method won’t be called for a mouse click. Can you see the problem? It’s in the name of the method: MouseClicked( ) instead of mouseClicked( ). A simple slip in capitalization results in the addition of a completely new method.</p>
<p>However, this is not the method that’s called when the mouse is clicked, so you don’t get the desired results. Despite the inconvenience, an interface will guarantee that the methods are properly implemented.</p>
<p>An improved alternative way to guarantee that you are in fact overriding a method is to use the built-in @Override annotation in the code above.</p>
<p>Exercise 9: (5) Starting with ShowAddListeners.java, create a program with the full functionality of typeinfo.ShowMethods.java.</p>
<subtitle>Tracking multiple events</subtitle>
<p>To prove to yourself that these events are in fact being fired, it’s worth creating a program that tracks behavior in a JButton beyond whether it has been pressed. This example also shows you how to inherit your own button object from JButton.<a l:href="#bookmark139" type="note"><sup>140</sup></a><sup></sup></p>
<p>In the code below, the MyButton class is an inner class of TrackEvent, so MyButton can reach into the parent window and manipulate its text fields, which is necessary in order to write the status information into the fields of the parent. Of course, this is a limited solution, since MyButton can be used only in conjunction with TrackEvent. This kind of code is sometimes called &quot;highly coupled&quot;:</p>
<p>//: gui/TrackEvent.java // Show events as they happen. import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.util.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class TrackEvent extends JFrame { private HashMap&lt;String,JTextField&gt; h = new HashMap&lt;String,JTextField&gt;(); private String[] event = {</p>
<p>&quot;focusGained&quot;, &quot;focusLost&quot;, &quot;keyPressed&quot;,</p>
<p>&quot;keyReleased&quot;, &quot;keyTyped&quot;, &quot;mouseClicked&quot;,</p>
<p>&quot;mouseEntered&quot;, &quot;mouseExited&quot;, &quot;mousePressed&quot;,</p>
<p>&quot;mouseReleased&quot;, &quot;mouseDragged&quot;, &quot;mouseMoved&quot;</p>
<p>};</p>
<p>private MyButton</p>
<p>b1 = new MyButton(Color.BLUE, &quot;testl&quot;), b2 = new MyButton(Color.RED, &quot;test2&quot;); class MyButton extends JButton {</p>
<p>void report(String field, String msg) { h.get(field).setText(msg);</p>
<p>}</p>
<p>FocusListener fl = new FocusListener() { public void focusGained(FocusEvent e) { report(&quot;focusGained&quot;, e.paramString());</p>
<p>}</p>
<p>public void focusLost(FocusEvent e) { report(&quot;focusLost&quot;, e.paramString());</p>
<p>}</p>
<p>};</p>
<p>KeyListener kl = new KeyListener() { public void keyPressed(KeyEvent e) { report(&quot;keyPressed&quot;, e.paramString());</p>
<p>public void keyReleased(KeyEvent e) { report(&quot;keyReleased&quot;, e.paramString());</p>
<p>}</p>
<p>public void keyTyped(KeyEvent e) { report(&quot;keyTyped&quot;, e.paramString());</p>
<p>}</p>
<p>};</p>
<p>MouseListener ml = new MouseListener() { public void mouseClicked(MouseEvent e) { report(&quot;mouseClicked&quot;, e.paramString());</p>
<p>}</p>
<p>public void mouseEntered(MouseEvent e) { report(&quot;mouseEntered&quot;, e.paramString());</p>
<p>}</p>
<p>public void mouseExited(MouseEvent e) { report(&quot;mouseExited&quot;, e.paramString());</p>
<p>}</p>
<p>public void mousePressed(MouseEvent e) { report(&quot;mousePressed&quot;, e.paramString());</p>
<p>}</p>
<p>public void mouseReleased(MouseEvent e) { report(&quot;mouseReleased&quot;, e.paramString());</p>
<p>}</p>
<p>};</p>
<p>MouseMotionListener mml = new MouseMotionListener() { public void mouseDragged(MouseEvent e) { report(&quot;mouseDragged&quot;, e.paramString());</p>
<p>}</p>
<p>public void mouseMoved(MouseEvent e) { report(&quot;mouseMoved&quot;, e.paramString());</p>
<p>}</p>
<p>};</p>
<p>public MyButton(Color color, String label) { super(label); setBackground(color); addFocusListener(fl); addKeyListener(kl); addMouseListener(ml); addMouseMotionListener(mml);</p>
<p>}</p>
<p>}</p>
<p>public TrackEvent() {</p>
<p>setLayout(new GridLayout(event.length + 1, 2)); for(String evt : event) {</p>
<p>JTextField t = new JTextField();</p>
<p>t.setEditable(false);</p>
<p>add(new JLabel(evt, JLabel.RIGHT));</p>
<p>add(t);</p>
<p>h.put(evt, t);</p>
<p>}</p>
<p>add(bl);</p>
<p>add(b2);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new TrackEvent(), 700, 500);</p>
<p>}</p>
<p>} ///:~</p>
<p>In the MyButton constructor, the button’s color is set with a call to SetBackground( ). The listeners are all installed with simple method calls.</p>
<p>The TrackEvent class contains a HashMap to hold the strings representing the type of event and JTextFields where information about that event is held. Of course, these could have been created statically rather than putting them in a HashMap, but I think you’ll agree that it’s a lot easier to use and change. In particular, if you need to add or remove a new type of event in TrackEvent, you simply add or remove a string in the event array— everything else happens automatically.</p>
<p>When report( ) is called, it is given the name of the event and the parameter string from the event. It uses the HashMap h in the outer class to look up the actual JTextField associated with that event name and then places the parameter string into that field.</p>
<p>This example is fun to play with because you can really see what’s going on with the events in your program.</p>
<p>Exercise 10: (6) Create an application using SwingConsole, with a JButton and a JTextField. Write and attach the appropriate listener so that if the button has the focus, characters typed into it will appear in the JTextField.</p>
<p>Exercise 11: (4) Inherit a new type of button from JButton. Each time you press this button, it should change its color to a randomly selected value. See ColorBoxes.java (later in this chapter) for an example of how to generate a random color value.</p>
<p>Exercise 12: (4) Monitor a new type of event in TrackEvent.java by adding the new event-handling code. You’ll need to discover on your own the type of event that you want to monitor.</p>
</section>
<section>
<title>
<p>A selection of Swing components</p></title><empty-line/>
<p>Now that you understand layout managers and the event model, you’re ready to see how Swing components can be used. This section is a non-exhaustive tour of the Swing components and features that you’ll probably use most of the time. Each example is intended to be reasonably small so that you can easily lift the code and use it in your own programs.</p>
<p>Keep in mind:</p>
<p>1.    You can easily see what each of these examples looks like during execution by compiling and running the downloadable source code for this chapter (<a l:href="http://www.MindView.net">www.MindView.net</a>).</p>
<p>2.    The JDK documentation from <a l:href="http://java.sun.com">http://java.sun.com</a> contains all of the Swing classes and methods (only a few are shown here).</p>
<p>3.    Because of the naming convention used for Swing events, it’s fairly easy to guess how to write and install a handler for a particular type of event. Use the lookup program ShowAddListeners.java from earlier in this chapter to aid in your investigation of a particular component.</p>
<p>4.    When things start to get complicated you should graduate to a GUI builder.</p>
<subtitle>Buttons</subtitle>
<p>Swing includes a number of different types of buttons. All buttons, check boxes, radio buttons, and even menu items are inherited from AbstractButton (which, since menu items are included, would probably have been better named &quot;AbstractSelector&quot; or something equally general). You’ll see the use of menu items shortly, but the following example shows the various types of buttons available:</p>
<p>//: gui/Buttons.java // Various Swing buttons. import javax.swing.*; import javax.swing.border.*; import javax.swing.plaf.basic.*; import java.awt.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class Buttons extends JFrame {</p>
<p>private JButton jb = new JButton(&quot;JButton&quot;); private BasicArrowButton</p>
<p>up = new BasicArrowButton(BasicArrowButton.NORTH), down = new BasicArrowButton(BasicArrowButton.SOUTH), right = new BasicArrowButton(BasicArrowButton.EAST), left = new BasicArrowButton(BasicArrowButton.WEST); public Buttons() {</p>
<p>setLayout(new FlowLayout()); add(jb);</p>
<p>add(new JToggleButton(&quot;JToggleButton&quot;)); add(new JCheckBox(&quot;JCheckBox&quot;)); add(new JRadioButton(&quot;JRadioButton&quot;));</p>
<p>JPanel jp = new JPanel();</p>
<p>jp.setBorder(new TitledBorder(&quot;Directions&quot;));</p>
<p>jp.add(up);</p>
<p>jp.add(down);</p>
<p>jp.add(left);</p>
<p>jp.add(right);</p>
<p>add(jp);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new Buttons(), 350, 200);</p>
<p>}</p>
<p>} ///:~</p>
<p>This begins with the BasicArrowButton from javax.swing.plaf.basic, then continues with the various specific types of buttons. When you run the example, you’ll see that the toggle button holds its last position, in or out. But the check boxes and radio buttons behave identically to each other, just clicking on or off (they are inherited from JToggleButton).</p>
<p>Button groups</p>
<p>If you want radio buttons to behave in an &quot;exclusive or&quot; fashion, you must add them to a &quot;button group.&quot; But, as the following example demonstrates, any AbstractButton can be added to a ButtonGroup.</p>
<p>To avoid repeating a lot of code, this example uses reflection to generate the groups of different types of buttons. This is seen in makeBPanel( ), which creates a button group in a JPanel. The second argument to makeBPanel( ) is an array of String. For each String, a button of the class represented by the first argument is added to the JPanel:</p>
<p>//: gui/ButtonGroups.java</p>
<p>// Uses reflection to create groups</p>
<p>// of different types of AbstractButton.</p>
<p>import javax.swing.*;</p>
<p>import javax.swing.border.*;</p>
<p>import java.awt.*;</p>
<p>import java.lang.reflect.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class ButtonGroups extends JFrame { private static String[] ids = {</p>
<p>&quot;Lumpy&quot;</p>
<p>&quot;June&quot;, &quot;Ward&quot;, &quot;Beaver&quot;, &quot;Wally&quot;, &quot;Eddie&quot;</p>
<p>};</p>
<p>static JPanel makeBPanel(</p>
<p>{</p>
<p>Class&lt;? extends AbstractButton&gt; kind, String[] ids) ButtonGroup bg = new ButtonGroup();</p>
<p>JPanel jp = new JPanel();</p>
<p>String title = kind.getName();</p>
<p>title = title.substring(title.lastIndexOf(‘.’) + 1); jp.setBorder(new TitledBorder(title)); for(String id : ids) {</p>
<p>AbstractButton ab = new JButton(&quot;failed&quot;); try {</p>
<p>// Get the dynamic constructor method // that takes a String argument:</p>
<p>Constructor ctor =</p>
<p>kind.getConstructor(String.class);</p>
<p>// Create a new object:</p>
<p>ab = (AbstractButton)ctor.newlnstance(id);</p>
<p>} catch(Exception ex) {</p>
<p>System.err.println(&quot;can’t create &quot; + kind);</p>
<p>}</p>
<p>bg.add(ab);</p>
<p>jp.add(ab);</p>
<p>}</p>
<p>return jp;</p>
<p>}</p>
<p>public ButtonGroups() {</p>
<p>setLayout(new FlowLayout()); add(makeBPanel(JButton.class, ids)); add(makeBPanel(JToggleButton.class, ids)); add(makeBPanel(JCheckBox.class, ids)); add(makeBPanel(JRadioButton.class, ids));</p>
<p>}</p>
<p>public static void main(String[] args) { run(new ButtonGroups(), 500, 350);</p>
<p>}</p>
<p>} ///:~</p>
<p>The title for the border is taken from the name of the class, stripping off all the path information. The AbstractButton is initialized to a JButton that has the label &quot;failed,&quot; so if you ignore the exception message, you’ll still see the problem on the screen. The getConstructor( ) method produces a Constructor object that takes the array of arguments of the types in the list of Classes passed to getConstructor( ). Then all you do is call newInstance( ), passing it a list of arguments—in this case, just the String from the ids array.</p>
<p>To get &quot;exclusive or&quot; behavior with buttons, you create a button group and add each button for which you want that behavior to the group. When you run the program, you’ll see that all the buttons except JButton exhibit this &quot;exclusive or&quot; behavior.</p>
<subtitle>Icons</subtitle>
<p>You can use an Icon inside a JLabel or anything that inherits from AbstractButton (including JButton, JCheckBox, JRadioButton, and the different kinds of JMenuItem). Using Icons with JLabels is quite straightforward (you’ll see an example later). The following example explores all the additional ways you can use Icons with buttons and their descendants.</p>
<p>You can use any GIF files you want, but the ones used in this example are part of this book’s code distribution, available at <a l:href="http://www.MindView.net">www.MindView.net</a>. To open a file and bring in the image, simply create an Imagelcon and hand it the file name. From then on, you can use the resulting Icon in your program.</p>
<p>//: gui/Faces.java // Icon behavior in JButtons. import javax.swing.*; import java.awt.*; import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class Faces extends JFrame { private static Icon[] faces;</p>
<p>private JButton jb, jb2 = new JButton(&quot;Disable&quot;); private boolean mad = false; public Faces() { faces = new Icon[]{</p>
<p>new ImageIcon(getClass().getResource(&quot;Face0.gif&quot;)), new ImageIcon(getClass().getResource(&quot;Face1.gif&quot;)), new ImageIcon(getClass().getResource(&quot;Face2.gif&quot;)), new ImageIcon(getClass().getResource(&quot;Face3.gif&quot;)), new ImageIcon(getClass().getResource(&quot;Face4.gif&quot;)),</p>
<p>};</p>
<p>jb = new JButton(&quot;JButton&quot;, faces[3]); setLayout(new FlowLayout()); jb.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { if(mad) {</p>
<p>jb.setIcon(faces[3]); mad = false;</p>
<p>} else {</p>
<p>jb.setIcon(faces[0]); mad = true;</p>
<p>}</p>
<p>jb.setVerticalAlignment(JButton.TOP);</p>
<p>jb.setHorizontalAlignment(JButton.LEFT);</p>
<p>}</p>
<p>});</p>
<p>jb.setRolloverEnabled(true);</p>
<p>jb.setRolloverIcon(faces[1]);</p>
<p>jb.setPressedIcon(faces[2]);</p>
<p>jb.setDisabledIcon(faces[4]);</p>
<p>jb.setToolTipText(&quot;Yow!&quot;);</p>
<p>add(jb);</p>
<p>jb2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { if(jb.isEnabled()) { jb.setEnabled(false); jb2.setText(&quot;Enable&quot;);</p>
<p>} else {</p>
<p>jb.setEnabled(true);</p>
<p>jb2.setText(&quot;Disable&quot;);</p>
<p>}</p>
<p>}</p>
<p>});</p>
<p>add(jb2);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new Faces(), 250, 125);</p>
<p>}</p>
<p>} ///:~</p>
<p>An Icon can be used as an argument for many different Swing component constructors, but you can also use setIcon( ) to add or change an Icon. This example also shows how a JButton (or any AbstractButton) can set the various different sorts of icons that appear when things happen to that button: when it’s pressed, disabled, or &quot;rolled over&quot; (the mouse moves over it without clicking). You’ll see that this gives the button a nice animated feel.</p>
<subtitle>Tool tips</subtitle>
<p>The previous example added a &quot;tool tip&quot; to the button. Almost all of the classes that you’ll be using to create your user interfaces are derived from JComponent, which contains a method called setToolTipText(String). So, for virtually anything you place on your form, all you need to do is say (for an object j c of any JComponent-derived class):</p>
<p>jc.setToolTipText(&quot;My tip&quot;);</p>
<p>When the mouse stays over that JComponent for a predetermined period of time, a tiny box containing your text will pop up next to the mouse.</p>
<subtitle>Text fields</subtitle>
<p>This example shows what JTextFields can do:</p>
<p>//: gui/TextFields.java // Text fields and Java events. import javax.swing.*; import javax.swing.event.*; import javax.swing.text.*; import java.awt.*; import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class TextFields extends JFrame { private JButton</p>
<p>b1 = new JButton(&quot;Get Text&quot;), b2 = new JButton(&quot;Set Text&quot;); private JTextField</p>
<p>t1 = new JTextField(30), t2 = new JTextField(30), t3 = new JTextField(30); private String s = &quot;&quot;;</p>
<p>private UpperCaseDocument ucd = new UpperCaseDocument() public TextFields() { tl.setDocument(ucd); ucd.addDocumentListener(new T1()); b1.addActionListener(new B1()); b2.addActionListener(new B2()); t1.addActionListener(new T1A()); setLayout(new FlowLayout()); add(b1) add(b2) add(t1) add(t2) add(t3)</p>
<p>} class T1 implements DocumentListener {</p>
<p>public void changedUpdate(DocumentEvent e) {} public void insertUpdate(DocumentEvent e) { t2.setText(t1.getText()); t3.setText(&quot;Text: &quot;+ t1.getText());</p>
<p>public void removeUpdate(DocumentEvent e) { t2.setText(t1.getText());</p>
<p>}</p>
<p>}</p>
<p>class T1A implements ActionListener { private int count = 0;</p>
<p>public void actionPerformed(ActionEvent e) { t3.setText(&quot;t1 Action Event &quot; + count++);</p>
<p>}</p>
<p>}</p>
<p>class B1 implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) { if(t1.getSelectedText() == null) s = t1.getText(); else</p>
<p>s = t1.getSelectedText(); t1.setEditable(true);</p>
<p>}</p>
<p>}</p>
<p>class B2 implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) { ucd.setUpperCase(false); t1.setText(&quot;Inserted by Button 2: &quot; + s); ucd.setUpperCase(true); t1.setEditable(false);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) { run(new TextFields(), 375, 200);</p>
<p>}</p>
<p>}</p>
<p>class UpperCaseDocument extends PlainDocument { private boolean upperCase = true; public void setUpperCase(boolean flag) { upperCase = flag;</p>
<p>}</p>
<p>public void</p>
<p>insertString(int offset, String str, AttributeSet attSet) throws BadLocationException {</p>
<p>if(upperCase) str = str.toUpperCase(); super.insertString(offset, str, attSet);</p>
<p>}</p>
<p>} ///:~</p>
<p>The JTextField t3 is included as a place to report when the action listener for the JTextField t1 is fired. You’ll see that the action listener for a JTextField is fired only when you press the Enter key.</p>
<p>The JTextField t1 has several listeners attached to it. The T1 listener is a DocumentListener that responds to any change in the &quot;document&quot; (the contents of the JTextField, in this case). It automatically copies all text from t1 into t2. In addition, t1’s document is set to a derived class of PlainDocument, called UpperCaseDocument, which forces all characters to uppercase. It automatically detects backspaces and performs the deletion, adjusting the caret and handling everything as you expect.</p>
<p>Exercise 13: (3) Modify TextFields.java so that the characters in t2 retain the original case that they were typed in, instead of automatically being forced to uppercase.</p>
<subtitle>Borders</subtitle>
<p>JComponent contains a method called setBorder( ), which allows you to place various interesting borders on any visible component. The following example demonstrates a number of the different borders that are available, using a method called showBorder( ) that creates a JPanel and puts on the border in each case. Also, it uses RTTI to find the name of the border that you’re using (stripping off all the path information), then puts that name in a JLabel in the middle of the panel:</p>
<p>//: gui/Borders.java // Different Swing borders. import javax.swing.*; import javax.swing.border.*; import java.awt.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class Borders extends JFrame {</p>
<p>static JPanel showBorder(Border b) {</p>
<p>JPanel jp = new JPanel(); jp.setLayout(new BorderLayout());</p>
<p>String nm = b.getClassQ.toStringQ;</p>
<p>nm = nm.substring(nm.lastIndexOf(‘.’) + 1);</p>
<p>jp.add(new JLabel(nm, JLabel.CENTER),</p>
<p>BorderLayout.CENTER); jp.setBorder(b); return jp;</p>
<p>}</p>
<p>public Borders() {</p>
<p>setLayout(new GridLayout(2,4)); add(showBorder(new TitledBorder(&quot;Title&quot;))); add(showBorder(new EtchedBorder())); add(showBorder(new LineBorder(Color.BLUE))); add(showBorder(</p>
<p>new MatteBorder(5,5,30,30,Color.GREEN))); add(showBorder(</p>
<p>new BevelBorder(BevelBorder.RAISED))); add(showBorder(</p>
<p>new SoftBevelBorder(BevelBorder.LOWERED))); add(showBorder(new CompoundBorder( new EtchedBorder(), new LineBorder(Color.RED))));</p>
<p>}</p>
<p>public static void main(String[] args) { run(new Borders(), 500, 300);</p>
<p>}</p>
<p>} ///:~</p>
<p>You can also create your own borders and put them inside buttons, labels, etc.—anything derived from JComponent.</p>
<subtitle>A mini-editor</subtitle>
<p>The JTextPane control provides a great deal of support for editing, without much effort. The following example makes very simple use of this component, ignoring the bulk of its functionality:</p>
<p>//: gui/TextPane.java</p>
<p>// The JTextPane control is a little editor. import javax.swing.*;</p>
<p>import java.awt.*; import java.awt.event.*; import net.mindview.util.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class TextPane extends JFrame {</p>
<p>private JButton b = new JButton(&quot;Add Text&quot;); private JTextPane tp = new JTextPane(); private static Generator sg = new RandomGenerator.String(7); public TextPane() {</p>
<p>b.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { for(int i = 1; i &lt; 10; i++)</p>
<p>tp.setText(tp.getText() + sg.next() + &quot;\n&quot;);</p>
<p>}</p>
<p>});</p>
<p>add(new JScrollPane(tp)); add(BorderLayout.SOUTH, b);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new TextPane(), 475, 425);</p>
<p>}</p>
<p>} ///:~</p>
<p>The button adds randomly generated text. The intent of the JTextPane is to allow text to be edited in place, so you will see that there is no append( ) method. In this case (admittedly, a poor use of the capabilities of JTextPane), the text must be captured, modified, and placed back into the pane using setText( ).</p>
<p>Elements are added to the JFrame using its default BorderLayout. The JTextPane is added (inside a JScrollPane) without specifying a region, so it just fills the center of the pane out to the edges. The JButton is added to the SOUTH, so the component will fit itself into that region; in this case, the button will nest down at the bottom of the screen.</p>
<p>Notice the built-in features of JTextPane, such as automatic line wrapping. There are numerous other features that you can look up using the JDK documentation.</p>
<p>Exercise 14: (2) Modify TextPane.java to use a JTextArea instead of a JTextPane.</p>
<subtitle>Check boxes</subtitle>
<p>A check box provides a way to make a single on/off choice. It consists of a tiny box and a label. The box typically holds a little &quot;x&quot; (or some other indication that it is set) or is empty, depending on whether that item was selected.</p>
<p>You’ll normally create a JCheckBox using a constructor that takes the label as an argument. You can get and set the state, and also get and set the label if you want to read or change it after the JCheckBox has been created.</p>
<p>Whenever a JCheckBox is set or cleared, an event occurs, which you can capture the same way you do a button: by using an ActionListener. The following example uses a JTextArea to enumerate all the check boxes that have been checked:</p>
<p>//: gui/CheckBoxes.java // Using JCheckBoxes. import javax.swing.*; import java.awt.*;</p>
<p>public class CheckBoxes extends JFrame { private JTextArea t = new JTextArea(6, 15); private JCheckBox</p>
<p>cb1 = new JCheckBox(&quot;Check Box 1&quot;), cb2 = new JCheckBox(&quot;Check Box 2&quot;), cb3 = new JCheckBox(&quot;Check Box 3&quot;); public CheckBoxes() {</p>
<p>cb1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { trace(&quot;1&quot;, cb1);</p>
<p>}</p>
<p>});</p>
<p>cb2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { trace(&quot;2&quot;, cb2);</p>
<p>}</p>
<p>});</p>
<p>cb3.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { trace(&quot;3&quot;, cb3);</p>
<p>}</p>
<p>});</p>
<p>setLayout(new FlowLayout());</p>
<p>add(new JScrollPane(t));</p>
<p>add(cb1);</p>
<p>add(cb2);</p>
<p>add(cb3);</p>
<p>}</p>
<p>private void trace(String b, JCheckBox cb) { if(cb.isSelected())</p>
<p>t.append(&quot;Box &quot; + b + &quot; Set\n&quot;); else</p>
<p>t.append(&quot;Box &quot; + b + &quot; Cleared\n&quot;);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new CheckBoxes(), 200, 300);</p>
<p>}</p>
<p>} ///:~</p>
<p>The trace( ) method sends the name of the selected JCheckBox and its current state to the JTextArea using append( ), so you’ll see a cumulative list of the check boxes that were selected, along with their state.</p>
<p>Exercise 15: (5) Add a check box to the application created in Exercise 5, capture the event, and insert different text into the text field.</p>
<subtitle>Radio buttons</subtitle>
<p>The concept of radio buttons in GUI programming comes from pre-electronic car radios with mechanical buttons: When you push one in, any other buttons pop out. Thus, it allows you to force a single choice among many.</p>
<p>To set up an associated group of JRadioButtons, you add them to a ButtonGroup (you can have any number of ButtonGroups on a form). One of the buttons can be optionally set to true (using the second argument in the constructor). If you try to set more than one radio button to true, then only the last one set will be true.</p>
<p>Here’s a simple example of the use of radio buttons, showing event capture using an ActionListener:</p>
<p>//: gui/RadioButtons.java // Using JRadioButtons. import javax.swing.*; import java.awt.*; import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class RadioButtons extends JFrame { private JTextField t = new JTextField(15); private ButtonGroup g = new ButtonGroup(); private JRadioButton</p>
<p>rb1 = new JRadioButton(&quot;one&quot;, false), rb2 = new JRadioButton(&quot;two&quot;, false), rb3 = new JRadioButton(&quot;three&quot;, false); private ActionListener al = new ActionListener() { public void actionPerformed(ActionEvent e) { t.setText(&quot;Radio button &quot; +</p>
<p>((JRadioButton)e.getSource()).getText());</p>
<p>}</p>
<p>};</p>
<p>public RadioButtons() { rbl.addActionListener(al); rb2.addActionListener(al); rb3.addActionListener(al); g.add(rbl); g.add(rb2); g.add(rb3); t.setEditable(false); setLayout(new FlowLayout()); add(t); add(rbl); add(rb2); add(rb3);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new RadioButtons(), 200, 125);</p>
<p>}</p>
<p>} ///:~</p>
<p>To display the state, a text field is used. This field is set to non-editable because it’s used only to display data, not to collect it. Thus it is an alternative to using a JLabel.</p>
<subtitle>Combo boxes (drop-down lists)</subtitle>
<p>Like a group of radio buttons, a drop-down list is a way to force the user to select only one element from a group of possibilities. However, it’s a more compact way to accomplish this, and it’s easier to change the elements of the list without surprising the user. (You can change radio buttons dynamically, but that tends to be visibly jarring.)</p>
<p>By default, JComboBox box is not like the combo box in Windows, which lets you select from a list or type in your own selection. To produce this behavior you must call setEditable( ). With a JComboBox box, you choose one and only one element from the list. In the following example, the JComboBox box starts with a certain number of entries, and then new entries are added to the box when a button is pressed.</p>
<p>//: gui/ComboBoxes.java // Using drop-down lists. import javax.swing.*; import java.awt.*;</p>
<p>public class ComboBoxes extends JFrame { private String[] description = {</p>
<p>&quot;Ebullient&quot;, &quot;Obtuse&quot;, &quot;Recalcitrant&quot;, &quot;Brilliant&quot; &quot;Somnescent&quot;, &quot;Timorous&quot;, &quot;Florid&quot;, &quot;Putrescent&quot;</p>
<p>};</p>
<p>&apos;);</p>
<p>private JTextField t = new JTextField(15); private JComboBox c = new JComboBox(); private JButton b = new JButton(&quot;Add items&apos; private int count = 0; public ComboBoxes() {</p>
<p>for(int i = 0; i &lt; 4; i++)</p>
<p>c.addItem(description[count++]);</p>
<p>t.setEditable(false);</p>
<p>b. addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>if(count &lt; description.length) c.addItem(description[count++]);</p>
<p>}</p>
<p>});</p>
<p>c. addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>+</p>
<p>t.setText(&quot;index: &quot;+ c.getSelectedIndex() + &quot; ((JComboBox)e.getSource()).getSelectedItem());</p>
<p>}</p>
<p>});</p>
<p>setLayout(new FlowLayout()); add(t)</p>
<p>add(c)</p>
<p>add(b)</p>
<p>}</p>
<p>public static void main(String[] args) { run(new ComboBoxes(), 200, 175);</p>
<p>}</p>
<p>} ///:~</p>
<p>The JTextField displays the &quot;selected index,&quot; which is the sequence number of the currently selected element, as well as the text of the selected item in the combo box.</p>
<subtitle>List boxes</subtitle>
<p>List boxes are significantly different from JComboBox boxes, and not just in appearance. While a JComboBox box drops down when you activate it, a JList occupies some fixed number of lines on a screen all the time and doesn’t change. If you want to see the items in a list, you simply call getSelectedValues( ), which produces an array of String of the items that have been selected.</p>
<p>A JList allows multiple selection; if you control-click on more than one item (holding down the Control key while performing additional mouse clicks), the original item stays highlighted and you can select as many as you want. If you select an item, then shift-click on another item, all the items in the span between the two are selected. To remove an item from a group, you can control-click it.</p>
<p>//: gui/List.java import javax.swing.*; import javax.swing.border.*; import javax.swing.event.*; import java.awt.*;</p>
<p>public class List extends JFrame { private String[] flavors = {</p>
<p>&quot;Chocolate&quot;, &quot;Strawberry&quot;, &quot;Vanilla Fudge Swirl&quot;,</p>
<p>&quot;Mint Chip&quot;, &quot;Mocha Almond Fudge&quot;, &quot;Rum Raisin&quot;,</p>
<p>&quot;Praline Cream&quot;, &quot;Mud Pie&quot;</p>
<p>};</p>
<p>private DefaultListModel lItems = new DefaultListModel(); private JList lst = new JList(lltems); private JTextArea t =</p>
<p>new JTextArea(flavors.length, 20); private JButton b = new JButton(&quot;Add Item&quot;); private ActionListener bl = new ActionListener() { public void actionPerformed(ActionEvent e) { if(count &lt; flavors.length) {</p>
<p>lItems.add(0, flavors[count++]);</p>
<p>} else {</p>
<p>// Disable, since there are no more // flavors left to be added to the List b.setEnabled(false);</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>private ListSelectionListener ll = new ListSelectionListener() {</p>
<p>public void valueChanged(ListSelectionEvent e) { if(e.getValueIsAdjusting()) return; t.setText(&quot;&quot;);</p>
<p>for(Object item : lst.getSelectedValues()) t.append(item + &quot;\n&quot;);</p>
<p>}</p>
<p>};</p>
<p>private int count = 0; public List() {</p>
<p>t.setEditable(false); setLayout(new FlowLayout());</p>
<p>// Create Borders for components:</p>
<p>Border brd = BorderFactory.createMatteBorder(</p>
<p>1, 1, 2, 2, Color.BLACK); lst.setBorder(brd); t.setBorder(brd);</p>
<p>// Add the first four items to the List for(int i = 0; i &lt; 4; i++)</p>
<p>lItems.addElement(flavors[count++]);</p>
<p>add(t);</p>
<p>add(lst);</p>
<p>add(b);</p>
<p>// Register event listeners</p>
<p>lst.addListSelectionListener(ll);</p>
<p>b.addActionListener(bl);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new List(), 250, 375);</p>
<p>}</p>
<p>} ///:~</p>
<p>You can see that borders have also been added to the lists.</p>
<p>If you just want to put an array of Strings into a JList, there’s a much simpler solution; you pass the array to the JList constructor, and it builds the list automatically. The only reason</p>
<p>for using the &quot;list model&quot; in the preceding example is so that the list can be manipulated during the execution of the program.</p>
<p>JLists do not automatically provide direct support for scrolling. Of course, all you need to do is wrap the JList in a JScrollPane, and the details are automatically managed for you.</p>
<p>Exercise 16: (5) Simplify List.java by passing the array to the constructor and eliminating the dynamic addition of elements to the list.</p>
<subtitle>Tabbed panes</subtitle>
<p>The JTabbedPane allows you to create a &quot;tabbed dialog,&quot; which has filefolder tabs running across one edge. When you press a tab, it brings forward a different dialog.</p>
<p>//: gui/TabbedPane1.java // Demonstrates the Tabbed Pane. import javax.swing.*; import javax.swing.event.*; import java.awt.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class TabbedPane1 extends JFrame { private String[] flavors = {</p>
<p>&quot;Chocolate&quot;, &quot;Strawberry&quot;, &quot;Vanilla Fudge Swirl&quot;,</p>
<p>&quot;Mint Chip&quot;, &quot;Mocha Almond Fudge&quot;, &quot;Rum Raisin&quot;,</p>
<p>&quot;Praline Cream&quot;, &quot;Mud Pie&quot;</p>
<p>};</p>
<p>private JTabbedPane tabs = new JTabbedPane(); private JTextField txt = new JTextField(20); public TabbedPane1() { int i = 0;</p>
<p>for(String flavor : flavors) tabs.addTab(flavors[i],</p>
<p>new JButton(&quot;Tabbed pane &quot; + i++)); tabs.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent e) { txt.setText(&quot;Tab selected: &quot; + tabs.getSelectedIndex());</p>
<p>}</p>
<p>});</p>
<p>add(BorderLayout.SOUTH, txt); add(tabs);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new TabbedPane1(), 400, 250);</p>
<p>}</p>
<p>} ///:~</p>
<p>When you run the program, you’ll see that the JTabbedPane automatically stacks the tabs if there are too many of them to fit on one row. You can see this by resizing the window when you run the program from the console command line.</p>
<subtitle>Message boxes</subtitle>
<p>Windowing environments commonly contain a standard set of message boxes that allow you to quickly post information to the user or to capture information from the user. In Swing, these message boxes are contained in JOptionPane. You have many different possibilities (some quite sophisticated), but the ones you’ll most commonly use are probably the message</p>
<p>dialog and confirmation dialog, invoked using the static</p>
<p>JOptionPane.showMessageDialog( ) and JOptionPane.showConfirmDialog( ).</p>
<p>The following example shows a subset of the message boxes available with JOptionPane:</p>
<p>//: gui/MessageBoxes.java // Demonstrates JOptionPane. import javax.swing.*; import java.awt.*; import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class MessageBoxes extends JFrame { private JButton[] b = {</p>
<p>new JButton(&quot;Alert&quot;), new JButton(&quot;Yes/No&quot;), new JButton(&quot;Color&quot;), new JButton(&quot;Input&quot;), new JButton(&quot;3 Vals&quot;)</p>
<p>};</p>
<p>private JTextField txt = new JTextField(15); private ActionListener al = new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>String id = ((JButton)e.getSource()).getText(); if(id.equals(&quot;Alert&quot;))</p>
<p>JOptionPane.showMessageDialog(null,</p>
<p>&quot;There&apos;s a bug on you!&quot;, &quot;Hey!&quot;,</p>
<p>JOptionPane.ERROR_MESSAGE); else if(id.equals(&quot;Yes/No&quot;))</p>
<p>JOptionPane.showConfirmDialog(null,</p>
<p>&quot;or no&quot;, &quot;choose yes&quot;,</p>
<p>JOptionPane.YES_NO_OPTION); else if(id.equals(&quot;Color&quot;)) {</p>
<p>Object[] options = { &quot;Red&quot;, &quot;Green&quot; }; int sel = JOptionPane.showOptionDialog( null, &quot;Choose a Color!&quot;, &quot;Warning&quot;, JOptionPane.DEFAULT_OPTION,</p>
<p>JOptionPane.WARNING_MESSAGE, null, options, options[0]); if(sel != JOptionPane.CLOSED_OPTION)</p>
<p>txt.setText(&quot;Color Selected: &quot; + options[sel]);</p>
<p>} else if(id.equals(&quot;Input&quot;)) {</p>
<p>String val = JOptionPane.showInputDialog(</p>
<p>&quot;How many fingers do you see?&quot;); txt.setText(val);</p>
<p>} else if(id.equals(&quot;3 Vals&quot;)) {</p>
<p>Object[] selections = {&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;};</p>
<p>Object val = JOptionPane.showInputDialog( null, &quot;Choose one&quot;, &quot;Input&quot;,</p>
<p>JOptionPane.INFORMATION_MESSAGE, null, selections, selections[0]); if(val != null)</p>
<p>txt.setText(val.toString());</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>public MessageBoxes() {</p>
<p>setLayout(new FlowLayout()); for(int i = 0; i &lt; b.length; i++) { b[i].addActionListener(al); add(b[i]);</p>
<p>}</p>
<p>add(txt);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new MessageBoxes(), 200, 200);</p>
<p>} ///:~</p>
<p>To write a single ActionListener, I’ve used the somewhat risky approach of checking the String labels on the buttons. The problem with this is that it’s easy to get the label a little bit wrong, typically in capitalization, and this bug can be hard to spot.</p>
<p>Note that showOptionDialog( ) and showInputDialog( ) provide return objects that contain the value entered by the user.</p>
<p>Exercise 17: (5) Create an application using SwingConsole. In the JDK documentation from <a l:href="http://java.sun.com">http://java.sun.com</a>, find the JPasswordField and add this to the program. If the user types in the correct password, use JOptionPane to provide a success message to the user.</p>
<p>Exercise 18: (4) Modify MessageBoxes.java so that it has an individual ActionListener for each button (instead of matching the button text).</p>
<subtitle>Menus</subtitle>
<p>Each component capable of holding a menu, including JApplet, JFrame, JDialog, and their descendants, has a setJMenuBar( ) method that accepts a JMenuBar (you can have only one JMenuBar on a particular component). You add JMenus to the JMenuBar, and JMenuItems to the JMenus. Each JMenuItem can have an ActionListener attached to it, to be fired when that menu item is selected.</p>
<p>With Java and Swing you must hand assemble all the menus in source code. Here is a very simple menu example:</p>
<p>//: gui/SimpleMenus.java import javax.swing.*; import java.awt.*; import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class SimpleMenus extends JFrame { private JTextField t = new JTextField(15); private ActionListener al = new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>t.setText(((JMenuItem)e.getSource()).getText());</p>
<p>}</p>
<p>};</p>
<p>private JMenu[] menus = {</p>
<p>new JMenu(&quot;Winken&quot;), new JMenu(&quot;Blinken&quot;), new JMenu(&quot;Nod&quot;)</p>
<p>};</p>
<p>private JMenuItem[] items = {</p>
<p>new JMenuItem(&quot;Fee&quot;), new JMenuItem(&quot;Fi&quot;), new JMenuItem(&quot;Fo&quot;), new JMenuItem(&quot;Zip&quot;), new JMenuItem(&quot;Zap&quot;), new JMenuItem(&quot;Zot&quot;), new JMenuItem(&quot;Olly&quot;), new JMenuItem(&quot;Oxen&quot;), new JMenuItem(&quot;Free&quot;)</p>
<p>};</p>
<p>public SimpleMenus() {</p>
<p>for(int i = 0; i &lt; items.length; i++) { items[i].addActionListener(al); menus[i % 3].add(items[i]);</p>
<p>}</p>
<p>JMenuBar mb = new JMenuBar();</p>
<p>for(JMenu jm : menus) mb.add(jm); setJMenuBar(mb); setLayout(new FlowLayoutQ); add(t);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new SimpleMenus(), 200, 150);</p>
<p>}</p>
<p>} ///:~</p>
<p>The use of the modulus operator in &quot;i%3&quot; distributes the menu items among the three JMenus. Each JMenuItem must have an ActionListener attached to it; here, the same ActionListener is used everywhere, but you’ll usually need an individual one for each JMenuItem.</p>
<p>JMenuItem inherits AbstractButton, so it has some button-like behaviors. By itself, it provides an item that can be placed on a drop-down menu. There are also three types inherited from JMenuItem: JMenu, to hold other JMenultems (so you can have cascading menus); JCheckBoxMenuItem, which produces a check mark to indicate whether that menu item is selected; and JRadioButtonMenuItem, which contains a radio button.</p>
<p>As a more sophisticated example, here are the ice cream flavors again, used to create menus. This example also shows cascading menus, keyboard mnemonics, JCheckBoxMenuItems, and the way that you can dynamically change menus:</p>
<p>//: gui/Menus.java</p>
<p>// Submenus, check box menu items, swapping menus,</p>
<p>// mnemonics (shortcuts) and action commands. import javax.swing.*; import java.awt.*; import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class Menus extends JFrame { private String[] flavors = {</p>
<p>&quot;Chocolate&quot;, &quot;Strawberry&quot;, &quot;Vanilla Fudge Swirl&quot;,</p>
<p>&quot;Mint Chip&quot;, &quot;Mocha Almond Fudge&quot;, &quot;Rum Raisin&quot;,</p>
<p>&quot;Praline Cream&quot;, &quot;Mud Pie&quot;</p>
<p>};</p>
<p>private JTextField t = new JTextField(&quot;No flavor&quot;, 30); private JMenuBar mb1 = new JMenuBar(); private JMenu</p>
<p>f = new JMenu(&quot;File&quot;), m = new JMenu(&quot;Flavors&quot;), s = new JMenu(&quot;Safety&quot;);</p>
<p>// Alternative approach: private JCheckBoxMenuItem[] safety = { new JCheckBoxMenuItem(&quot;Guard&quot;), new JCheckBoxMenuItem(&quot;Hide&quot;)</p>
<p>};</p>
<p>private JMenuItem[] file = { new JMenuItem(&quot;Open&quot;) };</p>
<p>// A second menu bar to swap to: private JMenuBar mb2 = new JMenuBar(); private JMenu fooBar = new JMenu(&quot;fooBar&quot;); private JMenuItem[] other = {</p>
<p>// Adding a menu shortcut (mnemonic) is very // simple, but only JMenuItems can have them // in their constructors: new JMenuItem(&quot;Foo&quot;, KeyEvent.VK_F), new JMenuItem(&quot;Bar&quot;, KeyEvent.VK_A),</p>
<p>// No shortcut: new JMenuItem(&quot;Baz&quot;),</p>
<p>};</p>
<p>private JButton b = new JButton(&quot;Swap Menus&quot;); class BL implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) { JMenuBar m = getJMenuBar(); setJMenuBar(m == mb1 ? mb2 : mbl); validate(); // Refresh the frame</p>
<p>}</p>
<p>}</p>
<p>class ML implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) { JMenultem target = (JMenuItem)e.getSource(); String actionCommand = target.getActionCommand(); if(actionCommand.equals(&quot;Open&quot;)) {</p>
<p>String s = t.getText(); boolean chosen = false; for(String flavor : flavors) if(s.equals(flavor)) chosen = true; if(!chosen)</p>
<p>t.setText(&quot;Choose a flavor first!&quot;); else</p>
<p>t.setText(&quot;Opening &quot; + s + &quot;. Mmm, mm!&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class FL implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) { JMenultem target = (JMenuItem)e.getSource(); t.setText(target.getText());</p>
<p>}</p>
<p>}</p>
<p>// Alternatively, you can create a different // class for each different Menultem. Then you // don’t have to figure out which one it is: class FooL implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) { t.setText(&quot;Foo selected&quot;);</p>
<p>}</p>
<p>}</p>
<p>class BarL implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) { t.setText(&quot;Bar selected&quot;);</p>
<p>}</p>
<p>}</p>
<p>class BazL implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) { t.setText(&quot;Baz selected&quot;);</p>
<p>}</p>
<p>}</p>
<p>class CMIL implements ItemListener {</p>
<p>public void itemStateChanged(ItemEvent e) { JCheckBoxMenuItem target =</p>
<p>(JCheckBoxMenuItem)e.getSource();</p>
<p>String actionCommand = target.getActionCommand(); if(actionCommand.equals(&quot;Guard&quot;)) t.setText(&quot;Guard the Ice Cream! &quot; +</p>
<p>&quot;Guarding is &quot; + target.getState()); else if(actionCommand.equals(&quot;Hide&quot;)) t.setText(&quot;Hide the Ice Cream! &quot; +</p>
<p>&quot;Is it hidden? &quot; + target.getState());</p>
<p>public Menus() {</p>
<p>ML ml = new ML();</p>
<p>CMIL cmil = new CMIL();</p>
<p>safety[0].setActionCommand(&quot;Guard&quot;);</p>
<p>safety[0].setMnemonic(KeyEvent.VK_G);</p>
<p>safety[0].addItemListener(cmil);</p>
<p>safety[1].setActionCommand(&quot;Hide&quot;);</p>
<p>safety[1].setMnemonic(KeyEvent.VK_H);</p>
<p>safety[1].addItemListener(cmil);</p>
<p>other[0].addActionListener(new FooL());</p>
<p>other[1].addActionListener(new BarL());</p>
<p>other[2].addActionListener(new BazL());</p>
<p>FL fl = new FL(); int n = 0;</p>
<p>for(String flavor : flavors) {</p>
<p>JMenuItem mi = new JMenuItem(flavor);</p>
<p>mi.addActionListener(fl);</p>
<p>m.add(mi);</p>
<p>// Add separators at intervals: if((n++ + 1) % 3 == 0) m.addSeparator();</p>
<p>}</p>
<p>for(JCheckBoxMenuItem sfty : safety) s.add(sfty);</p>
<p>s. setMnemonic(KeyEvent.VK_A); f.add(s);</p>
<p>f.setMnemonic(KeyEvent.VK_F); for(int i = 0; i &lt; file.length; i++) { file[i].addActionListener(ml); f.add(file[i]);</p>
<p>}</p>
<p>mb1.add(f);</p>
<p>mb1.add(m);</p>
<p>setJMenuBar(mb1);</p>
<p>t. setEditable(false); add(t, BorderLayout.CENTER);</p>
<p>// Set up the system for swapping menus: b.addActionListener(new BL()); b.setMnemonic(KeyEvent.VK_S); add(b, BorderLayout.NORTH); for(JMenuItem oth : other) fooBar.add(oth);</p>
<p>fooBar.setMnemonic(KeyEvent.VK_B);</p>
<p>mb2.add(fooBar);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new Menus(), 300, 200);</p>
<p>}</p>
<p>} ///:~</p>
<p>In this program I placed the menu items into arrays and then stepped through each array, calling add( ) for each JMenuItem. This makes adding or subtracting a menu item somewhat less tedious.</p>
<p>This program creates two JMenuBars to demonstrate that menu bars can be actively swapped while the program is running. You can see how a JMenuBar is made up of JMenus, and each JMenu is made up of JMenuItems, JCheckBoxMenuItems, or even other JMenus (which produce submenus). When a JMenuBar is assembled, it can be installed into the current program with the setJMenuBar( ) method. Note that when the</p>
<p>button is pressed, it checks to see which menu is currently installed by calling getJMenuBar( ), then it puts the other menu bar in its place.</p>
<p>When testing for &quot;Open,&quot; notice that spelling and capitalization are critical, but Java signals no error if there is no match with &quot;Open.&quot; This kind of string comparison is a source of programming errors.</p>
<p>The checking and unchecking of the menu items is taken care of automatically. The code handling the JCheckBoxMenuItems shows two different ways to determine what was checked: string matching (the less-safe approach, although you’ll see it used) and matching on the event target object. As shown, the getState( ) method can be used to reveal the state. You can also change the state of a JCheckBoxMenuItem with setState( ).</p>
<p>The events for menus are a bit inconsistent and can lead to confusion: JMenuItems use ActionListeners, but JCheckBoxMenuItems use ItemListeners. The JMenu objects can also support ActionListeners, but that’s not usually helpful. In general, you’ll attach listeners to each JMenuItem, JCheckBoxMenuItem, or JRadioButtonMenuItem,</p>
<p>but the example shows ItemListeners and ActionListeners attached to the various menu components.</p>
<p>Swing supports mnemonics, or &quot;keyboard shortcuts,&quot; so you can select anything derived from AbstractButton (button, menu item, etc.) by using the keyboard instead of the mouse. These are quite simple; for JMenuItem, you can use the overloaded constructor that takes, as a second argument, the identifier for the key. However, most AbstractButtons do not have constructors like this, so the more general way to solve the problem is to use the setMnemonic( ) method. The preceding example adds mnemonics to the button and some of the menu items; shortcut indicators automatically appear on the components.</p>
<p>You can also see the use of setActionCommand( ). This seems a bit strange because in each case, the &quot;action command&quot; is exactly the same as the label on the menu component. Why not just use the label instead of this alternative string? The problem is internationalization. If you retarget this program to another language, you want to change only the label in the menu, and not change the code (which would no doubt introduce new errors). By using setActionCommand( ), the &quot;action command&quot; can be immutable, but the menu label can change. All the code works with the &quot;action command,&quot; so it’s unaffected by changes to the menu labels. Note that in this program, not all the menu components are examined for their action commands, so those that aren’t do not have their action command set.</p>
<p>The bulk of the work happens in the listeners. BL performs the JMenuBar swapping. In ML, the &quot;figure out who rang&quot; approach is taken by getting the source of the ActionEvent and casting it to a JMenuItem, then getting the action command string to pass it through a cascaded if statement.</p>
<p>The FL listener is simple even though it’s handling all the different flavors in the flavor menu. This approach is useful if you have enough simplicity in your logic, but in general, you’ll want to take the approach used with FooL, BarL, and BazL, in which each is attached to only a single menu component, so no extra detection logic is necessary, and you know exactly who called the listener. Even with the profusion of classes generated this way, the code inside tends to be smaller, and the process is more foolproof.</p>
<p>You can see that menu code quickly gets long-winded and messy. This is another case where the use of a GUI builder is the appropriate solution. A good tool will also handle the maintenance of the menus.</p>
<p>Exercise 19: (3) Modify Menus.java to use radio buttons instead of check boxes on the menus.</p>
<p>Exercise 20: (6) Create a program that breaks a text file into words. Distribute those words as labels on menus and submenus.</p>
<subtitle>Pop-up menus</subtitle>
<p>The most straightforward way to implement a JPopupMenu is to create an inner class that extends MouseAdapter, then add an object of that inner class to each component that you want to produce pop-up behavior:</p>
<p>//: gui/Popup.java</p>
<p>// Creating popup menus with Swing.</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class Popup extends JFrame {</p>
<p>private JPopupMenu popup = new JPopupMenu(); private JTextField t = new JTextField(10); public Popup() {</p>
<p>setLayout(new FlowLayout()); add(t);</p>
<p>ActionListener al = new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>t.setText(((JMenuItem)e.getSource()).getText());</p>
<p>}</p>
<p>};</p>
<p>JMenultem m = new JMenuItem(&quot;Hither&quot;);</p>
<p>m.addActionListener(al);</p>
<p>popup.add(m);</p>
<p>m = new JMenuItem(&quot;Yon&quot;);</p>
<p>m.addActionListener(al);</p>
<p>popup.add(m);</p>
<p>m = new JMenuItem(&quot;Afar&quot;);</p>
<p>m.addActionListener(al);</p>
<p>popup.add(m);</p>
<p>popup.addSeparator();</p>
<p>m = new JMenuItem(&quot;Stay Here&quot;);</p>
<p>m.addActionListener(al);</p>
<p>popup.add(m);</p>
<p>PopupListener pl = new PopupListener();</p>
<p>addMouseListener(pl);</p>
<p>t.addMouseListener(pl);</p>
<p>}</p>
<p>class PopupListener extends MouseAdapter { public void mousePressed(MouseEvent e) { maybeShowPopup(e);</p>
<p>}</p>
<p>public void mouseReleased(MouseEvent e) { maybeShowPopup(e);</p>
<p>}</p>
<p>private void maybeShowPopup(MouseEvent e) { if(e.isPopupTrigger())</p>
<p>popup.show(e.getComponent(), e.getX(), e.getY());</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) { run(new Popup(), 300, 200);</p>
<p>}</p>
<p>} ///:~</p>
<p>The same ActionListener is added to each JMenuItem. It fetches the text from the menu label and inserts it into the JTextField.</p>
<subtitle>Drawing</subtitle>
<p>In a good GUI framework, drawing should be reasonably easy—and it is, in the Swing library. The problem with any drawing example is that the calculations that determine where things go are typically a lot more complicated than the calls to the drawing routines, and these calculations are often mixed together with the drawing calls, so it can seem that the interface is more complicated than it actually is.</p>
<p>For simplicity, consider the problem of representing data on the screenhere, the data will be provided by the built-in Math.sin( ) method, which produces a mathematical sine function. To make things a little more interesting, and to further demonstrate how easy it is to use Swing components, a slider will be placed at the bottom of the form to dynamically control the number of sine wave cycles that are displayed. In addition, if you resize the window, you’ll see that the sine wave refits itself to the new window size.</p>
<p>Although any JComponent may be painted and thus used as a canvas, if you just want a straightforward drawing surface, you will typically inherit from a JPanel. The only method you need to override is paintComponent( ), which is called whenever that component must be repainted (you normally don’t need to worry about this, because the decision is managed by Swing). When it is called, Swing passes a Graphics object to the method, and you can then use this object to draw or paint on the surface.</p>
<p>In the following example, all the intelligence concerning painting is in the SineDraw class; the SineWave class simply configures the program and the slider control. Inside SineDraw, the setCycles( ) method provides a hook to allow another object—the slider control, in this case—to control the number of cycles.</p>
<p>//: gui/SineWave.java</p>
<p>// Drawing with Swing, using a JSlider. import javax.swing.*; import javax.swing.event.*; import java.awt.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>class SineDraw extends JPanel {</p>
<p>private static final int SCALEFACTOR = 200; private int cycles; private int points; private double[] sines; private int[] pts; public SineDraw() { setCycles(5); } public void paintComponent(Graphics g) { super.paintComponent(g); int maxWidth = getWidth();</p>
<p>double hstep = (double)maxWidth / (double)points; int maxHeight = getHeight(); pts = new int[points]; for(int i = 0; i &lt; points; i++) pts[i] =</p>
<p>(int)(sines[i] * maxHeight/2 * .95 + maxHeight/2); g.setColor(Color.RED); for(int i = 1; i &lt; points; i++) { int    x1    =    (int)((i - 1)    *    hstep);</p>
<p>int    x2    =    (int)(i * hstep);</p>
<p>int    y1    =    pts[i-1];</p>
<p>int    y2    =    pts[i];</p>
<p>g.drawLine(x1, y1, x2, y2);</p>
<p>public void setCycles(int newCycles) { cycles = newCycles; points = SCALEFACTOR * cycles * 2; sines = new double[points]; for(int i = 0; i &lt; points; i++) {</p>
<p>double radians = (Math.PI / SCALEFACTOR) * i; sines[i] = Math.sin(radians);</p>
<p>}</p>
<p>repaint();</p>
<p>}</p>
<p>}</p>
<p>public class SineWave extends JFrame { private SineDraw sines = new SineDraw(); private JSlider adjustCycles = new JSlider(1, 30, 5); public SineWave() { add(sines);</p>
<p>adjustCycles.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent e) { sines.setCycles(</p>
<p>((JSlider)e.getSource()).getValue());</p>
<p>}</p>
<p>});</p>
<p>add(BorderLayout.SOUTH, adjustCycles);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new SineWave(), 700, 400);</p>
<p>}</p>
<p>} ///:~</p>
<p>All of the fields and arrays are used in the calculation of the sine wave points; cycles indicates the number of complete sine waves desired, points contains the total number of points that will be graphed, sines contains the sine function values, and pts contains the y-coordinates of the points that will be drawn on the JPanel. The setCycles( ) method creates the arrays according to the number of points needed and fills the sines array with numbers. By calling repaint( ), setCycles( ) forces paintComponent( ) to be called so the rest of the calculation and redraw will take place.</p>
<p>The first thing you must do when you override paintComponent( ) is to call the base-class version of the method. Then you are free to do whatever you like; normally, this means using the Graphics methods that you can find in the documentation for java.awt.Graphics (in the JDK documentation from <a l:href="http://java.sun.com">http://java.sun.com</a>) to draw and paint pixels onto the JPanel. Here, you can see that almost all the code is involved in performing the calculations; the only two method calls that actually manipulate the screen are setColor( ) and drawLine( ). You will probably have a similar experience when creating your own program that displays graphical data; you’ll spend most of your time figuring out what it is you want to draw, but the actual drawing process will be quite simple.</p>
<p>When I created this program, the bulk of my time was spent in getting the sine wave to display. Once I did that, I thought it would be nice to dynamically change the number of cycles. My programming experiences when trying to do such things in other languages made me a bit reluctant to try this, but it turned out to be the easiest part of the project. I created a JSlider (the arguments are the leftmost value of the JSIider, the rightmost value, and the starting value, respectively, but there are other constructors as well) and dropped it into the JFrame. Then I looked at the JDK documentation and noticed that the only listener was the addChangeListener, which was triggered whenever the slider was changed enough for it to produce a different value. The only method for this was the obviously named stateChanged( ), which provided a ChangeEvent object so that I could look backward to</p>
<p>the source of the change and find the new value. Calling the sines object’s setCycles( ) enabled the new value to be incorporated and the JPanel to be redrawn.</p>
<p>In general, you will find that most of your Swing problems can be solved by following a similar process, and you’ll find that it’s generally quite simple, even if you haven’t used a particular component before.</p>
<p>If your problem is more complex, there are other, more sophisticated alternatives for drawing, including third-party JavaBeans components and the Java 2D API. These solutions are beyond the scope of this book, but you should look them up if your drawing code becomes too onerous.</p>
<p>Exercise 21: (5) Modify SineWave.java to turn SineDraw into a JavaBean by adding &quot;getter&quot; and &quot;setter&quot; methods.</p>
<p>Exercise 22: (7) Create an application using SwingConsole. This should have three sliders, one each for the red, green, and blue values in java.awt.Color. The rest of the form should be a JPanel that displays the color determined by the three sliders. Also include noneditable text fields that show the current RGB values.</p>
<p>Exercise 23: (8) Using SineWave.java as a starting point, create a program that displays a rotating square on the screen. One slider should control the speed of rotation, and a second slider should control the size of the box.</p>
<p>Exercise 24: (7) Remember the &quot;sketching box&quot; toy with two knobs, one that controls the vertical movement of the drawing point, and one that controls the horizontal movement? Create a variation of this toy, using SineWave.java to get you started. Instead of knobs, use sliders. Add a button that will erase the entire sketch.</p>
<p>Exercise 25: (8) Starting with SineWave.java, create a program (an application using the SwingConsole class) that draws an animated sine wave that appears to scroll past the viewing window like an oscilloscope, driving the animation with a java.util.Timer. The speed of the animation should be controlled with a javax.swing.JSlider control.</p>
<p>Exercise 26: (5) Modify the previous exercise so that multiple sine wave panels are created within the application. The number of sine wave panels should be controlled by command-line parameters.</p>
<p>Exercise 27: (5) Modify Exercise 25 so that the javax.swing.Timer class is used to drive the animation. Note the difference between this and java.util.Timer.</p>
<p>Exercise 28: (7) Create a dice class (just a class, without a GUI). Create five dice and throw them repeatedly. Draw the curve showing the sum of the dots from each throw, and show the curve evolving dynamically as you throw more and more times.</p>
<subtitle>Dialog boxes</subtitle>
<p>A dialog box is a window that pops up out of another window. Its purpose is to deal with some specific issue without cluttering the original window with those details. Dialog boxes are commonly used in windowed programming environments.</p>
<p>To create a dialog box, you inherit from JDialog, which is just another kind of Window, like a JFrame. A JDialog has a layout manager (which defaults to BorderLayout), and you add event listeners to deal with events. Here’s a very simple example:</p>
<p>//: gui/Dialogs.java</p>
<p>// Creating and using Dialog Boxes.</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>class MyDialog extends JDialog { public MyDialog(JFrame parent) { super(parent, &quot;My dialog&quot;, true); setLayout(new FlowLayout()); add(new JLabel(&quot;Here is my dialog&quot;));</p>
<p>JButton ok = new JButton(&quot;OK&quot;); ok.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { dispose(); // Closes the dialog</p>
<p>}</p>
<p>});</p>
<p>add(ok);</p>
<p>setSize(150,125);</p>
<p>}</p>
<p>}</p>
<p>public class Dialogs extends JFrame {</p>
<p>private JButton b1 = new JButton(&quot;Dialog Box&quot;); private MyDialog dlg = new MyDialog(null); public Dialogs() {</p>
<p>b1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { dlg.setVisible(true);</p>
<p>}</p>
<p>});</p>
<p>add(b1);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new Dialogs(), 125, 75);</p>
<p>}</p>
<p>} ///:~</p>
<p>Once the JDialog is created, setVisible(true) must be called to display and activate it. When the dialog window is closed, you must release the resources used by the dialog’s window by calling dispose( ).</p>
<p>The following example is more complex; the dialog box is made up of a grid (using GridLayout) of a special kind of button that is defined here as class ToeButton. This button draws a frame around itself and, depending on its state, a blank, an &quot;x,&quot; or an &quot;o&quot; in the middle. It starts out blank, and then depending on whose turn it is, changes to an &quot;x&quot; or an &quot;o.&quot; However, it will also flip back and forth between &quot;x&quot; and &quot;o&quot; when you click on the button, to provide an interesting variation on the tic-tac-toe concept. In addition, the dialog box can be set up for any number of rows and columns by changing numbers in the main application window.</p>
<p>//: gui/TicTacToe.java</p>
<p>// Dialog boxes and creating your own components. import javax.swing.*; import java.awt.*; import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class TicTacToe extends JFrame { private JTextField</p>
<p>rows = new JTextField(&quot;3&quot;),</p>
<p>cols = new JTextField(&quot;3&quot;); private enum State { BLANK, XX, OO } static class ToeDialog extends JDialog {</p>
<p>private State turn = State.XX; // Start with x’s turn ToeDialog(int cellsWide, int cellsHigh) { setTitle(&quot;The game itself&quot;);</p>
<p>setLayout(new GridLayout(cellsWide, cellsHigh)); for(int i = 0; i &lt; cellsWide * cellsHigh; i++) add(new ToeButton()); setSize(cellsWide * 50, cellsHigh * 50); setDefaultCloseOperation(DISPOSE_ON_CLOSE);</p>
<p>}</p>
<p>class ToeButton extends JPanel { private State state = State.BLANK; public ToeButton() { addMouseListener(new ML()); } public void paintComponent(Graphics g) { super.paintComponent(g); int</p>
<p>x1 = 0, y1 = 0, x2 = getSize().width - 1, y2 = getSize().height - 1; g.drawRect(x1, y1, x2, y2); x1 = x2/4; y1 = y2/4;</p>
<p>int wide = x2/2, high = y2/2; if(state == State.XX) {</p>
<p>g.drawLine(x1, y1, x1 + wide, y1 + high); g.drawLine(x1, y1 + high, x1 + wide, y1);</p>
<p>}</p>
<p>if(state == State.OO)</p>
<p>g.drawOval(x1, y1, x1 + wide/2, y1 + high/2);</p>
<p>}</p>
<p>class ML extends MouseAdapter {</p>
<p>public void mousePressed(MouseEvent e) { if(state == State.BLANK) { state = turn; turn =</p>
<p>(turn == State.XX ? State.OO : State.XX);</p>
<p>}</p>
<p>else</p>
<p>state =</p>
<p>(state == State.XX ? State.OO : State.XX); repaint();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class BL implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) {</p>
<p>JDialog d = new ToeDialog( new Integer(rows.getText()), new Integer(cols.getText())); d.setVisible(true);</p>
<p>}</p>
<p>}</p>
<p>public TicTacToe() {</p>
<p>JPanel p = new JPanel(); p.setLayout(new GridLayout(2,2)); p.add(new JLabel(&quot;Rows&quot;, JLabel.CENTER)); p.add(rows);</p>
<p>p.add(new JLabel(&quot;Columns&quot;, JLabel.CENTER)); p.add(cols);</p>
<p>add(p, BorderLayout.NORTH);</p>
<p>JButton b = new JButton(&quot;go&quot;); b.addActionListener(new BL()); add(b, BorderLayout.SOUTH);</p>
<p>public static void main(String[] args) { run(new TicTacToe(), 200, 200);</p>
<p>}</p>
<p>} ///:~</p>
<p>Because statics can only be at the outer level of the class, inner classes cannot have static data or nested classes.</p>
<p>The paintComponent( ) method draws the square around the panel and the &quot;x&quot; or the &quot;o.&quot; This is full of tedious calculations, but it’s straightforward.</p>
<p>A mouse click is captured by the MouseListener, which first checks to see if the panel has anything written on it. If not, the parent window is queried to find out whose turn it is, which establishes the state of the ToeButton. Via the inner-class mechanism, the ToeButton then reaches back into the parent and changes the turn. If the button is already displaying an &quot;x&quot; or an &quot;o,&quot; then that is flopped. You can see in these calculations the convenient use of the ternary if-else described in the Operators chapter. After a state change, the ToeButton is repainted.</p>
<p>The constructor for ToeDialog is quite simple: It adds into a GridLayout as many buttons as you request, then resizes it for 50 pixels on a side for each button.</p>
<p>TicTacToe sets up the whole application by creating the JTextFields (for inputting the rows and columns of the button grid) and the &quot;go&quot; button with its ActionListener. When the button is pressed, the data in the JTextFields must be fetched, and, since they are in String form, turned into ints using the Integer constructor that takes a String argument.</p>
<subtitle>File dialogs</subtitle>
<p>Some operating systems have a number of special built-in dialog boxes to handle the selection of things such as fonts, colors, printers, and the like. Virtually all graphical operating systems support the opening and saving of files, so Java’s JFileChooser encapsulates these for easy use.</p>
<p>The following application exercises two forms of JFileChooser dialogs, one for opening and one for saving. Most of the code should by now be familiar, and all the interesting activities happen in the action listeners for the two different button clicks:</p>
<p>//: gui/FileChooserTest.java // Demonstration of File dialog boxes. import javax.swing.*; import java.awt.*; import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class FileChooserTest extends JFrame { private JTextField</p>
<p>fileName = new JTextField(), dir = new JTextField(); private JButton</p>
<p>open = new JButton(&quot;Open&quot;), save = new JButton(&quot;Save&quot;); public FileChooserTest() {</p>
<p>JPanel p = new JPanel();</p>
<p>open.addActionListener(new OpenL()); p.add(open);</p>
<p>save.addActionListener(new SaveL()); p.add(save);</p>
<p>add(p, BorderLayout.SOUTH);</p>
<p>dir.setEditable(false);</p>
<p>fileName.setEditable(false);</p>
<p>p = new JPanel();</p>
<p>p.setLayout(new GridLayout(2,1));</p>
<p>p.add(fileName);</p>
<p>p.add(dir);</p>
<p>add(p, BorderLayout.NORTH);</p>
<p>}</p>
<p>class OpenL implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) {</p>
<p>JFileChooser c = new JFileChooser();</p>
<p>// Demonstrate &quot;Open&quot; dialog:</p>
<p>int rVal = c.showOpenDialog(FileChooserTest.this); if(rVal == JFileChooser.APPROVE_OPTION) {</p>
<p>fileName.setText(c.getSelectedFile().getName());</p>
<p>dir.setText(c.getCurrentDirectory().toString());</p>
<p>}</p>
<p>if(rVal == JFileChooser.CANCEL_OPTION) { fileName.setText(&quot;You pressed cancel&quot;); dir.setText(&quot;&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class SaveL implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) {</p>
<p>JFileChooser c = new JFileChooser();</p>
<p>// Demonstrate &quot;Save&quot; dialog:</p>
<p>int rVal = c.showSaveDialog(FileChooserTest.this); if(rVal == JFileChooser.APPROVE_OPTION) {</p>
<p>fileName.setText(c.getSelectedFile().getName());</p>
<p>dir.setText(c.getCurrentDirectory().toString());</p>
<p>}</p>
<p>if(rVal == JFileChooser.CANCEL_OPTION) { fileName.setText(&quot;You pressed cancel&quot;); dir.setText(&quot;&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) { run(new FileChooserTest(), 250, 150);</p>
<p>}</p>
<p>} ///:~</p>
<p>Note that there are many variations you can apply to JFileChooser, including filters to narrow the file names that you will allow.</p>
<p>For an &quot;open file&quot; dialog, you call showOpenDialog( ), and for a &quot;save file&quot; dialog, you call showSaveDialog( ). These commands don’t return until the dialog is closed. The JFileChooser object still exists, so you can read data from it. The methods getSelectedFile( ) and getCurrentDirectory( ) are two ways you can interrogate the results of the operation. If these return null, it means the user canceled out of the dialog.</p>
<p>Exercise 29: (3) In the JDK documentation for javax.swing, look up the JColorChooser. Write a program with a button that brings up the color chooser as a dialog.</p>
<subtitle>HTML on Swing components</subtitle>
<p>Any component that can take text can also take HTML text, which it will reformat according to HTML rules. This means you can very easily add fancy text to a Swing component. For example:</p>
<p>//: gui/HTMLButton.java</p>
<p>// Putting HTML text on Swing components. import javax.swing.*; import java.awt.*; import java.awt.event.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class HTMLButton extends JFrame { private JButton b = new JButton(</p>
<p>&quot;&lt;html&gt;&lt;b&gt;&lt;font size=+2&gt;&quot; +</p>
<p>&quot;&lt;center&gt;Hello!&lt;br&gt;&lt;i&gt;Press me now!&quot;); public HTMLButton() {</p>
<p>b.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { add(new JLabel(&quot;&lt;html&gt;&quot; +</p>
<p>&quot;&lt;i&gt;&lt;font size=+4&gt;Kapow!&quot;));</p>
<p>// Force a re-layout to include the new label: validate();</p>
<p>}</p>
<p>});</p>
<p>setLayout(new FlowLayout()); add(b);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new HTMLButton(), 200, 500);</p>
<p>}</p>
<p>} ///:~</p>
<p>You must start the text with &quot;&lt;html&gt;,&quot; and then you can use normal HTML tags. Note that you are not forced to include the normal closing tags.</p>
<p>The ActionListener adds a new JLabel to the form, which also contains HTML text. However, this label is not added during construction, so you must call the container’s validate( ) method in order to force a re-layout of the components (and thus the display of the new label).</p>
<p>You can also use HTML text for JTabbedPane, JMenuItem, JToolTip, JRadioButton, and JCheckBox.</p>
<p>Exercise 30: (3) Write a program that shows the use of HTML text on all the items from the previous paragraph.</p>
<subtitle>Sliders and progress bars</subtitle>
<p>A slider (which has already been used in SineWave.java) allows the user to input data by moving a point back and forth, which is intuitive in some situations (volume controls, for example). A progress bar displays data in a relative fashion from &quot;full&quot; to &quot;empty&quot; so the user gets a perspective. My favorite example for these is to simply hook the slider to the progress bar so when you move the slider, the progress bar changes accordingly. The following example also demonstrates the ProgressMonitor, a more fullfeatured pop-up dialog:</p>
<p>//: gui/Progress.java // Using sliders, progress bars and progress monitors.</p>
<p>import javax.swing.*;</p>
<p>import javax.swing.border.*;</p>
<p>import javax.swing.event.*;</p>
<p>import java.awt.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class Progress extends JFrame {</p>
<p>private JProgressBar pb = new JProgressBar(); private ProgressMonitor pm = new ProgressMonitor( this, &quot;Monitoring Progress&quot;, &quot;Test&quot;, 0, 100); private JSlider sb =</p>
<p>new JSlider(JSlider.HORIZONTAL, 0, 100, 60); public Progress() {</p>
<p>setLayout(new GridLayout(2,1)); add(pb);</p>
<p>pm.setProgress(0);</p>
<p>pm.setMillisToPopup(1000);</p>
<p>sb.setValue(0);</p>
<p>sb.setPaintTicks(true);</p>
<p>sb.setMajorTickSpacing(20);</p>
<p>sb.setMinorTickSpacing(5);</p>
<p>sb.setBorder(new TitledBorder(&quot;Slide Me&quot;));</p>
<p>pb.setModel(sb.getModel()); // Share model</p>
<p>add(sb);</p>
<p>sb.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent e) { pm.setProgress(sb.getValue());</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>public static void main(String[] args) { run(new Progress(), 300, 200);</p>
<p>}</p>
<p>} ///:~</p>
<p>The key to hooking the slider and progress bar components together is in sharing their model, in the line:</p>
<p>pb.setModel(sb.getModel());</p>
<p>Of course, you could also control the two using a listener, but using the model is more straightforward for simple situations. The ProgressMonitor does not have a model and so the listener approach is required. Note that the ProgressMonitor only moves forward, and once it reaches the end it closes. The JProgressBar is fairly straightforward, but the JSlider has a lot of options, such as the orientation and major and minor tick marks. Notice how straightforward it is to add a titled border.</p>
<p>Exercise 31: (8) Create an &quot;asymptotic progress indicator&quot; that gets slower and slower as it approaches the finish point. Add random erratic behavior so it will periodically look like it’s starting to speed up.</p>
<p>Exercise 32: (6) Modify Progress.java so that it does not share models, but instead uses a listener to connect the slider and progress bar.</p>
<subtitle>Selecting look &amp; feel</subtitle>
<p>&quot;Pluggable look &amp; feel&quot; allows your program to emulate the look and feel of various operating environments. You can even dynamically change the look and feel while the program is executing. However, you generally just want to do one of two things: either select the &quot;crossplatform&quot; look and feel (which is Swing’s &quot;metal&quot;), or select the look and feel for the system you are currently on so your Java program looks like it was created specifically for that system (this is almost certainly the best choice in most cases, to avoid confounding the user). The code to select either of these behaviors is quite simple, but you must execute it before you create any visual components, because the components will be made based on the current look and feel, and will not be changed just because you happen to change the look and feel midway during the program (that process is more complicated and uncommon, and is relegated to Swing-specific books).</p>
<p>Actually, if you want to use the cross-platform (&quot;metal&quot;) look and feel that is characteristic of Swing programs, you don’t have to do anything—it’s the default. But if you want instead to use the current operating environment’s look and feel,<a l:href="#bookmark140" type="note"><sup>141</sup></a><sup></sup> you just insert the following code, typically at the beginning of your main( ), but at least before any components are added:</p>
<p>try {</p>
<p>UIManager.setLookAndFeet(</p>
<p>UIManager.getSystemLookAndFeelClassName());</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>You don’t actually need anything in the catch clause because the UIManager will default to the cross-platform look and feel if your attempts to set up any of the alternatives fail. However, during debugging, the exception can be quite useful, so you may at least want to see some results via the catch clause.</p>
<p>Here is a program that takes a command-line argument to select a look and feel, and shows how several different components look under the chosen look and feel:</p>
<p>//: gui/LookAndFeel.java // Selecting different looks &amp; feels.</p>
<p>// {Args: motif} import javax.swing.*; import java.awt.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class LookAndFeel extends JFrame { private String[] choices =</p>
<p>&quot;Eeny Meeny Minnie Mickey Moe Larry Curly&quot;.split(&quot; &quot;); private Component[] samples = { new JButton(&quot;JButton&quot;), new JTextField(&quot;JTextField&quot;), new JLabel(&quot;JLabel&quot;), new JCheckBox(&quot;JCheckBox&quot;), new JRadioButton(&quot;Radio&quot;), new JComboBox(choices), new JList(choices),</p>
<p>};</p>
<p>public LookAndFeel() { super(&quot;Look And Feel&quot;); setLayout(new FlowLayout()); for(Component component : samples) add(component);</p>
<p>}</p>
<p>private static void usageError() {</p>
<p>System.out.println(</p>
<p>&quot;Usage:LookAndFeel [crossjsystemjmotif]&quot;);</p>
<p>System.exit(l);</p>
<p>public static void main(String[] args) { if(args.length == 0) usageError(); if(args[0].equals(&quot;cross&quot;)) { try {</p>
<p>UIManager.setLookAndFeel(UIManager.</p>
<p>getCrossPlatformLookAndFeelClassName());</p>
<p>} catch(Exception e) { e.printStackTrace();</p>
<p>}</p>
<p>} else if(args[0].equals(&quot;system&quot;)) { try {</p>
<p>UIManager.setLookAndFeel(UIManager.</p>
<p>getSystemLookAndFeelClassName());</p>
<p>} catch(Exception e) { e.printStackTrace();</p>
<p>}</p>
<p>} else if(args[0].equals(&quot;motif&quot;)) { try {</p>
<p>UIManager.setLookAndFeel(&quot;com.sun.java.&quot;+</p>
<p>&quot;swing.plaf.motif.MotifLookAndFeel&quot;);</p>
<p>} catch(Exception e) { e.printStackTrace();</p>
<p>}</p>
<p>} else usageError();</p>
<p>// Note the look &amp; feel must be set before // any components are created. run(new LookAndFeel(), 300, 300);</p>
<p>}</p>
<p>} ///:~</p>
<p>You can see that one option is to explicitly specify a string for a look and feel, as seen with MotifLookAndFeel. However, that one and the default &quot;metal&quot; look and feel are the only ones that can legally be used on any platform; even though there are look-and-feel strings for Windows and Macintosh, those can only be used on their respective platforms (these are produced when you call getSystemLookAndFeelClassName( ) and you’re on that particular platform).</p>
<p>It is also possible to create a custom look and feel package, for example, if you are building a framework for a company that wants a distinctive appearance. This is a big job and is far beyond the scope of this book (in fact, you’ll discover it is beyond the scope of many dedicated Swing books!).</p>
<subtitle>Trees, tables &amp; clipboard</subtitle>
<p>You can find a brief introduction and examples for these topics in the online supplements for this chapter at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
<section>
<title>
<p>JNLP and Java Web Start</p></title><empty-line/>
<p>It’s possible to sign an applet for security purposes. This is shown in the online supplement for this chapter at <a l:href="http://www.MindView.net">www.MindView.net</a>. Signed applets are powerful and can effectively take the place of an application, but they must run inside a Web browser. This requires the extra overhead of the browser running on the client machine, and also means that the user</p>
<p>interface of the applet is limited and often visually confusing. The Web browser has its own set of menus and toolbars, which will appear above the applet.<a l:href="#bookmark141" type="note"><sup>142</sup></a><sup></sup></p>
<p>The Java Network Launch Protocol (JNLP) solves the problem without sacrificing the advantages of applets. With a JNLP application, you can download and install a standalone Java application onto the client’s machine. This can be run from the command prompt, a desktop icon, or the application manager that is installed with your JNLP implementation. The application can even be run from the Web site from which it was originally downloaded.</p>
<p>A JNLP application can dynamically download resources from the Internet at run time, and can automatically check the version if the user is connected to the Internet. This means that it has all of the advantages of an applet together with the advantages of standalone applications.</p>
<p>Like applets, JNLP applications need to be treated with some caution by the client’s system. Because of this, JNLP applications are subject to the same sandbox security restrictions as applets. Like applets, they can be deployed in signed JAR files, giving the user the option to trust the signer. Unlike applets, if they are deployed in an unsigned JAR file, they can still request access to certain resources of the client’s system by means of services in the JNLP API. The user must approve these requests during program execution.</p>
<p>JNLP describes a protocol, not an implementation, so you will need an implementation in order to use it. Java Web Start, or JAWS, is Sun’s freely available official reference implementation and is distributed as part of Java SE5- If you are using it for development, you must ensure that the JAR file (javaws.jar) is in your classpath; the easiest solution is to add javaws.jar to your classpath from its normal Java installation path in jre/lib. If you are deploying your JNLP application from a Web server, you must ensure that your server recognizes the MIME type application/x-java-jnlp-file. If you are using a recent version of the Tomcat server (<a l:href="http://jakarta.apache.org/tomcat">http://jakarta.apache.org/tomcat</a>) this is pre-configured. Consult the user guide for your particular server.</p>
<p>Creating a JNLP application is not difficult. You create a standard application that is archived in a JAR file, and then you provide a launch file, which is a simple XML file that gives the client system all the information it needs to download and install your application. If you choose not to sign your JAR file, then you must use the services supplied by the JNLP API for each type of resource you want to access on the user’s machine.</p>
<p>Here is a variation of FileChooserTest.java using the JNLP services to open the file chooser, so that the class can be deployed as a JNLP application in an unsigned JAR file.</p>
<p>//: gui/jnlp/JnlpFileChooser.java</p>
<p>// Opening files on a local machine with JNLP.</p>
<p>// {Requires: javax.jnlp.FileOpenService;</p>
<p>// You must have javaws.jar in your classpath}</p>
<p>// To create the jnlpfilechooser.jar file, do this:</p>
<p>// cd ..</p>
<p>// cd ..</p>
<p>// jar cvf gui/jnlp/jnlpfilechooser.jar gui/jnlp/*.class</p>
<p>package gui.jnlp;</p>
<p>import javax.jnlp.*;</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import java.io.*;</p>
<p>public class JnlpFileChooser extends JFrame { private JTextField fileName = new JTextField();</p>
<p>private JButton</p>
<p>open = new JButton(&quot;Open&quot;), save = new JButton(&quot;Save&quot;); private JEditorPane ep = new JEditorPane(); private JScrollPane jsp = new JScrollPane(); private FileContents fileContents; public JnlpFileChooser() {</p>
<p>JPanel p = new JPanel(); open.addActionListener(new OpenL()); p.add(open);</p>
<p>save.addActionListener(new SaveL()); p.add(save);</p>
<p>jsp.getViewport().add(ep);</p>
<p>add(jsp, BorderLayout.CENTER);</p>
<p>add(p, BorderLayout.SOUTH);</p>
<p>fileName.setEditable(false);</p>
<p>p = new JPanel();</p>
<p>p.setLayout(new GridLayout(2,1));</p>
<p>p.add(fileName);</p>
<p>add(p, BorderLayout.NORTH);</p>
<p>ep.setContentType(&quot;text&quot;);</p>
<p>save.setEnabled(false);</p>
<p>}</p>
<p>class OpenL implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) { FileOpenService fs = null; try {</p>
<p>fs = (FileOpenService)ServiceManager.lookup( &quot;javax.jnlp.FileOpenService&quot;);</p>
<p>} catch(UnavailableServiceException use) { throw new RuntimeException(use);</p>
<p>}</p>
<p>if(fs != null) { try {</p>
<p>fileContents = fs.openFileDialog(&quot;.&quot;, new String[]{&quot;txt&quot;, &quot;*&quot;}); if(fileContents == null) return;</p>
<p>fileName.setText(fileContents.getName()); ep.read(fileContents.getInputStream(), null); } catch(Exception exc) {</p>
<p>throw new RuntimeException(exc);</p>
<p>}</p>
<p>save.setEnabled(true);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class SaveL implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) { FileSaveService fs = null; try {</p>
<p>fs = (FileSaveService)ServiceManager.lookup( &quot;javax.jnlp.FileSaveService&quot;);</p>
<p>} catch(UnavailableServiceException use) { throw new RuntimeException(use);</p>
<p>}</p>
<p>if(fs != null) { try {</p>
<p>fileContents = fs.saveFileDialog(&quot;.&quot;, new String[]{&quot;txt&quot;}, new ByteArrayInputStream( ep.getText().getBytes()), fileContents.getName());</p>
<p>if(fileContents == null) return;</p>
<p>fileName.setText(fileContents.getName());</p>
<p>} catch(Exception exc) {</p>
<p>throw new RuntimeException(exc);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>JnlpFileChooser fc = new JnlpFileChooser(); fc.setSize(400, 300); fc.setVisible(true);</p>
<p>}</p>
<p>} ///:~</p>
<p>Note that the FileOpenService and the FileSaveService classes are imported from the javax.jnlp package and that nowhere in the code is the JFileChooser dialog box referred to directly. The two services used here must be requested using the</p>
<p>ServiceManager.lookup( ) method, and the resources on the client system can only be accessed via the objects returned from this method. In this case, the files on the client’s file system are being written to and read from using the FileContent interface, provided by the JNLP. Any attempt to access the resources directly by using, say, a File or a FileReader object would cause a SecurityException to be thrown in the same way that it would if you tried to use them from an unsigned applet. If you want to use these classes and not be restricted to the JNLP service interfaces, you must sign the JAR file.</p>
<p>The commented jar command in JnlpFileChooser.java will produce the necessary JAR file. Here is an appropriate launch file for the preceding example.</p>
<p>//:! gui/jnlp/filechooser.jnlp &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</p>
<p>&lt;jnlp spec = &quot;1.0+&quot;</p>
<p>codebase=&quot;file:C:/AAA-TIJ4/code/gui/jnlp&quot;</p>
<p>href=&quot;filechooser.jnlp&quot;&gt;</p>
<p>&lt;information&gt;</p>
<p>&lt;title&gt;FileChooser demo application&lt;/title&gt;</p>
<p>&lt;vendor&gt;Mindview Inc.&lt;/vendor&gt;</p>
<p>&lt;description&gt;</p>
<p>Jnlp File chooser Application &lt;/description&gt;</p>
<p>&lt;description kind=&quot;short&quot;&gt;</p>
<p>Demonstrates opening, reading and writing a text file &lt;/description&gt;</p>
<p>&lt;icon href=&quot;mindview.gif&quot;/&gt;</p>
<p>&lt;offline-allowed/&gt;</p>
<p>&lt;/information&gt;</p>
<p>&lt;resources&gt;</p>
<p>&lt;j2se version=&quot;1.3+&quot;</p>
<p>href=&quot;<a l:href="http://java.sun.com/products/autodl/j2se%22/">http://java.sun.com/products/autodl/j2se&quot;/</a>&gt;</p>
<p>&lt;jar href=&quot;jnlpfilechooser.jar&quot; download=&quot;eager&quot;/&gt;</p>
<p>&lt;/resources&gt;</p>
<p>&lt;application-desc</p>
<p>main-class=&quot;gui.jnlp.JnlpFileChooser&quot;/&gt;</p>
<p>&lt;/jnlp&gt;</p>
<p>///:~</p>
<p>You’ll find this launch file in the source-code download for this book (from <a l:href="http://www.MindView.net">www.MindView.net</a>) saved as filechooser.jnlp without the first and last lines, in the same directory as the JAR file. As you can see, it is an XML file with one &lt;jnlp&gt; tag. This has a few sub-elements, which are mostly selfexplanatory.</p>
<p>The spec attribute of the jnlp element tells the client system what version of the JNLP the application can be run with. The codebase attribute points to the URL where this launch file and the resources can be found. Here, it points to a directory on the local machine, which is a good means of testing the application. Note that you’ll need to change this path so that it indicates the appropriate directory on your machine, in order for the program to load successfully. The href attribute must specify the name of this file.</p>
<p>The information tag has various sub-elements that provide information about the application. These are used by the Java Web Start administrative console or equivalent, which installs the JNLP application and allows the user to run it from the command line, make shortcuts, and so on.</p>
<p>The resources tag serves a similar purpose as the applet tag in an HTML file. The J2se subelement specifies the J2SE version required to run the application, and the jar sub-element specifies the JAR file in which the class is archived. The jar element has an attribute download, which can have the values &quot;eager&quot; or &quot;lazy&quot; that tell the JNLP implementation whether or not the entire archive needs to be downloaded before the application can be run.</p>
<p>The application-desc attribute tells the JNLP implementation which class is the executable class, or entry point, to the JAR file.</p>
<p>Another useful sub-element of the jnlp tag is the security tag, not shown here. Here’s what a security tag looks like:</p>
<p>&lt;security&gt;</p>
<p>&lt;all-permissions/&gt;</p>
<p>&lt;security/&gt;</p>
<p>You use the security tag when your application is deployed in a signed JAR file. It is not needed in the preceding example because the local resources are all accessed via the JNLP services.</p>
<p>There are a few other tags available, the details of which can be found in the specification at <a l:href="http://java.sun.com/products/javawehstart/downloadspec">http://java.sun.com/products/javawehstart/downloadspec</a>. html.</p>
<p>To launch the program, you need a download page containing a hypertext link to the .jnlp file. Here’s what it looks like (without the first and last lines):</p>
<p>//:! gui/jnlp/filechooser.html &lt;html&gt;</p>
<p>Follow the instructions in JnlpFileChooser.java to build jnlpfilechooser.jar, then:</p>
<p>&lt;a href=&quot;filechooser.jnlp&quot;&gt;click here&lt;/a&gt;</p>
<p>&lt;/html&gt;</p>
<p>///:~</p>
<p>Once you have downloaded the application once, you can configure it by using the administrative console. If you are using Java Web Start on Windows, then you will be prompted to make a shortcut to your application the second time you use it. This behavior is configurable.</p>
<p>Only two of the JNLP services are covered here, but there are seven services in the current release. Each is designed for a specific task such as printing, or cutting and pasting to the clipboard. You can find more information at <a l:href="http://java.sun.com">http://java.sun.com</a>.</p>
</section>
<section>
<title>
<p>Concurrency &amp; Swing</p></title><empty-line/>
<p>When you program with Swing you’re using threads. You saw this at the beginning of this chapter when you learned that everything should be submitted to the Swing event dispatch thread through SwingUtilities.invokeLater( ). However, the fact that you don’t have to explicitly create a Thread object means that threading issues can catch you by surprise. You must keep in mind that there is a Swing event dispatch thread, which is always there, handling all the Swing events by pulling each one out of the event queue and executing it in turn. By remembering the event dispatch thread you’ll help ensure that your application won’t suffer from deadlocking or race conditions.</p>
<p>This section addresses threading issues that arise when working with Swing.</p>
<subtitle>Long-running tasks</subtitle>
<p>One of the most fundamental mistakes you can make when programming with a graphical user interface is to accidentally use the event dispatch thread to run a long task. Here’s a simple example:</p>
<p>//: gui/LongRunningTask.java</p>
<p>// A badly designed program.</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import java.util.concurrent.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class LongRunningTask extends JFrame { private JButton</p>
<p>b1 = new JButton(&quot;Start Long Running Task&quot;), b2 = new JButton(&quot;End Long Running Task&quot;); public LongRunningTask() {</p>
<p>b1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent evt) { try {</p>
<p>TimeUnit.SECONDS.sleep(3);</p>
<p>} catch(InterruptedException e) {</p>
<p>System.out.println(&quot;Task interrupted&quot;); return;</p>
<p>}</p>
<p>System.out.println(&quot;Task completed&quot;);</p>
<p>}</p>
<p>});</p>
<p>b2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent evt) {</p>
<p>// Interrupt yourself?</p>
<p>Thread.currentThread().interrupt();</p>
<p>}</p>
<p>});</p>
<p>setLayout(new FlowLayout());</p>
<p>add(b1);</p>
<p>add(b2);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new LongRunningTask(), 200, 150);</p>
<p>}</p>
<p>} ///:~</p>
<p>When you press bi, the event dispatch thread is suddenly occupied in performing the long-running task. You’ll see that the button doesn’t even pop back out, because the event dispatch thread that would normally repaint the screen is busy. And you cannot do anything else, like press b2, because the program won’t respond until bi’s task is complete and the event dispatch thread is once again available. The code in b2 is a flawed attempt to solve the problem by interrupting the event dispatch thread.</p>
<p>The answer, of course, is to execute long-running processes in separate threads. Here, the single-thread Executor is used, which automatically queues pending tasks and executes them one at a time:</p>
<p>//: gui/InterruptableLongRunningTask.java</p>
<p>// Long-running tasks in threads.</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import java.util.concurrent.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>class Task implements Runnable { private static int counter = 0; private final int id = counter++; public void run() {</p>
<p>System.out.println(this + &quot; started&quot;); try {</p>
<p>TimeUnit.SECONDS.sleep(3);</p>
<p>} catch(InterruptedException e) {</p>
<p>System.out.println(this + &quot; interrupted&quot;); return;</p>
<p>}</p>
<p>System.out.println(this + &quot; completed&quot;);</p>
<p>}</p>
<p>public String toString() { return &quot;Task &quot; + id; } public long id() { return id; }</p>
<p>};</p>
<p>public class InterruptableLongRunningTask extends JFrame { private JButton</p>
<p>b1 = new JButton(&quot;Start Long Running Task&quot;), b2 = new JButton(&quot;End Long Running Task&quot;);</p>
<p>ExecutorService executor =</p>
<p>Executors.newSingleThreadExecutor(); public InterruptableLongRunningTask() {</p>
<p>b1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>Task task = new Task(); executor.execute(task);</p>
<p>System.out.println(task + &quot; added to the queue&quot;);</p>
<p>}</p>
<p>});</p>
<p>b2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { executor.shutdownNow(); // Heavy-handed</p>
<p>}</p>
<p>});</p>
<p>setLayout(new FlowLayout());</p>
<p>add(bl);</p>
<p>add(b2);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>run(new InterruptableLongRunningTask(), 200, 150);</p>
<p>}</p>
<p>This is better, but when you press b2, it calls shutdownNow( ) on the ExecutorService, thereby disabling it. If you try to add more tasks, you get an exception. Thus, pressing b2 makes the program inoperable. What we’d like to do is to shut down the current task (and cancel pending tasks) without stopping everything. The Java SE5 Callable/Future mechanism described in the Concurrency chapter is just what we need. We’ll define a new class called TaskManager, which contains tuples that hold the Callable representing the task and the Future that comes back from the Callable. The reason the tuple is necessary is because it allows us to keep track of the original task, so that we may get extra information that is not available from the Future. Here it is:</p>
<p>//: net/mindview/util/TaskItem.java // A Future and the Callable that produced it. package net.mindview.util; import java.util.concurrent.*;</p>
<p>public class TaskItem&lt;R,C extends Callable&lt;R&gt;&gt; { public final Future&lt;R&gt; future; public final C task;</p>
<p>public TaskItem(Future&lt;R&gt; future, C task) { this.future = future; this.task = task;</p>
<p>}</p>
<p>} ///:~</p>
<p>In the java.util.concurrent library, the task is not available via the Future by default because the task would not necessarily still be around when you get the result from the Future. Here, we force the task to stay around by storing it.</p>
<p>TaskManager is placed in net.mindview.util so it is available as a general-purpose utility:</p>
<p>//: net/mindview/util/TaskManager.java // Managing and executing a queue of tasks. package net.mindview.util; import java.util.concurrent.*; import java.util.*;</p>
<p>public class TaskManager&lt;R,C extends Callable&lt;R&gt;&gt; extends ArrayList&lt;TaskItem&lt;R,C&gt;&gt; { private ExecutorService exec =</p>
<p>Executors.newSingleThreadExecutor(); public void add(C task) {</p>
<p>add(new TaskItem&lt;R,C&gt;(exec.submit(task),task));</p>
<p>}</p>
<p>public List&lt;R&gt; getResults() {</p>
<p>Iterator&lt;TaskItem&lt;R,C&gt;&gt; items = iterator();</p>
<p>List&lt;R&gt; results = new ArrayList&lt;R&gt;(); while(items.hasNext()) {</p>
<p>TaskItem&lt;R,C&gt; item = items.next(); if(item.future.isDone()) { try {</p>
<p>results.add(item.future.get());</p>
<p>} catch(Exception e) {</p>
<p>throw new RuntimeException(e);</p>
<p>}</p>
<p>items.remove();</p>
<p>}</p>
<p>}</p>
<p>return results;</p>
<p>public List&lt;String&gt; purge() {</p>
<p>Iterator&lt;TaskItem&lt;R,C&gt;&gt; items = iterator();</p>
<p>List&lt;String&gt; results = new ArrayList&lt;String&gt;(); while(items.hasNext()) {</p>
<p>TaskItem&lt;R,C&gt; item = items.next();</p>
<p>// Leave completed tasks for results reporting: if(!item.future.isDone()) {</p>
<p>results.add(&quot;Cancelling &quot; + item.task); item.future.cancel(true); // May interrupt items.remove();</p>
<p>}</p>
<p>}</p>
<p>return results;</p>
<p>}</p>
<p>} ///:~</p>
<p>TaskManager is an ArrayList of Taskltem. It also contains a singlethread Executor, so when you call add( ) with a Callable, it submits the Callable and stores the resulting Future along with the original task. This way, if you need to do anything with the task, you have a reference to that task. As a simple example, in purge( ) the task’s toString( ) is used.</p>
<p>This can now be used to manage the long-running tasks in our example:</p>
<p>//: gui/InterruptableLongRunningCallable.java</p>
<p>// Using Callables for long-running tasks.</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import java.util.concurrent.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>class CallableTask extends Task implements Callable&lt;String&gt; { public String call() { run();</p>
<p>return &quot;Return value of &quot; + this;</p>
<p>}</p>
<p>}</p>
<p>public class</p>
<p>InterruptableLongRunningCallable extends JFrame { private JButton</p>
<p>b1 = new JButton(&quot;Start Long Running Task&quot;), b2 = new JButton(&quot;End Long Running Task&quot;), b3 = new JButton(&quot;Get results&quot;); private TaskManager&lt;String,CallableTask&gt; manager = new TaskManager&lt;String,CallableTask&gt;(); public InterruptableLongRunningCallable() { b1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>CallableTask task = new CallableTask(); manager.add(task);</p>
<p>System.out.println(task + &quot; added to the queue&quot;);</p>
<p>}</p>
<p>});</p>
<p>b2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { for(String result : manager.purge())</p>
<p>System.out.println(result);</p>
<p>}</p>
<p>});</p>
<p>b3.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>// Sample call to a Task method: for(TaskItem&lt;String,CallableTask&gt; tt : manager)</p>
<p>tt.task.id(); // No cast required for(String result : manager.getResults()) System.out.println(result);</p>
<p>}</p>
<p>});</p>
<p>setLayout(new FlowLayout());</p>
<p>add(bl);</p>
<p>add(b2);</p>
<p>add(b3);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>run(new InterruptableLongRunningCallable(), 200, 150);</p>
<p>}</p>
<p>} ///:~</p>
<p>As you can see, CallableTask does exactly the same thing as Task except that it returns a result—in this case a String identifying the task.</p>
<p>Non-Swing utilities (not part of the standard Java distribution) called SwingWorker (from the Sun Web site) and Foxtrot (from <a l:href="http://foxtrot.sourceforge.net">http://foxtrot.sourceforge.net</a>) were created to solve a similar problem, but at this writing, those utilities had not been modified to take advantage of the Java SE5 Callable/Future mechanism.</p>
<p>It’s often important to give the end user some kind of visual cue that a task is running, and of its progress. This is normally done through either a JProgressBar or a ProgressMonitor. This example uses a ProgressMonitor:</p>
<p>//: gui/MonitoredLongRunningCallable.java</p>
<p>// Displaying task progress with ProgressMonitors.</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import java.util.concurrent.*;</p>
<p>import net.mindview.util.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>class MonitoredCallable implements Callable&lt;String&gt; { private static int counter = 0; private final int id = counter++; private final ProgressMonitor monitor; private final static int MAX = 8;</p>
<p>public MonitoredCallable(ProgressMonitor monitor) { this.monitor = monitor; monitor.setNote(toString()); monitor.setMaximum(MAX - 1); monitor.setMillisToPopup(500);</p>
<p>}</p>
<p>public String call() {</p>
<p>System.out.println(this + &quot; started&quot;); try {</p>
<p>for(int i = 0; i &lt; MAX; i++) {</p>
<p>TimeUnit.MILLISECONDS.sleep(500);</p>
<p>if(monitor.isCanceled())</p>
<p>Thread.currentThread().interrupt();</p>
<p>final int progress = i;</p>
<p>SwingUtilities.invokeLater( new Runnable() { public void run() {</p>
<p>monitor.setProgress(progress);</p>
<p>}</p>
<p>}</p>
<p>);</p>
<p>}</p>
<p>} catch(InterruptedException e) { monitor.close();</p>
<p>System.out.println(this + &quot; interrupted&quot;); return &quot;Result: &quot; + this + &quot; interrupted&quot;;</p>
<p>}</p>
<p>System.out.println(this + &quot; completed&quot;); return &quot;Result: &quot; + this + &quot; completed&quot;;</p>
<p>}</p>
<p>public String toString() { return &quot;Task &quot; + id; }</p>
<p>};</p>
<p>public class MonitoredLongRunningCallable extends JFrame { private JButton</p>
<p>b1 = new JButton(&quot;Start Long Running Task&quot;), b2 = new JButton(&quot;End Long Running Task&quot;), b3 = new JButton(&quot;Get results&quot;); private TaskManager&lt;String,MonitoredCallable&gt; manager = new TaskManager&lt;String,MonitoredCallable&gt;(); public MonitoredLongRunningCallable() {</p>
<p>b1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>MonitoredCallable task = new MonitoredCallable( new ProgressMonitor(</p>
<p>MonitoredLongRunningCallable.this,</p>
<p>&quot;Long-Running Task&quot;, &quot;&quot;, 0, 0)</p>
<p>);</p>
<p>manager.add(task);</p>
<p>System.out.println(task + &quot; added to the queue&quot;);</p>
<p>}</p>
<p>});</p>
<p>b2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { for(String result : manager.purge()) System.out.println(result);</p>
<p>}</p>
<p>});</p>
<p>b3.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { for(String result : manager.getResults()) System.out.println(result);</p>
<p>}</p>
<p>});</p>
<p>setLayout(new FlowLayout());</p>
<p>add(bl);</p>
<p>add(b2);</p>
<p>add(b3);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>run(new MonitoredLongRunningCallable(), 200, 500);</p>
<p>}</p>
<p>} ///:~</p>
<p>The MonitoredCallable constructor takes a ProgressMonitor as an argument, and its call( ) method updates the ProgressMonitor every half second. Notice that a</p>
<p>MonitoredCallable is a separate task and thus should not try to control the UI directly, so SwingUtilities.invokeLater( ) is used to submit the progress change information to the monitor. Sun’s Swing Tutorial (on <a l:href="http://java.sun.com">http://java.sun.com</a>) shows an alternate approach of using a Swing Timer, which checks the status of the task and updates the monitor.</p>
<p>If the &quot;cancel&quot; button is pressed on the monitor, monitor.isCanceled( ) will return true. Here, the task just calls interrupt ) on its own thread, which will land it in the catch clause where the monitor is terminated with the close( ) method.</p>
<p>The rest of the code is effectively the same as before, except for the creation of the ProgressMonitor as part of the MonitoredLongRunningCallable constructor.</p>
<p>Exercise 33: (6) Modify InterruptableLongRunningCallable.java so that it runs all the tasks in parallel rather than sequentially.</p>
<subtitle>Visual threading</subtitle>
<p>The following example makes a Runnable JPanel class that paints different colors on itself. This application is set up to take values from the command line to determine how big the grid of colors is and how long to sleep( ) between color changes. By playing with these values, you may discover some interesting and possibly inexplicable features in the threading implementation on your platform:</p>
<p>//: gui/ColorBoxes.java</p>
<p>// A visual demonstration of threading.</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.util.concurrent.*;</p>
<p>import java.util.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>class CBox extends JPanel implements Runnable { private int pause;</p>
<p>private static Random rand = new Random(); private Color color = new Color(0); public void paintComponent(Graphics g) { g.setColor(color);</p>
<p>Dimension s = getSize(); g.fillRect(0, 0, s.width, s.height);</p>
<p>}</p>
<p>public CBox(int pause) { this.pause = pause; } public void run() { try {</p>
<p>while(!Thread.interrupted()) {</p>
<p>color = new Color(rand.nextInt(0xFFFFFF)); repaint(); // Asynchronously request a paint() TimeUnit.MILLISECONDS.sleep(pause);</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>// Acceptable way to exit</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class ColorBoxes extends JFrame { private int grid = 12; private int pause = 50; private static ExecutorService exec =</p>
<p>Executors.newCachedThreadPool();</p>
<p>public void setUp() {</p>
<p>setLayout(new GridLayout(grid, grid)); for(int i = 0; i &lt; grid * grid; i++) {</p>
<p>CBox cb = new CBox(pause); add(cb);</p>
<p>exec.execute(cb);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>ColorBoxes boxes = new ColorBoxes(); if(args.length &gt; 0)</p>
<p>boxes.grid = new Integer(args[0]); if(args.length &gt; 1)</p>
<p>boxes.pause = new Integer(args[1]); boxes.setUp(); run(boxes, 500, 400);</p>
<p>}</p>
<p>} ///:~</p>
<p>ColorBoxes configures a GridLayout so that it has grid cells in each dimension. Then it adds the appropriate number of CBox objects to fill the grid, passing the pause value to each one. In main( ) you can see how pause and grid have default values that can be changed if you pass in command-line arguments.</p>
<p>CBox is where all the work takes place. This is inherited from JPanel and it implements the Runnable interface so that each JPanel can also be an independent task. These tasks are driven by a thread pool ExecutorService.</p>
<p>The current cell color is color. Colors are created using the Color constructor that takes a 24-bit number, which in this case is created randomly.</p>
<p>paintComponent( ) is quite simple; it just sets the color to color and fills the entire JPanel with that color.</p>
<p>In run( ), you see the infinite loop that sets the color to a new random color and then calls repaint( ) to show it. Then the thread goes to sleep( ) for the amount of time specified on the command line.</p>
<p>The call to repaint( ) in run( ) deserves examination. At first glance, it may seem like we’re creating a lot of threads, each of which is forcing a paint. It might appear that this is violating the principle that you should only submit tasks to the event queue. However, these threads are not actually modifying the shared resource. When they call repaint( ), it doesn’t force a paint at that time, but only sets a &quot;dirty flag&quot; indicating that the next time the event dispatch thread is ready to repaint things, this area is a candidate for repainting. Thus the program doesn’t cause Swing threading problems.</p>
<p>When the event dispatch thread actually does perform a paint( ), it first calls paintComponent( ), then paintBorder( ) and paintChildren( ). If you need to override paint( ) in a derived component, you must remember to call the base-class version of paint( ) so that the proper actions are still performed.</p>
<p>Precisely because this design is flexible and threading is tied to each JPanel element, you can experiment by making as many threads as you want. (In reality, there is a restriction imposed by the number of threads your JVM can comfortably handle.)</p>
<p>This program also makes an interesting benchmark, since it can show dramatic performance and behavioral differences between one JVM threading implementation and another, as well as on different platforms.</p>
<p>Exercise 34: (4) Modify ColorBoxes.java so that it begins by sprinkling points (&quot;stars&quot;) across the canvas, then randomly changes the colors of those &quot;stars.&quot;</p>
</section>
<section>
<title>
<p>Visual programming and JavaBeans</p></title><empty-line/>
<p>So far in this book you’ve seen how valuable Java is for creating reusable pieces of code. The &quot;most reusable&quot; unit of code has been the class, since it comprises a cohesive unit of characteristics (fields) and behaviors (methods) that can be reused either directly via composition or through inheritance.</p>
<p>Inheritance and polymorphism are essential parts of object-oriented programming, but in the majority of cases when you’re putting together an application, what you really want is components that do exactly what you need. You’d like to drop these parts into your design like the chips an electronic engineer puts on a circuit board. It seems that there should be some way to accelerate this &quot;modular assembly&quot; style of programming.</p>
<p>&quot;Visual programming&quot; first became successful—very successful—with Microsoft’s Visual BASIC (VB), followed by a second-generation design in Borland’s Delphi (which was the primary inspiration for the JavaBeans design). With these programming tools the components are represented visually, which makes sense since they usually display some kind of visual component such as a button or a text field. The visual representation, in fact, is often exactly the way the component will look in the running program. So part of the process of visual programming involves dragging a component from a palette and dropping it onto your form. The Application Builder Integrated Development Environment (IDE) writes code as you do this, and that code will cause the component to be created in the running program.</p>
<p>Simply dropping the component onto a form is usually not enough to complete the program. Often, you must change the characteristics of a component, such as its color, the text that’s on it, the database it’s connected to, etc. Characteristics that can be modified at design time are referred to as properties. You can manipulate the properties of your component inside the IDE, and when you create the program, this configuration data is saved so that it can be rejuvenated when the program is started.</p>
<p>By now you’re probably used to the idea that an object is more than characteristics; it’s also a set of behaviors. At design time, the behaviors of a visual component are partially represented by events, meaning &quot;Here’s something that can happen to the component.&quot; Ordinarily, you decide what you want to happen when an event occurs by tying code to that event.</p>
<p>Here’s the critical part: The IDE uses reflection to dynamically interrogate the component and find out which properties and events the component supports. Once it knows what they are, it can display the properties and allow you to change them (saving the state when you build the program), and also display the events. In general, you do something like doubleclicking on an event, and the IDE creates a code body and ties it to that particular event. All you must do at that point is write the code that executes when the event occurs.</p>
<p>All this adds up to a lot of work that’s done for you by the IDE. As a result, you can focus on what the program looks like and what it is supposed to do, and rely on the IDE to manage the connection details for you. The reason that visual programming tools have been so successful is that they dramatically speed up the process of building an application—certainly the user interface, but often other portions of the application as well.</p>
<subtitle>What is a JavaBean?</subtitle>
<p>After the dust settles, then, a component is really just a block of code, typically embodied in a class. The key issue is the ability for the IDE to discover the properties and events for that component. To create a VB component, the programmer originally had to write a fairly complicated piece of code following certain conventions to expose the properties and events (it got easier as the years passed). Delphi was a second-generation visual programming tool, and the language was actively designed around visual programming, so it was much easier to create a visual component. However, Java has brought the creation of visual components to its most advanced state with JavaBeans, because a Bean is just a class. You don’t have to write any extra code or use special language extensions in order to make something a Bean. The only thing you need to do, in fact, is slightly modify the way that you name your methods. It is the method name that tells the IDE whether this is a property, an event, or just an ordinary method.</p>
<p>In the JDK documentation, this naming convention is mistakenly termed a &quot;design pattern.&quot; This is unfortunate, since design patterns (see Thinking in Patterns at <a l:href="http://www.MindView.net">www.MindView.net</a>) are challenging enough without this sort of confusion. It’s not a design pattern, it’s just a naming convention, and it’s fairly simple:</p>
<p>1.    For a property named xxx, you typically create two methods: getXxx( ) and setXxx( ). The first letter after &quot;get&quot; or &quot;set&quot; will automatically be lowercased by any tools that look at the methods, in order to produce the property name. The type produced by the &quot;get&quot; method is the same as the type of the argument to the &quot;set&quot; method. The name of the property and the type for the &quot;get&quot; and &quot;set&quot; are not related.</p>
<p>2.    For a boolean property, you can use the &quot;get&quot; and &quot;set&quot; approach above, but you can also use &quot;is&quot; instead of &quot;get.&quot;</p>
<p>3.    Ordinary methods of the Bean don’t conform to the above naming convention, but they’re public.</p>
<p>4.    For events, you use the Swing &quot;listener&quot; approach. It’s exactly the same as you’ve been seeing: addBounceListener(BounceListener) and</p>
<p>removeBounceListener(BounceListener) to handle a BounceEvent. Most of the time, the built-in events and listeners will satisfy your needs, but you can also create your own events and listener interfaces.</p>
<p>We can use these guidelines to create a simple Bean:</p>
<p>//: frogbean/Frog.java // A trivial JavaBean. package frogbean; import java.awt.*; import java.awt.event.*;</p>
<p>class Spots {}</p>
<p>public class Frog { private int jumps; private Color color; private Spots spots; private boolean jmpr;</p>
<p>public int getJumps() { return jumps; } public void setJumps(int newJumps) { jumps = newJumps;</p>
<p>}</p>
<p>public Color getColor() { return color; } public void setColor(Color newColor) { color = newColor;</p>
<p>}</p>
<p>public Spots getSpots() { return spots; }</p>
<p>public void setSpots(Spots newSpots) { spots = newSpots;</p>
<p>}</p>
<p>{</p>
<p>l) {</p>
<p>public boolean isJumper() { return jmpr; } public void setJumper(boolean j) { jmpr = j; } public void addActionListener(ActionListener l)</p>
<p>}</p>
<p>public void removeActionListener(ActionListener // ...</p>
<p>}</p>
<p>public void addKeyListener(KeyListener l) {</p>
<p>// ...</p>
<p>}</p>
<p>public void removeKeyListener(KeyListener l) { // ...</p>
<p>}</p>
<p>// An &quot;ordinary&quot; public method: public void croak() {</p>
<p>System.out.println(&quot;Ribbet!&quot;);</p>
<p>}</p>
<p>}</p>
<p>///:~</p>
<p>First, you can see that it’s just a class. Usually, all your fields will be private and accessible only through methods and properties. Following the naming convention, the properties are jumps, color, spots, and jumper (notice the case change of the first letter in the property name). Although the name of the internal identifier is the same as the name of the property in the first three cases, in jumper you can see that the property name does not force you to use any particular identifier for internal variables (or, indeed, to even have any internal variables for that property).</p>
<p>The events this Bean handles are ActionEvent and KeyEvent, based on the naming of the &quot;add&quot; and &quot;remove&quot; methods for the associated listener. Finally, you can see that the ordinary method croak( ) is still part of the Bean simply because it’s a public method, not because it conforms to any naming scheme.</p>
<p>Extracting Beanlnfo with the Introspector</p>
<p>One of the most critical parts of the JavaBean scheme occurs when you drag a Bean off a palette and drop it onto a form. The IDE must be able to create the Bean (which it can do if there’s a default constructor) and then, without access to the Bean’s source code, extract all the necessary information to create the property sheet and event handlers.</p>
<p>Part of the solution is already evident from the Type Information chapter: Java reflection discovers all the methods of an unknown class. This is perfect for solving the JavaBean problem without requiring extra language keywords like those in other visual programming languages. In fact, one of the prime reasons that reflection was added to Java was to support JavaBeans (although reflection also supports object serialization and Remote Method Invocation, and is helpful in ordinary programming). So you might expect that the creator of the IDE would have to reflect each Bean and hunt through its methods to find the properties and events for that Bean.</p>
<p>This is certainly possible, but the Java designers wanted to provide a standard tool, not only to make Beans simpler to use, but also to provide a standard gateway to the creation of more complex Beans. This tool is the Introspector class, and the most important method in this class is the static getBeanInfo( ). You pass a Class reference to this method, and it fully interrogates that class and returns a BeanInfo object which you can dissect to find properties, methods, and events.</p>
<p>Usually, you won’t care about any of this; you’ll probably get most of your Beans off the shelf, and you won’t need to know all the magic that’s going on underneath. You’ll simply drag Beans onto your form, then configure their properties and write handlers for the events of interest. However, it’s an educational exercise to use the Introspector to display information about a Bean. Here’s a tool that does it:</p>
<p>//: gui/BeanDumper.java // Introspecting a Bean. import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.beans.*; import java.lang.reflect.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class BeanDumper extends JFrame {</p>
<p>private JTextField query = new JTextField(20); private JTextArea results = new JTextArea(); public void print(String s) { results.append(s + &quot;\n&quot;); } public void dump(Class&lt;?&gt; bean) { results.setText(&quot;&quot;);</p>
<p>BeanInfo bi = null; try {</p>
<p>bi = Introspector.getBeanInfo(bean, Object.class);</p>
<p>} catch(IntrospectionException e) {</p>
<p>print(&quot;Couldn’t introspect &quot; + bean.getName()); return;</p>
<p>}</p>
<p>for(PropertyDescriptor d: bi.getPropertyDescriptors()){</p>
<p>Class&lt;?&gt; p = d.getPropertyType(); if(p == null) continue;</p>
<p>print(&quot;Property type:\n &quot; + p.getName() +</p>
<p>&quot;Property name:\n &quot; + d.getName());</p>
<p>Method readMethod = d.getReadMethod(); if(readMethod != null)</p>
<p>print(&quot;Read method:\n &quot; + readMethod);</p>
<p>Method writeMethod = d.getWriteMethod(); if(writeMethod != null)</p>
<p>print(&quot;Write method:\n &quot; + writeMethod); print(&quot;====================&quot;);</p>
<p>}</p>
<p>print(&quot;Public methods:&quot;);</p>
<p>for(MethodDescriptor m : bi.getMethodDescriptors()) print(m.getMethod().toString()); print(&quot;======================&quot;);</p>
<p>print(&quot;Event support:&quot;);</p>
<p>for(EventSetDescriptor e: bi.getEventSetDescriptors()){ print(&quot;Listener type:\n &quot; + e.getListenerType().getName()); for(Method lm : e.getListenerMethods())</p>
<p>print(&quot;Listener method:\n &quot; + lm.getName()); for(MethodDescriptor lmd :</p>
<p>e.getListenerMethodDescriptors() ) print(&quot;Method descriptor:\n &quot; + lmd.getMethod());</p>
<p>Method addListener= e.getAddListenerMethod(); print(&quot;Add Listener Method:\n &quot; + addListener);</p>
<p>Method removeListener = e.getRemoveListenerMethod(); print(&quot;Remove Listener Method:\n &quot;+ removeListener); print(&quot;====================&quot;);</p>
<p>}</p>
<p>class Dumper implements ActionListener {</p>
<p>public void actionPerformed(ActionEvent e) {</p>
<p>String name = query.getText();</p>
<p>Class&lt;?&gt; c = null; try {</p>
<p>c = Class.forName(name);</p>
<p>} catch(ClassNotFoundException ex) {</p>
<p>results.setText(&quot;Couldn’t find &quot; + name); return;</p>
<p>}</p>
<p>dump(c);</p>
<p>}</p>
<p>}</p>
<p>public BeanDumper() {</p>
<p>JPanel p = new JPanel(); p.setLayout(new FlowLayout()); p.add(new JLabel(&quot;Qualified bean name:&quot;)); p.add(query);</p>
<p>add(BorderLayout.NORTH, p); add(new JScrollPane(results));</p>
<p>Dumper dmpr = new Dumper();</p>
<p>query.addActionListener(dmpr);</p>
<p>query.setText(&quot;frogbean.Frog&quot;);</p>
<p>// Force evaluation</p>
<p>dmpr.actionPerformed(new ActionEvent(dmpr, 0, &quot;&quot;));</p>
<p>}</p>
<p>public static void main(String[] args) { run(new BeanDumper(), 600, 500);</p>
<p>}</p>
<p>} ///:~</p>
<p>BeanDumper.dump( ) does all the work. First it tries to create a BeanInfo object, and if successful, calls the methods of BeanInfo that produce information about properties, methods, and events. In Introspector.getBeanInfo( ), you’ll see there is a second argument that tells the Introspector where to stop in the inheritance hierarchy. Here, it stops before it parses all the methods from Object, since we’re not interested in seeing those.</p>
<p>For properties, getPropertyDescriptors( ) returns an array of PropertyDescriptors. For each PropertyDescriptor, you can call getPropertyType( ) to find the class of object that is passed in and out via the property methods. Then, for each property, you can get its pseudonym (extracted from the method names) with getName( ), the method for reading with getReadMethod( ), and the method for writing with getWriteMethod( ). These last two methods return a Method object that can actually be used to invoke the corresponding method on the object (this is part of reflection).</p>
<p>For the public methods (including the property methods), getMethodDescriptors( ) returns an array of MethodDescriptors. For each one, you can get the associated Method object and print its name.</p>
<p>For the events, getEventSetDescriptors( ) returns an array of EventSetDescriptors.</p>
<p>Each of these can be queried to find out the class of the listener, the methods of that listener class, and the add- and removelistener methods. The BeanDumper program displays all of this information.</p>
<p>Upon startup, the program forces the evaluation of frogbean.Frog. The output, after unnecessary details have been removed, is:</p>
<p>Property type:</p>
<p>Color</p>
<p>Property name: color</p>
<p>Read method:</p>
<p>public Color getColor() Write method:</p>
<p>public void setColor(Color)</p>
<p>Property type: boolean Property name: jumper Read method:</p>
<p>public boolean isJumper()</p>
<p>Write method:</p>
<p>public void setJumper(boolean)</p>
<p>Property type: int</p>
<p>Property name: jumps</p>
<p>Read method:</p>
<p>public int getJumps()</p>
<p>Write method:</p>
<p>public void setJumps(int)</p>
<p>Property type: frogbean.Spots Property name: spots</p>
<p>Read method:</p>
<p>public frogbean.Spots getSpots() Write method:</p>
<p>public void setSpots(frogbean.Spots)</p>
<p>Public methods:</p>
<p>public void setSpots(frogbean.Spots) public void setColor(Color) public void setJumps(int) public boolean isJumper() public frogbean.Spots getSpots() public void croak()</p>
<p>public void addActionListener(ActionListener) public void addKeyListener(KeyListener) public Color getColor() public void setJumper(boolean) public int getJumps()</p>
<p>public void removeActionListener(ActionListener) public void removeKeyListener(KeyListener)</p>
<p>Event support:</p>
<p>Listener type:</p>
<p>KeyListener Listener method: keyPressed Listener method: keyReleased Listener method: keyTyped</p>
<p>Method descriptor:</p>
<p>public abstract void keyPressed(KeyEvent) Method descriptor:</p>
<p>public abstract void keyReleased(KeyEvent)</p>
<p>Method descriptor:</p>
<p>public abstract void keyTyped(KeyEvent) AddListener Method:</p>
<p>public void addKeyListener(KeyListener) Remove Listener Method:</p>
<p>public void removeKeyListener(KeyListener)</p>
<p>Listener type:</p>
<p>ActionListener Listener method: actionPerformed Method descriptor:</p>
<p>public abstract void actionPerformed(ActionEvent) Add Listener Method:</p>
<p>public void addActionListener(ActionListener) Remove Listener Method:</p>
<p>public void removeActionListener(ActionListener)</p>
<p>This reveals most of what the Introspector sees as it produces a BeanInfo object from your Bean. You can see that the type of the property and its name are independent. Notice the lowercasing of the property name. (The only time this doesn’t occur is when the property name begins with more than one capital letter in a row.) And remember that the method names you’re seeing here (such as the read and write methods) are actually produced from a Method object that can be used to invoke the associated method on the object.</p>
<p>The public method list includes the methods that are not associated with a property or an event, such as croak( ), as well as those that are. These are all the methods that you can call programmatically for a Bean, and the IDE can choose to list all of these while you’re making method calls, to ease your task.</p>
<p>Finally, you can see that the events are fully parsed out into the listener, its methods, and the add- and remove-listener methods. Basically, once you have the BeanInfo, you can find out everything of importance for the Bean. You can also call the methods for that Bean, even though you don’t have any other information except the object (again, a feature of reflection).</p>
<subtitle>A more sophisticated Bean</subtitle>
<p>This next example is slightly more sophisticated, albeit frivolous. It’s a JPanel that draws a little circle around the mouse whenever the mouse is moved. When you press the mouse, the word &quot;Bang!&quot; appears in the middle of the screen, and an action listener is fired.</p>
<p>The properties you can change are the size of the circle as well as the color, size, and text of the word that is displayed when you press the mouse. A BangBean also has its own addActionListener( ) and removeActionListener( ), so you can attach your own listener that will be fired when the user clicks on the BangBean. You should recognize the property and event support:</p>
<p>//: bangbean/BangBean.java // A graphical Bean. package bangbean; import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.io.*; import java.util.*;</p>
<p>public class</p>
<p>BangBean extends JPanel implements Serializable {</p>
<p>private int xm, ym;</p>
<p>private int cSize = 20; // Circle size private String text = &quot;Bang!&quot;; private int fontSize = 48; private Color tColor = Color.RED; private ActionListener actionListener; public BangBean() {</p>
<p>addMouseListener(new ML()); addMouseMotionListener(new MML());</p>
<p>}</p>
<p>public int getCircleSize() { return cSize; } public void setCircleSize(int newSize) { cSize = newSize;</p>
<p>}</p>
<p>public String getBangText() { return text; } public void setBangText(String newText) { text = newText;</p>
<p>}</p>
<p>public int getFontSize() { return fontSize; } public void setFontSize(int newSize) { fontSize = newSize;</p>
<p>}</p>
<p>public Color getTextColor() { return tColor; } public void setTextColor(Color newColor) { tColor = newColor;</p>
<p>}</p>
<p>public void paintComponent(Graphics g) { super.paintComponent(g); g.setColor(Color.BLACK);</p>
<p>g.drawOval(xm - cSize/2, ym - cSize/2, cSize, cSize);</p>
<p>}</p>
<p>// This is a unicast listener, which is // the simplest form of listener management: public void addActionListener(ActionListener l) throws TooManyListenersException { if(actionListener != null)</p>
<p>throw new TooManyListenersException(); actionListener = l;</p>
<p>}</p>
<p>public void removeActionListener(ActionListener l) { actionListener = null;</p>
<p>}</p>
<p>class ML extends MouseAdapter {</p>
<p>public void mousePressed(MouseEvent e) {</p>
<p>Graphics g = getGraphics();</p>
<p>g.setColor(tColor);</p>
<p>g.setFont(</p>
<p>new Font(&quot;TimesRoman&quot;, Font.BOLD, fontSize)); int width = g.getFontMetrics().stringWidth(text); g.drawString(text, (getSize().width - width) /2, getSize().height/2); g.dispose();</p>
<p>// Call the listener’s method: if(actionListener != null)</p>
<p>actionListener.actionPerformed( new ActionEvent(BangBean.this,</p>
<p>ActionEvent.ACTION_PERFORMED, null));</p>
<p>}</p>
<p>}</p>
<p>class MML extends MouseMotionAdapter { public void mouseMoved(MouseEvent e) { xm = e.getX(); ym = e.getY();</p>
<p>repaint();</p>
<p>public Dimension getPreferredSize() { return new Dimension(200, 200);</p>
<p>}</p>
<p>} ///:~</p>
<p>The first thing you’ll notice is that BangBean implements the Serializable interface. This means that the IDE can &quot;pickle&quot; all the information for the BangBean by using serialization after the program designer has adjusted the values of the properties. When the Bean is created as part of the running application, these &quot;pickled&quot; properties are restored so that you get exactly what you designed.</p>
<p>When you look at the signature for addActionListener( ), you’ll see that it can throw a TooManyListenersException. This indicates that it is unicast, which means it notifies only one listener when the event occurs. Ordinarily, you’ll use multicast events so that many listeners can be notified of an event. However, that runs into threading issues, so it will be revisited in the next section, &quot;JavaBeans and synchronization.&quot; In the meantime, a unicast event sidesteps the problem.</p>
<p>When you click the mouse, the text is put in the middle of the BangBean, and if the actionListener field is not null, its actionPerformed( ) is called, creating a new ActionEvent object in the process. Whenever the mouse is moved, its new coordinates are captured and the canvas is repainted (erasing any text that’s on the canvas, as you’ll see).</p>
<p>Here is the BangBeanTest class to test the Bean:</p>
<p>//: bangbean/BangBeanTest.java</p>
<p>// {Timeout: 5} Abort after 5 seconds when testing</p>
<p>package bangbean;</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import java.util.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class BangBeanTest extends JFrame { private JTextField txt = new JTextField(20);</p>
<p>// During testing, report actions: class BBL implements ActionListener { private int count = 0;</p>
<p>public void actionPerformed(ActionEvent e) { txt.setText(&quot;BangBean action &quot;+ count++);</p>
<p>}</p>
<p>}</p>
<p>public BangBeanTest() {</p>
<p>BangBean bb = new BangBean(); try {</p>
<p>bb.addActionListener(new BBL());</p>
<p>} catch(TooManyListenersException e) { txt.setText(&quot;Too many listeners&quot;);</p>
<p>}</p>
<p>add(bb);</p>
<p>add(BorderLayout.SOUTH, txt);</p>
<p>}</p>
<p>public static void main(String[] args) { run(new BangBeanTest(), 400, 500);</p>
<p>}</p>
<p>} ///:~</p>
<p>When a Bean is used in an IDE, this class will not be used, but it’s helpful to provide a rapid testing method for each of your Beans. BangBeanTest places a BangBean within the JFrame, attaching a simple ActionListener to the BangBean to print an event count to the JTextField whenever an ActionEvent occurs. Usually, of course, the IDE would create most of the code that uses the Bean.</p>
<p>When you run the BangBean through BeanDumper or put the BangBean inside a Bean-enabled development environment, you’ll notice that there are many more properties and actions than are evident from the preceding code. That’s because BangBean is inherited from JPanel, and JPanel is also a Bean, so you’re seeing its properties and events as well.</p>
<p>Exercise 35: (6) Locate and download one or more of the free GUI builder development environments available on the Internet, or use a commercial product if you own one.</p>
<p>Discover what is necessary to add BangBean to this environment and to use it.</p>
<subtitle>JavaBeans and synchronization</subtitle>
<p>Whenever you create a Bean, you must assume that it will run in a multithreaded environment. This means that:</p>
<p>1.    Whenever possible, all the public methods of a Bean should be synchronized. Of course, this incurs the synchronized runtime overhead (which has been significantly reduced in recent versions of the JDK). If that’s a problem, methods that will not cause problems in critical sections can be left unsynchronized, but keep in mind that such methods are not always obvious. Methods that qualify tend to be small (such as getCircleSize( ) in the following example) and/or &quot;atomic&quot;; that is, the method call executes in such a short amount of code that the object cannot be changed during execution (but review the Concurrency chapter— what you may think is atomic might not be). Making such methods unsynchronized might not have a significant effect on the execution speed of your program. You’re better off making all public methods of a Bean synchronized and removing the synchronized keyword on a method only when you know for sure that it makes a difference and that you can safely remove the keyword.</p>
<p>2.    When firing a multicast event to a bunch of listeners interested in that event, you must assume that listeners might be added or removed while moving through the list.</p>
<p>The first point is fairly straightforward, but the second point requires a little more thought. BangBean.java ducked out of the concurrency question by ignoring the synchronized keyword and making the event unicast. Here is a modified version that works in a multithreaded environment and uses multicasting for events:</p>
<p>//: gui/BangBean2.java</p>
<p>// You should write your Beans this way so they</p>
<p>// can run in a multithreaded environment.</p>
<p>import javax.swing.*;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import java.io.*;</p>
<p>import java.util.*;</p>
<p>import static net.mindview.util.SwingConsole.*;</p>
<p>public class BangBean2 extends JPanel implements Serializable { private int xm, ym;</p>
<p>private int cSize = 20; // Circle size private String text = &quot;Bang!&quot;; private int fontSize = 48;</p>
<p>private Color tColor = Color.RED;</p>
<p>private ArrayList&lt;ActionListener&gt; actionListeners = new ArrayList&lt;ActionListener&gt;(); public BangBean2() {</p>
<p>addMouseListener(new ML()); addMouseMotionListener(new MM());</p>
<p>}</p>
<p>public synchronized int getCircleSize() { return cSize; } public synchronized void setCircleSize(int newSize) { cSize = newSize;</p>
<p>}</p>
<p>public synchronized String getBangText() { return text; } public synchronized void setBangText(String newText) { text = newText;</p>
<p>}</p>
<p>public synchronized int getFontSize(){ return fontSize; } public synchronized void setFontSize(int newSize) { fontSize = newSize;</p>
<p>}</p>
<p>public synchronized Color getTextColor(){ return tColor;} public synchronized void setTextColor(Color newColor) { tColor = newColor;</p>
<p>}</p>
<p>public void paintComponent(Graphics g) { super.paintComponent(g); g.setColor(Color.BLACK);</p>
<p>g.drawOval(xm - cSize/2, ym - cSize/2, cSize, cSize);</p>
<p>}</p>
<p>// This is a multicast listener, which is more typically // used than the unicast approach taken in BangBean.java: public synchronized void addActionListener(ActionListener l) { actionListeners.add(l);</p>
<p>}</p>
<p>public synchronized void removeActionListener(ActionListener l) { actionListeners.remove(l);</p>
<p>}</p>
<p>// Notice this isn’t synchronized: public void notifyListeners() {</p>
<p>ActionEvent a = new ActionEvent(BangBean2.this, ActionEvent.ACTION_PERFORMED, null); ArrayList&lt;ActionListener&gt; lv = null;</p>
<p>// Make a shallow copy of the List in case // someone adds a listener while we’re // calling listeners: synchronized(this) {</p>
<p>lv = new ArrayList&lt;ActionListener&gt;(actionListeners);</p>
<p>}</p>
<p>// Call all the listener methods: for(ActionListener al : lv) al.actionPerformed(a);</p>
<p>}</p>
<p>class ML extends MouseAdapter {</p>
<p>public void mousePressed(MouseEvent e) {</p>
<p>Graphics g = getGraphics();</p>
<p>g.setColor(tColor);</p>
<p>g.setFont(</p>
<p>new Font(&quot;TimesRoman&quot;, Font.BOLD, fontSize)); int width = g.getFontMetrics().stringWidth(text); g.drawString(text, (getSize().width - width) /2, getSize().height/2); g.dispose();</p>
<p>notifyListeners();</p>
<p>class MM extends MouseMotionAdapter { public void mouseMoved(MouseEvent e) { xm = e.getX(); ym = e.getY(); repaint();</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>BangBean2 bb2 = new BangBean2(); bb2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { System.out.println(&quot;ActionEvent&quot; + e);</p>
<p>}</p>
<p>});</p>
<p>bb2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { System.out.println(&quot;BangBean2 action&quot;);</p>
<p>}</p>
<p>});</p>
<p>bb2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { System.out.println(&quot;More action&quot;);</p>
<p>}</p>
<p>});</p>
<p>JFrame frame = new JFrame();</p>
<p>frame.add(bb2);</p>
<p>run(frame, 300, 300);</p>
<p>}</p>
<p>} ///:~</p>
<p>Adding synchronized to the methods is an easy change. However, notice in addActionListener( ) and removeActionListener( ) that the ActionListeners are</p>
<p>now added to and removed from an ArrayList, so you can have as many as you want.</p>
<p>You can see that the method notifyListeners( ) is not synchronized. It can be called from more than one thread at a time. It’s also possible for addActionListener( ) or removeActionListener( ) to be called in the middle of a call to notifyListeners( ), which is a problem because it traverses the ArrayList actionListeners. To alleviate the problem, the ArrayList is duplicated inside a synchronized clause, using the ArrayList constructor which copies the elements of its argument, and the duplicate is traversed. This way, the original ArrayList can be manipulated without impact on notifyListeners( ).</p>
<p>The paintComponent( ) method is also not synchronized. Deciding whether to synchronize overridden methods is not as clear as when you’re just adding your own methods. In this example, it turns out that paintComponent( ) seems to work OK whether it’s synchronized or not. But the issues you must consider are:</p>
<p>1.    Does the method modify the state of &quot;critical&quot; variables within the object? To discover whether the variables are &quot;critical,&quot; you must determine whether they will be read or set by other threads in the program. (In this case, the reading or setting is virtually always accomplished via synchronized methods, so you can just examine those.) In the case of paintComponent( ), no modification takes place.</p>
<p>2.    Does the method depend on the state of these &quot;critical&quot; variables? If a synchronized method modifies a variable that your method uses, then you might very well want to make your method synchronized as well. Based on this, you might observe that cSize is changed by synchronized methods, and therefore paintComponent( )</p>
<p>should be synchronized. Here, however, you can ask, &quot;What’s the worst thing that will happen if cSize is changed during a paintComponent( )?&quot; When you see that it’s nothing too bad, and a transient effect at that, you can decide to leave paintComponent( ) unsynchronized to prevent the extra overhead from the synchronized method call.</p>
<p>3.    A third clue is to notice whether the base-class version of paintComponent( ) is synchronized, which it isn’t. This isn’t an airtight argument, just a clue. In this case, for example, a field that is changed via synchronized methods (that is, cSize) has been mixed into the paintComponent( ) formula and might have changed the situation. Notice, however, that synchronized doesn’t inherit; that is, if a method is synchronized in the base class, then it is not automatically synchronized in the derivedclass overridden version.</p>
<p>4.    paint( ) and paintComponent( ) are methods that must be as fast as possible. Anything that takes processing overhead out of these methods is highly recommended, so if you think you need to synchronize these methods it may be an indicator of bad design.</p>
<p>The test code in main( ) has been modified from that seen in BangBeanTest to demonstrate the multicast ability of BangBean2 by adding extra listeners.</p>
<subtitle>Packaging a Bean</subtitle>
<p>Before you can bring a JavaBean into a Bean-enabled IDE, it must be put into a Bean container, which is a JAR file that includes all the Bean classes as well as a &quot;manifest&quot; file that says, &quot;This is a Bean.&quot; A manifest file is simply a text file that follows a particular form. For the BangBean, the manifest file looks like this:</p>
<p>Manifest-Version: 1.0</p>
<p>Name: bangbean/BangBean.class Java-Bean: True</p>
<p>The first line indicates the version of the manifest scheme, which until further notice from Sun is 1.0. The second line (empty lines are ignored) names the BangBean.class file, and the third says, &quot;It’s a Bean.&quot; Without the third line, the program builder tool will not recognize the class as a Bean.</p>
<p>The only tricky part is that you must make sure that you get the proper path in the &quot;Name:&quot; field. If you look back at BangBean.java, you’ll see it’s in package bangbean (and thus in a subdirectory called bangbean that’s off of the classpath), and the name in the manifest file must include this package information. In addition, you must place the manifest file in the directory above the root of your package path, which in this case means placing the file in the directory above the &quot;bangbean&quot; subdirectory. Then you must invoke jar from the same directory as the manifest file, as follows:</p>
<p>jar cfm BangBean.jar BangBean.mf bangbean</p>
<p>This assumes that you want the resulting JAR file to be named BangBean.jar, and that you’ve put the manifest in a file called BangBean.mf.</p>
<p>You might wonder, &quot;What about all the other classes that were generated when I compiled BangBean.java?&quot; Well, they all ended up inside the bangbean subdirectory, and you’ll see that the last argument for the above jar command line is the bangbean subdirectory. When you give jar the name of a subdirectory, it packages that entire subdirectory into the JAR file (including, in this case, the original BangBean.java source-code file—you might not choose to include the source with your own Beans). In addition, if you turn around and unpack the JAR file you’ve just created, you’ll discover that your manifest file isn’t inside, but that jar has created its own manifest file (based partly on yours) called MANIFEST.MF and placed it inside the subdirectory META-INF (for &quot;meta-information&quot;). If you open this manifest file, you’ll also notice that digital signature information has been added by jar for each file, of the form:</p>
<p>Digest-Algorithms: SHA MD5</p>
<p>SHA-Digest: pDpEAG9NaeCx8aFtqPI4udSX/O0=</p>
<p>MD5-Digest: 04NcSlhE3Smnzlp2hj6qeg==</p>
<p>In general, you don’t need to worry about any of this, and if you make changes, you can just modify your original manifest file and reinvoke jar to create a new JAR file for your Bean. You can also add other Beans to the JAR file simply by adding their information to your manifest.</p>
<p>One thing to notice is that you’ll probably want to put each Bean in its own subdirectory, since when you create a JAR file you hand the jar utility the name of a subdirectory, and it puts everything in that subdirectory into the JAR file. You can see that both Frog and BangBean are in their own subdirectories.</p>
<p>Once you have your Bean properly inside a JAR file, you can bring it into a Beans-enabled IDE. The way you do this varies from one tool to the next, but Sun provides a freely available test bed for JavaBeans in its &quot;Bean Builder.&quot; (Download from <a l:href="http://java.sun.com/beans">http://java.sun.com/beans</a>.) You place a Bean into the Bean Builder by simply copying the JAR file into the correct subdirectory.</p>
<p>Exercise 36: (4) Add Frog.class to the manifest file in this section and run jar to create a JAR file containing both Frog and BangBean. Now either download and install the Bean Builder from Sun, or use your own Beans-enabled program builder tool and add the JAR file to your environment so you can test the two Beans.</p>
<p>Exercise 37: (5) Create your own JavaBean called Valve that contains two properties: a boolean called &quot;on&quot; and an int called &quot;level.&quot; Create a manifest file, use jar to package your Bean, then load it into the Bean Builder or into a Beans-enabled program builder tool so that you can test it.</p>
<subtitle>More complex Bean support</subtitle>
<p>You can see how remarkably simple it is to make a Bean, but you aren’t limited to what you’ve seen here. The JavaBeans architecture provides a simple point of entry but can also scale to more complex situations. These situations are beyond the scope of this book, but they will be briefly introduced here. You can find more details at <a l:href="http://java.sun.com/beans">http://java.sun.com/beans</a>.</p>
<p>One place where you can add sophistication is with properties. The examples you’ve seen here have shown only single properties, but it’s also possible to represent multiple properties in an array. This is called an indexed property. You simply provide the appropriate methods (again following a naming convention for the method names), and the Introspector recognizes an indexed property so that your IDE can respond appropriately.</p>
<p>Properties can be bound, which means that they will notify other objects via a PropertyChangeEvent. The other objects can then choose to change themselves based on the change to the Bean.</p>
<p>Properties can be constrained, which means that other objects can veto a change to that property if it is unacceptable. The other objects are notified by using a</p>
<p>PropertyChangeEvent, and they can throw a PropertyVetoException to prevent the change from happening and to restore the old values.</p>
<p>You can also change the way your Bean is represented at design time:</p>
<p>1.    You can provide a custom property sheet for your particular Bean. The ordinary property sheet will be used for all other Beans, but yours is automatically invoked when your Bean is selected.</p>
<p>2.    You can create a custom editor for a particular property, so the ordinary property sheet is used, but when your special property is being edited, your editor will automatically be invoked.</p>
<p>3.    You can provide a custom BeanInfo class for your Bean that produces information different from the default created by the Introspector.</p>
<p>4.    It’s also possible to turn &quot;expert&quot; mode on and off in all FeatureDescriptors to distinguish between basic features and more complicated ones.</p>
<subtitle>More to Beans</subtitle>
<p>There are a number of books about JavaBeans; for example, JavaBeans by Elliotte Rusty Harold (IDG, 1998).</p>
</section>
<section>
<title>
<p>Alternatives to Swing</p></title><empty-line/>
<p>Although the Swing library is the GUI sanctioned by Sun, it is by no means the only way to create graphical user interfaces. Two important alternatives are Macromedia Flash, using Macromedia’s Flex programming system, for client-side GUIs over the Web, and the open-source Eclipse Standard Widget Toolkit (SWT) library for desktop applications.</p>
<p>Why would you consider alternatives? For Web clients, you can make a fairly strong argument that applets have failed. Considering how long they’ve been around (since the beginning) and the initial hype and promise around applets, coming across a Web application that uses applets is still a surprise. Even Sun doesn’t use applets everywhere. Here’s an example:</p>
<p><a l:href="http://java.sun.c0m/developer/onUneTraining/new2java/javamap/intro.html">http://java.sun.c0m/developer/onUneTraining/new2java/javamap/intro.html</a></p>
<p>An interactive map of Java features on the Sun site seems a very likely candidate for a Java applet, and yet they did it in Flash. This appears to be a tacit acknowledgement that applets have not been a success. More importantly, the Flash Player is installed on upwards of 98 percent of computing platforms, so it can be considered an accepted standard. As you’ll see, the Flex system provides a very powerful client-side programming environment, certainly more powerful than JavaScript and with a look and feel that is often preferable to an applet. If you want to use applets, you must still convince the client to download the JRE, whereas the Flash Player is small and fast to download by comparison.</p>
<p>For desktop applications, one problem with Swing is that users notice that they are using a different kind of application, because the look and feel of Swing applications is different from the normal desktop. Users are not generally interested in new looks and feels in an application; they are trying to get work done and prefer that an application look and feel like all their other applications. SWT creates applications that look like native applications, and because the library uses native components as much as possible, the applications tend to run faster than equivalent Swing applications.</p>
</section>
<section>
<title>
<p>Building Flash Web clients with Flex</p></title><empty-line/>
<p>Because the lightweight Macromedia Flash virtual machine is so ubiquitous, most people will be able to use a Flash-based interface without installing anything, and it will look and behave the same way across all systems and platforms.<a l:href="#bookmark142" type="note"><sup>143</sup></a><sup></sup></p>
<p>With Macromedia Flex, you can develop Flash user interfaces for Java applications. Flex consists of an XML- and script-based programming model, similar to programming models such as HTML and JavaScript, along with a robust library of components. You use the MXML syntax to declare layout management and widget controls, and you use dynamic scripting to add event-handling and service invocation code which links the user interface to Java classes, data models, Web services, etc. The Flex compiler takes your MXML and script files and compiles them into bytecode. The Flash virtual machine on the client operates like the Java Virtual Machine in that it interprets compiled bytecode. The Flash bytecode format is known as SWF, and SWF files are produced by the Flex compiler.</p>
<p>Note that there’s an open-source alternative to Flex at <a l:href="http://openlaszlo.org">http://openlaszlo.org</a>; this has a structure that’s similar to Flex but may be a preferable alternative for some. Other tools also exist to create Flash applications in different ways.</p>
<subtitle>Hello, Flex</subtitle>
<p>Consider this MXML code, which defines a user interface (note that the first and last lines will not appear in the code that you download as part of this book’s source-code package):</p>
<p>//:! gui/flex/helloflexi.mxml</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</p>
<p>&lt;mx:Application</p>
<p>xmlns:mx=&quot;<a l:href="http://www.macromedia.com/2003/mxml">http://www.macromedia.com/2003/mxml</a>&quot;</p>
<p>backgroundColor=&quot;#ffffff&quot;&gt;</p>
<p>&lt;mx:Label id=&quot;output&quot; text=&quot;Hello, Flex!&quot; /&gt;</p>
<p>&lt;/mx:Application&gt;</p>
<p>///:~</p>
<p>MXML files are XML documents, so they begin with an XML version/encoding directive. The outermost MXML element is the Application element, which is the topmost visual and logical container for a Flex user interface. You can declare tags representing visual controls, such as the Label element above, inside the Application element. Controls are always placed within a container, and containers encapsulate layout managers, among other mechanisms, so they manage the layout of the controls within them. In the simplest case, as in the above example, the Application acts as the container. The Application’s default layout manager merely places controls vertically down the interface in the order in which they are declared.</p>
<p>ActionScript is a version of ECMAScript, or JavaScript, which looks quite similar to Java and supports classes and strong typing in addition to dynamic scripting. By adding a script to the example, we can introduce behavior. Here, the MXML Script control is used to place ActionScript directly into the MXML file:</p>
<p>//:! gui/flex/helloflex2.mxml</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</p>
<p>&lt;mx:Application</p>
<p>xmlns:mx=&quot;<a l:href="http://www.macromedia.com/2003/mxml">http://www.macromedia.com/2003/mxml</a>&quot;</p>
<p>backgroundColor=&quot;#ffffff&quot;&gt;</p>
<p>&lt;mx:Script&gt;</p>
<p>&lt;![CDATA[</p>
<p>function updateOutput() {</p>
<p>output.text = &quot;Hello! &quot; + input.text;</p>
<p>}</p>
<p>]]&gt;</p>
<p>&lt;/mx:Script&gt;</p>
<p>&lt;mx:TextInput id=&quot;input&quot; width=&quot;200&quot; change=&quot;updateOutput()&quot; /&gt;</p>
<p>&lt;mx:Label id=&quot;output&quot; text=&quot;Hello!&quot; /&gt; &lt;/mx:Application&gt;</p>
<p>///:~</p>
<p>A TextInput control accepts user input, and a Label displays the data as it is being typed. Note that the id attribute of each control becomes accessible in the script as a variable name, so the script can reference instances of the MXML tags. In the TextInput field, you can see that the change attribute is connected to the updateOutput( ) function so that the function is called whenever any kind of change occurs.</p>
<subtitle>Compiling MXML</subtitle>
<p>The easiest way to get started using Flex is with the free trial, which you can download at <a l:href="http://www.macromedia.com/software/flex/trial.1">www.macromedia.com/software/flex/trial.<sup>1</sup></a> The product is packaged in a number of editions, from free trials to enterprise server versions, and Macromedia offers additional tools for developing Flex applications. Exact packaging is subject to change, so check the Macromedia site for specifics. Also note that you may need to modify the jvm.config file in the Flex installation bin directory.</p>
<p>To compile the MXML code into Flash bytecode, you have two options:</p>
<p>1.    You can place the MXML file in a Java Web application, alongside JSP and HTML pages in a WAR file, and have requests for the .mxml file compiled at run time whenever a browser requests the MXML document’s URL.</p>
<p>2.    You can compile the MXML file using the Flex command-line compiler, mxmlc.</p>
<p>The first option, Web-based runtime compilation, requires a servlet container (such as Apache Tomcat) in addition to Flex. The servlet container’s WAR file(s) must be updated with Flex configuration information, such as servlet mappings which are added to the web.xml descriptor, and it must include the Flex JAR files—these steps are handled automatically when you install Flex. After the WAR file is configured, you can place the MXML files in the Web application and request the document’s URL through any browser. Flex will compile the application upon the first request, similar to the JSP model, and will thereafter deliver the compiled and cached SWF within an HTML shell.</p>
<p>The second option does not require a server. When you invoke the Flex mxmlc compiler on the command line, you produce SWF files. You can deploy these as you desire. The mxmlc executable is located in the bin directory of a Flex installation, and invoking it with no arguments will provide a list of valid command-line options. Typically, you’ll specify the location of the Flex client component library as the value of the -flexlib command-line option, but in very simple examples like the two that we’ve seen so far, the Flex compiler will assume the location of the component library. So you can compile the first two examples like this: <a l:href="#bookmark143" type="note"><sup>144</sup></a><sup></sup></p>
<p>mxmlc.exe helloflexl.mxml mxmlc.exe helloflex2.mxml</p>
<p>This produces a helloflex2.swf file which can be run in Flash, or placed alongside HTML on any HTTP server (once Flash has been loaded into your Web browser, you can often just double-click on the SWF file to start it up in the browser).</p>
<p>For helloflex2.swf, you’ll see the following user interface running in the Flash Player:</p>
<p>This was not too hard to do...|</p>
<p>Hello! This was not too hard to do.</p>
<p>In more complex applications, you can separate MXML and ActionScript by referencing functions in external ActionScript files. From MXML, you use the following syntax for the Script control:</p>
<p>&lt;mx:Script source=&quot;MyExternalScript.as&quot; /&gt;</p>
<p>This code allows the MXML controls to reference functions located in a file named MyExternalScript.as as if they were located within the MXML file.</p>
<subtitle>MXML and ActionScript</subtitle>
<p>MXML is declarative shorthand for ActionScript classes. Whenever you see an MXML tag, there exists an ActionScript class of the same name. When the Flex compiler parses MXML, it first transforms the XML into ActionScript and loads the referenced ActionScript classes, and then compiles and links the ActionScript into an SWF.</p>
<p>You can write an entire Flex application in ActionScript alone, without using any MXML. Thus, MXML is a convenience. User interface components such as containers and controls are typically declared using MXML, while logic such as event handling and other client logic is handled through ActionScript and Java.</p>
<p>You can create your own MXML controls and reference them using MXML by writing ActionScript classes. You may also combine existing MXML containers and controls in a new MXML document that can then be referenced as a tag in another MXML document. The Macromedia Web site contains more information about how to do this.</p>
<subtitle>Containers and controls</subtitle>
<p>The visual core of the Flex component library is a set of containers which manage layout, and an array of controls which go inside those containers. Containers include panels, vertical and horizontal boxes, tiles, accordions, divided boxes, grids, and more. Controls are user interface widgets such as buttons, text areas, sliders, calendars, data grids, and so forth.</p>
<p>The remainder of this section will show a Flex application that displays and sorts a list of audio files. This application demonstrates containers, controls, and how to connect to Java from Flash.</p>
<p>We start the MXML file by placing a DataGrid control (one of the more sophisticated Flex controls) within a Panel container:</p>
<p>//:! gui/flex/songs.mxml</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</p>
<p>&lt;mx:Application</p>
<p>xmlns:mx=&quot;<a l:href="http://www.macromedia.com/2003/mxml">http://www.macromedia.com/2003/mxml</a>&quot; backgroundColor=&quot;#B9CAD2&quot; pageTitle=&quot;Flex Song Manager&quot; initialize=&quot;getSongs()&quot;&gt;</p>
<p>&lt;mx:Script source=&quot;songScript.as&quot; /&gt;</p>
<p>&lt;mx:Style source=&quot;songStyles.css&quot;/&gt;</p>
<p>&lt;mx:Panel id=&quot;songListPanel&quot;</p>
<p>titleStyleDeclaration=&quot;headerText&quot; title=&quot;Flex MP3 Library&quot;&gt;</p>
<p>&lt;mx:HBox verticalAlign=&quot;bottom&quot;&gt;</p>
<p>&lt;mx:DataGrid id=&quot;songGrid&quot;</p>
<p>cellPress=&quot;selectSong(event)&quot; rowCount=&quot;8&quot;&gt; &lt;mx:columns&gt;</p>
<p>&lt;mx:Array&gt;</p>
<p>&lt;mx:DataGridColumn columnName=&quot;name&quot; headerText=&quot;Song Name&quot; width=&quot;120&quot; /&gt; &lt;mx:DataGridColumn columnName=&quot;artist&quot; headerText=&quot;Artist&quot; width=&quot;180&quot; /&gt; &lt;mx:DataGridColumn columnName=&quot;album&quot; headerText=&quot;Album&quot; width=&quot;160&quot; /&gt;</p>
<p>&lt;/mx:Array&gt;</p>
<p>&lt;/mx:columns&gt;</p>
<p>&lt;/mx:DataGrid&gt;</p>
<p>&lt;mx:VBox&gt;</p>
<p>&lt;mx:HBox height=&quot;100&quot; &gt;</p>
<p>&lt;mx:Image id=&quot;albumImage&quot; source=&quot;&quot; height=&quot;80&quot; width=&quot;100&quot; mouseOverEffect=&quot;resizeBig&quot; mouseOutEffect=&quot;resizeSmall&quot; /&gt;</p>
<p>&lt;mx:TextArea id=&quot;songInfo&quot;</p>
<p>styleName=&quot;boldText&quot; height=&quot;100%&quot; width=&quot;120&quot; vScrollPolicy=&quot;off&quot; borderStyle=&quot;none&quot; /&gt; &lt;/mx:HBox&gt;</p>
<p>&lt;mx:MediaPlayback id=&quot;songPlayer&quot; contentPath=&quot;&quot; mediaType=&quot;MP3&quot; height=&quot;70&quot; width=&quot;230&quot; controllerPolicy=&quot;on&quot; autoPlay=&quot;false&quot; visible=&quot;false&quot; /&gt;</p>
<p>&lt;/mx:VBox&gt;</p>
<p>&lt;/mx:HBox&gt;</p>
<p>&lt;mx:ControlBar horizontalAlign=&quot;right&quot;&gt;</p>
<p>&lt;mx:Button id=&quot;refreshSongsButton&quot; label=&quot;Refresh Songs&quot; width=&quot;100&quot; toolTip=&quot;Refresh Song List&quot; click=&quot;songService.getSongs()&quot; /&gt;</p>
<p>&lt;/mx:ControlBar&gt;</p>
<p>&lt;/mx:Panel&gt;</p>
<p>&lt;mx:Effect&gt;</p>
<p>&lt;mx:Resize name=&quot;resizeBig&quot; heightTo=&quot;100&quot; duration=&quot;500&quot;/&gt;</p>
<p>&lt;mx:Resize name=&quot;resizeSmall&quot; heightTo=&quot;80&quot; duration=&quot;500&quot;/&gt;</p>
<p>&lt;/mx:Effect&gt;</p>
<p>&lt;mx:RemoteObject id=&quot;songService&quot; source=&quot;gui.flex.SongService&quot; result=&quot;onSongs(event.result)&quot; fault=&quot;alert(event.fault.faultstring, ‘Error’)&quot;&gt; &lt;mx:method name=&quot;getSongs&quot;/&gt;</p>
<p>&lt;/mx:RemoteObject&gt;</p>
<p>&lt;/mx:Application&gt;</p>
<p>///:~</p>
<p>The DataGrid contains nested tags for its array of columns. When you see an attribute or a nested element on a control, you know that it corresponds to some property, event, or encapsulated object in the underlying ActionScript class. The DataGrid has an id attribute with the value songGrid, so ActionScript and MXML tags can reference the grid programmatically by using songGrid as a variable name. The DataGrid exposes many more properties than those shown here; the complete API for MXML controls and containers can be found online at http ://livedocs. macromedia. com/flex/is/asdocs_ en/index.html.</p>
<p>The DataGrid is followed by a VBox containing an Image to show the front of the album along with song information, and a MediaPlayback control that will play MP3 files. This example streams the content in order to reduce the size of the compiled SWF. When you embed images, audio, and video files into a Flex application instead of streaming them, the files become part of the compiled SWF and are delivered along with your user interface assets instead of streamed on demand at run time.</p>
<p>The Flash Player contains embedded codecs for playing and streaming audio and video in a variety of formats. Flash and Flex support the use of the Web’s most common image formats, and Flex also has the ability to translate scalable vector graphics (SVG) files into SWF resources that can be embedded in Flex clients.</p>
<subtitle>Effects and styles</subtitle>
<p>The Flash Player renders graphics using vectors, so it can perform highly expressive transformations at run time. Flex effects provide a small taste of these sorts of animations. Effects are transformations that you can apply to controls and containers using MXML syntax.</p>
<p>The Effect tag shown in the MXML produces two results: The first nested tag dynamically grows an image when the mouse hovers over it, and the second dynamically shrinks that image when the mouse moves away. These effects are applied to the mouse events available on the Image control for albumlmage.</p>
<p>Flex also provides effects for common animations like transitions, wipes, and modulating alpha channels. In addition to the built-in effects, Flex supports the Flash drawing API for truly innovative animations. Deeper exploration of this topic involves graphic design and animation, and is beyond the scope of this section.</p>
<p>Standard styling is available through Flex’s support for Cascading Style Sheets (CSS). If you attach a CSS file to an MXML file, the Flex controls will follow those styles. For this example, songStyles.css contains the following CSS declaration:</p>
<p>//:! gui/flex/songStyles.css .headerText {</p>
<p>font-family: Arial, &quot;_sans&quot;; font-size: 16; font-weight: bold;</p>
<p>}</p>
<p>.boldText {</p>
<p>font-family: Arial, &quot;_sans&quot;; font-size: 11; font-weight: bold;</p>
<p>}</p>
<p>///:~</p>
<p>This file is imported and used in the song library application via the Style tag in the MXML file. After the style sheet is imported, its declarations can be applied to Flex controls in the</p>
<p>MXML file. As an example, the style sheet’s boldText declaration is used by the TextArea control with the songInfo id.</p>
<subtitle>Events</subtitle>
<p>A user interface is a state machine; it performs actions as state changes occur. In Flex, these changes are managed through events. The Flex class library contains a wide variety of controls with extensive events covering all aspects of mouse movement and keyboard usage.</p>
<p>The click attribute of a Button, for example, represents one of the events available on that control. The value assigned to click can be a function or an inline bit of script. In the MXML file, for example, the ControlBar holds the refreshSongsButton to refresh the list of songs. You can see from the tag that when the click event occurs,</p>
<p>songService.getSongs( ) is called. In this example, the click event of the Button refers to the RemoteObject which corresponds to the Java method.</p>
<subtitle>Connecting to Java</subtitle>
<p>The RemoteObject tag at the end of the MXML file sets up the connection to the external Java class, gui.flex.SongService. The Flex client will use the getSongs( ) method in the Java class to retrieve the data for the DataGrid. To do so, it must appear as a service—an endpoint with which the client can exchange messages. The service defined in the RemoteObject tag has a source attribute which denotes the Java class of the RemoteObject, and it specifies an ActionScript callback function, onSongs( ), to be invoked when the Java method returns. The nested method tag declares the method getSongs( ), which makes that Java method accessible to the rest of the Flex application.</p>
<p>All invocations of services in Flex return asynchronously, through events fired to these callback functions. The RemoteObject also raises an alert dialog control in the event of an error.</p>
<p>The getSongs( ) method may now be invoked from Flash using ActionScript: songService.getSongs();</p>
<p>Because of the MXML configuration, this will call getSongs( ) in the SongService class:</p>
<p>//: gui/flex/SongService.java package gui.flex; import java.util.*;</p>
<p>public class SongService {</p>
<p>private List&lt;Song&gt; songs = new ArrayList&lt;Song&gt;(); public SongService() { fillTestData(); } public List&lt;Song&gt; getSongs() { return songs; } public void addSong(Song song) { songs.add(song); } public void removeSong(Song song) { songs.remove(song); } private void fillTestData() {</p>
<p>addSong(new Song(&quot;Chocolate&quot;, &quot;Snow Patrol&quot;,</p>
<p>&quot;Final Straw&quot;, &quot;sp-final-straw.jpg&quot;,</p>
<p>&quot;chocolate.mp3&quot;));</p>
<p>addSong(new Song(&quot;Concerto No. 2 in E&quot;, &quot;Hilary Hahn&quot;,</p>
<p>&quot;Bach: Violin Concertos&quot;, &quot;hahn.jpg&quot;,</p>
<p>&quot;bachviolin2.mp3&quot;));</p>
<p>addSong(new Song(&quot;‘Round Midnight&quot;, &quot;Wes Montgomery&quot;,</p>
<p>&quot;The Artistry of Wes Montgomery&quot;,</p>
<p>&quot;wesmontgomery.jpg&quot;, &quot;roundmidnight.mp3&quot;));</p>
<p>} ///:~</p>
<p>Each Song object is just a data container:</p>
<p>//: gui/flex/Song.java package gui.flex;</p>
<p>public class Song implements java.io.Serializable { private String name; private String artist; private String album; private String albumImageUrl; private String songMediaUrl; public Song() {}</p>
<p>public Song(String name, String artist, String album,</p>
<p>String albumImageUrl, String songMediaUrl) { this.name = name; this.artist = artist; this.album = album; this.albumImageUrl = albumImageUrl; this.songMediaUrl = songMediaUrl;</p>
<p>}</p>
<p>public void setAlbum(String album) { this.album = album;} public String getAlbum() { return album; } public void setAlbumImageUrl(String albumImageUrl) { this.albumImageUrl = albumImageUrl;</p>
<p>}</p>
<p>public String getAlbumImageUrl() { return albumImageUrl;} public void setArtist(String artist) { this.artist = artist;</p>
<p>}</p>
<p>public String getArtist() { return artist; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setSongMediaUrl(String songMediaUrl) { this.songMediaUrl = songMediaUrl;</p>
<p>}</p>
<p>public String getSongMediaUrl() { return songMediaUrl; }</p>
<p>} ///:~</p>
<p>When the application is initialized or you press the refreshSongsButton, getSongs( ) is called, and upon returning, the ActionScript onSongs(event.result) is called to populate the songGrid.</p>
<p>Here is the ActionScript listing, which is included with the MXML file’s Script control:</p>
<p>//: gui/flex/songScript.as function getSongs() { songService.getSongs();</p>
<p>}</p>
<p>function selectSong(event) {</p>
<p>var song = songGrid.getItemAt(event.itemIndex); showSongInfo(song);</p>
<p>}</p>
<p>function showSongInfo(song) {</p>
<p>songInfo.text = song.name + newline; songInfo.text += song.artist + newline; songInfo.text += song.album + newline;</p>
<p>albumImage.source = song.albumImageUrl; songPlayer.contentPath = song.songMediaUrl; songPlayer.visible = true;</p>
<p>function onSongs(songs) {</p>
<p>songGrid.dataProvider = songs;</p>
<p>} ///:~</p>
<p>To handle DataGrid cell selections, we add the cellPress event attribute to the DataGrid declaration in the MXML file:</p>
<p>cellPress=&quot;selectSong(event)&quot;</p>
<p>When the user clicks on a song in the DataGrid, this will call selectSong( ) in the ActionScript above.</p>
<subtitle>Data models and data binding</subtitle>
<p>Controls can directly invoke services, and ActionScript event callbacks give you a chance to programmatically update the visual controls when services return data. While the script which updates the controls is straightforward, it can get verbose and cumbersome, and its functionality is so common that Flex handles the behavior automatically, with data binding.</p>
<p>In its simplest form, data binding allows controls to reference data directly instead of requiring glue code to copy data into a control. When the data is updated, the control which references it is also automatically updated without any need for programmer intervention. The Flex infrastructure correctly responds to the data change events, and updates all controls which are bound to the data.</p>
<p>Here is a simple example of data binding syntax:</p>
<p>&lt;mx:Slider id=&quot;mySlider&quot;/&gt;</p>
<p>&lt;mx:Text text=&quot;{mySlider.value}&quot; /&gt;</p>
<p>To perform data binding, you place references within curly braces: {}. Everything within those curly braces is deemed an expression for Flex to evaluate.</p>
<p>The value of the first control, a Slider widget, is displayed by the second control, a Text field. As the Slider changes, the Text field’s text property is automatically updated. This way, the developer does not need to handle the Slider’s change events in order to update the Text field.</p>
<p>Some controls, such as the Tree control and the DataGrid in the song library application, are more sophisticated. These controls have a dataprovider property to facilitate binding to collections of data. The ActionScript onSongs( ) function shows how the SongService.getSongs( ) method is bound to the dataprovider of the Flex DataGrid. As declared in the RemoteObject tag in the MXML file, this function is the callback that ActionScript invokes whenever the Java method returns.</p>
<p>A more sophisticated application with more complex data modeling, such as an enterprise application making use of Data Transfer Objects or a messaging application with data conforming to complex schemas, may encourage further decoupling of the source of data from the controls. In Flex development, we perform this decoupling by declaring a &quot;Model&quot; object, which is a generic MXML container for data. The model contains no logic. It mirrors the Data Transfer Object found in enterprise development, and the structures of other programming languages. By using the model, we can databind our controls to the model, and</p>
<p>at the same time have the model databind its properties to service inputs and outputs. This decouples the sources of data, the services, from the visual consumers of the data, facilitating use of the Model- View-Controller (MVC) pattern. In larger, more sophisticated applications, the initial complexity caused by inserting a model is often only a small tax compared to the value of a cleanly decoupled MVC application.</p>
<p>In addition to Java objects, Flex can also access SOAP-based Web services and RESTful HTTP services using the WebService and HttpService controls, respectively. Access to all services is subject to security authorization constraints.</p>
<subtitle>Building and deploying</subtitle>
<p>With the earlier examples, you could get away without a -flexlib flag on the command line, but to compile this program, you must specify the location of the flex-config.xml file using the -flexlib flag. For my installation, the following command works, but you’ll have to modify it for your own configuration (the command is a single line, which has been wrapped):</p>
<p>//:! gui/flex/buiId-command.txt mxmlc -flexlib C:/&quot;Program</p>
<p>Files&quot;/Macromedia/Flex/jrun4/servers/default/flex/WEB-INF/flex</p>
<p>songs.mxml</p>
<p>///:~</p>
<p>This command will build the application into an SWF file which you can view in your browser, but the book’s code distribution file contains no MP3 files or JPG files, so you won’t see anything but the framework when you run the application.</p>
<p>In addition, you must configure a server in order to successfully talk to the Java files from the Flex application. The Flex trial package comes with the JRun server, and you can start this through your computer’s menus once Flex is installed, or via the command line:</p>
<p>jrun -start default</p>
<p>You can verify that the server has been successfully started by opening <a l:href="http://localhost:8700/samples">http://localhost:8700/samples</a> in a Web browser and viewing the various samples (this is also a good way to get more familiar with the abilities of Flex).</p>
<p>Instead of compiling the application on the command line, you can compile it via the server. To do this, drop the song source files, CSS style sheet, etc., into the jrun4/servers/default/flex directory and access them in a browser by opening http://localhost:870o/flex/songs.mxml.</p>
<p>To successfully run the app, you must configure both the Java side and the Flex side.</p>
<p>Java: The compiled Song.java and SongService.java files must be placed in your WEB-INF/classes directory. This is where you drop WAR classes according to the J2EE specification. Alternatively, you can JAR the files and drop the result in WEB-INF/lib. It must be in a directory that matches its Java package structure. If you’re using JRun, these would be placed in jrun4/servers/defauIt/flex/WEB-</p>
<p>INF/classes/gui/flex/Song.cIass and jrun4/servers/default/flex/WEBINF/ classes/gui/flex/SongService.class. You also need the image and MP3 support files available in the Web app (for JRun, jrun4/servers/default/flex is the Web app root).</p>
<p>Flex: For security reasons, Flex cannot access Java objects unless you give permission by modifying your flex-config.xml file. For JRun, this is located at</p>
<p>jrun4/servers/default/flex/WEB-INF/flex/flex-config.xml. Go to the &lt;remote-objects&gt; entry in that file, look at the &lt;whitelist&gt; section within, and see the following note:</p>
<p>&lt;!--</p>
<p>For security, the whitelist is locked down by default. Uncomment the source element below to enable access to all classes during development.</p>
<p>We strongly recommend not allowing access to all source files in production, since this exposes Java and Flex system classes. &lt;source&gt;*&lt;/source&gt;</p>
<p>--&gt;</p>
<p>Uncomment that &lt;source&gt; entry to allow access, so that it reads &lt;source&gt;*&lt;/source&gt;. The meaning of this and other entries is described in the Flex configuration docs.</p>
<p>Exercise 38: (3) Build the &quot;simple example of data binding syntax&quot; shown above.</p>
<p>Exercise 39: (4) The code download for this book does not include the MP3S or JPGs shown in SongService.java. Find some MP3S and JPGs, modify SongService.java to include their file names, download the Flex trial and build the application.</p>
</section>
<section>
<title>
<p>Creating SWT applications</p></title><empty-line/>
<p>As previously noted, Swing took the approach of building all the UI components pixel-bypixel, in order to provide every component desired whether the underlying OS had those components or not. SWT takes the middle ground by using native components if the OS provides them, and synthesizing components if it doesn’t. The result is an application that feels to the user like a native application, and often has noticeably faster performance than the equivalent Swing program. In addition, SWT tends to be a less complex programming model than Swing, which can be desirable in a large portion of applications.<a l:href="#bookmark144" type="note"><sup>145</sup></a><sup></sup></p>
<p>Because SWT uses the native OS to do as much of its work as possible, it can automatically take advantage of OS features that may not be available to Swing—for example, Windows has &quot;subpixel rendering&quot; that makes fonts on LCD screens clearer.</p>
<p>It’s even possible to create applets using SWT.</p>
<p>This section is not meant to be a comprehensive introduction to SWT; it’s just enough to give you a flavor of it, and to see how SWT contrasts with Swing. You’ll discover that there are lots of SWT widgets and that they are all reasonably straightforward to use. You can explore the details in the full documentation and many examples that can be found at <a l:href="http://www.eclipse.org">www.eclipse.org</a>. There are also a number of books on programming with SWT, and more on the way.</p>
<subtitle>Installing SWT</subtitle>
<p>SWT applications require downloading and installing the SWT library from the Eclipse project. Go to <a l:href="http://www.eclipse.org/downloads/">www.eclipse.org/downloads/</a> and choose a mirror. Follow the links to the current Eclipse build and locate a compressed file with a name that begins with &quot;swt&quot; and includes the name of your platform (for example, &quot;win32&quot;). Inside this file you’ll find swt.jar. The easiest way to install the swt.jar file is to put it into your jre/lib/ext directory (that way you don’t have to make any modifications to your classpath). When you decompress the SWT library, you may find additional files that you need to install in appropriate places for your platform. For example, the Win32 distribution comes with DLL files that need to be placed somewhere in your java.library.path (this is usually the same as your PATH environment variable, but you can run object/ShowProperties.java to discover the actual value of java.library.path). Once you’ve done this, you should be able to transparently compile and execute an SWT application as if it were any other Java program.</p>
<p>The documentation for SWT is in a separate download.</p>
<p>An alternative approach is just to install the Eclipse editor, which includes both SWT and the SWT documentation that you can view through the Eclipse help system.</p>
<subtitle>Hello, SWT</subtitle>
<p>Let’s start with the simplest possible &quot;hello world&quot;-style application:</p>
<p>//: swt/HelloSWT.java</p>
<p>// {Requires: org.eclipse.swt.widgets.Display; You must // install the SWT library from <a l:href="http://www.eclipse.org">http://www.eclipse.org</a> } import org.eclipse.swt.widgets.*;</p>
<p>public class HelloSWT {</p>
<p>public static void main(String [] args) {</p>
<p>Display display = new Display();</p>
<p>Shell shell = new Shell(display); shell.setText(&quot;Hi there, SWT!&quot;); // Title bar shell.open();</p>
<p>while(!shell.isDisposed())</p>
<p>if(!display.readAndDispatch())</p>
<p>display.sleep();</p>
<p>display.dispose();</p>
<p>}</p>
<p>} ///:~</p>
<p>If you download the source code from this book, you’ll discover that the &quot;Requires&quot; comment directive ends up in the Ant build.xml as a prerequisite for building the swt subdirectory; all the files that import org.eclipse.swt require that you install the SWT library from <a l:href="http://www.eclipse.org">www.eclipse.org</a>.</p>
<p>The Display manages the connection between SWT and the underlying operating system—it is part of a Bridge between the operating system and SWT. The Shell is the top-level main window, within which all the other components are built. When you call setText( ), the argument becomes the label on the title bar of the window.</p>
<p>To display the window and thus the application, you must call open( ) on the Shell.</p>
<p>Whereas Swing hides the event-handling loop from you, SWT forces you to write it explicitly. At the top of the loop, you check to see whether the shell has been disposed—note that this gives you the option of inserting code to perform cleanup activities. But this means that the main( ) thread is the user interface thread. In Swing, a second event-dispatching thread is created behind the scenes, but in SWT your main( ) thread is what handles the UI. Since by default there’s only one thread and not two, this makes it somewhat less likely that you’ll clobber the UI with threads.</p>
<p>Notice that you don’t have to worry about submitting tasks to the user interface thread like you do in Swing. SWT not only takes care of this for you, it throws an exception if you try to manipulate a widget with the wrong thread. However, if you need to spawn other threads to perform long-running operations, you still need to submit changes in the same way that you do with Swing. For this, SWT provides three methods which can be called on the Display object: asyncExec(Runnable), syncExec(Runnable) and timerExec(int, Runnable).</p>
<p>The activity of your main( ) thread at this point is to call readAndDispatch( ) on the Display object (this means that there can only be one Display object per application). The readAndDispatch( ) method returns true if there are more events in the event queue, waiting to be processed. In that case, you want to call it again, immediately. However, if nothing is pending, you call the Display object’s sleep( ) to wait for a short time before checking the event queue again.</p>
<p>Once the program is complete, you must explicitly dispose( ) of your Display object. SWT often requires you to explicitly dispose of resources, because these are usually resources from the underlying operating system, which may otherwise become exhausted.</p>
<p>To prove that the Shell is the main window, here’s a program that makes a number of Shell objects:</p>
<p>//: swt/ShellsAreMainWindows.java import org.eclipse.swt.widgets.*;</p>
<p>public class ShellsAreMainWindows { static Shell[] shells = new Shell[10]; public static void main(String [] args) {</p>
<p>Display display = new Display(); for(int i = 0; i &lt; shells.length; i++) { shells[i] = new Shell(display); shells[i].setText(&quot;Shell #&quot; + i); shells[i].open();</p>
<p>}</p>
<p>while(!shellsDisposed())</p>
<p>if(!display.readAndDispatch())</p>
<p>display.sleep();</p>
<p>display.dispose();</p>
<p>}</p>
<p>static boolean shellsDisposed() {</p>
<p>for(int i = 0; i &lt; shells.length; i++) if(shells[i].isDisposed()) return true; return false;</p>
<p>}</p>
<p>} ///:~</p>
<p>When you run it, you’ll get ten main windows. The way the program is written, if you close any one of the windows, it will close all of them.</p>
<p>SWT also uses layout managers—different ones than Swing, but the same idea. Here’s a slightly more complex example that takes the text from System.getProperties( ) and adds it to the shell:</p>
<p>//: swt/DisplayProperties.java import org.eclipse.swt.*; import org.eclipse.swt.widgets.*; import org.eclipse.swt.layout.*; import java.io.*;</p>
<p>public class DisplayProperties {</p>
<p>public static void main(String [] args) {</p>
<p>Display display = new Display();</p>
<p>Shell shell = new Shell(display); shell.setText(&quot;Display Properties&quot;); shell.setLayout(new FillLayout());</p>
<p>Text text = new Text(shell, SWT.WRAP | SWT.V_SCROLL);</p>
<p>StringWriter props = new StringWriter(); System.getProperties().list(new PrintWriter(props));</p>
<p>text.setText(props.toString());</p>
<p>shell.open();</p>
<p>while(!shell.isDisposed())</p>
<p>if(!display.readAndDispatch())</p>
<p>display.sleep();</p>
<p>display.dispose();</p>
<p>}</p>
<p>} ///:~</p>
<p>In SWT, all widgets must have a parent object of the general type Composite, and you must provide this parent as the first argument in the widget constructor. You see this in the Text constructor, where shell is the first argument. Virtually all constructors also take a flag argument that allows you to provide any number of style directives, depending on what that particular widget accepts. Multiple style directives are bitwise-ORed together as seen in this example.</p>
<p>When setting up the Text( ) object, I added style flags so that it wraps the text, and automatically adds a vertical scroll bar if it needs to. You’ll discover that SWT is very constructor-based; there are many attributes of a widget that are difficult or impossible to change except via the constructor. Always check a widget constructor’s documentation for the accepted flags. Note that some constructors require a flag argument even when they have no &quot;accepted&quot; flags listed in the documentation. This allows future expansion without modifying the interface.</p>
<subtitle>Eliminating redundant code</subtitle>
<p>Before going on, notice that there are certain things you do for every SWT application, just like there were duplicate actions for Swing programs. For SWT, you always create a Display, make a Shell from the Display, create a readAndDispatch( ) loop, etc. Of course, in some special cases, you may not do this, but it’s common enough that it’s worth trying to eliminate the duplicate code as we did with net.mindview.util.SwingConsole.</p>
<p>We’ll need to force each application to conform to an interface:</p>
<p>//: swt/util/SWTApplication.java</p>
<p>package swt.util;</p>
<p>import org.eclipse.swt.widgets.*;</p>
<p>public interface SWTApplication {</p>
<p>void createContents(Composite parent);</p>
<p>} ///:~</p>
<p>The application is handed a Composite object (Shell is a subclass) and must use this to create all of its contents inside createContents( ). SWTConsole.run( ) calls createContents( ) at the appropriate point, sets the size of the shell according to what the user passes to run( ), opens the shell and then runs the event loop, and finally disposes of the shell at program exit:</p>
<p>//: swt/util/SWTConsole.java</p>
<p>package swt.util;</p>
<p>import org.eclipse.swt.widgets.*;</p>
<p>public class SWTConsole { public static void</p>
<p>run(SWTApplication swtApp, int width, int height) {</p>
<p>Display display = new Display();</p>
<p>Shell shell = new Shell(display);</p>
<p>shell.setText(swtApp.getClass().getSimpleName());</p>
<p>swtApp.createContents(shell);</p>
<p>shell.setSize(width, height); shell.open();</p>
<p>while(!shell.isDisposed()) { if(!display.readAndDispatch()) display.sleep();</p>
<p>}</p>
<p>display.dispose();</p>
<p>}</p>
<p>} ///:~</p>
<p>This also sets the title bar to the name of the SWTApplication class, and sets the width and height of the Shell.</p>
<p>We can create a variation of DisplayProperties.Java that displays the machine environment, using SWTConsole:</p>
<p>//: swt/DisplayEnvironment.java import swt.util.*; import org.eclipse.swt.*; import org.eclipse.swt.widgets.*; import org.eclipse.swt.layout.*; import java.util.*;</p>
<p>public class DisplayEnvironment implements SWTApplication { public void createContents(Composite parent) { parent.setLayout(new FillLayout());</p>
<p>Text text = new Text(parent, SWT.WRAP | SWT.V_SCROLL); for(Map.Entry entry: System.getenv().entrySet()) { text.append(entry.getKey() + &quot;: &quot; + entry.getValue() + &quot;\n&quot;);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String [] args) {</p>
<p>SWTConsole.run(new DisplayEnvironment(), 800, 600);</p>
<p>}</p>
<p>} ///:~</p>
<p>SWTConsole allows us to focus on the interesting aspects of an application rather than the repetitive code.</p>
<p>Exercise 40: (4) Modify DisplayProperties.java so that it uses SWTConsole.</p>
<p>Exercise 41: (4) Modify Display Environment.java so that it does nor use SWTConsole.</p>
<subtitle>Menus</subtitle>
<p>To demonstrate basic menus, this example reads its own source code and breaks it into words, then populates the menus with these words:</p>
<p>//: swt/Menus.java</p>
<p>// Fun with menus.</p>
<p>import swt.util.*;</p>
<p>import org.eclipse.swt.*;</p>
<p>import org.eclipse.swt.widgets.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>public class Menus implements SWTApplication {</p>
<p>private static Shell shell;</p>
<p>public void createContents(Composite parent) { shell = parent.getShell();</p>
<p>Menu bar = new Menu(shell, SWT.BAR); shell.setMenuBar(bar);</p>
<p>Set&lt;String&gt; words = new TreeSet&lt;String&gt;( new TextFile(&quot;Menus.java&quot;, &quot;\\W+&quot;));</p>
<p>Iterator&lt;String&gt; it = words.iterator(); while(it.next().matches(&quot;[0-9]+&quot;))</p>
<p>; // Move past the numbers.</p>
<p>MenuItem[] mItem = new MenuItem[7]; for(int i = 0; i &lt; mItem.length; i++) { mItem[i] = new MenuItem(bar, SWT.CASCADE); mItem[i].setText(it.next());</p>
<p>Menu submenu = new Menu(shell, SWT.DROP_DOWN); mItem[i].setMenu(submenu);</p>
<p>}</p>
<p>int i = 0;</p>
<p>while(it.hasNext()) {</p>
<p>addItem(bar, it, mItem[i]); i = (i + 1) % mItem.length;</p>
<p>}</p>
<p>}</p>
<p>static Listener listener = new Listener() { public void handleEvent(Event e) {</p>
<p>System.out.println(e.toString());</p>
<p>}</p>
<p>};</p>
<p>void</p>
<p>addItem(Menu bar, Iterator&lt;String&gt; it, MenuItem mItem) {</p>
<p>MenuItem item = new MenuItem(mItem.getMenu(),SWT.PUSH); item.addListener(SWT.Selection, listener); item.setText(it.next());</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>SWTConsole.run(new Menus(), 600, 200);</p>
<p>}</p>
<p>} ///:~</p>
<p>A Menu must be placed on a Shell, and Composite allows you to fetch its shell with getShell( ). TextFile is from net.mindview.util and has been described earlier in the book; here a TreeSet is filled with words so they will appear in sorted order. The initial elements are numbers, which are discarded. Using the stream of words, the top-level menus on the menu bar are named, then the submenus are created and filled with words until there are no more words.</p>
<p>In response to selecting one of the menu items, the Listener simply prints the event so you can see what kind of information it contains. When you run the program, you’ll see that part of the information includes the label on the menu, so you can base the menu response on that—or you can provide a different listener for each menu (which is the safer approach, for internationalization).</p>
<subtitle>Tabbed panes, buttons, and events</subtitle>
<p>SWT has a rich set of controls, which they call widgets. Look at the documentation for org.eclipse.swt.widgets to see the basic ones, and org.eclipse.swt.custom to see</p>
<p>fancier ones.</p>
<p>To demonstrate a few of the basic widgets, this example places a number of sub-examples inside tabbed panes. You’ll also see how to create Composites (roughly the same as Swing JPanels) in order to put items within items.</p>
<p>//: swt/TabbedPane.java</p>
<p>// Placing SWT components in tabbed panes. import swt.util.*; import org.eclipse.swt.*; import org.eclipse.swt.widgets.*; import org.eclipse.swt.events.*; import org.eclipse.swt.graphics.*; import org.eclipse.swt.layout.*; import org.eclipse.swt.browser.*;</p>
<p>public class TabbedPane implements SWTApplication { private static TabFolder folder; private static Shell shell;</p>
<p>public void createContents(Composite parent) { shell = parent.getShell(); parent.setLayout(new FillLayout()); folder = new TabFolder(shell, SWT.BORDER); labelTab(); directoryDialogTab(); buttonTab(); sliderTab(); scribbleTab(); browserTab();</p>
<p>}</p>
<p>public static void labelTab() {</p>
<p>TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText(&quot;A Label&quot;); // Text on the tab tab.setToolTipText(&quot;A simple label&quot;);</p>
<p>Label label = new Label(folder, SWT.CENTER); label.setText(&quot;Label text&quot;); tab.setControl(label);</p>
<p>}</p>
<p>public static void directoryDialogTab() {</p>
<p>TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText(&quot;Directory Dialog&quot;); tab.setToolTipText(&quot;Select a directory&quot;); final Button b = new Button(folder, SWT.PUSH); b.setText(&quot;Select a Directory&quot;); b.addListener(SWT.MouseDown, new Listener() { public void handleEvent(Event e) {</p>
<p>DirectoryDialog dd = new DirectoryDialog(shell);</p>
<p>String path = dd.open(); if(path != null) b.setText(path);</p>
<p>}</p>
<p>});</p>
<p>tab.setControl(b);</p>
<p>}</p>
<p>public static void buttonTab() {</p>
<p>TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText(&quot;Buttons&quot;);</p>
<p>tab.setToolTipText(&quot;Different kinds of Buttons&quot;);</p>
<p>Composite composite = new Composite(folder, SWT.NONE); composite.setLayout(new GridLayout(4, true)); for(int dir : new int[]{</p>
<p>SWT.UP, SWT.RIGHT, SWT.LEFT, SWT.DOWN }) {</p>
<p>Button b = new Button(composite, SWT.ARROW | dir); b.addListener(SWT.MouseDown, listener);</p>
<p>newButton(composite, SWT.CHECK, &quot;Check button&quot;); newButton(composite, SWT.PUSH, &quot;Push button&quot;); newButton(composite, SWT.RADIO, &quot;Radio button&quot;); newButton(composite, SWT.TOGGLE, &quot;Toggle button&quot;); newButton(composite, SWT.FLAT, &quot;Flat button&quot;); tab.setControl(composite);</p>
<p>}</p>
<p>private static Listener listener = new Listener() { public void handleEvent(Event e) {</p>
<p>MessageBox m = new MessageBox(shell, SWT.OK);</p>
<p>m.setMessage(e.toString());</p>
<p>m.open();</p>
<p>}</p>
<p>};</p>
<p>private static void newButton(Composite composite, int type, String label) {</p>
<p>Button b = new Button(composite, type); b.setText(label);</p>
<p>b.addListener(SWT.MouseDown, listener);</p>
<p>}</p>
<p>public static void sliderTab() {</p>
<p>TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText(&quot;Sliders and Progress bars&quot;); tab.setToolTipText(&quot;Tied Slider to ProgressBar&quot;); Composite composite = new Composite(folder, SWT.NONE); composite.setLayout(new GridLayout(2, true)); final Slider slider =</p>
<p>new Slider(composite, SWT.HORIZONTAL); final ProgressBar progress =</p>
<p>new ProgressBar(composite, SWT.HORIZONTAL); slider.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent event) { progress.setSelection(slider.getSelection());</p>
<p>}</p>
<p>});</p>
<p>tab.setControl(composite);</p>
<p>}</p>
<p>public static void scribbleTab() {</p>
<p>TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText(&quot;Scribble&quot;);</p>
<p>tab.setToolTipText(&quot;Simple graphics: drawing&quot;); final Canvas canvas = new Canvas(folder, SWT.NONE); ScribbleMouseListener sml= new ScribbleMouseListener(); canvas.addMouseListener(sml); canvas.addMouseMoveListener(sml); tab.setControl(canvas);</p>
<p>}</p>
<p>private static class ScribbleMouseListener</p>
<p>extends MouseAdapter implements MouseMoveListener { private Point p = new Point(0, 0); public void mouseMove(MouseEvent e) { if((e.stateMask &amp; SWT.BUTTON1) == 0)</p>
<p>return;</p>
<p>GC gc = new GC((Canvas)e.widget); gc.drawLine(p.x, p.y, e.x, e.y); gc.dispose(); updatePoint(e);</p>
<p>}</p>
<p>}</p>
<p>public void mouseDown(MouseEvent e) { updatePoint(e) private void updatePoint(MouseEvent e) {</p>
<p>p.x = e.x;</p>
<p>p.y = e.y;</p>
<p>}</p>
<p>public static void browserTab() {</p>
<p>TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText(&quot;A Browser&quot;); tab.setToolTipText(&quot;A Web browser&quot;);</p>
<p>Browser browser = null; try {</p>
<p>browser = new Browser(folder, SWT.NONE);</p>
<p>} catch(SWTError e) {</p>
<p>Label label = new Label(folder, SWT.BORDER); label.setText(&quot;Could not initialize browser&quot;); tab.setControl(label);</p>
<p>}</p>
<p>if(browser != null) {</p>
<p>browser.setUrl(&quot;<a l:href="http://www.mindview.net">http://www.mindview.net</a>&quot;);</p>
<p>tab.setControl(browser);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>SWTConsole.run(new TabbedPane(), 800, 600);</p>
<p>}</p>
<p>} ///:~</p>
<p>Here, createContents( ) sets the layout and then calls the methods that each create a different tab. The text on each tab is set with setText( ) (you can also create buttons and graphics on a tab), and each one also sets its tool tip text. At the end of each method, you’ll see a call to setControl( ), which places the control that the method created into the dialog space of that particular tab.</p>
<p>labelTab( ) demonstrates a simple text label. directoryDialogTab( ) holds a button which opens a standard DirectoryDialog object so the user can select a directory. The result is set as the button’s text.</p>
<p>buttonTab( ) shows the different basic buttons. sliderTab( ) repeats the Swing example from earlier in the chapter of tying a slider to a progress bar.</p>
<p>scribbleTab( ) is a fun example of graphics. A drawing program is produced from only a few lines of code.</p>
<p>Finally, browserTab( ) shows the power of the SWT Browser component—a full-featured Web browser in a single component.</p>
<subtitle>Graphics</subtitle>
<p>Here’s the Swing SineWave.java program translated to SWT:</p>
<p>//: swt/SineWave.java</p>
<p>// SWT translation of Swing SineWave.java.</p>
<p>import swt.util.*;</p>
<p>import org.eclipse.swt.*;</p>
<p>import org.eclipse.swt.widgets.*;</p>
<p>import org.eclipse.swt.events.*;</p>
<p>import org.eclipse.swt.layout.*;</p>
<p>class SineDraw extends Canvas {</p>
<p>private static final int SCALEFACTOR = 200; private int cycles; private int points;</p>
<p>private doublet] sines; private int[] pts;</p>
<p>public SineDraw(Composite parent, int style) { super(parent, style); addPaintListener(new PaintListener() { public void paintControl(PaintEvent e) { int maxWidth = getSize().x;</p>
<p>double hstep = (double)maxWidth / (double)points;</p>
<p>int maxHeight = getSize().y;</p>
<p>pts = new int[points];</p>
<p>for(int i = 0; i &lt; points; i++)</p>
<p>pts[i] = (int)((sines[i] * maxHeight / 2 * .95) + (maxHeight / 2)); e.gc.setForeground(</p>
<p>e.display.getSystemColor(SWT.COLOR_RED)); for(int i = 1; i &lt; points; i++) { int x1    =    (int)((i - 1)    *    hstep);</p>
<p>int x2    =    (int)(i    * hstep);</p>
<p>int y1    =    pts[i -    1];</p>
<p>int y2    =    pts[i];</p>
<p>e.gc.drawLine(x1, y1, x2, y2);</p>
<p>}</p>
<p>}</p>
<p>});</p>
<p>setCycles(5);</p>
<p>}</p>
<p>public void setCycles(int newCycles) { cycles = newCycles; points = SCALEFACTOR * cycles * 2; sines = new double[points]; for(int i = 0; i &lt; points; i++) {</p>
<p>double radians = (Math.PI / SCALEFACTOR) * i; sines[i] = Math.sin(radians);</p>
<p>}</p>
<p>redraw();</p>
<p>}</p>
<p>}</p>
<p>public class SineWave implements SWTApplication { private SineDraw sines; private Slider slider;</p>
<p>public void createContents(Composite parent) { parent.setLayout(new GridLayout(1, true)); sines = new SineDraw(parent, SWT.NONE); sines.setLayoutData(</p>
<p>new GridData(SWT.FILL, SWT.FILL, true, true)); sines.setFocus();</p>
<p>slider = new Slider(parent, SWT.HORIZONTAL); slider.setValues(5, 1, 30, 1, 1, 1); slider.setLayoutData(</p>
<p>new GridData(SWT.FILL, SWT.DEFAULT, true, false)); slider.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent event) { sines.setCycles(slider.getSelection());</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>public static void main(String[] args) { SWTConsole.run(new SineWave(), 700, 400);</p>
<p>}</p>
<p>} ///:~</p>
<p>Instead of JPanel, the basic drawing surface in SWT is Canvas.</p>
<p>If you compare this version of the program with the Swing version, you’ll see that SineDraw is virtually identical. In SWT, you get the graphics context gc from the event object that’s handed to the PaintListener, and in Swing the Graphics object is handed directly to the paintComponent( ) method. But the activities performed with the graphics object are the same, and setCycles( ) is identical.</p>
<p>createContents( ) requires a bit more code than the Swing version, to lay things out and set up the slider and its listener, but again, the basic activities are roughly the same.</p>
<subtitle>Concurrency in SWT</subtitle>
<p>Although AWT/Swing is single-threaded, it’s easily possible to violate that singlethreadedness in a way that produces a non-deterministic program. Basically, you don’t want to have multiple threads writing to the display because they will write over each other in surprising ways.</p>
<p>SWT doesn’t allow this—it throws an exception if you try to write to the display using more than one thread. This will prevent a novice programmer from accidentally making this mistake and introducing hard-to-find bugs into a program.</p>
<p>Here is the translation of the Swing ColorBoxes.java program in SWT:</p>
<p>//: swt/ColorBoxes.java</p>
<p>// SWT translation of Swing ColorBoxes.java.</p>
<p>import swt.util.*;</p>
<p>import org.eclipse.swt.*;</p>
<p>import org.eclipse.swt.widgets.*;</p>
<p>import org.eclipse.swt.events.*;</p>
<p>import org.eclipse.swt.graphics.*;</p>
<p>import org.eclipse.swt.layout.*;</p>
<p>import java.util.concurrent.*;</p>
<p>import java.util.*;</p>
<p>import net.mindview.util.*;</p>
<p>class CBox extends Canvas implements Runnable { class CBoxPaintListener implements PaintListener { public void paintControl(PaintEvent e) {</p>
<p>Color color = new Color(e.display, cColor); e.gc.setBackground(color);</p>
<p>Point size = getSize();</p>
<p>e.gc.fillRectangle(0, 0, size.x, size.y); color.dispose();</p>
<p>}</p>
<p>}</p>
<p>private static Random rand = new Random(); private static RGB newColor() { return new RGB(rand.nextInt(255),</p>
<p>rand.nextInt(255), rand.nextInt(255));</p>
<p>}</p>
<p>private int pause; private RGB cColor = newColor(); public CBox(Composite parent, int pause) { super(parent, SWT.NONE); this.pause = pause;</p>
<p>addPaintListener(new CBoxPaintListener());</p>
<p>}</p>
<p>public void run() { try {</p>
<p>while(!Thread.interrupted()) { cColor = newColor();</p>
<p>getDisplay().asyncExec(new Runnable() { public void run() {</p>
<p>try { redraw(); } catch(SWTException e) {}</p>
<p>// SWTException is OK when the parent // is terminated from under us.</p>
<p>}</p>
<p>});</p>
<p>TimeUnit.MILLISECONDS.sleep(pause);</p>
<p>}</p>
<p>} catch(InterruptedException e) {</p>
<p>// Acceptable way to exit } catch(SWTException e) {</p>
<p>// Acceptable way to exit: our parent // was terminated from under us.</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class ColorBoxes implements SWTApplication { private int grid = 12; private int pause = 50;</p>
<p>public void createContents(Composite parent) {</p>
<p>GridLayout gridLayout = new GridLayout(grid, true); gridLayout.horizontalSpacing = 0; gridLayout.verticalSpacing = 0; parent.setLayout(gridLayout);</p>
<p>ExecutorService exec = new DaemonThreadPoolExecutor(); for(int i = 0; i &lt; (grid * grid); i++) { final CBox cb = new CBox(parent, pause); cb.setLayoutData(new GridData(GridData.FILL_BOTH)); exec.execute(cb);</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>ColorBoxes boxes = new ColorBoxes(); if(args.length &gt; 0)</p>
<p>boxes.grid = new Integer(args[0]); if(args.length &gt; 1)</p>
<p>boxes.pause = new Integer(args[1]);</p>
<p>SWTConsole.run(boxes, 500, 400);</p>
<p>}</p>
<p>} ///:~</p>
<p>As in the previous example, painting is controlled by creating a PaintListener with a paintControl( ) method that is called when the SWT thread is ready to paint your component. The PaintListener is registered in the CBox constructor.</p>
<p>What’s notably different in this version of CBox is the run( ) method, which cannot just call redraw( ) directly but must submit the redraw( ) to the asyncExec( ) method on the Display object, which is roughly the same as SwingUtilities.invokeLater( ). If you replace this with a direct call to redraw( ), you’ll see that the program just stops.</p>
<p>When running the program, you will see little visual artifacts—horizontal lines occasionally running through a box. This is because SWT is not doublebuffered by default, while Swing is. Try running the Swing version side by side with the SWT version and you’ll see it more clearly. You can write code to double-buffer SWT; you’ll find examples on the <a l:href="http://www.eclipse.org">www.eclipse.org</a> Web site.</p>
<p>Exercise 42: (4) Modify swt/ColorBoxes.java so that it begins by sprinkling points (&quot;stars&quot;) across the canvas, then randomly changes the colors of those &quot;stars.&quot;</p>
<subtitle>SWT vs. Swing?</subtitle>
<p>It’s hard to get a complete picture from such a short introduction, but you should at least start to see that SWT, in many situations, can be a more straightforward way to write code than Swing. However, GUI programming in SWT can still be complex, so your motivation for using SWT should probably be, first, to give the user a more transparent experience when using your application (because the application looks/feels like the other applications on that platform), and second, if the responsiveness provided by SWT is important. Otherwise,</p>
<p>Swing may be an appropriate choice.</p>
<p>Exercise 43: (6) Choose any one of the Swing examples that wasn’t translated in this section, and translate it to SWT. (Note: This makes a good homework exercise for a class, since the solutions are not in the solution guide.)</p>
</section>
<section>
<title>
<p>Summary</p></title><empty-line/>
<p>The Java GUI libraries have seen some dramatic changes during the lifetime of the language. The Java 1.0 AWT was roundly criticized as being a poor design, and while it allowed you to create portable programs, the resulting GUI was &quot;equally mediocre on all platforms.&quot; It was also limiting, awkward, and unpleasant to use compared with the native application development tools available for various platforms.</p>
<p>When Java 1.1 introduced the new event model and JavaBeans, the stage was set—now it was possible to create GUI components that could easily be dragged and dropped inside a visual IDE. In addition, the design of the event model and JavaBeans clearly shows strong consideration for ease of programming and maintainable code (something that was not evident in the 1.0 AWT). But it wasn’t until the JFC/Swing classes appeared that the transition was complete. With the Swing components, cross-platform GUI programming can be a civilized experience.</p>
<p>IDEs are where the real revolution lies. If you want a commercial IDE for a proprietary language to get better, you must cross your fingers and hope that the vendor will give you what you want. But Java is an open environment, so not only does it allow for competing IDEs, it encourages them. And for these tools to be taken seriously, they must support JavaBeans. This means a leveled playing field; if a better IDE comes along, you’re not tied to the one you’ve been using. You can pick up and move to the new one and increase your productivity. This kind of competitive environment for GUI IDEs has not been seen before, and the resulting marketplace can generate very positive results for programmer productivity.</p>
<p>This chapter was only meant to give you an introduction to the power of GUI programming and to get you started so that you can see how relatively simple it is to feel your way through the libraries. What you’ve seen so far will probably suffice for a good portion of your UI design needs. However, there’s a lot more to Swing, SWT and Flash/Flex; these are meant to be fully powered UI design toolkits. There’s probably a way to accomplish just about everything you can imagine.</p>
<subtitle>Resources</subtitle>
<p>Ben Galbraith’s online presentations at <a l:href="http://www.galbraiths.org/presentations">www.galbraiths.org/presentations</a> provide some nice coverage of both Swing and SWT.</p>
<p>Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>A: Supplements</p></title><empty-line/>
<p>There are a number of supplements to this book, including the items, seminars, and services available through the MindView Web site.</p>
<p>This appendix describes these supplements so that you can decide if they will be helpful to you.</p>
<p>Note that although the seminars are often held as public events, they may be given as private, inhouse seminars at your location.</p>
<section>
<title>
<p>Downloadable supplements</p></title><empty-line/>
<p>The code for this book is available for download from <a l:href="http://www.MindView.net">www.MindView.net</a>. This includes the Ant build files and other support files necessary to do a successful build and execution of all the examples in the book.</p>
<p>In addition, a few portions of the book were moved to electronic form. The subjects include:</p>
<p>•    Cloning Objects</p>
<p>•    Passing &amp; Returning Objects</p>
<p>•    Analysis and Design</p>
<p>rd</p>
<p>•    Portions of other chapters from Thinking in Java, 3 Edition that were not relevant enough to put in the print version of the 4<sup>th</sup> edition of this book.</p>
</section>
<section>
<title>
<p>Thinking in C: Foundations for Java</p></title><empty-line/>
<p>At <a l:href="http://www.MindView.net">www.MindView.net</a>, you will find the Thinking in C seminar as a free download. This presentation, created by Chuck Allison and developed by MindView, is a multimedia Flash course which gives you an introduction to the C syntax, operators and functions that Java syntax is based upon.</p>
<p>Note that you must have the Flash Player from <a l:href="http://www.Macromedia.com">www.Macromedia.com</a> installed on your system in order to play Thinking in C.</p>
</section>
<section>
<title>
<p>Thinking in Java seminar</p></title><empty-line/>
<p>My company, MindView, Inc., provides five-day, hands-on, public and in-house training seminars based on the material in this book. Formerly called the Hands-On Java seminar, this is our main introductory seminar that provides the foundation for our more advanced seminars. Selected material from each chapter represents a lesson, which is followed by a monitored exercise period so that each student receives personal attention. You can find schedule and location information, testimonials, and details at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
<section>
<title>
<p>Hands-On Java seminar-on-CD</p></title><empty-line/>
<p>The Hands-On Java CD contains an extended version of the material from the Thinking in Java seminar and is based on this book. It provides at least some of the experience of the live seminar without the travel and expense. There is an audio lecture and slides corresponding to every chapter in the book. I created the seminar and I narrate the material on the CD. The material is in Flash format, so it should run on any platform that supports the Flash Player. The Hands-On Java CD is for sale at <a l:href="http://www.MindView.net">www.MindView.net</a>, where you can find trial demos of the product.</p>
</section>
<section>
<title>
<p>Thinking in Objects seminar</p></title><empty-line/>
<p>This seminar introduces the ideas of object-oriented programming from the standpoint of the designer. It explores the process of developing and building a system, primarily focusing on socalled “Agile Methods” or “Lightweight Methodologies,” especially Extreme Programming (XP). I introduce methodologies in general, small tools like the “index-card” planning techniques described in Planning Extreme Programming by Beck and Fowler (Addison-Wesley, 2001), CRC cards for object design, pair programming, iteration planning, unit testing, automated building, source-code control, and similar topics. The course includes an XP project that will be developed throughout the week.</p>
<p>If you are starting a project and would like to begin using object-oriented design techniques, we can use your project as the example and produce a first-cut design by the end of the week.</p>
<p>Visit <a l:href="http://www.MindView.net">www.MindView.net</a> for schedule and location information, testimonials, and details.</p>
</section>
<section>
<title>
<p>Thinking in Enterprise Java</p></title><empty-line/>
<p>This book has been spawned from some of the more advanced chapters in earlier editions of Thinking in Java. This book isn’t a second volume of Thinking in Java, but rather focused coverage of the more advanced topic of enterprise programming. It is currently available (in some form, likely still in development) as a free download from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>Because it is a separate book, it can expand to fit the necessary topics. The goal, like Thinking in Java, is to produce a very understandable introduction to the basics of the enterprise programming technologies so that the reader is prepared for more advanced coverage of those topics.</p>
<p>The list of topics will include, but is not limited to:</p>
<p>•    Introduction to Enterprise Programming</p>
<p>•    Network Programming with Sockets and Channels</p>
<p>•    Remote Method Invocation (RMI)</p>
<p>•    Connecting to Databases</p>
<p>•    Naming and Directory Services</p>
<p>•    Servlets</p>
<p>•    Java Server Pages</p>
<p>•    Tags, JSP Fragments and Expression Language</p>
<p>•    Automating the Creation of User Interfaces</p>
<p>•    Enterprise JavaBeans</p>
<p>•    XML</p>
<p>•    Web Services</p>
<p>•    Automated Testing</p>
<p>You can find the current state of Thinking in Enterprise Java at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
<section>
<title>
<p>Thinking in Patterns (with Java)</p></title><empty-line/>
<p>One of the most important steps forward in object-oriented design is the “design patterns” movement, chronicled in Design Patterns, by Gamma, Helm, Johnson &amp; Vlissides (Addison-Wesley, 1995). That book shows 23 general classes of problems and their solutions, primarily written in C++. The Design Patterns book is a source of what has now become an essential, almost mandatory, vocabulary for OOP programmers. Thinking in Patterns introduces the basic concepts of design patterns along with examples in Java. The book is not intended to be a simple translation of Design Patterns, but rather a new perspective with a Java mindset. It is not limited to the traditional 23 patterns, but also includes other ideas and problemsolving techniques as appropriate.</p>
<p>This book began as the last chapter in Thinking in Java, 1<sup>st</sup> Edition, and as ideas continued to develop, it became clear that it needed to be its own book. At the time of this writing, it is still in development, but the material has been worked and reworked through numerous presentations of the Objects &amp; Patterns seminar (which has now been split into the Designing Objects &amp; Systems and Thinking in Patterns seminars).</p>
<p>You can find out more about this book at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
<section>
<title>
<p>Thinking in Patterns seminar</p></title><empty-line/>
<p>This seminar has evolved from the Objects &amp; Patterns seminar that Bill Venners and I gave for the past several years. That seminar grew too full, so we’ve split it into two seminars: this one, and the Designing Objects &amp; Systems seminar, described earlier in this appendix.</p>
<p>The seminar strongly follows the material and presentation in the Thinking in Patterns book, so the best way to find out what’s in the seminar is to learn about the book from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>Much of the presentation emphasizes the design evolution process, starting with an initial solution and moving through the logic and process of evolving the solution to more appropriate designs. The last project shown (a trash recycling simulation) has evolved over time, and you can look at that evolution as a prototype for the way your own design can start as an adequate solution to a particular problem and evolve into a flexible approach to a class of problems.</p>
<p>This seminar will help you:</p>
<p>•    Dramatically increase the flexibility of your designs.</p>
<p>•    Build in extensibility and reusability.</p>
<p>•    Create denser communications about designs using the language of patterns.</p>
<p>Following each lecture there will be a set of patterns exercises for you to solve, where you are guided to write code to apply particular patterns to the solution of programming problems.</p>
<p>Visit <a l:href="http://www.MindView.net">www.MindView.net</a> for schedule and location information, testimonials, and details.</p>
</section>
<section>
<title>
<p>Design consulting and reviews</p></title><empty-line/>
<p>My company also provides consulting, mentoring, design reviews and implementation reviews to help guide your project through its development cycle, including your company’s first Java project. Visit <a l:href="http://www.MindView.net">www.MindView.net</a> for availability and details.</p>
</section>
</section>
<section>
<title>
<p>B: Resources</p></title><empty-line/>
<section>
<title>
<p>Software</p></title><empty-line/>
<p>The JDK from <a l:href="http://java.sun.com">http://java.sun.com</a>. Even if you choose to use a third-party development environment, it’s always a good idea to have the JDK on hand in case you come up against what might be a compiler error. The JDK is the touchstone, and if there is a bug in it, chances are it will be well known.</p>
<p>The JDK documentation from <a l:href="http://java.sun.com">http://java.sun.com</a>, in HTML. I have never found a reference book on the standard Java libraries that wasn’t out of date or missing information. Although the JDK documentation from Sun is shot through with small bugs and is sometimes unusably terse, all the classes and methods are at least there. Sometimes people are initially uncomfortable using an online resource rather than a printed book, but it’s worth your while to get over this and open the HTML docs so you can at least get the big picture. If you can’t figure it out at that point, then reach for the printed books.</p>
</section>
<section>
<title>
<p>Editors &amp; IDEs</p></title><empty-line/>
<p>There is a healthy competition in this arena. Many offerings are free (and the non-free ones usually have free trials), so your best bet is to simply try them out yourself and see which one fits your needs. Here are a few:</p>
<p>JEdit, Slava Pestov’s free editor, is written in Java, so you get the bonus of seeing a desktop Java application in action. This editor is based heavily on plug-ins, many of which have been written by the active community. Download from <a l:href="http://www.jedit.org">www.jedit.org</a>.</p>
<p>NetBeans, a free IDE from Sun, at <a l:href="http://www.netbeans.org">www.netbeans.org</a>. Designed for drag-and-drop GUI building, code editing, debugging, and more.</p>
<p>Eclipse, an open-source project backed by IBM, among others. The Eclipse platform is also designed to be an extensible foundation, so you can build your own standalone applications on top of Eclipse. This project created the SWT described in the Graphical User Interfaces chapter. Download from <a l:href="http://www.Eclipse.org">www.Eclipse.org</a>.</p>
<p>IntelliJ IDEA, the payware favorite of a large faction of Java programmers, many of whom claim that IDEA is always a step or two ahead of Eclipse, possibly because IntelliJ is not creating both an IDE and a development platform, but just sticking to creating an IDE. You can download a free trial from <a l:href="http://www.jetbrains.com">www.jetbrains.com</a>.</p>
</section>
<section>
<title>
<p>Books</p></title><empty-line/>
<p>Core Java™ 2, 7<sup>th</sup> Edition, Volumes I &amp; II, by Horstmann &amp; Cornell (Prentice Hall, 2005). Huge, comprehensive, and the first place I go when I’m hunting for answers. The book I recommend when you’ve completed Thinking in Java and need to cast a bigger net.</p>
<p>The Java™ Class Libraries: An Annotated Reference, by Patrick Chan and Rosanna Lee (Addison-Wesley, 1997). Although sadly out of date, this is what the JDK reference should have been: enough description to make it usable. One of the technical reviewers for Thinking in Java said, “If I had only one Java book, this would be it (well, in addition to yours, of course).” I’m not as thrilled with it as he is. It’s big, it’s expensive, and the quality of the examples doesn’t satisfy me. But it’s a place to look when you’re stuck, and it seems to have more depth (and sheer size) than most alternatives. However, Core Java 2 has more recent coverage of many of the library components.</p>
<p>Java Network Programming, 2<sup>nd</sup> Edition, by Elliotte Rusty Harold (O’Reilly, 2000). I didn’t begin to understand Java networking (or networking in general, for that matter) until I found this book. I also find his Web site, Cafe au Lait, to be a stimulating, opinionated, and upto-date perspective on Java developments, unencumbered by allegiances to any vendors. His regular updates keep up with fast-changing news about Java. See <a l:href="http://www.cafeaulait.org">www.cafeaulait.org</a>.</p>
<p>Design Patterns, by Gamma, Helm, Johnson and Vlissides (Addison-Wesley, 1995). The seminal book that started the patterns movement in programming, mentioned numerous places in this book.</p>
<p>Refactoring to Patterns, by Joshua Kerievsky (Addison-Wesley, 2005). Marries refactoring and design patterns. The most valuable thing about this book is that it shows you how to evolve a design by folding in patterns as they are needed.</p>
<p>The Art of UNIX Programming, by Eric Raymond (Addison-Wesley, 2004). Although Java is a cross-platform language, the prevalence of Java on the server has made knowledge of Unix/Linux important. Eric’s book is an excellent introduction to the history and philosophy of this operating system, and is a fascinating read if you just want to understand some of the roots of computing.</p>
<subtitle>Analysis &amp; design</subtitle>
<p>Extreme Programming Explained, 2<sup>nd</sup> Edition, by Kent Beck with Cynthia Andres. (Addison-Wesley, 2005). I’ve always felt that there might be a much different, much better program development process, and I think XP comes pretty darn close. The only book that has had a similar impact on me was Peopleware (described later), which talks primarily about the environment and dealing with corporate culture. Extreme Programming Explained talks about programming and turns most things, even recent “findings,” on their ear. They even go so far as to say that pictures are OK as long as you don’t spend too much time on them and are willing to throw them away. (You’ll notice that the book does not have the “UML stamp of approval” on its cover.) I could see deciding to work for a company based solely on whether they used XP. Small book, small chapters, effortless to read, exciting to think about. You start imagining yourself working in such an atmosphere, and it brings visions of a whole new world.</p>
<p>UML Distilled, 2<sup>nd</sup> Edition, by Martin Fowler (Addison-Wesley, 2000). When you first encounter UML, it is daunting because there are so many diagrams and details. According to Fowler, most of this stuff is unnecessary, so he cuts through to the essentials. For most projects, you only need to know a few diagramming tools, and Fowler’s goal is to come up with a good design rather than worry about all the artifacts of getting there. In fact, the first half of the book is all that most people will need. A nice, thin, readable book; the first one you should get if you need to understand UML.</p>
<p>Domain-Driven Design, by Eric Evans (Addison-Wesley, 2004). This book focuses on the domain model as the primary artifact of the design process. I have found this to be an important shift in emphasis that helps keep designers at the right level of abstraction.</p>
<p>The Unified Software Development Process, by Ivar Jacobsen, Grady Booch, and James Rumbaugh (Addison-Wesley, 1999). I went in fully prepared to dislike this book. It seemed to have all the makings of a boring college text. I was pleasantly surprised—although there are a few parts that have explanations that seem as if those concepts aren’t clear to the authors. The bulk of the book is not only clear, but enjoyable. And best of all, the process makes a lot of practical sense. It’s not Extreme Programming (and does not have their clarity about testing), but it’s also part of the UML juggernaut; even if you can’t get XP through the door, most people have climbed aboard the “UML is good” bandwagon (regardless of their actual level of experience with it), so you can probably get it adopted. I think this book should be the flagship of UML, and the one you can read after Fowler’s UML Distilled when you want more detail.</p>
<p>Before you choose any method, it’s helpful to gain perspective from those who are not trying to sell you one. It’s easy to adopt a method without really understanding what you want out of it or what it will do for you. Others are using it, which seems a compelling reason.</p>
<p>However, humans have a strange little psychological quirk: If they want to believe something will solve their problems, they’ll try it. (This is experimentation, which is good.) But if it doesn’t solve their problems, they may redouble their efforts and begin to announce loudly what a great thing they’ve discovered. (This is denial, which is not good.) The assumption here may be that if you can get other people in the same boat, you won’t be lonely, even if it’s going nowhere (or sinking).</p>
<p>This is not to suggest that all methodologies go nowhere, but that you should be armed to the teeth with mental tools that help you stay in experimentation mode (“It’s not working; let’s try something else”) and out of denial mode (“No, that’s not really a problem. Everything’s wonderful, we don’t need to change”). I think the following books, read before you choose a method, will provide you with these tools.</p>
<p>Software Creativity, by Robert L. Glass (Prentice Hall, 1995). This is the best book I’ve seen that discusses perspective on the whole methodology issue. It’s a collection of short essays and papers that Glass has written and sometimes acquired (P.J. Plauger is one contributor), reflecting his many years of thinking and study on the subject. They’re entertaining and only long enough to say what’s necessary; he doesn’t ramble and bore you. He’s not just blowing smoke, either; there are hundreds of references to other papers and studies. All programmers and managers should read this book before wading into the methodology mire.</p>
<p>Software Runaways: Monumental Software Disasters, by Robert L. Glass (Prentice Hall, 1998). The great thing about this book is that it brings to the forefront what we don’t talk about: the number of projects that not only fail, but fail spectacularly. I find that most of us still think, “That can’t happen to me” (or “That can’t happen again”), and I think this puts us at a disadvantage. By keeping in mind that things can always go wrong, you’re in a much better position to make them go right.</p>
<p>Peopleware, 2<sup>nd</sup> Edition, by Tom DeMarco and Timothy Lister (Dorset House, 1999). You must read this book. It’s not only fun, it rocks your world and destroys your assumptions. Although DeMarco and Lister have backgrounds in software development, this book is about projects and teams in general. But the focus is on the people and their needs, rather than the technology and its needs. They talk about creating an environment where people will be happy and productive, rather than deciding what rules those people should follow to be adequate components of a machine. This latter attitude, I think, is the biggest contributor to programmers smiling and nodding when XYZ method is adopted, and then quietly doing whatever they’ve always done.</p>
<p>Secrets of Consulting: A Guide to Giving &amp; Getting Advice Successfully, by</p>
<p>Gerald M. Weinberg (Dorset House, 1985). A superb book, one of my all-time favorites. It’s perfect if you are trying to be a consultant or if you’re using consultants and trying to do a better job. Short chapters, filled with stories and anecdotes that teach you how to get to the core of the issue with minimal struggle. Also see More Secrets of Consulting, published in 2002, or most any other Weinberg book.</p>
<p>Complexity, by M. Mitchell Waldrop (Simon &amp; Schuster, 1992). This chronicles the coming together in Santa Fe, New Mexico, of a group of scientists from different disciplines to discuss real problems that their individual disciplines couldn’t solve (the stock market in economics, the initial formation of life in biology, why people do what they do in sociology, etc.). By crossing physics, economics, chemistry, math, computer science, sociology, and others, a multidisciplinary approach to these problems is developing. But more important, a different way of thinking about these ultra-complex problems is emerging: away from mathematical determinism and the illusion that you can write an equation that predicts all behavior, and toward first observing and looking for a pattern and trying to emulate that pattern by any means possible. (The book chronicles, for example, the emergence of genetic algorithms.) This kind of thinking, I believe, is useful as we observe ways to manage more and more complex software projects.</p>
<subtitle>Python</subtitle>
<p>Learning Python, 2<sup>nd</sup> Edition, by Mark Lutz and David Ascher (O’Reilly, 2003). A nice programmer’s introduction to my favorite language, an excellent companion to Java. The book includes an introduction to Jython, which allows you to combine Java and Python in a single program (the Jython interpreter is compiled to pure Java bytecodes, so there is nothing special you need to add to accomplish this). This language union promises great possibilities.</p>
<subtitle>My own list of books</subtitle>
<p>Not all of these are currently available, but some can be found through used-book outlets.</p>
<p>Computer Interfacing with Pascal &amp; C (self-published under the Eisys imprint, 1988. Available for sale only from <a l:href="http://www.Mindyiew.net">www.Mindyiew.net</a>). An introduction to electronics from back when CP/M was still king and DOS was an upstart. I used high-level languages and often the parallel port of the computer to drive various electronic projects. Adapted from my columns in the first and best magazine I wrote for, Micro Cornucopia. Alas, Micro C was lost long before the Internet appeared. Creating this book was an extremely satisfying publishing experience.</p>
<p>Using C++ (Osborne/McGraw-Hill, 1989). One of the first books out on C++. This is out of print and replaced by its 2<sup>nd</sup> edition, the renamed C++ Inside &amp; Out.</p>
<p>C++ Inside &amp; Out (Osborne/McGraw-Hill, 1993). As noted, actually the 2<sup>nd</sup> edition of Using C++. The C++ in this book is reasonably accurate, but it’s circa 1992 and Thinking in C++ is intended to replace it. You can find out more about this book and download the source code at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>Thinking in C++, 1<sup>st</sup> Edition (Prentice Hall, 1995). This won the Software Development Magazine Jolt Award for best book of the year.</p>
<p>Thinking in C++, 2<sup>nd</sup> Edition, Volume 1 (Prentice Hall, 2000). Downloadable from <a l:href="http://www.MindView.net">www.MindView.net</a>. Updated to follow the finalized language standard.</p>
<p>Thinking in C++, 2<sup>nd</sup> Edition, Volume 2, coauthored with Chuck Allison (Prentice Hall, 2003). Downloadable from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>Black Belt C++: The Master’s Collection, Bruce Eckel, editor (M&amp;T Books, 1994). Out of print. A collection of chapters by various C++ luminaries based on their presentations in the C++ track at the Software Development Conference, which I chaired. The cover on this book stimulated me to gain control over all future cover designs.</p>
<p>Thinking in Java, 1<sup>st</sup> Edition (Prentice Hall, 1998). The 1<sup>st</sup> edition of this book won the Software Development Magazine Productivity Award, the Java Developer’s Journal Editor’s</p>
<p>Choice Award, and the JavaWorld Reader’s Choice Award for best book. Downloadable from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>Thinking in Java, 2<sup>nd</sup> Edition (Prentice Hall, 2000). This edition won the JavaWorld Editor’s Choice Award for best book. Downloadable from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
<p>Thinking in Java, 3<sup>rd</sup> Edition, (Prentice Hall, 2003). This edition won the Software Development Magazine Jolt Award for best book of the year, along with other awards listed on the back cover. Downloadable from <a l:href="http://www.MindView.net">www.MindView.net</a>.</p>
</section>
</section>
<section>
<title>
<p>Index</p></title><empty-line/>
<p>Please note that some names will be duplicated in capitalized form. Following Java style, the capitalized names refer to Java classes, while lowercase names refer to a general concept.</p>
<p>i    *</p>
<p>! ■ 71    <sup>A</sup> ■ 76</p>
<p>!= • 70    <sup>A</sup>= • <sup>76</sup></p>
<table>
<tr><td>&amp;&amp; ■ 76 &amp;&amp; ■ 71 &amp;= • 76</td><td>1I    ■ 76II    ■ 71| = • 76</td></tr>
<tr><td>■</td><td>+</td></tr>
<tr><td>.NET ■ 37 .new syntax ■ 247 .this syntax • 246</td><td>+ ■ 69; String conversion with operator + ■ 64, 81, 356 &lt;</td></tr>
<tr><td>@</td><td>&lt; ■ 70 &lt;&lt; ■ 76</td></tr>
<tr><td>@ symbol, for annotations ■ 761</td><td>&lt;&lt;= ■ 77</td></tr>
<tr><td>@author ■ 58@Deprecated, annotation ■ 761 @deprecated, Javadoc tag ■ 58</td><td>OIIV</td></tr>
<tr><td>@docRoot ■ 57 @inheritDoc ■ 57</td><td></td></tr>
<tr><td>@interface, and extends keyword ■ 769 @link ■ 57 @Override ■ 761</td><td>== ■ 70</td></tr>
<tr><td>@param ■ 58 @Retention ■ 762 @return ■ 58</td><td>&gt;</td></tr>
<tr><td>@see ■ 57</td><td>V0</td></tr>
<tr><td>@since ■ 58</td><td>&gt;= ■ 70</td></tr>
<tr><td>@SuppressWarnings ■ 761</td><td>&gt;&gt; ■ 76</td></tr>
<tr><td>@Target ■ 762 @Test ■ 762 @Test, for @Unit ■ 778</td><td>IIA , A <sup>1</sup></td></tr>
<tr><td>@TestObjectCleanup, @Unit tag ■ 785 @TestObjectCreate, for @Unit ■ 782</td><td>A</td></tr>
<tr><td>@throws ■ 58</td><td>abstract: class ■ 219; inheriting from abstract classes</td></tr>
<tr><td>@Unit ■ 778; using ■ 778</td><td>■ 220; keyword ■ 220; vs. interface ■ 231</td></tr>
<tr><td rowspan="2">@version • 57 [</td><td>Abstract Window Toolkit (AWT) ■ 937 AbstractButton ■ 958 abstraction ■ 15</td></tr>
<tr><td>AbstractSequentialList ■ 616 AbstractSet ■ 568</td></tr>
<tr><td>[ ], indexing operator ■ 134</td><td>access: class ■ 159; control ■ 145, 162; control, violating with reflection ■ 432; inner classes &amp; access rights -245; package access and friendly ■ 153; specifiers ■ 20, 145, 153; within a directory, via the default package ■ 155</td></tr>
</table>
<p>action command • 976 ActionEvent • 977, 1011 ActionListener • 946 ActionScript, for Macromedia Flex • 1019 active objects, in concurrency • 931 Adapter design pattern • 229, 235, 307, 448, 524, 526, 569</p>
<p>Adapter Method idiom • 307 adapters, listener • 954 add( ), ArrayList • 276 addActionListener( ) • 1009, 1014 addChangeListener • 980 addition • 67 addListener • 949 Adler32 • 700</p>
<p>agent-based programming • 934 aggregate array initialization • 134 aggregation • 21</p>
<p>aliasing • 66; and String • 356; arrays • 135 Allison, Chuck • 3, 12, 1043, 1050 allocate( ) • 681 allocateDirect( ) • 681 alphabetic sorting • 295 alphabetic vs. lexicographic sorting • 561 AND: bitwise • 82; logical (&amp;&amp;) • 71 annotation • 761; apt processing tool • 771; default element values • 763, 765; default value • 768; elements • 762; elements, allowed types for • 765; marker annotation • 762; processor • 764; processor based on reflection • 769 anonymous inner class • 251, 649, 944; and tabledriven code • 616; generic • 459 application: builder • 1003; framework • 264 applying a method to a sequence • 520 apt, annotation processing tool • 771 argument: constructor • 108; covariant argument types • 504; final • 186, 649; generic type argument inference • 450; variable argument lists (unknown quantity and type of arguments) • 137 Arnold, Ken • 938</p>
<p>array: array of generic objects • 610; associative array • 278; bounds checking • 135; comparing arrays • 557; comparison with container • 535; copying an array • 555; covariance • 483; dynamic aggregate initialization syntax • 538; element comparisons • 557; first-class objects • 536; initialization • 134; length • 135, 536; multidimensional • 540; not Iterable • 306; of objects • 537; of primitives • 537; ragged • 541; returning an array • 539 ArrayBlockingQueue • 872</p>
<p>ArrayList • 283, 586; add( ) • 276; get( ) • 276; size( )</p>
<p>• 276</p>
<p>Arrays: asList( ) • 280, 309, 585; binarySearch( ) • 562; class, container utility • 555 asCharBuffer( ) • 682</p>
<p>aspect-oriented programming (AOP) • 509 assert, and @Unit • 780 assigning objects • 65 assignment • 65</p>
<p>associative array • 275, 278; another name for map • 596</p>
<p>atomic operation • 833 AtomicInteger • 838</p>
<p>atomicity, in concurrent programming • 826 AtomicLong • 838 AtomicReference • 838</p>
<p>autoboxing • 296, 448; and generics • 450, 495 auto-decrement operator • 69 auto-increment operator • 69 automatic type conversion • 166 available( ) • 667</p>
<p>B</p>
<p>backwards compatibility • 467 bag • 278</p>
<p>bank teller simulation • 900 base 16 • 74 base 8 • 74</p>
<p>base class • 156, 168, 195; abstract base class • 219; base-class interface • 199; constructor • 206; initialization • 170 base types • 22</p>
<p>basic concepts of object-oriented programming</p>
<p>(OOP) • 15</p>
<p>BASIC, Microsoft Visual BASIC • 1002 BasicArrowButton • 958 BeanInfo, custom • 1017</p>
<p>Beans: and Borland’s Delphi • 1002; and Microsoft’s Visual BASIC • 1002; application builder • 1003; bound properties • 1017; component • 1003; constrained properties • 1017; custom BeanInfo • 1017; custom property editor • 1017; custom property sheet • 1017; events • 1003; EventSetDescriptors • 1007; FeatureDescriptor • 1017; getBeanInfo( ) • 1005; getEventSetDescriptors( ) • 1007; getMethodDescriptors( ) • 1007; getName( ) •</p>
<p>1007; getPropertyDescriptors( ) • 1007; getPropertyType( ) • 1007; getReadMethod( ) • 1007; getWriteMethod( ) • 1007; indexed property</p>
<p>•    1017; Introspector • 1005; JAR files for packaging</p>
<p>•    1015; manifest file • 1015; Method • 1007; MethodDescriptors • 1007; naming convention • 1003; properties • 1003; PropertyChangeEvent • 1017; PropertyDescriptors • 1007; ProptertyVetoException • 1017; reflection • 1003, 1005; Serializable • 1011; visual programming • 1002</p>
<p>Beck, Kent • 1048 benchmarking • 914</p>
<p>binary: numbers • 74; numbers, printing • 79;</p>
<p>operators • 76 binarySearch( ) • 562, 635</p>
<p>binding: dynamic binding • 196; dynamic, late, or runtime binding • 193; early • 26; late • 26; late binding • 196; method call binding • 196; runtime binding • 196 BitSet • 644</p>
<p>bitwise: AND • 82; AND operator (&amp;) • 76; EXCLUSIVE OR XOR (<sup>A</sup>) • 76; NOT ~ • 76; operators • 76; OR • 82; OR operator (|) • 76 blank final • 185</p>
<p>Bloch, Joshua • 121, 725, 823, 836 blocking: and available( ) • 668; in concurrent programs • 799 BlockingQueue • 872, 887 Booch, Grady • 1048 book errors, reporting • 14 Boolean • 91; algebra • 76; and casting • 83; operators that won’t work with boolean • 70; vs. C and C++ • 72 Borland Delphi • 1002 bound properties • 1017 bounds: and Class references • 402; in generics • 465, 480; self-bounded generic types • 500; superclass and Class references • 404 bounds checking, array • 135 boxing • 296, 448; and generics • 450, 495 BoxLayout • 949 branching, unconditional • 99 break keyword • 99 Brian’s Rule of Synchronization • 830 browser, class • 159 Budd, Timothy • 16 buffer, nio • 679 BufferedInputStream • 660 BufferedOutputStream • 661 BufferedReader • 341, 663, 665 BufferedWriter • 663, 668 busy wait, concurrency • 860</p>
<p>button: creating your own • 955; radio button • 966;</p>
<p>Swing • 942, 958 ButtonGroup • 959, 966 ByteArrayInputStream • 657 ByteArrayOutputStream • 659 ByteBuffer • 679</p>
<p>bytecode engineering • 791; Javassist • 793</p>
<p>C</p>
<p>C#: programming language • 37 C++ • 70; exception handling • 348; Standard Template Library (STL) • 646; templates • 440, 464 CachedThreadPool • 805 Callable, concurrency • 807 callback • 648, 943; and inner classes • 262 camel-casing • 60</p>
<p>capacity, of a HashMap or HashSet • 630 capitalization of package names • 50 Cascading Style Sheets (CSS), and Macromedia Flex • 1023</p>
<p>case statement • 105</p>
<p>CASE_INSEN SITTVE_ORDER String Comparator • 634, 647</p>
<p>cast • 27; and generic types • 497; and primitive types • 92; asSubclass( ) • 404; operators • 82; via a generic class • 498 cast( ) • 404</p>
<p>catch: catching an exception • 316; catching any exception • 323; keyword • 316 Chain of Responsibility design pattern • 743 chained exceptions • 328, 351 change, vector of • 266 channel, nio • 679 CharArrayReader • 663 CharArrayWriter • 663 CharBuffer • 682 CharSequence • 375 Charset • 683 check box • 965</p>
<p>checked exceptions • 322, 347; converting to unchecked exceptions • 351 checkedCollection( ) • 506 CheckedInputStream • 699 checkedList( ) • 506 checkedMap( ) • 506 CheckedOutputStream • 699 checkedSet( ) • 506 checkedSortedMap( ) • 506 checkedSortedSet( ) • 506 Checksum class • 700</p>
<p>Chiba, Shigeru, Dr. • 793, 795 class • 17; abstract class • 219; access • 159; anonymous inner class • 251, 649, 944; base class • 156, 168, 195; browser • 159; class hierarchies and exception handling • 345; class literal • 399, 410; creators • 19; data • 51; derived class • 195; equivalence, and instanceof/isInstance( ) • 417; final classes • 188; inheritance diagrams • 182; inheriting from abstract classes • 220; inheriting from inner classes • 270; initialization • 400; initialization &amp; class loading • 190; initialization of fields • 126; initializing the base class • 170; initializing the derived class • 170; inner class •</p>
<p>243; inner class, and access rights • 245; inner class, and overriding • 270; inner class, and super • 270; inner class, and Swing • 950; inner class, and upcasting • 248; inner class, identifiers and .class files • 273; inner class, in methods and scopes •</p>
<p>249; inner class, nesting within any arbitrary scope • 250; instance of • 16; keyword • 21; linking • 400; loading • 191, 400; member initialization • 166; methods • 51; multiply nested • 259; nested class (static inner class) • 257; nesting inside an interface • 258; order of initialization • 128; private inner classes • 266; public class, and compilation units • 146; referring to the outer-class object in an inner class • 246; static inner classes • 257; style of creating classes • 158; subobject • 170 Class • 960; Class object • 395, 717, 829; forName( ) • 396, 953; getCanonicalName( ) • 398; getClass( ) • 324; getConstructors( ) • 421; getInterfaces( ) •</p>
<p>398; getMethods( ) • 421; getSimpleName( ) • 398; getSuperclass( ) • 398; isAssignableFrom( ) • 413; isInstance( ) • 411; isInterface( ) • 398; newInstance( ) • 398; object creation process • 131; references, and bounds • 402; references, and generics • 401; references, and wildcards • 402; RTTI using the Class object • 395 class files, analyzing • 791 class loader • 395</p>
<p>class name, discovering from class file • 791 ClassCastException • 216, 405 ClassNotFoundException • 408 classpath • 148</p>
<p>cleanup: and garbage collector • 175; performing • 121; verifying the termination condition with finalize( ) • 122; with finally • 334 clear( ), nio • 681</p>
<p>client programmer • 19; vs. library creator • 145 close( ) • 666</p>
<p>closure, and inner classes • 262</p>
<p>code: coding standards • 14; coding style • 59;</p>
<p>organization • 153; reuse • 165; source code • 12 collecting parameter • 509, 530 collection • 29, 278, 302, 634; classes • 275; filling with a Generator • 453; list of methods for • 580; utilities • 631</p>
<p>Collections: addAll( ) • 280; enumeration( ) • 642; fill( ) • 568; unmodifiableList( ) • 584 collision: during hashing • 608; name • 150 combo box • 967 comma operator • 96</p>
<p>Command design pattern • 268, 429, 739, 805 comments, and embedded documentation • 55 Commitment, Theory of Escalating • 823 common interface • 219</p>
<p>Communicating Sequential Processes (CSP) • 934 Comparable • 558, 589, 594 Comparator • 559, 589 compareTo( ), in java.lang.Comparable • 558, 591 comparing arrays • 557</p>
<p>compatibility: backwards • 467; migration • 466 compilation unit • 146 compile-time constant • 183 compiling a Java program • 54 component, and JavaBeans • 1003 composition • 21, 165; and design • 213; and dynamic behavior change • 214; combining composition &amp; inheritance • 173; vs. inheritance • 179, 183, 595, 642</p>
<p>compression, library • 699</p>
<p>concurrency: active objects • 931; and containers • 637; and exceptions • 831; and Swing • 994; ArrayBlockingQueue • 872; atomicity • 826; BlockingQueue • 872, 887; Brian’s Rule of Synchronization • 830; Callable • 807; Condition class • 870; constructors • 816; contention, lock • 914; CountDownLatch • 883; CyclicBarrier • 885; daemon threads • 811; DelayQueue • 887; Exchanger • 898; Executor • 804; I/O between tasks using pipes • 876; LinkedBlockingQueue • 872; lock, explicit • 831; lock-free code • 833; long and double non-atomicity • 833; missed signals • 864; performance tuning • 913; priority • 809; PriorityBlockingQueue • 889; producer-consumer • 867; race condition • 827; ReadWriteLock • 929; ScheduledExecutor • 892; semaphore • 895; sleep(</p>
<p>) • 808; SynchronousQueue • 904; task interference • 826; terminating tasks • 846; the Goetz Test for avoiding synchronization • 833; thread local storage • 845; thread vs. task, terminology • 820; UncaughtExceptionHandler • 824; word tearing • 833 ConcurrentHashMap • 598, 921, 925 ConcurrentLinkedQueue • 921 ConcurrentModificationException • 637; using CopyOnWriteArrayList to eliminate • 921, 933 Condition class, concurrency • 870 conditional compilation • 152 conditional operator • 80</p>
<p>conference, Software Development Conference • 10 console: sending exceptions to • 351; Swing display framework in net.mindview.util.SwingConsole • 942</p>
<p>constant: compile-time constant • 183; constant folding • 183; groups of constant values • 236; implicit constants, and String • 355 constrained properties • 1017 constructor • 107; and anonymous inner classes •</p>
<p>251; and concurrency • 816; and exception handling • 340, 341; and finally • 341; and overloading • 109; and polymorphism • 204; arguments • 108; baseclass constructor • 206; behavior of polymorphic methods inside constructors • 210; calling baseclass constructors with arguments • 170; calling from other constructors • 118; Constructor class for reflection • 419; default • 115; initialization during inheritance and composition • 173; instance initialization • 253; name • 107; no-arg • 108, 115; order of constructor calls with inheritance • 204; return value • 108; static construction clause • 131; static method • 131; synthesized default constructor access • 421 consulting &amp; training provided by MindView, Inc. • 1043</p>
<p>container • 29; class • 275; classes • 275; comparison with array • 535; performance test • 616</p>
<p>containers: basic behavior • 281; lock-free • 921;</p>
<p>typesafe and generics • 275 contention, lock, in concurrency • 914 context switch • 798 continue keyword • 99 contravariance, and generics • 487 control framework, and inner classes • 264 control, access • 20, 162</p>
<p>conversion: automatic • 166; narrowing conversion • 83; widening conversion • 83 Coplien, Jim: curiously recurring template pattern • 501</p>
<p>copying an array • 555 CopyOnWriteArrayList • 900, 921 CopyOnWriteArraySet • 921 copyright notice, source code • 12 CountDownLatch, for concurrency • 883 covariant • 402; argument types • 504; arrays • 483;</p>
<p>return types • 212, 415, 504 CRC32 • 700</p>
<p>critical section, and synchronized block • 839 CSS (Cascading Style Sheets), and Macromedia Flex</p>
<p>• 1.023</p>
<p>curiously recurring: generics • 501; template pattern in C++ • 501</p>
<p>CyclicBarrier, for concurrency • 885</p>
<p>D</p>
<p>daemon threads • 811</p>
<p>data: final • 183; primitive data types and use with operators • 84; static initialization • 129 Data Transfer Object • 442, 571 Data Transfer Object (Messenger idiom) • 617 data type, equivalence to class • 18 database table, SQL generated via annotations • 766 DatagramChannel • 697 DataInput • 665</p>
<p>DataInputStream • 660, 663, 667 DataOutput • 665 DataOutputStream • 661, 664 deadlock, in concurrency • 878 decode( ), character set • 684 decompiler, javap • 356, 434, 470 Decorator design pattern • 512 decoupling, via polymorphism • 26, 193 decrement operator • 69</p>
<p>default constructor • 115; access the same as the class • 421; synthesizing a default constructor • 170 default keyword, in a switch statement • 104 default package • 146, 155 defaultReadObject( ) • 714 defaultWriteObject( ) • 714 DeflaterOutputStream • 699 Delayed • 889</p>
<p>DelayQueue, for concurrency • 887 delegation • 172, 512 Delphi, from Borland • 1002 DeMarco, Tom • 1049 deque, double-ended queue • 290, 595 derived: derived class • 195; derived class, initializing • 170; types • 22 design • 214; adding more methods to a design • 163; and composition • 213; and inheritance • 213; and mistakes • 162; library design • 145 design pattern: Adapter • 229, 235, 448, 524, 526, 569; Adapter method • 307; Chain of Responsibility • 743; Command • 268, 429, 739,</p>
<p>805; Data Transfer Object (Messenger idiom) • 442, 571, 617; Decorator • 512; Facade • 411; Factory Method • 239, 414, 446, 666; Factory Method, and anonymous classes • 255; Flyweight • 573, 935; Iterator • 246, 287; Null Iterator • 426; Null Object • 426; Proxy • 422; Singleton • 161; State • 214; Strategy • 226, 234, 526, 547, 558, 559, 648, 653, 743, 889; Template Method • 264, 408, 475, 616, 696, 842, 919, 923; Visitor • 775 destructor • 120, 121, 334; Java doesn’t have one • 175</p>
<p>diagram: class inheritance diagrams • 182; inheritance • 27</p>
<p>dialog: box • 981; file • 984; tabbed • 970 dictionary • 279 Dijkstra, Edsger • 878</p>
<p>dining philosophers, example of deadlock in concurrency • 878</p>
<p>directory: and packages • 153; creating directories and paths • 655; lister • 647 dispatching: double dispatching • 752; multiple, and enum • 752</p>
<p>display framework, for Swing • 942 dispose( ) • 982 division • 67</p>
<p>documentation • 11; comments &amp; embedded documentation • 55</p>
<p>double: and threading • 833; literal value marker (d or D) • 74</p>
<p>double dispatching • 752; with EnumMap • 757 double-ended queue (deque) • 290 do-while • 95</p>
<p>downcast • 182, 215; type-safe downcast • 405 drawing lines in Swing • 978 drop-down list • 967 duck typing • 515, 524</p>
<p>dynamic: aggregate initialization syntax for arrays • 538; behavior change with composition • 214; binding • 193, 196; proxy • 423; type checking in Java • 584; type safety and containers • 506</p>
<p>E</p>
<p>early binding • 26, 196 East, BorderLayout • 947</p>
<p>editor, creating one using the Swing JTextPane • 964 efficiency: and arrays • 535; and final • 189 else keyword • 93</p>
<p>encapsulation • 158; using reflection to break • 432 encode( ), character set • 684 end sentinel • 445</p>
<p>endian: big endian • 688; little endian • 688 entrySet( ), in Map • 607 enum: adding methods • 727; and Chain of Responsibility design pattern • 743; and inheritance • 732; and interface • 733; and multiple dispatching • 752; and random selection • 732; and state machines • 747; and static imports • 726; and switch • 728; constant-specific methods • 740, 756; groups of constant values in C &amp; C++ • 236; keyword • 142, 725; values( ) • 725, 729 enumerated types • 142 Enumeration • 641 EnumMap • 739</p>
<p>EnumSet • 457, 645; instead of flags • 737 equals( ) • 70; and hashCode( ) • 589, 612; and hashed data structures • 605; conditions for</p>
<p>defining properly • 604; overriding for HashMap • 604</p>
<p>equivalence: == • 70; object equivalence • 70 erasure • 497; in generics • 463 Erlang language • 800</p>
<p>error: handling with exceptions • 313; recovery • 313; reporting • 348; reporting errors in book • 14; standard error stream • 318 Escalating Commitment, Theory of • 823 event: event-driven programming • 943; event-driven system • 264; events and listeners • 950; JavaBeans • 1003; listener • 949; model, Swing • 949; multicast, and JavaBeans • 1012; responding to a Swing event • 943 EventSetDescriptors • 1007</p>
<p>exception: and concurrency • 831; and constructors • 340; and inheritance • 339, 345; and the console • 351; catching an exception • 316; catching any exception • 323; chained exceptions • 351; chaining</p>
<p>•    328; changing the point of origin of the exception</p>
<p>•    327; checked • 322, 347; class hierarchies • 345; constructors • 341; converting checked to unchecked • 351; creating your own • 317; design issues • 343; Error class • 331; Exception class •</p>
<p>331; exception handler • 316; exception handling • 313; exception matching • 345; exceptional condition • 314; FileNotFoundException • 342; fillInStackTrace( ) • 325; finally • 333; generics • 507; guarded region • 316; handler • 314; handling • 32; logging • 319; losing an exception, pitfall • 337; NullPointerException • 331; printStackTrace( ) • 325; reporting exceptions via a logger • 320; restrictions • 339; re-throwing an exception • 325; RuntimeException • 331; specification • 322, 348; termination vs. resumption • 317; Throwable • 323; throwing an exception • 314, 315; try • 334; try block • 316; typical uses of exceptions • 353; unchecked • 331</p>
<p>Exchanger, concurrency class • 898 executing operating system programs from within Java • 677</p>
<p>Executor, concurrency • 804 ExecutorService • 805</p>
<p>explicit type argument specification for generic methods • 281, 452 exponential notation • 75 extending a class during inheritance • 23 extends • 156, 169, 215; and @interface • 769; and interface • 233; keyword • 168 extensible program • 199 extension: sign • 77; zero • 77 extension, vs. pure inheritance • 214 Externalizable • 708; alternative approach to using • 712</p>
<p>Extreme Programming (XP) • 1048</p>
<p>F</p>
<p>Facade • 411</p>
<p>Factory Method design pattern • 239, 414, 446, 666;</p>
<p>and anonymous classes • 255 factory object • 199, 473 fail fast containers • 637 false • 71</p>
<p>FeatureDescriptor • 1017</p>
<p>Fibonacci • 448</p>
<p>Field, for reflection • 419</p>
<p>fields, initializing fields in interfaces • 236</p>
<p>FIFO (first-in, first out) • 299 file: characteristics of files • 655; dialogs • 984; File class • 647, 657, 664; File.list( ) • 647; incomplete output files, errors and flushing • 668; JAR file • 147; locking • 696; memory-mapped files • 693 FileChannel • 680 FileDescriptor • 657 FileInputReader • 665 FileInputStream • 657 FileLock • 697 FilenameFilter • 647 FileNotFoundException • 342 FileOutputStream • 659 FileReader • 341, 663 FileWriter • 663, 668 fillInStackTrace( ) • 325 FilterInputStream • 657 FilterOutputStream • 659 FilterReader • 663 FilterWriter • 663</p>
<p>final • 223, 442; and efficiency • 189; and private • 187; and static • 183; argument • 186, 649; blank finals • 185; classes • 188; data • 183; keyword • 183; method • 196; methods • 186, 212; static primitives</p>
<p>•    185; with object references • 183</p>
<p>finalize( ) • 120, 177, 343; and inheritance • 206; calling directly • 121</p>
<p>finally • 175, 177; and constructors • 341; and return • 336; keyword • 333; not run with daemon threads • 815; pitfall • 337</p>
<p>finding .class files during loading • 148 FixedThreadPool • 805 flag, using EnumSet instead of • 737 Flex: OpenLaszlo alternative to Flex • 1018; tool from Macromedia • 1018 flip( ), nio • 681</p>
<p>float: floating point true and false • 72; literal value marker (F) • 74 FlowLayout • 947 flushing output files • 668 Flyweight design pattern • 573, 935 focus traversal • 938 folding, constant • 183 for keyword • 95</p>
<p>foreach • 97, 100, 138, 139, 152, 265, 277, 298, 303, 386, 448, 449, 495, 725, 744; and Adapter Method</p>
<p>•    307; and Iterable • 305</p>
<p>format: precision • 365; specifiers • 365; string • 363;</p>
<p>width • 365 format( ) • 363 Formatter • 364 forName( ) • 396, 953 FORTRAN programming language • 75 forward referencing • 128 Fowler, Martin • 145, 350, 1048 framework, control framework and inner classes • 264</p>
<p>function: member function • 18; overriding • 23 function object • 526 functional languages • 800 Future • 808</p>
<p>Generator • 199, 446, 453, 459, 496, 522, 547, 559, 569, 732, 748; filling a Collection • 453; general purpose • 454</p>
<p>generics: @Unit testing • 786; and type-safe containers • 275; anonymous inner classes • 459; array of generic objects • 610; basic introduction • 275; bounds • 465, 480; cast via a generic class • 498; casting • 497; Class references • 401; contravariance • 487; curiously recurring • 501; erasure • 463, 497; example of a framework • 921; exceptions • 507; explicit type argument specification for generic methods • 281, 452; inner classes • 459; instanceof • 472, 497; isInstance( ) • 472; methods • 449, 569; overloading • 499; reification • 467; self-bounded types • 500; simplest class definition • 292; supertype wildcards • 487; type tag • 472; unbounded wildcard • 489; varargs and generic methods • 452; wildcards • 483 get( ): ArrayList • 276; HashMap • 296; no get( ) for Collection • 581 getBeanInfo( ) • 1005 getBytes( ) • 667 getCanonicalName( ) • 398 getChannel( ) • 680 getClass( ) • 324, 397 getConstructor( ) • 960 getConstructors( ) • 421 getenv( ) • 306</p>
<p>getEventSetDescriptors( ) • 1007 getInterfaces( ) • 398 getMethodDescriptors( ) • 1007 getMethods( ) • 421 getName( ) • 1007 getPropertyDescriptors( ) • 1007 getPropertyType( ) • 1007 getReadMethod( ) • 1007 getSelectedValues( ) • 968 getSimpleName( ) • 398 getState( ) • 976 getSuperclass( ) • 398 getWriteMethod( ) • 1007 Glass, Robert • 1049 glue, in BoxLayout • 949 Goetz Test, for avoiding synchronization • 833 Goetz, Brian • 830, 833, 914, 936 goto, lack of in Java • 101 graphical user interface (GUI) • 264, 937 graphics • 983; Graphics class • 978 greater than (&gt;) • 70 greater than or equal to (&gt;=) • 70 greedy quantifiers • 374 GridBagLayout • 948 GridLayout • 948, 1001 Grindstaff, Chris • 1028 group, thread • 823 groups, regular expression • 378 guarded region, in exception handling • 316 GUI: graphical user interface • 264, 937; GUI builders • 938 GZIPInputStream • 699 GZIPOutputStream • 699</p>
<p>G</p>
<p>garbage collection • 120, 121; and cleanup • 175; how the collector works • 123; order of object reclamation • 177; reachable objects • 638</p>
<p>H</p>
<p>handler, exception • 316 Harold, Elliotte Rusty • 1017, 1048; XOM XML library • 720</p>
<p>has-a • 21; relationship, composition • 180</p>
<p>hash function • 608</p>
<p>hashCode( ) • 598, 602, 608; and hashed data structures • 605; equals( ) • 589; issues when writing • 611; recipe for generating decent • 612 hashing • 605, 608; and hash codes • 602; external chaining • 608; perfect hashing function • 608 HashMap • 598, 629, 925, 957 HashSet • 293, 589, 626 Hashtable • 629, 642 hasNext( ), Iterator • 288 Hexadecimal • 74 hiding, implementation • 158 Holub, Allen • 931 HTML on Swing components • 985</p>
<p>I</p>
<p>I/O: available( ) • 667; basic usage, examples • 665; between tasks using pipes • 876; blocking, and available( ) • 668; BufferedInputStream • 660; BufferedOutputStream • 661; BufferedReader •</p>
<p>341, 663, 665; BufferedWriter • 663, 668; ByteArrayInputStream • 657; ByteArrayOutputStream • 659; characteristics of files • 655; CharArrayReader • 663; CharArrayWriter • 663; CheckedInputStream •</p>
<p>699; CheckedOutputStream • 699; close( ) • 666; compression library • 699; controlling the process of serialization • 708; DataInput • 665; DataInputStream • 660, 663, 667; DataOutput • 665; DataOutputStream • 661, 664; DeflaterOutputStream • 699; directory lister • 647; directory, creating directories and paths • 655; Externalizable • 708; File • 657, 664; File class • 647; File.list( ) • 647; FileDescriptor • 657; FileInputReader • 665; FileInputStream • 657; FilenameFilter • 647; FileOutputStream • 659; FileReader • 341, 663; FileWriter • 663, 668; FilterInputStream • 657; FilterOutputStream • 659; FilterReader • 663; FilterWriter • 663; from standard input • 675; GZIPInputStream • 699; GZIPOutputStream • 699; InflaterInputStream • 699; input • 657; InputStream • 657; InputStreamReader • 662, 663; internationalization • 662; interruptible • 854; library • 647; lightweight persistence • 703; LineNumberInputStream • 660; LineNumberReader • 663; mark( ) • 665; mkdirs( )</p>
<p>•    656; network I/O • 679; new nio • 679; ObjectOutputStream • 704; output • 657; OutputStream • 657, 658; OutputStreamWriter •</p>
<p>662,    663; pipe • 657; piped streams • 672; PipedInputStream • 657; PipedOutputStream •</p>
<p>657, 659; PipedReader • 663; PipedWriter • 663; PrintStream • 661; PrintWriter • 663, 668, 669; PushbackInputStream • 660; PushbackReader • 663; RandomAccessFile • 664, 665, 671; read( ) • 657; readDouble( ) • 670; Reader • 657, 662, 663; readExternal( ) • 708; readLine( ) • 343, 663, 668, 676; readObject( ) • 704; redirecting standard I/O • 677; renameTo( ) • 656; reset( ) • 665; seek( ) • 665, 671; SequenceInputStream • 657, 664; Serializable</p>
<p>•    708; setErr(PrintStream) • 677; setIn(InputStream) • 677; setOut(PrintStream) • 677; StreamTokenizer • 663; StringBuffer • 657; StringBufferInputStream • 657; StringReader •</p>
<p>663,    666; StringWriter • 663; System.err • 675; System.in • 675; System.out • 675; transient • 711;</p>
<p>typical I/O configurations • 665; Unicode • 663; write( ) • 657; writeBytes( ) • 670; writeChars( ) • 670; writeDouble( ) • 670; writeExternal( ) • 708; writeObject( ) • 704; Writer • 657, 662, 663; ZipEntry • 701; ZipInputStream • 699; ZipOutputStream • 699 Icon • 960</p>
<p>IdentityHashMap • 598, 630 if-else statement • 80, 93 IllegalAccessException • 408 IllegalMonitorStateException • 861 ImageIcon • 960 immutable • 427</p>
<p>implementation • 18; and interface • 179, 222; and interface, separating • 20; and interface, separation</p>
<p>•    158; hiding • 145, 158, 248; separation of interface and implementation • 949</p>
<p>implements keyword • 223 import keyword • 146</p>
<p>increment operator • 69; and concurrency • 828 indexed property • 1017 indexing operator [ ] • 134 indexOf( ), String • 421</p>
<p>inference, generic type argument inference • 450 InflaterInputStream • 699</p>
<p>inheritance • 21, 156, 165, 168, 193; and enum • 732; and final • 189; and finalize( ) • 206; and generic code • 439; and synchronized • 1015; class inheritance diagrams • 182; combining composition &amp; inheritance • 173; designing with inheritance • 213; diagram • 27; extending a class during • 23; extending interfaces with inheritance • 232; from abstract classes • 220; from inner classes</p>
<p>•    270; initialization with inheritance • 190; method overloading vs. overriding • 178; multiple inheritance in C++ and Java • 230; pure inheritance vs. extension • 214; specialization •</p>
<p>180; vs. composition • 179, 183, 595, 642</p>
<p>initial capacity, of a HashMap or HashSet • 630 initialization: and class loading • 190; array initialization • 134; base class • 170; class • 400; class member • 166; constructor initialization during inheritance and composition • 173; initializing with the constructor • 107; instance initialization • 132, 253; lazy • 166; member initializers • 206; non-static instance initialization • 132; of class fields • 126; of method variables • 125; order of initialization • 128, 211; static • 191; with inheritance • 190 inline method calls • 186</p>
<p>inner class • 243; access rights • 245; and overriding</p>
<p>•    270; and control frameworks • 264; and super • 270; and Swing • 950; and threads • 816; and upcasting • 248; anonymous inner class • 649, 944; and table-driven code • 616; callback • 262; closure</p>
<p>•    262; generic • 459; hidden reference to the object of the enclosing class • 246; identifiers and .class files • 273; in methods &amp; scopes • 249; inheriting from inner classes • 270; local • 250; motivation • 260; nesting within any arbitrary scope • 250; private inner classes • 266; referring to the outer-class object • 246; static inner classes • 257</p>
<p>InputStream • 657 InputStreamReader • 662, 663 instance: instance initialization • 253; non-static instance initialization • 132; of a class • 16 instanceof • 410; and generic types • 497; dynamic instanceof with isInstance( ) • 411; keyword • 405 Integer: parseInt( ) • 984; wrapper class • 136</p>
<p>interface: and enum • 733; and generic code • 439; and implementation, separation of • 20, 158, 949; and inheritance • 232; base-class interface • 199; classes nested inside • 258; common interface •</p>
<p>219; for an object • 17; initializing fields in interfaces • 236; keyword • 222; name collisions when combining interfaces • 233; nesting interfaces within classes and other interfaces • 237; private, as nested interfaces • 239; upcasting to an interface • 225; vs. abstract • 231; vs. implementation • 179 internationalization, in I/O library • 662 interrupt( ): concurrency • 851; threading • 820 interruptible io • 854 Introspector • 1005</p>
<p>invocation handler, for dynamic proxy • 423 is-a • 214; relationship, inheritance • 180; and upcasting • 181; vs. is-like-a relationships • 24 isAssignableFrom( ), Class method • 413 isDaemon( ) • 813</p>
<p>isInstance( ) • 411; and generics • 472 isInterface( ) • 398 is-like-a • 215</p>
<p>Iterable • 448, 571; and array • 306; and foreach • 305</p>
<p>Iterator • 287, 289, 302; hasNext( ) • 288; next( ) • 288</p>
<p>Iterator design pattern • 246</p>
<p>J</p>
<p>Jacobsen, Ivar • 1048 JApplet • 946; menus • 972 JAR • 1015; file • 147; jar files and classpath • 149; utility • 702</p>
<p>Java: and set-top boxes • 76; AWT • 937; bytecodes • 357; compiling and running a program • 54; Java Foundation Classes (JFC/Swing) • 937; Java Virtual Machine (JVM) • 395; Java Web Start • 989; public Java seminars • 10 Java standard library, and thread-safety • 884 JavaBeans, see Beans • 1002 javac•54 javadoc • 55</p>
<p>javap decompiler • 356, 434, 470</p>
<p>Javassist • 793</p>
<p>JButton • 960; Swing • 942</p>
<p>JCheckBox • 960, 965</p>
<p>JCheckBoxMenuItem • 973, 976</p>
<p>JComboBox • 967</p>
<p>JComponent • 961, 978</p>
<p>JDialog • 981; menus • 972</p>
<p>JDK 1.1 I/O streams • 662</p>
<p>JDK, downloading and installing • 54</p>
<p>JFC, Java Foundation Classes (Swing) • 937</p>
<p>JFileChooser • 984</p>
<p>JFrame • 946; menus • 972</p>
<p>JIT, just-in-time compilers • 125</p>
<p>JLabel • 963</p>
<p>JList • 968</p>
<p>JMenu • 972, 976</p>
<p>JMenuBar • 972, 977</p>
<p>JMenuItem • 960, 972, 976, 977, 978</p>
<p>JNLP, Java Network Launch Protocol • 989</p>
<p>join( ), threading • 820</p>
<p>JOptionPane • 970</p>
<p>Joy, Bill • 70</p>
<p>JPanel • 959, 978, 1001</p>
<p>JPopupMenu • 977 JProgressBar • 987 JRadioButton • 960, 966 JScrollPane • 946, 969 JSlider • 987 JTabbedPane • 970 JTextArea • 945 JTextField • 943, 961 JTextPane • 964 JToggleButton • 958 JUnit, problems with • 778 JVM (Java Virtual Machine) • 395</p>
<p>K</p>
<p>keyboard: navigation, and Swing • 938; shortcuts •</p>
<p>976</p>
<p>keySet( ) • 629</p>
<p>L</p>
<p>label • 101</p>
<p>labeled: break • 101; continue • 101 late binding • 26, 193, 196 latent typing • 515, 524</p>
<p>layout, controlling layout with layout managers •</p>
<p>946</p>
<p>lazy initialization • 166 least-recently-used (LRU) • 602 left-shift operator (&lt;&lt;) • 76 length: array member • 135; for arrays • 536 less than (&lt;) • 70 less than or equal to (&lt;=) • 70 lexicographic: sorting • 295; vs. alphabetic sorting • 561</p>
<p>library: creator, vs. client programmer • 145; design • 145; use • 146</p>
<p>LIFO (last-in, first-out) • 291 lightweight: object • 287; persistence • 703 LineNumberInputStream • 660 LineNumberReader • 663 LinkedBlockingQueue • 872 LinkedHashMap • 598, 601, 630 LinkedHashSet • 294, 589, 626, 627 LinkedList • 283, 290, 299, 586 linking, class • 400 list: boxes • 968; drop-down list • 967 List • 275, 278, 283, 586, 968; performance comparison • 620; sorting and searching • 634 listener: adapters • 954; and events • 950; interfaces • 953</p>
<p>Lister, Timothy • 1049 ListIterator • 586</p>
<p>literal: class literal • 399, 410; double • 74; float • 74;</p>
<p>long • 74; values • 73 little endian • 688 livelock • 935</p>
<p>load factor, of a HashMap or HashSet • 630 loader, class • 395</p>
<p>loading: .class files • 148; class • 191, 400;</p>
<p>initialization &amp; class loading • 190 local: inner class • 250; variable • 48 lock: contention, in concurrency • 914; explicit, in concurrency • 831; in concurrency • 829; optimistic locking • 927</p>
<p>lock-free code, in concurrent programming • 833 locking, file • 696, 697 logarithms, natural • 75</p>
<p>logging, building logging into exceptions • 319 logical: AND • 82; operator and short-circuiting • 73; operators • 71; OR • 82</p>
<p>long: and threading • 833; literal value marker (L) • 74</p>
<p>look &amp; feel, pluggable • 987 LRU, least-recently-used • 602 lvalue • 65</p>
<p>M</p>
<p>machines, state, and enum • 747 Macromedia Flex • 1018 main( ) • 169</p>
<p>manifest file, for JAR files • 702, 1015 Map • 275, 278, 296; EnumMap • 739; in-depth exploration of • 596; performance comparison •</p>
<p>628</p>
<p>Map.Entry • 607 MappedByteBuffer • 694 mark( ) • 665 marker annotation • 762 matcher, regular expression • 375 matches( ), String • 371 Math.random( ) • 296; range of results • 625 mathematical operators • 67, 697 member: initializers • 206; member function • 18; object • 20</p>
<p>memory exhaustion, solution via References • 638</p>
<p>memory-mapped files • 693</p>
<p>menu: JDialog, JApplet, JFrame • 972;</p>
<p>JPopupMenu • 977 message box, in Swing • 970 message, sending • 17 Messenger idiom • 442, 571, 617 meta-annotations • 763 Metadata • 761</p>
<p>method: adding more methods to a design • 163; aliasing during method calls • 66; applying a method to a sequence • 520; behavior of polymorphic methods inside constructors • 210; distinguishing overloaded methods • 110; final • 186, 196, 212; generic • 449; initialization of method variables • 125; inline method calls • 186; inner classes in methods &amp; scopes • 249; lookup tool • 951; method call binding • 196; overloading • 109; overriding private • 202; polymorphic method call • 193; private • 212; protected methods • 180; recursive • 360; static • 119, 196 Method • 1007; for reflection • 419 MethodDescriptors • 1007 Meyer, Jeremy • 761, 791, 989 Meyers, Scott • 19 microbenchmarks • 625 Microsoft Visual BASIC • 1002 migration compatibility • 466 missed signals, concurrency • 864 mistakes, and design • 162 mixin • 509 mkdirs( ) • 656</p>
<p>mnemonics (keyboard shortcuts) • 976 Mock Object • 431 modulus • 67</p>
<p>monitor, for concurrency • 829 Mono • 37</p>
<p>multicast • 1011; event, and JavaBeans • 1012 multidimensional arrays • 540 multiparadigm programming • 16 multiple dispatching: and enum • 752; with EnumMap • 757</p>
<p>multiple implementation inheritance • 261 multiple inheritance, in C++ and Java • 230 multiplication • 67 multiply nested class • 259 multitasking • 799</p>
<p>mutual exclusion (mutex), concurrency • 828 MXML, Macromedia Flex input format • 1018 mxmlc, Macromedia Flex compiler • 1020</p>
<p>N</p>
<p>name: clash • 146; collisions • 150; collisions when combining interfaces • 233; creating unique package names • 148; qualified • 398 namespaces • 146 narrowing conversion • 83 natural logarithms • 75 nested class (static inner class) • 257 nesting interfaces • 237 net.mindview.util.SwingConsole • 942 network I/O • 679 Neville, Sean • 1018 new I/O • 679</p>
<p>new operator • 120; and primitives, array • 135 newInstance( ) • 960; reflection • 398 next( ), Iterator • 288</p>
<p>nio • 679; and interruption • 854; buffer • 679;</p>
<p>channel • 679; performance • 694 no-arg constructor • 108, 115 North, BorderLayout • 947 not equivalent (!=) • 70 NOT, logical (!) • 71 notifyAll( ) • 860 notifyListeners( ) • 1015 null • 45</p>
<p>Null Iterator design pattern • 426 Null Object design pattern • 426 NullPointerException • 331 numbers, binary • 74</p>
<p>O</p>
<p>object • 16; aliasing • 66; arrays are first-class objects • 536; assigning objects by copying references • 65; Class object • 395, 717, 829; creation • 108; equals(</p>
<p>) • 70; equivalence • 70; equivalence vs. reference equivalence • 70; final • 183; getClass( ) • 397; hashCode( ) • 598; interface to • 17; lock, for concurrency • 829; member • 20; object-oriented programming • 393; process of creation • 131; serialization • 703; standard root class, default inheritance from • 168; wait( ) and notifyAll( ) • 860; web of objects • 704 object pool • 895</p>
<p>object-oriented, basic concepts of object-oriented programming (OOP) • 15 ObjectOutputStream • 704 Octal • 74</p>
<p>ones complement operator • 76 OOP: basic characteristics • 16; basic concepts of object-oriented programming • 15; protocol • 222;</p>
<p>Simula-67 programming language • 17; substitutability • 16 OpenLaszlo, alternative to Flex • 1018 operating system, executing programs from within Java • 677</p>
<p>operation, atomic • 833</p>
<p>operator • 64; + and += overloading for String • 169; +, for String • 356; binary • 76; bitwise • 76; casting • 82; comma operator • 96; common pitfalls • 82; indexing operator [ ] • 134; logical • 71; logical operators and short-circuiting • 73; onescomplement • 76; operator overloading for String • 356; overloading • 81; precedence • 64; relational • 70; shift • 76; String conversion with operator + • 64, 81; ternary • 80; unary • 69, 76 optional methods, in the Java containers • 583 OR • 82; (||) • 71</p>
<p>order: of constructor calls with inheritance • 204; of</p>
<p>initialization • 128, 190, 211</p>
<p>ordinal( ), for enum • 726</p>
<p>organization, code • 153</p>
<p>OSExecute • 678</p>
<p>OutputStream • 657, 658</p>
<p>OutputStreamWriter • 662, 663</p>
<p>overflow, and primitive types • 92</p>
<p>overloading: and constructors • 109; distinguishing</p>
<p>overloaded methods • 110; generics • 499; lack of</p>
<p>name hiding during inheritance • 178; method</p>
<p>overloading • 109; on return values • 114; operator +</p>
<p>and += overloading for String • 169, 356; operator</p>
<p>overloading • 81; vs. overriding • 178</p>
<p>overriding: and inner classes • 270; function • 23;</p>
<p>private methods • 202; vs. overloading • 178</p>
<p>P</p>
<p>package • 146; access, and friendly • 153; and directory structure • 153; creating unique package names • 148; default • 146, 155; names, capitalization • 50; package access, and protected • 180</p>
<p>paintComponent( ) • 978, 983 painting on a JPanel in Swing • 978 parameter, collecting • 509, 530 parameterized types • 439 parseInt( ) • 984 pattern, regular expression • 373 perfect hashing function • 608 performance: and final • 189; nio • 694; test, containers • 616; tuning, for concurrency • 913 persistence • 715; lightweight persistence • 703 PhantomReference • 638 philosophers, dining, example of deadlock in concurrency • 878 pipe • 657 piped streams • 672 PipedInputStream • 657 PipedOutputStream • 657, 659 PipedReader • 663, 876 PipedWriter • 663, 876 pipes, and I/O • 876 Plauger, P.J. • 1049 pluggable look &amp; feel • 987 pointer, Java exclusion of pointers • 262 polymorphism • 25, 193, 217, 393, 437; and constructors • 204; and multiple dispatching • 752; behavior of polymorphic methods inside constructors • 210 pool, object • 895</p>
<p>portability in C, C++ and Java • 84 position, absolute, when laying out Swing components • 949 possessive quantifiers • 374 post-decrement • 69 postfix • 69 post-increment • 69 pre-decrement • 69 preferences API • 722 prefix • 69 pre-increment • 69 prerequisites, for this book • 15 primitive: comparison • 70; data types, and use with operators • 84; final • 183; final static primitives • 185; initialization of class fields • 126; types • 43 primordial class loader • 395 printf( ) • 363</p>
<p>printStackTrace( ) • 323, 325 PrintStream • 661</p>
<p>PrintWriter • 663, 668, 669; convenience constructor in Java SE5 • 672 priority, concurrency • 809 PriorityBlockingQueue, for concurrency • 889 PriorityQueue • 300, 593 private • 20, 145, 153, 155, 180, 829; illusion of overriding private methods • 187; inner classes • 266; interfaces, when nested • 239; method overriding • 202; methods • 212 problem space • 16 process control • 677 process, concurrent • 799 ProcessBuilder • 678 ProcessFiles • 790</p>
<p>producer-consumer, concurrency • 867 programmer, client • 19</p>
<p>programming: basic concepts of object-oriented programming (OOP) • 15; event-driven programming • 943; Extreme Programming (XP) • 1048; multiparadigm • 16; object-oriented • 393 progress bar • 986 promotion, to int • 84, 92 property • 1003; bound properties • 1017; constrained properties • 1017; custom property editor • 1017; custom property sheet • 1017; indexed property • 1017 PropertyChangeEvent • 1017 PropertyDescriptors • 1007 ProptertyVetoException • 1017 protected • 20, 145, 153, 156, 180; and package access • 180; is also package access • 158 protocol • 222</p>
<p>proxy: and java.lang.ref.Reference • 638; for unmodifiable methods in the Collections class • 585</p>
<p>Proxy design pattern • 422</p>
<p>public • 20, 145, 153, 154; and interface • 222; class, and compilation units • 146 pure substitution • 24, 214 PushbackInputStream • 660 PushbackReader • 663 pushdown stack • 291; generic • 444 Python • 1, 3, 6, 35, 39, 515, 564, 799, 1050</p>
<p>Q</p>
<p>quantifier: greedy • 374; possessive • 374; regular expression • 374; reluctant • 374 queue • 275, 290, 299, 593; performance • 620;</p>
<p>synchronized, concurrency • 872 queuing discipline • 300</p>
<p>R</p>
<p>race condition, in concurrency • 827</p>
<p>RAD (Rapid Application Development) • 418</p>
<p>radio button • 966</p>
<p>ragged array • 541</p>
<p>random selection, and enum • 732</p>
<p>random( ) • 296</p>
<p>RandomAccess, tagging interface for containers • 312</p>
<p>RandomAccessFile • 664, 665, 671, 680 raw type • 464</p>
<p>reachable objects and garbage collection • 638</p>
<p>read( ) • 657; nio • 681</p>
<p>readDouble( ) • 670</p>
<p>Reader • 657, 662, 663</p>
<p>readExternal( ) • 708</p>
<p>reading from standard input • 675</p>
<p>readLine( ) • 343, 663, 668, 676</p>
<p>readObject( ) • 704; with Serializable • 712</p>
<p>ReadWriteLock • 929</p>
<p>recursion, unintended via toString( ) • 360</p>
<p>redirecting standard I/O • 677</p>
<p>ReentrantLock • 832, 856</p>
<p>refactoring • 145</p>
<p>reference: assigning objects by copying references • 65; final • 183; finding exact type of a base reference • 395; null • 45; reference equivalence vs. object equivalence • 70 reference counting, garbage collection • 123 Reference, from java.lang.ref • 638 referencing, forward • 128 reflection • 418, 419, 951, 1005; and Beans • 1003; and weak typing • 350; annotation processor • 764, 769; breaking encapsulation with • 432; difference between RTTI and reflection • 419; example • 959; latent typing and generics • 519 regex • 373</p>
<p>Registered Factories, variation of Factory Method design pattern • 414 regular expressions • 370 rehashing • 630 reification, and generics • 467 relational operators • 70 reluctant quantifiers • 374 removeActionListener( ) • 1009, 1014 removeXXXListener( ) • 950 renameTo( ) • 656 reporting errors in book • 14 request, in OOP • 17 reset( ) • 665</p>
<p>responsive user interfaces • 822 resume( ), and deadlocks • 850 resumption, termination vs. resumption, exception handling • 317</p>
<p>re-throwing an exception • 325 return: an array • 539; and finally • 336; constructor return value • 108; covariant return types • 212, 504; overloading on return value • 114; returning multiple objects • 442 reusability • 20</p>
<p>reuse: code reuse • 165; reusable code • 1002 rewind( ) • 684 right-shift operator (&gt;&gt;) • 76 rollover • 961 RoShamBo • 752 Rumbaugh, James • 1048 running a Java program • 54 runtime binding • 196; polymorphism • 193 runtime type information (RTTI) • 216; Class object • 395, 960; ClassCastException • 405; Constructor class for reflection • 419; Field • 419; getConstructor( ) • 960; instanceof keyword • 405; isInstance( ) • 411; Method • 419; misuse • 437; newInstance( ) • 960; reflection • 418; reflection, difference between • 419; shape example • 393; type-safe downcast • 405 RuntimeException • 331, 351 rvalue • 65</p>
<p>S</p>
<p>ScheduledExecutor, for concurrency • 892 scheduler, thread • 802</p>
<p>scope: inner class nesting within any arbitrary scope</p>
<p>•    250; inner classes in methods &amp; scopes • 249 scrolling in Swing • 946</p>
<p>searching: an array • 562; sorting and searching Lists • 634</p>
<p>section, critical section and synchronized block • 839 seek( ) • 665, 671</p>
<p>self-bounded types, in generics • 500 semaphore, counting • 895 seminars: public Java seminars • 10; training, provided by MindView, Inc. • 1043 sending a message • 17 sentinel, end • 445</p>
<p>separation of interface and implementation • 20,</p>
<p>158, 949</p>
<p>sequence, applying a method to a sequence • 520 SequenceInputStream • 657, 664 Serializable • 703, 708, 711, 719, 1011; readObject( ) • 712; writeObject( ) • 712</p>
<p>serialization: and object storage • 715; and transient • 711; controlling the process of serialization • 708; defaultReadObject( ) • 714; defaultWriteObject( ) • 714; Versioning • 714</p>
<p>Set • 275, 278, 293, 589; mathematical relationships</p>
<p>•    456; performance comparison • 626 setActionCommand( ) • 976 setBorder( ) • 963 setErr(PrintStream) • 677</p>
<p>setIcon( ) • 961 setIn(InputStream) • 677 setLayout( ) • 946 setMnemonic( ) • 976 setOut(PrintStream) • 677 setToolTipText( ) • 961</p>
<p>shape: example • 22, 197; example, and runtime type information • 393 shift operators • 76</p>
<p>short-circuit, and logical operators • 73</p>
<p>shortcut, keyboard • 976</p>
<p>shuffle( ) • 635</p>
<p>side effect • 64, 70, 114</p>
<p>sign extension • 77</p>
<p>signals, missed, in concurrency • 864</p>
<p>signature, method • 48</p>
<p>signed twos complement • 79</p>
<p>Simula-67 programming language • 17 simulation • 900</p>
<p>sine wave • 978</p>
<p>single dispatching • 752</p>
<p>SingleThreadExecutor • 806</p>
<p>Singleton design pattern • 161</p>
<p>size( ), ArrayList • 276</p>
<p>size, of a HashMap or HashSet • 630</p>
<p>sizeof( ), lack of in Java • 84</p>
<p>sleep( ), in concurrency • 808</p>
<p>slider • 986</p>
<p>Smalltalk • 16</p>
<p>SocketChannel • 697</p>
<p>SoftReference • 638</p>
<p>Software Development Conference • 10</p>
<p>solution space • 15</p>
<p>SortedMap • 600</p>
<p>SortedSet • 592</p>
<p>sorting • 557; alphabetic • 295; and searching Lists • 634; lexicographic • 295 source code • 12; copyright notice • 12 South, BorderLayout • 947 space: namespaces • 146; problem space • 16;</p>
<p>solution space • 15 specialization • 180</p>
<p>specification, exception specification • 322, 348 specifier, access • 20, 145, 153 split( ), String • 226, 371 sprintf( ) • 369</p>
<p>SQL generated via annotations • 766</p>
<p>stack • 290, 291, 642; generic pushdown • 444</p>
<p>standard input, reading from • 675</p>
<p>standards, coding • 14</p>
<p>State design pattern • 214</p>
<p>state machines, and enum • 747</p>
<p>stateChanged( ) • 980</p>
<p>static • 223; and final • 183; block • 131; construction clause • 131; data initialization • 129; final static primitives • 185; import, and enum • 726; initialization • 191, 396; initializer • 414; inner classes • 257; keyword • 51, 119; method • 119, 196; strong type checking • 347; synchronized static • 829; type checking • 437; vs. dynamic type checking • 584 STL, C++ • 646 stop( ), and deadlocks • 850 Strategy design pattern • 226, 234, 526, 547, 558, 559, 648, 653, 743, 889 stream, I/O • 657 StreamTokenizer • 663</p>
<p>String: CASE_INSENSITIVE_ORDER Comparator • 634; class methods • 355; concatenation with operator += • 81; conversion with operator + • 64, 81; format( ) • 369; immutability • 355; indexOf( ) • 421; lexicographic vs. alphabetic sorting • 561; methods • 361; operator + and += overloading • 169; regular expression support in • 371; sorting, CASE_INSENSITIVE_ORDER • 647; split( ) method • 226; toString( ) • 166 StringBuffer • 657 StringBufferInputStream • 657 StringBuilder, vs. String, and toString( ) • 357 StringReader • 663, 666 StringWriter • 663 strong static type checking • 347 Stroustrup, Bjarne • 144 structural typing • 515, 524 struts, in BoxLayout • 949 Stub • 431</p>
<p>style: coding style • 59; of creating classes • 158 subobject • 170, 179</p>
<p>substitutability, in OOP • 16</p>
<p>substitution: inheritance vs. extension • 214;</p>
<p>principle • 24 subtraction • 67 suites, @Unit vs. JUnit • 787 super • 171; and inner classes • 270; keyword • 169 superclass • 169; bounds • 404 supertype wildcards • 487 suspend( ), and deadlocks • 850 SWF, Flash bytecode format • 1018 Swing • 937; and concurrency • 994; component examples • 957; components, using HTML with • 985; event model • 949 switch: and enum • 728; keyword • 104 switch, context switching in concurrency • 798 synchronized • 829; and inheritance • 1015; and wait( ) &amp; notifyAll( ) • 860; block, and critical section • 839; Brian’s Rule of Synchronization • 830; containers • 637; deciding what methods to synchronize • 1015; queue • 872; static • 829 SynchronousQueue, for concurrency • 904 System.arraycopy( ) • 555 System.err • 318, 675 System.in • 675 System.out • 675</p>
<p>System.out, changing to a PrintWriter • 676 systemNodeForPackage( ), preferences API • 723</p>
<p>T</p>
<p>tabbed dialog • 970</p>
<p>table-driven code • 741; and anonymous inner classes • 616</p>
<p>task vs. thread, terminology • 820 tearing, word tearing • 833 Template Method design pattern • 264, 408, 475, 616, 696, 842, 919, 923 templates, C++ • 440, 464 termination condition, and finalize( ) • 122 termination vs. resumption, exception handling •</p>
<p>317</p>
<p>ternary operator • 80</p>
<p>testing: annotation-based unit testing with @Unit • 778; techniques • 258; unit testing • 169 Theory of Escalating Commitment • 823 this keyword • 116</p>
<p>thread: group • 823; interrupt( ) • 851; isDaemon( ) • 813; notifyAll( ) • 860; priority • 809; resume( ), and deadlocks • 850; safety, Java standard library • 884; scheduler • 802; states • 849; stop( ), and deadlocks • 850; suspend( ), and deadlocks • 850; thread local storage • 845; vs. task, terminology • 820; wait( ) • 860 ThreadFactory, custom • 812 throw keyword • 315</p>
<p>Throwable base class for Exception • 323</p>
<p>throwing an exception • 315</p>
<p>time conversion • 889</p>
<p>Timer, repeating • 866</p>
<p>TimeUnit • 809, 889</p>
<p>toArray( ) • 629</p>
<p>tool tips • 961</p>
<p>TooManyListenersException • 1011</p>
<p>toString( ) • 166; guidelines for using StringBuilder •</p>
<p>359</p>
<p>training seminars provided by MindView, Inc. • 1043 transferFrom( ) • 681</p>
<p>transferTo( ) • 681 transient keyword • 711 translation unit • 146 TreeMap • 598, 600, 629 TreeSet • 294, 589, 592, 626 true • 71</p>
<p>try • 177, 334; try block in exceptions • 316 tryLock( ), file locking • 697 tuple • 442, 455, 461 twos complement, signed • 79 type: argument inference, generic • 450; base • 22; checking, static • 347, 437; data type equivalence to class • 18; derived • 22; duck typing • 515, 524; dynamic type safety and containers • 506; finding exact type of a base reference • 395; generics and type-safe containers • 275; latent typing • 515, 524; parameterized • 439; primitive • 43; primitive data types and use with operators • 84; structural typing • 515, 524; tag, in generics • 472; type checking and arrays • 535; type safety in Java • 82; type-safe downcast • 405</p>
<p>TYPE field, for primitive class literals • 399</p>
<p>U</p>
<p>UML: indicating composition • 21; Unified Modeling Language • 18, 1048</p>
<p>unary: minus (-) • 69; operator • 76; operators • 69; plus (+) • 69</p>
<p>unbounded wildcard in generics • 489 UncaughtExceptionHandler, Thread class • 824 unchecked exception • 331; converting from checked-351</p>
<p>unconditional branching • 99 unicast • 1011 Unicode • 663</p>
<p>Unified Modeling Language (UML) • 18, 1048 unit testing • 169; annotation-based with @Unit •</p>
<p>778</p>
<p>unmodifiable, making a Collection or Map unmodifiable • 635 unmodifiableList( ), Collections • 584 unsupported methods, in the Java containers • 583 UnsupportedOperationException • 584 upcasting • 27, 181, 193; and interface • 225; and runtime type information • 394; inner classes and upcasting • 248</p>
<p>user interface: graphical user interface (GUI) • 264, 937; responsive, with threading • 822 userNodeForPackage( ), preferences API • 723 Utilities, java.util.Collections • 631</p>
<p>Visitor design pattern, and annotations, mirror API</p>
<p>775</p>
<p>Visual BASIC, Microsoft • 1002</p>
<p>visual programming • 1002; environments • 938</p>
<p>volatile • 826, 833, 836</p>
<p>W</p>
<p>wait( ) • 860 waiting, busy • 860 Waldrop, M. Mitchell • 1050 WeakHashMap • 598, 640 WeakReference • 638 web of objects • 704 Web Start, Java • 989 West, BorderLayout • 947 while • 94</p>
<p>widening conversion • 83</p>
<p>wildcards: and Class references • 402; in generics • 483; supertype • 487; unbounded • 489 windowClosing( ) • 982</p>
<p>word tearing, in concurrent programming • 833</p>
<p>write( ) • 657; nio • 681</p>
<p>writeBytes( ) • 670</p>
<p>writeChars( ) • 670</p>
<p>writeDouble( ) • 670</p>
<p>writeExternal( ) • 708</p>
<p>writeObject( ) • 704; with Serializable • 712</p>
<p>Writer • 657, 662, 663</p>
<p>X</p>
<p>XDoclet • 761 XML • 720</p>
<p>XOM XML library • 720 XOR (Exclusive-OR) • 76</p>
<p>Y</p>
<p>You Aren’t Going to Need It (YAGNI) • 427</p>
<p>Z</p>
<p>zero extension • 77 ZipEntry • 701 ZipInputStream • 699 ZipOutputStream • 699</p>
<p>V</p>
<p>value, preventing change at run time • 183 values( ), for enum • 725, 729 varargs • 137, 520; and generic methods • 452 Varga, Ervin • 5, 855</p>
<p>variable: defining a variable • 96; initialization of method variables • 125; local • 48; variable argument lists (unknown quantity and type of arguments) • 137 Vector • 624, 641 vector of change • 266 Venners, Bill • 122 versioning, serialization • 714</p>
</section>
</body>
<body name="notes">
<section id="bookmark0"><title><p>1</p></title>
<p><sup></sup> However, I believe that the Python language comes closest to doing exactly that. See <a l:href="http://www.Python.org">www.Python.org</a>.</p></section>
<section id="bookmark1"><title><p>2</p></title>
<p> began using Enterprise Architect from Sparxsystems on this book, and it has rapidly become my UML tool of choice. Marco Hunsicker’s Jalopy code formatter (<a l:href="http://www.triemax.com">www.triemax.com</a>) came in handy on numerous occasions, and Marco was very helpful in</p></section>
<section id="bookmark2"><title><p>3</p></title>
<p><sup></sup> Some language designers have decided that object-oriented programming by itself is not adequate to easily solve all programming problems, and advocate the combination of various approaches into multiparadigm programming languages. See Multiparadigm Programming in Leda by Timothy Budd (Addison-Wesley, 1995).</p></section>
<section id="bookmark3"><title><p>4</p></title>
<p><sup></sup>    This is actually a bit restrictive, since objects can conceivably exist in different machines and address spaces, and they can also be stored on disk. In these cases, the identity of the object must be determined by something other than memory address.</p></section>
<section id="bookmark4"><title><p>5</p></title>
<p><sup></sup>    Some people make a distinction, stating that type determines the interface while class is a particular implementation of that interface.</p></section>
<section id="bookmark5"><title><p>6</p></title>
<p><sup></sup> I’m indebted to my friend Scott Meyers for this term.</p></section>
<section id="bookmark6"><title><p>7</p></title>
<p><sup></sup> This is usually enough detail for most diagrams, and you don’t need to get specific about whether you’re using aggregation or composition.</p></section>
<section id="bookmark7"><title><p>8</p></title>
<p><sup></sup> They do not hold primitives, but Java SE5 autoboxing makes this restriction almost a non-issue. This is discussed in detail later in the book.</p></section>
<section id="bookmark8"><title><p>9</p></title>
<p><sup></sup> Primitive types, which you’ll learn about later, are a special case.</p></section>
<section id="bookmark9"><title><p>10</p></title>
<p><sup></sup> This can be a flashpoint. There are those who say, “Clearly, it’s a pointer,” but this presumes an underlying implementation. Also, Java references are much more akin to C++ references than to pointers in their syntax. In the 1<sup>st </sup>edition of this book, I chose to invent a new term, “handle,” because C++ references and Java references have some important differences. I was coming out of C++ and did not want to confuse the C++ programmers whom I assumed would be the largest audience for Java. In the 2<sup>nd</sup> edition, I decided that “reference” was the more commonly used term, and that anyone changing from C++ would have a lot more to cope with than the terminology of references, so they might as well jump in with both feet. However, there are people who disagree even with the term “reference.” I read in one book where it was “completely wrong to say that Java supports pass by reference,” because Java object identifiers (according to that author) are actually “object references.” And (he goes on) everything is actually pass by value. So you’re not passing by reference, you’re “passing an object reference by value.” One could argue for the precision of such convoluted explanations, but I think my approach simplifies the understanding of the concept without hurting anything (well, the language lawyers may claim that I’m lying to you, but I’ll say that I’m providing an appropriate abstraction).</p></section>
<section id="bookmark10"><title><p>11</p></title>
<p><sup></sup> static methods, which you’ll learn about soon, can be called for the class, without an object.</p></section>
<section id="bookmark11"><title><p>12</p></title>
<p><sup></sup> Of course, since static methods don’t need any objects to be created before they are used, they cannot directly access non-static members or methods by simply calling those other members without referring to a named object (since nonstatic members and methods must be tied to a particular object).</p></section>
<section id="bookmark12"><title><p>13</p></title>
<p><sup></sup> The Java compiler and documentation from Sun tend to change regularly, and the best place to get them is directly from Sun. By downloading it yourself, you will get the most recent version.</p></section>
<section id="bookmark13"><title><p>14</p></title>
<p><sup></sup> IBM’s “jikes” compiler is a common alternative, as it is significantly faster than Sun’s javac (although if you’re building groups of files using Ant, there’s not too much of a difference). There are also open-source projects to create Java compilers, runtime environments, and libraries.</p></section>
<section id="bookmark14"><title><p>15</p></title>
<p><sup></sup> <a l:href="http://java.sun.com/docs/codeconv/index.html">http://java.sun.com/docs/codeconv/index.html</a>. To preserve space in this book and seminar presentations, not all of these guidelines could be followed, but you’ll see that the style I use here matches the Java standard as much as possible.</p></section>
<section id="bookmark15"><title><p>16</p></title>
<p><sup></sup> The number 47 was considered a “magic number” at a college I attended, and it stuck.</p></section>
<section id="bookmark16"><title><p>17</p></title>
<p><sup></sup> John Kirkham writes, “I started computing in 1962 using FORTRAN II on an IBM 1620. At that time, and throughout the 1960s and into the 1970s, FORTRAN was an all uppercase language. This probably started because many of the early input devices were old teletype units that used 5 bit Baudot code, which had no lowercase capability. The ‘E’ in the exponential notation was also always uppercase and was never confused with the natural logarithm base ‘e’, which is always lowercase. The ‘E’ simply stood for exponential, which was for the base of the number system used—usually 10. At the time octal was also widely used by programmers. Although I never saw it used, if I had seen an octal number in exponential notation I would have considered it to be base 8. The first time I remember seeing an exponential using a lowercase ‘e’ was in the late 1970s and I also found it confusing. The problem arose as lowercase crept into FORTRAN, not at its beginning. We actually had functions to use if you really wanted to use the natural logarithm base, but they were all uppercase.”</p></section>
<section id="bookmark17"><title><p>18</p></title>
<p><sup></sup> Some people will obsessively put this in front of every method call and field reference, arguing that it makes it “clearer and more explicit.” Don’t do it. There’s a reason that we use high-level languages: They do things for us. If you put this in when it’s not necessary, you will confuse and annoy everyone who reads your code, since all the rest of the code they’ve read won’t use this everywhere. People expect this to be used only when it is necessary. Following a consistent and straightforward coding style saves time and money.</p></section>
<section id="bookmark18"><title><p>19</p></title>
<p><sup></sup> The one case in which this is possible occurs if you pass a reference to an object into the static method (the static method could also create its own object). Then, via the reference (which is now effectively this), you can call non-static methods and access non-static fields. But typically, if you want to do something like this, you’ll just make an ordinary, non-static method.</p></section>
<section id="bookmark19"><title><p>20</p></title>
<p><sup></sup> Joshua Bloch goes further in his section titled “avoid finalizers”: “Finalizers are unpredictable, often dangerous, and generally unnecessary.” Effective JavaTMProgramming Language Guide, p. 20 (Addison-Wesley, 2001).</p></section>
<section id="bookmark20"><title><p>21</p></title>
<p>A term coined by Bill Venners (<a l:href="http://www.Artima.com">www.Artima.com</a>) during a seminar that he and I were giving together.</p></section>
<section id="bookmark21"><title><p>22</p></title>
<p><sup></sup> Of course, checking every array access costs time and code and there’s no way to turn it off, which means that array accesses might be a source of inefficiency in your program if they occur at a critical juncture. For Internet security and programmer productivity, the Java designers saw that this was a worthwhile trade-off. Although you may be tempted to write code that you think might make array accesses more efficient, this is a waste of time because automatic compile-time and runtime optimizations will speed array accesses.</p></section>
<section id="bookmark22"><title><p>23</p></title>
<p><sup></sup> See Refactoring: Improving the Design of Existing Code, by Martin Fowler, et al. (Addison-Wesley, 1999). Occasionally someone will argue against refactoring, suggesting that code which works is perfectly good and it’s a waste of time to refactor it. The problem with this way of thinking is that the lion’s share of a project’s time and money is not in the initial writing of the code, but in maintaining it. Making code easier to understand translates into very significant dollars.</p></section>
<section id="bookmark23"><title><p>24</p></title>
<p><sup></sup> There’s nothing in Java that forces the use of an interpreter. There exist native-code Java compilers that generate a single executable file.</p></section>
<section id="bookmark24"><title><p>25</p></title>
<p><sup></sup> When referring to the environment variable, capital letters will be used (CLASSPATH).</p></section>
<section id="bookmark25"><title><p>26</p></title>
<p> Make the member public. Then everybody, everywhere, can access it.</p></section>
<section id="bookmark26"><title><p>27</p></title>
<p><sup></sup> There’s another effect in this case: Since the default constructor is the only one defined, and it’s private, it will prevent inheritance of this class. (A subject that will be introduced later.)</p></section>
<section id="bookmark27"><title><p>28</p></title>
<p><sup></sup> However, people often refer to implementation hiding alone as encapsulation.</p></section>
<section id="bookmark28"><title><p>29</p></title>
<p><sup></sup> Don’t fall prey to the urge to prematurely optimize. If you get your system working and it’s too slow, it’s doubtful that you can fix it with the final keyword. <a l:href="http://MindView.net/Books/BetterJava">http://MindView.net/Books/BetterJava</a> has information about profiling, which can be helpful in speeding up your program.</p></section>
<section id="bookmark29"><title><p>30</p></title>
<p><sup></sup> The constructor is also a static method even though the static keyword is not explicit. So to be precise, a class is first loaded when any one of its static members is accessed.</p></section>
<section id="bookmark30"><title><p>31</p></title>
<p><sup></sup> Thanks to Randy Nichols for asking this question.</p></section>
<section id="bookmark31"><title><p>32</p></title>
<p><sup></sup> For C++ programmers, this ist he analogue of C++’s pure virtual function.</p></section>
<section id="bookmark32"><title><p>33</p></title>
<p><sup></sup> This shows how interfaces prevent the &quot;diamond problem&quot; that occurs with C++ multiple inheritance.</p></section>
<section id="bookmark33"><title><p>34</p></title>
<p><sup></sup> Thanks to Martin Danner for asking about this during a seminar.</p></section>
<section id="bookmark34"><title><p>35</p></title>
<p><sup></sup> This is very different from the design of nested classes in C++, which is simply a namehiding mechanism. There is no link to an enclosing object and no implied permissions in C++.</p></section>
<section id="bookmark35"><title><p>36</p></title>
<p><sup></sup> Thanks again to Martin Danner.</p></section>
<section id="bookmark36"><title><p>37</p></title>
<p><sup></sup> For some reason this has always been a pleasing problem for me to solve; it came from my earlier book C++ Inside &amp; Out, but Java allows a more elegant solution</p></section>
<section id="bookmark37"><title><p>38</p></title>
<p><sup></sup> On the other hand, ‘$’ is a meta-character to the Unix shell and so you’ll sometimes have trouble when listing the .class files. This is a bit strange coming from Sun, a Unix-based company. My guess is that they weren’t considering this issue, but instead thought you’d naturally focus on the source-code files.</p></section>
<section id="bookmark38"><title><p>39</p></title>
<p><sup></sup> A number of languages, such as Perl, Python, and Ruby, have native support for containers.</p>
<p><sup>2</sup> This is a place where operator overloading would have been nice. C+ + and C# container classes produce a cleaner syntax using operator overloading.</p></section>
<section id="bookmark39"><title><p>40</p></title>
<p><sup></sup> At the end of the Generics chapter, you’ll find a discussion about whether this is such a bad problem. However, the Generics chapter will also show you that Java generics are useful for more than just type-safe containers.</p></section>
<section id="bookmark40"><title><p>41</p></title>
<p>    Ask a Collection to hand you an Iterator using a method called iterator( ). That Iterator will be ready to return the first element in the sequence.</p>
<p>2.    Get the next object in the sequence with next( ).</p>
<p>3.    See if there are any more objects in the sequence with hasNext( ).</p></section>
<section id="bookmark41"><title><p>42</p></title>
<p><sup></sup> remove( ) is a so-called &quot;optional&quot; method (there are other such methods), which means that not all Iterator implementations must implement it. This topic is covered in the Containers in Depth chapter. The standard Java library containers implement remove) ), however, so you don’t need to worry about it until that chapter.</p></section>
<section id="bookmark42"><title><p>43</p></title>
<p><sup></sup> This actually depends on the implementation. Priority queue algorithms typically sort on insertion (maintaining a heap), but they may also perform the selection of the most important element upon removal. The choice of algorithm could be important if object priority can change while it is waiting in the queue.</p></section>
<section id="bookmark43"><title><p>44</p></title>
<p><sup></sup> Some people advocate the automatic creation of an interface for every possible combination of methods in a class— sometimes for every single class. I believe that an interface should have more meaning than a mechanical duplication of method combinations, so I tend to wait until I see the value added by an interface before creating one.</p></section>
<section id="bookmark44"><title><p>45</p></title>
<p><sup></sup> The C programmer can look up the return value of printf( ) for an example of this.</p></section>
<section id="bookmark45"><title><p>46</p></title>
<p><sup></sup> Jim Gray, Turing Award winner for his team’s contributions on transactions, in an interview on <a l:href="http://www.acmqueue.org">www.acmqueue.org</a>.</p></section>
<section id="bookmark46"><title><p>47</p></title>
<p><sup></sup> As do most languages, including C++, C#, Python, D, etc.</p></section>
<section id="bookmark47"><title><p>48</p></title>
<p><sup></sup> C+ + exception handling does not have the finally clause because it relies on destructors to accomplish this sort of cleanup.</p>
<p><sup>5</sup> A destructor is a function that’s always called when an object becomes unused. You the destructor gets called. C+ + has automatic destructor calls, and C# (which is much more like Java) has a way that automatic destruction can occur.</p></section>
<section id="bookmark48"><title><p>49</p></title>
<p><sup></sup> ISO C++ added similar constraints that require derived-method exceptions to be the same as, or derived from, the exceptions thrown by the base-class method. This is one case in which C++ is actually able to check exception specifications at compile time.</p></section>
<section id="bookmark49"><title><p>50</p></title>
<p><sup></sup> Barbara Liskov and Alan Snyder, Exception Handling in CLU, IEEE Transactions on Software Engineering, Vol. SE-5, No. 6, November 1979. This paper is not available on the Internet, only in print form, so you’ll have to contact a library to get a copy.</p></section>
<section id="bookmark50"><title><p>51</p></title>
<p><sup></sup>    <a l:href="http://discuss.develop.com/archives/wa.exe?A2=indoonA&amp;L=DOTNET&amp;P=R32820">http://discuss.develop.com/archives/wa.exe?A2=indoonA&amp;L=DOTNET&amp;P=R32820</a></p></section>
<section id="bookmark51"><title><p>52</p></title>
<p><sup></sup>    Exception Handling in CLU, Liskov &amp; Snyder.</p></section>
<section id="bookmark52"><title><p>53</p></title>
<p><sup></sup>    Bjarne Stroustrup, The C++ Programming Language, 3rd Edition (Addison-Wesley, 1997), P- 376.</p></section>
<section id="bookmark53"><title><p>54</p></title>
<p><sup></sup>    Indirectly with Smalltalk via conversations with many experienced programmers in that language; directly with Python (<a l:href="http://www.Python.org">www.Python.org</a>).</p></section>
<section id="bookmark54"><title><p>55</p></title>
<p><sup></sup> Kees Koster, designer of the CDL language, as quoted by Bertrand Meyer, designer of the Eiffel language, <a l:href="http://www.elj.com/elj/vi/ni/bm/right/">www.elj.com/elj/vi/ni/bm/right/</a>.</p></section>
<section id="bookmark55"><title><p>56</p></title>
<p><sup></sup> C++ allows the programmer to overload operators at will. Because this can often be a complicated process (see Chapter 10 of Thinking in C++, 2nd Edition, Prentice Hall, 2000), the Java designers deemed it a &quot;bad&quot; feature that shouldn’t be included in Java. It wasn’t so bad that they didn’t end up doing it themselves, and ironically enough, operator overloading would be much easier to use in Java than in C++. This can be seen in Python (see <a l:href="http://www.Python.org">www.Python.org</a>) and C#, which have garbage collection and straightforward operator overloading.</p></section>
<section id="bookmark56"><title><p>57</p></title>
<p><sup></sup> Mark Welsh assisted in the creation of this section, and the &quot;Scanning input&quot; section.</p></section>
<section id="bookmark57"><title><p>58</p></title>
<p><sup></sup> Quote from one of Commander Taggart’s speeches on Galaxy Quest.</p>
<p><sup>4</sup> I have no idea how they came up with this method name, or what it’s supposed to refer to. But it’s reassuring to know that whoever comes up with nonintuitive method names is still employed at Sun. And that their apparent policy of not reviewing code designs is still in place. Sorry for the sarcasm, but this kind of thing gets tiresome after a few years.</p></section>
<section id="bookmark58"><title><p>59</p></title>
<p><sup></sup> Especially in the past. However, Sun has greatly improved its HTML Java documentation so that it’s easier to see base-class methods.</p></section>
<section id="bookmark59"><title><p>60</p></title>
<p><sup></sup> A tenet of Extreme Programming (XP), as is &quot;Do the simplest thing that could possibly work.&quot;</p></section>
<section id="bookmark60"><title><p>61</p></title>
<p><sup></sup> The most famous case of this is the Windows operating system, which had a published API that you were supposed to write to, and an unpublished but visible set of functions that you could discover and call. To solve problems, programmers used the hidden API functions, which forced Microsoft to maintain them as if they were part of the public API. This became a source of great cost and effort for the company.</p></section>
<section id="bookmark61"><title><p>62</p></title>
<p><sup></sup> Angelika Langer’s Java Generics FAQ (see <a l:href="http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html">www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html</a>) as well as her other writings (together with Klaus Kreft) have been invaluable during the preparation of this chapter.</p></section>
<section id="bookmark62"><title><p>63</p></title>
<p><sup></sup> Or a class with all private constructors.</p></section>
<section id="bookmark63"><title><p>64</p></title>
<p><sup></sup> <a l:href="http://gafter.biogspot.com/2004/og/puzziing-through-erasure-answer.htmi">http://gafter.biogspot.com/2004/og/puzziing-through-erasure-answer.htmi</a></p></section>
<section id="bookmark64"><title><p>65</p></title>
<p><sup></sup>    Note that some programming environments, such as Eclipse and IntelliJ Idea, will automatically generate delegation code.</p></section>
<section id="bookmark65"><title><p>66</p></title>
<p><sup></sup>    Patterns are the subject of Thinking in Patterns (with Java), which you can find at <a l:href="http://www.MindView.net">www.MindView.net</a>. See also Design Patterns, by Erich Gamma et al. (Addison-Wesley, 1995)-</p></section>
<section id="bookmark66"><title><p>67</p></title>
<p>The Ruby and Smalltalk languages also support latent typing.</p></section>
<section id="bookmark67"><title><p>68</p></title>
<p><sup></sup>    Because you can use casts, which effectively disable the type system, some people argue that C++ is weakly typed, but that’s extreme. It’s probably safer to say that C++ is &quot;strongly typed with a trap door.&quot;</p></section>
<section id="bookmark68"><title><p>69</p></title>
<p><sup></sup>    The implementation of Java’s generics using erasure is sometimes referred to as secondclass generic types.</p></section>
<section id="bookmark69"><title><p>70</p></title>
<p><sup></sup> See citation at the end of this chapter.</p></section>
<section id="bookmark70"><title><p>71</p></title>
<p><sup></sup> You will sometimes see these called functors. I will use the term function object rather than<sup>A</sup>unctor, as the term &quot;functor&quot; has a specific and different meaning in mathematics.</p></section>
<section id="bookmark71"><title><p>72</p></title>
<p> believe the intent of the general-purpose language feature called &quot;generics&quot; (not necessarily Java’s particular implementation of it) is expressiveness, not just creating type-safe containers. Type-safe containers come as a side effect of the ability to create more general-purpose code.</p></section>
<section id="bookmark72"><title><p>73</p></title>
<p><sup></sup> Although this is a place where things are a bit fuzzy. You could also make an argument that a Generator represents the Command pattern. However, I think that the task is to fill an array, and the Generator fulfills part of that task, so it’s more strategy-like than command-like.</p></section>
<section id="bookmark73"><title><p>74</p></title>
<p><sup></sup> Design Patterns, Erich Gamma et al. (Addison-Wesley, 1995). See Thinking in Patterns (with Java) at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p></section>
<section id="bookmark74"><title><p>75</p></title>
<p><sup></sup> See <a l:href="http://www.Python.org">www.Python.org</a>.</p></section>
<section id="bookmark75"><title><p>76</p></title>
<p><sup></sup> See <a l:href="http://www.php.net">www.php.net</a>.</p></section>
<section id="bookmark76"><title><p>77</p></title>
<p><sup></sup> This may not be a strict definition of adapter as defined in the Design Patterns book, but I think it meets the spirit of the idea.</p></section>
<section id="bookmark77"><title><p>78</p></title>
<p><sup></sup> This data was found on the Internet. Various corrections have been submitted by readers over time.</p></section>
<section id="bookmark78"><title><p>79</p></title>
<p><sup></sup> The Maps in java.util perform bulk copies using getKey( ) and getValue( ) for Maps, so this works. If a custom Map were to simply copy the entire Map.Entry then this approach would cause a problem.</p></section>
<section id="bookmark79"><title><p>80</p></title>
<p><sup></sup>    I am using the term &quot;interface&quot; here to describe both the formal interface keyword and the more general meaning of &quot;the methods supported by any class or subclass.&quot;</p></section>
<section id="bookmark80"><title><p>81</p></title>
<p><sup></sup>    Although this sounds odd and possibly useless when I describe it this way, you’ve seen, especially in the Type Information chapter, that this kind of dynamic behavior can be very powerful.</p></section>
<section id="bookmark81"><title><p>82</p></title>
<p><sup></sup> If these speedups still don’t meet your performance needs, you can further accelerate table lookup by writing your own Map and customizing it to your particular types to avoid delays due to casting to and from Objects. To reach even higher levels of performance, speed enthusiasts can use Donald Knuth’s The Art of Computer Programming, Volume 3: Sorting and Searching, Second Edition, to replace overflow bucket lists with arrays that have two additional benefits: they can be optimized for disk storage characteristics and they can save most of the time of creating and garbage collecting individual records.</p></section>
<section id="bookmark82"><title><p>83</p></title>
<p><sup></sup> The case of a perfect hashing function is implemented in the Java SE5 EnumMap and EnumSet, because an enum defines a fixed number of instances. See the Enumerated Types chapter.</p></section>
<section id="bookmark83"><title><p>84</p></title>
<p><sup></sup> As it turns out, a prime number is not actually the ideal size for hash buckets, and recent hashed implementations in Java use a power-of-two size (after extensive testing). Division or remainder is the slowest operation on a modern processor. With a power-of-two hash table length, masking can be used instead of division. Since get( ) is by far the most common operation, the % is a large part of the cost, and the power-of-two approach eliminates this (but may also affect some hashCode( ) methods).</p></section>
<section id="bookmark84"><title><p>85</p></title>
<p>    Or as an EnumSet or CopyOnWriteArraySet, which are special cases. While acknowledging that there maybe additional specialized implementations of various container interfaces, this section attempts to look at the more general cases.</p></section>
<section id="bookmark85"><title><p>86</p></title>
<p><sup></sup>    Krzysztof Sobolewski assisted me in figuring out the generics for this example.</p></section>
<section id="bookmark86"><title><p>87</p></title>
<p><sup></sup> In a private message, Joshua Bloch wrote: &quot;... I believe that we erred by allowing implementation details (such as hash table size and load factor) into our APIs. The client should perhaps tell us the maximum expected size of a collection, and we should take it from there. Clients can easily do more harm than good by choosing values for these parameters. As an extreme example, consider Vector’s capacitylncrement. No one should ever set this, and we shouldn’t have provided it. If you set it to any nonzero value, the asymptotic cost of a sequence of appends goes from linear to quadratic. In other words, it destroys your performance. Over time, we’re beginning to wise up about this sort of thing. If you look at IdentityHashMap, you’ll see that it has no low-level tuning parameters.&quot;</p></section>
<section id="bookmark87"><title><p>88</p></title>
<p><sup></sup> It’s not clear that this was a good design decision, especially compared to the simplicity of I/O libraries in other languages. But it’s the justification for the decision.</p></section>
<section id="bookmark88"><title><p>89</p></title>
<p><sup></sup> In the original design, close( ) was supposed to be called when finalize( ) ran, and you will see finalize( ) defined this way for I/O classes. However, as is discussed elsewhere in this book, the finalize( ) feature didn’t work out the way the Java designers originally envisioned it (that is to say, it’s irreparably broken), so the only safe approach is to explicitly call close( ) for files.</p></section>
<section id="bookmark89"><title><p>90</p></title>
<p><sup></sup> XML is another way to solve the problem of moving data across different computing platforms, and does not depend on having Java on all platforms. XML is introduced later in this chapter.</p></section>
<section id="bookmark90"><title><p>91</p></title>
<p><sup></sup> The Graphical User Interfaces chapter shows an even more convenient solution for this: a GUI program with a scrolling text area.</p></section>
<section id="bookmark91"><title><p>92</p></title>
<p><sup></sup> More details about threads will be found in the Concurrency chapter.</p></section>
<section id="bookmark92"><title><p>93</p></title>
<p><sup></sup> The section &quot;Interfaces and type information&quot; at the end of the Type Information chapter shows how it’s possible to access private methods from outside of the class.</p></section>
<section id="bookmark93"><title><p>94</p></title>
<p><sup></sup> Projects are suggestions to be used (for example) as term projects. Solutions to projects are not included in the solution guide.</p></section>
<section id="bookmark94"><title><p>95</p></title>
<p><sup></sup>    Projects are suggestions to be used (for example) as term projects. Solutions to projects are not included in the solution guide.</p></section>
<section id="bookmark95"><title><p>96</p></title>
<p><sup></sup>    This example existed for a number of years in both C++ and Java (in Thinking in Patterns) on <a l:href="http://www.MindView.net">www.MindView.net</a> before it appeared, without attribution, in a book by other authors.</p></section>
<section id="bookmark96"><title><p>97</p></title>
<p><sup></sup>    Jeremy Meyer came to Crested Butte and spent two weeks with me working on this chapter. His help was invaluable.</p></section>
<section id="bookmark97"><title><p>98</p></title>
<p><sup></sup>    This was no doubt inspired by a similar feature in C#. The C# feature is a keyword and not an annotation, and is enforced by the compiler. That is, when you override a method in C#, you must use the override keyword, whereas in Java the (©Override annotation is optional.</p></section>
<section id="bookmark98"><title><p>99</p></title>
<p><sup></sup> Projects are suggestions to be used (for example) as term projects. Solutions to projects are not included in the solution guide.</p></section>
<section id="bookmark99"><title><p>100</p></title>
<p><sup></sup>    However, using the non-standard -XclassesAsDecls option, you may work with annotations that are in compiled classes.</p></section>
<section id="bookmark100"><title><p>101</p></title>
<p><sup></sup>    The Java designers coyly suggest that a mirror is where you find a reflection.</p></section>
<section id="bookmark101"><title><p>102</p></title>
<p><sup></sup>    I originally had thoughts of making a &quot;better JUnit&quot; based on the design shown here. However, it appears that JUnit4 also includes many of the ideas presented here, so it remains easier to go along with that.</p></section>
<section id="bookmark102"><title><p>103</p></title>
<p><sup></sup>    This library is part of this book’s code package, available at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p></section>
<section id="bookmark103"><title><p>104</p></title>
<p><sup></sup>    It is not clear why the default constructor for the class under test must be public, but if it isn’t, the call to newlnstance( ) just hangs (doesn’t throw an exception).</p></section>
<section id="bookmark104"><title><p>105</p></title>
<p><sup></sup>    Jeremy Meyer and I spent most of a day figuring this out.</p>
<p><sup>10</sup> Various legends surround the meaning of this, but since Java was created by nerds we can make a reasonable guess that it had something to do with fantasizing about a woman in a coffee shop.</p></section>
<section id="bookmark105"><title><p>106</p></title>
<p><sup></sup> Thanks to Dr. Shigeru Chiba for creating this library, and for all his help in developing AtUnitRemover.java.</p></section>
<section id="bookmark106"><title><p>107</p></title>
<p><sup></sup> Dr. Shigeru Chiba very nicely added the CtClass.removeMethod( ) at our request.</p></section>
<section id="bookmark107"><title><p>108</p></title>
<p><sup></sup>    Eric Raymond, for example, makes a strong case in The Art of UNIX Programming (Addison-Wesley, 2004).</p></section>
<section id="bookmark108"><title><p>109</p></title>
<p><sup></sup>    It could be argued that trying to bolt concurrency onto a sequential language is a doomed approach, but you’ll have to draw your own conclusions.</p></section>
<section id="bookmark109"><title><p>110</p></title>
<p><sup></sup>    This requirement was never completely fulfilled and is no longer so loudly touted by Sun. Ironically, one reason that &quot;write once/run everywhere&quot; didn’t completely work may have resulted from problems in the threading system—which might actually be fixed in Java SE5.</p></section>
<section id="bookmark110"><title><p>111</p></title>
<p><sup></sup> This is true when the system uses time slicing (Windows, for example). Solaris uses a FIFO concurrency model: Unless a higher-priority thread is awakened, the current thread runs until it blocks or terminates. That means that other threads with the same priority don’t run until the current one gives up the processor.</p></section>
<section id="bookmark111"><title><p>112</p></title>
<p><sup></sup> In this case, a single thread (main( )), is creating all the LiftOff threads. If you have multiple threads creating LiftOff threads, however, it is possible for more than one LiftOff to have the same id. You’ll learn why later in this chapter.</p></section>
<section id="bookmark112"><title><p>113</p></title>
<p><sup></sup> This was not true for some of the earliest versions of Java.</p></section>
<section id="bookmark113"><title><p>114</p></title>
<p><sup></sup> It also offers an important concurrency guarantee that the others do not—no two tasks will be called concurrently. This changes the locking requirements for the tasks (you’ll learn about locking later in the chapter).</p></section>
<section id="bookmark114"><title><p>115</p></title>
<p><sup></sup>    Effective Java™ Programming Language Guide, by Joshua Bloch (Addison-Wesley, 2001), p. 211.</p></section>
<section id="bookmark115"><title><p>116</p></title>
<p><sup></sup>    And in a number of other places throughout the experience of Java. Well, why stop there? I’ve consulted on more than a few projects where this has applied.</p></section>
<section id="bookmark116"><title><p>117</p></title>
<p><sup></sup> From Brian Goetz, author of Java Concurrency in Practice, by Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea (Addison-Wesley, 2006).</p></section>
<section id="bookmark117"><title><p>118</p></title>
<p><sup></sup>    After the previously mentioned Brian Goetz, a concurrency expert who helped with this chapter, based on only partially tongue-in-cheek comments from him.</p></section>
<section id="bookmark118"><title><p>119</p></title>
<p><sup></sup>    A corollary to this test is, &quot;If someone implies that threading is easy and straightforward, make sure that person is not making important decisions about your project. If that person already is, then you’ve got trouble.&quot;</p></section>
<section id="bookmark119"><title><p>120</p></title>
<p><sup></sup> This is being remedied in the upcoming C++ standard.</p></section>
<section id="bookmark120"><title><p>121</p></title>
<p><sup></sup> Inspired by Joshua Bloch’s Effective Java™Programming Language Guide (Addison- Wesley, 2001), p. 190.</p></section>
<section id="bookmark121"><title><p>122</p></title>
<p><sup></sup> See Design Patterns, by Gamma et al. (Addison-Wesley, 1995).</p></section>
<section id="bookmark122"><title><p>123</p></title>
<p><sup></sup> However, exceptions are never delivered asynchronously. Thus, there is no danger of something aborting mid-instruction/method call. And as long as you use the try-finally idiom when using object mutexes (vs. the synchronized keyword), those mutexes will be automatically released if an exception is thrown.</p></section>
<section id="bookmark123"><title><p>124</p></title>
<p><sup></sup> Some releases of the JDK also provided support for InterruptedIOException. However, this was only partially implemented, and only on some platforms. If this exception is thrown, it causes 10 objects to be unusable. Future releases are unlikely to continue support for this exception.</p></section>
<section id="bookmark124"><title><p>125</p></title>
<p><sup></sup> Ervin Varga helped research this section.</p></section>
<section id="bookmark125"><title><p>126</p></title>
<p><sup></sup> Note that, although it’s unlikely, the call to t.interrupt( ) could actually happen before the call to blocked.f( ).</p></section>
<section id="bookmark126"><title><p>127</p></title>
<p><sup></sup> On some platforms there’s a third way to come out of a wait( ): the so-called spurious wake-up. A spurious wake-up essentially means that a thread may prematurely stop blocking (while waiting on a condition variable or semaphore) without being prompted by a notify( ) or notifyAll( ) (or their equivalents for the new Condition objects). The thread just wakes up, seemingly by itself. Spurious wake-ups exist because implementing POSIX threads, or the equivalent, isn’t always as straightforward as it should be on some platforms. Allowing spurious wake-ups makes the job of building a library like pthreads easier for those platforms.</p></section>
<section id="bookmark127"><title><p>128</p></title>
<p><sup></sup> You can also have livelock when two tasks are able to change their state (they don’t block) but they never make any useful progress.</p></section>
<section id="bookmark128"><title><p>129</p></title>
<p><sup></sup> As a freshman in high school; the classroom had an ASR-33 teletype with a 110-baud acoustic-coupler modem accessing an HP-1000.</p></section>
<section id="bookmark129"><title><p>130</p></title>
<p> tried having each horse print itself, but then the order of display was dependent on the task manager. The CyclicBarrier allows each horse to do whatever it needs to do in order to move forward, and then it has to wait at the barrier until all the other horses have moved forward. When all horses have moved, the CyclicBarrier automatically calls its Runnable barrieraction task to display the horses in order, along with the fence.</p></section>
<section id="bookmark130"><title><p>131</p></title>
<p><sup></sup> Brian Goetz was very helpful in explaining these issues to me. See his article at www-128.ibm.com/developerworks/library/j-jtp12214 for more about performance measurement.</p></section>
<section id="bookmark131"><title><p>132</p></title>
<p><sup></sup> See Thinking in Patterns at <a l:href="http://www.MindView.net">www.MindView.net</a>.</p></section>
<section id="bookmark132"><title><p>133</p></title>
<p><sup></sup> For an introduction to benchmarking under the influence of Java’s dynamic compilation, see www-128.ibm.com/developerworks/library/j-jtp12214.</p></section>
<section id="bookmark133"><title><p>134</p></title>
<p><sup></sup> Thanks to Allen Holub for taking the time to explain this to me.</p></section>
<section id="bookmark134"><title><p>135</p></title>
<p><sup></sup>    A variation on this is called &quot;the principle of least astonishment,&quot; which essentially says, &quot;Don’t surprise the user.&quot;</p></section>
<section id="bookmark135"><title><p>136</p></title>
<p><sup></sup>    Note that IBM created a new open-source GUI library for their Eclipse editor (<a l:href="http://www.Eclipse.org">www.Eclipse.org</a>), which you may want to consider as an alternative to Swing. This will be introduced later in the chapter.</p></section>
<section id="bookmark136"><title><p>137</p></title>
<p><sup></sup> My favorite example of this is Ken Arnold’s &quot;Napkin&quot; look and feel, which makes the windows look like they were scribbled on a napkin. See <a l:href="http://napkinlaf.sourceforge.net">http://napkinlaf.sourceforge.net</a>.</p></section>
<section id="bookmark137"><title><p>138</p></title>
<p><sup></sup> Technically, the event dispatch thread comes from the AWT library.</p></section>
<section id="bookmark138"><title><p>139</p></title>
<p><sup></sup> This practice was added in Java SE5, so you will see lots of older programs that don’t do it. That doesn’t mean the authors were ignorant. The suggested practices seem to be constantly evolving.</p></section>
<section id="bookmark139"><title><p>140</p></title>
<p><sup></sup> In Java 1.0/1.1 you could not usefully inherit from the button object. This was only one of numerous fundamental design flaws.</p></section>
<section id="bookmark140"><title><p>141</p></title>
<p><sup></sup> You may argue about whether the Swing rendering does justice to your operating environment.</p></section>
<section id="bookmark141"><title><p>142</p></title>
<p><sup></sup> Jeremy Meyer developed this section.</p></section>
<section id="bookmark142"><title><p>143</p></title>
<p><sup></sup> Sean Neville created the core of the material in this section.</p></section>
<section id="bookmark143"><title><p>144</p></title>
<p><sup></sup> Note that you must download Flex, and not FlexBuilder. The latter is an IDE design tool.</p></section>
<section id="bookmark144"><title><p>145</p></title>
<p><sup></sup> Chris Grindstaff was very helpful in translating SWT examples and providing SWT information.</p></section>
</body>
<binary id="image1.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAB7AI4BAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKQ15d438ST3t/N&#xd;&#xa;p9u7R2sJKOo48xgeSfbjiuSrqvBXiKey1OCynmLWcx2bWBOxj0x+OBXqg6Vx/jrxHNpUcVnYSBLm&#xd;&#xa;UbncclF7Y+vNeZO5dy7EszHJJ7mt3wv4lm0K42N+8s5GzJHjJHuvvXrsE0dxBHNE26ORQ6nGMgjI&#xd;&#xa;qSiiiiiiiikNeG6xG0esXqOMMJ3yP+BGqVanh2yubzW7QW8LyeXMjuVHCgEEknt0r2uvLfiJYXMe&#xd;&#xa;uNevGfs8yqqOCDyAMj2rkqWvbfD6umg2Cu25vs6c/wDARWlRRRRRRRRSYzXIeLfBx1aY3lg8cdxj&#xd;&#xa;50YYEnvkd65YeAtdzzDF/wB/RXbeDNBl0PTpVuhH9olfcSnOFxwM/nXRVR1vTYtW0qe0lUNvXKZJ&#xd;&#xa;GG7Hj3rzZvAWuBiFihIB6iUc1seHvAUkVwtxrBQqjcQKchvQk/0rvlVUUKoAAGAB0FOoooooooop&#xd;&#xa;K4zxf4xfS7hrDTgpuAP3kjDITI4A9T9a43/hLdezn+0pfyH+Fdd4X8bi7ZLPVSFnYkLMAFVvQH0P&#xd;&#xa;0rtx0rmvE3i230VPJg2z3mceXnhPdq8/vPFWsXk4le9dNr70WP5Qp7f5Nb/hvxzc/aorXVnR4WOP&#xd;&#xa;PIwy8cZx1Gf516MGDAEEEHkEUtFFFFFFFFIa8M1gs2sXpcksZ3yT1+8ap0q9at299f28Mq29zPHE&#xd;&#xa;/EgRyAfrVUknrTaWvavDDM3hzTy5JPkL1+latFFFFFFFFJXnnjjwtcPeS6pYRh42XdMi8FSOre+e&#xd;&#xa;tcSLW4JA8iU/8ANdr4S8FvI4vdXhKxjmO3b+L3YentXoEcMSRCNI1VAAAoHAArlfFXg+DUYDcadC&#xd;&#xa;kV2uWKrhRL35989/evNpbK6hkMcltKjrwQUPFb3hfwlc6vOs10jwWSnliMF8dgP616vHGkUaxxqF&#xd;&#xa;RQAqgYAA7U+iiiiiiiikrn/Eviq20HEWwz3TDIjBwAPUmuOj+IeriVTJFbPGDyoUgkfXNd34b1yL&#xd;&#xa;XdO+0ohjdW2SIecHrwe45rWqpqmoRaZp015MfkiXOM43HsPxNefXXxF1B5R9ltoYYx1V8uT+PFdB&#xd;&#xa;4c8bQ6xeizuLf7PM/wDqyG3BvbpxXWUtFFFFFFFFMlcJGznOFBJxXiOtahJqerXN3ISfMc7QRjC9&#xd;&#xa;h+VUa3PCWs3Wl6tFHAVMdzIkciMOCCcZ+ozXsQrzT4iaxcvqTaUCEtogrEDq5IB5+lcZTopGikV0&#xd;&#xa;JDKcgg4xXuOk3n2/TLW6I2tNErkehI5q5RRRRRRRRSGvJvGegT6bqk11HE7Wc7l1cchSeSD+tc13&#xd;&#xa;rp/B3hu51K/hvXBitYJA28/xEcgD9K9XHSvPvHvhy7nvTqlqjTIygSqoyVwOv0xXBEYrT0DRrjWd&#xd;&#xa;QjhijYxbh5kmOEHua9ohiSCFIol2xxqFUegHAFSUUUUUUUUUU1lDAhgCD1BrLj8N6PDdC5j0+FZR&#xd;&#xa;yCBwPw6VqKoVdqgADoBTqSs270DSr2YS3NhDJJnO4jGfrjrV23t4rWJYoI1jjXoqjAFTUUUUUUlG&#xd;&#xa;aM0ZozRRRmijNGaM0A0ZozRmjNFcRo2gTajpNteSa/qSPMm4qJzgfrSaMt5pnjf+zX1O4vIGgL/v&#xd;&#xa;WJ9x1JpdYjuL/wAcjTxqN1awNbh/3MpXkA9ulN13QbjTdJnvIfEN+zQgNtknOG56cHrW9oFxLceE&#xd;&#xa;beaV2aU25y5PJxkZz68Vx2gLDqGnefqHim6tJt5Xyzd7ePXk11Oj6CIriC+i12+vIhkhWm3I/BH4&#xd;&#xa;1l+LtS1Kx8U2A05pHJg3GAH5X5bOR9BXQaB4gtddty9vlJU/1kTdV/xFYvhhrjUpPENtLeTgeeY0&#xd;&#xa;feSYwS33fSqHinSLrQ9KF3DrepSt5gTa8xxzn0PtW9pfhyW2nt7ttZ1CbaAxiklJVsjv+dVormf/&#xd;&#xa;AIWRNbmeQwC23CLeducDnHSq/jG8vW17S9Mgu5beC5ZQ5iO1uWxnPWp7jwncR28rx69qruqEqvnH&#xd;&#xa;5jjgVf8ACD6m+iqurJIs6OVXzRhimBgn9ffiuR0nZfy3p1HxLc2LRzlUT7VtyPxNblr4cS9iMln4&#xd;&#xa;o1CdAdpaO43AH0yD71R0PwPpeo6Na3c8t0skqbmCuoAP/fNb+jeEdN0W8+1WrTvLt2gyuDgd8YAr&#xd;&#xa;A1rSYNY8fi0ujIsTW4JKEA5APsayfEPhVdDvI7grPcaWzAMVYeYvtnGPxxXe6dPp8+gMNKYG1jjZ&#xd;&#xa;FABG3joc8157oGp6DZad5WqaVJc3G8neIweOw5IrrtC8W6VdXNtpdjZXMAbIQFFCrwT61FrIJ+Im&#xd;&#xa;jHHHkn/2el8QeGbhLw6xoUnkXigtIgOBJ349z+Rqv8OZJJpNXlmXZJJMrMMYwTuzVz4jgnw0MDP7&#xd;&#xa;9P5Gumtf+PWH/cX+VcpED/ws+ZscfZRz+Aqn44ka08SaRqDxSPBAQzFBno+cfWrE/wAQ9PaCRYba&#xd;&#xa;9WUqQjFFwDjg9a1PBl1f3uifadSkMkryHaSgU7cDHAA75riNL1DRbGe+XV9Ne7kadijKgO0Z6ckV&#xd;&#xa;vWXjbQdPiMVnpl3BGzbiqRqBn1+97Cu4AxS0mKCKydO1+11DVLvToYplltSQ7OBtODjjmtC6nW1t&#xd;&#xa;ZrhwSkSF2A6kAZ4qPTL+PU9PhvYFdY5RlQ+ARzjn8qp694gs9Aiiku0lfzWKqIwCeO/JFWtM1K31&#xd;&#xa;Wxiu7UkxyDoeqnuD71Bq2tW+kTWkc8crNdSeWnlgHB465I9a0+tVdTv49M0+a8mV2jhGWCAZPOOP&#xd;&#xa;zpdPvE1Cxhu4lZY5lDqHxkA+tWcUUYoopaKKSvNLD+2P+Ew1r+xTD5vmvv8AN6bd/wDjWnqA8Zf2&#xd;&#xa;ddfaWs/I8p/M24ztwc4/Ctzwg6x+EbF5GCqsZJYnAA3GuMOsaZqvi6W91aYLYwqUhRoy4ccgZAB9&#xd;&#xa;Sas+DdZtdO1u502OcyWVxJ/o7ncMHPAwRxnj8q1vHf8Ax/6D/wBfX9VrsKxfGX/Iq6h/1zH/AKEK&#xd;&#xa;l8K/8izp3/XBf5VrUUUUUUUUVzmh2cEHiPU5o49skjNuOSc/NW1qKLJp10jjKtE4I9sGsb7LCvgr&#xd;&#xa;7MqkQ+Xt2hj03evWrOg6ZYxaRbqlpDjBJJQEnk9SetUfE+m2TSWLi3RHRyVaP5COncYp/jC1huFs&#xd;&#xa;2lUlo3ZkIYqVPHPFYe6f/n9vv/AuX/4qtmGIXHhO8juHlmVmIPmys5x8vcnNYcSPDGsUNzdxxoMK&#xd;&#xa;qXUgAHsA1dJ4VLlbnfNPLyuPNmaTHXpuJxW/RRRX/9k=</binary>
<binary id="image2.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2Nj&#xd;&#xa;Y2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCADDAxYDASIA&#xd;&#xa;AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA&#xd;&#xa;AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3&#xd;&#xa;ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm&#xd;&#xa;p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA&#xd;&#xa;AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx&#xd;&#xa;BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK&#xd;&#xa;U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3&#xd;&#xa;uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD0Cqcb&#xd;&#xa;udSnQklQBgenAqrLrG45tlBAyG3juPoadZ3kBeSaeaJJHxld2MYrjnXjOooReqev3AadFVv7Rs/+&#xd;&#xa;fmL/AL6FH9o2f/PzF/32K6eePcCzRVb+0bP/AJ+Yv++xR/aFn/z8xf8AfQp88e4Fmiq39oWf/PzF&#xd;&#xa;/wB9Cj+0LP8A5+Yv++hS549wLNFVv7Qs/wDn5i/76FH9oWf/AD8xf99Cjnj3As0VW/tCz/5+Yv8A&#xd;&#xa;voUf2hZ/8/MX/fQo549wLNFVv7Qs/wDn5i/76FH9oWf/AD8xf99Cjnj3As0VW/tCz/5+Yv8AvoUf&#xd;&#xa;2jZ/8/UX/fQo549wLNFVv7Qs/wDn5i/76FH9o2f/AD8xf99ijnj3As02QbkYe1Qf2hZ/8/MX/fQo&#xd;&#xa;/tCz/wCfmL/voUOUWtwKmn3T+cYZGJ9Ca1K58SIl75iupQPnd2rX/tGz/wCfmL/voVx4OreLjJ7M&#xd;&#xa;CzRVb+0LP/n5i/76FH9oWf8Az8xf99Cuznj3As0VW/tCz/5+Yv8AvoUf2hZ/8/MX/fQo549wLNFV&#xd;&#xa;v7Qs/wDn5i/76FB1C0x/x8xf99Cjnj3Aq397JFP5cRAwOeKu2cjTWyO3UjmsGeTzZnc9Cc5Na9ve&#xd;&#xa;WcMCR/aovlGPvCvPwtaU6snJ6CL1FVf7Qs/+fmL/AL6FH9oWn/PzF/32K9Hnj3GWqKq/2jZ/8/MX&#xd;&#xa;/fQo/tGz/wCfmL/voUuePcC1RVT+0rL/AJ+ov++hR/aVl/z9Rf8AfQp88e4Fuiqn9pWX/P1F/wB9&#xd;&#xa;Cj+0rL/n6i/76FHPHuBboqp/aVl/z9Rf99Cj+0rL/n6i/wC+hRzx7gW6Kqf2lZf8/UX/AH2KP7Ss&#xd;&#xa;v+fqL/voUc8e4XLdFVP7Ssv+fqL/AL6FH9pWX/P1F/30KOePcC3RVT+0rL/n6i/76FH9pWX/AD9R&#xd;&#xa;f99Cjnj3At0VU/tKy/5+ov8AvoUf2lZf8/UX/fQo549wLdFVP7Ssv+fqL/vsUf2lZf8AP1F/32KO&#xd;&#xa;ePcLluiqn9pWX/P1F/30KP7Tsv8An6i/77FHPHuK5boqp/aVl/z9Rf8AfQo/tKy/5+ov++hRzx7j&#xd;&#xa;LdFVP7Ssv+fqL/voUf2lZf8AP1F/30KOePcC3RVT+0rL/n6i/wC+hR/aVl/z9Rf99Cjnj3At0VU/&#xd;&#xa;tKy/5+ov++hR/aVl/wA/UX/fQo549wLdFVP7Ssv+fqL/AL6FH9pWX/P1F/30KOePcC3RVT+0rL/n&#xd;&#xa;6i/76FH9pWX/AD9Rf99Cjnj3At0VU/tKy/5+ov8AvoUf2lZf8/UX/fQo549wLdFVP7Ssv+fqL/vo&#xd;&#xa;Uf2lZf8AP1F/30KOePcC3RVT+0rL/n6i/wC+hR/aVl/z9Rf99Cjnj3At0VU/tKy/5+ov++hR/aVl&#xd;&#xa;/wA/UX/fQo549wLdFVP7Ssv+fqL/AL6FH9pWX/P1F/30KOePcC3RVT+0rL/n6i/76FH9pWX/AD9R&#xd;&#xa;f99Cjnj3At0VU/tKy/5+ov8AvoUf2lZf8/UX/fQo549wLdFVP7Ssv+fqL/voUf2lZf8AP1F/30KO&#xd;&#xa;ePcC3RVT+0rL/n6i/wC+hR/aVl/z9Rf99Cjnj3At0VU/tKy/5+ov++hR/aVl/wA/UX/fQo549wLd&#xd;&#xa;FVP7Ssv+fqL/AL6FH9pWX/P1F/30KOePcC3RVT+0rL/n6i/76FH9pWX/AD9Q/wDfYo549wLdFVP7&#xd;&#xa;Ss/+fqL/AL7FH9pWX/P1F/32KOePcVy3RVT+0rL/AJ+ov++hR/aVl/z9Rf8AfQo549xluiqn9pWX&#xd;&#xa;/P1F/wB9Cj+0rL/n6i/76FHPHuBboqp/aVl/z9Rf99ij+0rL/n6i/wC+hRzx7gW6KZFKkyb43DL6&#xd;&#xa;in1QBRRRQBxS3KxLMo5fzG/DmqxJJJJyTT0i864mUMAfMb+dNdCjlW4IrwKiSqSAbRmiioGLRSUt&#xd;&#xa;IQUU8RueiH8qYcg4NAgoopR1oASirn2RCAQzVXmTy5CoOaSknsCZHRRS0wEp8WDKoIBGabQhw4Pv&#xd;&#xa;QBp7FAOFH5VmN94/WtTqKzG+8frWVNvUBtFLRWoFq2fdC0Z6iqmMU5WKnIPNITk5pJWYCUU4I56I&#xd;&#xa;fypCCpwRg0wEooooAKcmN659aspao0atubJFQ3EQicAHORmkpJ6AT3VwNpRD16mqeB6UUtEVyrQB&#xd;&#xa;KVfvDNFJTA1AiDoq/lWdN/rm+taKHKA+1Z03+ub61lTbuxEB6milPU0+GEzFgpAIGcGuu9kQR0Ur&#xd;&#xa;KUYqwwRSU7gFT2Vq95cLFHx6nHQVBW/4ajHlzynqSFFXBc0rDirsuwaPZwoAYhIe7P3on0aylXiI&#xd;&#xa;Rn1TinXN4yOUj7dTTIr592JACPWqeIoqXIdaou17HPahYSWM21zuU/dYd6q11msQLcac57oN6muT&#xd;&#xa;qakeV6HLONmFFFFQSFKqs7bVBJPQCkqW3uGtpRIoHuD3oVuoF230otgzsV/2RVpdOtQP9Xn3Jpgu&#xd;&#xa;ba7QBm8t/Q8U02o6/aE2+tabbIoWXS4GB8slD9eKzLi3kt5Nrjr0I6GtHz7W158wyv7dBVC6u5Lp&#xd;&#xa;gW4UdFFJ2sJkFFFFQIKKKKACiiigAoopOaAFooooAKKKKAsFFFFABRSZpaACiiigAoopM0ALRRmi&#xd;&#xa;gAooozQAUUUUBYKKKKACiiigAooooAKfFC8zhIxk0ypIJ3t5A8Zwf500Bow6bDHjz3DN6ZwKtCG0&#xd;&#xa;C4CxY/CqwvbW5UCcFG9TSFLMcm549BVt22RRJLYWsufLwjf7JrLubd7eTY/4H1q8b+3t1K28ZYn+&#xd;&#xa;I1nyyvM5eRiT/KlK1hDKKKKgQVat9PmnG7ARfVqt6ZbwMnmEh39D/DV2d3jXciBsdRVqOl2OxVj0&#xd;&#xa;qAAbyzn64FTLY2qkERDj1JqH+0G/55j86P7Qb/nmv501OCDmR0dmoS2QDvzU9cxFeSyNhIx9c1aL&#xd;&#xa;bVLOwAA5Oa64YlWskUnfY3aK4yCXzdTciRnXYcZPuKK6qc+ePMO5FbnF7J7yN/On3ycq34VXVtt1&#xd;&#xa;IfSVv51bvuY0YdM14NbSrcfUpUUVJFC8p+UcDqaQMjpwOCDT5ovKYLnJxUdJCNUHKg1my/61vrV+&#xd;&#xa;3bdCpqhL/rW+tZ01qwGUUtFaAaacov0qjdf69quxf6pfpVG5/wBe1Y0/iYkRUtFFbDCiiigDTQ5j&#xd;&#xa;B9qzW+8frWhCcwL9Kz2+8frWdPRsEJRRTo4nlOFHTvWgDaKkmi8ogZyTUVCA04m3QqfaqVz/AK9q&#xd;&#xa;s2jZg+lVbr/XtWUFaTQiKilorUZo2/MKfSqt7/rR9KsWp/cLVa9P776CsY/GxIgpaSlrYYUlLRQB&#xd;&#xa;owHMK/SqE3+ub61dtD+4HsapTf65/qazgveYiE9TU9icXGD3BqA9TToH2TI3YHmumSvGxPUn1BAJ&#xd;&#xa;VYfxCqtXdR/5Zn61S7VNL4UJhXQ+HDizm9Q/9KzLTSrm7AZVCIf4nrf0/TxYQuocuz9cjArqpxad&#xd;&#xa;zSCdymxyxPvSHrVZrohiNg6+tT2F0rXSrIowenNeVGk5Tsz13FxjexdvJjBpDl+pTbz71ygrs7iG&#xd;&#xa;3uowk21lBzjNNjsLRFPlwRjjrivXlTvZJ7Hlzi5O5x1FWWtCHYFuh7CnC2QdcmsvZyMbFT60lXhD&#xd;&#xa;GP4RTgqjoo/Kq9kwsUAD6UoRj0U/lV/j0par2XmOxQ8mQ/wGnCCQ9v1q7RT9kgsVBbSd8fnS/Zm/&#xd;&#xa;vCrVJT9nELFf7Ke7j8qX7KP736VYoo9nELEH2Vf7xpfsqe9TUU+SIWIfs0fv+dL9nj/u1LSU+WPY&#xd;&#xa;LEfkR/3aXyY/7oqSinyoBnlR/wBwUeWn9xfyp9FHKgGeWn9xfypdif3V/Kl49afHG8pIjRnx1wKO&#xd;&#xa;XyAj2L/dH5UbV/uj8qd060/yJfK83YfL/vdqaXSwyLav90flRtX+6PypcjGc0ZHrRyvsITav90fl&#xd;&#xa;RsX+6PypaM+tKwCbF/uj8qNif3V/KlyPWjI9afL5AJ5af3F/Kk8tP7g/KpERpHCpyScAUOpjYq3B&#xd;&#xa;BwRS5QI/Kj/uCk8mP+6KfketGR60cnkAzyI/7tJ9nj/u/rUlFLlXYLEX2eP0P50n2aP3qf8AGijk&#xd;&#xa;XYLEH2ZP7xpPsq9mNWKSlyR7BYrm1/2/0pPsrf3hVqkpeziFiobZ+xWj7PIOwP41copeyiKxRMMg&#xd;&#xa;/hNIY3HVTV+il7JBYz8EdQfyptaNBUHqB+VL2XmFijFK8Lho2INakGqoeJlKn1HSqxhjPVBTTbxn&#xd;&#xa;tihQkthq6NIvZzc7oyfrimMLGLkuv/fWazjar2JFNNs3Zs0nF9gL8mpwRriFC34YFZ9xdS3J+dvl&#xd;&#xa;7KOlNMEg7frTCrDqpFS+YV2WNN/4/T/1zP8AMUUmmn/TT/1zP8xRXo4b+Gi47ETf66b/AK6N/Opj&#xd;&#xa;Lvt9jdVPFLJCqxyv3MrfzqDFeRVs5v1K3Crlh/HVOrVj95qyn8ImJe/60fSq9WL3/Wj6VXoj8KEi&#xd;&#xa;aO4eNdoxj3qJjuYk9TRRTSSAKKKKANC3OYVqlcf69quWp/cCqdx/rn+tZw+JiRHS0lFaDFopKXvi&#xd;&#xa;mMUMwGAxFJU9zbG3jRi2S3oKr0NWBqwtWbL7zfSqygswA6mr0UaxOAByRzUTelhMivT86/Sq1WL3&#xd;&#xa;76/Sq9EPhQEkU7xAhcc+tMkYyOWPU0lFVZXuAUUUUAXrPmH8TVe8/wBefoKnsj+6I96r3Z/0g1lH&#xd;&#xa;42IhpaSitRi0UlLQABmAwCRQeetFFAEZ6mkpT978asy2pSFMDLk81rfZGZHJMJIFVuHTv6irukaf&#xd;&#xa;57efKP3YPyj+8arW1i80qxkgZPNdKqpBCFXhVGKuMOXc2pwu7jprlLS23nr0UDvWM2o3TMSJSM9g&#xd;&#xa;BSahM0s+CflHQVWwTnAOB19qznXctI7HrUaEVG8uoFiSSeSaSiiuc7LBWvok3DxE9PmFZO07Q3Yn&#xd;&#xa;FS2sxt7lJOwPP0rWlNwmmzCtTU4NIm1CEw3bjHBORVat+7giughb0yGHpVZdNiByWc/jXotpM8Rw&#xd;&#xa;bMmitK+t4orXMaAHcOazGBxxVR1JlHlYv40ZHrTdp9aBGSQB1Nacke5I8c0hOOtWhZIhCSXKJIf4&#xd;&#xa;cHj8adFaRGcwXMjRuDxjofxpcmvkFilvHpSF8f8A66v/AGSCCGR7iNwwbCAtjNJ5cNrbRSNEskku&#xd;&#xa;SN3QCtLQW47FNTkUjHAzV+Nba6mt0SMRkk7wKsFnWYh5bYQg42e1Qoq9wsY+WIyAcfSnGKcLvMbh&#xd;&#xa;fUqcVqWjhLi4iiO+LaWUds1DY3M0l4qu7OHOGUnIxV3j2CxHBYyy2rShW3AjavrRBBMDLthVyBgg&#xd;&#xa;n7vvUyDbb30atwp456c0mmo6XoVwQWQnB+lTZXQWKUFtLPnbgKv3mY4Ap0tlLEm8Mjx5wWRsgfWr&#xd;&#xa;cSs+myxop3q+4rjkii3Vo7K5MqlUYYAI6mq5n2Ai+wlI0kknjEbD7wyajurVothVw6OMqw71Znhl&#xd;&#xa;Om2/yN8pOeOlOuIHFhbb1ICE7jnoDU9bgV/sMKlUlugsjY4C5Ap1lE9tqixluQ2DjvVyRJI51ECR&#xd;&#xa;Lb8HzCAaR4z/AGuJgU2ZDZ3DpWnMwMyUbZXHox/nVm3+bTbtc9l/nUV3GUuHyQckkEHPerNpGDZT&#xd;&#xa;q0kamQAKGbniso35rivqV1tIo4FmuC5352onX8aS4tESNJoXJic4+bgqferqTvJaxpDOsckeVYMc&#xd;&#xa;ZqG4lOIklnMxDbnCngVbkx3QJb2m9YR5shPBkUcA02G0je9a2mL5yQCtWnlP2kSC8RbfIwqnnHpi&#xd;&#xa;mr5Y1QzmePZnPWlbW4FN4rRJBGPNbDYZs4z9KlmtbS3uTE5lbOOmPlzUTRD7VtM0ZBOd3ap7xY5r&#xd;&#xa;7es8e1sHOemKOeQDEtY4tQ+zyO/UBWXg80sVpFPeSQOzggnaw9vWp5PLbVROJ4tmQ3X0ogWNNRkl&#xd;&#xa;M8W05PX1oXxfMCtDaW05aKN5PNAJBIGDiorWyEsbSyvsiTqQOT9KtWEYiumZ5osKCM7uuRSwbPss&#xd;&#xa;tm8iq27Ktn5TVKTAjgtLabd5crhUGSGAzVOULuIQ5XPBNaVnb+QJi8iFvLOFU5rNxWbuteoiWOzA&#xd;&#xa;hEs83lq33QBkmh7PY0ZEymJ+j4/pV/fJNaQm3jjkKDaysASD+NRXCzypHb7Y9xOdiDG2tOYZEbBk&#xd;&#xa;nSHzUYuMg4OKQ2Eju0ccsbOvJAatCNSg+x/P5u3iTHT2+lVtPhkiu5UcbWCHGamyvcCr/Z9wUJVo&#xd;&#xa;2YDJQNzUMUM0rlY0LEdfarllDMt8hKMu05ZiO1WA8X2S4baxUyc7DggVSd+gGfJbTQqDImAe4OR+&#xd;&#xa;lI1vOMDynyeny9atrJCLKYRJMUPdsYBpZZ5ItOt1RyC+SSDzWdle4WKSgLFJ5qOH/hOOB9ah31oo&#xd;&#xa;7NpUu9i3zgDJzU5jNvFGkE0MbFcsW6mr919AsZSnIzQTitC5CKYJB5TSE4cLyDS3Rt4rvyhbIQcb&#xd;&#xa;v/rVnyq+orGbuHrS7h61bewRr94kJWNfmJ9BQltZzuUjeRCOctjBquSA7FSlqeK0zF5kkixx5wCR&#xd;&#xa;kn8KZc2zRKrKyujdGFRyaiIqXt0p/wBiuvL3+UcYyBnn8qhO9CQwII7EVTpMY+3AF5nA/wBWf5ii&#xd;&#xa;i35ux/1zP8xRW9JWjYaIJ24Kf9NGP61BQ5zNLn/no386K8SorTZSCrNj/rGHtVanJI0ZypxWcldW&#xd;&#xa;Eye9/wBaPpVenPI0hyxyabQlZWEPjXfIqnoakngESghsjPpTbf8A161Yvf8AVj61LfvJAUqWkpao&#xd;&#xa;CeG4EUe0qTUMjB3LDvTaKEktQFrSQAovA6VmVqRcxr9KzqaIGZ82POfHrVuG0SWz3Icydf8A61Up&#xd;&#xa;TmRvrUtrcm3kz/CeorWPmVG19SxfAvDbqAdxHSh7OKK13SsQ/tVuWSFUWc4IA+Wsq4ned9zdB0Hp&#xd;&#xa;Vysi5WQ60XdNn05qwr7rsgdhVWCURFiR1HFNWRlcspwTWLjdmRNe/fX6VXpzyNIRuOcUymlZWAUc&#xd;&#xa;sB6mrE9sI03K2frUEY/eL9avXf8AqD9RSk7NAZ9LSUtUBNbziIEEE5qOZxJKX6ZplFKyvcBa0IAD&#xd;&#xa;CvA6VnVo2x/cKampsDKl3jzzj0qGrU0JeZiSAKVYUXtk+9bwpSkgKyozdAalW3J+8QKsDiitlRS3&#xd;&#xa;AjigQSDjJ96mlOSBTFO180hOTmq9n+8T6JEmhpUeWeQ/QVYvG6IPrRpq7bUH1JNR3BzMfassXO0W&#xd;&#xa;dtCOxm3IJnwOpwK0ri3W00kjHztjJqC1iEupqD0UbjVzWzi0Uer1NCNqTmzqqTvOEDCooorlO80I&#xd;&#xa;rcy6S7KOVckVn9a3NGw1myn+8az9Rs2tpSyj923Q+ldU6f7uM0clOr+8lBk9jeOIvLYBgvAqc3Du&#xd;&#xa;wA457Vn2fRqtJ99frXK6072uRUpxUmyxqQzZt7EVj1tXwzaP9KxK9aGx5lXcWnwOI50Y9AwJplFX&#xd;&#xa;sZGtcCVpy0FtE6vyJCuageIXF6TNMhVANzcDPsKob2AwGOPTNJWjmhmrJLDch47mRFCH92y8kVX8&#xd;&#xa;23kgEEzsPLJ2SKO30qlS0nPyFqWXnjj8sWwI8s53kck043Nu0vmm2PmZz97jP0qnRuHqPzpcwGjp&#xd;&#xa;7tJePMzKMg5JOMZqN7uSFmVY4Vk6F0HNUd692H50hlT+8KPaaATw3EkDMYzjd1yM5p4vJ1dnWQhm&#xd;&#xa;6kVU86MfxUn2iP1NR7TzEWPPl83zN7b/AO9nmiSaSUgySM2OmTVY3Efv+VJ9pT0al7RdxlkyOers&#xd;&#xa;fxppYkYJP51B9pX+6aFnLttSNmb0FHtF3AnycYzxRzU8VpK3MgCD06mp1tIx1yfxp8w7FCir7WkR&#xd;&#xa;HGRVWe1mjBaMK4HboaTlYLEdJVY3Dg4KAEdqPtTf3RU+0iSWqSq32pv7opPtTf3RR7SIXLVFQxvP&#xd;&#xa;J9yEn8Kl8q7xnyB+dPnQC0tQPJNH9+ErTPtR7qKXtIjLVTW9y0AZdiujdVNZ/wBqP90fnS/av9j9&#xd;&#xa;aaqx7hc0mugImSGFYw33iDkmq1V/tQ7ofzo+1L3U0/aJ9QuWASOhoyc5yc1B9pT+6aUXKejUc67i&#xd;&#xa;Jw7A5DH86tWtxFGrmYyl3G3I9Kz/ALRH6n8qBPH/AHh+NNVEuo9C29zKVMYlcx9gT2pkU8kLFo2x&#xd;&#xa;nr71D5qf3xSh1PRh+dPn8wLEt1LLgOQQDnGMCnS3kksXluqEdjt6VWyPUfnS0+ZgWRef6N5Bhj2+&#xd;&#xa;o659aPtMckaJcQlygwrK2DiqtLT5mMs+fC0yM0ZWNOgTr+NPkltpb0Sl3VScnK96p0lHMI0vtEH2&#xd;&#xa;yVvMzHMuCcY21AbWOJGeS4Q8fKEOSaq0lPnuGpqb3ksofJhSYKMMrDJBpk3mGKKDyY4mdshQeR9a&#xd;&#xa;z1ZlOVJH0pwkcPvDHd60c6YXZony57sA74bkcDupIrPnZnnkL43E84qVb64AxvBPTJAz+dV855ND&#xd;&#xa;aewXFg/4/B/1zP8AMUUQf8fY/wCuZ/mKK6KXwlLYpFGaWfaM4kbP502r8KAJOf7ztn86oV4dSV6k&#xd;&#xa;vUoKKKKkApaSlpCJrXmdanvf9WPrUNp/rx9Kmvf9WPrWb+NC6lOiikrQYUVZs7dbhm3NgL2quwwx&#xd;&#xa;A6A07BYStOH/AFKn2rMrRhP+jr9KzqLQTKDfeb602lPU0VYASSACTgdBSUtFACU7axUtjgd6QckA&#xd;&#xa;VdlQJaFfSk5W0ApUUUUwHQ/65PrV27/1J+oqnB/r0+tXLoEwnHtWcviQjPoqVYXbrwPepVt0HXmu&#xd;&#xa;hU5MZWAJOAM1IsDnrwKshQOgxS4rVUUtwIlgQcnmrMYAUAdKjqVCNvWoxMbQ0QMjbljRQTyaSuiO&#xd;&#xa;kUAUZpjuQcYpuGat1TbV2A7IzS4JB9KYEwee1WQMRGsq9RU7WEalhxZx/Sq83+tb61YsD/ocf0qv&#xd;&#xa;PxM31rixnwr1O+gLpuP7Qk/3Kfrp/cxfWq1i+3VAP73FWdd/1MX+8a0pv/Z2jVq1eJi0UUVxnomx&#xd;&#xa;oTjbKnfOa1HRZEKuAQexrn9MmEN2u44DfKa6CQtsJTBbHAPQ16mHkpU7djycVHlqXKB06OJiYmIB&#xd;&#xa;7HtSpahWBLZxVY63GJCk8LxuvDY55pX1i0AyGZvYLWMqVPmvYzVa61ZavCPskpPZa5z7SnbJq3da&#xd;&#xa;0ZY2jiiwGGCWPNZVV7RrY5qkk3oWTdDsp/OkN0ey1Xope0kZXJjcv6AUhuJD3qKpI4JZT+7Qn3pc&#xd;&#xa;0mAhlkP8ZpN7f3jV1NKlb77qv6086Q2OJRn6U7SHZmdknuaSrUun3EXO3cPVaq9OD1FS79RBRiii&#xd;&#xa;kAUUUUAFFFFAD4UWSVUZgoY8k1vQW8duuI1GfX1rnqu2uovDhZBvT9RVxaW41oX5LwxPtaLn69ab&#xd;&#xa;/aA/55/rUi3NrcLgsv0bimm1tjyGx9GptS6Mbv0G/wBof9M/1qeCZ5RnYVX1JqDNlAcllJ+uagm1&#xd;&#xa;UYIgTHuaE2viYLzH6tHD5e8kLL296yac8jyPudiT702ok7vQTJIYJJ3CxjPqfStaDToYgC/zt79K&#xd;&#xa;q6bdpF+6kGAx4b0rSmiWaPGcehFXFK1xpEgwBxx9KKy5IJkPIJHqKaI5ScBXo9o+wuZ9jWIDDDAE&#xd;&#xa;e9Z15poIMluMH+761JBZseZSQPQU+6vo7Zdq4Z8cAdqd7rUe61MMgg4PUUU6RzI5dup5NNrIkKKK&#xd;&#xa;KACjFFFABRRRQAUU+KJ5nCRrk1pRaXGq7p3z7dAKaTY0jKyaUM3ZjWs0dgvG0H6U02VpN/qnKNTt&#xd;&#xa;5hYzRLIP4jThcSDvmpbiwmgG776+oqrReSDVE4uW7gGnC6HdTVaimqkhXLYuYz6inCaM9GFUqKaq&#xd;&#xa;sdzQBB6EfnS1nDI6GnCRx0Y1aq90Fy9S1TFy464NSC6H8SmqVSI7liH/AI+x/wBcz/MUUy1lWS7+&#xd;&#xa;XtGf5iiu6k7wVilsSg7YJT/tt/Os+rM74iZfWRv51Wrw5L35epSCiiikAUtJS0hD4pDE24AE+9Pl&#xd;&#xa;uDKoBAH0qGilZXuIWpbURmdfN6VDRVDvqbCwCG5Z0HyOvbsaqWlp5rmSQYQE/jU1jdBl8qVuR0J7&#xd;&#xa;1FeXYP7mHhB1I71o7WuaPltcr3XkiYiEHb39KipKKzM2FLQBk4qwLN+5ApNpbiK9FKVIYgDOKcIX&#xd;&#xa;PbH1pqLYBAuZlHvVu7OIPrSWsezOSDT5QGYZGcVPI5VOUDPCs3QE1IsDnrgCrXHYUYrrVFdQGRxL&#xd;&#xa;GwbqRUpckYptLVeyhe9gEoopCwHetbNgOoqMyelOVty5qnBpXYCkgdajMnoKcyhutKEAprkSvICM&#xd;&#xa;bm9alHSin7CaipVit9AGYGc0Up4ODSUr3VwEA+bFTOcIaiidTKVBBNMvZjHtVep5rkrS5qsY9iTY&#xd;&#xa;005tAPQmm3QxMfeq2gzGRJUY8gg1oywiUjJwRVV4+0jodtGSVmzE83y7wSD+Fs1rawPMskkHTcDQ&#xd;&#xa;dGhY7mkbJp1/EItLMYJYLjBNVClKFOSkdEqsJzg49DBooqby99r5gHKNg/jXGo3O9y5dyHkdK6DT&#xd;&#xa;LsXEO1j+8Tg+9c/UlvM1vMsinkfyrWjU5JeRlXpe0j5l3xDZcLdoP9l/8awcV2rKl3akdVkWuNmj&#xd;&#xa;aGZ4m6qSK66sVe6PBnGzGUUUViQFFFFAGnZ6aCokn5zyFFXmligwh+X04rLs9QaEBJcsn6itMNBd&#xd;&#xa;pwQw+vNaxatoUvIPtkP979KT7XB/e/SoX0/n5Xx9aFsP78nHsKm8wvIsLdRO21SSfpUV5ZJOpIwr&#xd;&#xa;gcGjzbWzH3hn25NZ93qDzjYgKJ39TVX094d9NSoRgkelJRRWRAUUUUAFFFFABRRRQAUZPqaKKACi&#xd;&#xa;iigAooooAKs299Lb8Z3J6Gq1FCdguay6tHj5o2B9jSPq64+SMn6msqiq5mO5an1CeYYDbF9Fqqee&#xd;&#xa;tFFS22K4UUUUAFFFFIAooopgFFFFAFywvBbEq65U9SOorTIiu1G2TI9AawKVWZDlSQfaqUujGmbn&#xd;&#xa;2GL1aj7DEOhbP1rMTUblBjfn6ihtRuWGN+PoKd4dg0NaSaO1i/eOT6A9TWFNIJZWdVCgnoKazM5y&#xd;&#xa;zFj7mkpSlcGwoooqRBRRRQAUUUUAFFFFAFnTf+P0/wDXM/zFFGm/8fp/65n+Yor1MN/DRcdh9wP3&#xd;&#xa;ROP+WjfzpFgAtmkbr2qbYJEcH/nq386kmUGMJ2rx5pufKu7KM2irX2dPel+zJ71fsZDKtFWvs6e9&#xd;&#xa;L5EfpR7GQipRVzyY/wC7R5Uf90U/YsRToq75af3RS7VHYUewfcCkM9gaUIx6Kau4HpRVKiu4FQQu&#xd;&#xa;e1OFu3cirNFUqMUBCtuARkmrg+6KhqVPu1z4mCUU0BGQMnikpT1NJXZFaASJwMdzSSfeqPeqsDmp&#xd;&#xa;SQzKRXPKDp1OZgNZdqj1pufWnTHsOtQYdq3w8XKF5MVyQuooVg3SmCL1NPVQvStmoJaDBhkcUwRk&#xd;&#xa;9akoxSjNxVkA0IBTqKKlyb3GGKKa0ir1NRNcf3R+dRKcV1ET1KhyoxWc0jt1NW7NsxY9DXHiJqcd&#xd;&#xa;AZHPOVkZQPxquzs3UmnXH+vf61HQpO1gLNpsjPLDe54HpRqI4Q/UVTztfPoc1duCJhCRyC3NS1yz&#xd;&#xa;UiCbTWWyxNLwGGCfQVebWbRehZvoKy9QfCrGO/JFUMVrSm+W7LU3HRHSDxBCWCrC+ScVc1Tmwc/S&#xd;&#xa;uVs13XkI/wBsfzrpdUkJsWHqRXR7S8Hc2w95TRhVoaSBI8sLdHSs+reluVvV9wRXFSdpq57FZXgy&#xd;&#xa;tIhjlZG6qcU2ruqptuy3TeM1SqZq0mi6cuaKZvaLJvtShPKHH4Vja/F5eoFgMCRQau6LIVlkX1Ap&#xd;&#xa;niMbkhk7gkV2xkpUkjx8VC02YdFFFZnEFFFHfFABSqxU5UkH2pwhlIz5bflTSrKfmUj6iiwakq3d&#xd;&#xa;wo4lb86a88sn35GP41Hmii7AKKKKACiiigAoopKAJ7e1luGxGvHdj0rSh0uJcGQlz+lFhfRMgjcB&#xd;&#xa;GHA9DU00ErEtFKRntmtEkldFaDhZ24/5Yr+VRyadbyD7m0+oqHyrvOMt/wB9VMkTxjfPMQPTNO99&#xd;&#xa;0CfkZt1YyW3zfeT19Kq1qXuoqUMcPOeCxrLrOVr6CYUUUUhBRRRQAUUUUAFFFFABRRRQAd6tw6dP&#xd;&#xa;KASAinuaZZTxwTbpEDA8Z9K2SVuI/wB1Lj0INXGKY0ismlQgfOzMfyp7aZbkcBh+NRvHdqeGLfQ0&#xd;&#xa;LHdscZYe5NO67B8iGfSnUEwtuHoetZ7KVYqwwR2NbhkS0XM0xY+lZV5ci5l3BQoHHuaUktwZXooo&#xd;&#xa;qBBRRRQAUUUUAFFFFABRRSqrO4VRknoKAEpQrN91SfoK1rbTEQbp+W9OwqR7uKL5Y0Bx6VXLZajs&#xd;&#xa;YpVh1Vh9RSVsfbgeHiBFI1ra3YJj+RvalZPYWhkUVPc2sls3zcqejCoKTVgLOm/8fp/65n+Yoo03&#xd;&#xa;/j9P/XM/zFFeph/4aNI7FiI4Mn/XRv509jk1FH/y0/66N/Ok2tXP7OMpuQ2S0VFtelUMG5q3TS6i&#xd;&#xa;uS0lLUJV81EYqXULktFRbX96VVYNzVOml1AkzRketGKjMZz1qYxT3YEmR60m4etM8s+tKqYOapxg&#xd;&#xa;luA+mmQCnU3y196mHL9oBPN9qVXJOOgpdi+lLgCm3TaskAh6VHsY9alopRm4gRiP1NSJ8lGKKmcn&#xd;&#xa;NWkAp5OaSjNSRxNIpK9qnRKwyPFFI7CMkMQCKia4A+6CaTkluImpGcL1IFVWmdu+B7U1CN4LgsM8&#xd;&#xa;1m6y6DRO1wv8IzU8SLPaPIxKsuelPktobmANbgKR0/8Ar0y2RzZzR4w5bH0qHKTZaiZ9FadzFBBa&#xd;&#xa;BGHzdsdSazKyasQ1YWgMV6EiiipEB5OTzSUtFMCM9T9afFKY2GeVBzimHqaTFa2ujMfNJ5spf16U&#xd;&#xa;yiihK2wFvSwDqEWSAASf0rZ1Rt9uqphvm7HNc3WlpY/duT3NKpPlgzqwsrTSGFGH8J/Kp7AH7ZHx&#xd;&#xa;VqqmosUhBU4JPUVyU53kj06ta0GW9YH+qP1FZlOsGMzOJWLgAYyelWzbxkdK0rTSmycNVTpoNKP+&#xd;&#xa;lH/dqXXh/oa+u+qzlrJTNDjPTBqreajLeRKjqqgHPFbUpJwOTGTi5WKdFFFWeeWLO1N05GQFXr61&#xd;&#xa;qiG3tEB2DPrjJNYiO0bBkYqfatCHVTwJk3Y7iri1YaJmvn/hQAUgvGY4kiBHfip0vbVxw6j6jFOa&#xd;&#xa;6tlHMifhT5X3HbzKz2dvdoWi+Ru/FZk8D28mx+vbHetGfVEXIhXJ9SOKzJJGlcs5JJpSsJjaBknA&#xd;&#xa;GT6UVPZ3C282503A/pULcRPBpcj/ADSnYPTvV6PT7ZBym4+9S7kuY/3cn4g81VeC6U8OWHsa0+HZ&#xd;&#xa;FPQsGytiMeUtVLjSht3QHB/unvUiQXTdXKj3NStNDaId8pdvTqad0+gGGyMjlXBDDtUsV1NEMJI2&#xd;&#xa;Pelu7g3Mu8qFxwKgrPbYktHULkj7+PoKgkleQ5dy31NMopXYBRRRQAUUUUAFW7XT5Lgb2OxP51UB&#xd;&#xa;wwPpWzaahHIoSTEbfoaqKT3GhPslnbriTk+5ppSwPGzHvVk2cTncSTnvmk+xQ+/51TUuiHqVH0yO&#xd;&#xa;Rd1vL+BrPmhkgbbIuPf1rdjtUjbcpYfjVPUruNk8lAHbufShx01E0ZdFFFZiCnI7IcoxU+1NooAs&#xd;&#xa;jULkDHmfpTWvLhxgyt+FQUU7sLgSSckkn3ooopAFSQQSTttjXPqewpibd438LnmuhthEIV8nG31F&#xd;&#xa;VGNxpFKLSkAzK5J9BUpsrJeoGf8Aep1wtzI2E+Vfr1qv9jnPYfnTbtokN+g86Zbv/q3IPsc1Um02&#xd;&#xa;aPlf3i+3WrAtJ1OQAD9auW/nr8soBHrQve3VhLXoc+QQSCMEUVs6lbwtEZWIRh0PrWNUyjZg9ApV&#xd;&#xa;JVgynBHekopCNO21TjZcDj+9V5Gt5BlNjVz1AyOhxVc/cfMdJsjx9xfyqOWa3t/mJUH0HWsHzH/v&#xd;&#xa;t+dN9+9Vz+Q7lq9vWucKBtQdB61VooqG7klnTf8Aj9P/AFzP8xRRpv8Ax+n/AK5n+Yor08P/AA0a&#xd;&#xa;R2Jo+sn/AF0b+dSVHH1k/wCujfzqSueXxMoKKKKkQUUtFIBKWiigQUlLRQAlGKWkzQAUtJRQAtFI&#xd;&#xa;SB1OKY0qDvSukA+ioTcj+EVGZ3PTiodWKAtZx1pUBkOEGaoliepJqW2uWt345U9RUe2uUrX1JJ3a&#xd;&#xa;JypTB96s6ZIXEmexFSyJFewZBHsfSobCF4XmRhyRkHtUtybLUbMqiB7u5l29Mk5qCRGjcq4wRWyi&#xd;&#xa;paW/JGByT6msm5mNxKXIwOgFRJWFKKRFRS0VmZklvO8Em5encetaf2yEQGUcMeCO+ayVUsQFBJ9B&#xd;&#xa;Scq2CMEHvVqTRcZND5pWmkLOefT0qOtDUVUJFtUBm7gVRdGjba42n0NJoUk0NpaSlqSQopURpG2o&#xd;&#xa;pJ9qHUoxVuCKYER6mkpT1NJWqMwopUVpG2opJrQg0p25mbaPQdapRb2BK5nVZt7xoI9oUHJzWkmm&#xd;&#xa;W6jlSfxpJNLgYfLuQ/Wm6TkrMuLlF3RT/tNv+eY/Oorm7NwgXbtwc9aW6sJLfn76eo7VVrL2UYu9&#xd;&#xa;ipVZtWbL2lf6yT6VpVgKzL90kfSnebJ/fb86yqUeeV7m1LEKEeWxqX/No31FZFOZ3YYLsR6E02tK&#xd;&#xa;cORWMa1RVJXQUUUVoZBRRRQAUUUUAFFFFABRRRQA5HeM5Rip9qsDULoDHmfpVWii7AnkvLiQYaU4&#xd;&#xa;9qg6nJzRRRcAooooAKKKKACiiigAooooAKKKKAJYrmaL7khFTDUrnH3h+VVKKd2FyaS6nl+/Iceg&#xd;&#xa;4qGiikAUUUUAFFFFABRRRQAUUUUAFSQzyQNmNse3Y1HRQBrQ6rG2BKCp9R0q2lzA/wB2VfzrnqKt&#xd;&#xa;TY+Y6Np4lGWkUD61Vm1OFARHl2/SsaihzbDmJbi4kuGzI30HYVFRRUMQUUUUAFFFFABRRRQAUUUU&#xd;&#xa;AWdN/wCP0/8AXM/zFFGm/wDH6f8Armf5iivUw/8ADRpHYmjYZkyR/rG/nTty+oqqY3aSUhGI8xuQ&#xd;&#xa;D60eVJ/zzf8A75NcFSpLmegy1uX1FLvX+8KqeVJ/zzf/AL5NHlSf883/AO+TUe1l2AteYv8AeFHm&#xd;&#xa;J/eFVfKl/wCebf8AfJo8qX/nm/5Gj2suwFnzU9aPOj/vVW8mT/nm/wD3yaPJk/55v+Rpe1l2Asee&#xd;&#xa;nv8AlSG4T0NQeVJ/zzf/AL5NHlS/883/AO+TSdSYExuR2Wmm4PZRUfkyf883/wC+TR5Uv/PN/wDv&#xd;&#xa;k0ueYDjO59KaZHPVjR5Uv/PN/wDvk0eVL/zzf/vk1DcmA0knqTSU/wAqX/nm/wD3yaPKl/55v/3y&#xd;&#xa;aVmAyin+VL/zzf8A75NHlS/883/75NFmA2kp/lS/883/AO+TR5Uv/PN/++TRZgPt7hreTK9O4rVS&#xd;&#xa;5ieIyBsAdc9qx/Kk/wCeb/kaPKl6eW+PoapNopSaJLu5a4fjhB0FQ07ypf8Anm//AHyaPKk/55v/&#xd;&#xa;AN8mpabJbuNop3lS/wDPN/8Avk0eVL/zzf8A75NLlYEtrcm3kzgFT1q3c26XUfnQY3Y/Os/ypf8A&#xd;&#xa;nm//AHyalt3nt3yqPg9Rg1aTKi+jNMRKzRyyfwLwD2rOvrgTyfKPlXv61LeTyzDZHG4Xv8p5qn5M&#xd;&#xa;n/PN/wAjRLshyl0Q2lRDI4VeSaXypf8Anm//AHyaURzKwIjcEexqeUjqXbeBrW9VSchl4NVZkaW8&#xd;&#xa;dVGSWOK07aQzxqZEKup7jFN2Lah5dpd2J6CtOW5rypryMq6tZLYjfgg9CDUFTz+fPKXdH9htPFR+&#xd;&#xa;VL/zzf8A75NVZ9jmdr6F/S54V/dsoV/7x71enWY/NE/4VheVL/zyf/vk1PDPeQ8KHI9Cpqk3azHf&#xd;&#xa;QuGW7BxhvyqWIXb/AHm2j3qp9vvP+eR/75NRSXF7JwRIB7LihL1FsaVxdxW6FWbe+OlYbHcxIAGT&#xd;&#xa;0HanGKUnJjkJ+ho8qX/nk/8A3yaUrsHqMop/lSf88n/75NHlSf8APJ/++TSs+wrDKKf5Uv8Azzf/&#xd;&#xa;AL5NHlS/883/AO+TRyvsAyin+VL/AM83/wC+TR5Uv/PN/wDvk0WfYBlFP8qT/nk//fJo8qT/AJ5P&#xd;&#xa;/wB8miz7BYZRT/Kl/wCeb/8AfJo8qX/nm/8A3yaLPsAyin+VL/zzf/vk0eVL/wA83/75NFn2AZRT&#xd;&#xa;/Kk/55P/AN8mjypP+eT/APfJos+wWGUU/wAqX/nm/wD3yaPKl/55v/3yaLPsAyin+VL/AM83/wC+&#xd;&#xa;TR5Uv/PN/wDvk0WfYBlFP8qX/nm//fJo8qX/AJ5v/wB8miz7AMop/lS/883/AO+TR5Uv/PN/++TR&#xd;&#xa;Z9gGUU/ypf8Anm//AHyaPKl/55v/AN8mizAZRT/Kl/55v/3yaPKl/wCeb/8AfJoswGUU/wAqX/nk&#xd;&#xa;/wD3yaPKl/55P/3yaLPsAyin+VJ/zyf/AL5NHlSf88n/AO+TRZ9gsMop/lS/88n/AO+TR5Uv/PN/&#xd;&#xa;++TRZ9gGUU/ypf8Anm//AHyaPKl/55v/AN8miz7AMop/lSf88n/75NHlSf8APJ/++TRZ9gsMop/l&#xd;&#xa;S/8APJ/++TR5Uv8Azzf/AL5NFn2AZRT/ACpf+eb/APfJo8qX/nm//fJos+wDKKf5Un/PJ/8Avk0e&#xd;&#xa;VJ/zyf8A75NFn2Cwyin+VL/zyf8A75NHlS/883/75NFn2AZRT/Kk/wCeT/8AfJo8qT/nk/8A3yaL&#xd;&#xa;PsAyin+VL/zyf/vk0eVL/wA83/75NFn2AZRT/Kl/55v/AN8mjypf+eb/APfJos+wDKKf5Un/ADyf&#xd;&#xa;/vk0eVJ/zyf/AL5NFn2Cwyin+VL/AM8n/wC+TR5Uv/PN/wDvk0WfYBlFP8qX/nm//fJo8qX/AJ5v&#xd;&#xa;/wB8miz7ATab/wAfp/65n+YopdPRkvTuUr+7PUe4or1MP/DRa2Oq0tMWY3Lg726j3q5tX0FOorax&#xd;&#xa;Q3avoKNq+g/KnUUWQDdq+g/KjavoPyp1FFkA3avoPyo2r6D8qdRRYBu1fQflRtX0FOop2AbtX0FG&#xd;&#xa;1fQflTqKLAN2r6CjavoKdRSsgG7V9BRtX0FOoosgG7V9BRtX0FOoosgG7V9BRtX0FOoosgG7V9B+&#xd;&#xa;VG1fQU6iiyAbtX0FG1fQU6iiyAbtX0FG1fQU6iiyAbtX0FG1fQU6iiyAbsX0FG1fQflTqKLIBu1f&#xd;&#xa;QUbV9BTqKLARvEjqVI4NEcKRoFA/OpKKOVXuA3YvoPyo2L6D8qdRTsA3YvoPyo2L6D8qdRRYBuxf&#xd;&#xa;QflRsX0H5U6igBuxfQflRsX0H5U6ilYBuxfQflRsX0H5U6iiwDdi/wB0flRsX+6KdRTsA3Yv90Ub&#xd;&#xa;F/uinUUWAbsX0H5UbF9B+VOoosA3YvoPyo2L/dFOoosA3Yv90UbF/uinUUWAbsX0H5UbF9B+VOoo&#xd;&#xa;sA3YvoPyo2L/AHRTqKLAN2L/AHRRsX+6KdRRYBuxf7oo2L/dFOoosA3Yv90UbF/uinUUWAjcxxqS&#xd;&#xa;2AKpS3gPEaD6mpby3aT5lOSO1ZdxA7dGZGHauStOUdEhMsmaQ/xfkKFnkU8Nn6isoxXQOMsfxqSO&#xd;&#xa;3uGPzyFR6Z5rlVWV9Cb+RtQXSthZFAPrirgVSOgrMt7N2AByFHc9a00UIoUdBXfScmveLDYvoPyo&#xd;&#xa;2L6D8qdRW1gG7F9B+VGxf7op1FFgG7F/uijYv90U6iiwDdi+g/KjYvoPyp1FFgG7F9B+VGxf7op1&#xd;&#xa;FFgG7F/uijYv90U6iiwDdi+g/KjYvoPyp1FFgG7F9B+VGxf7op1FFgG7F9B+VGxfQflTqKLAN2L6&#xd;&#xa;D8qNi/3RTqKLAN2L/dFGxf7op1FFgG7F9B+VGxfQflTqKLAN2L6D8qNi/wB0U6iiwDdi/wB0UbF/&#xd;&#xa;uinUUWAqXNilxIrliu0EcCirdFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAB&#xd;&#xa;RRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFF&#xd;&#xa;FFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAIaZIiuvzKDRRSewEIt4v7gqWOKNRlU&#xd;&#xa;AoorKKVxjxS0UVsIWiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK&#xd;&#xa;KKKACiiigAooooAKKKKAP//Z</binary>
<binary id="image3.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2Nj&#xd;&#xa;Y2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCABoAD4DASIA&#xd;&#xa;AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA&#xd;&#xa;AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3&#xd;&#xa;ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm&#xd;&#xa;p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA&#xd;&#xa;AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx&#xd;&#xa;BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK&#xd;&#xa;U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3&#xd;&#xa;uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDv6QnC&#xd;&#xa;k0tNk/1bfSlJ6AZlzcpF88pPzHgYqOC9hmbahIbsCKoamxNyFzwq1ViLCRSg+bPGK8GVZ8x6saCd&#xd;&#xa;O51tvIXXB6jipqqWZ5OeuKtZr2aEuaCueZNWYtFJS1sSMdwi5NU5bz5eyD1NE0m4lieB0rAu7gzy&#xd;&#xa;+iDhRXnV8VbRHVRw/Ox+okNc7lIOV6im2UyQzbnHGOuM1Xory+b3rnqci5ORmyl/CzBRIQTxyK07&#xd;&#xa;MkowPY1yeSMGuh0+4BRXJ4YYb6134Wu3O0jz8TQUFdGnRUfnxgZ3U6ORZASueK9RTi3a5xWZkXT8&#xd;&#xa;hR0rMtLf7ROQeFHX86vTnMjUmnIFgL92Ymvnqa9pUdz01L2dN2M2UATOFGFBIAphpWOXJ9TSVD3O&#xd;&#xa;2OyJ7mIp5bAcOg/OpdOuPKcowyrfpVvyRc2SKeDt4NZ8Ubx3AV1IIrWadN8yOZSVSDjLc1ftALBV&#xd;&#xa;HU960LU/K1ZEX+sX61rWp+9W+AqSlO8jirJJaGRLw75p9ic2f0JFNuRhpPpUemOCskfvmuXD6VGd&#xd;&#xa;Elencz6SlYYYj0OKSoe53rY17B91qo7rwas+WGwWXPocVk2Nx5Mu1vut+lbltIA208g16FG1SNme&#xd;&#xa;VXi6c2yJUUdFFWrUHJ4PSpwi54UU4DFddLDcjvc55VLqxkTQLKTyRxiobezW3cOrEnpzWt9lXuTV&#xd;&#xa;aVVUgID1rD6tye80aKs/hTOfnGLiQD+8aNmYN4/hODS3HNxJ/vGptPUSebEejLXnJXk0epJ8sEyp&#xd;&#xa;Wrp85ki2k/Mnf1rLKkHB7HFWdPbZdD/aGKqlLlkTXipwudPC++MHv3qSqtk3DL6HNWa9+EuaKZ4r&#xd;&#xa;VmB6VTuAFcYq5UVwFETsRyFNRXi5QdhwdmclIcyufVjVnTD/AKXx3U1MY1P8INW9MgQzMdo4FeBR&#xd;&#xa;ftKiij1qlVKmzKvF23cgHTOaS1OLqL/eFaGoW0ZvH6jOKrRWoE6EMeGH86JNRqcvmVGonT+Ru2h/&#xd;&#xa;eN9KtVFFD5bE561LXv0IuMLM8ebTegU2RQ6FT0NFFatXRJX+wQf3T+dSQW0cBJQdaKKyjQpxd1Ep&#xd;&#xa;zk1ZspXltLJcsyKSCBUAtZlYEoRzRRXDPCU3Ucn3NlVko2NNJiPvciplYMMiiivUOZH/2Q==</binary>
<binary id="image4.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCARgAukBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APP6KKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKO&#xd;&#xa;9LSUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUd6WkoopaKSiilooopKWiikoopaKKKKKKSloopKKKKWikpaKKKKKKSiloo&#xd;&#xa;ooopKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKO9LSUUV6P4E0fT77w/5t1aRSyecw3MMn&#xd;&#xa;GBW7e+HtISyuGXT4AyxsQcdDivG6K3PB9tDd+IbeG4jWSNs5Vq9P/wCEb0b/AKB0H/fNH/CN6N/0&#xd;&#xa;DoP++aP+Eb0b/oHQf9815348s7ax1pYrSFIkMYO1R3rmK7v4f6FbXttcXd7AkqE7EDj8zXYf8I3o&#xd;&#xa;3/QOg/75rE8W+G7EaFNLZWkcUsXz5QdR3rzCkr1rQNB0qfQ7OWWxhd2jBYkdTWj/AMI3o3/QOg/7&#xd;&#xa;5pj+GdFYYOnQj6CsnVPAWm3UZNmDbS44xyv5V5xqVhPpl7Ja3KlZEP4EdiK6/wCHmmWV/a3pvLaO&#xd;&#xa;Yo6BSwzjg12H/CN6P20+D/vmvN/GHh9tF1AvCv8AokxJjP8AdPda56ui8C2lve6+IbqJZY/KY7WG&#xd;&#xa;RnivSP8AhG9G/wCgdB/3zXlfiqCK18R3sECCONHAVR0HArJpKKK9U8LaHpdz4es5p7GKSR0+ZiOT&#xd;&#xa;VPxzo+n2OgGa1tI4pPMUblFecU+CJppkiQZZ2Cj8a9gs/C+kxWcMctjC8ioAzEck1P8A8I3o3/QO&#xd;&#xa;g/75rzjxxpKaXrR8hAkEy7kUdB6isSxmSC9hlljWSNWG5W6EV69b6DodxbxzR6fAVdQwOKxPGnhu&#xd;&#xa;yTQZLixtY4pICHOwdV6H+efwrzSivWPD/hfT49EtRd2ccs7oHdmHPPOP1xRr+naLpOj3N2dPt9yr&#xd;&#xa;hBt6seBXk5612vw+0O3v1uru9gWWJcRorDjPUn+Vdp/wjejf9A6D/vmsnxR4ZsDoNy9jZxxTxDzF&#xd;&#xa;KDk46j8s15ZSUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUd6Wkoor1X4cf8iz/23f8AkK6K&#xd;&#xa;/wD+Qfc/9cn/AJGvCKK6DwN/yNFr+P8AKvYK47xJ4ym0TVGs0tUkAUNuZiOtZX/Cyrj/AKB8X/fZ&#xd;&#xa;rm/EOtPrl8Ll4REQoXAOay1UuwVeSTgCvavDtgNN0S2t8YYJlvqagv8AVxa+IbCw3ACZW3f0rXni&#xd;&#xa;WaF4n5V1KmvENWs20/U7i2YY8tyB9Kp17V4Z/wCResP+uQpPE2py6Ro015Ciu6FQA3Tk4rldL+IT&#xd;&#xa;y3UcV/bIsbsAZEP3feu/rgfifZp5dnehfn3GJj68ZH9ak+F3/HpqH/XRP5Gu6qjq+mwatYS2lwuV&#xd;&#xa;ccN3U9iK8a1TT59Kv5bS4GHjPXsw7EVu/Dr/AJGb/tg/9K9Xrxrxl/yNeof74/8AQRWJRRRXsvg/&#xd;&#xa;/kV7H/c/rVD4if8AItn/AK6rXlNdL4E077dr6SMMx243n69q9YkYIhc8BRk1keGdUOq2MsrHlJmX&#xd;&#xa;8M8Vl/ETTvtOjLcqPnt2yf8AdPWvLq9Q+Huqfa9JNpI2ZLc4H+6a6meFLiCSGQbkkUqR6g9a8O1G&#xd;&#xa;0ew1C4tZPvQuVq74Z07+09dtbcjKbt7/AO6OTXtI4AHSvOviXqnmXMGmxtxH+8kA9T0H5fzrhu+K&#xd;&#xa;9n8LaeNM8P2kBGHK73/3m5/+tTNW1f7DrmlWe4AXLsH+mMD9SK2GUMpUjIbIIrxHXLA6ZrF1aEcR&#xd;&#xa;yHb/ALvUfoRVGkoooooooooooooooooooooooooooooooooooooo70tJRRXqvw4/5Fn/ALbv/IV0&#xd;&#xa;V/8A8g+5/wCuT/yNeEUV0Hgb/kaLX8f5V7BXKa/4NTWtRN2120RKhdoXPSs3/hW0f/QQf/vgVxuu&#xd;&#xa;6cNK1WazEhkEZ+9jGateENP/ALR8QW6EZRD5jfQV7IOleSeJNWaTxc91Gx228gVfoK9VtJ1ubWKd&#xd;&#xa;DlZFDCvOviTp3k6hDeoMLMu1vqK4yvavDP8AyL1h/wBchVLx3G8vha5WNWZiycKMn7wrzfS/D+o6&#xd;&#xa;jdRxJayKpIy7KQFHc17Qo2oFz0GK4P4n3iGOzslOX3GRh6cYH8zT/hd/x6ah/wBdE/ka7a4UvBKo&#xd;&#xa;OCVIB/Cszwxqq6vo8M5P71BslHow/wAetUfGXh4azYGaBB9shGU/2h3WuP8Ah4pXxQVYEEQuCD+F&#xd;&#xa;eq1434y/5GvUP98f+gisSiiivZfB/wDyLFj/ALn9aofET/kWz/11WvKq9P8Ah1p/2bR2umHz3Dcf&#xd;&#xa;7orV8XX39n+H7mQHDuuxfqa5H4aX/l31xZM3Eq71+or0C+tkvLKa3cZWRCteHXcDWt3LA4w0bFTW&#xd;&#xa;v4P1P+zNdhdjiKU+W/0New5BGRXmnxJ07yNUhvkXCXCbW/3l/wDrYq/8MtOxHdai46nyoz7dT/Su&#xd;&#xa;3ubhLW2kuJThI1LsfYV4fqV5JqGoT3cp+eVyx9vQVd8L6d/aev2tuRmMNvk/3Ryf8K9orybxnqbz&#xd;&#xa;eK3khbi0KpGfQryf1r1OwukvbGC6j+7MgcfiK4H4m6fsurbUEHEo8tz7jkfp/KuGpKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKO9LSUUV6r8OP+RZ/7bv8AyFdFf/8AIPuf+uT/AMjXhFLW/wCB&#xd;&#xa;v+Rotfx/lXsFY+o+JdM0y6NvdzFJAAcbc1U/4TbQ/wDn5b/vg15z4ovYNQ124ubZ90TkEHFdf8NN&#xd;&#xa;P8u0nv3XmQ7F+grsNQkeGwneFC8gQ7VUck14/LoOsySNI2nzksST8tel+DTdJoUcF5C8UkJKgOOo&#xd;&#xa;pPGmn/2h4fnCjMkP7xfw615BXtXhn/kXrD/rkK0JZY4gDKwUMwUZ9TTwAOK5vxR4pGgsIVtneWRc&#xd;&#xa;ox4SvLtQvp9SvJLq5fdI5yfb2Fd58Lv+PTUP+uifyNdy33TXj/hnXZND1YuSWtpTtlTPb1HuK9dh&#xd;&#xa;ljuIUliYOjqCpHQg1zjaQth42t7+BMRXcbq+Oz4z+uP5109eN+Mv+Rr1D/fH/oIrEopaSvZfB/8A&#xd;&#xa;yLFj/uf1qh8RP+RbP/XVa8vtYGubqKBBlpGCivcbC1WysYLdBgRoFrk/iFDf3qW1rZ20sqAl3KDj&#xd;&#xa;PauY0HTNY03WLa6NhOFRxu+XsetetDkZryz4had9k1v7Qi4S4Xd+I61yynDAg8ivYvCWqDVNEhkL&#xd;&#xa;ZljGyQe/+RUPjixF74buCBl4P3q/h1/TNX/DtgNN0OztsYZYwW92PJ/U1gfEbVPsulR2MbYkuWy3&#xd;&#xa;+4Ov64/WvMq9B+GWn4S61Fx1IiQ/qf6V291K0NtNKiF2RCQo7nHSvHZtC1qaZ5XsJy7sWY7epPJr&#xd;&#xa;0XwOLuPQltr2CSJ4HKrvGMqeR/OrPi3T/wC0vD11EBmRF8xPqvP8s143RSUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUd6Wkoor1X4cf8iz/23f8AkK6S6jaW0mjX7zoyj8RXmH/CAa16Qf8Afykf&#xd;&#xa;wFrCKzEQ4UZPz1X8EKU8V2ynqNwNevV5/wCMPDOqaprbXNpCHiKAAlsVhf8ACEa7/wA+y/8AfYrM&#xd;&#xa;v9IvNOvEtLqPbK+MAHPWvYdEsRp2k21sowUQZ+verryxpje6qT6nFN+0Qf8APaP/AL6FKs0THCyo&#xd;&#xa;T6BhSyIJEZGGVYYI9q8S1yxOnavc2x4COcfSvW/DP/IvWH/XIVR8dO0fhe4kRirLJGQR1B3irXhn&#xd;&#xa;WV1rSI7gkecvyTL6N6/jR4m0SPXNMeHgTp80Teh9PxrxyaKSCZ4ZVKyISrKexFeg/C7/AI9NQ/66&#xd;&#xa;J/I13LfdNeByf6xvqa7jwB4j8lxpV4+I2/1Dk9D/AHfx7V6GVVipYAlTkexp1eN+Mv8Aka9Q/wB8&#xd;&#xa;f+gisSirWn2FxqV0lvaxl5GPbt9a2db8JX2mPCIo3uFdRlkXOG7ivS9AtWstDs7eQYdIxkH1rD+I&#xd;&#xa;8gXw+qHq8o/SuW+H2nfa9dE7jKW67vx7V6tUf2iH/ntH/wB9Cj7RB/z2j/76FPV1cZRgw9Qc1y/x&#xd;&#xa;A0/7XoRnQZe3bd+HevKq6jwBqpsdcW3kbEN0NnPZu3+fevVHRZI2RwGVhgg9xS8ADsK8b8Wap/au&#xd;&#xa;uzzKcxRny4/oKxwMkAck8Cva/DunjTNEtbUjDqmX/wB48n+daDyJHje6rnpk4pv2iD/ntH/30KVZ&#xd;&#xa;4mYKsqEnoAwpzAEEHkHivFPEWnnTNcu7XGEDkp/unkfoazKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKO9Oq4mkajIiyR2czIwyrBOCKX+xNT/58J/8Avg0f2Jqf/PhP/wB8GvSvANvNa+HvKuIn&#xd;&#xa;jfzmO1hg9BXT0VFcAm3kAGSUP8q8z8KaZfQeKYpZrWVI9zfMy4FeoUtFcdqmlSX3ju1keJjbxxhi&#xd;&#xa;2OMjtXYV5v45i1K+1si2t7hoolCgoDgmub/srWf+fa6/I1e0W11ey1a2uGtbnajjdkHpXrwOQD61&#xd;&#xa;5/8AELRJ572G8tIHkLrtcIM9Oldd4ejeLQrKORSjrEAQe1UvG9vLc+GbiKCNpHLJhVGT94Vx3g86&#xd;&#xa;po2rL5tlOLafCSDYePQ/hXqA6Vwnj3w29xIupWMReQnbKijk+hqx8OLO5s7a+W5gkiLOmA4xng12&#xd;&#xa;R6GvEX0XU97f6DP1/uGlTR9VRgy2VwGByCEPWvUvCuoXV7poS+gkiuYcKxdcbvQ1uV5P4s0q/n8S&#xd;&#xa;30sNpM8bOMMF4Pyisf8AsTU/+fGf/vg0f2Jqf/PhP/3wa7LwG02nO9tdadJE0pys5T9DXfDpQeMm&#xd;&#xa;vN/G0moavepDbWc5t4M4Ow/MfWuh8B6U+naOZJ4yk07ZIYcgdq3NVleDTLiSJGdwh2qoySa8fbTN&#xd;&#xa;ZZixtrrJOTwaT+ytZ/59br8jXd/D0XsFtc215DKmGDoZAfxrq7mFbm2kgcZWRSpz7143d6BqUN1L&#xd;&#xa;EtnMyqxAYLwRTI9I1aKRZEspwyEMDsPBFex6XcyXem288sbRyOgLowwQ3f8AWqfii6uLbQ7g2cTy&#xd;&#xa;TuPLQIMkZ7/lXkx0TU8/8eM//fBrU8M+HryfXbUXVrJHCrb3LLgcc4r1sdK888fx6je6xHFa287Q&#xd;&#xa;wxAbkBwSeT/SuW/srWf+fW6/I1a0y11iy1G2ufst0fKkDEEHpn/9dexA5APrXCfEXRZ7qa2vbSFp&#xd;&#xa;GIMcgUZPqD/OuKOian/z4T/98Gj+xNT/AOfCf/vg0f2Jqf8Az4T/APfBo/sTU/8Anwn/AO+DR/Ym&#xd;&#xa;p/8APhP/AN8Gj+xNT/58J/8Avg0f2Jqf/PhP/wB8Gj+xNT/58J/++DR/Ymp/8+E//fBo/sTU/wDn&#xd;&#xa;wn/74NH9ian/AM+E/wD3waP7E1P/AJ8J/wDvg0f2Jqf/AD4T/wDfBo/sTU/+fCf/AL4NH9ian/z4&#xd;&#xa;T/8AfBo/sTU/+fCf/vg0f2Jqf/PhP/3waP7E1P8A58J/++DR/Ymp/wDPhP8A98Gj+xNT/wCfCf8A&#xd;&#xa;74NH9ian/wA+E/8A3waP7E1P/nwn/wC+DR/Ymp/8+E//AHwaP7E1P/nwn/74NH9ian/z4T/98Gj+&#xd;&#xa;xNT/AOfCf/vg0f2Jqf8Az4T/APfBo/sTU/8Anwn/AO+DR/Ymp/8APhP/AN8Gj+xNT/58J/8Avg0f&#xd;&#xa;2Jqf/PhP/wB8Gj+xNT/58J/++DR/Ymp/8+E//fBo/sTU/wDnwn/74NH9ian/AM+E/wD3waP7E1P/&#xd;&#xa;AJ8J/wDvg0f2Jqf/AD4T/wDfBo/sTU/+fCf/AL4NI2j6iilmsplUDJJQ8VX8mb+6a9p8P/8AIv6d&#xd;&#xa;/wBe0f8A6CK0aKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKp6t/yCrr/AK5N/KvGK9i8P/8AIv6d/wBe0f8A6CK0aKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKp6t/yCrr/AK5N/KvGK9i8P/8AIv6d/wBe0f8A6CK0aKKKKKKYxCgkkADqSajt7u3u1LW8&#xd;&#xa;8cyg4JRgQDU1VzfWou/spuIvtGMiPcN35VYpaKKKKKKKp/2lZG8NoLuE3GceVvG7OOmKt1FcXENr&#xd;&#xa;EZbiWOKMHlnO0CnxukqK8bBlYZDA5BHrTqWiiiiiqk2o2UFytvLdQxzN0jZwGP4U+e7trZkW4nii&#xd;&#xa;ZzhQ7AFj7VOOlLRRTScDJIx7mkR1flGVvoadS0UUUVDc3MFpE01xLHFGOru20D8afG6yRq8bBkYZ&#xd;&#xa;BByCKfRRRRRRRRRRRRRRRSGmLIjHCupPoGp9LRRRRRRRTGdFYBmAJ6AmnUtFFFFFFFFFFFFFFU9W&#xd;&#xa;/wCQVdf9cm/lXjFexeH/APkX9O/69o//AEEVo0UUUmR0zQSB1oqvfW63tnNbM5USKVyOorH8L+Gx&#xd;&#xa;oCT5ufPaU+mABVDRvE19f+KJtNmSEQJuwVU546c5qtP/AMlOi/65D+Vdp58XmeWJU3/3dwz+VSUd&#xd;&#xa;K8c1TULk+Ibq8jkk2xT5wGOBzXqq6hGdIGoZ+TyvM/SvKtP1G5bxDb3sksm2WfP3jjrXseRiigEZ&#xd;&#xa;rzaP/kqh/wCu5/8AQK2/GHia90TUbaC0WFklTc29STnOPWtTxLoY1/To7f7R5DxuHVsZGcY5H41c&#xd;&#xa;0bTl0nSoLJZDIIhjeeMknJ4q4zoqbndQvqTgUI6SIGjZWU9CDxTY5opGKpIjMOoVgSKkzxUazxNI&#xd;&#xa;Y1ljLjqoYZqSo5J4o3CPKisegZgDXn3ib/kf7P8A4BXQ+JfCy67fW9wbswmPgrtzkZ7ehroY0EMK&#xd;&#xa;pnhFAyT6Ukc0cufLkV8f3SDUgNFeYanPe+J/FL6YbkwwByqrn5QB3x3NbWn+C7zSdWgmstTYQDmX&#xd;&#xa;5cE+2OhrtOg9KYs8LSFFlQuP4Qwz+VSZ4pCwAJYgD1NNjljlXMbq4zjKnNIJojIYxIm8dVDDI/Cs&#xd;&#xa;rxPoY1/T1t/PMDI+9WxkZwRyPxq3ounrpOkwWSymQRKRvPfJJ/rVxnVVLMQFHUnikjlSRd0bq49V&#xd;&#xa;OaVnVFLOwVR1J4pEkSRdyOrL6g5FPyMU1nRFLOwVR1JOKTzEMe8OpT+9kY/OkinimBMUqSAddrZq&#xd;&#xa;SiovPi8zy/OTf/d3DP5VLSZpiTRSMVSRWI6gNmpBUF7dRWVrLczNtSNSxrzfz9Z8aai8UMzQWinl&#xd;&#xa;ckIo98dTV9/hzNFHvttU/fDoDHt5+ueK09UivLTwDJHeSOblEwzFsnr61yfh/wAO6hrtq9xBfiLY&#xd;&#xa;20h2b+lWroeJPCMsc0l001uzY++XRj6EHpXoOi6nFq+lw3sI2hx8yk52kdRV+uf8csyeFbxkYqRs&#xd;&#xa;5H++K4nw94bvNd06S7h1JoWSQoEOTkgA9c8da1PA+s3661JpF7M8ygMBvJYoy+/p1qz4z8U3EF1/&#xd;&#xa;ZOlErPwJJU+8Ceir7+9Z8PgDUruHz7y/SOZudrZc59zUFrqeseD9UWz1Bmmteu0ksCv95D2+ld3r&#xd;&#xa;V6ieGru8hfKm3ZkYe44/nXnXg3UJrHxBaNNIxhugYuWOOeB+oFdv451A2HhyYI22S4IhU/Xr+gNc&#xd;&#xa;x8PLuWLXLi2uHc74ujEnBBH+Nekiloooooooooqnq3/IKuv+uTfyrxivYvD/APyL+nf9e0f/AKCK&#xd;&#xa;0aKKK818Zxy6N4sttSiJCSlZcAnG5SAw/LH51d8eXL38+nafaNkzfvBg9c9KZ4b1k2XhTUopWPm2&#xd;&#xa;pZQD78VX8IWbnRNV1GUsS8bIhJPpkmn+A7ZtR0nVLV5WXzcLuHJHFY2iaKt14pawNw6eSxIcDk7T&#xd;&#xa;WxrsFzP48S3s5jDJJEq+Z3UY5ql4q8MDw/FBeW93LIzvhmbgg+uRXoPh+4ku9Es55Tl3jBYnuat3&#xd;&#xa;cnlWk0mcbEJ/SvMfDen/ANrWGtsRlmXK/XOaVdcYeBjp+f3wl8rHfb1pviPTv7K0rRW24cLuc++c&#xd;&#xa;1uePZzJ4dsJUYjfg8H2Fb/g458LWB/2D/wChGuS8FMx8bXwJJG2Xv/timxf8lVP/AF2P/oFUfHOl&#xd;&#xa;iw1zf57Sfay0pBH3Mt0FbXi3Tv7G8FWtms7S+Xc/fPBOQxqeZm/4VWDk58pec/8ATQVkeGPD03iH&#xd;&#xa;R3+030sVtFKRHGozlsAkn8xVLwzb39xqdxosN68EEmfPKeint6E07VdOk8KeJLUWlw7BgsiseD1w&#xd;&#xa;Qfyrf+IetT2zwadbSmISrvldTg4zgD6cVzt5pei21gZrPXRLfIA20KQGPsa6HT/E90fAt3dSOWu7&#xd;&#xa;dvJEh6nOMMfcZ/Ssfw34Zk8SRzX15dyoA20MOWY/jTLuyutP8YWVrdTmfYyCORupXtmtL4jOy6vp&#xd;&#xa;4DEZXsfer3jfUriGxsdPtnKG6ADEHBI4GKqz+C59I0uW7stQk+0rGfMTaArDuKtfDNi2nXm5if3o&#xd;&#xa;6/Su0rjPEvg6W6vG1HSZfLuM7mQttyfUHsaoaR4t1PTL9bDXo3Zchd7jDr7+4q14+1uaHyNPtZTE&#xd;&#xa;sy7pJFP8J7Vzt1pmjW+n+fZ67vvUG7btIBPoDXRafq8+p+BL/wC0OWmgQoXPUjtWJ4S0i416C5tp&#xd;&#xa;byWGzTazKmDvPOP61BYWt9p/imXR7G8aJpHMLSAfw9c49cVJ4p0E+Grm0uLW7lkaUsd7cMGGP8a6&#xd;&#xa;Lx1O8vg6wmYkPJJGx57lGNK7H/hVmcnPkDnPP36xvC3h+fxDpLC6v5YrOOQhI0wctgZJ/Sk8NrPo&#xd;&#xa;vjg6YkpeMu0bg8BhtyDin+J57vX/ABeujxSlIY3CKM8ZxlmI/OpPEHhaXQNDmmsr+WSBionjYAAj&#xd;&#xa;IwRj3xVuwLH4W3BJOdr855+/WN4e0TUPEelNAt0IbOCUn5sne5A7ewx+dS+KoJtOl0rTLt5Bp0MS&#xd;&#xa;Bmj6OcneR71r6Boujy6lHd6JrEyqqfPCD85+vt+FdyOlcz451qbStNRLZtk052h+6jviuai8EXN3&#xd;&#xa;pK6j9tP2qRPN2Mv/ALNnrWp4H1q5vLa7sLxzJJAhKsxycdMZrnfDdhdatql3aRXkkELZ85lPJXPQ&#xd;&#xa;UutaU/hTXLU2dzIwfDKx4PXkGvVYG3wRserKDWD473/8Ixc7PUZ+maz/AIaeX/Y05XG/zfm9enFd&#xd;&#xa;jWF42/5Fe8/3R/Osn4Z/8ge4/wCu39K0fHmz/hFbrfjOU2/XcKofDMv/AGFcbs7PtB2/98rmtFvG&#xd;&#xa;mgAkG+wQcf6p/wDCovGc8dz4LuJ4W3RyLGyn1BYYrgdO1nWNI0f/AEOQR200rDdsBO/AzyfbFdj4&#xd;&#xa;G0BYFGsy3CzzXCHbt6Lnrn3rntLwfiQ32r732qXr6/Nt/pXqdcN8URH9isSceb5jY/3cc/rior6d&#xd;&#xa;4fhbbK+d0oVB9NxI/QVk3unPF4H0nUohiSGVySPRmOD+YH51c1y9/wCEn1jRbKM/u3jR5AOzNy35&#xd;&#xa;AVFM39m/EpgoAVpl4Hoyg16aKWiiiiiiiiiqerf8gq6/65N/KvGK9i8P/wDIv6d/17R/+gitGiii&#xd;&#xa;uW8f6cb7w+0yLmS1YSDHXb0P+P4VzfgmK41LX4p7oMVs4Qqkj0GBVDxRa3Fjrd7awo3lXLB8AHmu&#xd;&#xa;8g08ad4Oa2A+YW5LfUisP4YqyQXwZSPmXqPaqfhhHHj65Yo2D5nJBq/co3/CzIW2nGwc49qn+JSl&#xd;&#xa;tHg2qT+97D2rb8Kgjw3YA/8APIUvieY2/h69dQSfLIAHvWB8NbcppVy7rjzJMYI9BWC2gyf8Jz9i&#xd;&#xa;2HyfN83ocbetdB8SLcyaRbuikmOTHA9qhvLCbWvAVqYFLTwICExy2CMj8qydG8bSaPpSafLY+ZJD&#xd;&#xa;kIxfbjnPIx2zV74e6fcvqF1q9whRJEKqSMBiTk/hxUEaP/wtInaceceSP9il+JKM2sWJVSQIuoH+&#xd;&#xa;0a2PiOrN4ehAUk/aF6D/AGTVeZW/4VWF2nPlLxj/AKaCrnw6Ur4bIYFT578fgKwvBaOvje+JUgbZ&#xd;&#xa;eSP9sUvxDR28R2JVSQIl5AP981c+Iej3M0tvqdtEZREuyRQucAHIOPTmseTxLpktqqW3huzF42Bk&#xd;&#xa;xgrn2GMmuom0iTUfBs0C6dDp91MBJ5MYwCwORkY4JA6Vyvh7xNN4ZWWxurJ3BbdtJ2sp/EUk95ea&#xd;&#xa;n4us7u5tWg3shRCOi9q0viKjtq+nlVJG3sPer3jfTbiawsdQtkLtagFgBkgcHNUbjxrc6tpctpaa&#xd;&#xa;c32hoyHcNkKO5xir3wyUrp15uVh+9HX6V2lcPf8AjDUNI1ueLULBvsvSMA4P1B71h391deM9bg+y&#xd;&#xa;2jRogC+u0Z5JPatnx3olwVtb62jMywIEkULngdD9KyT4l017VYrfw5aG8PGWjDKT9MZrqJYSvgm6&#xd;&#xa;dtOisZpYiWiiGPxxVL4ZqVs73cpX5k6/8CrPhR/+FpFtpx5zc4/2DVz4oIzw6ftUthn6D2WneM1Z&#xd;&#xa;vBGmgKScxZwD/wA8zUrq3/Crdu07vJHGOf8AWVZ+HClfDjhgR/pDdR7LWGqP/wALS3FTjzjzjj/V&#xd;&#xa;1H4ot7vQfFg1iCLdE7h1btnGGUntS694quNf0aaCz0+SOAbTPITuxyMDp64q/p6sPhdOpU7tr8Y5&#xd;&#xa;+/V34bKy6BMGBH+kN1H+ytS+Kteh066itL/SmubKTl5GAIP+6PX6kVxqxQ6h4libwzbzxRrgnd/C&#xd;&#xa;edx6nAxXrUedg3HJxya5nx1os2raYj2yb5oCWCd2HfFc3F43ubXSF04WR+1Rp5XmM3/suOtangfR&#xd;&#xa;biztbq/vEMbzoQitwcdc4ql8PUZddvyyso2nqP8Aap3xGR21fTyqE/L2H+1XfWv/AB6xf7g/lUd9&#xd;&#xa;aRX1pLbTDKSqVNebKuseCNQkaOEzWjnk4Oxx9R0NX5fiNNLHstdNAmPA3SFhn6ADNaurSXdx4Akk&#xd;&#xa;vUYXLoC4K4I59K5Lw94mutBtJLeKx84O27LZH8qtXdz4h8XyR2/2QxQK2cBCqD3YnrXoGiaXFo+l&#xd;&#xa;xWUR3BB8zdNxPU1nt4L0EklrHJPP+sb/ABqPxjbpb+DLi3t0wkaxqq8nADCsLwrpC6v4LvbORdrm&#xd;&#xa;4Zo2IxtYKuD/AE/Oo/Aepz6ffyaPeo6LIxCbh9yTuPxx+lW/Gfhm6e9/tjSgzSjDSxp94EdGHrVO&#xd;&#xa;D4iXlvD5V3YJJOgwW3lMn3GKqW9jq/jTVEurtGhtF434wqr6L6mtf4iqLfSdPsYEOwOSAB0CjA/n&#xd;&#xa;W1b6WLrwPFp7D5pLQYyOjYyP1rmfhxpsh1K5vZ0IECeWuf7x6/kB+tQeOYpLfxhDcIjEMkb5A9CR&#xd;&#xa;/SvSoH8yFH/vKDUlFFFFFFFFFU9W/wCQVdf9cm/lXjFexeH/APkX9O/69o//AEEVo0UUUUUUUUUl&#xd;&#xa;FLRRRRRUL28DuHeFGbsxUE1KAAAB0paSiiilpKO3NRLbwrIXWKMOerBRmpajeCKRgzxIzDoSoOKk&#xd;&#xa;opCMjBGaZHDHFny41TP90YqQUtMkjSRdsiK49GGaSOKOJdsaKg9FGKfUSW8KPvWFFc/xBRn86lpa&#xd;&#xa;KKSiloprorqVdQynqDyKbHGkS7Y0VB6KMCn0tMdFkUq6hlPUEZFJHFHECI41jB7KMU8UGovIi8zz&#xd;&#xa;PJTf/e2jP51LS0lFLTWAIwRkVGlvBG26OGNWPdVANS0tFFFFFFJ3qJ7eGRtzwxsw7soJqUYAwBgU&#xd;&#xa;tFFFFFFFFFFFFFFU9W/5BV1/1yb+VeMV7F4f/wCRf07/AK9o/wD0EVo0UUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVT1b/kF&#xd;&#xa;XX/XJv5V4xXsXh//AJF/Tv8Ar2j/APQRWjRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRVPVv+QVdf9cm/lXjFexeH/8AkX9O&#xd;&#xa;/wCvaP8A9BFaNFFFNZgoLHoBk1h6N4psNYvprW33q8fKlhjePUf/AF63a5rxhrV7o6Wn2Hyt00m0&#xd;&#xa;+YpI9qh0zxBqcWtx6VrEMHmSruSSEnFdOZolALSqATgHI5NK0sasEaRVY9ASMmiSRIk3SOqL6sQB&#xd;&#xa;So6SKGRlZT0IORTVmidyiyozjqoYZFOLqDgsAcZ601JopFLJIrAdSGBrM0LXo9aa6CQmLyJNnLA5&#xd;&#xa;9601niZiqyIWHUBhkVmeINdi0SxjumiM6vIEAVgOoJz+lF4uqS6rYy2VzDHZAZnjblm+nrWnJLHE&#xd;&#xa;oMsioD0LMAKcGUoGBBXrnPFMeeFNpeVF3cDLAZp7ukalnZVUdycCiORJUDxsrqejKcilJAyT26mm&#xd;&#xa;RzwyA+XKjY64YHFBmjBUGRAX+6CR81DTxJII2lRXPRSwBNPdlRdzsFA7k4FMSaJ1DJIrKeAQRg1l&#xd;&#xa;nXov+Ej/ALIMR3bN/mbhj6YrUkniiIEkiIT0DMBmnkgDJOB1z2rmfEOqXEGraSlnc4hnk2uEwQ1d&#xd;&#xa;OOlMM0Yk8syKHP8ADuGfyo8xMZ3jHrmkM0QcRmVA7dF3DJpZJEiXdI6oPVjgVzlxqVyPGtrZxzk2&#xd;&#xa;skJYoMEH3rpeg5PFMeeJE3vKir6lgBT9y7d2Rt65zxTEnidcpIjLnGVORmnF1BILAEDOCaassbgF&#xd;&#xa;ZFYN0wwoE8TIzLKhVeCcjA+tKssbqGWRWB6ENkVlQ69HL4km0cRENFHv83cMHgcY/GtR54o2CySI&#xd;&#xa;jN0DMBmnlgqkscD1Ncz4t1We1j05tPuQBLdCNzGQcj0rpq5rw7qdxcaxrcd5cbobefbGGwAoy3H6&#xd;&#xa;V0ayxsgdXUr2IbilLqoySAPUmkdsRswxwMiuEtfEfiS7hvLqBLN4LRyHVlIYj866zQ9VXVdJhvGX&#xd;&#xa;yi/BUnofarwmiLFRIpZeoz0pxZQMlgAe+aHdUXe7BV9SeKRJEkTcjqy+qkEUkc0UhIjkRyOu1s4p&#xd;&#xa;9cPba74m1K/u4NOSzZbdyp3jHGfrXWaUb/7EDqnlC4zz5fTH+c0t3dJ9iumglRpI4mPysCVODWZ4&#xd;&#xa;M1C4v/DyXF7MZJN7Au2Bxmt0ugTeXAQc7s8Ukckcqbo3V19VINc54J1K81GC+a8nMxjuCiZAGBjp&#xd;&#xa;XTClooooooooooooooooqnq3/IKuv+uTfyrxivYvD/8AyL+nf9e0f/oIrRooornvFNjrF2tqdKvF&#xd;&#xa;gSOQNIM7cf7We4Hp/OsSa5g1aOe18NzRw3+4GZ1TZ5+OpU54GecV2VhHcRWUSXcolnVQHcDGTXJf&#xd;&#xa;EcMY9NVG2sZsA+h9at2PhmWCd9T1K+a8uREQny4C8VkeENCg1C0e9uZJXNvMxijDYUEc9Ky0gn1c&#xd;&#xa;6hdTWvn3CyECd7tYxDzx8prc1DStWvNN0uSeOO8eBT5lsZh+99wQcHiqz6lBb+Fr8aVbTWUyyBZo&#xd;&#xa;2cny8/3apppNwtrZXNhpy2twSCty1+h80/7prS1Cy/tHxzBbXTOoa2BlVGxu45GR2o03Tbe08ZXu&#xd;&#xa;lwqy2kkBzHuPPFZ2jQiy0fXLy1DLPCxiRgTwuatwaFpX/CHPqXnut0YGYyiUj5sfdxnv0/GqGqWk&#xd;&#xa;TeA9Hu2B85XMYO442lnJ/kK2dUtYrLxT4atoFKxRrhQT05qGCzg8ReKtVj1iZ8WzFIYfM28AkZH5&#xd;&#xa;Z/GodMc29p4m0yCcz2NvC5ibOcHnp/ntUUOhWk3gE6nNve6VGZGLnCAORtA6Y6/nV24sL/VPD+h3&#xd;&#xa;MYW7WGPL2sj7TLj37nArX8Gz2DJewWdpLZTRyfvrd3LBG56e3FV/iFdTQ2FnAkrRQ3E22Z1OOPT/&#xd;&#xa;AD6U6bQtK0jRdSm05jvksZFYGTduXH3sVn+F9Gi/sKHW2kllu7eORoE3fIuN2Bj681iWNhJqej3F&#xd;&#xa;7JY/aJ2Zib2S+VPLPup/PmtLWTeyWfh7TtWmKRyuRO6uCGAYAHI4+6RTvEWj6fo97pYsHZN84zF5&#xd;&#xa;hYHn72DUr6XaD4ieWIzt8vzsbj9+s23gl1q71Ge60430quVDG7EXlDtwas3H9o23ha2tbuTMUlyE&#xd;&#xa;3JKH/d+m4GpdW0qx0nX9IjsHYK0mTHv3Y9676ZmSF2XkhSR9a8+8O6VY6xDqF/qMzm7SRvm8wqY/&#xd;&#xa;eqtvx4C1ABtwFzw3rz1qbW9EtrLwxaalE0pvCUJlZySc+3arerImq+JtMsdRlYWpgVtpbAZiPWnW&#xd;&#xa;1ja6d4+trazkYxLEfkL7tnsM/wAq7LVP+QXdf9cm/lXCeHfD9nqPhea5u2kkdVk8td5CxkDqAPwq&#xd;&#xa;nJe3S/Dy1jEriOS7MTHPROTj6Zq14q0TTNK0qzk0+Vt0kqgr5hIlGD82P89at6zZDUvH8No0rxRy&#xd;&#xa;2o8wocMVwxIz71Fr+kRWmtaDplnJJFF8yhwcsAzZPP40niXSrfSv7K0mCSSKwubkvM7tyT8o5PsP&#xd;&#xa;50us6VYaR4h0OOwdkV7hWaEuWx8w5wemelPs9LtY/iPdRrE22GPz0G4nD/Kc/qayNOtpdbhvry60&#xd;&#xa;83sxc5ma8EXk8f3T2FW9WfUYPCmmWl/NtjluCjSLIGBj4xyOO5/KpfE2jadpDaWLB2XzLhcx+YWD&#xd;&#xa;dPm+vb8a9Frz/R9KsNW8Sa7FfszKlwSsIkKg/M3zcHnH9ai0rTlubvW9Et5DJaKu6PkkKw6c1Thu&#xd;&#xa;p9YttN8Ptu8yKYiX/dBr0sRLDaeUgwqJtA9sV5fpem/a7DVZ21J7ZYZCfKJ+ST6jNW9RvTf+C7Bl&#xd;&#xa;iS3K3HlgRjA47itDXdBt9L8LXU8LzSTzhDK7tnNO8TTxP4HslSRSzeWAAeTUOrqNQ1/S9Lv5misv&#xd;&#xa;IVtu7aGOKk8TW0Gh6ELTSXZYZ5wJQJORx0z2zVOHSru11Cwm07TlsZMgkm+V/NXvwa9GHTnrXmWk&#xd;&#xa;6Yuo6xqe7VJLDZKeUfbu5+orW8UedpPhOG3t76S4SWYJJcFsnbjOM/hV608P6RptlNc2EpaZ7Nxu&#xd;&#xa;MmfMGOTiuQsZnfStLsb5mt9JlmcySofvtnofQDj889q3PF2f7X0rSYYd1j5e5bdZBGshyQBuP0H5&#xd;&#xa;1J4e068sfE/+j2aWVoyfvrf7WspHBw2OvXFWfh3zbal/19H+VdhS0UUUUUUUUUUUUUUUVT1b/kFX&#xd;&#xa;X/XJv5V4xXsXh/8A5F/Tv+vaP/0EVo0UUUVRs9KsbG4lntbaOOWU5dlH+cVdrP1XR7PVvJ+2Kx8l&#xd;&#xa;tybWI5q60atE0Z+6VwfpVXTNLtdJt2hs1ZUZixySeTWbe+D9Hvbw3UsLq7HLKj7VY+4qxf8AhzT7&#xd;&#xa;9IVZJITANsbQuUKj0p1l4f06ysZrRIN8c3+sMh3F/qao2vgrRrW6WdY5XKnKo75UfhWodItDqy6n&#xd;&#xa;sb7Sq7AQxxj6Ui6PaJqz6mEb7S67Cdxxj6U2x0OxsY7mOGJilySZAzFs5rMTwNoiOxMUrBs/KZDh&#xd;&#xa;c+lXpvDenTaTDpjxubaFt6AOc557/ianudHs7rULW9lVzPa8REOQB+FVNX8LaXrE/n3MbrN0Lxtt&#xd;&#xa;LfWp7TQNOs9Ml0+CHbDMpEnPzNnjk09NFsk0Y6SqN9kKldu45wTk81VuPC+m3FrawETR/ZBiJ45C&#xd;&#xa;HUH3q1pGjWmjxOlorbpDud3bczn3NT6hp9tqdo1tdxiSJux7e4NZen+E9L09LlYRK32mIxPvfPyn&#xd;&#xa;qK1NOsLfTbFLS1UiGPO0Mc9TmsafwRos1yZvLlQMdzRpJhCfpWhqGg6fqGnx2M0GIYv9XsOCn0NU&#xd;&#xa;LfwXo9uY2EcrPG4YO0hzn/CtP+x7T+1v7T2t9q27N244x9Kz9Q8H6TqF21zIkscj/f8AKfaG+tXG&#xd;&#xa;0LTm0r+zPs6i27KOufXPrVK18G6PayRSxxSGSJtyu0hJJrf68VgXHgzRrm9a6eGRSxyyK5CsfpU6&#xd;&#xa;eGNMTTJdPWN1t5W3su89asXujWd7pqafOjG3TGAGIPHTmodU8OadqsMUdzG2YVCo6thgPrTNP8La&#xd;&#xa;Xp11Fc20TrLGMBi5OfrWtNEs0LxSco4KntwaqWGk2mn6e1lbKwgbcCCxJ561BH4d02PSG0sQs1qz&#xd;&#xa;FtrMSQT3zVGPwNokabTHM53Ahmk5Ht9K1TpFodWTU9rfakTYDuOMYx0ovNItLzULa+nRjNbf6shi&#xd;&#xa;AO/SjVtJtNYtfIvIyyg5Ug4Kn1BrOtfBuj2skEqRStLC4dXaQkk+/wCVaMekWkesSaoqP9qlTYzb&#xd;&#xa;jjHHb8BWZe+DNHvLtrl45Y2kOXWJ8Kx+laFxoWnT6UNNe3UWq/dVeNp9QfWs6HwTo0IQiKZ3Rw4d&#xd;&#xa;pDuyO30rougrAuvBuj3cs0rxyiWZ97OJDnOecVc0vR7HQbaRbOJufmYn5masLwhp80ur3+sXdu8L&#xd;&#xa;SOViV12nHc4rsGG5SDyCMVzp8EaGZTI1s7EtuIMjYrQu9B0+7sobSSErBCwZFQlcGrk9pBcWjW08&#xd;&#xa;YeFl2kH0rCtvA+i29yswjlYqcqryZXP0rQ1fQrDWY0S8iJKfddDgiorbwzptvpcmnCJpLeQ7mDtk&#xd;&#xa;59c1Dp3hDSdOuluIo5HkXlfMfcF+lb1c7N4J0Wed5pIpS7ksSJD1rQi0HT49KOm+SXtT1VmJP51V&#xd;&#xa;03wnpmmSzSQCYmWMxHfJnCnqB+VTDw3po0f+yvKY2pbdgtkg+oNNuvDWm3mnQ2U6SNHBxG+87kHo&#xd;&#xa;DTtH8OafosjS2sbNMwwZJW3Nj0qxpWkWmkJKtorKJX3tubPNXxS0UUUUUUUUUUUUUUUVT1b/AJBV&#xd;&#xa;1/1yb+VeMV7F4f8A+Rf07/r2j/8AQRWjRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRVPVv8AkFXX/XJv5V4xXsXh/wD5F/Tv&#xd;&#xa;+vaP/wBBFaNFFFFNyCTg9OtLTJpo4ImkmdURRlmY4ArBbxtoKzeX9sJ5xuEbFfzxW7DNHcQrLCwe&#xd;&#xa;NxlWHcVJS0UUVmWOtW19qV1YxLIJbb75YDH4VpUx5EjxvdVz03HFPHSloooopjsEVmPQDJArP0bW&#xd;&#xa;rXWLFruDekSOUJk45GP8aNX1uz0eCKa5Zikr7FMY3c1pAggEdKWs3UtZt9NvLO2nSQvePsjKAEZ4&#xd;&#xa;68+9aNLRRRRRRRWZLrVpFrMelvv+0SLuGF4/OtKloooooooooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooqnq3/IKuv8Ark38q8Yr2Lw//wAi/p3/AF7R/wDoIrRooorC8Q+IoNC8hZYpXMzY&#xd;&#xa;+QfdXueeCfasCNJfCLzapd3k95HdH92mCC+ecvnofauzsbuO+s4rqIMElUMAwwa5Px7LJNcabp28&#xd;&#xa;pDPJ+8wevNdLDo+nQWgtUtIfKxggoDn61l63rDaMbXTNKtVlupRiKMn5VFRabrmrJqf9n6zZQwyt&#xd;&#xa;E0kbxng47dTWfF4p1280+5urSxttlsx8x2JwR7DPWibxXrTaSmqW9hbraqQJC7Elj3wM8D86v6p4&#xd;&#xa;murb+zDZ2iSm9XOxiQc+gNMh8QavZazBZa1aQRx3JxG0LHj/ABqroVwlr4n1+eTOyMbj+FR/8Jfq&#xd;&#xa;0kDahDbWAslP+reX96w/P+lUPG+oS6laabcxxoLWT5kyfm3dwa39U8R39pLaadFBbjU5ow8vmPiK&#xd;&#xa;P8c+1S6B4iuLvU5dL1GO3W5RN6yW7bkcce59a1ddvpNM0a5vYVV3hXcA3Q847fWuWufFmtw6ba6q&#xd;&#xa;1hbLZSEK2WJZj7c8Dg4qxc+JtXs76xku7KGOwvWCoAxMgBxyT2OCOK1Idbmk8X3GjmOPyY4g4fnd&#xd;&#xa;nAP9ajt9bnuvEepaU8SLFbQllcZ3Hhf8a5Kwa4X4cXnkIjK1wRMWP3VwvI/HFaUes3eleENKkmtL&#xd;&#xa;WTdKqRBwWG3bkN7NmuzuNQs7VwlxdQxORkLJIAcfjWP4l8QPpkdpFp8aXNzetiHJyuOOePqKwNVn&#xd;&#xa;1STXdBj1e1ijlS4BV4myjAsvHsRitfUtf1OTW20vRbaGR4hmR5s4H+FRW3iTV57y/s2soI7i1i3h&#xd;&#xa;CS2T9c9KRvGL/wDCNx38cMf2xpfK8nnG6umtpZjp6TXKKJtm50ToDjoK5fTvEesardM1mmnmJJNh&#xd;&#xa;t3crLj1qxrHiS7j1T+zNNjtvPVd0j3D7VX27U3TvFU89rfpcwwreWaFsRtlH/WqD+LNcOkR6olhb&#xd;&#xa;Lag4cknLfQZ4FTXfinWLZbS9ewgTT7hgoBYl+e/tWlNrDL4rtbBbaErLFu80j5xkdM1Sh8Ra1f31&#xd;&#xa;9Z6fY2zvbsQHdiAB788mn6d4tkk0O+u763VZ7RtjIhIDH8elQDxB4ki0p9Un061a1KblAYhlHYkZ&#xd;&#xa;6VLf+LLq10nSLz7NG5vSfMQZ4Ax93n+dMvPEmtadYGW/sYbeSeYRwBj8qLjksQf8K2tDutTuFkN+&#xd;&#xa;tm8YA8ue1fKv68Vr0tFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFU9W/wCQVdf9cm/l&#xd;&#xa;XjFexeH/APkX9O/69o//AEEVo0UUVBcW0NyqiaJJNjB03KDtYdD9a5zRvD2oW1/ePql4t5bSn/Vu&#xd;&#xa;Nwc5yCQeldSAFAAAAHAArE8TaCNbs1VJPKuYm3ROR0NZKXPjSKIWv2G2kYDAuC4/Pr/SpdY0XVZJ&#xd;&#xa;LDU7R45NRtlw6scB/pSWFlrmo6uuoavbxW6xQskcasCcnv1NLo+iX1p4d1CzniUTTsxQbwc56c03&#xd;&#xa;+w7/AP4Qb+y/KX7X/d3jHX1rN1+C7tJ/D0MexLuNdoDHgN9RV1dN1zWdctbnVbWK1gtDkBGB3H8z&#xd;&#xa;Viy0C7Oq6y9woS3vVKowYH9KxoPD2sWifYl0TTrjDfLdyhTx71qeJvDt5e6dp9vYwQBoDl1jIRR9&#xd;&#xa;BS+JtAurjVodVs7aC8KoEktpsYYDuM/WrPhrTLqG6lu73S7CxyMRJAg3r65I7Vp+I7ObUNBu7W2U&#xd;&#xa;NNImFBOO4rE1TQr+48FWemRRA3URTcpcDGM55/KpvEejXuoQ6QttGrNayK0uWAx0/wAKi1jTNWtP&#xd;&#xa;Eh1rSIY7kyR+XJEzAdvqPQU/w9pGpLqOoarqiJHc3SbFiUg7Rx3/AAFVtP8AD+oweCb7TJIVF1NI&#xd;&#xa;WRQ4Ix8vf8DRqvh/UbnwvpFlFEpuLVlMoLgAAA9+hroNQ0DTNUnE99aLLKF2BixHH4H3rK8TaDcT&#xd;&#xa;RadcaOqibTyPLjJ4KjGOvpgVSuLHxFq2q6XeXtpBBHbTBjEsgyBkEk8+3apb/TdY03xFLqmkQR3S&#xd;&#xa;XC4dGbbg/ial0HStWj8Q3WoanHEBPHj922QPasOx0mK58czW8LF7S3kMzL2Deleitna2zBbHGfWu&#xd;&#xa;E1HRdW1G8QnRra1uFlDG9hlABH+71zU+s+Hb6PV/7QtbK31JZECyRTY64681Z0/Rrz+yb7ztOsbW&#xd;&#xa;4nQrHHAoUgehbOKRtCvz4HGl+Upu/wC7vGOvrT9a0S+vPD+n2kEStNAylwXAxj3qWXSLxvFlnfiM&#xd;&#xa;fZ4oQjNuHXHpT/Dmk3mn6pqc9zGFjuHzHhgcj8OlZtr4XvX03V7W5CxtdS74SGzn0zUZt/FU+iya&#xd;&#xa;Q1jbxxiPZ5xkGXHoOetS3fh7UZdL0CBIVMllJmYbwMDI/PpW94hjvZbNUs7G2vVLfvYZjjcvt2zW&#xd;&#xa;T4S0e8sNSvLqW2FhbTKAloJN+Dxzn/PWusHSlooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooqnq3/IKuv+uTfyrxivYvD/8AyL+nf9e0f/oIrRoooooooooooorOv9HtNQu7e5uA3mW5zHhs&#xd;&#xa;DNaFLRRRRRRRRRRRRRRRTWGQRzWfpei2elPM9sr7523OztuJNaNLRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRVPVv+QVdf9cm/lXjFexeH/8AkX9O/wCvaP8A9BFaNFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFU9W/5BV1/1yb+VeMV7F4f/wCRf07/AK9o/wD0EVo0UUVHJIsYyxAycAZAyew+tc5o&#xd;&#xa;XiebU9Ruraexa2jhJw7cbecYb3rph0rn/FmuSaTbRR2qhru4bZHkdPeqEXhvXpYRPN4iuEuiM7Fz&#xd;&#xa;sHt1/pW+LpdM02N9Vuo1dVAeRjgMfam2+v6VdRSSwX0TpEMvzjaPcGphqdi1ib0XMZth1lB+Wo5d&#xd;&#xa;a02GzS7kvIlgf7rk8N9KfZatY6hC0tndRzIn3iDyv1HWoR4g0o+Vtvoj5rbE2nJJ9OKa/iPSEu/s&#xd;&#xa;rX8Imzt25PX0z0rVBBAI6VnS67pcPnCS+hUw8OC3IqM+I9IFoLo6hD5LNtDZPX0x1q5BfWtxaC7h&#xd;&#xa;nRrcgt5gPGO9VLXxFpF5c/Z7fUIXlPAUHGfoTwanuNVsLW4MFxdRxShPMKMcHb6/oaj/ALc0z7AL&#xd;&#xa;43ka2zEqJDkZI6getSafq1hqisbG6jm2/eC9R+BqzPNHbwvLMypGilmYngCs1/EujRmPdqEA80ZU&#xd;&#xa;56jp+HSpH17S474WbX0IuCQNue/16VJqGr2Gl7Be3UcLP91WJJP4U1Nb0yTcI76FisRmOG6Jj71Z&#xd;&#xa;fhbxIdaa7jnaFZInJQJxlP7xzV7/AISTRftIg/tGHzM4wG4/PpVu51GztJIo7i5jjeXlAx+9WLrF&#xd;&#xa;1p+r20Dw60bVI59pZCcOf7ta97qthpiRC9u0i3j5dx5aq15qdnd6dfR2l1HLJHCSwRuV4qn4Ed5P&#xd;&#xa;DULyOzsXbljnvSeKPEh0W4tYYTCzyP8AvBJnKr61QutQjXxzbTm6C2pttxYthcY610mn6zp2psy2&#xd;&#xa;V3HMyckA81HJ4h0mO8Nq9/CJgcFc9Px6VJ/bOnfZGu/tcX2dW2GTPAPpUR8Q6QLpbf8AtCHzWxhd&#xd;&#xa;39a1B0rDWGH/AIS95hqrGXyQDZZ6DHX+tT/8JHo4u/sn9oQ+du27cnr6Z6VqDGKzZ/EGk2/m+dfw&#xd;&#xa;qYn2OM8hvTH4Vasr+0vrYXFpOksPTcp6fWqSeJdGe6FuuowGUnAGeCfr0qzqGq2OmIr310kIb7u7&#xd;&#xa;q30A5psesadJYG+W8hNsvWTdgA+h9/amWes6dqscq2V8jlVO7bwyj15rl9QRbTwFeG11V7798D5w&#xd;&#xa;bBUll+Uf571u6dr+lxWllaT38S3PkxgqW7lR1PSsrxNLIvjDSFSRgrI2QCQD1ro9Q1jTtMKi+u44&#xd;&#xa;S3RTnJ/AVYs7y2voBNaTJLGejKcim31/a6dD515OkMfTLdzXJ61qsF/rmiyWF2JIjIQ2xiB+IrrI&#xd;&#xa;r+0mupLWK4jeeL78YPK0xNUsZHnRbmMtAMygH7n1qD+3NLl8qJL6MvcAiPack1S0J7PTbC6mbWPt&#xd;&#xa;cIlJaRzxH7Vak8R6NHKkb6hCGcZUbsjmrV7qdlp8Amu7mOKNuhJ6/T1qO31vTLp4kgvYZHl+4obk&#xd;&#xa;1f6A9KzG8RaOt19lN/CJs4xnofr0q5ZXttfxGW0mSaMMVLKcgEdq5nx7K8TaRskZM3ODtOM9OtX5&#xd;&#xa;47ePxYty+rOsiQEmzycbcHJ/r+FadvqljdWj3cF1FJbx53yA8LgZOfwpn9s6d9h+2m8i+zZI8zPB&#xd;&#xa;NLp2safqm77DdRzFPvBSQR+B5q47qil3YKqjJY9AKzrTxDpN9c/Zra+iklPRRkZ+nrS3+vaXp0wh&#xd;&#xa;vL2KKQ/wkkn8cdPxqaTU7GKxW9kuoltmxiXd8pzUA8QaS12LUX8Jmbou7j8+lLBr2l3N2bWG+heY&#xd;&#xa;HBUHr7e9R23kW+p39w+oFxtBeFjxCB3ok8S6NCqM+owgPyuCTn8qtzajZ29oLua5jS3IyJCeDVaD&#xd;&#xa;xDpM4Qx38LeY21Rnkn0xUs+tabbSSxzXkSPCMupPK1atZ4rq3SeB98bjKtjGRU1FFFFU9W/5BV1/&#xd;&#xa;1yb+VeMV7F4f/wCRf07/AK9o/wD0EVo0UUVz/ijRrvVfsrWt61uIX3MB6f3vqKwnuo/Ewm0/Tmkt&#xd;&#xa;p423NKVx52OpbHQ967OwgktbKKCWZpXRQC7dTXL+PIJY5tP1FULx2z/vAOwz1rai8S6TJaC4+2xK&#xd;&#xa;uMkE8j8K5vxRcQXutaT9rdhpco3ZPCk+9LHZaUfFcVtpRQxTW7iZUOVFYxkuYrWXwwobzGu8D/cq&#xd;&#xa;94gtmtvEFhYlYTaxQgRrMcIT3zVjQrRotWvZYZrRYzAwkgt3JAOODR4J0WzvNPe8uVLSJK2wk8Jj&#xd;&#xa;uKptHHorGSaO01Kyknz5gb94pzXo8LB4UZRgMoIFcLoWmWuo+KdX+1RCURvkK3Sq/hXSLO6/txLi&#xd;&#xa;IOkEhSMN0X73I9+BVCOa5T4cHyWbYbwrIR2TH8s4qz4it9DtdItJdGkUXoddhjbLHjnNXNTsxqXj&#xd;&#xa;rT7a8yBJZqZVBxkgMSKi8VWiWWr6VYQxxpYKpZUkJCFyxJyfyqz4etGj8VebBNZRqIyJoLdyQRjr&#xd;&#xa;+eK6fxL/AMi3qP8A17v/ACrhZdLtF+HEd/5QNyWB8w9R85GPpipfEenW1n4Z0e8hj23LsheXPzMS&#xd;&#xa;uTk/UVc1BbWf4humrlfsywDyhIcKTgf/AF6bpFvp7+PLy3swr2jWrKVByv8ADkD2qjosPkeG/EFx&#xd;&#xa;aJi4RjGrL1CcZA/Cqdpaxz6ACTp6EnmZ3IkBzWrrdrJLc+HrW6lDuy7XdD1Geuas+L9MtdL02xht&#xd;&#xa;I/LRroEjPU1HqK2s/jeOPVyPswgBjDnCk4qLQhbrd+IhZkGARHYQc8Vv+Af+RXh/32/nWb4/toWu&#xd;&#xa;dMkaNS7zBGPqvpUWpafbz+O7S0eMeQIB8nbA7UQW0en+OrmCxQRIbZmCL0ziqfh2HR5tLv5NUMf2&#xd;&#xa;ze24yNhh6Yqsm3/hXlxtJI+1cH8au+ItKsrLwzYXNvEFnLITIPvHNd9aHNpCT3Rf5VyWAfibOCcD&#xd;&#xa;7Lyf+AisYJFoMavPFaalYtcZWVG/eBv8ivSkIZAQMAjNef6RBpM3ibWxqnlkiZvLWQ4XG45P1qnY&#xd;&#xa;STQ6P4mXTGf7KjqIiD0XcQcf8Bpbq28Pr4NSeF0GobFIIb5/MyMj+dX7qyubyHRr1p7dr6O1Gba5&#xd;&#xa;OA455+uDTE+ya54WngiEOmPFcguM/I788frVvQrtE1a5sbmxt4rwWxzLbnKsorGtP+SY33vdD/0J&#xd;&#xa;Kl1mDQ18HW81q0f23bGVYN85bjOf1qzqTStrvhpp8+abUF89c4Oar33mz+ML5blLZyoxGt0xC7fa&#xd;&#xa;tvwRbSQPelLiCS3ZuEiYkI3pVfxztbVtJjuyRZFj5npnNUtUh0qHxRpC6X5Y+cb1jOV9quabdQ2H&#xd;&#xa;jnVTdSLEJFG0twDVXSWWe48S3ER3RMp2sOhq14M0Wzk0WLUZEL3K7trE/d+lZlj/AMiVrX/Xc/zq&#xd;&#xa;XUdIs4vAUN4kI+07VYyd+tJqpjm1HQk1Jj9iMILZPBPvUxi0yLxzpy6WU2Y+cIcqDXa6iZF064MW&#xd;&#xa;fMEbbfriuB8KwaJNpN7JqjR/ag5LM5wyjA6fjmtz4b4/4R6XH/Py38lqP4gff0b/AK+v8KS4UN8T&#xd;&#xa;olYZBtCCP+AtXP3Us2hrrHh+MMTcyp9nx/dY8/pgVb8R2Laa+had8n2ZF+YSHCNJnndVnRLNl8WQ&#xd;&#xa;y281jEQn72C3ckMuDz/Kuv1qBLnSLqGScQK8ZBkzjbXG6TImlapptneWlrPuO23uoD83Pc1n2yPc&#xd;&#xa;6tqzXiWck4lKsLtyCoyfu1Jc28lv8Pp1a5jnhNypiKHIUdx+dS+JtJtLTTNDeCPZLKyq7g8tkDPN&#xd;&#xa;S+I7C203xRo4s4xDvxu298Hqa05P+Qh4j/64j+VZWm6RZS+A5ruSFWnCswc9Rj0qreuz+HtAW5Zv&#xd;&#xa;shbEnp171a1yDSIdY0kaWYwxkG4RnIx2J96nXTbfVPHeoQXQLRBclc4BrubaCO1t0ghXbHGMKPQV&#xd;&#xa;LRRRRVPVv+QVdf8AXJv5V4xXsXh//kX9O/69o/8A0EVo0UUUlQQ2dtBI8kMKI8hy5UYzU9MljSVC&#xd;&#xa;kihlIwQwyDWO3hLRGm802SZznHb8qv3WmWV5arbXFujwqMKpH3fpUWnaHp2lsWs7ZI2bgt1NSnS7&#xd;&#xa;Jr/7cbdDcgY8zHNJqOlWWpxhL2BZQOmeoplho1hp0Tx2lusauMNjqans9PtbGAw2sKxxkklR3qgP&#xd;&#xa;DGkC588Wab87vbPritgDAwOlVbfT7S1nmnghVJZvvsOrUlrptnZ+ebeBU89syY/iNNt9Ksraya0h&#xd;&#xa;t0W3cktHjg5qraeGdIs7gXEFmgkByCecVdfT7R9QS9aFTcoNqydwP8mk1DTbTU4RDeQLMg5GR0qL&#xd;&#xa;TdGsNKDGyt1jLcEjkmrk8MdxC8Myho3UqynoQaqnSbE6cLA26m1HSPt1z/OludLsru2itp7dXhhw&#xd;&#xa;Y1PRccCo9S0Ww1XYb23WRk+63els9F06xnE1raxxSBNm5euKltNNtLJJUtoEjWY7pAOjGqP/AAi2&#xd;&#xa;jfaBP9hj3g5x2/Kr0+m2dxNDLLAjSQf6s4+7S3tha34RbuFZQjbl3djUOo6NYans+2W6ybPuk9RS&#xd;&#xa;2+j6fbeb5FrGnnLtfA+8Kns7O3sYBBaxCKMHIUdKbeafa3xjN1CsnltuTPY0Np1o18t60Km4UbVk&#xd;&#xa;7gUn9nWovjeiFftONu/viqkvhvSZrs3T2cZlJyT2J+lS/wBiad9jaz+yp9nZt5TsT61Nc6bZ3dsl&#xd;&#xa;tPCrxJjap6DFWkUKgVRgAYAqsdOtPt5vvJX7SV2GTuR6VRTwxo6XInWzTcDuA7Z9cVr1x2l+G1ud&#xd;&#xa;Y1ltUs90E02+Jm78t0/MV09lptpYWptraBEiPVcdfrVFPC2jJc/aFso9+d2O2fpVnUdF0/Uihu7d&#xd;&#xa;XdBhWHBA9M03+wtN/s82P2SP7Pu3bMd/X60un6Jp+nFza26ozjazHkkelKmi6clg9ktsgt3bc0fY&#xd;&#xa;n1/Sq/8AwjGj/aVnFlHvXGPTj2q7cabaXNzFczQK80Iwjd1qDUtC07U3D3lssjrwG6GrNjYW2nwC&#xd;&#xa;G0hWKMdlHWk1DTrXUoPJvIVlTqAe1VLbw7pVq0bRWcatE25W75p+o6DpuqSCS7tlkcfxdDUtrpVl&#xd;&#xa;aWjWsFuiQsMMo7/WpbWyt7O2FvbxLHEM/KOnNQLo2npaS2q2yCGU5dB0Y1JJptnLYCyeBTbgYCHp&#xd;&#xa;WP4k0+aS0ghtNPhu4I+DE3DAexrM0nRbmTXra8/s1dPtrZcBM5LGu1PIwRWS3hjR3uvtJso/Mzn2&#xd;&#xa;J+lX7GxttPgMNpEsUZYsVHqabe6fa35i+1QrIYm3pnsaDp9qdQF95K/aQu0SdwKbPpVlc3sd3Nbo&#xd;&#xa;88QGxyORTr/T7XUYfJvIVlTqA3b6VBpuiafpZZrO3WNmGC3U1cnhjuIXhmRXjcYZSOCKz7Lw7pdh&#xd;&#xa;cCe3tVWVfunrt+lF/wCHdL1Gfz7q0R5O7dCfrU8mk2EtiLJ7ZDbAgiPGBTrnS7O7jhSeBXWAgxg/&#xd;&#xa;w49KLrTLO8uIp7iBXlh+4x6inHT7UvO5hXdOMSH+9TY9Ns4rA2SQKLcjBjHSmSaPYSaeLFrZDbDo&#xd;&#xa;npUFv4a0i32eVZoDG25T3Bq5Hp1pHeveJCouHGGfuatClooooqnq3/IKuv8Ark38q8Yr2Lw//wAi&#xd;&#xa;/p3/AF7R/wDoIrRoooopKWkoooooooopaSiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiilooooqnq3/ACCrr/rk38q8Yr2Lw/8A8i/p3/XtH/6CK0aKKKKh&#xd;&#xa;juIZXdIpUZk4YA5K1LWVrmu2uiJE90JCJWIXYM1X0zxVp2o3S20Zkimb7qyLjNbtLRRRRRRRRRWP&#xd;&#xa;Priw+JINHMJLSxmQSZ4HBP8A7LRpWtrqWpahZrCyGzfYWJ+9yR/StelrH1DXFsdbsdNMJZrrOHB+&#xd;&#xa;7WvTXdY0Z3O1VBJJ7AVQvNYtLXSJdSEglgjGcoepzjH51HoOqzatameWze2Q4Me453gjrWrS0UUU&#xd;&#xa;UUUVT1O8+wWMt15by+WM7F6ml027+32MNyI2j8xc7G6irVLRTJXEcbOx4UFj9Ky9D8QWeu+d9k3A&#xd;&#xa;w43Bhjrn/CmjxHZHXjo4LG4zjOPlzjOM1sClooooooooqOV/Ljd8Z2qTWJJ4lWPS7W+FpK4uH2bV&#xd;&#xa;5289a3UbcgbBGRnmnVDdTra20k752xqWOK5pfHmmP92K5IPcR1o/2+n9uw6YIWzNEJA+egxmtkdK&#xd;&#xa;WmSNsRmxnAziszQdaXWoJZViMflyFCCc5rVFLRRRRRRRRRRRRRRRRRRRRRRWbr91Da6VOZnC70Kq&#xd;&#xa;PUmvJ/sq/wB5q9Z8P/8AIv6d/wBe0f8A6CK0aKKK5/xPrs2ji2WK0efz32sR2HoPesJrVfCgm1O3&#xd;&#xa;Mt3JMQPKJ/1YPPz+9dnY3LXdnFO0TRF1BKN1Fcl8RyQmmlRuImyB61V00zeJvEUFwYY7QWHDqD8z&#xd;&#xa;VveG9Xu9RvtSiuGUpbybUAGOKxW8UamNH1G6Dp5lvciJPl/hJqTUNW8Q6dFZ6hcSQeRMygwqvTNT&#xd;&#xa;a1rt8msJaJdJYQGMMsrpkOSOldLpMk8mnxNdSxSykcvF901j+ItZvYtSt9K0sJ9qmGS79FFVtP1f&#xd;&#xa;VtP1uHS9YMcv2gfu5EFQWWq6/q11qFvaTQRrbyEb2XkD0rT8IavdapZzreEGa3k2EgYzU3i3WZNF&#xd;&#xa;0oTQKDNK4jTPQHBOf0rC1bUfEuiabFPczQSiVwCwXlCQeKsXnPxN04/9Op/k9HhD/kZvEf8A12H/&#xd;&#xa;AKE1bPirULjTNBnu7UgSoVwSM9WANc/fan4ks9Mh1mSSA25VC0IXoD3P5inarcLd+LvDdygws0Qc&#xd;&#xa;D0zzUn9q61rGu3ltpcsUFvZMUJdc7iDj+hqGHVdY1Oy8QW0zRRy2ihcbeAPm3D8hWNGl+fh07CWP&#xd;&#xa;7J533CPmxu/+Kwa2hrGoaN4W06MmOW7u9qWuBwqbRjPvzinS6rrug3Vq2sPDPbXL7DsGChqfV9Z1&#xd;&#xa;ZPEx0zTwjb4gVDDGD65qC+1XXtPvdNsC8T3Nwp35HBOeKZDqniFddm0dpoJJmXcspXAQeuKl0vXt&#xd;&#xa;UVdXtrvbPcWSEqyjqat+GtQvb2cM+p293EUyyBdrofpW3rFxJZ6Vc3ERxJGhZc881jQ6zdv4KbVC&#xd;&#xa;y/aRGWzjjOfSs++8Raimj6XKJFiN0MzXGzIT8KunUr+Dw1e3bXttdtGMxSRjqPcVV1HxDqNvoGkX&#xd;&#xa;UBjM1ywDjbwf8KS51TXdK1ay+3TQyQ3bbfLRfu1Jc6trGp+IbjT9JkjhjtR87Oucmn6BrWqXXia5&#xd;&#xa;07UPLAhiJIUdwQP61t+Ip/svh+/lzgiBgD7kYH864nw+48P3OmXkpK29/aN5h7bgSR+mKrWkckF9&#xd;&#xa;o2tz5D317IzZ7AkAf1rornVNY1TxHc6dpUsVvFZ/fdxncf8A9dGm+ItQS+1dNUEe2wh37UHcf40m&#xd;&#xa;jXPiTVfI1JZYI7OSQfuSOSgOD/WoTrGv3+s6np2nGL9zJhXYY2KCf1qW51bWb7Vm0nS3jSS1jU3E&#xd;&#xa;zjq2BnH4mpNK17UFn1HTdSCfbbWFpUdejADP9RWWmueIrrw4+rJNBHFASGG35n5Az+tS3+u6/DpN&#xd;&#xa;tre+CO2kKjyQMk9eT9cVc8Q+Jp4Ly1sLOWK2eWISvNKMhQR0qPRPEtyNUaxvLmG9Qxl1miGBwM4q&#xd;&#xa;Oy1HxBrUVzfWskKWiFlETD7w+tN/tS50vwnpT2+0NLLtYMM96u6rq+p3OuxaTpTpE4jDySMM44p2&#xd;&#xa;marq3/CUf2VqLRFVi3ZQfe963db/AOQNeZ/55N/KuD8LXOsxaSiWWlQ3MG8/vG61rSk/8LBtGkXa&#xd;&#xa;32bLD0OKLLVNe1q8uptPkhitbdyqo653n0plt4l1V9B1C6ZFe4gmEahV4Udz71d0C/vL3zGk1K3u&#xd;&#xa;4jESyhdrqcdMVh+HP7ZbTb7+zJIoY4pWZmcZLH0FdN4N1mfWdNkkugvmxSbCV78CugFLRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRVa+vIbG2aedgqKPzrzbWdWm1a7MshIiHCJ6Cs/P1r1Hw/wD8i/p3/XtH/wCgitGi&#xd;&#xa;iio3jWRcMAecjjofWue0Tww2l6jc3Et49wkpOEbnPPU+9dIBXP8AinRJ9Z+x+Q6L5Eu9t1QzeH7q&#xd;&#xa;DxFHqmnSRoGAE6N/F61Um0HWrDU7q50aeHy7o5dZOopv/CI3I8OzWXnIbqeZZXY9OK09f0O41PSb&#xd;&#xa;S0hdA8LKWLdOBUOsabq9yfLhWzntjGE2SjBQ465rQ8N6XJo+kpayyeY4JY46DPYVT8Q6Fc3l5BqO&#xd;&#xa;mzLFeQjA3dGFV9N0HUptYj1PW543khGI0j6Crfh/RJ9MutQlmdCLl9y7e1O8MaNPo4vBO6N58pcb&#xd;&#xa;ewqTxPox1vSzbq+yVGEkbH1H/wCusG/8P+ItXsY7e/uoAsTAqo/ixxkn1rYm0WeTxfa6sHTyYYfL&#xd;&#xa;KnrnDD+tGhaLPpur6rdzOjJeSbkC9RyTz+dM8ef8inddvmT/ANDFYo0bXtW0ays3u4f7PeON92MN&#xd;&#xa;twCAfXFbN34elbWtHubdlEFggQg9SBVSXQdX0/W7q80aeERXbbpFl/hPr+ZNS6P4cvbJdZ+03CSy&#xd;&#xa;X6kBx6/NyfzpqeGrpfBbaN5kfnFs7u3391T6n4bkvtCsLVZhHd2Sr5bjpuAA/pVH+wNa1a7tjrlz&#xd;&#xa;Ebe3fcEj/iNajaLOfFy6sHXyBFs2984o1PRZ7zxHYagjoIrYfMD1NIuizjxc2rb18kxbNveorTQ7&#xd;&#xa;201TVb2KSINdD91kZwfeq+leH75deXUrtbe32LjZB0c+prpb22W8sprdzgSKVzXF/wDCOeIUsW0l&#xd;&#xa;LqD7AT94/exW1daVqFtp1paaabeSKFdrxzLw/wCNZ9l4Vu4tI1KF5IklvOkafcSpbzwzdT6RpNos&#xd;&#xa;ke+zYFz6/Sruv6LPqd3p8sLoFtpNzbu9Y1/BJZ+KZ5tK1G3inmGZYZuPxqDwiJH8aag8k4uG8pt0&#xd;&#xa;q9Cciuq8S6fPqmjTWds6q8pXlumAQT/Ks7WPDL3/AIas9OiZVntggDHpwuGpdf8ADkt7pOn2li6R&#xd;&#xa;vZupUt6BcfzxVe90LVrTXptT0aWIfaQPNSTpn/PNO0vwxdR3WpyalcJOL+LYzKMc1HpWj+IdLkis&#xd;&#xa;4bqE6ekmckfNtzkitHRtFnsNe1S+kdDHdtlAOo5J5qnqeg6jBrUmqaHPGksy4ljk6H3/AEpdJ8OX&#xd;&#xa;cTX97qE6y395EY8jooI//VS2nh26g8GzaQ0kZnkyQ3bkg/0pdQ8O3N14RttISRBNFsyx6cZqPWvD&#xd;&#xa;d1NdWmoae8QuoYhEyyDKsAMf1qfR9J1JZ5ZtTa2CuhURwxgY981n2nh/XtNM9nYXUK2UzE7mGWUG&#xd;&#xa;p7rwxdzaDp9iJUMltLvZj0PNSavoGof2vFqmkSxrcBAjq/Q4pdK0LU4vEX9q6jcRSs0ZUhBjHsK3&#xd;&#xa;9Rt2u9PuIEIDSIVBPSs/wtpM2j6QtpcMrOGJyvTmobjRJpfFkeqb08lY9hXuazItA1vS725GlXMK&#xd;&#xa;2tw247xyuasaVoOqaZpd7FFcQtczS7wzDII9DUemeHr4aydQu1t7c+WV8uDoxI6mr3h7RJ9K068t&#xd;&#xa;5nRmndmXHbIpfCOiT6JZ3EVw6M0su8bfTArfFLRRRRRRRRRRRRRRRRRRRUF3dRWcDTTuERRkk15v&#xd;&#xa;r2ty6tddSsCn5E9fc1lZo3V6n4f/AORf07/r2j/9BFaNFFFJRRRRRRRRRRRRRRRRRVe+sre/tXtr&#xd;&#xa;pBJE+MqalhiSCFIo1CpGoVQOwAwKfRRRRRRRRRRRRRRRRVC/0XT9RcPd2scjjoxHNSWOm2mnLss7&#xd;&#xa;dIQeu0dat0UUUUUUUUUUUUUUUUUUUUUUUUUtFFFFFFFFFFFFFFFFFFV7u6htITLPIEUDPJ61514h&#xd;&#xa;1yXVp8LlLdT8q+vuaxxxRSV6r4f/AORf07/r2j/9BFaNFFFFFFRSTxQgebKiZ6bmxmkjuIZTiOaN&#xd;&#xa;z6KwNS0tFFFFFVmvrVbtbRplE7DIjJ5IqxS0UUUlFFLRRRRRRTGYIGZjgAZJquuo2b2rXS3CGBfv&#xd;&#xa;ODwKso6uiupyrDII706qyXttJdvarMpnQZaMHkCpywUZPAqvaX1teqzW0yyhDtJXsasjpS0lFFLR&#xd;&#xa;RRRRRRTHdY1LSMFUckk4ApI5FkQNG4ZT0YHIpsc8UrMscqOV+8FYHFMjvLeW5e3jmRpU+8gPIqwK&#xd;&#xa;Wq93eW9kivczLErHaC3c+lOW4hZ/LWVC+M7d3NLJNHEMyyKgPdjio/t1t9qFt56ecw3BM8kVYFLR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRVLVNSt9MtjNO2P7q92Neb6vq1xqtyZZjhR9xB0UVnHmjNJmjNereH/&#xd;&#xa;APkX9O/69o//AEEVo0UUVn6nq9npgjF3OsTTNtTP8/pXPafqeq6bd3Nzr80aWbHCEcgnPG32rrIJ&#xd;&#xa;o7iFZYnDxuMhgeCK474jqHTTUJOGmwcelM1nwvDpWlvqOlzzQzQKHxvyDWvZeJIk8NQalek7mG0h&#xd;&#xa;erN7U7S/Ey318tpNZz2ryAmMyjhhUE/jG3juLm2itLiaaAkFUGc+9RDxvbSWXnwWdxKV/wBYqj7n&#xd;&#xa;1Nai+ILI6INVZisBHQ9c+lZtt42tpJ41ns7i3ikOElccGupUhlBByCMg1x97/wAlHtP+uNaGpeKY&#xd;&#xa;rS9e0tbWa8mT74iHC1a0rX7TU7Oa4UtD9nz5yScFPr+RrPsvGEV9exRW9jcNBJIIxPj5ck4zWfYa&#xd;&#xa;9cy+O7i3Zbj7Ow8tYSOEPHzEenX866LStbh1S8vbeKN1azfY5buckcflUNl4jt7231GZIpAtiSHB&#xd;&#xa;/ixnp+VVbDxfb6hdWsFtbTMZzhmxxH16mm3XjCCO4mjtbOe6jgOJJYx8ox1q3ceJ7GHRY9UUs8Up&#xd;&#xa;2Iq/eLelS6TrMl/M8M9hPaOi7v3g4I+tacsiwxPLI2EQFifQCuYj8bW8gklFlcm0TP7/AB8pIqxJ&#xd;&#xa;4ttYtOsb54JRBdsVDf3SDjn9fyq5qevQadd2tq0bzS3JwoTt71Tv/FkNtqTWNvaz3Ukf+sMXRal0&#xd;&#xa;/wAQWmspeRxxSBIEO8MMbhisjzbCbwPftpsDQw5IKscnOa1bvXrfRdKsvNRpJZY1CRp1PFRQeL4J&#xd;&#xa;Lu2tJrS4gnnbG1xjFY8morpvjm/lMMkztGFVIxkk1v6T4it9YW4gEUkFxEp3RP1xWV4GnjttK1Ga&#xd;&#xa;ZgsaTsSfQVYHjaDcJGsblbQnAuCPlrqIpFliWSM5VhkH2rG1zxHBpE8duIZLi4k5EcfWoLTxbbXO&#xd;&#xa;p29gbeeKebgq4xtOM81l6br1zN46uLdluPs7rsWFuiH5fmPt1/Ouwu5/s1rLPtL+WpbavU4rGHiu&#xd;&#xa;zOgDVtkhj8zy9n8W7PSi48VWcGiW2p7HZLhtixj72ef8Kns/EENzqlzp7xPDPbpvbf3HH+NQaT4q&#xd;&#xa;stUju3jR4xapvbf3XnkflUEfjG1eKzma2mjiu5TGjnGAQQCf1q3ceJbS216PSXV/NcqN/YE9BU1t&#xd;&#xa;rkN1rtxpcUbl7dcvJ/COnH61Q8fTmLwxMoODLIiD88/0rM8O6i2i6Nq1ncnEmn5dM+jDj9f51T8D&#xd;&#xa;LNZeIZILliWurQTYPuQR+hrodNn00+JdQjt7Zku0GZZCeG+lQf8ACaW7pL9msriZ4mIZVHQDvmr8&#xd;&#xa;niS0j0KPVZAwjkHCfxZ9K5bxLrw1XT7ZGtJrZ/PVlEg4YeoNWvEKHSvEGl6smRHJtjk9Kf4pY6v4&#xd;&#xa;j03SYmyi/vJMen/6q1GfTI/F0UH2d/twh+WTPyhcUuoeKoba9ktba0mu5Iv9Z5Q4WlfxXZjR/wC0&#xd;&#xa;kjkeNX2Og+8h96fqfimy01bRpEdxdLuXb2HvU1xr8EOq2unrG8ktwoYFeij3q5qV6unWE13KpZIl&#xd;&#xa;yQvWufl8bW4tVuYbK5lh/wCWj4wE9s1q3PiCyttFj1N2JilAKAfeYntVOx8WRXF9Fa3VnPZvMcRG&#xd;&#xa;UcNWV/b1z/wnv2fbcfZv9V5WOM9N/wBO9duKWiiiiiiiiiiiikNZusaxb6VBulbMh+6g6mvO9T1G&#xd;&#xa;41K5M1w5P91ey1QNJmiijFereH/+Rf07/r2j/wDQRWjRRRWXq+iWeriI3cW9oW3L2z7H2Nc9Y2Op&#xd;&#xa;a1PcWeu2irZxn92RxsI6BfUYrr7a3itYEggUJGgwoHauT+IMM0sentBC8xjl3EIM1W1DV9U12zOn&#xd;&#xa;WelTw+aAryScACn+IPD08HhmxgtlaVrRt0ip1b1xUegLb32s2zJDqOYVLF52O1D6Vb8OWsseu65J&#xd;&#xa;JCyq5O1mHX6VD4btJovDurpJA6u7vtBXBI9qqLpN5c+A4Io4W86GUyGNhgsM03U9Sn8Q6fb6VbaZ&#xd;&#xa;NHMGXezLgJiu9tIjBaRRMclECk/QVzN5bzH4gWswiYxCLBcDgH61hXdrJpWu3rXkV75Uzbkktief&#xd;&#xa;rWnpGkC80TVXt7e5gkvFKjz2zv7g0eGdaksba00a40ydZ0fYWC/KAT941asreZfiPfzmJhE1uAHI&#xd;&#xa;4Jwnes62vZ/DGv6s1zZTTRXUnmRvGuQeSf61N4esbtfDet3E8LI14HdIyOT8p/xrV8E2rQeF4Eki&#xd;&#xa;MUhL7srg/ePP5Vx9tbPo7XVlfw3/AJhc7Ps5O2QVvtp9nZ+EI4rjTrp4pJPMMQO54ie9HhGa8Orz&#xd;&#xa;wwyXM2lqnyvcLghuOB+tdNq9s95pN3bRnDywsqn3IriNO1Se28Mz6IdLna6CSJ9z5ec8n8/0FaNp&#xd;&#xa;o0l/8O47OSMrcIrSIGGCGDEj8x/Oq3hGzvb/AFdb7UonT7LEEjDjGT60QXE3hrxJftcWU00d0cxv&#xd;&#xa;Gual8NR3L3euTzWskHnKSqMMdulRaXaXKeAr6BoHErO21CvJ5qXxHb3Nu+jamlu8yWqKJIwMkfhU&#xd;&#xa;V3eza14i0m5isJ4oI35d060+e5n0vxneXzWU08GwAsi5x9Kf4fS41LxDf6t9meCB4yqhhgtUOjaX&#xd;&#xa;dT+F9XtRG8cskpKhhjdWVbxo9nFp89nqbzghWiDEJ9a9KsIFtbGGBQwVEAAY5IrkvEQn0vxZb6ub&#xd;&#xa;aS4tzHsOwZKmqsc9zqnjbT74WE0FuCcM69flPJrSsLedfiLqM7ROImtwocjgnCV1RAK4I4PBFedW&#xd;&#xa;ej3cfiIaQ0L/ANnx3n2kMR8pAXgflgUtnpF3J4kh0yaFxYWdzJMrEfKQcED+X5mrvjWzvLbV4tS0&#xd;&#xa;+F3a4geCUIMnpjP5EflVHXdIvNJhtUsYXf7TZC2m2D+IEEk/nW1r2gY8FxWkKkzWarIuOpb+L+Zr&#xd;&#xa;HTTb280K91iaFxf/AGpJUQg7sJgf1P5Vf8P/AGrS9E1LW7i0kkvLmUt5ePmxn/EmneLGuNX07RlS&#xd;&#xa;2lXz5RJImPudBz+ZqLxbolxdeIbU2yt5N8FiuCo4AVgcn8MflVrUreW08d6dcwQOYDb+WxUcDAYA&#xd;&#xa;fypdIt5k8Z6vK0TiN0+ViODTfBtrLDZasJoWRnlbG5cFhg1QvdMu5fBlr5cLGS3mLtGRyRn0qPW9&#xd;&#xa;Um1yws4bfTLhfKkUuxTpjsK6fxLpx1Lw7JCoJlRQ6DvkVkeCbK6mvbnVL+Jkl2iJA4wcAVPPbzf8&#xd;&#xa;LDhnEbmIQYL44zj1rAntX0nWb4Xsd9smctG9sThs9jW7o+iRT+Gr2MW00BugTtmbJyOhrF0bSbzU&#xd;&#xa;4bpL6Fl+zWxhh3A8n2q54Ut7yS+udUvreQPbQiONWGC2B2rUvb6fWvB99J9jkhlZSojI5PNRR2sg&#xd;&#xa;+HckHksJTbn5NvOay9R0q7uPBOkmOKQvaktJEBhsZNJp8FtqurWirbanJ5TbzJM+BGQR/hWt9nm/&#xd;&#xa;4WQJ/Lfyfs2N+OM49a6wUtFFFFFFFFFFFJWFr3iODTEMUJElyf4ey/WvP7q8mvJmmncu7HvUBOab&#xd;&#xa;SYopwFLivVPD/wDyL+nf9e0f/oIrRooopKKKKKKAAOgAooooAAOQBRRQQD1ANGKMDOcDPrRQVB6g&#xd;&#xa;H60UUEA9QDRQAAMAAUUYGc4GfWiiggHqAaKKMUAADgUYoAA6ACijAznAz60tIQCMEA0UUUUUUUUU&#xd;&#xa;YzRRRRRRQAB0AFFFFBAPUA0UUUYoooAA6ACiilooooooooooprsqKWYgKBySa5DX/Fm3dbac3zdG&#xd;&#xa;l/wrjJJGkcu5LMepPU0yilxSYpwWpEQk0/yTXpvh/wD5F/Tv+vaP/wBBFaNFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFIap6hqdrp0Re5&#xd;&#xa;lC+i9zXB654juNSYxqTHb54UHk/WsImkpcZoxS4pQuakVOasKoFO4r0Xw/8A8i/p3/XtH/6CK0aK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKQnA5qu99&#xd;&#xa;axtte4iDehYU5by2b7txEf8AgQp4miPSRD9GFKHU/wAQ/OlyPUUZHrSFgOrAfjTWnhX70qD6sKry&#xd;&#xa;6rYQ8yXkK/8AAxVCbxXpEeQtz5p/2Bmsm/8AGmVKWUOD2d/8K5O7vJ7uYy3Ehdz3JqsTnrRSgU/F&#xd;&#xa;JT1XNSKlSBMU8CjFei+H/wDkX9O/69o//QRWjRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRSE4qMzRL1lQfVhTGvbVPvXEQ/4GKhbVtPTreQj/AIFUTa/padbyM/Q1&#xd;&#xa;E3ifSl/5eM/QVC3izSx0kkP/AACqtx4ytlH7iB3PvwKy7rxdqEmREscQPoMmsm41W+uSfNuZGz2z&#xd;&#xa;iqLsSfmOT70zeR0J/OnCeQdJHH/AjT1u5x0nk/76NPF9cjpcSf8AfZo+3XP/AD8S/wDfZpDd3B6z&#xd;&#xa;yH/gRqNpXb7zsfqaZlT1ANOBGMDijGaYy4qM0oFPAp2KAM09VqVRUiin+1GK7XQtVsItCsEkvIVZ&#xd;&#xa;bdAVLjIO0Vf/ALZ03/n+g/77FH9s6b/z/Qf99ij+2dN/5/oP++xR/bOm/wDP9B/32KP7Z03/AJ/o&#xd;&#xa;P++xR/bOm/8AP9B/32KP7Z03/n+g/wC+xR/bOm/8/wBB/wB9ij+2dN/5/oP++xR/bOm/8/0H/fYo&#xd;&#xa;/tnTf+f6D/vsUf2zpv8Az/Qf99ij+2dN/wCf6D/vsUf2zpv/AD/Qf99ij+2dN/5/oP8AvsUf2zpv&#xd;&#xa;/P8AQf8AfYo/tnTf+f6D/vsUf2zpv/P9B/32KP7Z03/n+g/77FH9s6b/AM/0H/fYo/tnTf8An+g/&#xd;&#xa;77FH9s6b/wA/0H/fYo/tnTf+f6D/AL7FH9s6b/z/AEH/AH2KP7Z03/n+g/77FH9s6b/z/Qf99ij+&#xd;&#xa;2dN/5/oP++xR/bOm/wDP9B/32KP7Z03/AJ/oP++xR/bOm/8AP9B/32KP7Z03/n+g/wC+xR/bOm/8&#xd;&#xa;/wBB/wB9ij+2dN/5/oP++xR/bOm/8/0H/fYo/tnTf+f6D/vsUf2zpv8Az/Qf99ij+2dN/wCf6D/v&#xd;&#xa;sUf2zpv/AD/Qf99ij+2dN/5/oP8AvsUf2zpv/P8AQf8AfYo/tnTf+f6D/vsUf2zpv/P9B/32KP7Z&#xd;&#xa;03/n+g/77FH9s6b/AM/0H/fYo/tnTf8An+g/77FH9s6b/wA/0H/fYo/tnTf+f6D/AL7FH9s6b/z/&#xd;&#xa;AEH/AH2KP7Z03/n+g/77FH9s6b/z/Qf99ij+2dN/5/oP++xR/bOm/wDP9B/32KP7Z03/AJ/oP++x&#xd;&#xa;R/bOm/8AP9B/32KUaxpxOFvYSfQPVGbxPaRSMpSQgHGQKavi3Sz995E+q1Zi8RaVJ927QfXip11f&#xd;&#xa;T2GRdxY/3qRtY09VLG8hx7NWLqPjGCMFbJPNb++3ArmL3XL+8Y+ZcMAf4VOBWe08jH5nc/iajLE9&#xd;&#xa;zRmlDU4E04ZNPGaUqTSbD6UxkxyRUZWmlTRtNBBBFHejNFBoFPHHNO4NRMmDQoqQLTglPCU9VqQA&#xd;&#xa;AUdaWlrk6SiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiitzwlAs+rHeMhI&#xd;&#xa;2YfoP611VzahgeOaxri0YE4FVWhdeopCjAdKiII7ClwTQVNJtpyp6iniPJwBUq2hYVOLM4HFPWzx&#xd;&#xa;1FPFp3xTjbe1N8jb2pjwbh0qF7eozAcHilWD5cnoBUAQkk9qQxE00xECl8s4o8sntS+XjtSlMLSh&#xd;&#xa;acUzmo9uDTwuakKHsOakVcjPelCnPSnbPalK+goCEml8uuPooq7pOnTarqEVpAPmc8nso7mum8R+&#xd;&#xa;ELLSdFe9t7mSVlcLg4x1wau6d4J0i+to3jv3aQxqzqpB25FUtd8LaVp1sDb3zST+aqGMkZGTg8VW&#xd;&#xa;8WeGbbQ7S2mt5ZHMrYO76U7QPC9rqmgzX8s0iyR7sKBwcCuUPWuy8OeErHVNFF9dXMkR3MDjGABT&#xd;&#xa;NQ8OaNC9qlnqJnaWYIwBBwDWrceBdGt2VJtReJ2+6GIGa53xJ4Un0RFnSQT2zHG8DkfWrcvha1Tw&#xd;&#xa;kur+dJ5pjDbeMda0tO8E6RfW8bpfu8hQM6qQcZqhrfhfTLA28dvetLLJMI3TIyoNVvF/hu30L7N9&#xd;&#xa;mkkkMxOd1X9J8DxtZC81e5+zoRu2jjA9zUt14IsbyzabQ73zWX+EnIPtmsXwp4fj1jU7m0u2khMK&#xd;&#xa;EkDqCGAxUfinw6+g3ahC0ltIP3bkd+4PvV3UvDFtaeE4NWSWQzSJGxQ9BurlaSiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiitHQtQ/s3UUnPKEFWHsa9FUpcRLJGQysMgiqk1pk9KqSWqnt0qB7QEcCq7WRB&#xd;&#xa;6Uw2h/ummi1bP3TU6WG7tUiaa3PpUy6eB2p/2Rk7VLFHxgjFSmIU5YR6U4wgDpUTW2ecVEYtoPFQ&#xd;&#xa;NBz0pDbHPTtUU0ZI2KKiFvgYx0oNvgdKZ9nyelDW+O1J5OOcU0xbj0ppiwcY6U5Yu+OtNZcE0xo8&#xd;&#xa;inKmcVOEwM0hUqcjpUsfzfSn7AKNuakWIZ6UvlD0rg6KK9F8H6TLb+Gpb+y2G/uwVjL9EXOP8TV/&#xd;&#xa;UdEu38DLp7OpuI/ndieDhix5rD+F/wDyEb7/AK4r/OsLXP8Akbrj/r6P/oZr0LxRNo8VnbHWYmkj&#xd;&#xa;z8m0Z5xRpcumS+GrptIjaO32vwwxzivI69P8HGAeCmN0CYMvvx6VhTP4efUtOGjRssv2gbiQRxVn&#xd;&#xa;4mhjeWIUEnYen1rSu/MT4c4vs+Z5IADdc54plz/yTNf+uI/nWb8MP+P29/65j+dYd5/yOj/9fQ/n&#xd;&#xa;XX+OjGNT0fzcbPN5z9ag+JIuDa2pi3G2Gd+3p7ZrO+Gguf7WuGTd9m8o7z23ZGPx61taD5R+IGtG&#xd;&#xa;LG3y+ceuVz+tSi4tfEEuqaDekCaKV/JY9cZ4I9x/KoPFNu9p8PoraQYkhESN9QcV5pSUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUVu6D4gk04iGbL25/NfpXaW97b3kQeKQMp96c0KsTimGAKeaQpF3IoH&#xd;&#xa;kDgkflSg2o6t+lSB7THXn6U6OS2GeRUgED9HWholHQg0hgGOmKjMPGTTlAAxQB6inBM1G0QJpDBx&#xd;&#xa;SPGqr0yaq/Zzzkdaa1vjnFAgB7U0wAdqaYfamGDI6VH5OO3SmmHdk460hi+XpURi+Wk8rNNVMGnY&#xd;&#xa;JNOABGKPLZR8oqWNj0arCRBuhFSGLbSba86oorf8MWF5rVy9nBfSW6xxlxhjjr/9euv8UQz6V4FS&#xd;&#xa;2a4aSVGVTICcnJzXIeE9fj0C4uJZIGl81AoCnHeulfwdJq16urpdoiXDCcIVOQCd2P1rP+IOrJcT&#xd;&#xa;R6aI2D2zct2PFR+FNfWHT/7GFu7yXLMocHgbquf8K2m/6CCf98GrA1ZPBkC6RdW7XQOX3jgMD25q&#xd;&#xa;k3iCx1jUNPt7WwFs4nVi2ByPwr0G5iRlMhgSWRASgIGc+gryrxR4jvdUlNpNH9niibmLvn3rb0TU&#xd;&#xa;k8QaIPDsaGKRYf8AWk5HHtVmz04+BbW4v55RdLJtTagwevvWNoWlHxJrdxqMUohWOYSbGGSea6/x&#xd;&#xa;V4ck18W/l3Cw+Vk5IqSzttTs7IWl5HHqESjG4YBx7g9a57WPF/8AZiSWOn6abSbHzF127ffHesDw&#xd;&#xa;rrp0jVJriSGS6kuF2AKeSxYGuptPCd1das2sy3D2c0kvmrEACyg9jW34r0yfVdCltbfBlJVgPXBr&#xd;&#xa;x2WN4ZXikXa6MVYehHWmUUVq6LoN9rU221hbyh9+Uj5V/Guuj+G0fl/vb9t/+ynFY+t+Br7T4jNa&#xd;&#xa;k3cYGSFHzKPp3/CuVIIODxW94a8NPr6zFLhYvKI6rnNWNf8ABtzo1l9qEouEBw+1fu+9czXU6D4L&#xd;&#xa;k1nTUvEu0jDEjaVJ6Vg6tYnTNSns2cOYW27gOtU6K3/DXhp/ECzFLhYfKI6jOaXxL4YfQIoXe5Wb&#xd;&#xa;zSRwMYrArstP+H9xe2MNybtYzKobYVORVHxF4Rl0KzS4a4WZS207VxisnRrBdT1KGzMwhMpwGYd8&#xd;&#xa;V0158Pri2s5p1u0laNC2xVOTgdK4utjw3oEuv3MsUcgiWJNzORkdelaWu+DDoumveS30bgEKqBTl&#xd;&#xa;iTWDpNg+p6nBZIdrStjOOg7muu/4VtPjP2+P/vk1yuu6TJoupyWUjbyoVg4GAQRWdRRRRTlVnOFU&#xd;&#xa;k+1bmj6bfJIJVkaEDr710/msoAUln74pViu5jnaQPUmnGBl+8cmmFdtNAx1GaspayyLujXd9KY8M&#xd;&#xa;icOhX6ioXQ4yob6ioxPKp+V8+xqxHqDjh8j3NWEvDIMKQanSVSB61ICDTqXAprHFNAB5NBUYpDGD&#xd;&#xa;SCPHamvH7VF5dIU9KheLPamCPHFBjytRGHpTGQBuah2DJ4pCMCkxg+1OWdVO1unrUnlq4yrZp6/u&#xd;&#xa;xT0uQx2tT9y/3q86oorsvhl/yHLn/r3P/oS10vxF/wCRYb/rsn9a8pr3DRB/xJbH/r3j/wDQRXlv&#xd;&#xa;jf8A5Gi7+o/lWj8OdP8AtOrPduuVt14J/vGu7vNWS11uysCR/pAbPt6Vz/xJ07ztOhvUGWhba3+6&#xd;&#xa;a4fw5/yMFj/11Fe1MQoJY4A71xHj7w550Z1W0TMi/wCuUD7w9axfhx/yMR/65NXV/EP/AJFp/wDr&#xd;&#xa;otZHwv6X3/Aa6HxV4hbw/BBItus3mMVwX24qponjiy1SdLaaJradyAoLBlJ+tXfFOhRa1prgIPtU&#xd;&#xa;SFoX759Poa4b4e2iXHiTdKoJt4mdQezZA/rXd+K9SvdK0g3FhB5sm8BiVyEXB+bH5Vx1r8Q75baa&#xd;&#xa;O7hjdyhEckfykN2yOmK41mLMWJySck+tNorR0HTG1fV4LNSQrnLsB91RyTXsUcdno+mbVCwW1umT&#xd;&#xa;7ADr9a4m7+JEouCLOxQwA9ZGO5h+HSun8OeI7fX7dmRTFNH/AKyInOPceorlfiHoMduV1S1jCK77&#xd;&#xa;ZlUYG49G/HnNT/C/7l99VruZ4o7iN4JQrq4wynuK8h8UaE+h6iyAE28nMTn09K77wB/yLEX++386&#xd;&#xa;8+8Xf8jPff8AXSsaivQvhf8A6q++q0/4of8AHpZf75/lXE6JYtqOr21soyHcbvp3r13Wb5NG0hpw&#xd;&#xa;BiPaqg/lTNctV1fw9NGuD5ke9PrjIrxuKSS2uUkXKyROGHqCDXtukXyappdveJgiVMkeh7j8815D&#xd;&#xa;4k046Xrl1ahdqK+6P/dPIr0D4ead9j0H7Sy4kun3c/3RwP6n8awPiRqn2jUItOjb5Ldd7j/bP+A/&#xd;&#xa;nT/hnp/mXtzqDrxCvloSO56/oP1rs5tWSLxHb6Xlf3sDSe+QeB+Wa5f4m6duhtdRReVPkyfQ8j9c&#xd;&#xa;/nXntJRTlBYgKCT6CtK10h3Aab5R2Uda6HTdLG3EEAPqTwPxNbcWmYUebJnH8K8KKmSEIcKoA+lT&#xd;&#xa;HCr1qu3zHms+5kAm2ryKYZOeOtW0HygjrVuG8uIsASF1/uvyKuxTWs/EsIQn+IcU640m3nXgKc9z&#xd;&#xa;WRdaNLCCYycf7XI/OsydGgGWVoj/AHx0psOomM4nPy5++o/nWnDNuwyOGU9CDVhZyfSpEbd1NSAA&#xd;&#xa;UhFFLQR3NNIJ+lNKU0pg8VHgg80GMHoKYU2jpUciHNQMnXNNEeFz61E8dQsyqMHqKhwH6im5aE5j&#xd;&#xa;br2xUqXW/CuNp9akAXqDml/CuFoorsvhl/yHLn/r2P8A6EteiXyWj2+2/ELQ5HE2Nue3Ws/yPDf/&#xd;&#xa;ADz0r/yHWtEI1hQQhRGFGwL0x2x7V5F43/5Gi7+o/lXeeBdO+w+H43ZcSTnzG+nauM8TauzeMPtM&#xd;&#xa;bErauFUj2616PewR6vokkfBWeLI+pGRXk2hRND4mtInGGScKR7161rhK6NdspwwjJBqj4W1qLXNJ&#xd;&#xa;G/BmQbJUP8/xrL03Qho3jXdCD9muImZP9k9xVn4h/wDIsv8A9dFrI+F3S+/4DU3xQ/48bL/rof5V&#xd;&#xa;59AXWeMx53hwVx65r3kcgZHNeO2WrPofiaa7hUOiyurL03KW6V6TpvinSNRVRHdpFI3HlzHY2fTn&#xd;&#xa;g/hT9U8O6VqsZ8+1j3kcSxjaw98jrXk+taXJpOrTWTnfsb5WxjcDyDWmPA2vkcWiY/66r/jUN34Q&#xd;&#xa;1mxtZbm4tlWKJdzESKcfrWp8Mwh124JxuFudv5iuo+ILOvhiQR5w0iB8f3c/44ryeuo+HbyDxMio&#xd;&#xa;flaJ9/0x/jiu48bqjeFb3f2CkfXcK5/4X/cvvqta/inVzouqadcnJibckgHpWhrGnWviHSPL3Ah1&#xd;&#xa;3xSDsexqt4JgktdC+zSqVkildWB+tec+Lv8AkZ77/rp/SsaivQvhf/qr76rT/ih/x6WX++f5VT+G&#xd;&#xa;mneZd3F+68RjYh9z1q18TL/EdtYqR8x8x/6VueCr77f4dg3HLxfu2/CvPPF+mnTteuFCkRSHenvm&#xd;&#xa;ul+GmqZW40yRun72IE/99D+R/OpviBorXt3p1xAvzzSC2Ygepyp/nXWSvb6RpJY/LBaxcfRRxXid&#xd;&#xa;5dSXt5NdSnMkrl2+pr1zwfp39m+HbZGGJJR5sn1b/wCtgVwOp643/CbtqKtlIJwi/wC4OD+Yz+de&#xd;&#xa;ka7Yrq2hXNuuGMke6M/7Q5X9QK8TYFWIIII4INJU1tbyXMmyMfU9hW/p2mEOI7ZPNnP8Xp/hXWaf&#xd;&#xa;4djhUSXTea57fwj/ABrTK+WoUAADoBUbOFHzEKPU0wFWHynNRyZ6CqN3ceUNiH5z39KqQxtnLc59&#xd;&#xa;aVkAbPFTxyqQFDKfTBqRZOasI4q1bXUkB4yVPVc1qxXUUiriRQWOACec+lJJZW86sCi88H0P1Fc3&#xd;&#xa;qvhhky9lxn/lkTw30Pb8a51Wns5WCZjdT80LcD8u1bFhfR3i4Hyyr95DxVrzmRvarEcwcYBqQMe9&#xd;&#xa;O3CjOKXNLkUmKRulMK5FGzikKimMoIqB489KRosDmoJUOOKqvAOpPNRmMY4NQulN8vf1FTQZU7Gq&#xd;&#xa;fA9a4Kiiuy+GX/Icuf8Ar2P/AKEtdL8RP+RXb/rqn9a8or3HRABolhgY/wBHj/8AQRXnPiGzbUPH&#xd;&#xa;T2qjPmSKD9O9emM8Gn2QMjrFBCoBY9ABWUde8Nk5N3ZE+pUf4VpWF9ZX0RaxmjljXg+X0FcDq+n/&#xd;&#xa;AGHx/aui4jnlEg47967rXf8AkCXn/XJv5V5DoWrzaNqKXMZyvSRf7y17FZ3FvqVtBdwkOjDcjelY&#xd;&#xa;XxD/AORZf/rotZHwu6X3/Aa2/GWg3WvW9vHaPEpjcsfMJHb2FZmheAVs7qO51CdJmjYMIowdufcm&#xd;&#xa;uj8QavFo2ly3MjDzMERL3Zu1eaeE9CbX9VPn7vs0fzTMOpz0GfU1b1XwJqlrcN9hjF3AT8pDAMB7&#xd;&#xa;gmu68KWF3pugxW98xMwJO3dnaOwrz7xzdJP4rnMZyIgqEj1AGf8ACuoHxH0wAD7JdcegX/GqWteO&#xd;&#xa;tP1LSLqzjtrlHlQqCwXH865fwzqo0bWoLps+XykmP7p6/wCNeuXltb6xpjwORJbzp95efoRXnN38&#xd;&#xa;PtWjuCtsYZos8OX28e+a63wl4XXQUead1ku5RtYr0QegrI+I+tR/Z00qBwzsQ82D0A6D8+fwpvwv&#xd;&#xa;+5ffVaPih9yx+rVX8AeI/JkGlXb/ALtj+5YnofSvQ0jRCxUAFjk471454u/5Ga+/66VjV0Hh7wrd&#xd;&#xa;62jzD9zAoOJGH3j6Cu18DaHeaNb3QvUEbyOMAEHIH0rL+J0qlLKHI3ZLYro/CGnjTvD9uhGHkHmP&#xd;&#xa;9TTrjXdAEzLcXdqZFO07wCR7VNp+r6RdzeRYXNu8h52x4FYPxH077RpEd7GuXt3+fj+E8fzxXAaL&#xd;&#xa;qDaXq1teJn92/wAw9V6EflmvatsN1FFJgSJkSIffsa4/4k6p5NlDp0bfNOd8g/2R0H4n+VcRoGnn&#xd;&#xa;U9btbXHyu4L+yjk/oK9nubm3sbYzXEiwwpgFm4A7Vkf274a/5+rL/vkf4Vq2N7a38HnWcySxA7Qy&#xd;&#xa;dMivJPGOnf2d4iuUVcRyt5qfRuT+uaz9P0+W/l2oCEH3mPQV1FjpQAEMY2J/E3rXVafaw2yBIhj1&#xd;&#xa;Pc/WtEHPeoZELHis3WVUaXceZtxt/irLjla3sJXhbYROozGQVYEds0SXkrWMUvnYcTbH4AKjPQj1&#xd;&#xa;qncXEgeZ1bK+YFBwCFHr7065meC2do7jcQRg8cU+OXfC5kbPXIOP6VTsXEdqjoIC6qxUD75NXoHY&#xd;&#xa;2/mm4yxjLbcDANN0+6knYCWVlfZkA4+b3qayvJZbR3kmO4IxByvb+VW9OuMW8Vw0ySMq7zkjCn14&#xd;&#xa;rX0S8uLmWVLkyCRVVsHaUIJPzKy9j6HnitgdDkZ9RWXq+h2+ox5I2SgfLIvUe3uPauDvbK50+7Ec&#xd;&#xa;wMcyco6dGHqP8KvWeo/aV8qfCz4/BvpVpHZTkHH41cjugRhhzU4cHoadkUoJNLmlzRmlApCeaaRT&#xd;&#xa;CvpRs55pkuAPWqcjZquyFvamGIqemajMZJ5FL5YxzQUGM5xjvUP2hP8Anota+k+CNHu9JtLiVZzJ&#xd;&#xa;LCjtiTAyQDVv/hAND/u3H/f3/wCtR/wgGh/3bj/v7/8AWrQ0bwxp2i3Lz2QlEjpsO98jGc/0q5q2&#xd;&#xa;l22r2f2W7DmLcG+VsHIrD/4QDQ/7tx/39/8ArV0ltAlrbxQRg7IkCLk54AxVBdBsk1ltV2sbluMl&#xd;&#xa;uPyqzqVhDqdk9rcl/KfrtbBrB/4QDQ/7tx/39/8ArVq6NoVnoiSJZeZtkOWDvmpb7SLW/ura5nVj&#xd;&#xa;LbNujKnFWrq3S6tpIJc7JF2tg4OK5v8A4QDQ/wC7cf8Af2tfR9GttGheG0eby2OdrvuwfapNW0u2&#xd;&#xa;1azNrd7zESDhWwc1BougWOieb9iEg8z729s1q0YrC1PwpYatcme+lupG/hHm8IPQDFS6P4cs9Fld&#xd;&#xa;7KS4VXHzRs+VJ9cetbA6UyVPMjZNzJuGMqeRXNHwForks/2lmJySZeSaT/hAND/u3H/f3/61H/CA&#xd;&#xa;aH/duP8Av7/9aj/hAND/ALtx/wB/f/rVs6RpEGjwGC1knMWchJH3Bfp6VoUyVDJGyBmXIxuU81zc&#xd;&#xa;ngTR5pGklN07scszTZJPvWlo2gWWhiQWQkHmY3b23Uus6BZa4IxeiQiPJXY22stfAWiqwZRcqwOQ&#xd;&#xa;RL0/SuliTyoljDM20YyxyTWDf+DNJ1C8kurhZvNkO5ismBVf/hAND/u3H/f3/wCtWzpOkW+j25t7&#xd;&#xa;V5jFnIWR92PpWgOlYmpeF9P1S/F5dmZ5BjA8z5RjtitjYBH5Y4GMDHaubfwHokjs7C4LMST+971Y&#xd;&#xa;03wjpel3iXdr54kTpmTINbF7aRX1nLazqWjlUqw9q50+AND9Lgf9ta6Gxs47GzitYixjiXau45OK&#xd;&#xa;ytV8J6Zq96bu8M5kIC4EmAAPQU7SPC2maNdm5tEkMhUrl23YB/8A1Vd1bTLfV7M2t1v8okMdjYJx&#xd;&#xa;WJ/wgGh/3bj/AL+//WrY0bRrTRLd4LPzPLdt5Dtu5xj+lUfE+kaZfKlzqCuZIxsQI+0t7VgQWsVr&#xd;&#xa;EIYI9iDt1P41chOw8jFOi13ThOsBvI/NJwAM4z9a145OOetQ6jqlppcAkupcbvuovLMfYVW07U49&#xd;&#xa;Wklja0kiaLGVlA5B6cU/Up7SxtTJdBFiXoNmefYVhXOqvPGRbaXcOJP4nUIGpIZ76CPnSlK91SZc&#xd;&#xa;/liqh1G080x3Fu9tk9JYwBmr6JGUyqoUPPA4NSrGkbBljVfcDFWEt4+WEaDd1wo5qRYYgR+7Tjp8&#xd;&#xa;op6QQgnEMYz1+UVMsUaAhI0UHqAoGa0tOeKKIp+7iAOR0GavI6sMqysB3U5/lT81S1XTINTtWimX&#xd;&#xa;3DDqp9RXneo6dPYXZgn4deUkXow9RU9ndmUbJMiZPvDpu9xV+J8irMchFTq/rT99KHpd1PVqXdzR&#xd;&#xa;mkNJ0FRs+e9Quw71AwBNNxShaYyUwx/Nk9KsR6aLuyunbcsaRE5BwSa4PK/9Nv8AvuvYvD//ACL+&#xd;&#xa;nf8AXtH/AOgitGikopaSiilpKKKKKKKWkoopaSlooopKKKWkoooooopaSiiiiilpKKKKjnkWGNnc&#xd;&#xa;gADJzXJ3t291PvJ4/gX0FQxrzjFOurf7RbSQFmTzFwWXris/V7aztdINvb2sYkkKxxYUbtxPXNbK&#xd;&#xa;zpY2Qa4fiJAGYnqf/wBdYVvMs0r63ep5kjHy7KAjOT2OK6LSLRrO3Z5/nuZm3zN7+n4VW8Q2MmoW&#xd;&#xa;REI3SxuJFX+9jtTbbULa7jC5EVwow0Mnysp+lByH461DZwxahJcxMA6opLBhxmuetpZLG78mL95A&#xd;&#xa;6ltmfuY610qQSPYpPs+RxwfQ063f5ArYLDrzU4KhwCRk84zyanbYkZcsqqOpPArE1DXNNkRrdL+W&#xd;&#xa;NsjdJChbA+tXdMsNEvGjdIortWON8jGQ5989Kg161i8O6lpt9pQNuJpvLlhQ4Rx9Pz/Su0zzTgaz&#xd;&#xa;db0tNTtSp+WReUf0Nee3UEkM5BGy4iPI/wA9qv2dws8YdeCOq+hq6JOAQaespPepQ/rTg9PD0ofF&#xd;&#xa;PDGnD60hcComkLcCmFiKaTn60mKQrSFD2o2HHNIImkdUUEsTgV0c9qtpoNxEAM+UxJ9TivIK9i8P&#xd;&#xa;/wDIv6d/17R/+gitGiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiikJxXP65eeY3k&#xd;&#xa;K2UTl8dz6Vloo6sOTT4wA2Kn8wHg4/Osu2xqGpNd9be2ykOehf8Aib+lZ+vzS6jeRWFkhuEjG+UR&#xd;&#xa;njPYE9K1tNsGikW5vSGnVdsaD7kI9B71qrMXNTKTxmqeo21vdri5hWXHQkcj8aq6foKyTMYLu8gV&#xd;&#xa;BkBZNwz9GBpPDdhctLe5vJlIJU/IuT+YrE07Sn1K61ArLMBaowXaeWbPTgdK6jRNEtpNKj+1xSvI&#xd;&#xa;eokkcj8s4qoLOKyneOKJI8HHyjGaraqjxLDfwjL2xywzjcp6iq1jfWus3DS3k8SW6HEdu7gZ/wBp&#xd;&#xa;h3+la9xqGmWkR/f2yKB91COfbAqj4etZYbq4vHj8mO4kVo4/b1xVnWUOseM9PsF+aKxHnTY6A5yB&#xd;&#xa;+ij8a60Z70tL9a5rxXpQkiF9CuZIx84A+8v+IrkVYWtwsgz5cnD+x9a0VkwP6VIr571KswBxmnCf&#xd;&#xa;npUiuT1qQNxUocBaTzM00tkik6HilPzfWm4xTuT1FJxTlIobGK0tDs9zm5ccDhM1par/AMgq6/65&#xd;&#xa;N/KvGK9i8P8A/Iv6d/17R/8AoIrRoooooooooooooooooooooooooooooooooooooooooooooopK&#xd;&#xa;qX9z9mtnl7gYX61yhYs+W57n3NO3cZqhqk04jihtm2y3EgjDf3R1J/Ks/UtOgjkjsrcyy3svJd5G&#xd;&#xa;Oxe7GrFxpVhp9oqqktxPIRHFG0hwzH2HbvWtpunR6ZaCBMGQ8yMB95u/4VDdaiyym2slWWVRl3Y4&#xd;&#xa;SMe5o0S+ub4STzJFHbIdodSTuI6ke1SQ+IorjVDZwQsyJnfOWACj1pn9u2l1f/Y7ffKxzl1HyitC&#xd;&#xa;11IWRaGOF7i6l/1cKdT7k9h71LeXt0saadBHCuqXIzIYeVhXuxPrVM2qQbNK0vzFS4Oy4vM557hf&#xd;&#xa;UmuntoEtbeO2jLMsa7RuOT+NYl3te9kYdM1z/iiRnS1sYzzcSYb6VoyaPp0sKRy2sb7FC7vun8xR&#xd;&#xa;aaHp1tKJIbRQ46FiWx+dW7+7SxhErqXkY4jjH3pG7AVNpVpJpcMkkyG41W8bzJQn6Lk8BR0rFsPE&#xd;&#xa;2oy+JZba7dVih3AW1tH5hkPoG9ffirun+J7u48RTWl5HbWFrbqfMWVxvz25zg/hXT21zFdR+ZC29&#xd;&#xa;M4DYOD9M9qldBIjIehFef6rpotrqa2IwjZKfSs+3ncIUf78fyt/jU6yHPNSqwqZXz0NTRtxUoanh&#xd;&#xa;i1HPSlBpS2OlKCDTsClO3H3qbsB6UFMDinQRNPMkS5yxx9K6uGJYYljUABRiq+rf8gq6/wCuTfyr&#xd;&#xa;xivYvD//ACL+nf8AXtH/AOgitGiiiiq19e2+n2zXF1KI4l6k060uoby3Se2kEkbjIYVNWDqviJre&#xd;&#xa;9/s/TrN769xlkVsKn1NFhq+rNex22p6O1uJPuyxyB1H19K3qWikoooqjcata22pW9hIzfaLjJjAU&#xd;&#xa;kHHvVaw1Oe58Q6nYOqCK1EZQgHJ3Lk5rXoorn/7U1K78TT2FktuttZ7DO0gO5t3Py49q6CilpKKy&#xd;&#xa;fE+pTaRok17bqrSRlQA/TlgK1ImLxIxxllBOKU1nxarHdw3ZsVaaW2JUxn5ct6Zqxp01xcWUct1b&#xd;&#xa;/Z5mHzR7s7as0UUUtFFFFFFFFFIelc9r0+51iB+VOT9ayQDjmlAFUdUtruRrW4sArTQOeG6cjFTa&#xd;&#xa;fataq0sxEl3NzLJ6ew9qjtP9P16S5P8AqbQeXH7ueprYnR5YnVXKFhgMOo/Csay0SVI/s91c+ZAW&#xd;&#xa;LMkalS5/2j1rTstGtbPPkiTZncI2clAfXFUodBT7XLfagFluJG3bB9xfw71HJpcJv3uo5p4WYYYR&#xd;&#xa;kKD+lQx2V7aalJcWNysKSKFZ2yzj6Zrp9Ih06w0+eVXeaVgWnkk+aR6qWkl/r06SRRNpdjbn90xj&#xd;&#xa;G9z7A8D8q0p7iGxhMVu/mzN952bJ+pNZIY5+tY2vZhv7C9kB8mJ8O2Olan9r6avzG/gx1+9zUI1v&#xd;&#xa;7VJ5Wj27XUneRhtjT3JrV0nSjFci6vZvtN3jhyMLGPRR2+tbNxEZ7aWJZHjLqV3p1XI6iq2k6PZ6&#xd;&#xa;PB5VnFgn70jcu59zU7afZvc/aXs4Hn/56GMFvzq0Bj/61OFYHiiz3wC4QZZOfw71xNyBFcpKPuyj&#xd;&#xa;a39KVZRg8809ZNw4NTRvjvVqNz68VMHqUP2pd2KUE9TSZpQCenFOCt6ml2k05dy05m4rd0i08mHz&#xd;&#xa;XHzv+grSqpq3/IKuv+uTfyrxivYvD/8AyL+nf9e0f/oIrRoooorir59QvL+7t9ftYYtJUZ8wnATn&#xd;&#xa;hlbqT7fyqbSZNSt9YitLC2h/sUR5R1bII/vbuu72rrq5TwgVXU9YSbi68/J3ddvauodwilj2GfrX&#xd;&#xa;HWzatrlvd6pFqsloIXYQwIBtwv8Ae9acmtXrWumay0jiAt5N1GD8vpup0utXhGq6vFK5tLdfKt0/&#xd;&#xa;hZu7VnJdauLaO8gl1qa8OGaN4cwMPQDsK1L2XUb/AMR21lHe3FnFLbb5FjOCD3xnoag1r7bYXkUV&#xd;&#xa;3fammnJFhbi3bLb/AFcjmup02VJrCF4rk3SFRiY/xVx/iCxnk8baei6hOhn3FGAGYuDwtWEs577x&#xd;&#xa;nrMMN7NapsiMjQYDt8owAe3ektNXvtK07X0muHu206RVheXk/NwM+vaqS3OsJax3ltLrc16Qrskk&#xd;&#xa;H7hs9QB2HvXexM0kCOVMbMoJU9VJHSuJ0eyuLfxRrDtqNy/2Ty5JOmZxtJw1WNMttW1/Tjqx1qe1&#xd;&#xa;kkLGGGIgRoASAGHfpUcmv3154f0q6V2ime/WCYx8BwM5/A1seIru4ttS0VIJnRJroJIFP3l461nx&#xd;&#xa;rqGq+JdXsv7Tuba1gMZAiIByR0B7d6rwazqGmaLriy3DXMthOIoZZOW5OMn1x1qt4i0u/tvCj3U+&#xd;&#xa;rT3PmBGmilwVySPu+mD+lad9Le6l4gg0e3vZbOCO1E8jxHDsemAfyptuuo23icaZJqk80LW7MrPj&#xd;&#xa;cp9T6mqWgW9xax63OL6ZjCzDB/ibH3j71O2r6g+h6Pbw3BW6vzta4bqo/wAamuP7Q8OX9kzalcXt&#xd;&#xa;tcyeW6TnJB9Qe1Q6ZFqWs299JJrN1CsMzrGsRA6ep7j2pIr/AFi88JRywyTSSpMUmeHHmlAeo961&#xd;&#xa;/C9zbzwzLBqN3dbW5S6/1kXsa3h0paKKKKKKKKjlO1ST0AzXI3cxnmJP8TZ/ComOTSdDRziq2oXf&#xd;&#xa;2Kxmm/iAwo9SeBU2kw/ZrGKNuXxuc+rHk1oBs9aljANW41AxVe6I6VnyKBmoup4zTRIqtzIEYe/N&#xd;&#xa;Sm7yPmnkI9CTikjdX+4wb6HNSjirCxJNGUkRXRuqsMg1XHh/Slk3/YIs9eRkflWvbQRxqFiRUUdF&#xd;&#xa;UYFX4YgvNS45zRilApwFKahuI1mhaNhkEV5tqduYxcW5+/Ax2/h0/Ss3JZQw7jNPRmHSp0mIqQXT&#xd;&#xa;j+HNTx3RJG4Yq9HPGRnJzT/OQ9CKkU5HtTto604H2p+cjgVIpHehioHFT6Xafa7rc2fLTk+9dMAA&#xd;&#xa;MCiqmrf8gq6/65N/KvGK9i8P/wDIv6d/17R/+gitGiiiiqGr6Vb6xZNa3QOw8gr1U+op+m6fb6XY&#xd;&#xa;x2tsMRoO/JJ9at1h6t4cjvrtby2uZbK8HHmxfxfUU3T9Auob1Lq/1e4vXjztQgKo/CoZ/ChMsws9&#xd;&#xa;SuLS1uDmaBACD64PatT+yLUaQdMVMW/l7Mf1+tJBo9rFow0vbug2bD6n3rJTwrc7EtpdauXsUIKw&#xd;&#xa;bQDgdt3XFan9kINaj1IStlIvKCYyMeuah1HSL65uZJLTV5beORdrxMgkXHsD0q7pWnx6ZYR2kTFk&#xd;&#xa;QfePUmq17oiXet2epmZla1BwgHDZB/xqS10lLfWb3URKWa6VFKEcLtGKgj8P24fVDM7Sx6iwLqRj&#xd;&#xa;bwen51QTwrdGNLWfW7mSwjI2wbQDgdAWznFdMqgKABwB9azrTSI7XVr++8xnN5tDIRwuBjiss+FJ&#xd;&#xa;4fNg0/V7i0spSS1uqg4z1Ct2q7P4bs5NEj0uIvDHEQ0cinLK4Od31qC08O3H9oQXmp6nJfNbZMKm&#xd;&#xa;MIFPqcdTV6y0lbTVr+/ErM15syhHC7Riq6+HLfZqkUsjSR6jJvZcY2fT8azpvCFxdWQsrvWriW3j&#xd;&#xa;wIk2AbcdM+tX9U8PteXUF7Z3slleQp5fmqgbcvoRSaf4da01YalcahNdXGwoxdQAfoO1TW2hR20G&#xd;&#xa;oRCdmF6xY5XG3IqKTw1byaLbWDTSB7bmKdRhlPrUdr4bmN7FdapqUt+8H+qVkCKp9cDqavaVo6ab&#xd;&#xa;BcRLK0gnkZySMYzVOPw7LbaatrZ6lPBIkrSrIoHJJ6EdxU+kaM1hc3F5c3TXV3PgPJsCDA9AK16W&#xd;&#xa;iiiiiiiiqWqSeXZyHuRtH41yrDLtjoOKBTT1px6Vla3gpZo33GuVDVtRqc1MAB2qVMAZBqUS7R61&#xd;&#xa;Xmkyc1WlcAY5LHoo6mrtnozSgSXbcHkRIcfma14baC3UCGJEA9BUuaq3FhaXP+tgUnsy/Kw/EVl3&#xd;&#xa;enTWnzxkzwDk5Hzr/j/OiAq6AoQVPcGriKMVYiU7hiryDAp9IcdPakV0LMgYFl6gHkU8UGmH36Vx&#xd;&#xa;PiiARav5gHE0fP1HH8sVyyfJGUP8LEU4NTg+KUMSauQHjmrDOAvSmoyE9KtxbT9yQ/nVkB/XNOTf&#xd;&#xa;3FSgN2NPwe9N8su4VRkk4FdPYWq2tsqfxdWPvVmlqnq3/IKuv+uTfyrxivYvD/8AyL+nf9e0f/oI&#xd;&#xa;rRoooopKKKKKKKKKKKKKKMD0ooooooooooooooooxRRS0UUUUUUUlZetP+4RfVs/kK51D+6Lf3yT&#xd;&#xa;+tNHWlNITUU9rFc+X5wJEbh1we4q5G4LVYLAio/M209H3Co5iEVnboBWhpVjsH2iZcyv0/2R6Vq8&#xd;&#xa;dBRRj2pCPUUmO4rJvLcWdwJo/lt5Gw4/ut6/Q1MuTjAq/BHsAJ6mps04GjPSua1zSb1L46hpkskU&#xd;&#xa;rff2cn8R3FVLbxZf2Z8vUrTzwP8AlpF8p/EV0Wk61Z6xA0lpIcrwyMMMv4VePWuY8aRYtra4x92X&#xd;&#xa;YT7Ef/Wrh5eJph7hqaHFPDA1ImM1ZQ8cU4s2KQMfSpUcg9KtRXLqeG/A1bius8Oh+oqyjowyrCn5&#xd;&#xa;9s1qaPa72+0OuMfdBrapaKp6t/yCrr/rk38q8Yr2Lw//AMi/p3/XtH/6CK0aKKKKKKKSmu+xGb0G&#xd;&#xa;awfDl9qeqNLeXEkC2m9kSJV+YYPUmtbUrlrPTp7lVDNEhYAng1Ho182o6Vb3boEaVNxUHgVez+VF&#xd;&#xa;FFFFB5FHbNANHtmijPPWkz+VLRn3ozRmkz71S06e/maf7dbJAFfEW187l9avZpOnXilzS0UUUUUU&#xd;&#xa;UUUUh6Vh68+0R+wJrHjVDCg3dBSMFHRhTCR60maUAHqaeGjXneAacrbj8jZp7AnvSRsQcVLBF59/&#xd;&#xa;GjfdA3n+ldCgwopfWpY0yMmpQB6UhUHqBVZxskx69KqagVNpKjDIZcYqHRJPOsFkfmRCUY+4rSH5&#xd;&#xa;0tYd/ea9HcMLaziMIbAOCciqh17WoS3nWUWB0+VhTJvF93Cm6WwTPYBzVaW7k1OUSyLGm8cKqjkf&#xd;&#xa;Wsa7gudKuReafI0Mg6lf8O9bukeOoTCseqRusw6yRrkN74FWPEOsaZqWiSLb3UbSB0YKcg8MM9fY&#xd;&#xa;muLuB+/f3TNQFcUDPrTxIy09bphVqG5DcE1djVHA5FTiEU77OPSrEMWMdatLGvcVbs7X7TOqL90c&#xd;&#xa;sfaulijWOMIgwo6U6loqnq3/ACCrr/rk38q8Yr2Lw/8A8i/p3/XtH/6CK0aKKKKKKK5S/a51jxLJ&#xd;&#xa;pQvJrS1t4w7eS213J9/SoIlurfU7vQZNRuZYHg8yKUv+8j9t1S+A7Ixae1z9quHDO6+UzZQEHrj1&#xd;&#xa;rb8Q/wDICvc/88jXKpc3MmkaDpdvcvbLdL+8kQ4bA7A1aktbrS/EmnWaandzWs4bKSyZI/HvTH1e&#xd;&#xa;90y3v9LmmklvvMC2zM2WZW6HPtTpob241ay0J9QuYo0g8yaRJCHkb61Ppi3Vn4uewk1Ce5t1g3Is&#xd;&#xa;r5I+vvXQ6k7x6ZdujFWWFyCDgg7TXH21hfXXhVdWfWrwXaQmRAJfkAXPBHfPcmpLu/vtU/4RsJdy&#xd;&#xa;2pvUcTGM7c8DJx+Bx9asahDcw6hp/h60v7qKOcPLLcPJulIGflB7dKfH9p0DxJY2S3s91Z3wYFJ3&#xd;&#xa;3NGQOoPpVfRba88QQ3GqzardW8vmssMcT4SMDple9Uv7Svz4AjuheTC5N1t83ed2NxGPpWjrkNxo&#xd;&#xa;enIlvqFy8+oXCQvNLJny85JK+lQ6tZXWh3Oki31a9kinu0SVJpcljn+XXIqzJFdan4u1GxfULqC0&#xd;&#xa;jijfy4pNpzgdD2/rVPRrG81JNRs7nVr3yrGZ44ikmGPXlj1PTpUJ1XUH8DWM4vJFuftYiMobkjLD&#xd;&#xa;n17Va1SyvdM1rTY7bVrxjfs0UpkfdjpkgdB1P0qeKCfSPFtpaxX11PBcxsXW4lL8jvUMV9d/2Hr8&#xd;&#xa;n2iUvDKRG285Qe3pUN/a3lt4eh1garetdAIxHmfJg9ttW7yS61jXbbTReTWkK24mcwttZyR61Y8L&#xd;&#xa;SXY1XVLW6vJLoQOFUuc4FdNS0UUUUUUUUUlc/wCJhtUN6If51zSynHeljZmbvVkKcU0kg0/IxzQP&#xd;&#xa;K7xhvqalimVWwkW36VZK5HFM245qzpx/06Y+ka1tjpS1aX7opaSobgDCnuDxWPqM37wp2AzWXbao&#xd;&#xa;dK0+5uPs7TRLcYYg42g966eKQSxJIv3WUEfSnMSEJUZOOB61zs+oeIjKRFZKiYOMRljVd7rxK0bF&#xd;&#xa;mkjb08lVH61k30l28IN4Ull74Kn+VQWNzsKqG+TPAIPyn0q9dXkbxFZEz9K5Z4vNuGVFxzkZp62s&#xd;&#xa;yg5GKsXIxKR/0yFNtrZ7mTavQdTV+bTWt4gQuffFUjGScFf0prwlBkDg03YPXBqeKSWH5h8wrRtL&#xd;&#xa;9JMBuDWrGoYZHSpljIxipBnjjJrodNtRb2/zAb25arlLRRVPVv8AkFXX/XJv5V4xXsXh/wD5F/Tv&#xd;&#xa;+vaP/wBBFaNFFFFFFFY2raDHf3SXcNzLZ3aDAmi6kehHel0vQYbBppnnlubqcYknlOWI9B6VY0jT&#xd;&#xa;ItKs/s0Ts67y+Wxnk1S1rw82rTbhqV3boy7XijPyMPpTr3w5bXOn21qkskDWuPJlQ/MpqK18MLFq&#xd;&#xa;MOoXOoXN1cxdGkxjHpitC50m2udTt7+Rf30AIX3qvq+gpqVxFdRXM1pdRcLLF1x6Go9M8OxWGotf&#xd;&#xa;m8uLi4ZNrtKwO739q0NW/wCQTef9cH/9BNcnofhtr7w5aAaldw20yZlt1I2tyc/TPpXRPoVq1zps&#xd;&#xa;0ZeMaeCsSLjBBGOfyp2s6LBqyws0kkFxA26KaM4ZDUGneHltL8393eT312F2rJLgbB7CuYuH02zv&#xd;&#xa;r6Fr7UtNV5GL2YQ4mJ7oR0BrU0LQPtfg63sr0SwFpTMFH3h82QDmt7V9Kg1ixNrcFgMhldThlYdC&#xd;&#xa;Kyx4TEs9tPe6peXUttIrxlyMDHOMf1rTg0qKHWLnUlkcyXKKjKcYAA7Umn6TDp8l68byMbyUyvux&#xd;&#xa;8pPpVNfC9qNGh0zz5vKhmEytkZJyTjp05q7f6VFfX1jdySOr2bFkAxgk+v5UXGlRXGrW+otI4kt1&#xd;&#xa;Kqo6EGqy+HrcWV/aiWXbesWc8ZXPpxU91o0N1oy6Y0jiIKF3DGeKwvEsVlaXlnJNLe2bomwXsK7h&#xd;&#xa;gfwnFO8E222bULmLzjbTSDy3lzuf3Oa62looooooooopKwfEy58sdmUj+VYAt1AGG7UojC808Nzi&#xd;&#xa;mOpYcAn6U4bgP9WfypfP2nBiP/fNWLWZZX2hGB9ccVYdTmjb8vSlsyY9QAbIEqEDjgkVuIcoD7Ut&#xd;&#xa;WI3BAGeafRVedwT7LzXOXspLSOTwTioktfO8H3xK8zBnGfTtW1oUwuNFs5B3iFX/AOVZGqadqF3P&#xd;&#xa;uttQaCLH3FJH8qonwvPM4ae+MhH98lv51Qv9P0zSkMS3DyzueVUDArMj0u4Mw8tSUbn1rWi0C5uA&#xd;&#xa;C0bDPXdxirsfg+0BDySkt/siq+raJBYWbT7yyKVBB68nFcpc4a5k2DPAAH41sW1sLW0RQP3khH1r&#xd;&#xa;UnDqqIDQLBZkzKsZz7c1Tu9KjSJtrcYJwe1YNpGzOeAee9bUOnRSR7sbD+lZV5YmG5O38xVqxvZb&#xd;&#xa;bCyqWT1ret545kBRh9DWppNn5kvnyD5V+6D3NbYpaKKKp6t/yCrr/rk38q8Yr2Lw/wD8i/p3/XtH&#xd;&#xa;/wCgitGiiiiiiikoooooooooIB6igAAAAAAUUtJRgHHA4oxRRRRRRRRiiggHrRRS0UUUUUUUUUVi&#xd;&#xa;+JFPlQuB0Yg/5/CufX7opwGetNkikXDIm4egpsN6kMhSQbSex4Natu0cy7kOR6GrG0YpAoxxxTTH&#xd;&#xa;zUkFq08mBwo6n0qzqVm32NGth+9tzvT/AGvUfjRZXCTxhlPyuMj1HqKs0AkNkdaf57gdAfxprSux&#xd;&#xa;5O0egqKc7YmJOOOtc1diS6njtYeXlO0Y7DuTW5folpoVxGg+SOAqPyqPwx/yL1jxj92K1KM1l6rY&#xd;&#xa;399II4bz7PbY+baPmP40WWg2Nowbb5snUs/c1phQowAAPQUUoNYHi6QDTUj7ySqPwGTXJadbm4uZ&#xd;&#xa;JD0B/lW0i+bfQr2Xmrx/eTnjIBq4BtUdsVkX8xKzPkbQNv41madDwOOtbFyRb2iqPvNxiqTQeY3P&#xd;&#xa;OKeLRccirmm6YZrkKmVA5Zh6V10caxxhFGABinUtFFFU9W/5BV1/1yb+VeMV7F4f/wCRf07/AK9o&#xd;&#xa;/wD0EVo0UUUVXu7uCyt3nuZRHEnVmp9vcRXUCzQSCSNxkMO9SVn61q0Oj2YuZzkFgoHrmrsciyxr&#xd;&#xa;IhyrgEH2p9LRRRRVa+nltrSWWGBp5EXKxrwWPpS2c0s9pHLLC0EjqC0bclT6VPS0VU1DUbbTo45L&#xd;&#xa;pyiSSCNSFJyx6CrXaoruVobWaVQCURmAPTgVT0DUJNU0a2vZVVXmBJC9BgkVo0tFFFFUL28uLe7t&#xd;&#xa;oYbKSeOVsPIpwIx6mr1LUU7mOGRxyVUnn6VQ8P6lJqulpdSqqszEYXpwa06Wobm4jtbeSeYlY4xu&#xd;&#xa;Y4zxRa3MV3bR3EDbo5BuU4xkVNRRRRRRVDWI/MsW45Uhq5eJc7l9DViOMHjFXIo9pBqWW0t7lMTx&#xd;&#xa;I/oT1FVbTTVsp3aKRvKI+4eSD9askHOKcinHNKIWdgqdTWvBEsMQUD604isa8tZLKZri1RngY7pY&#xd;&#xa;l+8h/vKP5ip7W7iuIwyurZ6MOhqxRRWfq1z5UaQopkmkPyxLyT/9al0nTTaBp5yGupPvEdEH90Uz&#xd;&#xa;xNMYdAuyPvMuxfcmka+j0bR7SN1MkxRUjgT7ztioLW81m1llu9cNpb2CoTtQ5ZT2H1rZt51ubeKe&#xd;&#xa;PISVQy7lIJH0rP1rXrPRYszNvnb7kKcsx/oKJNYa20iC5uodl1Mo2Wqn5mc9FH9TVQeILy2iLavo&#xd;&#xa;91bgZzJDiRAPf0qFl1bxBGLm3vTplnuJiAX95IufvMc8fStLSdWj1KaeO3V3htiIzcNgB274FY/i&#xd;&#xa;ybfNDEP4Qz4+vA/rVCxiFvAD69afbXIS8y3GRgGtq3UBdxOSaS+uRDGACC54Arn9Xl8m1iizlnbL&#xd;&#xa;VNpckYUMWGBU01wLq6BzmNOlSxNjORwelWraFrmURoDnv7V0tnapawhFHPc+tT0tFFFFU9W/5BV1&#xd;&#xa;/wBcm/lXjFexeH/+Rf07/r2j/wDQRWjRRRRXE3s99qeo3djrVisGmICfN3Y8sA8MG759KsaRPqFn&#xd;&#xa;rEOnWVkp0kR5WUNncP7+719q62uD8RanYXviIWt/Iws7VCDtQtuc/T0q94T1bz9EurUSEy2YbYxG&#xd;&#xa;CVxwcGqMV3rp8OrrZ1QsYufJ2AKyg8596vXmoalfazp9tY3htY7m28x8IGx9M96ks7rUdM1yXS7u&#xd;&#xa;+a7jkgaWKRwAyketQ6FLqV1YHVrzVJmjgZ8QKoAcD1os11zV9NbVk1drcsC8UCoCgA7H1p0mt303&#xd;&#xa;h231mKURtA2LiEkBZADg496da6lqF1oGoaw1zsDqTbxLg+WB68dar6rq+pQ6bocltdbJbl1EhKgh&#xd;&#xa;s46066/tnT/EFnYprEky36sC8sYPlkdSo6fSprG8vtL12/srm9lvYIrM3KGQDcMdsj8ar2f9u3eh&#xd;&#xa;ya4NXKSMjyJb+WDGFGePrx1qnrjXt94W0e8kvn/eSRqy7By+Th8+3pV7V9UvYtUg0cXt0qxQB57i&#xd;&#xa;C33yyHtgDpT9Kv76T+0rO4a6uLVbZnhuLi3MbdOVPHPX9KqWN7d6X4Y0K9ikYWqOUuY8DBVmOD7Y&#xd;&#xa;rcs7661LxLci3mI06yXy2AAxJIevPtUvirVZdI0dp7cZndxHHkZAJ7471z0epalZ3FtLBdanfbnA&#xd;&#xa;nims2Vdp6lTjir4k1LXdd1CG31GSxtrFhGBGoJdu5PtxUFtqmqppfiE3N3vnsmKxuqgYwDzgCr66&#xd;&#xa;hdnwQb4zk3XkFvMwOufyqCTU70SaABcNi6/13A+fj6U063daUdUtb+YyzRfPbMwALg8Ace9RTXWs&#xd;&#xa;NJpuk/bmiurlDLNPtGVH90VLp1zqS6zqWn314bmOG2yh2Bc+5x3rPtdWn0vwdb/ZMiaeZow23cV5&#xd;&#xa;6gd6mtNR1G1v7URXOpXsUrBZkuLRlC+4OOKtQPquq63qdomqPbW0EmF8tVLfQH0qoJ9RvfDmq282&#xd;&#xa;oMXtJCpk2AmRfQ1ueEYZotAtjLctMHQFQVA2D0962xS0UUUUVFPH5sLof4lIrjkyl1tbjcMH6ir8&#xd;&#xa;ajNWBjip4wc8GnmEk0wxFTTscVZs4+S+PpVymmkzWddaTBPI0sTPbTHq8fRvqDwaq+Tq9vxG1tcq&#xd;&#xa;OmSUP9f50ouNWPDadCPf7SMfyp4h1KfiW4gtV7+Spdv++m4H5VZtbKC03GNSZH+9I53M31NT9+ax&#xd;&#xa;dfUXd1p2n4yJJvMcf7K81Wvl1aHxIbqDTFvIRFshJkCiP15NV/EGjazqmlO88qyTowZLWA4THfOe&#xd;&#xa;SavW0uu6lCsDWi6VGAFeUtvcjGPkXt9TWC+kXFr4wMltpMtxFGB5TyudrNj77Mfx/Kurs9Lk+2/2&#xd;&#xa;jqEqz3mNqBFwkI9FB/U0uv2M2paRPZ20oikkwAT90jIJFUodJ1K6RI9YvkeBAAbe2BQOB/ebrj6V&#xd;&#xa;n2Gia1o8lzDYXdnHZSSFwzoWdc+g/wAazZogLyQCWSbLcySHJY/0+lXJE2QjHpVCVN3QkGpYru+i&#xd;&#xa;ARH49xmponkmk3yMWNUNW/e3KqBwoplvblBkZ+laNsh7jFallALrakYy2fyrpbO0jtY9qjLHq3c1&#xd;&#xa;YpaKKKKKp6t/yCrr/rk38q8Yr2Lw/wD8i/p3/XtH/wCgitGiiiis7WdKg1mwa0uSyqeQynlTUml6&#xd;&#xa;dDpVjHaW+7Yg6nkk1ZkDNGwRtrEYDehrO0PR10i2kTzDNLK5eSQjG4mq2o6OBqE2qxT+WTbskke3&#xd;&#xa;Ik49awdB0G61LQYY/wC03SxlO6WAoCeD0DelWNXsXk8Xafb2ly1q8dsfLdQDjHt3rV07QJ4r2a+1&#xd;&#xa;C+N3dyIY1YIFCD2FXNI0ldN0w2TSechLEkjGc9qyf+EZv4EktbHWXgsJCcxGIMyg9QG7VaPhmAx2&#xd;&#xa;VsJmFlancYSufMb1JzR/wjgQX8VvcmK2vF5h2ZCN6jmkuvDQuINLi+1FTYOrhtn3sH61cvdJF3rN&#xd;&#xa;hqHnFDZhwE2/e3DHXNNOio2uTak8m4TW/wBnaLb2yDnNZS+Fb2K0k06PWpF01sgRCIbgD23elXJv&#xd;&#xa;Dnm6HY6abogWkiOJNn3tue2fen6voct3fx6hp94bO9RPLL7AyuvoQaWw0W4hW7kvdRluri6QozEb&#xd;&#xa;UQYxwo4qhq1tDofgltOlP2klDDGMYLuxJHHt1/Ctbw7pY0jR4bU4MuN8rernrUmsaZDq+nvZzkqr&#xd;&#xa;YIZeqMOhFZkGg6pJcQHUdblngt3DJHGnlliP7xHWluvD92uqzX+k6l9ja5A85TGHViO4z0NUPDFg&#xd;&#xa;kjeILCeR5la4Mbs33myDkn3qRfCuorZjTv7aY6d0Mfkjdt9N1a1zokc1xp0kcpjWxPyrtzu4x60u&#xd;&#xa;p6Hbajf2l3KMNbtnGPve1M1vRH1GeC6tbo2l5B9yULuGPQioNM8OyWV7dXc1+9zLdRbHLJjB9R7e&#xd;&#xa;1J/wjER0JNOe4ctG/mRzKMFWznpRaaHqRu4ZtS1iS5SA5SONPLB/3iOtXdP0n7FqN9d+dv8Atbht&#xd;&#xa;u3G3/Gq8Hh8Q2upQfaSRfMWJ2/cz+PNaWm2YsNPgtN/meUoXdjGas0tFFFFFIa5XW7c298zqOGO9&#xd;&#xa;f60kMylasxtk1et8GruwYGKicDuKibAq7Cu2JR7U+kNIaYxABJrNuNSwxSAA47npUC6hc56qR6Yq&#xd;&#xa;7bXaz/Kw2P6ZqxSEhepA571iaePtvia9u9waO1UQR+meprdFOApSKQ0lITTcVR1e6+zWjEfexwPf&#xd;&#xa;tXJQKWmA6jOM/wA/1zWjIm5cVB5B7ChrdjT4othzVX7K0kjOR945q1HbYXpUhQqhA+8eldLo1iLO&#xd;&#xa;zXI/ePy1aFLRRRRRRVPVv+QVdf8AXJv5V4xXsXh//kX9O/69o/8A0EVo0UUUUlFFFBUEEEAg8EGm&#xd;&#xa;xxRxIEiRUUdFUYFIYYjKJTGhkAwH2jIH1p9FFFFFFFFGBRRTJIYpSpkiRyh3KWUHafUe9PooopiQ&#xd;&#xa;xRs7RxojOcsVUAsfU+tPooooooooopaKKKKKKSs3W7Qz2odR80Zz+Fc5CD5rJ/EO3tWlAh4rQgXF&#xd;&#xa;XEbA5qJ5earO4Z8e9aY6D6UuaRqYao6pKVtwik5Y9qxgCtSKc1NGSGDDtWsrhog5OBjJPpWBqOo+&#xd;&#xa;ZHJeDm0tmxCP+e0nQfgK0NBsWsdLjST/AFshMkn+8ea0xT1pTTDSU00E7QSTwK5fWrozz7F6A5/H&#xd;&#xa;t/WoNPh+cnGQBitFoc9AKb5GKaUPpTNu5sAVOluMDgU94di0y1h868hT/aya6iilooooooqnq3/I&#xd;&#xa;Kuv+uTfyrxivYvD/APyL+nf9e0f/AKCK0aKKKKKKKha4iSdYGkUSsMqpPJFS0tFFFFFFFFFFFFFQ&#xd;&#xa;Xc4trWacjIiQuR64Gai0q+GpabBeKhQTLuCntVulooooqjDqUU2pz2KpIJIVBLFflP0NXaWiiiii&#xd;&#xa;iiiiiiiimsAwwehrl9XtXs5xcRgnYckDutWrMrIiupyrDINaEYAHFK7kA1Uabkg1EJMSA981tg8C&#xd;&#xa;lFITTSaz9THCN271lTTJG6qwzu71FBMW1BoT0xxU0dxuvzbADgZqaUSaoRZRErbRn9/IP4j/AHR/&#xd;&#xa;Wo1tl1HVo0jULYafwoHR5P8A61b1KOtPBpCaTNFNP8qzdYvBBCUB57/4VzYJlbPc1o2ibKug0uM8&#xd;&#xa;U11AHAqGJMuTVtRTZjxUmjwl7lpcfKowK26Wiiiiiiiqerf8gq6/65N/KvGK9i8P/wDIv6d/17R/&#xd;&#xa;+gitGiiiiiiiuK1Ual/wnFnsMPKN5ef7nfPvV46rq+qX1xDpHkRw2zbGklGd7egq94f1eXUlnhuo&#xd;&#xa;xHdWz7JFXp9RUGuatew6jbaZpqp9qnBYvJyFUVFY6rqqeIYtL1AQkGIvvQfe/wAK29RvE0+xmupc&#xd;&#xa;7IlLGub/ALU8Q/YP7V8u3+zY3+Rj5tvrmp73xDdM2lHTo0cXwPD9jS2uqapaa9Hp+ptDIk0ZkV41&#xd;&#xa;xjFUD4nu72eZrW8s7SKNyqLMCWfFbOieII7/AEc3t2yQGNzHISfl3DuPY0uq6u40ie80iWK4a3IZ&#xd;&#xa;1HOV7/j3qvd+KYIrrTBF80N0oklb/nmjfKpP/AjSTeIZEvdSkVVNhp8eHbHLy/3QayP+Er1GO2W/&#xd;&#xa;a4s5EOGNooO8A+/rWhq3iZxfwWVjLDAZIRM00wyACMgY9ajs9dlvrTVrG6eKWSG1d1mh+667ef5i&#xd;&#xa;oPD2rTy6dp2laUEaaOINcSv92Jcnj3NdoMhRnk4/OuUstc1K+1WSIT2sAjnMZtZVIcoO4NLqviOf&#xd;&#xa;+2JtOs7i3tVtwN804zknsBSW/ie5k0XVJW8prqxA+dPuOD0I/WorjXNeh0uHV2S3W2bGYcZY575q&#xd;&#xa;ebV9asruxluhbm2vHCiNRymferkWqzvrmpWhVAltCHU45J96zbbV9fvdJ/tGL7NHFHklSMlwDz9K&#xd;&#xa;uX+tX017a2GlrGs80QlZ5OQoxRYarqn9uPp1+sXyQGTen8XvUehalrWsHz91vHbRzMjjblmAPb0r&#xd;&#xa;qB0paKKKKKKKKKSq93As8ZGMsBxXN27Npl59nk/1Eh/dE/wt3Fb0JFNkbOaqOmQTiqzKQ30rdiff&#xd;&#xa;Ereop+aQmm1RvLq3+0pZTEq8o+U9s1iapC1tNHv9eD61FAcawp7E4+tMV5G1S7khUmRIXK49am0n&#xd;&#xa;UFk0O3sbCTfeSAiTPWM/xMa6KztY7O2jgi+6g69ye5qfvTgKdTSaSl7VDczLBGWOM9h6muRvrk3U&#xd;&#xa;5OfkB6+pp9tFnnHFaMa4AqUcmpRUUm5uFBNKiBRUgpBG0zhFBJP6VsWsC28IQfifWpqWiiiiiiiq&#xd;&#xa;erf8gq6/65N/KvGK9i8P/wDIv6d/17R/+gitGiiiiiiisa70yabxJZ6gpXyoY2Rh3yaotpmraVfX&#xd;&#xa;Muj+TLBctvMcpxsb1q9oGkS6cs891IJLq5ffIV6D2FQa5pV5JqVtqmmtH9pgUqUkOAwNQ2Gl6rJ4&#xd;&#xa;hj1TUGhAERTy4z92tzULNL+xmtZPuyqVNc3/AGZ4h+wf2Vvtvs2Nnn5+bb9KuNoDxXekG3ZfJsQQ&#xd;&#xa;2epqe80qW48R2t+CvkxRMjA9eayo9G1XS5JotPgs7m3kcsrTD5kz/OtrTtLZdKFrqZjuWZtz/IAu&#xd;&#xa;c5xj2q5bWFpaRvHb28caSfeCjr2rBsPCcVvZanbSNuFySsR/uIOVH4En8qtWnh9E8MvpcrZknUmV&#xd;&#xa;x3c8k/nWbDpOu/Z47EpYxxphftSqC5Ue3rVrVdEvF1VNT01YJZfKEUkUy8MB0I9KkstM1J7bUGvD&#xd;&#xa;BG9zEY44YlAVOMdaqQ+GruytNPuLGSOLUbZQko/hlXPQ11KFjGpcAOQMgc4NcnqOi6vqcginitFZ&#xd;&#xa;ZQy3qHDhc5xip77Rr+21ifUdMjtpxcgCSKcdCOMg1J/YuoTaDqFvcyQ/absfKqKAqD0qS90W4n8L&#xd;&#xa;x6ajL5ybcknjg1Lq+kz3qaasRUG1kVnz6AdqSPSbhNb1K7JXy7mERpzzmjTNJuLTw2+nyFDMVYZB&#xd;&#xa;45qreaNqEF3Z3+nGJriGERSRucBhil0/SdUOuvqWoPDmSHZsQ/d9qveG9Nm0uweCdlLNKzjb6E1r&#xd;&#xa;jpS0UUUUUUUUUUlZ2qadHdxOGHDDnHUe4rP0+5kgl+w3h/egfupO0q/41eOaa3pioXUdcVdspA0R&#xd;&#xa;XPK1YNFLWH4ntWktY7mIHzIG3A1n61dDUdHt7mEgyA7WHoaz45duqQ3Bf5YwCy++Kv8AhwibV7mU&#xd;&#xa;Nkbf61rX1zZaRum8lFlfrsXBNXLKdrq1jmaMxlxnaetWB1p46UGm4oxTJpVhQu54HaubvrmTULgx&#xd;&#xa;RZxnDEfyFOudFltwkg+ZCOQP4TRCm3j0qwo4p6r39KsW8Dzn5Rhe5rVhgjiTaqj3J71HJZwv/Dg+&#xd;&#xa;1MGnxerfnU8MMcIOxcZqSlooooooooqnq3/IKuv+uTfyrxivYvD/APyL+nf9e0f/AKCK0aKKKKKK&#xd;&#xa;KSjFFGKMCiijFGKKKMUYooxRRRRRijAooooxRiiijFFLRRRRRRRRRRRSYqjqGnQ3kJRwV5yrLwUP&#xd;&#xa;qKz4LmWGQW19gP8AwSjpIP6GroQtUckZFRwEwzhsfL3rS6jI6GlxRTJ41lheNxlWGK87v3NpI1tD&#xd;&#xa;nBbJqGFJJWwDy3U+lbOgPHpt2zOxKSLgn0pszNrfiCKIZ8sNub/dFdkBgADoKcOtPoowO9RXEyQJ&#xd;&#xa;lyM9h61zt1fS6hceRAcf3mHYegrZ0vS0tVDsPm7A9q0iAeOvrVC40xGJaH5Se3aqwsLgHG0fnVmH&#xd;&#xa;TsHMpz7Cr6KqLhQAPQUtFFFLRRRRRRRRRVPVv+QVdf8AXJv5V4xXsXh//kX9O/69o/8A0EVo0UUU&#xd;&#xa;U1mCgljgDuaAcjIORS1jXHinSra4kgluCJIzhgFJwa0bG9hv7Zbi3ctG3Q4xVjpWOPEVodMub/bJ&#xd;&#xa;5Vu5RhjnIOK1IJRPAkq52uoYfjUtFFFITisObxbpEMrxyXJDoxU/Keopz+KNP+wm7id5IxKsRwuD&#xd;&#xa;uPStodKhju4JriWCKZWlixvUHlc+tTVRvNUhs76ztJAxku2ZUwOmBk1cd1jRndgFUZJPamW9xFcw&#xd;&#xa;LNDIHjbkMOhqWloqCe7gt3iSaVUaVtqBj94+gqalpDVSx1G3vxIbZ94iYo3HerdLRRRRRRRRRRRR&#xd;&#xa;RRRSVVu7OK5Uo6BlPUH+dUA0+mHbPunte0oGWjH+0O496u7o5oxJGysh6MDkGmNEKWGXY2x+nY1Z&#xd;&#xa;J9KSkri9ft1jvnLDqc1HYqm0njAqtqGoRwZCYLdhW14OsZ0SW/uRhphhAeuK6akFPFOHHWqF9qkV&#xd;&#xa;qpCEPJ/Kuavb6Scs7vgHqc1o+FokeaaUKCqqAv1NdOBRRRRRS0UUUUUUUUUUUUVT1b/kFXX/AFyb&#xd;&#xa;+VeMV7F4f/5F/Tv+vaP/ANBFaNFFFFcZqesL4guLjRLRp7aUZ2yEYDEHkH0FWNF1mOwvotAmM08y&#xd;&#xa;LgzMOM+n0966quBsrm5t/EOsfZtL+3Bpueny/nW7c67LY2Fuv9nmO9uGKx22cficU+x1TUl1COz1&#xd;&#xa;W1jiMykxvG2QSO1c4n/Ilax/18P/AOhVvT6zJZW2n2VlB595PEpVScADHU0ttrl/HfHT9RtY47p0&#xd;&#xa;LQsjZRyO1IPFKLoMl9LHtuI38toR/ez0qxca8TJp8VkiyyXnzdfur3NVLHX9Q1C/kW2ht/JjlMbI&#xd;&#xa;74kx64rpq5PxTBDJrehWixIPMuTI+FHIGOtHjMBDpNvbwBjJeq/loMbtv/66uW2sahHr8Om6jbwp&#xd;&#xa;9ojZ42ibOMdQfyqCHWI44Ne1GK0jVrWUpvHWUr6/pUVz4i1a10231OaxhS0k2ZXed+G70a1e28Pj&#xd;&#xa;HT5bmQJFaWskxz6twPxq22s3L6Pf389isdosZMSSH5pBjuOwNQyazJp1nosFpYxmS9TIhVsBOAeP&#xd;&#xa;zqez1i/TXRpmpwQoZITKjxNkADsagg1/U72Ga/srOJ9PiZsbmw8gHUitTw9qcmr6THeyRiMyMwCg&#xd;&#xa;54BxVfVLqP8A4SDSrJraOZpC8gduse0dRUB1vUbnVLyx0+1if7PgeZI2BVvw9q0uq2srXEQimhkM&#xd;&#xa;bhTkZHpWlcP5dvJJ/dUn9K43QtR/srw4s6x+ZcXlywiX1JPetJdd1OLVYtMubKITOjPvVsqQKevi&#xd;&#xa;cf2Eb14h9p8wwiAHq+cYol1rUZLuOwsraJrwRiSfc3ypntUmj63d32q3Njc2qwtboC5DZyfb2reH&#xd;&#xa;SloooooooooooopKQqD2rNm00wyNLYyeQ5+8mMo31HaoPtzxHZeRmJv745Rv8KeZFfkHIPcGpI7w&#xd;&#xa;IQsnTsatqwcZU5HqKOlc34wjC26zjr0NcYmoyxxso4DVreFdG/ta6N3cnMMR+7/eNegAAKFAwBwB&#xd;&#xa;S0nTk9KrXGp21uPvb29FrIu9YnnGxPkU+lYl7fxQKdzbn9BWQ1xLdSfOcDsBXbeDGH2a4T+IMD+G&#xd;&#xa;K6UUtFFFFFFFFFFFFFFFFFFU9W/5BV1/1yb+VeMV7F4f/wCRf07/AK9o/wD0EVo0UUUVi67pMl7Z&#xd;&#xa;TfYGWC7kGDIBgsPTNTaNpjWdrCbsrNdqm1piOcema06wtD0y5s9X1S4nQLHcSboyDnIpfEWmXN1J&#xd;&#xa;a3tiVNzaNuVG6MPSobVNV1HVYLi+tFtYLYMQu7JZiMZqmmhXw8M6jZFF86eZnQbuoJqe/wBJvoZr&#xd;&#xa;DUbFVkubaIRvEx4YY7GltLLUtT1uHUdRgW2jtlIjiDZJJ7mnSeHN/ib7Z/y6MPMaPsZOnSnaDoD6&#xd;&#xa;df3c8rbxkrb5P3U61m3+malfXakabHb3Syg/a4nwCuf1rs0BCKCckDk+tYd7ptxceLbC+2A2ttC/&#xd;&#xa;Oed5yOn5U7UtOuLrxJpV0FBtrUSMxz3IwOKJdPuJPF0N+VH2aG1KKc87yTn9KyDoWo/8Ilf2QRPt&#xd;&#xa;d3cmQjdxgsD/AErV8R6XPfaXa2VqgZVnj8zJxhF61VvvDrarr19NeIPsz2yxQuDyGznP50y6sdau&#xd;&#xa;/Clxps8atchljWTd/rEB6/lVyXSp28R6ZcBB9ls7dlznncRjpST6fKfFE2pT4WzSyMStnoc5P6Zr&#xd;&#xa;AgfVNJ8M3MEBtZLFUcxXW/qpzwB611PheA2/hzT4yuD5IYj0zz/WoZdPuZPF8N+VH2aG1KKc87ie&#xd;&#xa;f0pnhzTrqy+3TXSAS3Eu4YOeMVJ4Y0640+ymW6UCWWZnODngniotfl1nMlvYWkc0E0e3fuwVJqjd&#xd;&#xa;+H7qDRdMS0CyXNiwcoTw3rU+n2Wp3PiRdT1CBIY1hKIqtkjPrTrbw4U8STXshzahvMijPQOeppl3&#xd;&#xa;aanp/iKbUbC2W6iuECsu7BUiobJb3SP7U1XU41E07ARIhzk9h+ddHpr3T2MTXqqs7Ll1XoKtUtFF&#xd;&#xa;FFFFFFFFFFFIeagmtlkBHAB7VmS6SEbdCzQn/Z5H5VnzrcRsQ6hwO6nH6UyO9khbMbsvsRV+LWRg&#xd;&#xa;eagPupqlr1zHfWaxxAk5yQa4670+5ebKR/L9a7Hw3JBp2kJHMSJCSxAFaL61bp0BP1qpLrrtxEqj&#xd;&#xa;681SmvJ5/vyMR6CogjYJx09aoXck20qp2g1kPCxY9TU8FueDiux8HoVFy3Y7R/OulHSloooooooo&#xd;&#xa;ooooooooooqnq3/IKuv+uTfyrxivYvD/APyL+nf9e0f/AKCK0aKKKKSjFFFFFFGKMUYFFGKKKKMU&#xd;&#xa;YoxRRRSMoZSpAIPBFYZ8JaV528xyeXu3eT5h2flW6AAAAMAdhRiijFGKMCijFGBTXjSQAOisAcjI&#xd;&#xa;zzTqKWiiiiiiiiiiiiikooqGa1hm++gz61Tl0eF/uuw+vNVJNBY/dkU/UVA2g3B/iT86rXOjy2yb&#xd;&#xa;nxgnsazbhhBwQT7VSe+P8MR/GiO4uJDgYUfStnSYGmu4kY55ya6a702G5GQNj+o71g3+kyxfeXK+&#xd;&#xa;orMNh833aUWhXqMCup8P23kWJYjBkbNagpaKKKKKKKKKKKKKKKKKKp6t/wAgq6/65N/KvGK9i8P/&#xd;&#xa;APIv6d/17R/+gitGiiiiiiiioUnjeV40kDOn3lB5FRX9/b6fbie4fbHuC5HPJ6VaU7lBHQjNLRRV&#xd;&#xa;OXUbeLUIrFn/AH8qllXHYVYSWOQEo6sAcEg5xSSTRxbfMkVSxwNxxk1JS0UU0mobW7gu1ZreVZAj&#xd;&#xa;FWKnofSp6Wqeo6hb6bEktyxVXkEYIGeT0q3S1Bd3MdpbS3ExxHEpZj7CksbyK/tI7m3bdFIMqcYz&#xd;&#xa;U9LRRRRSUgOehyKWlqst7bvePaLKpnQbmTuBViqmo6jb6bCk1yxVGcRjjuelWx0paKKKKKKKKKKK&#xd;&#xa;SiiiqeqRl7U47HNclexFmqkLcFuRU6QYPFdD4ctsB5yOPurmt6ggEYIyKpy6bBI24ZX6U1dKtwcs&#xd;&#xa;C/sauqoVQoAAHQClpaKKKKKKKKKKKKKKKKKKp6t/yCrr/rk38q8Yr2Lw/wD8i/p3/XtH/wCgitGi&#xd;&#xa;iiiiiisfWtVe2KWdkvm30/CL/cH94+1YHh+S4sdH1W8KvdzmZgSDycDBNU4J7ifwjAbi3lO67R0J&#xd;&#xa;bJky2eK6W1124/taPT72xa3aZS0R3ZyB61sXE6WtvJPK22NFLMa5w+LJVRbp9OdbBmwJdwzj1x6V&#xd;&#xa;dv8AXmiu4rOwtmu7iRBJjOAq+pNZNjetfeL5Z5rd4WtLUh0bse9U9RvwnhUvp1nJDHdzEFg/Q5/r&#xd;&#xa;WjdXUEj6JaahYObiVhsDPymO59elXLnxFO99NaaXYveG3OJXzhQfQe9Oj8TQvod1qJhdXtTslgbq&#xd;&#xa;rZxj9agm8T3NvHbXU+myR2VwyqHLfMM9OK2Jr8xanBZ+RIwmUt5oHyrj1q6elcX4ZvhpnhnVLxoy&#xd;&#xa;4hu5G2g9fu1cn8V3EFvFfPpki2D7R5pbkA98elXtU142t3FZWds93dypvCKcBV9TWR4lu7m70O2k&#xd;&#xa;urU20qahGpQnOfcfnW+NWB8QNpIjO4Qed5meOuMUwa3GNVvrKRCgs4hK8hPBBGawdT8Q3OoaBeyr&#xd;&#xa;pkosZYnRJs89CASPSptI1ePSfCWnFkMsso2xxr1Y5q/ZeIZWv47PULM2skwzGQ4YN7Uyz8RXN9ds&#xd;&#xa;trp7SWyymNpN43Ajvj0relk8uJ5MZCKWrmP+EtuJLD7dBpkjWyEiVy2MYPb1qSXxXLGkF0dOkFhM&#xd;&#xa;wVZicHn2q1qPiB4b9bGwtGu7gpvYA4CioIPEct59ugSwlW4to8mMkZJPas/wzrTWmgT3F9FIIo5G&#xd;&#xa;w7NneSfuiryeJ545IWvtPa3tp2CpJvBxnpkVLd+Ipk1aXTrOxe4mRQwIbAINPttRtzrlxHJaLDcx&#xd;&#xa;26ySy57en4VWi8UXVwr3NvpUslihOZQeSB3Aqjr+prq/hOxvVjMayXifKTnGGYf0rtKWiiiiiiii&#xd;&#xa;iiiiiiimSIHQqehGK5u9tSkpUj6VUFvz0qSO2LyKijljj6V1NtCsECRL0UVJRRRRS0UUUUUUUUUU&#xd;&#xa;UUUUUUUUVT1b/kFXX/XJv5V4xXsXh/8A5F/Tv+vaP/0EVo0UUUUUUh6VzV14WDXFxepf3YuHU/dI&#xd;&#xa;/KqelaNe2Pha84me6nRsQsehJrSt9PmjstGtjEcQkNJ7YFLcWdxN4vtroxt9nggYb+241e1yyfUN&#xd;&#xa;HubWNsPImF+tclZ6cHSCyl0CUyqQsrvIQmPWtG5iu9G8SPeQWMl1bTQrGBH1TFMsLbUZJtavZ7No&#xd;&#xa;ZbiPbEnUkYpsukXf/CPaRYrAxZZVaYf3cHNXb3T7m48ZWFyIm+zW0Z+ftkg1TsXvvDlzfwHTpruO&#xd;&#xa;eZpopIu+exqvc6JqT+H74SRH7VqV2skkafwLuzWx4nsp7yDTra3iLxi7jaTHRUFXLbVHu9buLOGI&#xd;&#xa;Nb26gSTZ/wCWh/hH4VpmuLttJvk8IavaNbuJ5p3aNPUErz+laHiCwubnwWlnBCzXAjiGwdQRjNR3&#xd;&#xa;0F7pmvx6tb2j3UUluIZY0+8uO9JrP27W9FgdbCSJ1vUYRN97YP4jUmrR3eneJ49XgtJLqF7fyJFj&#xd;&#xa;+8pzkGobLTrvVbnWb25ga0F9B5ESP94DbjJ/SqaS6svhptEGkym4WJoTJkbCvqPekn0G8bw/pLG2&#xd;&#xa;MktmcyQE4LCrOl2n2jVIZodENtFCCS87Hdn/AGarXVtdS36yWOmXFle+d87o37tlzyTXZTq7Wci9&#xd;&#xa;XMZGB3OK5y0067j8Dz2TQsLhlbCdzk0uqafdS+ErO1jgZp0aMsncYPNMuI73SPEDajHZyXUFxCqM&#xd;&#xa;I/vKRT9Ft7+TWtTvbu0aBbiIBAT+n1qqmhXlx4Pks2iKXCzmRUb+LnNQwWZunt4E8PtG6sPNeZzs&#xd;&#xa;XHpzWzYWM8Xi29uWhIgeBFR+xIqJtMuJvEupSmNlgntRGsnbNUtMuNU03SzpP9kyyTIGSOUEbD15&#xd;&#xa;NQjSL7/hCdPsvsz/AGiO6DuncDexz+tdwOlLRRRRRRRRRRRRRRRSVDc2yXK4ccjoRVP+yVz/AKw4&#xd;&#xa;+lWYLKKBtyjLepqzS0UUUUUUUUUUUUUUUUUUUUUUUVT1b/kFXX/XJv5V4xXsXh//AJF/Tv8Ar2j/&#xd;&#xa;APQRWjRRRRRRSUUYFGKMCjFGKMUYoxRiiijFRwW0NsrCGNUDMXbA6k9TUmKMCijFGKMUYFGBRRij&#xd;&#xa;FFGKKKMUUYoooxRiiloooooooooooooooopKKKKWiiiiiiiiiiiiiiiiiiiiiiiiqerf8gq6/wCu&#xd;&#xa;TfyrxivYvD//ACL+nf8AXtH/AOgitGiiiiiiikzUEF5BcSyxRSh3hOJAP4TViiiiiiq8l3BHcx2z&#xd;&#xa;ygTSAlU7nFT0VDdXUNnbvPcSBIkxlj0HOKlRg6KynIIyD606iimO4RWdjhVGSfSo7W5iu7dJ7eQS&#xd;&#xa;RP8AdYd6mpaKTNFLRTSQASTgCq39pWQ63cOf98VaUhlBByDyCKWiiio5ZUiUtI4RR1LHAp24Fd2R&#xd;&#xa;jGc0yOZJV3ROrr6qc1JS0VDc3EVpA887hIoxlmPaojqFqJLaPzl3XIzEP74xnj8Kshg3Q5x1xS0t&#xd;&#xa;FFFNJxyeAKA2QCCPrUD3tvHdpatKonkGVTuRVimTTRwLvldUXpljiokvrWVwkdzEzHoA4JqwKWii&#xd;&#xa;ikNIWAwCRk9KUUtFFFFFFFFFFFFFFFFFFFFFFU9W/wCQVdf9cm/lXjFexeH/APkX9O/69o//AEEV&#xd;&#xa;o0UUUUUUVyGpa1ND4xtYFiuPKVSrIo4c+o9qisNUGn67rSpazXMrzAhIhzjHWtUeK7M6S2oGOUKk&#xd;&#xa;oidCPmUmpF8RxLZy3V1bTW0SEBTIOZM9MCo7XxRDLcxw3NrcWnnHEbSrw1X7fVIrjVLjT0VhLAoZ&#xd;&#xa;ienNRprlq017G25BZf6xj0rMPjK3SA3EtldJb/wSleHqvrWoRxeIdIvCrsrQsVVRkknoK09O8SQ3&#xd;&#xa;mofYZbaa1uCMqko+8MZ/pWne3H2Szln8t5dg+4gyT9K4OPUpr/wBqK3AmeRCD5j9GHmDgfSt6PxV&#xd;&#xa;DbRWwltLlbZgqC5K4UnFaGp67Dp9wlqkMtzdOu4RRDJA9TUmk6zDqbSxhJIbiAgSQyDDLmrGo6hB&#xd;&#xa;plm91dPtjT8yfQVlQ641/FPC1hc24aB3V5BwwxWRoHiJNO8M2gFncTxwofNlQfKnJNb994itLSwt&#xd;&#xa;bpd832rHkxoPmfNRWfiaG51GCwe2nguZQx2SLjbgZqKTxXD59xBb2dzcS28hjkVF6Y75qprniNLj&#xd;&#xa;wrJd2HnBpPk3KMGJgRnPpVqx8QxQaDDc3aTB/uKrD5pD7VYsfEUdzepaXFrPaTSDMYlH3qjTxPFN&#xd;&#xa;ePbW1ncTPHJscqOF961r840+4PQ+U38jXBaF/wAI4dPtlvLOWS6bAZ/KYgkn1rqLvxFb2F4dOhtZ&#xd;&#xa;5pkjBCRr2pLjxRFDdm0WzuZbkIHMSDJGe1LdeJoop/s8FpPc3CqGkjjGdnsTUsPiK0m0qe/AdRb/&#xd;&#xa;AOsjYYZT6U/SdbGqufKtZ0h27hK4wDWd49nEWiInJ8yZRgdSM81BP4wsV014lguwwiKgtCQOmOtO&#xd;&#xa;0K/h0bwha3FzuLTH5UXlnYnoKuJ4oi+1W9rcWdzb3FxIFRHXse+afN4ljXULmxt7S4ubi3xlYxwc&#xd;&#xa;jPWn23iSzm0ibUX3RRwMUkV/vKw7fWsLxN4gN34fmgayuLZ7nasRkXhxuGf0zV2SIf8ACa6XbLyL&#xd;&#xa;OxZsemfl/wAKfZanp9lp2p6rGJzELkiTec5bIHy+3NTHxTEktt5tncxW9ywWOd1wCT04qxf6+lrf&#xd;&#xa;/Yre2mu7hV3yJEPuD3p+ka7b6vcXENvHKpt9ofeMcnt+lTX+qRafc2kMwb/Sn8tX7A+9O/tO3/tc&#xd;&#xa;6YHzOIvNI9BnGKzbzXrKew1FmWU21sRG8i8byTj5T9axtV1Q2VvpNlYJd7CyuD1Lr1x7mp7rUAvj&#xd;&#xa;NJRbTSvHajbEgy2T/Kuk0vUU1G2MqxvEysUeN+qkdqwvH8qLp1rDJnZJOu4DkkDrTdG/4R1r1W06&#xd;&#xa;xkW5RSykxkdPrWh/wlFl9h88BzJ5nlCDHz7vTFOvfEUVrOltHbT3N0VDNFEMlR70N4kt49PW5mgn&#xd;&#xa;jkZzGsDL87N6AU7TfEEV7dm0mtprS427lSUcsPaqbeL4CZvIsrqZYWKyMi8LjvVbxJ4iDaFBLYCY&#xd;&#xa;/aSNsiD7vPIPvVl7m1u7zSEuEuY7gqZEUnHTruqSfxVALh4LK1uL0xf6wwjhan/4SWyOhvqylzDG&#xd;&#xa;drrj5lbIGMfjUP8AwlMKzWwltLmKC4YJHO64Uk9Klv8AxElrfS2kNpPdSQqHm8ofcBrXt5RPAkoD&#xd;&#xa;AOoOGGCKkooooooooooooooooooqnq3/ACCrr/rk38q8Yr2Lw/8A8i/p3/XtH/6CK0aKKKKKKK5y&#xd;&#xa;/hlbxlp8yxsYlhcM4HANJoFvJHr2sySRsqySgqxH3hjtWHNY3R03UYxbyEtqUbqNvVc9a3vFdjPc&#xd;&#xa;2FrLbR+abWRZDF/eFZup3r+JTaWlnZzxlJVeSSRNojx2qaed9C8S3N3cW80lvcxKA8a7sEetVotO&#xd;&#xa;utU0/XLpYXi+2nMSMMEgVV1XWPO8JtYfYJ0mjQLJuTCpjvmtV7eSTWtBlETNGlv8zY4HFOvreZvH&#xd;&#xa;mnzrExiWNgzgcD5TXTn7v4dq4eGzuR8Ory3MEgnaQkJjn74NaXii2ll8HxQQxM8i+V8ijkYxVHXL&#xd;&#xa;P7L4ka/uorp7SaBUD25O5GHY4rQ8LW8T313ew2tzEjgIslw5LSD6VP4ysZ7zSY2tozK9vMsxjH8Q&#xd;&#xa;Gcii312PVEmt4bO4R/JcsXTAU46VU0m1lj+HrwPCyzG3lGzHJJLYrOktrmxtPDmpNbSSJZxlJogu&#xd;&#xa;WXI64q2t1JqvjDTLyGznS2iSRfNkTG47TVbRtXXStS1szW0zxtePh4k3fNk/KaSHT7o+DtZke3dJ&#xd;&#xa;L2ZpY4QOQCRjipdb06eXSdKnEUsi2pzLGnD49qNMitb3WLaS2tL5li+ZpbhyAh9AD1rU8K28kM2q&#xd;&#xa;NLEyF7klSwxkVq6uXGk3XlqWfyyAB1NYejayix2tkdKuUIAQu0eAPeptIt5G8UardyxMq/LGjEdR&#xd;&#xa;7UaJbyHxFq93LEygsERmHUe1Z9ndnw7qWope2s7m4l8yOSNC24elVJbG9k0XU7l7eRH1CZdsQHIX&#xd;&#xa;PU129nEILOGIDARAMfhWF4nglutS0iFI2aIT73IGQPrVrxQrnw/drBFvkZNoCrk1j6vaT2mn6Bcp&#xd;&#xa;A8sdi4aWNRkgYHOPzpXun1zxRpM0VnPHa24kcySJjJI/+tV7wzBIL3WbuaJkM12Qu4YJUdKwTpt5&#xd;&#xa;L4PunW3fznvzctERgsufSrWr6i/iA6bbW1hcLELpGld48Bcdv1rSt45v+Ew1S9MTbIbVY42x97uc&#xd;&#xa;fiKxRp91/wAINaWpgk825uwZF28gbjyfyFbnim2kuZdHtoY2aMXiO+0cKq//AK6pRzzaN4n1OWS0&#xd;&#xa;luIrwqY5IhuwQPun0qbwS73Mmr30kXlNPdkFfTA6frWh4rsnvNElMAzPbkTRY67lOf5Vz91o2pRQ&#xd;&#xa;2WowEnVLqRlnbsgkXH5KBVvxHpX2PwjFpljE0m6RFbaMk85LH8RU9zaytr+iRLE3k28RYtjgHGKl&#xd;&#xa;0e3kbxNq11LEyr8qIzDqB6Vf0OJ0huZHQq0tw7YPpmsfxc0iatpcgtpZ4oXMjiNc1etdeSaKeUad&#xd;&#xa;cxeSm4BkwW9hWFBYXtpq0Gu3FqG+0yEPAq5MQPQ/Wra3LaF4hv7i7tppIbvDRyxpux7UzxJHJfHT&#xd;&#xa;dTNvcfZkz5kacOue9LpMNnNdTX0NvfD7PE2ya4Y4PHQA1U0DVfsWgyxPZTvLcM7RlEyJM+/apW0u&#xd;&#xa;6g0jRrJ4mLNc+bKAMhO/NadxbTXPjHzPLYRxWpVXxxk1maDfnw5Dc2d9Y3HnNMXRo4ywk6Dr+FV5&#xd;&#xa;tKvR4akSSBlk1HUFkaIDPloT3/Kt3xTbSXMuj20MZMf2xHfaOFVayNfl3ajLcafBeW2ro4RQqEpM&#xd;&#xa;AcZPbGK7aHeYkMmN5A3Y9e9SUUUUUUUUUUUUUUUUUUVT1b/kFXX/AFyb+VeMV7F4f/5F/Tv+vaP/&#xd;&#xa;ANBFaNFFFFFFFJRRgUUYA7UYHpUNxAtxbyQklQ4wSpwRWA3hi5mjW2udVmltFIPllRlgOxNdIiKi&#xd;&#xa;KijAUYFLRRiiggHqKMUUYHoKMCjApCB2FZuk6T/Z09/J5nmfa7gzYx93PatPFGBRgelGBRijFGKM&#xd;&#xa;UYHpRgUtJijFGBRgUYowKMAdBRijFB61gXHh+5F3cTafqctqtwd0iYyN3qPStLSNMh0qwS1hyVBJ&#xd;&#xa;Zm6sx6k1dwDRgUYFGKKKMUYFGKMD0owKgvrf7TZTW6ts8xSu7HTNR6TYrp2mwWYbd5K7d2OtW6MU&#xd;&#xa;EA9RRijAowPSilooooooooooooooooooqnq3/IKuv+uTfyrxivYvD/8AyL+nf9e0f/oIrRoooooo&#xd;&#xa;ooooooopKKKWiiiiiiiiiikopaKKKKKKKKKKKKKKKKKKSjFFLRRRRRRRRRRSUUtFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFU9W/5BV1/wBcm/lXjFexeH/+Rf07/r2j/wDQRWjRRRRRRRRRRRRRRRRRRRRRRRRS&#xd;&#xa;ZprusaFnO1R1JrGvfFej2RKy3YZh/Cgyaw7v4j2iZFraSSH1c4FdJ4e1X+2dIhvSgRnLAqOxBIrT&#xd;&#xa;paKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKp6t/wAgq6/65N/K&#xd;&#xa;vGK9i8P/APIv6d/17R/+gitGiiiiiiiiiiiiiiiiiiikozVO71bT7IE3V7BEfRnGfyrFu/HmiW+R&#xd;&#xa;HLJcMO0aHH5nFYl38SZDkWenqvo0r5/Qf41iXnjbXbkEC5WBT2iQD9TzWLc395dsWubqaY/7bk1W&#xd;&#xa;pa9J+GV3v0q6ticmKXeB7MP8RXa0tFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFU9W/5BV1/wBcm/lXjFexeH/+Rf07/r2j/wDQRWjRRRRRRRRRRRRRRRSd6guL22tV&#xd;&#xa;zcXEUWP77gVj3fjPQ7XI+2CZh2hQt+vSsS7+JMC5FnYSOezSuF/QZrEu/H+sz5EPkWw/2Eyf1zWJ&#xd;&#xa;d63qd7/x8X9w49N5A/IcVRyc5zzRRSUUUV2Hw1uvK1yW3J4nhP5g5/lmvT6Wiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiqerf8gq6/65N/KvGK9i8P/wDIv6d/17R/&#xd;&#xa;+gitGiiiiiiiiiikzTJJo4VLSyJGo7swArKu/FWi2eRJqETMO0Z3n9KxLv4jWEeRaWk859Wwg/qa&#xd;&#xa;xLv4iapLkW0FvbjsSCx/Xj9Kw7zxLrN5kTahNg9kOwfpisxnZ2LOxYnuTmkopKWnxwyzHEUbuf8A&#xd;&#xa;ZGav2+gancH5LV1Hq/y1p2/gu+kAMs0UY9ssa17TwNaBQ1xcSyEdQuFFWj4N0sEgwyex8w1zniXw&#xd;&#xa;4mlRLcQMxiZtpVu1c3Wr4YuvsfiKwnJwBKFP0PH9a9qpaKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKp6t/yCrr/rk38q8YrXtfG2sWlrFbwvCI4kCLmME4HAqT/hP9&#xd;&#xa;d/56Qf8Afqj/AIT/AF3/AJ6Qf9+qP+E/13/npB/36o/4T/Xf+ekH/fqj/hP9d/56Qf8Afqj/AIT/&#xd;&#xa;AF3/AJ6Qf9+qP+E/13/npB/36o/4T/XP+ekH/fqlHj3XiOGhP/bKlTx5rznAkgz/ANcqb/wn2u/8&#xd;&#xa;9IP+/VQXfi3XbqHc18Y1/uxKE/UVl+dNeAvPJJM/953JqNIQ/wApKqfWoBw2DSEYNGKsQ2N1OcQ2&#xd;&#xa;0r/7qmr8HhnVZsf6P5f++2K07bwRdSYM06IPRFJrVtvA1onMzySfVsfyrWsvDWm2jq620ZI/vDcf&#xd;&#xa;1q61tCsmURVHsMU4RAdqlCAjpT4x1B79KWUchz9DWF4ttPtGgXQAyyDePwNeX0qMUcMOCCCK6b/h&#xd;&#xa;PtcH/LSD8YhR/wAJ/rn/AD0g/wC/VH/Cf67/AM9IP+/VH/Cf67/z0g/79Uf8J/rv/PSD/v1R/wAJ&#xd;&#xa;/rv/AD0g/wC/VH/Cf67/AM9IP+/VH/Cf67/z0g/79Uf8J/rv/PSD/v1R/wAJ/rv/AD0g/wC/VH/C&#xd;&#xa;f67/AM9IP+/VH/Cf67/z0g/79Uf8J/rv/PSD/v1R/wAJ/rv/AD0g/wC/VH/Cf67/AM9IP+/VH/Cf&#xd;&#xa;67/z0g/79Uf8J/rv/PSD/v1R/wAJ/rv/AD0g/wC/VH/Cf67/AM9IP+/VH/Cf67/z0g/79Uf8J/rv&#xd;&#xa;/PSD/v1R/wAJ/rv/AD0g/wC/VH/Cf67/AM9IP+/VH/Cf67/z0g/79Uf8J/rv/PSD/v1R/wAJ/rv/&#xd;&#xa;AD0g/wC/VH/Cf67/AM9IP+/VH/Cf67/z0g/79Uf8J/rv/PSD/v1R/wAJ/rv/AD0g/wC/VH/Cf67/&#xd;&#xa;AM9IP+/VH/Cf67/z0g/79Uf8J/rv/PSD/v1R/wAJ/rv/AD0g/wC/VH/Cf67/AM9IP+/VH/Cf67/z&#xd;&#xa;0g/79Uf8J/rv/PSD/v1R/wAJ/rv/AD0g/wC/VH/Cf67/AM9IP+/VH/Cf67/z0g/79Uf8J/rv/PSD&#xd;&#xa;/v1R/wAJ/rv/AD0g/wC/VH/Cf67/AM9IP+/VH/Cf67/z0g/79Uf8J/rv/PSD/v1R/wAJ/rv/AD0g&#xd;&#xa;/wC/VH/Cf67/AM9IP+/VH/Cf67/z0g/79Uf8J/rv/PSD/v1R/wAJ/rv/AD0g/wC/VH/Cf67/AM9I&#xd;&#xa;P+/VH/Cf67/z0g/79Uf8J/rv/PSD/v1R/wAJ/rv/AD0g/wC/VH/Cf67/AM9IP+/VH/Cf67/z0g/7&#xd;&#xa;9Uf8J/rv/PSD/v1R/wAJ/rv/AD0g/wC/VH/Cf67/AM9IP+/VH/Cf67/z0g/79Uf8J/rv/PSD/v1T&#xd;&#xa;JvHOtTwvFI8JRxtOI+1YX2o/88k/X/Gq9FFFLikp8ab5AucZqWSGOGcKz7l7kU1fLWbIUsnpU0by&#xd;&#xa;oj7I8Drz2qGKQ+eGPc0k6BJGAIPPSpII2lRkVCx68A1d0zSL+6YiK0mYeu3A/WtiDwXqMjZcRRDP&#xd;&#xa;Vmyf0q0ngEJIDPe7ge0aY/nWqng3SIgrGJ5SOu5/8K0bfSbCCDy0tokweMKM/nVpYYUGAuaf8q/d&#xd;&#xa;QCjce3FJye9SAgKOORTSMkn3oxwKcooHysD6VIwDIR+NVLpBPbSRsOJEZT+IrxuWNopXjb7yMVP4&#xd;&#xa;U2kooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo707JptFPiUM+&#xd;&#xa;1jjNaOjxRNJIJQuV6ZFN1aKNZA8Z+oqhtBi3DqDzTRV6K2adoTFEzk9cc1tRaFfToRBZyDBzllx/&#xd;&#xa;OrsXhLUp5B5zRRJjHJyf0qaL4foh3XF6zc9I0x/OtqPwnpMeHaASN6u2a1LaxtrcAQwIn+6oFPVB&#xd;&#xa;HKcDANWMUyRcrmmgfIQeKjZcjIBpADSgUuOaU+wpMUoHPtSgdRSUHmnZJApnlZ3bjjvXlXii1W11&#xd;&#xa;66RQQrHzFz78/wA81j0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUd6WkpcVJBHI8iiONmOf4RmtiHQNVe8JjtZFDc5b5R+tatt4JvJ95urmJNw425NaFr4DtYom+&#xd;&#xa;1XMshI/hAUf1q7aeFNJhcZtRJ7yEmt62tbe2QJbwxxqOyqBVgDmjaT3ppGCfelH3KPqabKOhpBIS&#xd;&#xa;eeBTyy560MM1GFOCPypAtLspdvNKEODTdtLs9qUjBFBXkgUoWnhQDimvxhvwNcF44t4k1m1lmACN&#xd;&#xa;Gy59SOmfzrmJzb+SMoofBzt9aoUlFS20DXNxHCmN8jBRnpWnrfhy90JYmvDERISB5bE/0q7H4I1a&#xd;&#xa;WwW7j8hkZN4UOdxH5VzpQhypGCDgg+tbt94Q1Kx0w38zQeSFDYVyTg/hVi28B6tdW0c8b22yRQwy&#xd;&#xa;5zj8qkPw91gAnfa8f9ND/hVHS/CWoaqkzWzQAROUbexHP5VePw91kDJe1/7+H/CsnSvD93q19PaW&#xd;&#xa;zRCSAEtvYgcHHpWsfh7rIH3rUn08w8/pWBqel3elXHkXsJjfGRyCCPUEVrad4L1TUbCK8gMAjlBI&#xd;&#xa;DOQfTpisOK2klu1tVX96ziMD3zitrVfB+paTYPeXJgMSEA7HJPJx6VW0Pw5e66sxszEBDgN5jEdc&#xd;&#xa;47e1av8AwrzWf79r/wB/D/hWXZeG72+1a502FohPb53lmOODj0rTb4e60BkNan2Eh/wrE1XRNQ0h&#xd;&#xa;wt9btGD0YHKn8RUuheH7zXjMLNogYcFvMYjr+HtVXVtNn0m/ks7koZYwCdhyOQD/AFq5ofhu+11J&#xd;&#xa;HtPLVYzgmQkc/lRrfhy+0MRm88siToY2JGfyq7p/gjVNRsYbuB7cRyruXc5Bx+VWP+Feaz/ftf8A&#xd;&#xa;v4f8KoaX4T1DVDcC3aDMD+W+9yOfyq9/wr3Wf79r+Eh/wrmLmFra4khcgtGxU49aiooooooooooo&#xd;&#xa;oooooooooooooooooo70tdrb+FtKjOZp5pvUDgfpWrDpWkW6jytPRj6uM/zq9DGqcRwpH3+UYqa8&#xd;&#xa;nlWNZVVcL1yOtPW6dotyL1FCTyeUWfB4xUC6kQfmi/KrtvfJIdrKQcVaimjdchunY1KCCeopr9BS&#xd;&#xa;J3HWlwc8YoZcjBNNEY9aULyKfikYcim7cZp22jZg5p2KMAUhI7GmScEHtQT82exFOHQUOdo3ehwa&#xd;&#xa;HG7cB6ZFcj4/tvP0SO4AyYXGfYHivOljZz8q7selDxun31K/Wm0lXdH/AOQtaf8AXVf5123xQ/1N&#xd;&#xa;j/vNXTafcx2fh21nl4RYlyfSuP8AHfh4RyjVrJR5UhBlVex/vfSug8UY/wCEIY9f3SfyFYPgvxHq&#xd;&#xa;d5qsGnzTK1ssZAXywDwOOa0fHWv6jo9zbR2UqosiEsCgbv70/wCHDtLpd3I/3mmyeO9Q6hF40+1X&#xd;&#xa;D286C2ySgPl8L+IrO+G5dtevzKcuYTuPvuGa2L/UNcj8bx2toJXsSU3rsygBHzHOOO/eq3xO8k2F&#xd;&#xa;lkjzvNOPXbjn9cV02krHYaLp0Mh2ny0QZ/vEdPzrkrTQ9vxJmO39zGDdD8en/jx/Sul8SKl/4X1E&#xd;&#xa;RfMBG5/FDk/qtc58Lv8AVal/vR/+zVe1aHxi2p3B02VFtC37sEp0wPUZ61k+Amnk8Wag122648t/&#xd;&#xa;MPHLbxnpVrxl4l1TRtdWGzmVYfKVtjICCcnPv2resJoPFfhgNcRKPOVlZeoVxxkfzrnfhkhjutUj&#xd;&#xa;bquxT+bVhePP+Rsu/wDdT/0EV1+kJ/wj3gdrlvllZDJ+J6Umtp/wkHghLpfmkVBJ+I61h+CfEGoy&#xd;&#xa;ajaaW0q/ZVUgJsGfzxmtrx1r2oaNJaixlVBIDu3IG/nTPhxK89nfSyHLvNuOOOcUmoxeNPt07Wcy&#xd;&#xa;C23Ex8x9PxGa85uWla5lac5lLHeffvUVFFFFFFFFFFFFFFFFFFFFFFFFFFFFHelr0OTVoU3qo4IG&#xd;&#xa;Oc1W/tJ/MO1S2D0Ap8mvTLIuYWXOVxiqN7rV7AoLK21jjBqKLxPchdiopAHFXbPxM8cJ8y2aT1ZR&#xd;&#xa;xTF8SwuwDLszWjbaxbK6s8gGPetKK/gLFlZmDdgKtpOSAVO3P941Os7bcsylfYVOskbjI4zUm3uo&#xd;&#xa;NMJPX3qQDrTsUUj/AHc+lKASAc9adimnhvajn1pDjqTS44pjKSCueRyKQfMgNOHcHuKU8g57jmkU&#xd;&#xa;/u1PcHBrN1y0F3pV5a/34iV+teXWV3DbxorqyujE5Cg5+tE9zBckokbFj0Yn+lZpBBINJV3Rv+Qv&#xd;&#xa;af8AXVf5123xQ/1Nj/vNWxej/igmx/z6isnwTrianZNot+QzBCELfxr6fUVseMYxD4RuIx0VVUVw&#xd;&#xa;/gD/AJGiH/cb+VanxPA+22X/AFzP861Php/yB7jn/lr/AEpuoSeNDdTrbxRm2JITOzO3+dZnw3Dr&#xd;&#xa;r1+JB84iO4e+4V2kGrRy67d6W+FlhVZE5++pAz+R/nXnnirT78eKI4b2V51nkAhduhUkcccDHeur&#xd;&#xa;8e3p0/TbFo8hlukcf8BBNbdxNbQWk2sALkW27d6qAWA/WsbwVMdR8KSRyHczSSo3/Ajn/wBmrN+G&#xd;&#xa;KGMaoh6q0YP4bqu6tL4xXU5xp0UZtA37snZkjHuc1keAknj8W6gl2MXAjfzBkfe3jPT3qz4x8N6n&#xd;&#xa;rGvJPZwK0XlKpdnAAOT+Nb2nww+FfC4FxID5Cs7n+855wP5Vz3wycyXequ3VthP4lqqa3prat8RX&#xd;&#xa;tR90hGY+gCA/5+tdhr0OlXFiljqN4LaI4IHmBCQPrS6FBpUGnvYadeLcwjJI8wORn6VxHhy0+w+P&#xd;&#xa;Wtc/6p3FXvih/rrH/darfwx/5Bt3/wBdR/KpdRk8Z/bZ1s4ojbbj5eRH0/E15vcrItzKswxIGO4e&#xd;&#xa;+eaiopaKKKDRR+FFJS0UlL9aKKKKKMUUUUUlFFFHelr1KHS7dI/kjUfUUrwxKdowrH+6Kry2yyJv&#xd;&#xa;2jjoO9Yupwz3H7kRE45J7fnVm1tbWC2XzYkEi85oLRRpNsHy91RafFoFoyxsqM2RyGqvqegxB4ZL&#xd;&#xa;cCMq2W681rxxlFVlOOOlR3dx5UkRZWJJwPSp4dQkJGQqjODWjBcoyjcw4NTpeqAdpLD0qWOdJeOj&#xd;&#xa;HtVlTlQc0/NJR1Ug0RH5cdxTs0jdOtN64OaXj8OtNJPPNIMhs0IMMy9j0p2OnqKD39ulIBtkZezD&#xd;&#xa;IqOXACuf4Tg15FrVqlnqt5bqhPlykjnt+FUfM2NlQqjqMClu1/eBx0cZqvV7RBnWbPI/5ar/ADr2&#xd;&#xa;TUNKsdTCC+t1mCfd3ZGPyqR7K2ey+xvEpt9u3y+cY9K4nxrpdjodpaXemW628wl4dSc/rXYRRRar&#xd;&#xa;o8K3sayrNGpdegJxXltxet4e8U3UunxRr5TsqK2SAPzroPD94PGGquNYtYJVgi+QICByfrW1r0ye&#xd;&#xa;E9FMukW0Me6QZVgSP50ng3xBea8tz9sWFfLxgRqR/M1F4k8jwrZ/2lpVpClxNKI3ZsnIIJ9fUCq3&#xd;&#xa;gqYa9qd9qt9Cn2uMxhGTICjaR0z7Vv8AiOwlu7FJbRI2u7SQTwhxnJHb8a8y1/xHfa4sUV8kUfks&#xd;&#xa;cBFIOffJrv8AwkF1XwdBDfIJIsGMqeMqp4/kKwNb1qbwlq81hpNvbpbuFl2MpOCRz39q6/w9aW0W&#xd;&#xa;nRXcMCRS3kaSTFc/MxGfX3NcnrHjTVrTXLiwtYbdwkvloChLH9a6fQdFWx331yiHUbol53XIALHO&#xd;&#xa;0D0Fc/4o8by2V+bTS/KcR8SSOu4Z9BzXSjT7TW9Ns5dSgWdjEr4JIGSATwDXn02sTeF/EGqQ6ZFC&#xd;&#xa;sbSBdrgnAHTHPvXpVvY2oujqAgUXUqAPIM5IwP8ACuE+JFhdi9ivWO62K7Bj+E+9YXhTVLjTNYi+&#xd;&#xa;zhSJ2EbhhnjNeia5aWel211rNtaxfbkG7zGycn3Ga871XWdQ8T3NvHLFGZFO1FiUjOfqa9E8I6FJ&#xd;&#xa;oWnsk0m+WU7mAHC8dPet+uV17wRYagJJrMG2uj82QSVY+4/wrzO9tJrG7ktrhCkkZwQar1YsEWS/&#xd;&#xa;gjcblaRQQe4zXrUvhPQlhcjTogQp5y3+NeYaXbxTeIYLeRA0TTbSp6YzXqR8JaDg/wDEtj/At/jX&#xd;&#xa;mnijQpND1NosFreT5oX9R6fUU/wbZ29/4jgt7qISxMrEqe+FJFdf4u8O6TY+G7u5tbGOKZNu1gTx&#xd;&#xa;lgPX0NeaUlLXsFt4U0NraJm06MkoCTlvT615TqsaQ6reRRqFRJ3VQOwDECtvwLo0OratIbqISW0E&#xd;&#xa;eWU55J4A/mfwrvh4U0AtgadFkDOMn/GvNfFmlrpOvT28S7IWw8Y/2T/gc10/gjTtG1jSWF1YxPcw&#xd;&#xa;NtcknLA8g9fqPwrM8f6Pa6Xc2psbZYYnQ7tucE5965mxtmvL2G3jGWkcLXrH/CKaDb226WwiPlrl&#xd;&#xa;mLN2HXrXlOoSQzahO9tEI4S52IOwr0nQPCeljRbeS/s0kmZN7sxIxn8aj8S+FNMXQp5bCzSKaMbw&#xd;&#xa;yk8gde9eY0lFFFHelr1aGXMjRZOV6j1qZgCAcDIqMrktg4NQTRZhZDzkYOKzo47chCkbPuBAJ9qn&#xd;&#xa;tmLfKI1TKZ59ans3kW3AuSqyHuo4NPmKXMflqzAno2KdHlVVAA2BwWpJo2ZSXwOMj0BrPvrRhFKw&#xd;&#xa;7gMNp6Umns7RKwJZDyFPBrXguAVw64OOBUlnKsyZLAMpxwKv2kjBnjf+E8VcAyM0uKAOaavyuafS&#xd;&#xa;EZWmgcEelAxgUfh3xSkY98Uj/Kyt+Bp2OSSeD2pGwFz3FMB4GeooZdwYdm61wHjTTEGrC4ctiSId&#xd;&#xa;XCjI471l2f2aMYBtwoHZwTn15FVtYkt54VMLhmjOGx0rHp0cjxurxsVZTkEHBFdr4A1K+vNceO5u&#xd;&#xa;55k8ona8hIrp/G1xNa+HJZbeV4pAy4ZGwf0ryq51K+vFCXV3PMoOQJJCwH517To//IItP+uS/wAq&#xd;&#xa;8/1vwfrd5rF1cQW6NFJIWUmVRx9M1reCPDupaPqE8t9AqI0eAQ4bnPtVr4j/APIuj/rqtZvwv+5f&#xd;&#xa;fVa0PiX/AMi/D/18L/6C1Ufhb/qNS/3o/wCTV2Ul5HHqEVm5IeZGaP324yP1FcL4/wDDnlSHVrNP&#xd;&#xa;3bn9+o/hP976etb/AMP/APkVYP8Aff8A9CNcb8RP+Rof/rkn8q9I0H/kA6f/ANe0f/oIrC0jw/v8&#xd;&#xa;T6hq90mAJ2FurDqe7f4U/wAbeIxpNn9ltXH2yZeD/wA819fr6V5USSSSSST1Ne5aP/yBrH/r3j/9&#xd;&#xa;BFeSeLP+Rn1D/rsa9ihyLePHXYKpEWuu6bLE6ho2LRuP7pFeYvpM2i+Kbe1mBwJlKP2Zc9a9G8X/&#xd;&#xa;APIsX3/XOuR+Gtgk15cXrqCYQFTPYmuk8ba3Lo+mKLYhZ5jtVv7o7mvNrSPWNQlae1F3PIpyXj3M&#xd;&#xa;QfrXT/2v4y/s9bVbC4DgYM5hJcj+VctqVjqkLfaNSguUZz9+ZTkn6mqFWdM/5Cdr/wBdV/nXuM//&#xd;&#xa;AB7yf7h/lXjei/8AI0W3/Xx/WvY7mbyLaWbbu8tC2PXArM1bTrXxLoiqCMSoJIZP7pIyD/jXBeDb&#xd;&#xa;Sax8bxWtyuyWISKy/wDATXbeOf8AkUr3/gH/AKGteP0UV71af8ekP/XNf5V4lrX/ACGr/wD6+JP/&#xd;&#xa;AEI16T8PtO+x6ALhhiS6cuf90cAf59aisdcE3j+8s937pohCnP8AEmSf5t+VVfiZp/mWVtqCDmJv&#xd;&#xa;Lf6HkfqP1rlvB+rnSdaQsf3M2I5PpnrXe+ONO/tDw9I6DMkH7xceneuT+HWnfadYe7Zfkt14P+0a&#xd;&#xa;6jx7qn2HRDbo2Jbk7R9O9eeeHbA6lrdrbY4Lhm+g5Neo+K7wad4cuXT5SV2J9TT/AA7dLqnh63du&#xd;&#xa;d0exwfUcGvJtbsm0/V7m2Ixsc4+naqFFFFHelr1BTIt0G2fuyvL981ZaRQCWYYHJxzikR0kVJEOV&#xd;&#xa;YZFVGuHlaWOCM5icK2agZJY2+4dqvkEelCSFJW4XiQfgDU9uWe6eFs/uzuBx1q4Ih/dAPvTlQ46j&#xd;&#xa;8KR18yFgODjFQRKzW6B+udp7VNFbIQjEAMuRxSeUEkxtJHrTLeJo5pdsg2HlQPWrMd2YryEOPllX&#xd;&#xa;APvWrG+OD0zU1FNccg06lqPhZCPWkAwStOPJ+ooQgqM96JDuQjqetM3bkVvTrSOctz0apNo9Khcf&#xd;&#xa;OeTjtzXKeObcTWcMh6kkAnsce9cFw21n5yNp4JxUq21x5TfuHClOSVx+NUaSuu+G3/Iff/rka63x&#xd;&#xa;9/yK83++v868kr3PR/8AkEWn/XJf5VzOpfECPT9QntDpzSGJtu7zcZ/DFXvDfixNfu5IFs2gKLuy&#xd;&#xa;ZN2f0FV/iP8A8i6P+uq1m/C/7l99VrQ+Jf8AyL8P/Xyv/oLVR+Fv+o1L/ej/AJNUvxGuprK50m6t&#xd;&#xa;32SxO7Kf++a6HRdTtvEWjiXarBhsmiPODjkH2pfD2nNpVhJZfwRzOYz6qTkfzrz34if8jQ//AFxT&#xd;&#xa;+Vej6DzoGn/9e0f/AKCKj03WIb6/vrI4We1kKlc/eXswrl/iB4daUnV7QMzKMTpnsOjD6d6899a9&#xd;&#xa;z0f/AJA1j/17x/8AoIryPxZ/yM+of9djXscH/HvH/uj+Vec6R4hOkeKbyCdj9knmIb/ZOetdlrml&#xd;&#xa;JqcFvNGFM0EiyI3qM8im+L/+RYvf+udc38MLhdl7b5G/IcD26VL8Tbd3s7S4UZRGKt7ZrH8E+IbH&#xd;&#xa;RI7lb0yAyMCuxM13mja9Za2JDZeYVj+8XTFcz8TplFrZQcbi5b8MV55VnTP+Qna/9dV/nXuM/wDx&#xd;&#xa;7yf7h/lXjei/8jRbf9fH9a9hvf8Ajyn/AOubfyrgfh/4j8lxpN23yOf3DHsf7v41117pKvr9hqkS&#xd;&#xa;ASRFo5cD7ylSAfwP86r+Of8AkUr3/gH/AKGteP0tFe82g/0SH/cX+VeNXdq194pntY/vTXjIPbL1&#xd;&#xa;7HHD9ms0ggUDy4wqAnjgcVwFj4O1611mHUGktjIs3mtiQ5PPPb3NdxrViNT0i5s26yxkD2PUfqK8&#xd;&#xa;RIaOQggqynBHoa9e8LX66z4dQSHc6r5Ug/CneFtI/sixljZcO8rMfp2rz3xtqh1LXZFU5ig/dr/U&#xd;&#xa;1u/DPTsvc37DgDy0/rW54z0bUdbt4LeyMIjRtz+YxGT27U7wdpGoaLZTW18Yipfcnltn69q5v4la&#xd;&#xa;d5d5BfovEo2N9R0riKSiijvS16XJvijMsbMMdUbkGp0dSd4XlgOR6VICoQADAHpTiFXJwBnrjvTJ&#xd;&#xa;WwAwPGRWNJuXUL2I5AZVkU1tR8bCMHIzuqRWAJHNOjYBtoGM85pQ4Ukk57jFRww7BJtzh/nAParS&#xd;&#xa;Dbn65pWHJzmq5tXBDx8bWJweMioJN3kqJk2SRvuUA5yK00kJfb2YZFXY23Ac81J1pGGVoQ5X3pcZ&#xd;&#xa;pjrjBFI3BBFL0/A5oPAPsaFUhuOlNVfvx/iKQHKnPbkUp4Le3IpCueAe+RWZr9mLnTJdqlmjIkX5&#xd;&#xa;sYI/ya4hNO2yiQCJOeoBc/rVpINq7ZJy+c845OfWsA+HdXZi0em3TIT8pEZwRSf8I5rX/QLu/wDv&#xd;&#xa;0a6fwFpOoWOtPLd2U8CeWRudCBmul8a20954elhtYnmkLKQqDJrzT/hHNZ/6Bd1/37Nev6WjR6Zb&#xd;&#xa;I6lWWNQVIwQcV5hr+hatca5eSw6dcyRvISrLGSCK2/h9pd/YalcNeWc0CtHgGRCM81tePLO5vtDE&#xd;&#xa;NrBJNJ5gO1FycVn/AA8068sFvBeWssBcjb5ikZq74/s7m+0SKK0gknkE6ttRcnGD/jVT4dafeafF&#xd;&#xa;fi8tpYC5QqJFIzjNN+Imn3moLYfY7WWfYX3eWucZx/hWF4Yh17QtSWX+y7s28mFmQRHkev1FeooQ&#xd;&#xa;ygjOCO4xXm/jrR9RvfETzWtjPNF5SjciEjNd5o0bw6NYxSqVdIEVlIwQQozXn9/aa5Z+L7nUrCwu&#xd;&#xa;HAmJUrGSrr3H0r0W1l+12ccjwvH5ifNFKuGHqCK828UeDrq11EyaZbST20vzBY1J8s+h9q9H0tHj&#xd;&#xa;0qzjkUo6wopU9QQo4rzHxJoWq3PiC+mh0+4eN5SVZUJBH1r1WEEQRggghRkH6V5JrGg6vLq11LFp&#xd;&#xa;1y6NISGEZINdp4KudTS1+wanZ3EflD93JIhAI9M1qeKIJbnw9eQwI0kjphVUZJrzvQbLXtG1OO7T&#xd;&#xa;SrsheHXyj8y969PaODVNP2XMDeXKvzRyqVYf4VzbfDvSmm3Ce5VM52Bh/PFdDY2NppFiYbOHbGgz&#xd;&#xa;hRuZj/U15z4lttc1zVXuP7Ku1iX5Y1MR4FZH/COa1/0C7v8A79GrGn+H9Xj1C3d9NulVZFJJjIAG&#xd;&#xa;a9flBMLgAklTx+FeV6VoeqxeIYJn065WIT7i5jOAM16ldqWtJlUEsY2AA78V44vh7W1YFdMuwQcg&#xd;&#xa;iM5FeoeGb2+u9NC6nazQXUXysZFxv9CKb4wt5rvwzdw28TSysF2qgyThgf6V5f8A8I5rX/QLu/8A&#xd;&#xa;v0ansvDGqTXcUVzY3cETuA0nkk7R64r0OfwbpE1rawGJo1tjkMjYL567vXOK3JpPIt3kCM2xSQqj&#xd;&#xa;JOOwrgvB+iXreJJtS1C0lgC7pFEiFcsx/wDrmut1/UL7T7NJNOsmvJmfG0AkKMHk4rnv+Em8T/8A&#xd;&#xa;QuuB/wBc3rp9Gu7m90yOe8tWtrg5DxMCMEH39a878VeGdQGv3MljZTTQSnzFaNCQCeo/PNbvw+tr&#xd;&#xa;/T/tVteWU8KuQ6u6EDPTFdPrc9xb6VcPawyTTlSEVBk5NeSN4e1t3LNpl2STkkxGvVPDOn/2Zodv&#xd;&#xa;bldsm3c4I7msjUPEPiCG+ljtNBeWFWwjlG+YetLpniDXri/hhvdDeCBzhpAjfL781peLNNOq6FPD&#xd;&#xa;GpaVfnQAZJI7V5efDmtdtLu/+/RpP+Ec1r/oF3f/AH6NH/COa1/0C7v/AL9Gj/hHNa/6Bd3/AN+j&#xd;&#xa;SP4f1iNC76bdKqjJJjOBVLyZf+eD/wDfJr0hxviZQ2Nw60y0mV7RSHzt+Un6VYyGTg06J98an1H6&#xd;&#xa;0EN5RDc8dqz72VVubMlflmyN34dKfBcGKE+eCqxNtDDn9KuLcqYw4O5ScEgYIp0JPGF5RiDn0p7C&#xd;&#xa;USKyBSgzkDrSRTDMSyFkckrtbrirEOWG0+hXNLLuPlOPxqZGViz8ncOmM1Uu1E6kKMAoQhzUOnXD&#xd;&#xa;S2cZk4aJtre9a8EgIIXko36VcU8fQ0o7imx8MQaf3pGGVNRjmMeo60oPTPpg0noe4p28YJwaYxw6&#xd;&#xa;uKQ8SH0pAcYJ7cGlUgEA9Rxmhl8xHQ+6/mK4S8ZLV2SUncOAApJqlJfbekLKD3kYJn+td34XvBe6&#xd;&#xa;LC+UJXKHacgYrYoxRijFGBRRRijAoxRgelFGBRRRgUYoxRijFGKMUUYBoowKMUUYBooowKMCjFGK&#xd;&#xa;MUYoowPSiijFGKMUYoooxRijAoxRRiijFGKMUYqpq3/IKuv+uTfyrxby19K7uO4PmxAhQkgPB65F&#xd;&#xa;V9JZEmurZW3FJCxG3pmtMdMUsa7EC+lPY5wCeCcVBNDbyThZIyzxruHYD6UyS2RbdvKDDf8AMQzZ&#xd;&#xa;OfxqWJdyyAfxKGHNXEAZVPtSxncMHqDjNOYAKSwBx13Cq093Fpsfm4byzgnkYH4mpo7jzfuqoQnc&#xd;&#xa;pLZqZAOFbLZzjA4AokEcSoihvYZ6VGsW15Ake3IzwOpqSzkZbpS42iVMfiK1eoB7kU5GBI96GOGB&#xd;&#xa;9aCwzSb+cDpSLw7L2NN7Ed6U8n+VIec+9IeYyPTmh+UU+nBpDySPUUnX8R+tOByyt/eFcJ4itZIt&#xd;&#xa;ZvkVirzRiRGHXHcCub0uGC5kbzYw0iLwrNw59816H4KfZbTW/liPB3bQu3FdPS0UUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVT1b/kFXX/AFyb+VeMV3AykUbRx79zdx9z&#xd;&#xa;PWoIrWWLUJ7vzUQSjaFK8n0qxFcyC8FrMuWCbjIowDz6VcBpJFLIVBwRyDTjISEIBHz7W4yRTChW&#xd;&#xa;VHLsxJ2sScDH0ot2j83YrAtECGB7CrNu+UHHT0oZpA8ixgbiuVzUsW8IPNwDjnFVryC3njCTguDn&#xd;&#xa;5e596bBcxRsDDGdxXHX09qsJNJIqnJXnkdOKFDx3JmCsYiOh7VcEnmbCFIU0yZSsTH+KJtw+lX4H&#xd;&#xa;Dwhh9aWQ7VYr25FPch0DDp1pSc4Prwaae3tStwVYfSkbh89qToBjtR0x7GlT75HakUcMhpBjH0Oa&#xd;&#xa;Q8AgdjkUucqwHY5Fcx4zQobK/QYCNsb6GuHuLcLfzQgAhxuU45/AnpW94EuRBrqKXGJ4ypG/JBHt&#xd;&#xa;XpgpaKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKp6t/wAgq6/65N/K&#xd;&#xa;vGK7CR23SmMsDIism0c5/E02c3SLPILWQjAdQz5+YewonuJBcWVzGEEMoAkY9Rk8fzrWFKhZs5Uj&#xd;&#xa;B6e1Qy7ws67gvR1Ppj/9VRmSE+Z8zsGAkGMn8qRJoU1MBEw867i2f6VoK7DrEQAccUFh5kbqcjO0&#xd;&#xa;+1SOmxDsO9x0DHAqqysX8y4aBGPopcj+lNiliZtqvOccjAwv5CrNsWj8xWAVj91gOauQq4H7yQE4&#xd;&#xa;wRknJqOOWVoyCuxlPHuKlkbLAsRh0Ix70ulXAki2emVP1q+M5XPQ8GiH/VFD1XilXlCO4pSOtGMp&#xd;&#xa;j8aG5UH060n9aTrjPekOcCnE7XDDvTWXDkdiKMEYP50owrDH41m+IbZbnSZ4yOgyK821Bme2guQB&#xd;&#xa;5kR2NkZrT8OXEMU9rNE0QkMmZs4DfhntXqSkEAjpS0UUUUUUUUUUUUUUUUUUUUUUUUlFLRRRSUUt&#xd;&#xa;FFJRS0UUUUUUUUUUUUUUUUUVT1b/AJBV1/1yb+VeMV3MUSLO37oK6gYdfSnOkkcBEX7yTHy7j3rM&#xd;&#xa;htZbnS4IDIscsUmGHXoTx9avXV5Pap5jxIsajBYtk5x6fWi3W6dBJLOh3lXQrxheOKtSyKJoo3H+&#xd;&#xa;s3KD61mQSwK6IsLMVJhO7np9eKk+0XO2Dy4QvzbGXjOK0TfW6sd1yqAEAL3U1HPJtadQf7sq4qdp&#xd;&#xa;4vM+6zFlDHJ4FQm7aZQ0UbHqPmxgEVUY3bXK+awX72Oe3FWG1K2tLogzNcTbR+7iBkP6dKmTV+c/&#xd;&#xa;2bqCrnOfKzj8M5qayv7e6mdEnzJg5R1Kv/3yaSSVWhV3Y4gcNx1rRstqTShMYJDitL19+aRTiQn+&#xd;&#xa;9Thw5HrSdMe1C8HFAHVTSdj7Udjjsc0h6n8xQeYyB2ob5lB9KQ8596QjPPc/zqK6USwN/tKQa81u&#xd;&#xa;rfF3dWp6TDcv1rKUbRGXdC0Rxgkt+gr2XS5xcaZbSg53RjtirdLSZrIk8R6fFrK6W0v78jr/AAg+&#xd;&#xa;mfWtcdKrajfQ6bZSXVw2I4xk46mueh1DxTqUf2qytbK3t25jScncw9eOlbulXF7cWm7ULYW84Yqy&#xd;&#xa;q2QfcVczS80Umc0Z/SjNLnFUdObUmkuRqCQogkPkGI9U96u57E1RvtVjstRsrJ0cveFgjDouAOv5&#xd;&#xa;1ezR+NGfU0ZoznoaM/jRmsXWdRubXV9LggkAjuJCsg2g5GKu2j6kb65F1HCtsCPIKE7j9aug1Q1L&#xd;&#xa;VY9OmtY5I3Y3MnlqVxwfetCjNMlYrE7DqFJrJ8LX9xqOlefdSB5PNdcgAcA8dK2AfejJxRmlrE8M&#xd;&#xa;ajdah/aX2pw/kXjxR4UDCjoK2WJCEjsM1k+F9Wn1nR1u7hESQuy4QHHH1rXB+lLmkz70A5pc1Q0f&#xd;&#xa;VI9WtXnhRkVJWiIbuR3q9n3o/GmTGTyHMO0ybTt3dM1BprXrWSHUViW5/iEXSrWTS5opaKKKp6t/&#xd;&#xa;yCrr/rk38q8YruWO28TnhlI/Hr/jVNL1GeX7JDJNIG+bccAGqqQXEjSi4RS5l81Az4UnGOgq0CY7&#xd;&#xa;O7VISpQeYA2cE+1LoscU9mtwGcsxIKl8jr09qknvowBcPgQxkiI93fp+VUo3uriSZEfLrKG+RcAc&#xd;&#xa;+tXhbTEurHyo94YOTuLGormKSGQKZEkjmbguB8p/nVojfJbNnKuhiJqSBI3toPMi3uh2ZGflxUt6&#xd;&#xa;fIth5KKHzjaeOPXNZFvbzajevAQI4oz+8miJyf8AZzXQ29tBZQiK2jWNR/d7/WpVOWpt1ZwXke24&#xd;&#xa;j346N/Ep9QaybW3ltNQmtbhmkSZSY3b+If41u6WMxRuf7uw/hWopwFP4GmkgFec7WwakfsaG6n3F&#xd;&#xa;IfWlJ+fPrSEYY89aBijB44oVcZzjBpq/dYUn07Uh4HHY5oIyrD2zXnviCMw3nnAf6qTn6GueuYxH&#xd;&#xa;eyxjhX5HXH6V6X4DufP8OxofvRMUx6V0lLWZ4gF+dJm/sw4uMcHvjvj3rmYiy2iCdoD4j8o+WzL8&#xd;&#xa;wHvzjd710Hhf+0/7IT+1mJnzxu+9j3qn47R20IMoJVJVZ/8AdzW5YyxzWUMkTBkKDBXp0rE8W300&#xd;&#xa;Vpb29rN5RuphE0q9VHf6Vm63pY8NWEep6bd3ImikUOskpZZQTggirFxqD6Drd1NM7G0vLY3EauxI&#xd;&#xa;EijlR9f61m3r6hZaHp0Ly3BuNUnMk5Vjvxwdq+nUVPp0N3Z63Zmxsr23gkJS4SeUurDj5ue9S6Np&#xd;&#xa;q6tq2rSXtxcultekRRiUhRzn+gqqkcdlrUsmvC7SU3O6G7WVgpXspHQCu87VxMVxN/ZHitjLJmO4&#xd;&#xa;kCHeflA7D0qHUdL8jwhDrIvLo36wxyCUynjOOMdO9S65p0d5r2hSSTThrwHzNshG3CL930qG9mm1&#xd;&#xa;TxDfxXNteXVtaERxwwSlAvqzY5J70pl1G38JazFObiNYnX7O0smXClhkE+39au3umrp3hS4v457h&#xd;&#xa;7uaCMvI8pJyWXP061n6jp72/hyz1ZLy6N8Sg8wyk8HtjpVzULI6Vqej3Vvc3BluZQsxeQsH49OlV&#xd;&#xa;bqOW/v76aW11CdllKRNFOVWLHoKdPdanNpOladdyywvczmOSTOHKDpzU19pMWl+I9FSCeZomlPyS&#xd;&#xa;vuwcdRmpvt9xa3niOVHYmEAxgnIXjtVObSDF4UfVVv7sXjxeY7+ccHPbFJrVgtzHoM0s0+6crG2J&#xd;&#xa;Dxx1HvS6nJNd6/LYPDd3VraRqFihlKk+7EcmtHw3Ne2Qv0nhuRaxDdCkzbnH+zmtCw11dT86IWk8&#xd;&#xa;JWMnMikD+VcvHfXFj4MVbVmV5rtoyV+9gnnFK1vd2b28+l2OoQ3CyKWaWYssg7gg8Vpz6hJ4d1TV&#xd;&#xa;EkdjBPAbm2DsTh+hUfiRWff/AG2w03SNNeS4eW+dpLrY+HbodoPbrVnR4ryy1+1FnaXlvZyBlnjn&#xd;&#xa;lLr04YZ71oeCxgax/wBhCT+ldJIQI25/hNec2V3cW3ga1htpWia6vjAZFOCoJ5+nStHWdJXQ59JN&#xd;&#xa;jd3QWW8jSSN5SQ5z1qxcahJ4d1TVUkd3guITc229ifn6FR+JqnPbXcVvomjz3U6Nfu0l1IH+Yng7&#xd;&#xa;QewqxLYf2R4u0a2tbq4NtIJCYnlLBcD+XT8q6y7t1u7WS3dnVJBtLI2CPoa4XQmOk+F9S1G3eRpx&#xd;&#xa;K8ahmyox3x6+9TXNjLpWjW2tw6hcvdkq0m+Tcsme2KtXMLar4sS3luZ4oHtVd445Cu72pLISaXq+&#xd;&#xa;paXFcSyWotjKgkcsYzjsaqre3R8M6RbLcyIbyUxyS5ywH1rak8OjT7G7bS7i5FzJFtG+UsCfXnvV&#xd;&#xa;HwqbKC8WKRLq21Eph45ZWZZD3bmuwFLRRRVPVv8AkFXX/XJv5V4xXa3Rw9u4P3ZOnqMc/wA6LqON&#xd;&#xa;bN2HyKoLnb34rPsbOz1KzWYo288Md3INT6QD5c9rJOZinBJHQHiofDjeVDdQOceVJnPp/nFOup7e&#xd;&#xa;WxNnAwdmQupxwOc5HvTbCbyYEjKl1mO8NnBB64qyNS8woi+UAQThjkgiqtxdSTxKwkBIBGNuADVi&#xd;&#xa;0d49KiMgw4lBTdwTU0mowxfaoRcpGzHchzms6fVEMPVmk2lenU9jXSaXbC0sIk/iI3OfVjVoK0rB&#xd;&#xa;UGWParS6fOi7vlJ/u03HHIxjqKqahHvg8xfvxHep+lXLFxtcL0OHH0NXHzsYA84yKiiBZySfvrn8&#xd;&#xa;atH5ko6qMdqXb2pSOB7UpAzmk6elJuHqeKTgnODSfdfI6Gm4wxFJ2z+FAyDz2rkPE1r/AKbIhxiV&#xd;&#xa;MiuOvAWghm5DxnY34V2Hw3uf3t5bZ4OJF/lXeUtJisqTQLCTWF1Nov36j14J9frWqKZPDHcRNFKo&#xd;&#xa;dGGGU965xvCLQsy2Gq3VrAx/1SnIH0q6PDdodH/s+R5HXdv8xj8wb1qrH4WLzRHUNRnvIYWDJE/T&#xd;&#xa;I6Z9a09W0i21aKFLlciGVZF/Dt9KNY0iDVrVYZS0bRsHjkTgoR6VSsPD7W99HeXl/PeSxDEW84C5&#xd;&#xa;9h1q7pmlR6bLdvHIzG6mMrbuxPYVmTeFmuMwT6lcSWRk8zyGwec5xn0rogAAB0FY6+HoFtNTt/Nf&#xd;&#xa;GoOzuf7pPpUtzo0VzoI0lpGEQjWPd3wuMfypZ9Gimu9OuGkYNYAhB/eyMc/lVXUPDvn6g99ZXs1l&#xd;&#xa;cSACVo+j49qcvhu3Gi3GnGaVhcndLKxyxOQf6VcvNMjvNIOnO7CMoqFh14x/hUN1ocNzo8OmtI4j&#xd;&#xa;i24YdTin32kRX0tk7uwNo4dcd+Mc1Ru/DTy3c81rqVxbJcNuljTGCf6VNdeG7SfS4bJWkQwHdHKD&#xd;&#xa;lg3rUEHhfF9b3l1f3FzPbnKl8Yx6Yq7FolutzfzMWcXoxIh6VlnweGtmtH1K5Nn/AAw8YWtKfQ4Z&#xd;&#xa;47BGlfFkwZD64Heo9T8Pi8vRe2t1LZ3JXazx/wAQ9xVnR9Ij0uOT99JPNKcvJIeSavuoZGX+8MVj&#xd;&#xa;p4btP7HbTXZ3jLmQN0KknPFV4fDMhmiN7qdzcwwsGSJjgZHTOOtaWp6Rbao1q1wufs8okX39qbrO&#xd;&#xa;kQ6vDGJGeKWFt8UifeQ1W03QWtb4Xl5fz3k6qVQucBR9BVvStKj0v7V5Ts/2idpm3diewqLW9Jk1&#xd;&#xa;RY/KvZrUpkfuz94H1FQDwxZ/8I+ukEsY1beJP4g+c5qsPChllt5b3Urm5ktpFePfjAwc4xWrqmkW&#xd;&#xa;2qPbNcLk28okX39qZrWjRavFEGkeGaFt8UqdUNU7bw0I9SttQub6e5uYM8vjBBGMYrerM0/Q7az0&#xd;&#xa;2exJMsMzs7Bv9qs+LwjCsiLLeXE1pE26O3Y/KDVO/wBPa98aMsc0tuyWwKSR9jWrpvh2OyFy8txJ&#xd;&#xa;cXFypV5X649qU+G7VtFj01mcrEd0cnRlPrUdv4fnSKZLnVbmfzE2Kc42e4p9l4faHUIry7vZbuWF&#xd;&#xa;dsW8Aba2xS0UUVT1b/kFXX/XJv5V4xXcJLHIuSMYH8QxinyKJYmXPDKQPxqlo9obOCWLPAfGPfFF&#xd;&#xa;tsi1aeMFgXG7k/jxVe3Hk+IbiIqfLuEznHBPWqltvRYAf+WErxuc44/wqAu8dozRnLW8hwdvQU6x&#xd;&#xa;I8sSlVEqvuJbuD7VDq8k8KKgYCCRi64GDWW9zNIQZJHbHTJqRCGGTwfWrMTZZNzAhXUn869Q+zqy&#xd;&#xa;KVPBAIxU9nCsVwWPpWBaw68PFbSSyt9j3nPzfLt7Vr3kqC6cKQRgZxVWeZfJc5H3TnNGnyAQW7hg&#xd;&#xa;QU2NWisnCHvnaacmU6/wt+lWUPUUicMR2p2cdKMmjk9aTApRgmjaOc8UxuV+lDcgMKQjr70uK5rx&#xd;&#xa;fFsNpd4OFby2I9DXJyWxF7NCygrKNy56Zq34Ju3h12NJCFzmMrjFeoUtFJiiiiiijAoxRRijAoxR&#xd;&#xa;ijAoxRijFGBRijFFFGKKMUYoxRRRijFFGKKMUUUYooxRijFGKKTYu7dtG7pnHNLijFFFFLRRRVPV&#xd;&#xa;v+QVdf8AXJv5V4xXZ/a42tXkl2AruDKT3FULXW7OGARyzAlAACBnNVofEiNdRqYyEZwGP6ZqzrDf&#xd;&#xa;Z9Us7nPGQD78/wD16u3tkbiVJ45SkkedvpmqUzFJSL+FNpI2OhxuJqvfQPDfTRM2VnTKcYFWLW2l&#xd;&#xa;UiW42viP5UI4BHSq+qQm80dLgcyHljWLHZknlvwAzV6DS5H4WJ298YqxHor4PmhIl9Sa7DQdT/cR&#xd;&#xa;2U3M0Y2hv7w7GtpunNZ8+QSAzAfWqrD06VXnVpx5Kjg/eb0FTWEWy3lhI5Q7hWpbtlmGPvjI+tWd&#xd;&#xa;m4g/3lxUkfG36Yp7fK4Paj+M07OKTjP1oHIpaZ/k0KCMjFCDgrQRkA+lBGc+mKo61a/a9KuIcZJX&#xd;&#xa;I+ori5v3lpFOB80RBP8AI1nSIYPElncR4xJIp56da9cHSlopCarw31tPcSQRTo8sX31B5FWKCcDP&#xd;&#xa;aqGlavb6oJzbnPkyFD+Her+aM0Z9aM0maXNJmqU1/JHq0FkttIySozGYfdUjsf8APer2aM0ZpCag&#xd;&#xa;tr6C6mnihkDPA2yQf3TVjNZWpas9lqlhaLGGF05UsT92tXNFFGaM0A1FcytBbySqhkZFJCDqaj0+&#xd;&#xa;6e8so55IHgZxkxv1FWc0Vl6vqr6fd6dCsQcXc/lEk/drTzS5ozVeS+gjvorN5AJ5VLInqB1qxmq1&#xd;&#xa;nf298JTbSCTynMb47MOoqzmiijNFLRRRRRRRRRRRVPVv+QVdf9cm/lXjFVWkds7nJzycmm0ZrqdU&#xd;&#xa;/feH7W4zkoFyfqMVftJ7i5gjeYKodcqFPUVDqspt7ZHX55UfEYxnJNGosBb2skh2yxAGQZ6ZHP61&#xd;&#xa;eiaN4U2nIIzmqkTeTaXEWzd5TlgD6Gp7FY5oPNECIe2BVmMM8LbyQWyBTYbT9wIpW5PepGiVHi2O&#xd;&#xa;UmQfI4rQj1sRrtvUwf76cg/hTH1G2lk2xuWY9gpzSxJJcMQqFFHVmqyIUt4mRRksc+9NRT9oPB5H&#xd;&#xa;NTxI0EaF/wCFv0q4H2hvVWzTx3+uRT5OVGKM5ANLg0pHFJ0paOufejPPWkPEmexFLt9aD0zUL/NG&#xd;&#xa;VNefyOIb67s2PBJKj2rJllL2oP8Ay0tZAfwBr1uwnFzYQTjo6A/pVilrB8U6nf6baxvYWvnl3Csc&#xd;&#xa;ZwPpWDNCuirLqelwGW+kI82Itu8jPXjvXZ6fNNcWUMtxEYZXUFkPY1leL9U/s3RpNrYlm/dp+Peu&#xd;&#xa;Z0S+sdJ1m0WzuC8VzGI58gjD+tbOp32pyeKo9LsbhYUkiLElc7eOo96fp15qFjr0ukX9wLkPb+fD&#xd;&#xa;LjB9MH9fyqhpU2v6voX9orqKxMgfYgT7+M9f5U+58QX91o2i3Nm6xTXc/kyZGRnOP6VZ1C51TSxa&#xd;&#xa;abHeC4vb6UhZpFwI1AGeKDc6poWq2MN9efbba8fyslcMjdvwqC/1nU7HU5dHEiSXFy6m1mOBsU9c&#xd;&#xa;+4xWnLeXUHijTdOM26KS2dpCRyzDPNZlrPrOry6qsV+LeO0uHSMqnJx0B9sVXhv9bv8Aww2sC+EJ&#xd;&#xa;t1YiNV+/t6k1cu9X1C+/sexspFgnvoBNLLj7q4ycfrToZ9XtfEtvpVxeiWOS3d1k2ck84z9DVLw6&#xd;&#xa;11Y6hrlzPc+alvKfNULjzG7H2qumu6ldWzXyX8iSnLJbrAShHpmtC7unvtT8OXEiGOSRiWUjGDip&#xd;&#xa;7jXp7fTruEMHv47gwR8dSehx9K6GxWaOziW5ffMFG9sd64+5167vtSukjvZLOGBtiCOEuWPvUp8S&#xd;&#xa;X66Dlk23jTiBJGXaGz/Fin38ut6M1l5uoCdJ5lV8ryvsPatSz1C4l8V3tk75gihVlXHQmq8eqXZv&#xd;&#xa;tcjMmUtUzFx0OKqxaxqEemaRqUsm6CTC3I2+p4NSz65c/adSu4mBsbJNqgD77/Wqc82v22gPq51B&#xd;&#xa;WLpvMRThQfSrGsytPJ4YlkOWe5UsffAqDUtdubnWru0iu5LOC0IXdHEXZ2/oKVde1H/hGNTlckXF&#xd;&#xa;o4EczRlfMUsMHFJql1renaXBrD36sGKF4AvygNRq1vfSeONO8u8CF0dovl+4AOR75rr7hJJLeRIX&#xd;&#xa;8uQqQrYzg44NcN4eu7nR9K1rUJZhLHDcSL5e370mVG79auzN4gtNJ/tl79JGVRK9tt+XZ1xn1xXU&#xd;&#xa;2F2t9YW90gws0auAe2R0rnnutT1jX7y1srv7Jb2JVSQuS7H+lWPDF9fXV5qlvqEiu1rKsa7RgdD/&#xd;&#xa;AIV0NLRRRRRRRRRRRVPVv+QVdf8AXJv5V4xVTYc45P0qeCyubj/VQu2OuBVuy0O6u1LDaig4JY1Z&#xd;&#xa;sWnu9OOnRBTh/nJ6hc9vxradTZWaRwjc0UfC55PNKY32E8bj9wkfdPrWa8JiF2kzNtdOGY8k1f0+&#xd;&#xa;NTZwmRyFdQoA7Yq5LEftUirjMkXH1FWInzGg24OORiqmpXE0USvAhZ9w+XsKs6fN9ubBIDp95R2r&#xd;&#xa;Qa3RAJXA+TJqg8ELMzEFzINy4HSltnZYzMkeJM7T9K0ZjIU/ddBggDvU6M7qHIAI6gGmmR0dDkZc&#xd;&#xa;81byp3An7w6UCRcrn+IbaVZuVPY/KfrU0cwZOnTg0lvMJEZQfmU9Knzzn2oHajtQOxo5AOO1OGMU&#xd;&#xa;j/d+lNLHAIpHPI9DQUGOa8/8XwfZNWW5XgE8/Q1iyMEvTj7k6frXongi6Nx4chVvvQkxn8K6Clpr&#xd;&#xa;KCOlYel+GrfTdVub5JZHM3RWPA9frW6OlZF5ozXutwXs8itBbr8kJH8XrTtZ0WDU7B7dAkMmQUkV&#xd;&#xa;QNpFc1dWt4/jK1hjuhHdx2uRLtyGIA6j0rZ07RbqHUJ9U1O5We6aIxrsXCotYXhjTtWufDUa2N+k&#xd;&#xa;ME5cOrpkryQdprebw0iWmk20EoVdPmEpJH3z1P61b1zR/wC1UgkjlMF1bvvhlH8JqlBoV/c6jBe6&#xd;&#xa;xeJO1sSYY412qG9TTG8KrcQXj3k/mX1w/mLOox5ZH3QPYVbj0i4bVrDULi4V5LWAxPgY3k55qTSd&#xd;&#xa;HbTzqBMof7XO0wwPu57VXs/D723haXRzOrM6uvmY4+Yk/wBahuvDk5ttMezulivdPjEayEfK4xg5&#xd;&#xa;FOsdCvV1yHVb++WeVI2QoqYAB9KtWGiC2m1RpXEiX8u/bj7o5/xrNj8PavawmytNTRLInjKfOo9A&#xd;&#xa;a0bjRGlutMmE5IsjkluS9Zdnp0d/41vLwIRFakA56NJjrXWVzk2g6ja31xPpF7HClw250kTIB9RU&#xd;&#xa;k/htrjRRZz3jyXAk80TN2b29qxdcs9ThbTn1O9SYLcKqLGuB9T71ualo16dV/tHSrlIZ2QJIJFyG&#xd;&#xa;FLp+gywWt99puBLd3gPmOBgDjsKnttFWPw6ukzOJFEZQtj9aS00GCDQDpTHcrqQ7dyT3rJk8NatP&#xd;&#xa;pzabLqifZAMJhPmI7AmtK60RpxpP74D7BIHPH3sAf4VDeaHfRapPfaRdpA1zjzo5F3KSO9LJ4fuJ&#xd;&#xa;dAu7C4vWlnum3NIw4U5BwB6cVY1nRW1PQk04TBCNnzkZ+7in3OktPr1lqXmAC2jZCmOTkYrU6Vh2&#xd;&#xa;Xh1ItO1GyuXEsd7M8hwMbd2P5YqifDmrS2i6bPqatpy4U4X94yjoM100EKW1vHBENqRqFUegArCu&#xd;&#xa;tDv4dXn1DSLxIDcgeckiZBI7j3qx4f0WXSZb2Sa5+0NdOrliMHIzn+dbQpaKKKKKKKKKKKp6t/yC&#xd;&#xa;rr/rk38q8YrrbCwitVf9ymS2RxmprWH7KjLuB3HNOSKO3BVBtU8/jWYm218R7EiVVmXOQOelFjDI&#xd;&#xa;1zcSXR/eMSqc9qtzXMdtCI5C28/dULkms+4W4u9im1kRMHO71qfT2Mdi1vPIisG+TnpWkzo0kZfI&#xd;&#xa;YDh16VZRBs+X5uO5606AEqQyhfXip7W0t4d3ljG7kkVK8sYxHnkis2/uzbeWkKgknAHtUVtd3DSS&#xd;&#xa;rOpCn7mBitK3V0wJWZuO1ToqBj5bHceKQKjRFZG2lD0FWkEXlq6tnHTmlWJTuAJOG3CpVRVZh7hh&#xd;&#xa;VmNVycDgjIqrKnlXQYDAbrV5cYGKR+oxR3oHcetL/UU2he4oA4K0g5GDSk1w/jyJmnhb+B0Iz6EV&#xd;&#xa;yxJls45O8bCu68CSBDdwBshiJVHpmuwpaKSiijFRG1gNyLnyl84DAfHOKlKgjmo7e2htYhFBGscY&#xd;&#xa;5CqMCpMUUYoxRiijFGKKMUYoxTI4Y4ixjQKXO5sdz60+jFGKintobjb50avsO5dw6H1qXFGKMUYo&#xd;&#xa;xRgUYFFGKMUUYoxRRRiiloooooooooooqnq3/IKuv+uTfyrxiu4bJxtXGPU1DKSZI0bnvtUVMVZz&#xd;&#xa;84CovQetZWouv9o29yhLCP730q7JaW88i3CZ81MMCD/OotJlkmNwkrbnic7WI5Aq8nmKhDEOwHT1&#xd;&#xa;NZDJZw3EqyKxkJDlfSrK3SxOwii7BsZzmtKJ8lWXgMPukdKuwwHGXYc802RRHk7sDpzVNXRnYoDw&#xd;&#xa;cZIqrM0guGVUJYDKselVJpLj+0oopJlEbDJy2D9K6SxKhSpbJ7ZqZov3uUU80w2IMh3Hlh3qWzsR&#xd;&#xa;HFsYk81bUeWAcVGrlirnsSpqeCQELnqpwafcLlc9wafGenoRS0dqcOtFHfB6U6m9Hz2NNPDU0k4r&#xd;&#xa;C8WWX2rS1wdu1wSfauRktQZUtkGFxknHUV0Phdlg1ZY1A+ZSprtqWiiiiiiiiiiiiiiquo38Om2U&#xd;&#xa;l3ckiKPG4gZ6nFTxSCWJZF+6wyPpT6KKKKazBFLE4AGTUFle29/B51tIJI8kZHqKsUtFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFU9W/5BV1/wBcm/lXjFdwH3Rl+g5xmo7fdLah87ZHXk45zT7VzJbq55Jz&#xd;&#xa;mqazxrqxtfKXDr/KprcBL2b7oycbc8n3qODZDrE0Y4MqhqeJ4YnkCb3ZSSc9BVUyxuYp3tvMkkBG&#xd;&#xa;QKmSW5cqI7fYpGOnSr0FvMywySOAyH5vetfCAhmbBI6ZqtdOqtE5xjdimSyMH8tY8g/xUy8gC2w3&#xd;&#xa;HDmsW6gsVMRlYeYrAj1ro7Vo3RJOpHpWik/A2rTSdshZskVNG7Ej5eKdKpZTnjHSo0jADD1OaRRs&#xd;&#xa;mb0ccVazuhPuKICGjU9cVLTO5paKQ0nNKeY/ekbkA0mAeOxqtfQ+dp88fU7TiuKnyBHKOCODUOnX&#xd;&#xa;ZstfjLHhmBFenqcgH1paKKKparqMOl2T3U+dq9AOpPYVijxLe2/lTajphgtJSAJQ2SuemRVjUPET&#xd;&#xa;2urRWFvaNcSTJujKnrxn8qXTNenm1SbTtRtRbTxReb8rblK+uapf8JZdTJJdWdgkllGT87SAMwHU&#xd;&#xa;gV0FjqEF9YQ3kTgRzLuXccfhVXV9Y/sxrWRow9tNKI5JQf8AV56GlbW4B4gXScjzGi8wN7/3fy5q&#xd;&#xa;i3iqJIL+5eI/ZraUQxuDzK/cCoo/E9zDPbjUbKOGC4cIrpKGKk9NwqW98RzDUpbHTrZJ5IMeazvs&#xd;&#xa;UE9h6ms/W9YXV/BmptsMU0DKkqZztO9e9adprZmubfT7GHzzHGpnlz8sfA4z3NbU0ohheVslUUsc&#xd;&#xa;e3NYmja7fao0Uq2KC0l3YdZMsuP7w7VHd+JJzfzWum2qTmDiRpJAgz6ClPiqP+w5dQEB3wyCOSLP&#xd;&#xa;INQnxTdpex28umMpuF3W4Dct9fSrOna7cXN9c2F/ZiCeKPftDZDCoI/EEVp4b/tGGyVE84p5SHHf&#xd;&#xa;GaWTxJe209s15pvlWlwwVH35YZ6ZFT32v3K6o+n6ZZfapYlDSktgLTbLxI10moF7Romslyysep9K&#xd;&#xa;k0XWb7VjFN9gENo658xm5z9K3KWiiiiiiiiiiiiiiiiiiiiiiiiiqerf8gq6/wCuTfyrxiu1XMpI&#xd;&#xa;IxGDx705iznYnygdTTwoRQF4ArPlslOqR3YzuPGfpRcPHBqEZYHfJgZxnjpSXjSR6natGudxKk56&#xd;&#xa;1PNbxGYvIzguOQOhpUj+zIggUspbJB5IFPuBdENhgqA5yeOKlt9r28ivMG/iJFS3V/Ci7Su7auQf&#xd;&#xa;WqFxqH2izLKu0I4xW1DvaGKTgZAJFQanm4iIUlcHOapPb2qAPKAxPc1oaZdRyoUjHI9K14EcDJAz&#xd;&#xa;UjnbGcjJ9KijlZgCBgd6sZzjngimIAOc9OKY5wB7GpY5QAV9KbE3ljaTySTVgNuUGlwaUClOPWm5&#xd;&#xa;AoJpAc5FIPu4NANBHJ9DXDXsJSa5gbja5xWJqeUWG5Q8o3Jr1TSbgXemW06nIeMGrdLRRWP4m0yT&#xd;&#xa;VdLaGEgSowkTPQkdqxr5tY1y0TTH0xrYZXzZnb5cD0q5/Zlyni+zuVjJtooChf324FOn02ebxfLc&#xd;&#xa;shFq9gYTJ/tE1gW2lXOn2psJdBF3OpYR3Ab5SCeM11CaDb3Wj2lpexiMxDcUgYqoY9akl0G0OiTa&#xd;&#xa;XGG8p1O0u2SG6g/ga59fDt8PDzTlj/bAlEyv34+UL9NtXdU8NM/hSHTbUK0sDLJhukjDOc/XJqlb&#xd;&#xa;WMl3d28aeHktgrhpZZjkYH92kvdJlsdavrh9JOpW903mIUbDIe4qSXR7yXwnqMK6fFb3Fy6lIYzz&#xd;&#xa;tDDGffrViz0280HUY5LGFpbK6C/aIR1ifH3h7V0s5cQSGJQ77TtVuAxxXGW9jevqltLp+mzadIGP&#xd;&#xa;2k7v3bD2FFxpEmnareSSaSdRhuH3oyHBU+hqxLo92/hiaJbCKCeaVXEUXYA9/er15YXMmvaROsRM&#xd;&#xa;UEZEjf3TSmwuf+Erurvyz5D2oRX9T6VmHR77/hD1s/s58/7Tv2f7O7Oa1PElhc3ljYx28RdopkZg&#xd;&#xa;OwFVZo9Q0bxBd3sFk95BeAcIRlWqHT9P1Nxrc13a+XJdr8ig57dK3vD1tJaaHaQTrskSPDL6GtKl&#xd;&#xa;oooooooooooooooooooooooooqnq3/IKuv8Ark38q8Yrt0lBlZAD8vqKIAViCnnacGmKrrMzNJkd&#xd;&#xa;l9KSaaRJlRYyVIzu9DVbU7r7Lax3TxbmXj6ZqrrM0n2CK5i6qwbPpVszXL28TxKjFgCS3aph5oyS&#xd;&#xa;4A28uDUd00ojWZJ8pwGGKriWMXZSNjh1wQRT5JoB5LFjgAofrUFrcRPPMqj5duce4rVsrx720Kxn&#xd;&#xa;YRxmr0UQMexjuyMGk+w2scWyRSfQk5qLTWjt2kEdsRhuCe9bEV4WbBAUY61KJ1HOd2aiklKEAD5T&#xd;&#xa;UiyB4xhuRUqrgEevNDqG696ZvVXDdsVTmuW+1oFHHTNaMTlRjtUwbNLTuopMUYpADmgjBpDw1IT8&#xd;&#xa;vvXJeIUMWrB/4ZVrm5Y8pPA31Fdt4AuvP8PrEx+aByn4dq6cUtFFJRijFGKMUUYoxRiijFGKMCjF&#xd;&#xa;GKMUYoxRijHNGKMUYopaKKKKKKKKKKKKKKKKKKKKKKKKKKp6t/yCrr/rk38q8YruutNjGGcZ6nNN&#xd;&#xa;hO6PJ+9k5PvTieOTVLV4/O0yZBycZH4VWVWu9CWLb8zR4/GpLYtb2AiuMkqMfLQl4yoES2kKE4y1&#xd;&#xa;LNPN5YXdFGAcEGswzQxXXmTTNJIG/hHFX7cRTs0QgbBO4E+tNsYENx5ZUh+Qa1tIsvIaSIk4PNaU&#xd;&#xa;cXkgrkkDkGq00spzkovpmoY5t7bGnyT020W6Si4cMSVx371qwSKioCMGppD5i5P0oto1jJyeKSbU&#xd;&#xa;reDGXDHOMCqM2rStjy0OA2M4pn2hgCZCTtOcVJNOFUOFOM5rQguY3iVw3WrKSg9OanXJqQccUtFJ&#xd;&#xa;+FI/IqNucGjqK5vxVFmCKUDlGxXLXvyTJKDw3Bre+H84i1G9tSeHAkUV3dLRSUUtITSbh6ilByMi&#xd;&#xa;gmohcRFHcSptQkMd3C/WpFYMoZSCDyCO9OooopDSbh6j86ZJNHEu+SRVXOMk45p4ORkHilzQKY0q&#xd;&#xa;LIIy6hz0Unk0/NApaKKQmilpKAcjIpaKKKKKaTgjmlzTI5o5CwR1YqcMAc4NPpaKKKKKKKKKKKp6&#xd;&#xa;t/yCrr/rk38q8Yruh0pnPmD0xSxjG4e+RUVzCJQMsVCnPFNlBEOBzgVnaXHLHbukh+8SVGegp2nR&#xd;&#xa;yRTSLNIXOeM1ZDyRbizhx/dFVZ7dJZN5iYmTsTxTjAsQzsiQn15NXYSpK4Jduh2ita2sYlAkEWG9&#xd;&#xa;TWhEgAzgA/Sklh3NweKzZ7PcwJ5HSs+W0MDq4zhW/StCXeCroAUI702W62QerjnAqNdTlZjHDFkt&#xd;&#xa;0LUgS5eVWu5ig/uJ0q1stodwWMZ65PNMMrSN8oABwelTodxG7uMVOoWWJgVFSWkaA4KDitBFUdFx&#xd;&#xa;UmVH1pQ3OKWjmkxQfSo+1JWV4gi8zTpMDkc1x0sQa3w/OKs+G5Vt/EFpIjZD5jY/WvSqWkrH1zVX&#xd;&#xa;traeOw2TXyLuEWeQPXFGh6s91awR3+yG9dd3lZ5I9cVsUEV5tpw0u4udQOranNDIt06oolI+XNdn&#xd;&#xa;HqOm6To1u/2otb7dsbk7mf8AxqTTdcsdUkZLaU+YgyUcbWx9K5S3J/4RnxT7Xcv9K6W01K203w5Y&#xd;&#xa;z3coRfIjAz1Y7RwBUlh4gsNRaRbeRvMjXcY2UhseoFTQ6tZzaa2oRzA2yAlm9Mdadd6na2cEMs0o&#xd;&#xa;CTMEjI53E9MVUk8SadHeNbGR2dX2EqhKhvQn1rW6iuF8QaJFb6vpkEF1dbr24Ik/enheM4/Ol8U2&#xd;&#xa;EGkaVaWcU8rJPeCRmlcscAf/AKq6Ow17T7m5SyikcS7flDIVDAelMguYE1PUbg3zukKgSREfLHSw&#xd;&#xa;+KNLmmjiSZ8ynCMUIVj7GqU7LL46iLMAttbFiT2zVy91ayu9Mu2iu2iSMbWnVfun29ak/taz0y3t&#xd;&#xa;Ybu7LO8eVZhkv71Lp2uWWpSSR28jB4xllddpA9cGq58UaWJmjM7YQ4Mmw7M/WtOyu4b61S5t23RO&#xd;&#xa;Mqcdaz7x421+0iF68cioW8hRw49TUcvijS4t/wC+dzGxVgiFtuPWtS0uob22S4t3DxuMqwovZPJs&#xd;&#xa;55ScbI2b8hXOeGNQi03wjb3eozkea7MCxySSxwBWlb+JdOuJYoUlZZZSVWN0IbI9qsw6tZ3Gmtfx&#xd;&#xa;zD7OoJZzxjHWoJ/EWnwW0E7yNi4GYlVCWYeuKksddsNQuRb202+Up5hXBBAzjn0rRpssixRs7sER&#xd;&#xa;RksTwBXIx6xcav4ssEjDR2Cq8kfYyYBG4+2elWbDxGLzxZNZrKTbCICNdn8fU5P51n+G9dsbC1vr&#xd;&#xa;i6kffPeSSHahbavGM+ldnbzR3ECTQsGjcblYdxUtFFFFFFFFFFFU9W/5BV1/1yb+VeMV3KkEZBBF&#xd;&#xa;KV5zTekg9xTZoxLGU3Fc+lNSHZFt3Z+tZls5i1GW2c/KBlahmLx6lhSdz9A3Spore5Mrb5gg/wBk&#xd;&#xa;VZjtgjK5kZ2X1NQSbjcsREDz1NX9PaZrjDAKAecCt6NmJG7gVOHUqdpyRSLLuQ+tNbnPHWq0yqSc&#xd;&#xa;kYPaqF64KhFYgHjg0y0TKA+X0GMmhzJFNG23AzV+6hZ4wSeQakWEMFJ9KljgUAALnFSrbe2Oanjt&#xd;&#xa;0U5x1qVI0VsrRJPEkgQyAN6ZqlJLdzyYtSNoPUjirFvDcq4eabPso4q8DxRRmmk8009abjmq99EH&#xd;&#xa;tJlP9w/yrz9Ww+CchqS3mjt7tNgwUcN+teqRuJI1cdGANPpMVyus6Omm3dxrtpFLPcgZEeeAfX/6&#xd;&#xa;1Jo2kLqd1b67eRSQXJGTFngn1/8ArV1Y6UVx/g/T7a5/tV7m2R2+2vguvan6/HFp/iDSryeHOmwo&#xd;&#xa;yEBcrG3ODiozPDq3jCwn0obo7ZGNxMowpB6D3qpbqw8NeKRtOTdS4469Kkvl+zt4bv7qJpLGCBVl&#xd;&#xa;GM7GKjBI/Kp5rm31jxXpkukDeLfLTzoMLtI4XPeobrSrldck0aIEabfyrdMR/Co++v4nH50/RLC7&#xd;&#xa;uNYjtb4FrfRsrGT/ABsT8p/BcVUu7yHTLm6utJvN7PcZlsJkyXbPJWu9jJaNSRgkZI9K5rUgbjx7&#xd;&#xa;pUeCVt4HlJ7AnI/oKNfgF94q0a0dd0SrLK3HHTj+VLqSiTxlpaKuBFEzkgdKykdhoXiC6CnfPMVX&#xd;&#xa;jr2qzqtsI9P8P2aJyZV6DpxmqeqWN3qOs6vLas/7gIrRjjzFHJGat6vdW114Tto7GHy0kmSMxBcF&#xd;&#xa;TnkGrZt1n8a26OmUtbXjI4BNV5IZLnxJrLwKQyWoRSB1NZ6avY2/gt7B4W+1qhV4ynRs9Sa7DQIv&#xd;&#xa;I0Kyj9IhWOWMnjS7mwdttacHHc1F4fiWDwneXTRjfMZHORyeuK0/CERh8N2akYZl3EH3qj4l8RWa&#xd;&#xa;WGoaerOLpojGi7T8xbI4rNvof7LTwu14h+yWynzuMhWKjBP41YF3aav450+WzG9IIXZpAuAx5A/n&#xd;&#xa;UB0u5k1q60JQU015xdyMO6EfdH4irN3PbaV43E18PKtjaBLdyPlQ56Uug3Fvc+KtY1KJfLt1hRQ7&#xd;&#xa;DaD6n/x2ul02+i1KyS6gDCN87dwwTz1rK8T6ZqerJHb2ksUdsPmkDZy/PT6Vj6bDqreM/wB6bcG0&#xd;&#xa;t1jfYuF2E5wPfmrWkkJeeJr/AGY2SFUOP7inpUenwLZfDiV/LHmS27s3HLFicf0roPDkJt/D9hEe&#xd;&#xa;CIFz+IzWlRRRRRRRRRRRVPVv+QVdf9cm/lXjFdvb7fKXb0qbNQyhgykevNKDwc1ClxG0u3IJPSsr&#xd;&#xa;UCYNXhlAwGG01BqhcXMEvOAcZrRE0ZAjkbYXHBpFdIeWlL46VYZN8RIAJPIqxaK6yHdgZ5rcQB4h&#xd;&#xa;zyKFUgtgdaI1bnlQKRiApO7nFY9xcSFxjopwagaCS4+VOWDZrcgsysA3fKe+KJrTfCwUZPbNJGQE&#xd;&#xa;KzMAactxGqYAyB3NRPqipkKF4po1V3VGGPmqWC9llA45zzVyIyFmzkCnw2aRSFwMs3Unk1dUADgY&#xd;&#xa;FOzRmkzSc0YoK8ZphB4Ipsy+YjKeNwxXmk0TRTSJnJicg1DcK3nJKg7c16foM/2jR7Z85OzBrQpa&#xd;&#xa;QgHrQAAMCiimrGiZ2KFycnAxmleNJFKuoZT1BGRTIbeGBdsMaoPRRineVHhhsXDHLDHWhoo2TYyK&#xd;&#xa;UxjaRximxW8MC7YYkjHoqgU/YpYNj5gMA0BFBJAGT196jNpbmXzTBGZP720ZqWmmNC+/aN2Mbsc0&#xd;&#xa;pRC4cqCw4BxzSeWhbdtG7pnHNJ5MW0r5a7Sc4xxSmNGxlQdvTI6UCNASQoBbqQOtIIIgMCNOufuj&#xd;&#xa;r607Yu7dtG48ZxzVe8tRcW00SMYmlXHmJwR71zr6Dq95GtpeXNsbYEb3RMPIB2JrqYkEcaov3VAA&#xd;&#xa;+lHlJknaMngnHWgRoE2BFC+mOKVVVQAoAA6AVG9tBJIsjwozr0YqCRT5Io5U2SIrr6MMimx28MWP&#xd;&#xa;LiRMDA2qBgU/aN27AzjGaZLbwzjE0SSAdNy5xVe/02G+s5LU/u0lxv2cFhnpVqKNIo1jjUKijCqO&#xd;&#xa;gFOpojQMWCgM3U45NAiQBgEUBuox1o8tCmwqNnTbjinAADAGAKWiiiiiiiiiiiqerf8AIKuv+uTf&#xd;&#xa;yrxiu2QiNCFHIzxUVjcTTSssiBQP0q7cqfK+UZPpUOcjB4qGKC3ibeoANU9SjNy8PlLkq+c+1OvL&#xd;&#xa;UTwhX4AOc0sltHJAGc5K/dqaCIeX86KpIxzT1typ+/8ALjAFQwSGO9ETHNdLaMDHUpB7moVKqSAT&#xd;&#xa;71RnuD5pQKcetU3Vm8xQOa09DhBi8xwN2cVt7QF6VWnmCq3GMCsC1nD3Mgds84FSyKTvVSTxWelj&#xd;&#xa;dS4GMDNbFrpY8lQ3UHNaltapEPuirexdnAoBytKKXIHU0cUbhSE0ZzQvegdaZIeMV5vrSNaeJZk/&#xd;&#xa;gm+YUirlStdn4Nm3adJCesb/AM66KloooooopCaKWiiiikoopaQmgUtIetAoxRiiloooooopKOtB&#xd;&#xa;OPxoFFA6UtFFFFFFFFFFFFFU9W/5BV1/1yb+VeMV2gYAnHelicLNj1FTyz7AAe561C0W7OSSfrTj&#xd;&#xa;sC4IGajJ2qzKucDpUe8zRnem3jpTEkVrY7edpq0/ktbI0mcj0prSKY/lPbvWRLKySrJ/EDXR6ddq&#xd;&#xa;QAerDNaSSoXxzUVwxQkgcetZVyW80N5gAqEzh5VRW5PGRW7Z4togO1WHuiw+WqkjmViM1li2FtNI&#xd;&#xa;+M5Oau2rb/mOAOlXg8ER+ZwPrUTarbpLsVgfpUn9pYwFXOasxXTPGeDmnQysQ2eKZc3nlxkxjzHA&#xd;&#xa;zgGsu31e7uZgEhUANgjk10I6CiigUveg9abIO9cd4ytUS5tro8HBWsYSLww71v8Agu7A1Oa3J++m&#xd;&#xa;R+FdtS0UUUhOM1G88cZAeRFJ6AsBmnM6qpZmAUdzWD4j1CaOXSorGfabm8VGZDnK9xV9by6jvrz7&#xd;&#xa;QkS2cSAxuH+YnuCO1VbfWbnUfDg1CxhjE7/djkfA+9jk/QVrecI4ledkjOOcnAzT1kVlDKysvqDx&#xd;&#xa;TTcQgqDKgLfdyw5+lPLY/GlrD0bVLi81rWLaYr5VpIqx4GODnr+Va5uIVxuljGeRlhzUm8BdxIA9&#xd;&#xa;c1m61eeXot5Nazr5kcZIZCDg1Jo1w02lWjyuGleMMcnk1d3ru27hn071V1C5WO0uAkqiVY2IAYZz&#xd;&#xa;j0qp4Yu5bnw/bXFzIXkZcszd61Emjk/1civj+6c0hniD+WZE3/3dwz+VSZqNp4kGWlQDOOWAoaeJ&#xd;&#xa;cbpUUt0yw5pWkVF3O6qo6knAoWZGxtdTnpg9aztO1lL/AFK+s1UKbRlXduzvznp+VaBniD7DKgf+&#xd;&#xa;7uGac0iqcFlB9zVC6a7lv7KS0uIBaZbzlJyW9MVdeaONgryIpPQFgKzPE13JbeHb24tZdssScMvY&#xd;&#xa;5FXtOdpdOtZHOXeJWY+pIFc/qtzc3viuHTIb5rWCO3852QjLNuxg10pmiQYaVBzjJYdaWSaOMgSS&#xd;&#xa;IpPTcwGaUyKF3FgF9Sab58XmbPNTf/d3DNKsqMxVXUsOoByRTxS0UUUUUUUVT1b/AJBV1/1yb+Ve&#xd;&#xa;MV1qSL8n+0KcTtnQ49qfcfPEQDTo5P3QPeq63G+4ZCp471ZzwcelVoCQxEkmTnGKjhh8tpgG4c8V&#xd;&#xa;JEzfZSgwWBpUYmP96APpVK5XzkYRDlau6bDIskLs3QVsNLJG/C/jTXuGbhzgmsy8hZ5l5OCavWth&#xd;&#xa;GgD55XmpZbp8YRCRiqqXlwrEMoANWEY+WW3ZNZl/cy7CqEjNZ8V3dxqV3EjNSXEl1I6MzHbV20t1&#xd;&#xa;dlYN83oa6GG2XYpI5q9DGAKf5eDx3FIlmuMS4IPYDAqWOGOJNsaKqjsBT6WikNGad1FNbBFc94wg&#xd;&#xa;WTR2kP8AyyYNXB/ahJtCHgVr6FcfZtdtJeis20/jXqFLRRRTGJAJxnArzmwgudYtLq9ubRLiSSRx&#xd;&#xa;5slxs8n0AHbFX7lbsx+HtI1ObCTM5mZX4kC/dGfpipZ9NtLbxtpVtZfLGqvK8YbIUgHB/GoMJdaX&#xd;&#xa;4pu5yzIJ2CfMeCg4/mKZc2Mdj4V0e2hDLLf3EPmc9SRk1fFvFrfi3ULfUWJgs1RYoN2AcjJb3qrB&#xd;&#xa;MNMn8R21pIzWUFsWT5shHK9AfqaiutJtrXwCl9KHa88pJFlLHKliMAfga6drOO6g0r7TcPHNFtdV&#xd;&#xa;V8eYQBkH1rXHSuO0v/kKeLP8/wALVW0zRLS78GJe3O+S4MRZXLn5cE4A/KoTdTXOi6DazzukFy22&#xd;&#xa;Z84yB2zW1qek2Gm6JqLWS7Ge3wy7s8etZ+muU1zQ9zEI1ke/BNXLiZx4wuWhYsY7InAPAOKzdO0y&#xd;&#xa;yvPDM+pXUzfbGDs0pfBU+lVpJrgeGNEtYjiKdsSfNtDe2e1aFnYXNlrto0MUFkrZEka3G7zB64qD&#xd;&#xa;7Ouk3xuNTtvtUT3GUvI5MlSTwCK7pSGUMOQRXEaVpVvqcGryXfmSGOZxGCxwvGciq0OmQz+CJdQm&#xd;&#xa;aSS6jUlJGY5XB4xVq4zqWo6LY3sjC2kt97Ddje3oakexttP8baZb2cj+W8chaLfkLwR/n6VBpVjD&#xd;&#xa;Yan4intUYy2S/uBknkofzqjaafPd6AL1oImlkUv9sa5wynJ5x2x6VpX8Mt7qXhm3vJdzSxP5rRvw&#xd;&#xa;+FB61b1K1h0/xF4dtrRfLhDzHaCe4BqvpNlba3qusT6mzPLDcGONC+3y0HQiqFp/yJPiBRKZVW5Y&#xd;&#xa;K5OcgFcGu40rnSrP/rgn/oIrlZdHs5PiC0TK21rX7QRuP399P0TS7fUta1qS7DS+TeERqWOF5Jpu&#xd;&#xa;jWNtr93qdxqzM80c7RLEXwI0HQgf56VQe5lPg7W7cTvLDa3AjglJ5K7hxmpPE+lw6fpumXdq0iXM&#xd;&#xa;kqK8u87myuTWnDZxab4tsI7bcontmaXLZ3kdzXWClooooooooqnq3/IKuv8Ark38q8YrqYy0ltkp&#xd;&#xa;tYdBRdrmBWZygB61MrK0HB/GmW0yPlVIO04pxgk87eGUJjmpN6q3WovJiWXfxmmuquxIfB9qpSJN&#xd;&#xa;HIfLlIBqM285Bd5m2ilinjT+PdnrV6G7Ziqxxscd63ZFZ4FIHPeqtxwAW7VWkl8wjHABq/bPjvmk&#xd;&#xa;mnZQQiD0rMuYrqViVYKPaoV86xUvI7EdeaptqCXEpHQZ61ctkjY8EEGtBIUdMEZxT0hjQ7lytXYb&#xd;&#xa;0RAZJNXE1OLHf8qlkv02AjOKadTiCj5uvrU0V5Gw5PJq0rKwyDTqKSgU4dMVGR1rP1m3+06ZcxH+&#xd;&#xa;KM4ryW3OyRlNacE21VcHmNg1evWkontIZQch0B/SpqKKKSsO58KaZcXLzFJEEhzJGjkKx9xVvUdF&#xd;&#xa;sdStY7eeIhIf9WUOCn0NR6f4e0/T7pbqBHM4QpvdyxINPXQrBdOnsBGwguGLyDdySSM8/hU0+lWl&#xd;&#xa;wbTzEJ+yMGiGehHSq2p+H7HUrgTyiSOcDHmROVJHvT4tB0+LTZbBISIZv9Zz8z/U1Ld6Va3mnLYT&#xd;&#xa;oTbqFAUHH3en8qqrpbza+b+6YGOBAlrGP4cj5mPv2rXHSqUWk2kM15KiHfef64568Ef1p1vpttba&#xd;&#xa;athEhFuqlQpPY1A+g6e+mJp7Q5gT7vPI/GorTw3YW1vPCvnOs67H3yEnHpT7zw/YXlpDbyIwWAYj&#xd;&#xa;ZWwy/jT9L0Sy0sObdWLyffd23MR6Zqm/hLSnuHkMcgVyS0QchCfpVt9CsH0xNPaLNun3QTyv0NRa&#xd;&#xa;d4c0+wmM0aySS4wGlcsQPaox4W037QJCspUPvERkOzPritsAAYxxVS10y1tI50hQhZ2LPz1JpiaP&#xd;&#xa;ZppbacqEWzAgrnnmob7QLC9tYYJY2AgGI2VsMv402y8N6bZXUV1FG5nizh2cknIxzVu2022trq6u&#xd;&#xa;IkxJdEGUk5zisxvCGktOW8uUITkxCQ7CfpWlJpdpJd2tyY8SWoIiwcBQRjpTrnTra6vLa6lUmW2J&#xd;&#xa;MZz0yMGqN74Z069vWunWRJH+/wCW5UP9cVJF4f06HTrixihK29wxZ1B78f4CtGGJIIUijGERQqj2&#xd;&#xa;FQf2dbf2p/aO0/afK8rdn+HOaLPTrayluZIFKtcyeZIc9WqjqHhnTr+5Nw6yRSvw5icrv+uKsNol&#xd;&#xa;g2lHTRAFtTjKrxnnPWn3+k2moW8MFyhaOFgyAHGCBgU99Ot3vobxkPnQoUQ56A1apaKKKKKKKKp6&#xd;&#xa;t/yCrr/rk38q8YrqQwto282QE1VGpQtGVmGOeB1qI6kjMscakKTyTV62tUWXcpPzDJq6UPlFS2M1&#xd;&#xa;S+zBGBkmJyfWnTskbBSDk1Rnj2PvjfGexNNZpAoZiCKuRbZrfY/3SOajjFpD6HHtVgXo6RRH64xW&#xd;&#xa;3BKXtAWGDiqcz7hhqr5xwOeamSQr0pRPvJ3EAVC14FYgAke1QXUv2mIrjHHesh7AjlePpUkEU6Dh&#xd;&#xa;qtW890s+3cOfer267b+4T6Zp+blcblXFW4Zn4DR4q5+8kt2CqKpGObC7towela0EaPGu4YPtVuJf&#xd;&#xa;LPBJHvVlTkU6kxQeKBwaGqGQAgg9MYrx7VYja6rcx4xtkNQxTEEjsRXrng67+1eHLVsjKAofwrbp&#xd;&#xa;aKKKSiilopKKKMUUtFJRRRRRRRRS0UlFLSUUtJRS0UUlFLRRRRRRRRRRRVPVv+QVdf8AXJv5V4xU&#xd;&#xa;zSSt95s896ltbdpZ9rdK2Ley+fBi4z1rSe0dtpV9i0htIx80shIHXJqMG2LLtIwO9LfiONA2N1Ye&#xd;&#xa;qHdGHQEGokkL2XB5FW7C4URESEc9qRJoRN5cS5bP0q8kc54ICitSCN/JG5hUbIc+1O8kDnHNP8rP&#xd;&#xa;Sql1GEqoEI6GpEIY4YVIsSEcGjyFAyp5ojhYSbsZxVryyzZPenqnIGeKsInHy44q3aEdG60lwgLd&#xd;&#xa;sipLScBSrYyDVxZV74qWJsnipaXBoxzSnFNYionrzHxtb+TrrPjiRQ1c9mvR/hldb7C6tieUcMPo&#xd;&#xa;a7elooopCaqNqNuYrpoZFla1BMiKeQQM4pNHv/7U0u3vfL8vzl3bc5xzVzNGaM0ZrN0bVv7UF2fJ&#xd;&#xa;8r7PcPB97O7b3rSzRn8qOaQsApJOAOtR211BdxeZbSrKmSNynjNS5oyaQnAJPQVz8ni63EsvkWV5&#xd;&#xa;cW8TbZLiKPKLWv8A2jajyN06Kbgfuw3Bb8KtZqpFqdtNfy2Ub5nhAZ12nAB96t5ozRRmjNZl9rdv&#xd;&#xa;b6Nc6jbFbmODqFbGTkDGav283n28UuNvmIGx6ZGakzRmiijNGfpWdp2q/b76/thFs+xyCPduzuyO&#xd;&#xa;uO1aIqG7u4LKLzbmVIkJChmOBk9BVK81j7LrVpp3k7jcKW37vu4OOlaeaTNLS0UUUUUUVT1b/kFX&#xd;&#xa;X/XJv5V4xXQxeGpTy04z9KvWumxQSLuyxrVYgDG3iqF200ifuTjaeQKrJb/aOJSx/GnFdh8tItqj&#xd;&#xa;vU8iKYsMc/SqL2cbZZyMelVLiyj2nyhgY7VUtIWMmwiraWxhuAcc1omSXgjgfStC1iZkDFs+1W0h&#xd;&#xa;B6ikeLafakVODwKztQUkimW8KyjFJPayRHjkUxI5x0Q4qQLIOWSrtk0bAhk2mpJgo+7SIBjJxTwc&#xd;&#xa;DipYpAD0p8ivIwKg1JFp7uclttWoNOEbZaQtV1FVBgUuRRupMmjmkKmmMprkPG+mC4+zT5IwSp4r&#xd;&#xa;h7u08g5ByK6P4c3Xk680JPE0ZH4ivUqWiiio5AxRwhAfHyk9Ae1cRoceoC88Q+fPCyruE4Cfefac&#xd;&#xa;EegpNMl12HwfFfWtzbwW9tEWWJo9xkUE5ye3er2qeKZYrDSxE0VvPfxiRpZVJWJccnHejRPEM8mt&#xd;&#xa;pp017BqEUyEpPFGUKMOcEdOgroNWv10zS7i9ddwhXdt9T0A/OsrSx4iuTbXlzd2ywS4d7YR8qh/2&#xd;&#xa;vWsnQY9XnfVo9MuYLVEvpSXePezNnp7CrCeKbz/hFUu2jja/e4+yrx8u71pb6/8AEOjvYi7uba4j&#xd;&#xa;ubhI2ZY8FM9R/wDXqzd3+sXPiW60qwkgijjhWTzZE3FM46evJqO11HWJzqWkzy24v7ZQ6zbfldDz&#xd;&#xa;09cVmaJqd1ovhWe8laKRPNZIowpB3k8kn0p0fii8tpYJZNTtb5ZGCyW8cRUoD6HvitO3vtZ1PV76&#xd;&#xa;C0uoILa2lADNFuLDGcda6Vl3RlG7jBxXIwS3nhJzb3US3GlyynZMhw0ZJ6EU3VV1C68ZWMcFxAFR&#xd;&#xa;DLFlM7V96s299reqate29pcQQW9tIFLtHuY+oFOi1q52a3OTHtsvkjOwAk47nvVWfUfEEOhRavJd&#xd;&#xa;WyrhSbcQ/eB981evNU1C81ODTdNkjtpDCJppWTftB7AUyx1PVl1u5sLowzC2g35jTHmHt34qLw/q&#xd;&#xa;mp6pcCQ6hbcMRNZtFtaMex6mulvFuHtJFtHRJyPkZxkA+9ef2C3Y8Cas00sbW+5gqBcNu3DJz6Gt&#xd;&#xa;O7v9f0zRLfVPPthbKsf+iiPOFOAPm9av6rqWqHxDa6bp0kMQnt/MLSJu2HJ5/SmXN/rDX8GiWc0L&#xd;&#xa;Xiw+bcXbx/KBnjC+vSptO1TUbfWJNI1ZopJjEZYZ4lxvHcEetP0DVrnUPC7ahOUM4EhBC4Hy5xx+&#xd;&#xa;FZ7eItQfQtJ+ziI6jqTFFZl+VcHBP8qla/1zT9b0ywvbi3uIrp2zKke0kAcjHb/69VdPTU59f12L&#xd;&#xa;TbiG3H2hWeWRNx6cACtjwtqd3qFvdRX+w3FpO0LOgwGx3xWf8QUuzpkLRSxrB5qBlZcktng/Sqmt&#xd;&#xa;HUIvEejKTBLemJlLkEJnd1xWta32o6feXEGq3Ed0iwGdXjTYQB1GKwR4rvpoWvE1OziOSUsjCxJH&#xd;&#xa;oW9a7TSr0ajp0F2F2mVQSvoauUUUUUUUVT1b/kFXX/XJv5V4xXpiQMenH1pslsVG7Iqs2c80xBCk&#xd;&#xa;RzkH2qJDsfdkkflUFy5mcDPTsKmWAiM4IqNYHz0AU+tRXjLHHsTG6qltAQ289vWppWWWVMDpV+BU&#xd;&#xa;GMCr8MQ/gPWraQt6in+QSOaQWae9VbrT42p9pYxIOOtWHslb0qOWzZY/l61XWCQD5lzU8NsO8dLN&#xd;&#xa;YF1+WoF02XpnipU0o/xGrUWnxqQTVpYUXoKkxjpRzSgEikxSgCiil6io261jeKIGn0aXafmQhhXn&#xd;&#xa;d9bEx7i9M8O3P2PXbObOAJAD9DxXtg5ApaKKKQ1iWeizW0usuZEP9oOWTGfl4I5/Oi10aaDwkdIM&#xd;&#xa;qeb5Lxbxnbls/wCNVJ/Dl0LHS2tLiOO/05NiswyjjGCDVvS7PWTf/a9UuoFVV2rbWwOz6kmtHUrK&#xd;&#xa;PUtPns5shJk2kjt71kaZZeIrSS3tZbqzksoSAXCt5jKO3pVrQdJl0oXwldH+03LTLtB4B7Gsz/hF&#xd;&#xa;JW8PvYPcItwtybmKVRwp7ZpLnRde1R7NtRu7NVtZ1kCQq2Hx3JPf/GoJ4tQfxzqD6ZNCkyW6ErMC&#xd;&#xa;UcYHBxyK1NG0a7guL2/1KaOS+vBtIjHyIoHAFQxeGWbw4+mXEy+YZDIkiDO05yKSDT/EUkkMV5fW&#xd;&#xa;sVvERlrdTvkA7HPArR0vTJLK/wBRuHdWW6lEigdVGMc1a1C3e7spYIp3gkdcCROq1z0mi69qUcVn&#xd;&#xa;qd3afY42BZogd8mOmc9K1I9IkTxCdQMieUsAiRO4pdC0qXTFuzNIjvcTGTK54Has8eHLn+xtQtPP&#xd;&#xa;iMt5KXLYOAM9Kuato8t7osNhDKkewpuLA4IXrWVqKbfEfmabqEFpexQhJEuVwjr2IPeovDsN5eXm&#xd;&#xa;sXUV4kk7YjS52fISPQelaFlouoya3FqWom0R4UKf6MCDL7tmuj7VzcPhy4j8LXmlNPGZbh2YOM4G&#xd;&#xa;SD/SrWs6LNqPhoaWkqJIFjXeR8vy4z/KntpEjeI7XUvMTy4bYwlMHJOTyPzqHVtGvG1SPVtJniiv&#xd;&#xa;Fj8p0lBKSr7/AOe1JpWjXg1R9W1eeOW7KeVHHECEjXvjPU9aoR6Hr1haz6bp1zZ/YJS215A3mRhu&#xd;&#xa;oGOKNa0u307SdKiS/S1uLNwLeWUHazHkg+mapvJf3Xi3RTe3VpNKpdvKtMlY1x94k9z/AErpNK0u&#xd;&#xa;Ww1PVLp3R1vJFdQucrgHr+dGh6VLpkmoNLIri6uWmXbngHsaXxHpcur6attDIsbCVXy3TANRaho8&#xd;&#xa;t3r9hqKyoEtlIZTnJ5zxU91pZutRaeQqYWtzCy9+T1rGg0XxDZ2/9n2l5aLZjhJmU+ai+npXT2sT&#xd;&#xa;QW0cTyNKyqAXbq3vU1FFFFFFFU9W/wCQVdf9cm/lXjFeoB2B5pzKWBY9KoyDrmqsqk1n3LeSVUH5&#xd;&#xa;m6c0yIkAsT8x71NbXJ87buyPetIDd1IAqlLbFpyQOPWo5OPkHWiGMhwQpNa8EahOVrRt4FwDirBj&#xd;&#xa;xQBTgKjmXKmo4ODzirlGM0zZzT1TFPCcUhXikpwpwHFLxikNANFKDRkCkLUZNNYcVUvY/NtJY/7y&#xd;&#xa;kV5pLAzKyOeVyOax3UwTjB5U5zXt2lXAutLtpxyHjBz+FW6WiikoxRijFGKKMUYoxRioEsrZLx7t&#xd;&#xa;YVFxIoVpO5HpU9GKMUYoxRigjNGKMUYqpe6VYahtN5aRTlehdckVNb20FrCsNvEkUa9FQYAqXFGK&#xd;&#xa;MfWjHFGKMUUYqK5tYLuEw3MSSxt1VxkGq9jpGn6czNZ2kULNwWVeT+NXcUYoxRiijFFLRRRRRRRV&#xd;&#xa;PVv+QVdf9cm/lXjFetCMMM4qKcFeB0NU5l9qrunGKzWtTc3MpPAUYH1qER7CVY8inxIiuCRV5WDY&#xd;&#xa;9KLiYRqEA5PeqbTRRgsx5NLFeIoXew59617O5jkQYOa17cgipmGRTQKULmhoyaYIQpyBUnSpEGRS&#xd;&#xa;4o7Um44pw5FNxQKdnigClNNzg0pNAoJqN3welAckVFLcxRLmSVFHqTisLVPFFlao6RSiWbHyqvPP&#xd;&#xa;1rhT9ruJnkd9u854qldW7xHLHPvXqPgG6+0+G4kJ5iYpXS0tFFFFFFFFV728gsLV7m6kEcKfeYgn&#xd;&#xa;FTRussayIcqwyD6inU1mCgkkADqT2qhp2t2GqSyxWU/nNF9/CkD8z1rQzVZ7+2S+SyaQC4dSypg8&#xd;&#xa;gVZpaQ1Wh1C2nupbWKUNND99cHirI5paKazBQSegGTUFlfW+oQGa1kEkYYrkAjkdetWKWiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiqerf8gq6/65N/KvGK9XEhxgGq9xdQwgtPMiAd2OKyZ/EFgJlijkaQswXKrw&#xd;&#xa;Pxq9JkKWxVMDy9+7u2aoXLK0wwDz1p3lsegqeLdwu05pJUcnkVBLbK3JU+9RLajzAcDB6VtWccaY&#xd;&#xa;AwD7VrwkKOtWQ2RTgKcPlpSeKYTTDnNPQ4qTdQKaeDTlNDHmkopwpCeaaWAbrQzqoJYgfU4qlNql&#xd;&#xa;nAcS3CKfTOaoz+JrKMHZvkPsMVhah4yuACLaBV92yTWWfEeqXAIkmKj0XioRLI43OzSH3JNUJ5HE&#xd;&#xa;pcqSB0609bmVsLEvX86s/wBi6vqCAxWUz577SB+Zrt/A2j6jo9vPHfxrGshDKA4JB/CuqpaKKKKq&#xd;&#xa;alqEGl2Ul1dNtjT0GST2A96yYvE8izQC/wBLubKG4YJHLIQRk9AcdM0+78SeVqlxpttYXFzdQqrA&#xd;&#xa;JjDAjOc9gM07T/EsF1aXs1xC9o9icTxvyV/x6Vg+IvEMmoeGbrfpdzb284URTvghvmB5HbpXZWH/&#xd;&#xa;AB4W/wD1yX+QrL1HxF9mvzYWVlNf3SKGkSLACA9Mk1WuPESXmh3zQWc/2mJTHNbkAPHkH5j7UngW&#xd;&#xa;4aTQYYTZyQrEnErAbZck5x9Kp+PNQubZrGKCO5UecrebG2A3X5PrTb/UWh8UabdNaTmV7VgIAuXy&#xd;&#xa;T0rY0zxD9svprK7spbK4iTeVkYMCvrkVBJ4qMX79tMuDp+7AuwRgjpnHXFb8ciyxrIhyrDIPqK46&#xd;&#xa;HUZLHxVq4t7Ka8mfbiOPAwPUmtux8SWlzp9xczK9sbXiaOQfMhqmvi4qEnuNKuoLGQ4W5bBH1I7C&#xd;&#xa;r2qeIIbB4YIIJLy6nG6OGHqR6k9hUdhryag89pPbS2d2iEmGXuMdQe9ZHh3V4dL0Ab1eaaW5kWKG&#xd;&#xa;MfM5z6V18LvJCryRmNiMlSc49qkooooooooooooooooooooooooqnq3/ACCrr/rk38q8YrqotP8A&#xd;&#xa;E16ALq+EC+gxn/x0CrMHhCDO67uJrh/UnAq/b+H9NtmDR2q5HPzMW/masyo0hAHApgsYpM+YN31N&#xd;&#xa;VrmzhicCJQrHqRTogiIwPJFRQKTIfkqWdGAyarBGlYDPFSm0wRnOKI4hG5cvkVo2su/BrSTGKkGR&#xd;&#xa;Th70EcUzGKOKN4p6ODShvmxQwzzSAgdTSO3FQy3UUIzJIqj3IFZ1x4j023zuukJ9F5qg/jS2J2wQ&#xd;&#xa;ySehPAqJ/Et3IMxpHGPzNUrjXL+Tj7UQP9kAf0qrLfSOn7yR3J9WrLnlbfkL+NSQPJM4Qkv6BQTW&#xd;&#xa;lHoF7csDFYSnPdhtH61pW3gy+fHmvBAO+PmNa9t4Nso/9fNNN7DCj9KtDwlomdxsQx95GP6ZrRtt&#xd;&#xa;NsrQAW1rDFjuqAH86s4oxRS0UUUVjeKNJfWtHktYmCyhg6Z6Ejsa5yHQL28nt45dFSzSOQPNLJeP&#xd;&#xa;IGx/dXdXQWOm3MPirUr+RFFvPFGsbZ5OAAeO1UH8P3Vw/iGOQLGl+UMLZzkjnnHvVO8g8SX+gHSG&#xd;&#xa;0yGIoio83nLiQKRjA7HiuxtI2jtIY34ZEVTznoK52ez1PR9bu7/TbRb6C8wZIjIEZGA7E9qXTtHv&#xd;&#xa;2Gq6hfJHHeX8RRYUPCDGACfXpWn4csprDQbO1uVCzRJhgCDjk1S8XaXd6pDZLZorNDcLI+WAwMGn&#xd;&#xa;3Om3Mnimzv1VTBFCyMd3c+1Nn0mebxLLdFQLZ7UxbgeQT7Vz3/COXoj/ALPTSFbBx9se7fYy567N&#xd;&#xa;1d1aQC2tYoBjCKF46VzT2utafr9/f2tjHdQT4ATzArH3BqO38OXl9ZalJqG23ub5gyxochMdM0lx&#xd;&#xa;D4i1HThpE2nQwJgJJdeaCCo9F9asXmkX+nahbahpUS3TRQiGSF22lgO4J6U6y07Ub/WDq2pW6WpS&#xd;&#xa;IxwwK+4892IqhY+GL+wtReWqpHqiSsQrMGWRCenPA/CuwtXlktkaeIRSkfMgYHB+tTUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUVT1b/kFXX/AFyb+VeMV6xtHpRikNAi3DrUQGwsDVO5Q+Zk9COKijZd/LdqlRk8&#xd;&#xa;zjFFy6mPFUtjKQVOamOWAzkevNKkas2CcCr9tEiuMNWkpAFP3UFqTcTTCc9aT8aTI7HNOWVE+8yr&#xd;&#xa;9TVa61aytvmkuFGPQ5rJvfGljB8sSSSk9MDArLuPGdzIh8iFI/cnJrMn17UpwS90wB7LxWTLPJM+&#xd;&#xa;55GY+5zTR7D29KsQQyMQUJ68Vrw6XqNyn7m2lbPcLgfnWhZ+D9VlOZzFCP8AafJ/IVr23guEYNzd&#xd;&#xa;PJ7KoH+NaMHhXSIiC1t5resjE/p0rUgtbe2GIII4h/sKBUuKKMUtFFFFFFFFFJijAoxRijFFFGKK&#xd;&#xa;MZoxRijFGKMUYoxRijFGKKWiiiiiiiiiiiiiiiiiiiiiiiiqerf8gq6/65N/KvGK9aIppOKAM1Ko&#xd;&#xa;wKqT8Nmql55jREBDmuaur64sQTNg56YNUF8QuZcnIz6VcttSaWcFnJFaq3Adc5pBLJvyhH40+OaV&#xd;&#xa;ptrMKvWz4YktWrGx2g1KHH/1qDIB14+tVZtVs4M+ZcIMdgc1nz+JrRDiJJJT7DFZ83ie5ORBbqv+&#xd;&#xa;81Zs+r6vcEgzGNT2QYrOke4aUPLPK5z/ABNxTrmfdFjGSD1rOb53ycj8antrS7uHC21vLMT/AM81&#xd;&#xa;JrbtvCWs3Q5thCD3lcD9Bk1pWvw8kJBvL9VH92JM/qf8K2LTwPo0BBkjkuCO8j8fkMVtW2m2VmoF&#xd;&#xa;taxRY/uqM/nVrFFGKKWiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiqerf8AIKuv+uTfyrxivWMnNMlODxUycpUiYIqG4Udap3LhYeetcjrUX26ZYwcIuSTisOezWEKd&#xd;&#xa;wx6GtW3jQQLtX8avWsi+XjPSrQK4yKikdVGdwXHfNQx6vDbMdzmU+i81ZHiiVlxDa8ertVefWtSn&#xd;&#xa;HE4iHooqn5k8vM88kn1agBR25pAVzjirlrEZMCNGf/dBNakei30/3LVhnu/y/wA6lTwZczNme4ii&#xd;&#xa;HooLGrsHgbTVwbiSac+mdo/StW08P6TZYMFhCGH8RXcfzNaIUKMAYA9KXFFFLRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRVPVv+QVdf8AXJv5V4xXrJYVHI64&#xd;&#xa;p8bArUkbYFJIdw4qjOoKkEjiubvUIumAwFI71R1OK2is9+4M4p9jfW7WihYyT0Paqk1zcJvECKmD&#xd;&#xa;9azpry6Y4kmf8OKrec+7liRmtmBFaAHcOnpSxvubYqlm9AM1p22j6ncY8uzl57ldo/WtS38IX0n+&#xd;&#xa;uliiHpnJrRg8F2inM9xK/soCitO28O6VbEFLRGb1clv51pRxJEu2NFQeijFOwKKKWiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiqerf8AIKuv+uTfyrxi&#xd;&#xa;vVRESeW4p5hUEHt60yWeC3GZJUT/AHjis+TxBp8ZKrKZD6KKpy+JVGRHD9CzcVXOsz3AbBVQfQVl&#xd;&#xa;3z7yGkkLEVTumEtqwA61HpUZCnd93PFasdnNOcQW0khP9xCaR/Bms3rjbbpAv96VwP0GTWjZfDbn&#xd;&#xa;N9f8f3YV/qf8K6Sy8JaRaIF8l5sd5XJ/TpWrb2VrajFvbxRf7iAVPijFFFLRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRVPVv+QVdf9cm/lXjFdTP&#xd;&#xa;4rvHkAgjRF79Sap3eq6hcld08gHovFUZzMybnJZvUnNV4hIWLH731q5b2k8/EUTyH/YUmtK28M6z&#xd;&#xa;M3yWjRj1kYKP8a04fA15IQbq8ijH+wCx/pWpbeCdOjA895p/qdo/Sti00XTbIf6PZxL7lcn8zV0A&#xd;&#xa;AYAwPajtzRS0UZozRRRmiijNGaB0oooozRmiijNFGaKM0E0UZ5ozRRmjNFFFFGaKByKWikooooo7&#xd;&#xa;0UZoozRS0UlFFFGaKM0UUd6BRRRRRRS0lGfSgUtFJRRRVTVv+QXdf9cm/lXi+f8AaWoRczDpI1O+&#xd;&#xa;2XH/AD1ag3tyRgytRFfXML7klIPqQD/Or6+J9aQYTUJVHoMAfypf+Ep1z/oJz/mKP+Ep1z/oJT/m&#xd;&#xa;KP8AhKtc/wCgnP8AmKP+Eq13/oJz/mKP+Eq13/oJz/mK9D8DatLqmjE3MpknicqzHqfSpPG11dWW&#xd;&#xa;gPcWcrxSrIvzL1x3rgLDxDrt3fwW66lOTI4XGRXryAqignJAwSe9cL4+1DVNLvbeSzvJYYZExtU8&#xd;&#xa;ZFUPB2r6xqmvRRT380kKgs6k9RXpWeKzNF1ZNVW5ZMfuZmj49ulN8TG5TQLyWzleKaJPMVk68HJ/&#xd;&#xa;QGvLv+Ep1zoNSn/AivW9KSdNLtluZGkn8td7N1LY5/WsDx9c39jp0F3YXMkO2XY+zuCOP5frXH6P&#xd;&#xa;ruu3+rWlr/aU5EsqqeR0zz+letdqzLTVkudcvtOXGbVUbPrkc/lxVnU0mk026W3cpMY22MOoOOK8&#xd;&#xa;i/4SrXf+gnP+Yr1Lwybp9AtJb2V5Z5U3sz9eTkfpVTxtNeW2gvdWM8kMkLqzFD/D0P8AMV55B4k1&#xd;&#xa;64uI4F1KctIwQDPcmvYY1KRqrMWIABY9T71xfj/XbrTpra2sbhoZCCzlfTtXHf8ACVa7/wBBOf8A&#xd;&#xa;MVpeHte1q/1y0t5NQndHkG5Seor1WuC8e6jqul6hC9peyxQSp91TwCK5yz8Ra7d3kMC6lPmRwvUd&#xd;&#xa;69eiVkiRXYswUAk9zXP+OLm7s9DNxZTvC6OMlT2Nedf8JTrn/QTn/OvWNCmkuNFtJpnLyPGCzHqT&#xd;&#xa;WL4+1C707TIJLOdoXaTBK9xiuc8H69qt74gggur2WWJgcq2MV6ZXN+M4dUSxF7pN1NG8AzJEh+8v&#xd;&#xa;qPpXnv8AwlWuf9BOf8xXV/D/AFfUNS1C7S9u5JlSIFQ3Y5rtrtilpMykhgjEEduK8d/4SrXP+glN&#xd;&#xa;+dex25LW0RYkkoMk9+KkzRmsvWtOur2EtZahPZ3C/d2nKn6ivNrvXvEWm37291ezCSJhuU4wf/rG&#xd;&#xa;vVNOvI7/AE+C7iOUlQP9PUVzXj+51Kwtba8sLqWFAxjkCHjnkH9D+lcN/wAJTrn/AEE5/wA66fwL&#xd;&#xa;qGratqbvdXs0kEK5IYjBJ6V3N5cJaWstxKcJGpYmuE8Ia/qGqeJnS4uXaBldljPQelehV5LrPiTW&#xd;&#xa;bfV7uKLUJkRJCFUEcCu/8HXdxe+HoZ7qVpZWJyzda2884ozXI+NdXutKvdOa3mZI2b94o6MM11kT&#xd;&#xa;iWJJF6OARXBePNS1XS9UiNpeyxQSx5CqeMjrVHwhq+sap4ht4Jr+Z4Vy8ikjkAfT1xXph6V5j4s1&#xd;&#xa;jWdL8QXVvFfzJESHjUEYAI+n1rZ+H99qWpzXk19dyzRRqEUMRjJ6/wAq6+8uFtLOa5k+5EjOfoBm&#xd;&#xa;vIG8V64zEjUZlBOcAjAqS08T61JeQI+ozFWkUEEjpmvYh0rJ8SWt/c6ax0u5kguo/nQIfv8AtXmD&#xd;&#xa;eKNeRiralcBhwQeoNbfgvXtUv/EcEF3eyzRMjkqx44U16VXkWqeJdZh1S7jj1GZUSZ1UAjgBjXon&#xd;&#xa;hG6nvfD9vPcytLK2cs3U1sk0GuK17Vb638Z2VpDcukD7dyDoc12tAormvHd/dafoyzWczwyeYBuW&#xd;&#xa;vPf+Ep10f8xOf8xR/wAJVrv/AEE5/wAxR/wlWu/9BOf8xTZPE2tSoUk1GdlYYIJHNZ/2ib/no351&#xd;&#xa;DRRRRRRRRRXZ/DW98rVZrQnAmTI+oruvENqL3Q7uDqWjJH1Fec+AbI3PiJHZcrbqXPse1esVyvxD&#xd;&#xa;svtOgGYD5oHDfh3rK+GNnxd3jD0jU/rXYa5dix0e6uCcbIzj61w3w2vyupXNq5/1y7xn1FeiyxrL&#xd;&#xa;C8TDKupUj2IrxvSdLaXxVBpzqfkuNr/RTz+gNezgYFZXiey+3+H72ADLeWWX6ryP5VwPw5s/tHiA&#xd;&#xa;zkfLbxFvxPA/rXqMjrHG7scKoyT6CvLPC+sMfG32l2IW9kdD/wAC+6PzxXquMivGNR0tk8VTaag5&#xd;&#xa;a52IPZjkfoRXsscaxRJGnCqoUfQVX1O1F7ptzasM+dGy/iRxXlfguxa48U28brxATI4Pbb/9fFev&#xd;&#xa;ZrxvxdqA1HX7iZGzGuFT6CsWun+Htv53iNXPSJC1erFgoyTgCuW+IVj9q0EzgZa3bd+HeuR8AWP2&#xd;&#xa;vxAkrDKW6lz9e1er7gCASMnoKyPFcH2nw5eoBk7Mj8K8Yr23w5/yL9j/ANchXP8AxN/5A9v/ANdf&#xd;&#xa;6VyfgT/kZ7b6N/KvXsnPSooZo7lC8Z3AMVP1Bwf5V5d428OHSb37VbJ/oc54A/5Zt6f4Ve+GH/IT&#xd;&#xa;vf8AriP516Fe/wDHlP8A9c2/ka8G7V73a/8AHrF/uD+VcR8RtRvbG7shZ3c0AdGLCNyueR6Vz+l+&#xd;&#xa;NdYsplM1wbqHPzJKMnHsetepafeRahYw3cDZjlUMPb2rkfiVpiSWMGpIuJImEbkd1PT9f50z4a6p&#xd;&#xa;5lrPpkh+aP8AeRj/AGT1H5/zrrdYsE1PTJ7SQZDjj6jkV4jPE0E8kTjDIxU/hXqvgLTvsWgJK4xJ&#xd;&#xa;cHefp2qn8RtU+z6bHYxt885y3+6K5z4d/wDIyj/rk1eq968R8Qf8h29/67NXpngL/kV7f/eb+dR+&#xd;&#xa;P7ia20DfbzSRP5ijchIP6V5p/bOqD/mJXf8A3/b/ABqG5vbq62m5uJpsdPMctj869b8G3327w5bO&#xd;&#xa;Tlox5bfUVk/Eq083SYbkDJhkwfoao/DCz+a9vWHpEp/U/wBK9AFee/E+yAmsr0D7wMTfhyP5mtz4&#xd;&#xa;fWf2bw1HIR81w7SH6dB/Kj4g3v2Tw3JEpw9y4jH06n9BXk9TWP8Ax/2//XVf517wDwPpUSTJLJLG&#xd;&#xa;py8RAYemRkfzrgfH/hwRsdXtEOxv9eoHQ/3v8ayPh/8A8jXb/wC4/wD6Ca9arwzWP+Qzff8AXxJ/&#xd;&#xa;6Ea9U8D/APIr2v4/zrI+I95c2iWf2a4lhLE58tyufyrhf7Z1T/oI3f8A3+b/ABqJtQu2ukuXuJHn&#xd;&#xa;Q5WR2JI/OtJPFeumRQdSlwSPT/CvX7UlraJmOWZASfXiuN+IGr6hpk9otjdPAHUlguOea4e+13U9&#xd;&#xa;Rh8m9u3mjzna2OtZ9JRR3paSiiiiiiiiitDQrw2Gs2txnAWQZ+le2/LLH6qw/Q1y/gzSvsF1qkjD&#xd;&#xa;BM5RfoOa2NS1RbG9sbdsZupNnPbip9UtheabcwNzvjI/SszwXZGx8PQoy4d2LN+dZnxJvvJ0mK0U&#xd;&#xa;4ad8n6CuE8O3hsNdtJ84AcA/Q17WDuGR0PQ1yunaR5XxA1C72/IIQ6n/AGn4P8mra1zU10nTmunA&#xd;&#xa;IDomD7kA/pn8q0CAy+oI/OuX8FaV/Zr6qSuP9KMak/3V6fzq54zvfsPhq6YHDygRL9W4/lmvIYJW&#xd;&#xa;gnjmQ4eNgwPuDmvdbO4W7soLmM/LKiuPxGa5q40nzPiJb3e3KfZjKT/tD5R/MVvaxfDTdKubzg+T&#xd;&#xa;GWAPc9h+eKsW0y3FtFMn3ZEDg+xGa5vw7pP2PxVrdxtwpZQn0b5j/StjxBejT9DvLrOCkZC/7x4H&#xd;&#xa;6kV4kTk5NFd18MIM3F7PjooUV2XiC5Fpo80xOAu3n8RVi7hTUNMli6rNGcfiOK5n4e6YbOyuppB8&#xd;&#xa;7ylBn0XitK61HHi+ysQePJdm+p6Vr30XnWU8f96Nh+leFSrsldP7pIr2rw5/yL9j/wBchXP/ABN/&#xd;&#xa;5A9v/wBdf6VyfgT/AJGe2+jfyr17FcTpOuJp/jDUtMuG2wXFwWjJ6K57fjXWajYw6jZS2tym6KQY&#xd;&#xa;Pt7j3Fcf4K02XR/E+pWU3JWEFT/eXPBrtL3/AI8p/wDrm38jXg3ave7X/j1i/wBwfyrz74o/8fmn&#xd;&#xa;/wDXN/5iuGr1j4eszeF4g3QSOB9M/wCOas+NlU+FL7d2VSPruFeX+H9SbSdYtrvJ2K2HA7qete1q&#xd;&#xa;ysoZTlWGQR3FeZ+KdDY+MIook+S9YMMD869KgiWCCOJBhUUKPwryHxneNd+JLrLblibYuPQVd+HX&#xd;&#xa;/Iyj/rk1eq968R8Qf8h29/67NXpngL/kV7f/AHm/nXQOquMMAw9CKQQxf880/wC+RXmnxJRU1iAK&#xd;&#xa;oUGLsMd6vfDK95urJjzw6j+ddZ4ltPtugXkIGW8skfUVF4TsRp+gW8eMO6iR/qR/9arA1RD4hbTO&#xd;&#xa;Ny2wmz/wLGP5VQ8cWJvfDc4VcyRMsi/ng/oTWvp9sLLTra1UYEUap+Qrz74mXwl1O2slPEEe9vq3&#xd;&#xa;/wBYD864s9amsf8Aj/t/+uq/zr3fsPpXF6nra6J47bzj/otzDGsv+yecN+FdjIkdxCyOFkjkUgjq&#xd;&#xa;GBrg9M0Q6F4/t41ybeZJGhJ9NpyPwr0CvDNY/wCQzff9fEn/AKEa9U8D/wDIr2v4/wA63XRHwHUN&#xd;&#xa;jpkU3yIf+eSf98ivI/GwC+JrkKAAMcCsOL/Wp/vCvd7T/jzh/wCua/yrgfih/wAfNj/uN/OuDooo&#xd;&#xa;o70tJRRRRRRRRRS5xXtHhe9+36DazE5bZtb6itRY1TO1QNxycdzXmvjvVG/4SWBY2IFng8euc16L&#xd;&#xa;ZzrdWcM68rIgb8xUyoqKFUYA6AV5X8Qr37Tr5hU/LAgX8e9csCQQR1Fe1+Hb0X+h2k4OWKAN9RxW&#xd;&#xa;iEUOzhRuYAE+oHT+dcJ8T77EdnYqepMrj9B/Wun8L339oeHrOcnLCMI3+8vB/lWqqKu7aoG45Pua&#xd;&#xa;4D4n3vz2dgp6ZmcfoP61wNer/D+9+1eHEjJy9s5jI9uo/Q/pXS+WvmCTA3gbc+1cj8Sr7yNHhtVP&#xd;&#xa;zXEuSP8AZXk/rtq74EvftnhqBScvbkxH8On6EV0QRQxYABm6kd64z4mX3laXb2anmeTc3+6v/wBc&#xd;&#xa;j8q86htbi5BMEEsu3rsQtj8qjZSpIPBHUGvTfhtB5eizSkY8yXr9Kn+Ic5h8OMgPMkiir3hC++3+&#xd;&#xa;HrVycug2N9RWtFFHboRGoVcknFeZxar9o+ISXGfk8/YPp0r1A+/Q14jr0H2fW7yLGNsp4r13w3/y&#xd;&#xa;L9j/ANchXP8AxN/5A9v/ANdf6VyfgT/kZ7b6N/KvXq8Z8WEjxRqGP+exrvvBPiL+17H7Ncv/AKZA&#xd;&#xa;MHP8a9m/xrfNnGdQS9X5ZFjMR91JB/mKfef8eU//AFzb+RrwbtXvdr/x6xf7g/lXn/xR/wCPzT/+&#xd;&#xa;ub/zFcnpukX2qTLHZ20kmTy2PlX3J6V7DomnLpOk29kpz5a/M3qxOSfzrn/iPfpBoiWe795cOOO+&#xd;&#xa;0HJP54rzA+les+A9VOo6CkTtma1Plt9P4T+XH4VsXNhFcX9tdsPnt92PxqPXtQXTNIuLonlVIX69&#xd;&#xa;q8UlkaWVpHOWY5J966b4df8AIyr/ANcmr1bvXiPiD/kO3v8A12avTPAX/Ir2/wDvN/Om+O7y5stC&#xd;&#xa;820meGTzFG5Dg4rzj/hI9a/6Cl1/38NU7y+ur6QSXc8kzgYDOcnFang+9+w+IrV2OFkOxvoa9iKh&#xd;&#xa;lKsMg8GhVCqFUYA4Ary2HXB/wsL7du/ctOYfbZ90f416k6LIhVwGU8EGg9DXievXh1LXbu5XLCSU&#xd;&#xa;hPoOB+gFVJrS4twDPBLEG6F0IzRY/wDH/b/9dV/nXvA6D6V5X8Rj/wAVN/2wT+tbPgDxH50Y0i7c&#xd;&#xa;b1H7hmP3h/drsbmzS4ntpzxJbyFkb6ggj9f0q12rwzWP+Qzff9fEn/oRr1TwP/yK9r+P86y/iJqN&#xd;&#xa;5YJZmzupYCxO7y2xmuI/4SPWf+gpdf8Afw1Qubma7mM1xK0sjdWY5JpkX+tT/eFe72n/AB5w/wDX&#xd;&#xa;Nf5VwPxQ/wCPmx/3G/nXB0UUUd6Wp/sF5/z6T/8Afs0fYLz/AJ9J/wDv2aPsF5/z6T/9+zR9gvP+&#xd;&#xa;fSf/AL9mj7Bef8+k/wD37NH2C8/59J/+/Zo+wXn/AD6T/wDfs0fYLz/n0n/79mj7Bef8+k//AH7N&#xd;&#xa;H2C8/wCfSf8A79mj7Bef8+k//fs16H8N5J0srm0nhkj2MHUupHB+tdk77EZsE4GcCvFtVjvb3VLm&#xd;&#xa;5a1nzJIT/qz0r0nwNPLJ4fjinjdHhJT51IyO3Wugkfy42fGdqk4FeJ6jFe3moT3DWs5Mjk/6tvWq&#xd;&#xa;32C8/wCfSf8A79mvRfhxJOunT2s8UieW+5d6kcH612VeTeNPtd/4kumW2maOMiJCEOMDr+ua6P4b&#xd;&#xa;Szx2l1ZzwyxhHEib1IHIwRz9K7bNeR+L/td/4kvJVtpiiN5SYjOMLx/PNYn2C8/59J/+/Zrsvhs9&#xd;&#xa;za6jc2s0EqRzRhgWQgblP+BP5V6LXmPxCN1ea+I4reZ47eMKCEJBJ5P8x+VXPhq9zb3l3aTQyoki&#xd;&#xa;CRSyEAEHH9f0r0KvL/Hpur/xGY0gmaKBFjBEZIyeSf1/SvRNLsLfT7GO3tkCoo9ME+5rh/iLpg+2&#xd;&#xa;W9xbW7tJID5mxSc47nFdR4OtmtfDdqjqVYgsQRg81jfEkTy2lpDDFJJ85Y7VJ7VF8NpLiJLq0nhl&#xd;&#xa;ReHUshA966vW7h7XR7qaNWZ1jO0KMnNeQWNvexajBMbWfKyhifLPrXtqHcit6jNeVeONOuP+Elne&#xd;&#xa;KCV1cBsqhIr0Xw6rJoNkrqVYRDIIwRWD8SIZZtJgEUbyES9FUntXLeCLS5i8S27SW8qKAeWQgdK9&#xd;&#xa;Yrx7xVZ3UniXUGS2mZTKcEISDVPTv7S02+iu7a2nWSM5H7tsH2PtXsOlXy6lp8V0I3iLjlHXBU9x&#xd;&#xa;+dTXgJs5wOT5bfyNeHfYLzH/AB6T/wDfs17nbDFtED12D+VK8MchBkjRyOhZQcU5UVRhQB9Kqarq&#xd;&#xa;MWl2jXEqSyY+6kaFix9OK8l1u51TWtRa7uLScdkQRsQi+lZ32C8/59J/+/ZrpPA1xdaXrYEttOIJ&#xd;&#xa;1KP+7PB6g/59a9TxXBfEe5uZngsIIZXRRvcqhIJ7CuG+wXn/AD6T/wDfs103w+tbiLxGGlglRfKb&#xd;&#xa;lkIFeod68Y16yun1u8ZbaZgZTgiM816P4GjeLwzAsiMjAtwwwetb0kaSLtkRWHowzTPslv8A88Iv&#xd;&#xa;++BXDfEizYmz+y2xPXPlx/4VxMVpexSK62s4KkEfuzXtemzG4063mZSrOgJDDBBqLW7h7TR7ueJW&#xd;&#xa;aRIjtCjJz0FeMCyvQdwtZ89j5Zr2rSLl7zSrW4kVleSMFgwwQcc/rUPiG4ktdCvZYlZpBEQoUZOT&#xd;&#xa;wP51xHw60zdqdxPd2zq8SDy/MQgAk8nnvXe6rZQX+nT29wm9GQ8dwcdR7141ZWN2L63JtZwBIvPl&#xd;&#xa;n1r3AdB9K8w+IVrcTeJN0UErr5KDKoSO9c3Da38EqSxW9wkiMGVhGcgjv0r1zw1qsmraWktxE8Vw&#xd;&#xa;nyyqyFcn1H1rXrxPV7K7bV71ltZiDO5BEZ5+Y16f4KjePw1bLIjIwzkMMGtuSKOXHmIrY6bhmoza&#xd;&#xa;2/8Azwj/AO+BXm3xAspW11fs9s5Tyh/q4zjP4VzUdjeeYv8Aos/Uf8szXt9oCLSEHg+Wv8q4X4l2&#xd;&#xa;801zZGGGSTCNnYpOOa4f7Bef8+k//fs0fYLz/n0n/wC/Zo+wXn/PpP8A9+zR9gvP+fSf/v2aPsF5&#xd;&#xa;n/j0n/79ml+wXn/PpP8A9+zX/9k=</binary>
<binary id="image5.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAFcAj8BAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKjuJfJt5Zcb&#xd;&#xa;tiFsZxnAzWNaprF/aw3kWqQwR3CLKsRtN5QMMhd24ZxnGcDNS/Ydc/6DUH/gCP8A4uj7Drn/AEGo&#xd;&#xa;P/AEf/F0fYdc/wCg1B/4Aj/4uj7Drn/Qag/8AR/8XR9h1z/oNQf+AI/+Lo+w65/0GoP/AABH/wAX&#xd;&#xa;R9h1z/oNQf8AgCP/AIuj7Drn/Qag/wDAEf8AxdH2HXP+g1B/4Aj/AOLo+w65/wBBqD/wBH/xdH2H&#xd;&#xa;XP8AoNQf+AI/+Lo+w65/0GoP/AEf/F0fYdc/6DUH/gCP/i6PsOuf9BqD/wAAR/8AF0fYdc/6DUH/&#xd;&#xa;AIAj/wCLo+w65/0GoP8AwBH/AMXR9h1z/oNQf+AI/wDi6PsOuf8AQag/8AR/8XR9h1z/AKDUH/gC&#xd;&#xa;P/i6saFqf9saRBf+T5Pm7vk3bsYYjrgelaFFFFFFFFFFFV7q+s7Lb9ruoLffnb5sgTdjrjP1FV/7&#xd;&#xa;d0j/AKCtj/4EJ/jVO/8AFui2Hl7rxJt+f+PdhJjGOuDx1qvD450SaZIhNIpdgu502qM9yewrattS&#xd;&#xa;sbyQx2t7bTuBuKxSqxA9cA+9WqKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKr6h/yD7n/AK5N/I1X&#xd;&#xa;0D/kX9N/69Yv/QBWhRRRRRRRRRRRRRRRRRRWB4F/5FGx/wC2n/oxq36KKKKKKKZNLHBE0s0iRxqM&#xd;&#xa;s7sAAPcmudl13UdUjZdA099rRh1urkFFzu5ABGG4Hr39qItD1e9ngutT1maPCYktrXdGvf8AiDdc&#xd;&#xa;nrjtiprrwhp97t+1z31xszt825Z9ueuM/QUln4M0WznEq23mkAjbMd6/ka0P7C0j/oFWP/gOn+FQ&#xd;&#xa;3Om+H7OMSXVlpkCE7Q0sUagn0yR7VkSaT4fubqV9J1aGyvZ12J9juVAHTgIpGemcViHxF4l0B44t&#xd;&#xa;St3lt4m2F3U/vO+BIRyf8K9FhljniWWGRJI2GVdGBBHsRT6KKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKr6h/yD7n/rk38jVfQP+Rf03/r1i/8AQBWhRRRRRRRRRRRRRRRRRRWB4F/5FGx/7af+jGrfoooo&#xd;&#xa;oorE1fW5Le8i0/TIUu79iC8eTiNMdWI+71Xr61Fp2hXMs8N9rd491cLFtMPCxqc56LgN36jv7VvI&#xd;&#xa;ixqFRQqjoAMAU6imySJFG0kjqiICzMxwAB1JNcRqPiW8128m0jQNgDoQZmOCR/EBn+dJa+A5rqyj&#xd;&#xa;/tPUbgTZJaMNvUHJxjPtXOeIPDN7od4z26Ty2qgMtwqn5eBncR05zXpwFjr+kqzx+ba3C5AbIOP5&#xd;&#xa;iuf0WQ+FryTSdQfbZysZLe6kOF6fdJPA+709/euvoooooooooooooooooooooooooooooooqvqH/&#xd;&#xa;ACD7n/rk38jVfQP+Rf03/r1i/wDQBWhRRRRRRRRRRRRRRRRRRWB4F/5FGx/7af8Aoxq36KKKKK4H&#xd;&#xa;xX4nmvrn+xtE3s7NteRAMucfdX/Hg5FdR4e0aHSbJThnupFBmlkJLMfT8OB+Fa1FFFIyhlKsAVIw&#xd;&#xa;QRwRXL+JPDTSsmp6Ni3v7f5gF4EmOQMdM8dMYOeaXRfGVjcWe3U5ltLuI7JFfgMfUf561BN8QdFJ&#xd;&#xa;eN7a7kXOD+7Qhv8Ax6qvwzuZGtruBlmZQwYOeUX/AGevXnPTtXX6hp9rqdq1tewiWJsZBJB4Oeo5&#xd;&#xa;HSqehXV6ySWerNH9uhPJTpInZ+g4JyOnataiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiq+of8g+5/65&#xd;&#xa;N/I1X0D/AJF/Tf8Ar1i/9AFaFFFFFFFFFFFFFFFFFFFYHgX/AJFGx/7af+jGrfoooorG8Ua3Foum&#xd;&#xa;SOZCtzKjLAFAJ3Y4ODxgEjNZ/gnQxZ2n9p3KOL+6Db93G1S2cYHHOAa6miiiiiiuU8S+DY9Zv47y&#xd;&#xa;3kEMruouCxPzIBjI68gAYHArb0jR7LRoGisotgfBc7idxA68nitCiuW8ZWz2jW3iC1Kxz2RCyP1Y&#xd;&#xa;xk7cAHj+M+nWt7TdQt9Uso7u1bdG46Hqp7g+4q3RRRRRRRRRRRRRRRRRRRRRRRRRRRRRVfUP+Qfc&#xd;&#xa;/wDXJv5Gq+gf8i/pv/XrF/6AK0KKKKK5nQ7+6uPFusWs07vBDjy0PRee1b97t+xT78lfLbOOuMVh&#xd;&#xa;+D5rGHwyZrbzorWNnZjOwJGOScgDiq0PjdblbmS10u5nitgTJIjDCrzz+hq9NqSav4LvL6ONo1lt&#xd;&#xa;Z8KxyRgMP6VheHNfn0vwrAW0m5lt4Q5M6sApG8/44rd8Saq8XhqS900vL5g+WWI/cH976cY/Gk8J&#xd;&#xa;and6hpsIu7aZSIwftEhGJTntW/RRRRRWB4F/5FGx/wC2n/oxq36KKKK4CzebxP42Mz+eLKwkDooI&#xd;&#xa;xGwx+jFDXf0UUUUUUUUUUVFcxGa2liBwXQrn0yK4rwAbi11TUtLknLxWpKhR03BiCR9cV3VFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFV9Q/5B9z/wBcm/kar6B/yL+m/wDXrF/6AK0KKKKK4nTryLS/GOsz&#xd;&#xa;XgmjjlICMIXcN/3yDXRjUrXU7C8Fo0jlIjkNE6dQcY3AZ6dqwvDFpcSeAru1WJhPKkyIjfKSSCB1&#xd;&#xa;rP0m/g0/wVfadd+dHdGOddnkuRkggfMBj9a0tDUt8M3VQSxtbgAAck5eorOGUfC9ojE4k8qT5Npz&#xd;&#xa;/rD2q3b2VxdfD1LSGIm4e22qh+U5z79Ks+D7yGTRbWzHmCeCIeYrRMuOfUjB/Ct+iiiiisDwL/yK&#xd;&#xa;Nj/20/8ARjVv0UUVgeNb2Sx8NXLRKhMo8ltwPCsCDj3qTwno8Wk6PCAqGeVQ0sijG/klc/QNitui&#xd;&#xa;isibxLpUSXjfag5tADKFRjjJwOcYOSQOKhtvFelz6M+pGYRrHw8ZzuDccYxz1HI4qC48a6VDpMV6&#xd;&#xa;HLySj5YADuyMbhnGBjPXvjijQ/GWn6vO8DKbWQDKiU8N689Bjjr61n+JfHFtDatBpEoluH3Iz7WA&#xd;&#xa;i7ZGcZPp16VS8GeKbqS5uo9Wuw1vHA03mSfeGCOB68E8YzWynjzRmv5IWkdIFXK3BRiHPHG3GR1P&#xd;&#xa;X0q9aeK9EvbqO2tr3fNIdqr5TjJ+pFbVFcQv+hfE5Ibb91HcoWmVejnYzZP48129FFFFFFFFFRXE&#xd;&#xa;RngeISyRFhjfGQGX6ZBrj/E63uj/AGH7NrGoN9omEbeY6nA9sKK6O00qS2uUmbVNQnC5/dyupU8Y&#xd;&#xa;5woqW21Wyurua0hnzPA210ZSpzz0yBnoemaVNUs5NRawSbdcoMsqqSF+pxj8M1UTxNpEgm2XZYwM&#xd;&#xa;FkCxOSCc9sZPQ9Ks6fq1jqTSLaTb2j++rIyMPwYA1BP4i0uC5kt3uHaSMgOI4XcAkZ6qCKu2V9ba&#xd;&#xa;hbrcWkyyxsMgjj8weRViuN8SXupL4us7GyvHhje381kXo20uT+YXFaPiHVJf+ENl1GzdoJSkbDB+&#xd;&#xa;ZCWXIPvyRWhp16F8PWd5eS8m2jd3PJYlQTwOp9hUK+JtJMiIbiRS7BFL28ijJOByVwK0p7iK3tpL&#xd;&#xa;iV9sMaF2bGcKBknj2rNHibSWgjmS5d45ASpSCRuhxyAvHTvTx4h0trKO7S63wyHC7I2Zu/VQMjoe&#xd;&#xa;SKsafqlnqaO1nN5nlttYFSpB47EA96qS+JtJikkjNy7GM7XKQSOAfqFIrRtLqC9t0ntpVkicAhh7&#xd;&#xa;jP4delN1D/kH3P8A1yb+RqvoH/Iv6b/16xf+gCtCiiiiiiisa58Pm6SWOXV9TMcoKsnmJjB6j7vS&#xd;&#xa;tGxs4NPs47W2TZFGMKP1P61YoooooooorA8C/wDIo2P/AG0/9GNW/RRRXLeLIpr/AFfRtOixLC8p&#xd;&#xa;kuYdwAKKU5P4E106IsaKiDCqMAegp1FVtRhnuLCaK0m8id1wkn90+teP6VpurX5urTT4nYlR58ZZ&#xd;&#xa;U4ByM7iO4rRtPAutzXKRz2628ZzmVpEYLx6A59q6Kz+HNmIB9uu52mycmEhVx9CpNT/8K60j/n5v&#xd;&#xa;v++0/wDiagvfhzZmA/YbudZsjBmIZcfQKDWf/wAK3vP+ghB/3wawNW0R7bxG+kWW6ZxsVNzAFiUB&#xd;&#xa;PPA6k13+geDLLSJorqR3nulXHzEbFb1UYz+veumorB1O1gTxRo90sSieR5VZ+5AibAreoooooooo&#xd;&#xa;oorkPH//ADCP+vof0rr647XY4tK8Z6drV1My2zo6yERkiPCbRkjPUt6VoeEbeArqOowh/wDTbp3D&#xd;&#xa;MCAyBiVIB9mrG+H8UbarrUrRoZElUK5UZUEvnB7ZwKr+PXnt9cgk0tpIrl4T5zWxIcjIxuK8+nX2&#xd;&#xa;q94Ps9Rk0KOa01K3gMjMZFNoHfduI+ZtwJP1rT0Hw8+j6rPOdRSRZ0ObaOHykByPmChiOMY6d66G&#xd;&#xa;uQ1L/kp2k/8AXq38papeKXa0tNbsF+W2cR3Cbhy0jygtg9/pVu71KS10fwzYwxxGS9WELLIocREB&#xd;&#xa;Bnaep+bPUdKr+N4NRh0I/bNUhnQyLiJbYRk++dx6V0Oof8idc/8AYPb/ANFmqvgOKNPCtpIkaK8h&#xd;&#xa;cuwUAsQ7AZPfisf4YxRm1vZvLTzQ4UPtG7bjOM+nAquzzx6x4ra2aRZhGNhjJDA5HTHNaXhfT79/&#xd;&#xa;D1ubPUrWKKRcvGLMNz33HcMnGOtaPh7QX0W7uidQEyz/AD/Z0j8tUJPULuIHTHTtWvqH/IPuf+uT&#xd;&#xa;fyNV9A/5F/Tf+vWL/wBAFaFFFFFFFFFFFFFFFFFFFYHgX/kUbH/tp/6Mat+iiiuct7HzvHd3e+Zt&#xd;&#xa;+zW8a7Nud28N37Y2/rXR0UUVw/iW3k0DX7XV7G5aM3kuyaI/db1J56YPTHBGa7ZHWRQyMGU9CDkG&#xd;&#xa;nUUVV1K9TTtPuLp9p8qNnCltu8gE4z74rmvBulRXaf8ACQXbG4urlmKeZ83lAMRwT1PyjnjA4rr6&#xd;&#xa;KK5i/wBT83xzpmm+Tjyd8nmbuuYm4xj+tdPRRRRRRRRRRVDVNItdV8j7WHPkP5ibWxzV+uc8UNca&#xd;&#xa;gF0S3sJpVuCpluCCscYVg33sYJOCOo7VvWtulpaw20WRHCixrk5OAMCuI8KaFcSX2rNdjULJTKDG&#xd;&#xa;Y3eESDL/AEz2/P3rrNO0a006eWeLzJLiXAeaZ97kccbjzjgce1V38OWf2mWaCW6tDMQzpbTmJScY&#xd;&#xa;zhatWOlw2LtIsk00pG3zLiQyMB6AnkDjpV6qE2kWs2sQaq4f7VAhjQhuMc9v+BGm6zolnrcUcd6r&#xd;&#xa;lY2LLtbHNJc6FY3Nla2siMFtAohkVsSR7cYw3UdB+VVp/C1hdQNFdyXVyCQVaeYuyf7pPTPfHXA9&#xd;&#xa;K05bSKWweycHyXiMRGedpGOv0pum2EGl2MdnahhDHnaGOTyST+pqDRtEs9EikjslcLIwZtzZ5p1p&#xd;&#xa;pFrZ6jc38IcT3P8ArCWyPwFVR4aso3kNtNeWiyNvMdtO0SZ9lXjsKu2Gmw2O4o8s0jcGWdzI+P7u&#xd;&#xa;484749zUmof8g+5/65N/I1X0D/kX9N/69Yv/AEAVoUUUUUUUUUUUUUUUUUUVgeBf+RRsf+2n/oxq&#xd;&#xa;36KKKx7D/kZ9X/65W/8AJ62KKKKyPE+mR6rolxC+xXVd6SFAxQggnHpkDH41T8B3323w3Gvl7Psz&#xd;&#xa;mH72d2ADn2+9XR0UV5z4u1Y63rlvoULxi2FxGvnIQ+WbjP4biMZ7V39lax2VnFbQoipGuAEUKM9z&#xd;&#xa;j3PNT0UVyMNtHffEWW6iuEIsoRuVcNliGUgnPBGa66iiiiiiiiiiiiiiiiiiiiiiiiiiiiiq+of8&#xd;&#xa;g+5/65N/I1X0D/kX9N/69Yv/AEAVoUUUUUUUUUUUUUUUUUUVgeBf+RRsf+2n/oxq36KKKx7D/kZ9&#xd;&#xa;X/65W/8AJ62KKKKhu42ltJo0+88bKPqRXD/D62nsNZ1KyuDhokAZQ2RnNd9RRXn3gWwaXxDqN66I&#xd;&#xa;0MZeME8kOXBBA+gPNeg0UVHcS+Tbyy43bELYzjOBmua8EQwXMN3rKxsk95PIWXdkAbsgfr1rqaKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKr6h/yD7n/AK5N/I1k6JrOlxaHp8cmpWaOltGrK06gghRkEZq9&#xd;&#xa;/bukf9BWx/8AAhP8aP7d0j/oK2P/AIEJ/jR/bukf9BWx/wDAhP8AGj+3dI/6Ctj/AOBCf40f27pH&#xd;&#xa;/QVsf/AhP8aP7d0j/oK2P/gQn+NH9u6R/wBBWx/8CE/xo/t3SP8AoK2P/gQn+NH9u6R/0FbH/wAC&#xd;&#xa;E/xo/t3SP+grY/8AgQn+NH9u6R/0FbH/AMCE/wAaP7d0j/oK2P8A4EJ/jR/bukf9BWx/8CE/xo/t&#xd;&#xa;3SP+grY/+BCf40f27pH/AEFbH/wIT/Gj+3dI/wCgrY/+BCf40f27pH/QVsf/AAIT/Gj+3dI/6Ctj&#xd;&#xa;/wCBCf40f27pH/QVsf8AwIT/ABqh4F/5FGx/7af+jGrfooorjby5On/EWGScSpBdRLChCna7ngfX&#xd;&#xa;BP4ZrsqKKKK86sHZfinIoYhWlk3AHg/uzXotFU9XnkttHvp4W2yxW8jo2M4IUkHmsjwJBGvh2K6C&#xd;&#xa;/v7p3eZs/eIdhnHQceldHRRXMeOrySLTYLNPlF7KsTODgqAQeK3tPs47CwgtIuVhjVM4xuwMZPua&#xd;&#xa;s0UUUUUUUUUUUUUUUUUUUUUUUUUUUUVX1D/kH3P/AFyb+RqhoVlatoOnM1tCWNrESTGMk7RV/wCw&#xd;&#xa;2f8Az6wf9+xR9hs/+fWD/v2KPsNn/wA+sH/fsUfYbP8A59YP+/YqIQacbk2wgt/OCCQp5YztJIB6&#xd;&#xa;eoNEMGnTmQRQW7mJ/LfEY+VsA46e4qX7DZ/8+sH/AH7FH2Gz/wCfWD/v2KPsNn/z6wf9+xR9hs/+&#xd;&#xa;fWD/AL9ij7DZ/wDPrB/37FH2Gz/59YP+/Yo+w2f/AD6wf9+xR9hs/wDn1g/79ij7DZ/8+sH/AH7F&#xd;&#xa;H2Gz/wCfWD/v2KPsNn/z6wf9+xR9hs/+fWD/AL9ij7DZ/wDPrB/37FZHgX/kUbH/ALaf+jGrfooo&#xd;&#xa;rmvGmlzXVpDqVrOIp9M3TruHBxhj2PPy8dq1tD1BdV0i2vUDgSLzvAByCQenuDV+iiivPfF88lh4&#xd;&#xa;40+e1Iil8pMsFBzuZ1PX2OK9CorC8Z3zWPhu6ZUD+cphOT0DAjNW/DtiunaFaWyOXVU3ZI5+Ylv6&#xd;&#xa;1pUUVw+gNL4l8TSavKZTZWpK26SKuOh4IHcbs5+ldxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRVfUP&#xd;&#xa;+Qfc/wDXJv5Gq+gf8i/pv/XrF/6AKNSvp4J7e0s443urgOyeaSEAXGckZOfmGOKZY3139v8AsOox&#xd;&#xa;QrO0RmQ27Fl2ggHJIBzkjtVOy1TV9Tt/NsrO2RVd0Y3DsobDEArgHI45zjmrNxrSjw0+sW0RK+V5&#xd;&#xa;iJJwevfFTaJpFvolgLS2yRu3uxPLNgDPtwB0qj4gtYba4t9eVM3VqViGScMrtswfpvJreooooooo&#xd;&#xa;ooooorA8C/8AIo2P/bT/ANGNW/RRRRWBB9q0bV/s7eUNIuGxBySYnPUE453Oxxyenat+iiiuK+Jb&#xd;&#xa;tFZ6fIhwyzFgfQgV1OkTyXOj2M8zbpZbeN3bGMkqCTxVyub8exPP4e8mJS8kk8aqo6kk4ArdskaO&#xd;&#xa;ygRxhljUEehxU9FcD8QtfRo/7JtZSWyDcAKCvByFz1BBANdT4b0hdF0iO1wglJ3ylGJDP0yM+wFa&#xd;&#xa;tFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFV9Q/5B9z/ANcm/kar6B/yL+m/9esX/oAqDWY54byz1G3t&#xd;&#xa;3uTbLIhhj+82/byPptqPTftN/q/9oz2ctmI4GgEcuCWyytkY7cVY8O28tro8cU6GOQSSkqeuDIxH&#xd;&#xa;6EVStNKnuPBMemSDyJ3g2HePunPetHRtVg1nT0u7c4BOGXOSjeh/MVS8QXEVzLb6IrgXN2yyDP8A&#xd;&#xa;CqHfk/XYRW5RRRRRRRRRRRRWB4F/5FGx/wC2n/oxq36KKKKhvLZLyzntZCwSaNo2K9QCMHH51n6T&#xd;&#xa;qCm6n0iZk+1WajO3gOmAQQPYMoPvWtRRWJ4yt5brwvexQIZJCEIUdcB1J/QGs74dXET+HzAjgyxS&#xd;&#xa;EuvdQen8jXWVzviq+WG60azKEtcXsbBs8Da6/wDxVdFRVDWdVg0bT3u7g5AOFXOC7eg/I1xHgGym&#xd;&#xa;1HWpdYu2ldoidsmRh3IwQfwavRqKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKr6h/yD7n/rk38jVfQP&#xd;&#xa;+Rf03/r1i/8AQBWhRRRUQt4hcm5CDzigjL99oJIH5k0Q28UBkMSBDK/mPj+JsAZ/QVLRRRRRRRRR&#xd;&#xa;RRRWB4F/5FGx/wC2n/oxq36KKKKKwPFekXGoW0VzpuF1C2fdG+cMRg/KCeByQfwqbwzqzalYCO7Z&#xd;&#xa;V1CHKzxAEFSCcHnrkYOR61s0VDeI0tnPGgyzRsoHqSK898AXZ0zXLrSbiFhPO+wkEYQxhyQfX8K9&#xd;&#xa;IrkPGX/IweGf+vr/ANnjrr6K871m5n8a6pHY6UX+xw5Z5G4Q9t2Dg98Y613enWUenWENnCztHCu1&#xd;&#xa;S5BJHvirNFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFV9Q/5B9z/wBcm/kar6B/yL+m/wDXrF/6AK0K&#xd;&#xa;KzLrVZlupLexsJL14cCbbIqbCQCB8xGeDnimzatObiWPT9OkvVhbZI6yIgV+pXDEZ4IORxzU0eqw&#xd;&#xa;3GoNZ2yvK8TFZ2AKiLjI5PXsOM9aL7VYdOnRbtXjhkACTAFgXJxtwMkduTxzV+iiiiiiiiiiiisD&#xd;&#xa;wL/yKNj/ANtP/RjVv0UUUUUVyfiyyv7S9h13SI0MsI2zoowZF9WwQWHAGPp6VtaJrdprdoJ7Z8N0&#xd;&#xa;eM/eU8fn1HI4rSory2/E+g+PzOhjkeScyDcDgCQkY+oDV6lXIeMv+Rg8M/8AX1/7PHXX1jeKbm4h&#xd;&#xa;0nybJZDdXcgghMb7CrEE5zxj7tHhnQI9AsmiWVpZJSGkJ6Z9uOlbNFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;ISACScAd6ijureVtsU8Tt6K4Jqaiiiiiiq+of8g+5/65N/I1X0D/AJF/Tf8Ar1i/9AFV9XMk+qWG&#xd;&#xa;niaWKG4SV3aFyj5XbjDD6mmWSPYa8tglxcTQyWrTHz5TIwYMoGCegwTxVXSdNQeItVk+1XhMM0ZA&#xd;&#xa;M7YbMYPzDv179qTw7paLe6hL9rvSYL5lCm4Yq/yLyw/iPPf2q94U+bw9aTNzLMm+Rz9526ZJ7ngc&#xd;&#xa;+1XtTjSTTblZEVwIy2GGeQMg/gQDUeiSPLoenySOzu9tGzMxySSoySavUUUUUUUUUUUVgeBf+RRs&#xd;&#xa;f+2n/oxq36KKKKKKK4jxBoFxo1ydb8PkxsuBLbxrhccknqMjhflx710ug6xDrmmrdwjac7ZE5Oxs&#xd;&#xa;A4yQM8Ec1pVwPj20ii1zSbpAfNnk2vzxhSuP5mu+rivF91DJ4q8P2yPmaG5VpFweAzJjn8DXa1zs&#xd;&#xa;d21743ms5ISYLG33KWO5TIdhDAYwGAYjPXGa6Kiiiiiiiiiiiiiiiis7WrMXNo8n2m6gaGN2XyJm&#xd;&#xa;jycd8delYHg6Rv7BfWL69vZmiEhcPOzrtUZ+6T1rVg8U2F1AstpHdXIJIZYIS7J/vAdM9s9cH0q5&#xd;&#xa;Zava39hJd2xeRYw2+MLmRSM8FeueOBXP6B4rnuvtf2y2uptku2P7Pas20ejY6Gty6120tIbd5lmE&#xd;&#xa;lwcR24jPmnr/AAde1Flrtpd3v2PbNb3BXesdxGY2cc9AeT0P5UX2vWGn6lHYXMhSaSPzFyPlI54z&#xd;&#xa;6naRj6VieKteMnh27SC21K2kYKBK9u8YA3DOW7ZGR+NW/C39mrpUFwunraywWyGS5ktxFu+Xlg5H&#xd;&#xa;I4yTVqbxJawq7m1v2hQE+clszRlR/EG6Fcc56YrRhvbaeyF5HPGbcqX8zcNoA65PTjnP0rNj8TWs&#xd;&#xa;yb7e01CeMkgSRWrOrYOOCOD0q3d6xYWmnfb5LqJrboro4YOeeF9TweB6Gqh8T2McsSXUV3aCVtqv&#xd;&#xa;cwGJM/VuK2qKr6h/yD7n/rk38jVfQP8AkX9N/wCvWL/0AUuo6e91LBcW1wLe6gDBJGTeAGxuG3I9&#xd;&#xa;BTLHTZ4rw3l9drc3AjMSMkXlgKSCRjJzyBzU1rY/Zr++uvM3fa3Rtu3G3agXr36ZosLH7E943mb/&#xd;&#xa;ALTcGb7uNuVUY9/u1S0lLrTJf7OktibMMVtZUO7CgZw/HHfknnOKl1iW9kU2Vhb73kUGSV/lRUJw&#xd;&#xa;cHGCcA8dsg1ftbdLS1htosiOFFjXJycAYFS0UUUUUUUUUUVgeBf+RRsf+2n/AKMat+iiiiiiiiuY&#xd;&#xa;vLK48O3TajpUbSWLHNzZIMAHpvQDp2yAOi9a3NN1G11S0W5s5RJG3HB5U+hHY+1c58RNOM+lR6is&#xd;&#xa;5jaxOQoXli7IOueMYzXQaJI8uh6fJI7O720bMzHJJKjJJrh/Ef8AyUiw/wCutv8A+hCvRq5PwLLJ&#xd;&#xa;PJq8k0jyObrBZ2JOAMDn6CusooooooooooooooooqvqH/IPuf+uTfyNch4c/5Jvf/wDXK4/9BNXv&#xd;&#xa;h2ijw0rBQGaVsnHJ5qHwB/zF/wDr6P8AWjwB/wAxf/r6P9aoRQ3p8fXgNyLNnVvs73EW8PyvCAkc&#xd;&#xa;/T0NaWueH7u9iSfUdeggWA5EwthHtzxy2/3/AFqPVEV/iZpSuoZfsp4IyOktaPjr/kUb7/tn/wCj&#xd;&#xa;Fqvdao2keA7O5SJZWNrFGAx4BKAZI7/TvVa8Opt4Se7uNXto4Z7Pd5P2ULncmdgO7rzgcfhWayTv&#xd;&#xa;8K7fyFkYhmLbAThfMfJOO2Otdro7wPpNq1s0bReWMGMgrnv0981yficpLq+jTWlxDFp5JAuNoeBW&#xd;&#xa;yevO0nr39a2NQ0LVNStHtrrV4GjcY/48RkfQ7+K09GhW30m2iS6F2qJgTg5D+/U/zq9VfUP+Qfc/&#xd;&#xa;9cm/kar6B/yL+m/9esX/AKAK0KKKKKKKKKKKKKKKKKKKwPAv/Io2P/bT/wBGNW/RRRRRRRRUN3G0&#xd;&#xa;tpNGn3njZR9SK4f4fW09hrOpWVwcNEgDKGyM5rf8df8AIo33/bP/ANGLV/QP+Rf03/r1i/8AQBXE&#xd;&#xa;+I/+SkWH/XW3/wDQhXo1ch4A/wCYv/19H+tdfRRRRRRRRRRRRRRRRVLUNLtNTCC7R3CZwFldOuM5&#xd;&#xa;2kZ6d6q23hnSbVJEgtnRJEaNl8+QgqwweC1XdO0610u1FtZReVCCW27i3J9yTTdP0uz0zzvscPle&#xd;&#xa;c++T5icn15NVp/Dulz3Mlw9u6ySEFzHM6AkDHRSBUtxomn3NrDbTQFo4DmM+YwZev8Wc9z3qODw9&#xd;&#xa;plvMsqQOWXoJJ5HX8mYg1Yk0uzl1SLUnhzdwpsSTceBzxjOP4j271JfWVvqNo9rdx+ZBJjcu4jOC&#xd;&#xa;CORz1AprafavpwsGhDWoj8oRkk4XGMZ69O/WqUfhnSYkZFtnKMhjKtPIw2kY4Bbj+lXrOwtbGyWz&#xd;&#xa;togluoICElhgkk9c+pqgPC+kDO23lUEk4W5lUc89A1XrnT7S7s2tJ7dGt2/gAwB9MdPwqj/wjGlf&#xd;&#xa;88Z//AqX/wCKrWRFjUKihVHQAYAp1V9Q/wCQfc/9cm/kar6B/wAi/pv/AF6xf+gCqWtXq2OuaZJI&#xd;&#xa;zbPKuP3anmRsJhQO7HoB6mrmmavHqLOn2a5tJVGRFdRiN2X+8BnkcgZqC18RW15NDFbW11L5jsjM&#xd;&#xa;iBlhIJHzkH5c4yPYirWnTW8sl6LdJFMdyUl3nOX2qSRyeMEen0qtf6/HZ3JgjsL+9Kj53tIRIqN/&#xd;&#xa;dJzw3Q49CKoanrMeoeGru5ijuLQwXMUbiddjKRIhOeeBg1di8RQSXghazvYoSxUXkkQEDDsQ+cYb&#xd;&#xa;jB75HrU/iC+k07Rbq5hjlaVY22GNN2w4OGIPYdTVbT9fWfTnnuLO9gaJF/18QQzsQeIxn5iSOB7i&#xd;&#xa;n2XiGG6uBDNZX1ju4R7yIRK7ZwFBJ5Y9h7GptQ1q20+5FtKkrzNEZUSMAmTBA2qM8tznHoDS6Zq8&#xd;&#xa;eos6fZrm0lUZEV1GI3Zf7wGeRyBmqjJLrWpXMZuHXTbc+RLAPlaSUfNncOQMMvQjoeMdZ9ZtbkIb&#xd;&#xa;2wuTBPGo355V4wckYIIBxnkDPTmr9ncpeWcF1GGCTRrIobqARkZ/OpqKKKwPAv8AyKNj/wBtP/Rj&#xd;&#xa;Vv0UUUUUUUUVyHh3/kd9e/D+daHjr/kUb7/tn/6MWoPh+7P4Yj3MWxIwGTnA9K5/xH/yUiw/662/&#xd;&#xa;/oQr0auH8JJdad4w1TS5ZUMewzlUGQWJUg5Iz0au4oooooooooooooooooooooooooooooooooqv&#xd;&#xa;qH/IPuf+uTfyNV9A/wCRf03/AK9Yv/QBWfr11aWev6RNfSJHEqT/ADP0B+TFOs7qDU/Ei3djKs9v&#xd;&#xa;HZvE8idAxdSB+QNS+FEVdDRgoDNLNuIHJ/evS6B/r9Y/7CD/APoCVVtNRtdIvNSiv5RDNPdtNDGf&#xd;&#xa;vSKVUAj6lSPwrNkk+0aBrUjQvFv1OPMcoG4fNDwQM1t+KFC+H5FUAKJYQABwB5qVc1mJ59Fv4YlL&#xd;&#xa;ySW8iqo6klSAKwr+6h1DQ4I7K6HmWUsDXDoMmAKeWIPHGCfwqAPDql5ZINcn1QwXMcwihgjGzB+8&#xd;&#xa;xAHyjOD169K2JUVvGNvuUHbYORkdD5ic0r/8jjD/ANg+T/0YlGi/ub/VIJfllkujOqnqYyqgN9Mq&#xd;&#xa;R+FXdVlSHTLhpGCqUKgn1PAH4kgU3Rong0WwhlUpJHbxqynqCFAIq7RRRWB4F/5FGx/7af8Aoxq3&#xd;&#xa;6KKKKKKKKK5Dw7/yO+vfh/OtDx1/yKN9/wBs/wD0YtV/h5/yLCf9dX/nWB4j/wCSkWH/AF1t/wD0&#xd;&#xa;IV6NXIab/wAlO1b/AK9V/lFXX0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVX1D/kH3P/AFyb+Rqv&#xd;&#xa;oH/Iv6b/ANesX/oArQoooqhfWd7cTB7XVJLRAuCiwo4J55ywJ/8A1VJp9itjC67zJLK5klkIwXcg&#xd;&#xa;DOOg4A4HFW6KKKKKzb/RoLu7S+jZoNQjTZFcr8xQc5G0/KeCw5HenX+kW+pXMUl7mWKHBjiztCvn&#xd;&#xa;72RgnsMHjitCiiiisDwL/wAijY/9tP8A0Y1b9FFFFFFFFFeeRa9a6D4x1mW7jmdZW2jygCc/iRS+&#xd;&#xa;JPGmnatoVzY28N0ssu3aZEULwwPZj6VgeG/Ek3h77T5Nuk3n7c7yRjbn/GpbO+8Q6pq8up6eHluk&#xd;&#xa;UIzJGp2Kc4GCMdjV2+1vxlp0ImvZJIY2baGaCPBPJx932NUNBvbjUfGdldXcnmTySrubaBnAwOBx&#xd;&#xa;0Ar16iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiq+of8AIPuf+uTfyNV9A/5F/Tf+vWL/ANAFaFRG&#xd;&#xa;4iFyLYuPOKGQJ32ggE/mRRb3EV1CJYHEkZJAYdMg4P6g1LRRUMd1BJHLIkqskTMrkfwleo/Cnwyp&#xd;&#xa;PCk0TB45FDKw6EHkGn0UUUUUUUUUVgeBf+RRsf8Atp/6Mat+iiiiiiiiivM1tYL34mS291EssLyy&#xd;&#xa;bkbocRkj9RXpMMSQQpDEoSONQqqOgA4AomlSCF5pWCRxqWZj0AHJNcN4m8cmKQ22jtFIrIQ85ycE&#xd;&#xa;jjbyMEc9c9q4S7up725e4upWlmfG526nAwP0Fd74A8OwfZYtZnPmSPu8peyYYjP14/Wu6ooooooo&#xd;&#xa;ooooooooooooooooooooooooooqvqH/IPuf+uTfyNV9A/wCRf03/AK9Yv/QBTdTvbmK6trKyEQuL&#xd;&#xa;gOyvMCUAXGcgEH+Ks+zF+PF0f9oPbO32B9vkIyjHmJ1yTWnot7JqGmJczKiuzyKQgIGFdlH6Csa3&#xd;&#xa;1nWBoiazc/YTa+X5jxRxuHx6AlsZrQhvNRtdQtbbUjayC6LLGbdGXaVUsc5J7Ck8QIt5JY6VMP8A&#xd;&#xa;R72QiUj72EXeMfioB9q1oYkghSGJQkcahVUdABwBWMlvFpfiZBaoFGpq8k+f7yYII+u85znt0rco&#xd;&#xa;ooooooooorA8C/8AIo2P/bT/ANGNW/RRRRRRRRRXmt5KND+Ipvb8eXC2+VT97cpRlHTPU8VYv/iP&#xd;&#xa;MfL/ALOs0Trv+0ZbPTGMEe9cpqerX+tXAa7laQ72McYHCbj0Ufl+Va/h3wbd6sPPuCba2VwDuGGc&#xd;&#xa;Z+bHofqO9berHQfC+kTWlmvn3lzDJBv3AvtbPLEDHBwMda2fAksZ8LWUQkQyKJCUDDIHmN2roqKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKr6h/yD7n/AK5N/I1X0D/kX9N/69Yv/QBUWq29yL+zv7aA&#xd;&#xa;3LWyyIYVYKW37eck4421BZw6lP4hW/u7VYIPsjRKm4FkO9ThiCQc4J47e9WvD9rNZ6THBcJskEkr&#xd;&#xa;Fcg8GRiOnsRWd/Zd5/wgn9m+T/pf2fZ5e4dc9M5x+taOoWs02raVPGm6OCSRpGyPlBjIH15NQ69m&#xd;&#xa;2ez1MqzpZSFmjUEswcbOPpuz+FacFxDcW6zxOGjYZB6Y+oPT6GsiGZNV8QpNb7vL05HRnZSBIXx9&#xd;&#xa;3PXGzr0ORW5RRRRRRRRRRWB4F/5FGx/7af8Aoxq36KKKKKKKKK4D4m2UYa0v9z+aw8kjI27Rk/ny&#xd;&#xa;a5rQ/DV/rU+2KMxQgAtM4wACCRx1Ocdq66C08O+EIfMu5Uur1lDKHQSESJ12YX5Mk9z6elYuu+Ob&#xd;&#xa;zUFMNiptITgh1YiXI/2gcY/CuVcSHEkgY78kM38Xqc969G8DeGrrTJhqVy6L58BTyhyVywIORx0H&#xd;&#xa;612lFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFV9Q/wCQfc/9cm/kaoaFe2q6DpytcwhhaxAgyDIO&#xd;&#xa;0Vf+3Wf/AD9Qf9/BR9us/wDn6g/7+Cj7dZ/8/UH/AH8FH26z/wCfqD/v4KPt1n/z9Qf9/BR9us/+&#xd;&#xa;fqD/AL+Co1n05EdEltVWQlnUMoDE9SfXNOju7GKNY47i2REAVVV1AAHQAU77dZ/8/UH/AH8FH26z&#xd;&#xa;/wCfqD/v4KPt1n/z9Qf9/BR9us/+fqD/AL+Cj7dZ/wDP1B/38FH26z/5+oP+/go+3Wf/AD9Qf9/B&#xd;&#xa;R9us/wDn6g/7+Cj7dZ/8/UH/AH8FH26z/wCfqD/v4KPt1n/z9Qf9/BWR4F/5FGx/7af+jGrfoooo&#xd;&#xa;oooooriPif8A8g+x/wCurfyrmrjxhqT6dDYWz/ZoY4Y4tyN8+VA5DDBGcdKo6VpV7rmooiCRvOfM&#xd;&#xa;k7c4GfmYknk98Zya7yx8KaLoMJudTljuXRWYtMg2lR6Ic5I9q4/xfqljqF9FFpkSJaWybYzGu1Wz&#xd;&#xa;yflwMck/zr0rw1ff2loFndeX5e5Cu3dn7pK9fwzWpRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRSM&#xd;&#xa;oZSrAFSMEEcEVQ/sLSP+gVY/+A6f4Uf2FpH/AECrH/wHT/Cj+wtI/wCgVY/+A6f4Uf2FpH/QKsf/&#xd;&#xa;AAHT/Cj+wtI/6BVj/wCA6f4Uf2FpH/QKsf8AwHT/AAo/sLSP+gVY/wDgOn+FH9haR/0CrH/wHT/C&#xd;&#xa;j+wtI/6BVj/4Dp/hR/YWkf8AQKsf/AdP8KP7C0j/AKBVj/4Dp/hR/YWkf9Aqx/8AAdP8KP7C0j/o&#xd;&#xa;FWP/AIDp/hR/YWkf9Aqx/wDAdP8ACj+wtI/6BVj/AOA6f4Uf2FpH/QKsf/AdP8KP7C0j/oFWP/gO&#xd;&#xa;n+FH9haR/wBAqx/8B0/wo/sLSP8AoFWP/gOn+FH9haR/0CrH/wAB0/wq5BBDbQrDbxJFEv3UjUKo&#xd;&#xa;79BUlFFFFFFFFFcR8T/+QfY/9dW/lXNeFPDr6vdCe6jZdOjz5shO3PBxg98EDPpXTan4r07w/ax6&#xd;&#xa;dokUM+IyPMjcbUOBhjgHce56dPeuJ1PVdQ167jNyzTSfcjjQHGT/AHV9Tx061HqemXGlTJDdGMSs&#xd;&#xa;oYorgsmecMOx5716j4F/5FGx/wC2n/oxq36KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKK4v4kxST2VjHDG8jmViFRSTgLk8fQVx7+JtRfSBpgaNLcIqfIm1sD&#xd;&#xa;HcfTmpdP8IaxqNolzDCqxvyvmNtJHrg9veqOq6Rf6Jcol3GY2PzI65wceh9RxUVnaXmrXqwwJJPM&#xd;&#xa;5GTy2BkDJPYDI5r1zwvYT6X4ftbO6CiaPfuCnI5ckfoa1qKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKa0aOQXRWI6ZGcV5/408LpZCTWbApHGjb5Yzk/MWAB&#xd;&#xa;UcjqeRwKr2/xEvYbeKJrKByiBS2SucDrgcD8KxNR1/VtbxbXEnnK7/u41iXOSeACBn0+td/4P8Mp&#xd;&#xa;otv9pn+a9lTDEE4RSc7cH6DPHWumoooooooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooooooooqrqNjBqdjLZ3K7opRgjJHQ5B49wKx4fBGgpCiSWZldVAZzK4LHucBsVZ0&#xd;&#xa;Tw1YaMsnkxiSR33b3GSME4Az0xmtmiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiufTxdZS2a3cVrfSWwGZZUhysP8AvHPbqcZxWpf6lBYW6TOJJjKQsUcK72kO&#xd;&#xa;M4UfQZ9Kbp+qQ38kkXlTW9xGAXgnXa4B6HgkEfQ1Lp17HqNjFdwq6xyjIDgBhzjBxRY3sd/HLJCr&#xd;&#xa;hY5XiJYDkqcEj2yKs1l2VxLJ4h1OB5CYoo4Ci9lJ35/PArSdtiM20tgZwvU/SszStS+36heIYryB&#xd;&#xa;okjzDcIq7c7uRgnrjv6U/UdZisblLZba5urhkMnlWyBmVem45I4zxTbfVk1LSrm6tY5o0VG2SOoG&#xd;&#xa;4gHkc9iMc9xWdp/iiBdJspbiK7lTyo1nuxF+7RyADlifXqQDV3xTqVxpmizzWscpl2nbIiqwjPq2&#xd;&#xa;e34Grtheteo7NZ3NrtOMXCgE/TBNQaldTNdwabaNsnuFZ3lxnyoxgFgPUkgD657Yq3dxTS2xS3nM&#xd;&#xa;MwwVcqDyPUeh74x+FRaVff2hZLMyeXKrNHLHnOx1OGGfqKW9v0spLZHhnkNxKIlMSbgpPdvQVboo&#xd;&#xa;ooooooooooooooooooooooooooooooooooooooooooooooooooorl7H/AJJq3/YPk/8AQWpuswkQ&#xd;&#xa;aLeStdraQxlJntWYOgZVw3y84G3n61a0JNIl1B7iw1C4vZ0iKFpZnkCqSDjJ9wKydOtdRlt7iS2e&#xd;&#xa;RTpM8ywRg4FxJ5rM+R3BXCj3Jre8KYPh22cdJC8gz6M7MP51sVzf9q2OmeKNU+3XMcHmRQbN/fAf&#xd;&#xa;P8xW5ZXttqFuJ7SZZoiSNy9Mis/T/wDkaNY/65W/8nrN8QyvF4gg+ztdwSm1IaW1iEzOu7hSnOAO&#xd;&#xa;Tux3xVvTZ7L+wrqxsxcK1rC3mJcoVkG4E7jkDryarX3/ACTVf+wfH/6CtaXimN5vDWoJEhdzCcKB&#xd;&#xa;kmp9O1mw1QkWVwJiqhm2g/L9T0z7VWb9z4wVn4W4stkZ9WRySPyYH8DWxWP4c+dNQuV5iuL2R4z/&#xd;&#xa;AHlAVc/mpq7falbWElslwzKbmUQx4UnLHpn0q3RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRXGeM7+50C8XUNPk2y3SrHKrAMrbdxBx69q2vDUO6xOoSyPLdXmGl&#xd;&#xa;dyO2QAAOABz+ZrZooqpqVpHdWp3llki+eORDho2A6g/5z0NOvoTPaGEyyIGKqzIcMQSARntkenPp&#xd;&#xa;ipoYo4IUihRY40AVVUYAHpSSwRzNG0i7jG25eeAcYzjv1qSiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiv//Z</binary>
<binary id="image6.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCABRAZUBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/AOosdE0l7G3Z9LsmZolJ&#xd;&#xa;Jt0JJwPap/7B0j/oFWP/AIDp/hR/YOkf9Aqx/wDAdP8ACj+wdI/6BVj/AOA6f4Uf2DpH/QKsf/Ad&#xd;&#xa;P8KP7B0j/oFWP/gOn+FH9g6R/wBAqx/8B0/wo/sHSP8AoFWP/gOn+FH9g6R/0CrH/wAB0/wo/sHS&#xd;&#xa;P+gVY/8AgOn+FH9g6R/0CrH/AMB0/wAKP7B0j/oFWP8A4Dp/hR/YOkf9Aqx/8B0/wo/sHSP+gVY/&#xd;&#xa;+A6f4Uf2DpH/AECrH/wHT/Cj+wdI/wCgVY/+A6f4Uf2DpH/QKsf/AAHT/Cj+wdI/6BVj/wCA6f4V&#xd;&#xa;jazp9lZazobWlnb27NdEExRqufl74FdTS0UUUUUUUUUVyniyKOfxH4cimjSSN5ZQyOMgj5OoNbX9&#xd;&#xa;g6R/0CrH/wAB0/wo/sHSP+gVY/8AgOn+FH9g6R/0CrH/AMB0/wAKP7B0j/oFWP8A4Dp/hR/YOkf9&#xd;&#xa;Aqx/8B0/wo/sHSP+gVY/+A6f4Uf2DpH/AECrH/wHT/Cj+wdI/wCgVY/+A6f4Uf2DpH/QKsf/AAHT&#xd;&#xa;/Cj+wdI/6BVj/wCA6f4Uf2DpH/QKsf8AwHT/AAo/sHSP+gVY/wDgOn+FH9g6R/0CrH/wHT/Cj+wd&#xd;&#xa;I/6BVj/4Dp/hR/YOkf8AQKsf/AdP8KP7B0j/AKBVj/4Dp/hR/YOkf9Aqx/8AAdP8KP7B0j/oFWP/&#xd;&#xa;AIDp/hXGXUENt4p1eG3ijhiXydqRqFUfJngCu70//kH2v/XJf5CrNFFFFFFFFFFFFFFFFc94j/5C&#xd;&#xa;+gf9fZ/9BroKWiiiiiiiiiiuX8Tf8jR4a/66y/ySunpaKKKKKKKKKKKKKKKK8/1H/kb9Y/7Yf+ix&#xd;&#xa;Xb6f/wAg+1/65L/IVZoooooooooooooooornvEf/ACF9A/6+z/6DXQUtFFFFFFFFFFcv4m/5Gjw1&#xd;&#xa;/wBdZf5JXT0tFFFFFFFFFFFFFFFFef6j/wAjfrH/AGw/9Fiu30//AJB9r/1yX+QqzRRRRRSUZFLR&#xd;&#xa;RRRRRRRXPeI/+QvoH/X2f/Qa6Cilooooooooorl/E3/I0eGv+usv8krp6WiikozRS0UmaWiiiiii&#xd;&#xa;ivP9R/5G/WP+2H/osV2+n/8AIPtf+uS/yFWaKKKKSufvZ7vUtfbSop3tbaGESTSRNtkcnoAccCrM&#xd;&#xa;WhiGWOWPUtSyjAlXuS6sAehDZ4P51n6h4ivbKVhL/ZcH3tkU1w3mYB77QQM/XvUsvilX8KTa3a25&#xd;&#xa;/dsF8uQ99wU9PrWhpl1qN2RNc20EFs8e5AJC0meOoHGDyeD6Vp0UUUUVyvjW9j0640e8lVmSG4Zi&#xd;&#xa;F6n5a5y5+Imotd77e3t0gUnCOCSw7ZOf5V0uieNtP1JfLnD21wACVKllb1wR/XHWtf8AtvTv+fj/&#xd;&#xa;AMcb/Cj+29O/5+P/ABxv8KP7b07/AJ+P/HG/wo/tvTv+fj/xxv8ACj+29O/5+P8Axxv8KP7b07/n&#xd;&#xa;4/8AHG/wo/tvTv8An4/8cb/Cj+29O/5+P/HG/wAKP7b07/n4/wDHG/wo/tvTv+fj/wAcb/CsDXL6&#xd;&#xa;3vPFHh37PJv2SybvlIxkL6/SuvpaKKo647xaFqEkbsjpbSMrKcEEKcEGuV0+50uTT7Z7nV9a89ol&#xd;&#xa;Mm17gjdgZxgY61sahrdxZanp2n2dr9q+1RFlLvtbgdyfpk96W11y6i1ltM1WCGOQweekkDlk2jOc&#xd;&#xa;5we3pUH/AAkGpXFhc6nY2MBsIVdlaWUh5AuckAcY47mjU9Xkl8DnVCrRu6IxWKRkIy4HDDmrusav&#xd;&#xa;c2OpafZ2tqtw955nBfaRtAPXp3/SmWmr3yayNN1O2hR5IzJFJA5ZSB1Bzg/pVZPEdzqCNNpkVmsC&#xd;&#xa;kgG7n2NIR/dAzx9cVqaNqserW8kscbRtFK0MiMQdrDryOCORyK0aKKK8/wBR/wCRv1j/ALYf+ixX&#xd;&#xa;b6f/AMg+1/65L/IVZoooopD0rE1HSbsaquraZMq3Ai8uSCQHZMB05B4P59vxlin1qeVFextrSMMC&#xd;&#xa;7mcyllzyoAAwffms3RdL1XR43tIrSxkclv8AiYMcMwPzfOuMtySOvp6VWh8OagngW40krH9qeQMB&#xd;&#xa;u4xvU9foK6y0jaKzhjcDckaqfwFTUUUUUVzfiqGK41HQ4Z41kje6IZGGQRtqjffDzT7i7WW2uJba&#xd;&#xa;MtmSIAMCM9FP8Pf17Vv6RoWn6NHizt1V8YMrDLsM5wTWlRRRRRRRRRXMeJv+Ro8Nf9dZf5JXT0tF&#xd;&#xa;FU9Wt5LvSL22hAMk0Dxrk4GSpArK0+TXLLT7a1/siB/IiWPd9sAztAGcbfan3em3dx4n0rUQirFb&#xd;&#xa;xuJRu5BZSMD15NNvNHuLnxXHfEAWv2IwMQ3zAkt2/GslzPpPhvUNJR7OW2iimVJzcgMc5yuwD72S&#xd;&#xa;R161a/su7vvh5Dp8URW5eJMLJ8uMODzn2Fauo6fPceINIvI1XybTzvMJPPzJgYH1pLjT55PE1pfq&#xd;&#xa;F8iKB42Oeck8cVj23h2fSh9nTSdN1WAZKSSosci5OcMSGzXQaNbPa2rK9na2e5ywhtlwFGB1PGTx&#xd;&#xa;1wO1aFFFFef6j/yN+sf9sP8A0WK7fT/+Qfa/9cl/kKs0UUUUUUUUUUUUUUUVz3iP/kL6B/19n/0G&#xd;&#xa;ugpaKKKKKKKKKK5fxN/yNHhr/rrL/JK6elooooopKpNo+mtMZm060MpbeXMKlic5znHWro6UtFFF&#xd;&#xa;FFFFef6j/wAjfrH/AGw/9Fiu30//AJB9r/1yX+QqzRRRRRRRRRRRRRRRRXPeI/8AkL6B/wBfZ/8A&#xd;&#xa;Qa6Cloooooooooorl/E3/I0eGv8ArrL/ACSunpaKKKKKKKKKKKKKKKK8/wBR/wCRv1j/ALYf+ixX&#xd;&#xa;b6f/AMg+1/65L/IVZoooooooooooooooornvEf8AyF9A/wCvs/8AoNdBS0UUUUUUUUUVy/ib/kaP&#xd;&#xa;DX/XWX+SV09LRRRRRRRRRRRRRRRRXn+o/wDI36x/2w/9FitO18Z2sNrDE2maoWRFUkQDGQP96pf+&#xd;&#xa;E4s/+gXqv/gOP/iqP+E4s/8AoF6r/wCA4/8AiqP+E4s/+gXqv/gOP/iqP+E4s/8AoF6r/wCA4/8A&#xd;&#xa;iqP+E4s/+gXqv/gOP/iqP+E4s/8AoF6r/wCA4/8AiqP+E4s/+gXqv/gOP/iqP+E4s/8AoF6r/wCA&#xd;&#xa;4/8AiqP+E4s/+gXqv/gOP/iqP+E4s/8AoF6r/wCA4/8AiqP+E4s/+gXqv/gOP/iqP+E4s/8AoF6r&#xd;&#xa;/wCA4/8AiqP+E4s/+gXqv/gOP/iqP+E4s/8AoF6r/wCA4/8AiqP+E4s/+gXqv/gOP/iqP+E4s/8A&#xd;&#xa;oF6r/wCA4/8AiqP+E4s/+gXqv/gOP/iqpXGuR63rWjrb2V7EIbjezTRbRjGOxNdoKWiiiiiiiiii&#xd;&#xa;uS8ZTNaazoV55E00cDys4iTcf4al/wCE4s/+gZqv/gOP/iqP+E4s/wDoF6r/AOA4/wDiqP8AhOLP&#xd;&#xa;/oF6r/4Dj/4qj/hOLP8A6Beq/wDgOP8A4qj/AITiz/6Beq/+A4/+Ko/4Tiz/AOgXqv8A4Dj/AOKo&#xd;&#xa;/wCE4s/+gXqv/gOP/iqP+E4s/wDoF6r/AOA4/wDiqP8AhOLP/oF6r/4Dj/4qj/hOLP8A6Beq/wDg&#xd;&#xa;OP8A4qj/AITiz/6Beq/+A4/+Ko/4Tiz/AOgXqv8A4Dj/AOKo/wCE4s/+gXqv/gOP/iqP+E4s/wDo&#xd;&#xa;F6r/AOA4/wDiqP8AhOLP/oF6r/4Dj/4qj/hOLP8A6Beq/wDgOP8A4qj/AITiz/6Beq/+A4/+Ko/4&#xd;&#xa;Tiz/AOgXqv8A4Dj/AOKrBWd9T13Ur6K1uY4pvK2iWPDcLg+vpXo1FFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFf/2Q==</binary>
<binary id="image7.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAEOANUBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKworzWr27vVs2sEhtpzCPNjcscKDnhvepdviP8A&#xd;&#xa;57aV/wB+pP8A4qjb4j/57aV/36k/+Ko2+I/+e2lf9+pP/iqNviP/AJ7aV/36k/8AiqNviP8A57aV&#xd;&#xa;/wB+pP8A4qjb4j/57aV/36k/+Ko2+I/+e2lf9+pP/iqNviP/AJ7aV/36k/8AiqNviP8A57aV/wB+&#xd;&#xa;pP8A4qjb4j/57aV/36k/+Ko2+I/+e2lf9+pP/iqNviP/AJ7aV/36k/8AiqNviP8A57aV/wB+pP8A&#xd;&#xa;4qjb4j/57aV/36k/+Ko2+I/+e2lf9+pP/iqNviP/AJ7aV/36k/8AiqNviP8A57aV/wB+pP8A4qjb&#xd;&#xa;4j/57aV/36k/+Ko2+I/+e2lf9+pP/iqbBearDrNtZ35snjnjkcGBHBBXb6k/3q2qKKKKKx9B/wCP&#xd;&#xa;jWP+v9v/AEBK2KKKKKKKKKKKKKKKKKKKx73/AJGnS/8ArhP/AOyVsUUUUUVj6D/x8ax/1/t/6Alb&#xd;&#xa;FFFFFFFFFFFFFFFFFFFY97/yNOl/9cJ//ZK2KKKKKKx9B/4+NY/6/wBv/QErYooooooooooooooo&#xd;&#xa;ooorHvf+Rp0v/rhP/wCyVsUUUUUVj6D/AMfGsf8AX+3/AKAlbFFFFFFFFFFFFFFFFFFFY97/AMjT&#xd;&#xa;pf8A1wn/APZK2KKKKKKx9B/4+NY/6/2/9AStiiiiiiubC63qOo6gLXV1tYbefyljNsr/AMKnqfrV&#xd;&#xa;zS5r231F9N1C6F5L5XnrMIxHgZ27do+mc+9WL3V4bKfypLe8kOM5ht2dfzAqVdStWsjd+ZiMcEHh&#xd;&#xa;g390jru7Y65qtBrtrNMsbRXUG44DzwNGuewyRjJqW91e3spfKZJ5n/iWCJpCnpux0z71LY30N9GW&#xd;&#xa;i3qy/ejkUq6+mVPIzVqiiiiise9/5GnS/wDrhP8A+yVsUUUUUVj6D/x8ax/1/t/6AlbFFFFFFcZ/&#xd;&#xa;xJP7Y1b+1LswS/aflUXDx5XYvOAR3zUtjNpy+IbWPQnlnLKftUvmGVRHg4GWJx82OlT3mqSC9nS5&#xd;&#xa;1pNKKOVSFokbeoPD5Izz/SodK8mfQb95pXuU+3u4uI1HUEESY4GAeT24p0Wol54lh1qLV2Mij7MI&#xd;&#xa;UGRnlsgZ+Xr+FF872Wv38surjS45xHsLxqwlwuDjd6f1q/4dVXnvbpb177zimZzGqo20EfLjrjoa&#xd;&#xa;3KKKKKKx73/kadL/AOuE/wD7JWxRRRRRWPoP/HxrH/X+3/oCVsUUUUUVXksbOVy8lrA7nqzRgk06&#xd;&#xa;G0trdi0FvFESMEogXP5Uk1nazvvmtoZGxjc6An9adHbwxRGKOGNIz1RVAB/CmRWVpC4eK2hjcdGW&#xd;&#xa;MA06a1t7ggzwRSlem9A2Pzp8UUcKBIo1jQdFUYFPooooorHvf+Rp0v8A64T/APslbFFFFFFY+g/8&#xd;&#xa;fGsf9f7f+gJWxRRRRRRRRRRRRRRRRRRWPe/8jTpf/XCf/wBkrYooooorH0H/AI+NY/6/2/8AQErY&#xd;&#xa;oooooooooooooooooorHvf8AkadL/wCuE/8A7JWxRRRRRWPoP/HxrH/X+3/oCVsUUUUUUUUUUUUU&#xd;&#xa;UUUUUVj3v/I06X/1wn/9krYooooormrDV7HTb3VYryZone9Z1HlscjYgzwPY1d/4SjR/+fs/9+X/&#xd;&#xa;AMKP+Eo0f/n7P/fl/wDCj/hKNH/5+z/35f8Awo/4SjR/+fs/9+X/AMKP+Eo0f/n7P/fl/wDCj/hK&#xd;&#xa;NH/5+z/35f8Awo/4SjR/+fs/9+X/AMKP+Eo0f/n7P/fl/wDCj/hKNH/5+z/35f8AwpP+Ep0bcV+2&#xd;&#xa;cjqPKf8Awpf+Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/8KP+&#xd;&#xa;Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/&#xd;&#xa;8KqpqVrqXifT2s5DIsUEwc7GXGdmOoHoa6KiiiiiiiiiiiiiikJABJOAO9crpk0sOuvdu7NDeXEs&#xd;&#xa;RlkOVEa8x7T0wSxx69q6uiiiiiiiiiiiiiiiiiiiiiiiiqOs3YsdKnuCm8KAuM46kL/WqN5pptvD&#xd;&#xa;ENsZQxsVjkLYxv8ALw2PbOK09Nuxf6db3YTYJow+0nOMjpVmiiiiiiiiiiiiiiiiiiiiiiisDV72&#xd;&#xa;2l1u0sZZo4hAfPmEzBUdCCAOepzg49q0m1PTHUq19aMrDBBmUgj86o+H7iIXF9ZxzJLslMyeUwZF&#xd;&#xa;jb7qjHTGDx2rboooooooooooooooooooooooqvPY2dw++e1glfGNzxhjj8axrbTbE+J76M2VuUW2&#xd;&#xa;hIXylwCS+TjFbVvaW1qWNvbwwluvloFz+VT0UUUUUUUUUUUUUUUUUUUUUUUVj2v/ACNeof8AXrD/&#xd;&#xa;ADetiiiiiiiiiiiiiiiiiiiiiiiiiise1/5GvUP+vWH+b1sUUUUUUUUUUUUUUUVhR32s3l3erZJY&#xd;&#xa;CK2nMI84vuOADnj61LnxH/d0r85P8KM+I/7ulfnJ/hRnxH/d0r85P8KM+I/7ulfnJ/hRnxH/AHdK&#xd;&#xa;/OT/AAoz4j/u6V+cn+FGfEf93Svzk/woz4j/ALulfnJ/hRnxH/d0r85P8KrR2XiCPUpr0HTC80aR&#xd;&#xa;lcyYAUk+nvVnPiP+7pX5yf4UZ8R/3dK/OT/CjPiP+7pX5yf4UZ8R/wB3Svzk/wAKM+I/7ulfnJ/h&#xd;&#xa;RnxH/d0r85P8KM+I/wC7pX5yf4UZ8R/3dK/OT/CjPiP+7pX5yf4U23vtUi1e3stQSz2zxu6tAWyN&#xd;&#xa;uOufrW1RRRRRWPoP/HxrH/X+3/oCVsUUUUUUUUUUUUUUUUUUVj3v/I06X/1wn/8AZK2KKKKKKx9B&#xd;&#xa;/wCPjWP+v9v/AEBK2KKKKKKKKKKKKKKKKKKKx73/AJGnS/8ArhP/AOyVsUUUUUVj6D/x8ax/1/t/&#xd;&#xa;6AlbFFFFFFFFFFFFFFFFFFFY97/yNOl/9cJ//ZK2KKKKKKx9B/4+NY/6/wBv/QErYooooooooooo&#xd;&#xa;ooooooorHvf+Rp0v/rhP/wCyVsUUUUUVj6D/AMfGsf8AX+3/AKAlbFFFFc7p39s6lbNcrq0cKmWR&#xd;&#xa;An2VWwFcr1z7VOuqXthqFvZajB5kcx2R3kfR37ArjC9+56VZutZhtp2hS3urll4c20RkCH0OOh74&#xd;&#xa;9xVi1v4bq2aZNy7M743GHQ9cEdjj+dUYvEdrcJG9rb3lzHIAd8MJdVJ7EjoR3FWbK5gMV5JB58nl&#xd;&#xa;TyB1bLHcOoUenoKcuqWpsTdlyqKdrI3Dh/7hH97PGPWkutUhtYomaKd5JRuWCOPdJjudvXjIz9aS&#xd;&#xa;x1WG8lMXlT28uMqlxH5bMO5APUDj8xT7/UYrEKHSWWR/uxQrvcjuceg4596zLHUnvfE5URXcES2R&#xd;&#xa;PlzoUyd45AP8636KKKx73/kadL/64T/+yVsUUUUUVj6D/wAfGsf9f7f+gJWxRRRXN+H9X02100w3&#xd;&#xa;N/bQyrPNlHlVSP3jdjTry7k1fU7CGxtne1gnFw92ciNgvGFPRvvevaqhkms9V1LfrNvpiy3G9Eni&#xd;&#xa;UmQbFG4EkccY/Cr+jRBbHUpvtRuzPIzmYRbFf5APlwSCOOvrmrHheKOLw5YeWipugRm2jGSQMk+9&#xd;&#xa;N8O9NT/7CE39KyJ+NfOgdrmf7f5/93Dbtm3v93Gc9+lXdf8ANi1qyuFvUsI1hkVriVAyAkrheSBk&#xd;&#xa;4P5Uml/6TrcVydXj1ExQugMEICJkr95gxwTjgexotrqKy8Q6pLqk6QKzILVrhto27fm2E9s4zin2&#xd;&#xa;l7De+Ly9uS8a2JAkA+V/nHKnuO31FdBRRRWPe/8AI06X/wBcJ/8A2StiiiiiisfQf+PjWP8Ar/b/&#xd;&#xa;ANAStiiiioTaWxJJt4iT32CpFVUUKihVHQAYApskEMpzJEjkcZZQacqKibFUBR2A4pVUKoVQABwA&#xd;&#xa;O1IqqudqgZOTgdTSeWhkEmxd4GN2OfzokjSVdsiK49GGaI4o4s+XGiZ67VAzSSQxS48yNHx03KDi&#xd;&#xa;lSKNMbEVcDAwMYFPooorHvf+Rp0v/rhP/wCyVsUUUUUVj6D/AMfGsf8AX+3/AKAlbFFFFFFFFFFF&#xd;&#xa;FFFFFFFFY97/AMjTpf8A1wn/APZK2KKKKKKx9B/4+NY/6/2/9AStiiiiiiiiiiiiiiiiiiise9/5&#xd;&#xa;GnS/+uE//slbFFFFFFY+g/8AHxrH/X+3/oCVsUUUUUUUUUUUUUUUUUUVj3v/ACNOl/8AXCf/ANkr&#xd;&#xa;YooooorC0a5t4brV1mnijY3zHDuAcbErU+32f/P3B/38H+NH2+z/AOfuD/v4P8aPt9n/AM/cH/fw&#xd;&#xa;f40fb7P/AJ+4P+/g/wAaPt9n/wA/cH/fwf40fb7P/n7g/wC/g/xo+32f/P3B/wB/B/jR9vs/+fuD&#xd;&#xa;/v4P8aPt9n/z9wf9/B/jR9vs/wDn7g/7+D/Gj7fZ/wDP3B/38H+NH2+z/wCfuD/v4P8AGj7fZ/8A&#xd;&#xa;P3B/38H+NH2+z/5+4P8Av4P8aPt9n/z9wf8Afwf40fb7P/n7g/7+D/Gj7fZ/8/cH/fwf40fb7P8A&#xd;&#xa;5+4P+/g/xo+32f8Az9wf9/B/jWZPPDP4p0zyZY5MQT52MDj7lblFFFFFUptI02eVpZtPtJJGOWd4&#xd;&#xa;VJP1JFM/sPSP+gXZf+A6f4Uf2HpH/QLsv/AdP8KP7D0j/oF2X/gOn+FH9h6R/wBAuy/8B0/wo/sP&#xd;&#xa;SP8AoF2X/gOn+FH9h6R/0C7L/wAB0/wo/sPSP+gXZf8AgOn+FH9h6R/0C7L/AMB0/wAKP7D0j/oF&#xd;&#xa;2X/gOn+FH9h6R/0C7L/wHT/Cj+w9I/6Bdl/4Dp/hR/Yekf8AQLsv/AdP8KP7D0j/AKBdl/4Dp/hR&#xd;&#xa;/Yekf9Auy/8AAdP8KP7D0j/oF2X/AIDp/hR/Yekf9Auy/wDAdP8ACj+w9I/6Bdl/4Dp/hR/Yekf9&#xd;&#xa;Auy/8B0/wo/sPSP+gXZf+A6f4VLb6ZYWkvm21jbQyYxujiVTj6gVbooooooooooooooooooooooo&#xd;&#xa;oooooooor//Z</binary>
<binary id="image8.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAHUAjYBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKiuSVtZSpIIQkEfSsDR9I+2aPZ&#xd;&#xa;3M2p6p5k0Ku2LtwMkZq5/wAI/H/0EtV/8DHo/wCEfj/6CWq/+Bj0f8I/H/0EtV/8DHo/4R+P/oJa&#xd;&#xa;r/4GPR/wj8f/AEEtV/8AAx6P+Efj/wCglqv/AIGPR/wj8f8A0EtV/wDAx6P+Efj/AOglqv8A4GPR&#xd;&#xa;/wAI/H/0EtV/8DHo/wCEfj/6CWq/+Bj0f8I/H/0EtV/8DHo/4R+P/oJar/4GPR/wj8f/AEEtV/8A&#xd;&#xa;Ax6P+Efj/wCglqv/AIGPR/wj8f8A0EtV/wDAx6P+Efj/AOglqv8A4GPR/wAI/H/0EtV/8DHo/wCE&#xd;&#xa;fj/6CWq/+Bj0f8I/H/0EtV/8DHpfDLSNpsiyzSzGO4lQPK5ZsByBkn2rXooooooooooooooooooo&#xd;&#xa;oooooooooooooooooooooooooooooqG7/wCPSb/rm38qpeG/+Rc03/r2T/0EVp0UUUUUUUUUUUUU&#xd;&#xa;UUUUVj+Gf+QfP/1+T/8Aoxq2KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKhu/&#xd;&#xa;+PSb/rm38qpeG/8AkXNN/wCvZP8A0EVp0UUUUUUUUUUUUUUUUUVj+Gf+QfP/ANfk/wD6Matiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiobv/AI9Jv+ubfyql4b/5FzTf+vZP/QRW&#xd;&#xa;nRRRRRRRRRRRRRRRRRRWP4Z/5B8//X5P/wCjGrYooooooooooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooqG7/49Jv+ubfyql4b/wCRc03/AK9k/wDQRWnRRRVa+1C006NZLy4SBGO0FzjJqvba&#xd;&#xa;9pV3cJBb38Mkr/dRW5NFzrNtbazbaXIspnuVLIQBtA56nPse1aNFFFFFFFFFFFY/hn/kHz/9fk//&#xd;&#xa;AKMatiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiobv/j0m/65t/KqXhv/AJFz&#xd;&#xa;Tf8Ar2T/ANBFadFFFcd4z0K/1DUbS+sreO7WJQjQO2AeScnkcc461JqGsWP2m0s9d0eW3BIZHchl&#xd;&#xa;U8gH5SfpUHiOFrjx5pMSzSQM0JxJHjcv3+mQRR4iur/w5c6fJDqNzdLNIyvHcbSpHH90D1rT8Sap&#xd;&#xa;BDNFaR3l3HekgrBagBpAxwMllI4+tZ+kanqUHitNMujcGKaLftumRnXAJyCnGDinzT31744uNMXU&#xd;&#xa;Li3tkgEgEO3IOF9QfWmXNxqmieKNPtmv3u7S9bYFnwWXkAngDnnipdU8RxPrkmkvPPZRwgl54V3O&#xd;&#xa;WwCAODxyc8dhT/DOqXVxrV9ZGaa6s0XfDPMhVz90Y6Djr2rqaKKKKx/DP/IPn/6/J/8A0Y1bFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFQ3f/HpN/wBc2/lVLw3/AMi5pv8A17J/&#xd;&#xa;6CK06KKKy9Ws9Smngn02+EJjI3xSDMbj3wM5/Gqd5ol7rQjj1ma3WKFxIn2QMrbvfdnipb7RJbrx&#xd;&#xa;PY6qsqLHbIVZCDk/e6fnUXinQJtcNkYZo4vs7ljvB5zj0+lO1LRLmTXYNY0+aJbiOMxss4JQjBxj&#xd;&#xa;HOeT3qK20TUX8TRaxfT2pMcRj2QqwyMH1+tZssV//wALEupLFYlY24G+dWKYwvp3rYt9EubjVl1H&#xd;&#xa;WJoppIcfZ44QQkZ4yeec8DvUt3oxTUf7T0wQx3zAo5lBKODjkgc54GKtWMOoCVpdQniLY2rHACEx&#xd;&#xa;1yc85/HFXqKKKKx/DP8AyD5/+vyf/wBGNWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRUN3/x6Tf9c2/lVLw3/wAi5pv/AF7J/wCgitOiiiiiiiiiiiiiiiiiisfwz/yD5/8Ar8n/&#xd;&#xa;APRjVsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVDd/8AHpN/1zb+VUvDf/Iu&#xd;&#xa;ab/17J/6CK06KKKKKKKKKKKKKKKKKKx/DP8AyD5/+vyf/wBGNWxRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRUN3/x6Tf9c2/lVLw3/wAi5pv/AF7J/wCgitOiiiiiiiiiiiiiiiii&#xd;&#xa;isfwz/yD5/8Ar8n/APRjVsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVDd/8A&#xd;&#xa;HpN/1zb+VUvDf/Iuab/17J/6CK06KKKKKKKKKKKKKKKKKKx/DP8AyD5/+vyf/wBGNWxRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUN3/x6Tf9c2/lXP6FLrg0OxEFpYtEIE2F52BI&#xd;&#xa;xxkbaved4h/58tO/8CH/APiaPO8Q/wDPlp3/AIEP/wDE0ed4h/58tO/8CH/+Jo87xD/z5ad/4EP/&#xd;&#xa;APE0ed4h/wCfLTv/AAIf/wCJo87xD/z5ad/4EP8A/E0ed4h/58tO/wDAh/8A4mjzvEP/AD5ad/4E&#xd;&#xa;P/8AE0ed4h/58tO/8CH/APiaPO8Q/wDPlp3/AIEP/wDE0ed4h/58tO/8CH/+Jo87xD/z5ad/4EP/&#xd;&#xa;APE0ed4h/wCfLTv/AAIf/wCJo87xD/z5ad/4EP8A/E0ed4h/58tO/wDAh/8A4mjzvEP/AD5ad/4E&#xd;&#xa;P/8AE0ed4h/58tO/8CH/APiaPO8Q/wDPlp3/AIEP/wDE0ed4h/58tO/8CH/+JpvhQudLlMoUSfap&#xd;&#xa;twU5AO85xW1RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUN3/x6Tf9c2/lVLw3&#xd;&#xa;/wAi5pv/AF7J/wCgitOqWq3xsLeOVUDl5o4sE4xuYDP61doooorO1TVotNltoWhmmluSyxLEoOSB&#xd;&#xa;nnmi8vrmws47me2EiqpNwsJLMvH8OcZHrnHFXLeZbi3inTOyVA6564IzUtFFFFFFFFY/hn/kHz/9&#xd;&#xa;fk//AKMatiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiobv/j0m/65t/KqXhv/&#xd;&#xa;AJFzTf8Ar2T/ANBFN1aR5L6x07cViu/M8wr1IUA7fockGszWtC02xgtp7W1WOUXcADBiesg9TUia&#xd;&#xa;bDqXiLVluy8kCGH9znCk7Ovrkc9+9T6jb6fbWkOlx6e11kmRLaN8HA6tkkd29e9VtCJt9dltIrGW&#xd;&#xa;wgNt5vku4bc27G7IJ7cfhVSSRktW0MH9wt2YBJ/HgJ5ufTOeOnSr1leSaxqGlmcCPZaC9/d93bK4&#xd;&#xa;57YNW7bnxXfZ5xbQ49uXrX6jBrB8IEmzv8npfzAfmK36KKKKKKKKx/DP/IPn/wCvyf8A9GNWxRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUN3/wAek3/XNv5VS8N/8i5pv/Xsn/oI&#xd;&#xa;qe/09L3y2EskE8WfLmjxuXPXGQRziqL+HIp2je8vLm6likWSOSQrlMHOBgAYOK0ILKOC9urpWYvc&#xd;&#xa;lCwPQbRgYqO/05bx0lSeW2nQFVmixu2nqOQRg4H5VFYaQbS+a8lvrm6laLyszbeFznsB3qz9hj/t&#xd;&#xa;P7dlvM8rytvGMZzn61Bp+i2un3t1dxbmmuXLMzH7oJztHtmotSsb030N7pkkMcgGJ1kziVR90cem&#xd;&#xa;T+dS3suoTWUaWUHk3E6HLSkEQcd8Hk+mM81NplilhaLEqqHb55WH8bkfM34mrdFFFFFFFFY/hn/k&#xd;&#xa;Hz/9fk//AKMatiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiobv/j0m/65t/Kq&#xd;&#xa;Xhv/AJFzTf8Ar2T/ANBFadFFFFFFFIWAIBIBPQetG4biuRkckUtFFFFFFFFY/hn/AJB8/wD1+T/+&#xd;&#xa;jGrYooooooooooooooooooooooooooooooooooooooooooooooooqG7/AOPSb/rm38qpeG/+Rc03&#xd;&#xa;/r2T/wBBFS6jftaPDDBB9ouZ8+XFu2BguM8ngcGobXVpGvY7O/tPslxMC0SiQSBgOvIHFV4Ndu71&#xd;&#xa;XNjpTzeXI8b7pQgBDEDBI5zjt0q9fXN9CY/smni63D5szhNp/Ec07Tr77akgePyp4X2Sx7t2xsA4&#xd;&#xa;z34IqkmsXtyvn2Wl+faN9yUzhSwHU7SM+tSz6u++KKxtGuZ5IhMY3byiqE4ycjrntT7PU3mM8Nzb&#xd;&#xa;fZ7qBBI0W/eNpzg7gMdjVbQrf7TGurTyySvc5lhSRsiBWH3V/kT3p+uWX7ptQgmkgntx5jmM481F&#xd;&#xa;52N6jqB6ZrRtJ/tNpDcBdvmxq+3OcZGcVNRRRRRRRWP4Z/5B8/8A1+T/APoxq2KKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKhu/8Aj0m/65t/KqXhv/kXNN/69k/9BFU/Elq0l1YX&#xd;&#xa;TNdJBB5gke1z5g3AAYA57VBpVrDNq8N3CNTn8lWUy3jldmR0CsATn2rR8NxvFpjLIjI32iY4YYOD&#xd;&#xa;IxFUtXeQahILyXUYbcAfZzYhju4+bdtB79Kf4UQqNRYfajG9zuR7lSHYbF5OQDVGTyIpGT/icWco&#xd;&#xa;PFvbbzCp7AFVxg9fxNOv7e5F7a32pNeQk2gikNhknzNxJGFycVb0W1RnvJ4BfOJYxGJbxjuYjPG0&#xd;&#xa;gEAZ6+9WfDU0f9lRWW9TcWaiGZAeVYDB/D3qXXrqGDTJopZFWS5QwxKTyzMMAD8SKs6dE8GnWsMg&#xd;&#xa;w8cSKw9wADVmiiiiiiisfwz/AMg+f/r8n/8ARjVsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUVDd/8ek3/XNv5VS8N/8AIuab/wBeyf8AoIrToooooooqt9hthdLcpEElGSWT5d2f&#xd;&#xa;72Ov40PY20l19oliEkmABv8AmC47gHgH3FWaKKKKKKKKx/DP/IPn/wCvyf8A9GNWxRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUN3/wAek3/XNv5VS8N/8i5pv/Xsn/oIrToooooo&#xd;&#xa;orOn1MjUhp9tbvJOFV3YjEaoSep9eDgYov8AUzp1zGLi3dreVlRJIxnDE4+b0HIx+NaNFFFFFFFF&#xd;&#xa;Y/hn/kHz/wDX5P8A+jGrYooooooooooooooooooooooooooooooooooooooooooooooooqG7/wCP&#xd;&#xa;Sb/rm38qpeG/+Rc03/r2T/0EVT1+3e71rSIFmaJX87fgZ3LtXK/iMis7U9IgXW9P0q0Zre0uQ0s6&#xd;&#xa;KS3mbMEDk5HccVpW1rDpfiGC0sk8qCa2kkkTJO5lZQDz9TT5ok1nVrq0uhm2swn7rJAdmGQ2RyMc&#xd;&#xa;j8aLaGOG/n0Rh5lm8HnIpJGxSdpT1Pc5z3qhbXM1/BpunzyGScSN9uh6MqAMV3Y6DO39Kk12WOTX&#xd;&#xa;UtLu0uby2Ft5gigUkq+4jccEduKn8PBkvrqOCzubSwCIY450I+fJ3EZJ7be9T+HuTqZPJ+3yjPtx&#xd;&#xa;VvWBnRr32gc/+Oml0g50iyJ6+RH/AOgirlFFFFFFFY/hn/kHz/8AX5P/AOjGrYoooooooooooooo&#xd;&#xa;ooooooooooooooooooooooooooooooooooqG7/49Jv8Arm38qpeG/wDkXNN/69k/9BFWZ7JJ761u&#xd;&#xa;2Zg9sHCgdDuABz+VMn02ObVbbUGdxJboyKoxg7uuae9kj6lFfFm8yOJogvYhiD/So77ThdussU8l&#xd;&#xa;rcKMCaLG7b3HII7D8qksbFLJG+dpZXO6SV/vOfU446AdKrWmiwWmtXeqJJIZblQrKcbR06flUl9p&#xd;&#xa;guplnhuZbW4C7DLFgkrnO3kEYzzTrDT/ALGXkkuJbmd8BpZcZIHQYAA7nt3qr9mvLDU5JrVEksp2&#xd;&#xa;BkhX74cn5nGeMdM/TinarFf3ri0tVSK3O0zSSfxoTyq474znPrxWlFGkMSRRrtRFCqPQDpT6KKKK&#xd;&#xa;KKKx/DP/ACD5/wDr8n/9GNWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUN3/&#xd;&#xa;AMek3/XNv5VS8N/8i5pv/Xsn/oIrToooooooooooooooooorH8M/8g+f/r8n/wDRjVsUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVDd/8ek3/AFzb+VUvDf8AyLmm/wDXsn/oIq/N&#xd;&#xa;LHBE8srBUQEsT2FZsfiXSJJUjS8Bd2CqDGwyScAdKsX2r2OnOqXc4jZhkDaW/kKfFqdnNYtexzBr&#xd;&#xa;dQSz7TwB14xmsvQ/E1pf2tss86i8lJBRY2Azk47Y6Y71JLf6jqI/4kscccYORc3AzHIOmFAOc59R&#xd;&#xa;2q1pj6mjPFqghdsblmgGEx02nPOe/pSprenPe/ZFuQZ9xXbtbGR74xUd/PKmu6VEkjLHJ529QeGw&#xd;&#xa;oxmrl5e29jAZrqQRxg4zgn9BRZ3lvfQCa1kEkZ4zgj9DVSbX9LgAMl2ACzKMIx5U4PQetVry7utQ&#xd;&#xa;1JbHTZkWBBi8kGQ8ecYCnsSMn8Kl1uPVIYBc6OwknRQphlOVceoHHze+elaFlcx3lpHcROHVx1A7&#xd;&#xa;9D+uanooorH8M/8AIPn/AOvyf/0Y1bFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFQ3f8Ax6Tf9c2/lVLw3/yLmm/9eyf+giodZZRqumC4YCzzI0pc4QMAChJ6Zz0qr4i1O0mhtIIJ&#xd;&#xa;hMzXcJzF86jEg6kcD8aile7t/EOptFfWlkknlYN0md+E/hO4dKu6BG/2zULiW7iupJjHueGMqnC4&#xd;&#xa;4OSD+Bpvhi5gh0a0tZp447kbgYWcBwdx4x1qPw7eLYad9g1Ex2c1s5TEsoHmA/NuHtzj8Ks6pd/b&#xd;&#xa;rC4t9Lm8y42Bg0TZXG4ZG4cZxnjrSTXukvpJt0MRj2BVtgPnHoNnUY44xxiqyJcxX/hxLwlrlYpR&#xd;&#xa;KS2SW2DPPerM7LbeITcXxC25iC28jn5Ufnfz/DkFRz1ogZbjxD9osSGtxCVuHQ/K78bOf4sAMOOl&#xd;&#xa;N8KwRJZXMqRqskl1NvYDlsSMBmo9GBj8Sa4JAUMskbR7uN4C8keuK3JZY4YzJK6xovVmOAPxrM8L&#xd;&#xa;o8fh+1WRWVhv4YYP3zWtRRRWP4Z/5B8//X5P/wCjGrYooooooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooooqG7/49Jv+ubfyql4b/wCRc03/AK9k/wDQRU2rWTX9i1uogJYg/v4968H0yKyr&#xd;&#xa;Tw7NEVjleyS28xZWS1tzGzMpyvOT3rXvdMsdQZGvLSKcoMKZFBxUtrawWcCwW0SRRLnCIMAVA2k6&#xd;&#xa;e159sazhNzuDebsG7I75pbzSrC/kWS8s4Z3UbQ0iAkD0qSzsbWwjaOzt44EY7isa4BPrUS6Tp6Xn&#xd;&#xa;2xbOEXO4t5oQbsnqc1ZeCJ5o5XjVpI87GI5XPXFNurWC8gMN1Ck0RwSjjINFrawWcAhtYkhiXOEQ&#xd;&#xa;YAp0MEVuhSGNUUsWIUY5JyT+dUtR0z7XcRXcM8kN1ArCMg/Kc4OGHccDjIpuq6S2rRi3ubh0tSvz&#xd;&#xa;pF8rM2e5549sVoooRFUdFGBTqKKKx/DP/IPn/wCvyf8A9GNWxRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRUN3/wAek3/XNv5VS8N/8i5pv/Xsn/oIrToopjyJHt3uq7jtXJxk+gp9&#xd;&#xa;VpL+zilMUl3AkgOCrSAEfhmrNFQW13Ddeb5LFvKkaJ+MYYdRU9FFVYtQtZrgQQzLK+CSY/mC49SO&#xd;&#xa;AfalW/tmuXtvNCzKcbH+Utxn5c9R7irNFFFFY/hn/kHz/wDX5P8A+jGrYooooooooooooooooooo&#xd;&#xa;oooooooooooooooooooooooooooooqG7/wCPSb/rm38qpeG/+Rc03/r2T/0EU3XL2a1ECJOtpFIW&#xd;&#xa;33bqCsWMYBB456VUtdSuEt7mePULbVYYYmd3TCFCFJAwM5zjr2rPfxAYbQ3w1+1mITzPsQRAT32b&#xd;&#xa;s59s4q94mjuZ/wCynguvIDXcYx5YbDEHDc+nPHvTdUbULRbC0nvzOLy7EUjrGIyEI6DHQ+9asei6&#xd;&#xa;ckQRrWOQgf6yVQ7n6seTTbu4/s23trW3VpJpT5UPmOTyATlmOT0BqtLNqGjobm9ulvbXIEhEYjaP&#xd;&#xa;nAIA+9kkemKd4e6an/2EJf6U1Lq71l5Tpt19jhgkaJnaIOzuDyMHoBxznnNUtV1y+tbZYItn26G6&#xd;&#xa;ihkz92QPnHOOMgDPHHvVm+OrWGmXt9LqCuUgZ1hEK4RsZHzd8dOnNaOlWFtYWaJbRLGGAZiByxPP&#xd;&#xa;J79az/FiJb6W+qRoovLPDQyYyQScfiME8VtQsXhjZupUE/lT6KKKx/DP/IPn/wCvyf8A9GNWxRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUN3/wAek3/XNv5VS8N/8i5pv/Xsn/oI&#xd;&#xa;qbUUvCiPZrFLtzugl4V/T5sHGPpzWWdIu9RuDNeJDZbYZIQkDbw+9cZPA6U6K11VIUtFsrKONFEY&#xd;&#xa;ud+5gBxu2lcE+2av6tZS3dvAYSpltplnRW4DlQeCe3XrVO+0qXXtOMOqRJbTI5aFoZS+04+90Hqe&#xd;&#xa;Kes2vBQgsLMADG77Sc/XG2rN1p8lxbW5afN3bnek2zA3YwTt6cgn86rPa6jqq+TqUcNtbZBeOKTz&#xd;&#xa;DL3AzgbcEA8das6TZy2f23zdv766kmXBz8pxiq32K80t5P7JiimimcyPFLIU2uerA4Oc+nbFVr/Q&#xd;&#xa;ri5hil3I1293FPOScAKmcAfQHHvWxqVoL/Tri0L7BNGU3YzjI61V0fUzdRrb3NvLaXKr/q5RjeBx&#xd;&#xa;lfUdM/WquvSf2op0WBJHE52Tzou5YP4uffgce9bka7I1TOdoAzTqKKKx/DP/ACD5/wDr8n/9GNWx&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUN3/AMek3/XNv5Vzmh+J9GttEsYJ&#xd;&#xa;r+NJY4EVlKtwQOR0q9/wl2g/9BGP/vlv8KP+Eu0H/oIx/wDfLf4Uf8JdoP8A0EY/++W/wo/4S7Qf&#xd;&#xa;+gjH/wB8t/hR/wAJdoP/AEEY/wDvlv8ACj/hLtB/6CMf/fLf4Uf8JdoP/QRj/wC+W/wo/wCEu0H/&#xd;&#xa;AKCMf/fLf4Uf8JdoP/QRj/75b/Cj/hLtB/6CMf8A3y3+FH/CXaD/ANBGP/vlv8KP+Eu0H/oIx/8A&#xd;&#xa;fLf4Un/CWaBuDf2hFkd9rf4UDxZoAJI1CIE9flbn9KX/AIS7Qf8AoIx/98t/hR/wl2g/9BGP/vlv&#xd;&#xa;8KP+Eu0H/oIx/wDfLf4Uf8JdoP8A0EY/++W/wo/4S7Qf+gjH/wB8t/hS+FJUm0qSWNtyPdTMp9QX&#xd;&#xa;OK2qKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKTrUf2aD/AJ4x/wDfIo+zQf8A&#xd;&#xa;PGP/AL5FH2aD/njH/wB8ij7NB/zxj/75FH2aD/njH/3yKPs0H/PGP/vkUfZoP+eMf/fIo+zQf88Y&#xd;&#xa;/wDvkUfZoP8AnjH/AN8is/XRbwaVMDAmZsQKQo4Z/lB+mTWd4T05dLSfSLpYpbiLE5kUZUq3AHPO&#xd;&#xa;flNdD9mg/wCeMf8A3yKPs0H/ADxj/wC+RR9mg/54x/8AfIo+zQf88Y/++RR9mg/54x/98ij7NB/z&#xd;&#xa;xj/75FH2aD/njH/3yKPs0H/PGP8A75FH2aD/AJ4x/wDfIp6oqLtRQo9AMU6iiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiise//wBL1yytV/eRQhpbiPsOP3ZP/AgcfSjU&#xd;&#xa;v9E1mxvB+7hfdFcOP4sjEYPr8xOPrWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRWBYXtq2tajdy3MMJBFr5byAH5Cfm+h3fpUut3en3Glzf6bAWiHnIF&#xd;&#xa;lXlk+ZR+YFaVhM1zp9tO+N8sSu2OmSAasUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUVmzaBpNxM802n27yOdzMyck+tYXhfQ9LurW9a4sYJCl7KillzhQR&#xd;&#xa;gV1saLFGscahUQBVA6ACnUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVm6pqM9tJH&#xd;&#xa;bWNqLu8cF/KMmwbBwW3HjqRx71S/tPxH/wBC9H/4Gr/hR/afiP8A6F6P/wADV/wo/tPxH/0L0f8A&#xd;&#xa;4Gr/AIUf2n4j/wChej/8DV/wo/tPxH/0L0f/AIGr/hR/afiP/oXo/wDwNX/Cj+0/Ef8A0L0f/gav&#xd;&#xa;+FH9p+I/+hej/wDA1f8ACj+0/Ef/AEL0f/gav+FH9p+I/wDoXo//AANX/Cj+0/Ef/QvR/wDgav8A&#xd;&#xa;hR/afiP/AKF6P/wNX/Cj+0/Ef/QvR/8Agav+FH9p+I/+hej/APA1f8KP7T8R/wDQvR/+Bq/4Uf2n&#xd;&#xa;4j/6F6P/AMDV/wAKP7T8R/8AQvR/+Bq/4Uf2n4j/AOhej/8AA1f8KP7T8R/9C9H/AOBq/wCFH9p+&#xd;&#xa;I/8AoXo//A1f8KP7T8R/9C9H/wCBq/4Uf2n4j/6F6P8A8DV/wrH8N32tRW12LXR0nU3crMTdKu1s&#xd;&#xa;8r749a2P7T8R/wDQvR/+Bq/4Uf2n4j/6F6P/AMDV/wAKP7T8R/8AQvR/+Bq/4Uf2n4j/AOhej/8A&#xd;&#xa;A1f8KP7T8R/9C9H/AOBq/wCFH9p+I/8AoXo//A1f8KP7T8R/9C9H/wCBq/4Uf2n4j/6F6P8A8DV/&#xd;&#xa;wo/tPxH/ANC9H/4Gr/hR/afiP/oXo/8AwNX/AAo/tPxH/wBC9H/4Gr/hR/afiP8A6F6P/wADV/wo&#xd;&#xa;/tPxH/0L0f8A4Gr/AIUf2n4j/wChej/8DV/wo/tPxH/0L0f/AIGr/hR/afiP/oXo/wDwNX/Cj+0/&#xd;&#xa;Ef8A0L0f/gav+FH9p+I/+hej/wDA1f8ACj+0/Ef/AEL0f/gav+FH9p+I/wDoXo//AANX/Cj+0/Ef&#xd;&#xa;/QvR/wDgav8AhSR6zq0d7aQ3+jpbRXEvlCQXIfBwT0A9q6CiiiiiiiiiiiiiiiiiiiiiiiiseX/k&#xd;&#xa;b7b/AK8ZP/Q0rYooooooooooooooooooooorA8H/APHnf/8AX/N/MVv0UUUUUUUUUUUUUUUUUUUV&#xd;&#xa;j67/AMfmjf8AX6P/AEW9bFFFFFFFFFFFFFFFFFFFFFFFFFY8v/I323/XjJ/6GlbFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFYHg/wD487//AK/5v5it+iiiiiiiiiiiiiiiiiiiisfXf+PzRv8Ar9H/AKLetiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiseX/kb7b/rxk/9DStiiiiiiiiiiiiiiiiiiiiiisDwf/x53/8A1/zfzFb9&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFY+u/8fmjf9fo/wDRb1sUUUUUUUUUUUUUUUUUUUUUUUUVjy/8jfbf9eMn&#xd;&#xa;/oaVsUUUUUUUUUUUUUUUUUUUUUVgeD/+PO//AOv+b+YrfoooooooooooooooooooorH13/j80b/r&#xd;&#xa;9H/ot62KKKKKKKKKKKKKKKyNQvtQXVorDT47ZmaBpmadmAwGAwMfWk3eI/8AnnpX/fcn+FG7xH/z&#xd;&#xa;z0r/AL7k/wAKN3iP/nnpX/fcn+FG7xH/AM89K/77k/wo3eI/+eelf99yf4UbvEf/ADz0r/vuT/Cj&#xd;&#xa;d4j/AOeelf8Afcn+FG7xH/zz0r/vuT/Cjd4j/wCeelf99yf4VVaz8QNqkd/jTN6QtCF3yYwSDnp7&#xd;&#xa;Va3eI/8AnnpX/fcn+FG7xH/zz0r/AL7k/wAKN3iP/nnpX/fcn+FG7xH/AM89K/77k/wo3eI/+eel&#xd;&#xa;f99yf4UbvEf/ADz0r/vuT/Cjd4j/AOeelf8Afcn+FG7xH/zz0r/vuT/Cjd4j/wCeelf99yf4UwX2&#xd;&#xa;r22o2UF9FY+VdOyZhZywwpbuPatuo5nMcMjgZKqT+lYljeeIL6yguo4tMVJkDqGeTIBGeeKn3eI/&#xd;&#xa;+eelf99yf4UbvEf/ADz0r/vuT/Cjd4j/AOeelf8Afcn+FG7xH/zz0r/vuT/Cjd4j/wCeelf99yf4&#xd;&#xa;UbvEf/PPSv8AvuT/AAo3eI/+eelf99yf4UbvEf8Azz0r/vuT/Cjd4j/556V/33J/hVLS9P1/TIpo&#xd;&#xa;4/7McTTPMSzycFu3Sru7xH/zz0r/AL7k/wAKN3iP/nnpX/fcn+FG7xH/AM89K/77k/wo3eI/+eel&#xd;&#xa;f99yf4UbvEf/ADz0r/vuT/Cjd4j/AOeelf8Afcn+FG7xH/zz0r/vuT/Cjd4j/wCeelf99yf4UbvE&#xd;&#xa;f/PPSv8AvuT/AAqxol9Nf2JluEjSVJXiYRklcqxHGfpWhWdrV9cWNvAbVInlmnSFRKSFG7ucVBu8&#xd;&#xa;R/8APPSv++5P8KN3iP8A556V/wB9yf4UbvEf/PPSv++5P8KN3iP/AJ56V/33J/hRu8R/889K/wC+&#xd;&#xa;5P8ACjd4j/556V/33J/hRu8R/wDPPSv++5P8KN3iP/nnpX/fcn+FG7xH/wA89K/77k/wqreWfiC7&#xd;&#xa;ltZGGmKbabzVAeTk7SMHj3q1u8R/889K/wC+5P8ACjd4j/556V/33J/hRu8R/wDPPSv++5P8KN3i&#xd;&#xa;P/nnpX/fcn+FG7xH/wA89K/77k/wo3eI/wDnnpX/AH3J/hRu8R/889K/77k/wo3eI/8AnnpX/fcn&#xd;&#xa;+FG7xH/zz0r/AL7k/wAKje+1i0u7NL2KxMVzOIcws5YEgnPI9q3KKKKKx3/5HGH/AK8JP/RiVsUU&#xd;&#xa;UUUUUUUUUUUUUUUUVj6x/wAhfRf+vh//AEU1bFQ3f/HpN/1zb+VUvDf/ACLmm/8AXsn/AKCK06KK&#xd;&#xa;KKKKKKKKKKKKKKKKx/DP/IPn/wCvyf8A9GNWxWP4i+7pv/YQh/ma2KKKKKKKKKKKKKKKKKKKx9e/&#xd;&#xa;4+NH/wCv9f8A0B62KKKKKx3/AORxh/68JP8A0YlbFFFFFFFFFFFFFFFFFFFY+sf8hfRf+vh//RTV&#xd;&#xa;sVDd/wDHpN/1zb+VUvDf/Iuab/17J/6CK06KKKKKKKKKKKKKKKKKKx/DP/IPn/6/J/8A0Y1bFY/i&#xd;&#xa;L7um/wDYQh/ma2KKKKKKKKKKKKKKKKKKKx9e/wCPjR/+v9f/AEB62KKKKKx3/wCRxh/68JP/AEYl&#xd;&#xa;bFFFFFFFFFFFFFFFFFFFY+sf8hfRf+vh/wD0U1bFQ3f/AB6Tf9c2/lVLw3/yLmm/9eyf+gitOiii&#xd;&#xa;iiiiiiiiiiiiiiisfwz/AMg+f/r8n/8ARjVsVj+Ivu6b/wBhCH+ZrYoooooooooooooooooorH17&#xd;&#xa;/j40f/r/AF/9Aetiiiiisd/+Rxh/68JP/RiVsUUUUUUVAt3bPdvarcRG4QbmiDjco45I69x+dT0U&#xd;&#xa;VBHd20txJbx3ETzR/fjVwWX6jtU9FFFFFFY+sf8AIX0X/r4f/wBFNWxUN3/x6Tf9c2/lVLw3/wAi&#xd;&#xa;5pv/AF7J/wCgitOiiiiiiiiiiiiiiiiiisfwz/yD5/8Ar8n/APRjVsVj+Ivu6b/2EIf5mtiiiiii&#xd;&#xa;obm6t7OLzbqeOGPON0jBRn6mpVIZQykEEZBHelooooqBru2S7W1a4iFw43LEXG4jnkDr2P5VPRRR&#xd;&#xa;RWPr3/Hxo/8A1/r/AOgPWxRRRRWO/wDyOMP/AF4Sf+jErYoooormtS1G5u/E0egxMIIGhLzPjcXU&#xd;&#xa;j7o6bTjPPvUy+E7KJhJbzXSTId0bNMzBWHQkZ5Ge1VtPkt/+E8vofs7fa1tl8y48zhxiP+DHHbv2&#xd;&#xa;p994qktdau9Mh0ya5kgiDqYiWLkhTggDgfN1/wAaWPxPOmj3d9qGmPYtCQI4pnK+ccZwCVHp71cG&#xd;&#xa;parEPMutJUQD7xgnMr+2FCjPNZHh/wD5HvXP90f0rYn1oyX0ljpcMd5cwjMqmbYqDp1wec9qND1s&#xd;&#xa;arLd28kHkXNpJslQNuXqRwcDPQ1r0UUUVj6x/wAhfRf+vh//AEU1bFQ3f/HpN/1zb+VUvDf/ACLm&#xd;&#xa;m/8AXsn/AKCK06KKp6tLcw6VdS2al7hIyY1C7iW7cd64Xw3Bot3YNLqurOlzvO5JLjytvsOefrXX&#xd;&#xa;aOI9K0TfNqcd1apkpPwoC56Zyc896rWuvanfQy3Nno4NqpOySacxmRcZDAbelMtfFRuPC9xrP2MK&#xd;&#xa;YX2+V5mc8gdce/pWpBqfm6Aup+VjNv5/l7v9nOM4qv4f1t9c0iS9S1EbqzIsZkyCQBjnHHX0rKvP&#xd;&#xa;GT2BH2m2siBIEdYb4SOnqdu3tV3VfE6afcaaiWklxHfDcCh+YDjouOTz0pNL8Q3l3dSJf6PNp9si&#xd;&#xa;M5uJiQox65UAfnTbvxJdxabJqdtp0c2nqMrIbjazDOPu7T3962dNvotSsIbyDPlyjIyMHrj+lWqK&#xd;&#xa;KKx/DP8AyD5/+vyf/wBGNWxWP4i+7pv/AGEIf5mtiiisTxBotrewz3srzrLFA23ZKVHAJHArnvA+&#xd;&#xa;kQanpn226luWmjuCFxMwGAFI4/GtjUfFTWOvtpa6fJcER7g0RLMTtyBtArL1rWnvvD876voU8Ecc&#xd;&#xa;0YWN5WQuTu5BK9sfrXYIzjT1e3iDOIgUjZsAnHAz/WuauvGhsnjNzb2bIZAj/Z70Sug7naFq9qvi&#xd;&#xa;GWz1OxsbWyW4e8TehaXZj9DTL/xDe6SIZdU02OG3kkEZeO48wg4J6bR6Vb1vXodK2QpG1zeyj91b&#xd;&#xa;R/eb64yQOvOO1UdQ8R6jpctqt7pUSLcyCNSl1ux0/wBn3qrf/wDJTtN/69T/ACkrcv8AVfIu0sbN&#xd;&#xa;I7m+dS/kmXZtUY5JwcdeOOar6frsk2syaVfWgtrpUEihJPMVh35wMdq26KKx9e/4+NH/AOv9f/QH&#xd;&#xa;rYoooorHf/kcYf8Arwk/9GJWxRRRRXPalpVxDr6a7abZfLiKzQnO4qB/AAOW68HHOKcviOaZhFDo&#xd;&#xa;mqJI52o01vtRSehYg8D1PpVPTrS7X4g391NbusT2qr5oU7C2I8gHv0P5U6ytLlPiJqF01vKLd7YK&#xd;&#xa;spQ7ScR8A9Ox/KrfjPTG1TQJY4xI0kJ81EjXJcgEYx+NEWvXV2Vt7TR7+GdvuyXkJSIY5O4jJHHt&#xd;&#xa;1xVTQ7S5i8Z6xcS28qQyKNkjIQrdOh71TvdAh03WbrULi0u9Qgu2JWO13b0cnJztI+X8a2PDVpbw&#xd;&#xa;m5ubXTZbGObaNs5fzWIzkkMTxzxj3rdoooorH1j/AJC+i/8AXw//AKKatiobv/j0m/65t/KqXhv/&#xd;&#xa;AJFzTf8Ar2T/ANBFadFFRz+d5D/Zwhmx8gkJC598Vyv9qR3FkYdQ8L6gXcFZBDafKfocg0208M31&#xd;&#xa;v4S1DTXliaSd98WGYhR8px0zng1Ho+uX1noi2d7oWpBoo/LRorckFQMZOcVW8N2MupfD68tICokk&#xd;&#xa;lbbuzjjae30q1b6tPF4aXTW0PVzMLXydwtvlztxnr0qtpekai/gK6tFiltrrzjIqurIxAweBjPOM&#xd;&#xa;CqWqxvceG4NOsvD+pR3CMrySPbE7jg7uck8k1rahY3b6j4WdLWZlgVPNIQkR/d+96dO9dVqFot/Y&#xd;&#xa;T2jsUWZChYdRmuMi02x063FhfaFqt7LHw8tuJDE/ORj5gOhHbrXX6Raiz0yC3EKQhAcRozELkk9W&#xd;&#xa;571dooorH8M/8g+f/r8n/wDRjVsVj+Ivu6b/ANhCH+ZrYooqtqSs+m3SIpZmhcAAZJODWD4AtLiz&#xd;&#xa;0GSO6glgkNwx2yIVOMLzg1Wksro/EqO7FtN9mEeDNsOzPlkdenWrnjy1uLvw/wCVawSTSecp2xqW&#xd;&#xa;OOewp/iWwvLzwuIrMss8aq5UZDHA5UY5z7Vy+uxNeaHa2GneH9SheGQOzPbHng555J5NbeoWV0/i&#xd;&#xa;nQZktpmiiiAkcISqHB6ntUvj+0ubzSLZLW3lndblWKxoWIG1ueKqeLbPUbfxHY6zY2rXYiQJ5cas&#xd;&#xa;xBBY5OB0+aqfinVjqNzpKnTr602XIObmLYG5HTmte9tLlviJp90tvKbdLYq0oQ7QcPwT07j86TX9&#xd;&#xa;FiGsrrEsFzeRFPLkt7fdvzxtI2kcdc8+lP0C0tH1I3dpo91ZGNCryXhcO2em0EkEcHPpxXT0UVj6&#xd;&#xa;9/x8aP8A9f6/+gPWxRRRRWO//I4w/wDXhJ/6MStiiiiiiiiiiiiiiiiiiisfWP8AkL6L/wBfD/8A&#xd;&#xa;opq2Khu/+PSb/rm38qpeG/8AkXNN/wCvZP8A0EVp0UUUUU1lDqVYZBGDVbTtNtNLtvs9jD5UW4tt&#xd;&#xa;3E8n6mrdFFFFFFFFFFY/hn/kHz/9fk//AKMatisfxF93Tf8AsIQ/zNbFFFFFFFFFFFVL/TbXUVRb&#xd;&#xa;pGcIcrtkZP8A0Eiq1v4d0u2uY7iO2Yyx5Kl5XcDIx0YkVqUUUUUVj69/x8aP/wBf6/8AoD1sUUUU&#xd;&#xa;Vjv/AMjjD/14Sf8AoxK2KKKKKKKKKKKKKKKKKKKx9Y/5C+i/9fD/APopq2Khu/8Aj0m/65t/KqXh&#xd;&#xa;v/kXNN/69k/9BFadFFFFFFFFFFFFFFFFFFY/hn/kHz/9fk//AKMatisfxF93Tf8AsIQ/zNbFFFFF&#xd;&#xa;FFFFFFFFFFFFFFY+vf8AHxo//X+v/oD1sUUUUVjv/wAjjD/14Sf+jErYoooooooooooooooooorH&#xd;&#xa;1j/kL6L/ANfD/wDopq2Khu/+PSb/AK5t/KqXhv8A5FzTf+vZP/QRWnRRRRRRRRRRRRRRRRRRWP4Z&#xd;&#xa;/wCQfP8A9fk//oxq2Kx/EX3dN/7CEP8AM1sUUUUUUUUUUUUUUUUUUVj69/x8aP8A9f6/+gPWxRRR&#xd;&#xa;RWO//I4w/wDXhJ/6MStiiiiiiiiiiiiiiiiiiisfWP8AkL6L/wBfD/8Aopq2Khu/+PSb/rm38qpe&#xd;&#xa;G/8AkXNN/wCvZP8A0EVp0UUUUUUUUUUUUUUUUUVj+Gf+QfP/ANfk/wD6MatisfxF93Tf+whD/M1s&#xd;&#xa;UUUUUUUUUUUUUUUUUUVj69/x8aP/ANf6/wDoD1sUUUUViail9Br0N9a2DXcYtWhYLKiEEsp/iI9K&#xd;&#xa;f/aeq/8AQAm/8CYv/iqP7T1X/oATf+BMX/xVH9p6r/0AJv8AwJi/+Ko/tPVf+gBN/wCBMX/xVH9p&#xd;&#xa;6r/0AJv/AAJi/wDiqP7T1X/oATf+BMX/AMVR/aeq/wDQAm/8CYv/AIqj+09V/wCgBN/4Exf/ABVH&#xd;&#xa;9p6r/wBACb/wJi/+Ko/tPVf+gBN/4Exf/FUf2nqv/QAm/wDAmL/4qj+09V/6AE3/AIExf/FUf2nq&#xd;&#xa;v/QAm/8AAmL/AOKo/tPVf+gBN/4Exf8AxVH9p6r/ANACb/wJi/8AiqP7T1X/AKAE3/gTF/8AFUf2&#xd;&#xa;nqv/AEAJv/AmL/4qj+09V/6AE3/gTF/8VR/aeq/9ACb/AMCYv/iqgc6nf6rpskulSW0VvKzu7TRt&#xd;&#xa;wUYdAc9TW/Udwpe3lRRlmQgD8KwdLuNXsdMtbRtCldoYlQsLmLBwMf3qtf2nqv8A0AJv/AmL/wCK&#xd;&#xa;o/tPVf8AoATf+BMX/wAVR/aeq/8AQAm/8CYv/iqP7T1X/oATf+BMX/xVH9p6r/0AJv8AwJi/+Ko/&#xd;&#xa;tPVf+gBN/wCBMX/xVH9p6r/0AJv/AAJi/wDiqP7T1X/oATf+BMX/AMVR/aeq/wDQAm/8CYv/AIqj&#xd;&#xa;+09V/wCgBN/4Exf/ABVH9p6r/wBACb/wJi/+Ko/tPVf+gBN/4Exf/FUf2nqv/QAm/wDAmL/4qj+0&#xd;&#xa;9V/6AE3/AIExf/FUf2nqv/QAm/8AAmL/AOKo/tPVf+gBN/4Exf8AxVH9p6r/ANACb/wJi/8AiqP7&#xd;&#xa;T1X/AKAE3/gTF/8AFUf2nqv/AEAJv/AmL/4qpPD1vcW2nOLuEwyvPLJsLBsBnJHI471qVleIILma&#xd;&#xa;3tWtLc3EkF1HMYwwUkLnPJOKZ/aeq/8AQAm/8CYv/iqP7T1X/oATf+BMX/xVH9p6r/0AJv8AwJi/&#xd;&#xa;+Ko/tPVf+gBN/wCBMX/xVH9p6r/0AJv/AAJi/wDiqP7T1X/oATf+BMX/AMVR/aeq/wDQAm/8CYv/&#xd;&#xa;AIqj+09V/wCgBN/4Exf/ABVH9p6r/wBACb/wJi/+Ko/tPVf+gBN/4Exf/FUf2nqv/QAm/wDAmL/4&#xd;&#xa;qj+09V/6AE3/AIExf/FUf2nqv/QAm/8AAmL/AOKo/tPVf+gBN/4Exf8AxVH9p6r/ANACb/wJi/8A&#xd;&#xa;iqP7T1X/AKAE3/gTF/8AFUf2nqv/AEAJv/AmL/4qj+09V/6AE3/gTF/8VR/aeq/9ACb/AMCYv/iq&#xd;&#xa;r3DanqN5p4k0mS2jguRK8jTxtwFYdAc966Ciiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiv/Z</binary>
<binary id="image9.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAIRAmEBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKo63I8Wh6hJG7I6W0jKynBBCnBBqhaaGstpDI+papueNWOLx+pFS/8I/H/wBBLVf/&#xd;&#xa;AAMej/hH4/8AoJar/wCBj0f8I/H/ANBLVf8AwMej/hH4/wDoJar/AOBj0f8ACPx/9BLVf/Ax6P8A&#xd;&#xa;hH4/+glqv/gY9H/CPx/9BLVf/Ax6P+Efj/6CWq/+Bj0f8I/H/wBBLVf/AAMej/hH4/8AoJar/wCB&#xd;&#xa;j0f8I/H/ANBLVf8AwMej/hH4/wDoJar/AOBj0f8ACPx/9BLVf/Ax6P8AhH4/+glqv/gY9H/CPx/9&#xd;&#xa;BLVf/Ax6P+Efj/6CWq/+Bj0f8I/H/wBBLVf/AAMej/hH4/8AoJar/wCBj1n69pRsNEu7qDU9TEsU&#xd;&#xa;e5d125Ga6iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiis/X/wDkX9S/&#xd;&#xa;69Zf/QDVjT/+Qfbf9cl/kKsUUUUUUUUUUUUUUUUUVj+Lf+RY1D/rkf51sUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVn6//wAi/qX/AF6y/wDoBqxp/wDyD7b/AK5L/IVY&#xd;&#xa;ooooooooooooooooorH8W/8AIsah/wBcj/Otiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiis/X/APkX9S/69Zf/AEA1Y0//AJB9t/1yX+QqxRRRRRRRRRRRRRRRRRWP4t/5&#xd;&#xa;FjUP+uR/nWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWfr/8AyL+p&#xd;&#xa;f9esv/oBqxp//IPtv+uS/wAhViiiiqt9qNnpyK97cRwK5wpc4yahs9b0y+nEFpewzSkE7VOTik/t&#xd;&#xa;m2/t3+yNsv2jy/M3YG3H1zn9K0aKKKKKKKKKKx/Fv/Isah/1yP8AOtiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiis/X/8AkX9S/wCvWX/0A1Y0/wD5B9t/1yX+QqxRRRXG&#xd;&#xa;eJNBv5fEUGq2ltHexjaGgZsYwOvJH4fSrEutadca/aWWq6Y9tdxsDA0jBtrEjH3SepAqpe27XXxH&#xd;&#xa;MSXM1ufswO+EgN09wak1G8vtD8S6Xapfz3cN2wR1uMHGWAyNoHPNW/EGqwDUY7G2vb37cGCG2tSq&#xd;&#xa;5yNwJLrjpjv3qHw3qmoN4kvdKvDMUjiEoFwytIp+TjK/Lj5s/lUHhEahruly3V1rF8jpMYwIygGA&#xd;&#xa;qnup9an8NapqEV9qun6lOLo2QMnmY+Y+304/Ws//AISu11KK4uJtVudNkUlYLeJchlAyC3ynkkkd&#xd;&#xa;R0FdF4Q1K41XQYri62mUExlh/FjjJ9zW3RRRWP4t/wCRY1D/AK5H+dbFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFZ+v8A/Iv6l/16y/8AoBqxp/8AyD7b/rkv8hViiiis&#xd;&#xa;rULPU2vYrrTr4Jt4eCcZiIxjtznv1qtJodzqV7aXWrzQh7KQSQC0BUE5BO7dnP3R0x3p/wDYkv8A&#xd;&#xa;wlv9seanleT5fl4O7OKi1vQJtT1zTb+OaNEs3VmVgcthgePyouNDu4fEMusabNB5s8XlyJcglRjb&#xd;&#xa;yu3H90UmlaJfW/iS61i9mt2a4h8spCrAA/Ljr7LWL4Fi1mPRphafZI4/tDEi5jfdnavTBHHT9a6P&#xd;&#xa;RdCTT4Znun+03lzn7RM38XsPb/GoYdHu9KMkWi/Y0tpX80pcKzFWIAIGCOMAfrWtZQywW4E8vmys&#xd;&#xa;SzHsCeoX/ZHbPNWKKKKx/Fv/ACLGof8AXI/zrYoooooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooooooooorP1/wD5F/Uv+vWX/wBANWNP/wCQfbf9cl/kKsUUUUUUUUUUUUUUUUUVj+Lf&#xd;&#xa;+RY1D/rkf51sUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVn6//AMi/&#xd;&#xa;qX/XrL/6Aasaf/yD7b/rkv8AIVYooooooooooooooooorH8W/wDIsah/1yP862KKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKz9f/5F/Uv+vWX/ANANWNP/AOQfbf8AXJf5&#xd;&#xa;CrFFFFFFFFFFFFFFFFFFY/i3/kWNQ/65H+dbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFZ+v/APIv6l/16y/+gGrGn/8AIPtv+uS/yFWKKKKKKKKKKKKKKKKKKx/Fv/Is&#xd;&#xa;ah/1yP8AOtiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiis/X/8AkX9S&#xd;&#xa;/wCvWX/0A1RspdfFlBstNPK+WuCbh84x/u1N53iH/nz07/wIf/4mjzvEP/Pnp3/gQ/8A8TR53iH/&#xd;&#xa;AJ89O/8AAh//AImjzvEP/Pnp3/gQ/wD8TR53iH/nz07/AMCH/wDiaPO8Q/8APnp3/gQ//wATR53i&#xd;&#xa;H/nz07/wIf8A+Jo87xD/AM+enf8AgQ//AMTR53iH/nz07/wIf/4mjzvEP/Pnp3/gQ/8A8TR53iH/&#xd;&#xa;AJ89O/8AAh//AImjzvEP/Pnp3/gQ/wD8TR53iH/nz07/AMCH/wDiaPO8Q/8APnp3/gQ//wATR53i&#xd;&#xa;H/nz07/wIf8A+Jo87xD/AM+enf8AgQ//AMTR53iH/nz07/wIf/4mjzvEP/Pnp3/gQ/8A8TWZ4kl1&#xd;&#xa;s+H70XNrYrD5fzMk7FgPYFa6uiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiis/X/APkX9S/69Zf/AEA1Y0//AJB9t/1yX+QqxWd/aTf8JH/Zfljb9k+0eZnnO/bjFaNFFFFZ&#xd;&#xa;h1VpdUksLW2keSF0E0rjEaqQGOCO+DwMUuram2kx/aZrd5bRV+douXU+pHA24zznritKiiiiiiii&#xd;&#xa;sfxb/wAixqH/AFyP862KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKz&#xd;&#xa;9f8A+Rf1L/r1l/8AQDVjT/8AkH23/XJf5CstoI9Z1W+tr5fMt7NkVIs4BLIG3HvkZI9MGqdjYWun&#xd;&#xa;eOzDZwiKNtM3FQSefNAzz9BSeGdEs7rQ7G6vFa5m2Ao0jfcGeFGMcZyefWptVWz1C+cjRpdSaD90&#xd;&#xa;8iSBAjDnbyw9Qfxqfw6z3ej3MMweJVnlgWMkExIDgLn2HH4VjXF9KlhDaALssGuGjbnLfZduzd9e&#xd;&#xa;/wCmK1NJun1jU4bmcBGtrSKRQnQmZctnPptGPxqz4V/5AUZ7mWbJ/wC2r1rkAjBGRWD4GJPhKxJJ&#xd;&#xa;J/edf+ujVv0UUUUUUVj+Lf8AkWNQ/wCuR/nWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRWfr/APyL+pf9esv/AKAasaf/AMg+2/65L/IVVutI865ee3vbizeTBk8nb85A&#xd;&#xa;wCcg9himWOg29lqZ1BZZpLh4fKkZyPn+YHceOvAHHFW9Nso9OsIbOJmZIV2gt1NVbjRy87y2t9c2&#xd;&#xa;YkO6RIduGb+8cg84wPwqfS9PXTbZ4VmkmLyNKzyY3FmOT0Ap8VhFFf3N2Cxe4VFZTjA256fXPNR6&#xd;&#xa;dpVtp0t1LACZLqUySMx5OSSB9Bk4qrb21/pt84t1ik02SQbIV4eLP3jk8Y3Esep54qbVxqU0f2bT&#xd;&#xa;CkLuuTcychfYAc7vwxwat2dpBY2yW1rGIoUztQdBk5P6mp6KKKKKKKx/Fv8AyLGof9cj/Otiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiis/X/+Rf1L/r1l/wDQDVjT/wDk&#xd;&#xa;H23/AFyX+QqxRRRRRRRSbhu25G7GcZ5xSKyuoZGDKehByKdRRRRRRRWP4t/5FjUP+uR/nWxRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWfr/8AyL+pf9esv/oBqxp//IPt&#xd;&#xa;v+uS/wAhVO51S5+2S22n2P2toCBKTMI9pIBA5HPBqxp18L6KQmPypYZDFLHnO1wAcZ78Ec1nafrt&#xd;&#xa;5qdvDcWelM0Lgb2eYJtPfAI+YYxyP6VevrrUIJgtnpouoyuS5uAmDzxgj6fnTBrMI0uS8kUqYn8q&#xd;&#xa;ROu2TcFK57/McZpkOo6gJkW80owROwTekwlwTwMgDp79qdd6nOt29rYWX2uWJQ0wMoj2Bvu9RznB&#xd;&#xa;/KmrrGNPvpprcx3FiheaDfnHy7gA2MHIx+dGiWHkwrdzzSXNzMpPmSHJRWOQo9B0/Kq8luui6pay&#xd;&#xa;WzuLS6f7MLRWxHGx+beo6D7p49WJrdooooooorH8W/8AIsah/wBcj/Otiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiis/X/APkX9S/69Zf/AEA1Y0//AJB9t/1yX+QrnL+2&#xd;&#xa;Fvrd9Pcy6pElwyNF9i3EEBAp3bQcHI71reHrdYLSZkS4VZpjIGuH3O+QBuOQCOnQ+lHheOSHw5Yx&#xd;&#xa;yoyOsQBVhgj8KztRdxfzDUJtUiw37gWIcoY+xbaD82d34Yo0eA/8I7eK9rNOrXUjqk+VkZd+QxyO&#xd;&#xa;uPm6dRTLORvtkH9nTatLIZF8xb0OI/Lz8x+YAZx0pdUthBrlzdXMmoxRTxxrGbHcdxXO7dtB9RjP&#xd;&#xa;vUtrYGbRtWFql0zXkTKj3b/PIdhUZBAK88c/WtTRryC706LyJFcxL5bgHlWXggj8KqarJHeatp9j&#xd;&#xa;A6vcW04uZUB+6gUrk++XXj3raooooooorH8W/wDIsah/1yP862KKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKz9f/5F/Uv+vWX/ANANWNP/AOQfbf8AXJf5CrFFFFFFFFVo&#xd;&#xa;rG2huTcQxCNypU7OAcnOSBwTx160lnp9rYqBBEN2CDIx3ORnPLHk/wD1hVqiiiiiiisfxb/yLGof&#xd;&#xa;9cj/ADrYooooooooooooooooooooooooooooooooooooooooooooooooooooooorP1//AJF/Uv8A&#xd;&#xa;r1l/9ANWNP8A+Qfbf9cl/kKsUUUUUUUVTtdTtby5eG1fztgJeROVUg42k+vt7UNqdql/9jlfypiQ&#xd;&#xa;Iw/Hm5Gfl9fT61cooooooorH8W/8ixqH/XI/zrYooooooooooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooooooorP1/8A5F/Uv+vWX/0A1Y0//kH23/XJf5CsnztVvdZ1G0t7pLaC3ePbIEDs&#xd;&#xa;MoDtwR0OSc57YqvaNruoX9xEmopBbWjGBpBCrNJIMHO0jAGG9e1aWl38j2179qbzGspmiaQAAybV&#xd;&#xa;DZx0HXpVeCXUdXhS/s7wWtu4zFCYlYyD1Yn7pPTAz0qwt/JeaRcTQt5E8DMknAYB0PzAZ6g4Iz75&#xd;&#xa;qFdUnum0ZI8Qm+i+0OR82AoQlefXdjNVtV1fbqstm2qxaYIERgzorebuz69MY/Wi21mWXR9XaG6S&#xd;&#xa;6exiYx3SgYkOzcDgccHj8K1tIt4rbTIEiXaGXefct8x/UmqnikCPRpbxQBPZ/voW/usOM+/BPFbF&#xd;&#xa;FFFFFFFY/i3/AJFjUP8Arkf51sUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUVn6/wD8i/qX/XrL/wCgGrGn/wDIPtv+uS/yFQ2dk9vqOoXLMpW6dGUDqNqBefyo02yezkvm&#xd;&#xa;dlb7TctMuOwKqMH/AL5pthp5t/7QExV0u7hpQB2UqowfyNVxYajZD7Npktstn2E24tF7LjjHcZzy&#xd;&#xa;TV+ys47K38qPLbiWdm6ux6sfcnmszQtFm0zUtUuZpUkS7l3xKucoMscf+PDp6VLd6feJqEt5p5tW&#xd;&#xa;e4VVlFyCQNudu3H1Oc+1Sx6fPPp91BfyrvukZHWAYSMEbflyM9Oec81FoV/JLH9ju4Gt7mEEKrjH&#xd;&#xa;mIDgMPbGM+5qDXZ2v5Bo0EMkiTMEupUGRCpGfwPQ89q3qKKKKKKKx/Fv/Isah/1yP862KKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKz9f/AORf1L/r1l/9ANWNP/5B9t/1&#xd;&#xa;yX+QqxRRRRRRRSYGc4GemaAACSAMnrS0UUUUUUVj+Lf+RY1D/rkf51sUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVn6/8A8i/qX/XrL/6Aasaf/wAg+2/65L/IU2+1C106&#xd;&#xa;NZLuXy1Y7R8pJz9B9Khsdb07Ubg29pciSVU3ldjA7cgZ5HqRTJPEGlxXBt3usSBtpARiM/XGKs6h&#xd;&#xa;exWWnTXbsNka5BwSCeg6e+KyrTxZpstjBJNOBcPGpaNY2xvIHygkY68dan8/XLn95b21rbR9PLus&#xd;&#xa;l/r8pIxWhaSzPb7ruIRSISr8/KcfxD2PUZ5qvba3p11dfZoLkNLz8uxh09yMVG80o8UxQeY3lGyd&#xd;&#xa;ymeNwdRnHrgmrV9qFrp0ayXcvlqx2j5STn6D6Un9pWg083xmH2ZV3F8HgfTrUQ1vTjdtai5BmXOQ&#xd;&#xa;EbHAyecY6Cq2nTXeqXX2wyLHYRu32fyyQZ1K4ywPbnjpyKdqn9o2Uj3liyTRnb5sMpPyKDyUx7Ek&#xd;&#xa;59BWnBNHcQRzwtujkUOjeoIyDUlFFY/i3/kWNQ/65H+dbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFZ+v/wDIv6l/16y/+gGrGn/8g+2/65L/ACFZ1i6/8JBqrzsN0bRx&#xd;&#xa;xFz91Sikge2efrVK2u4br4gy+SxbytOMbHGORIDx69RVPR49T/4RmBBqVnDCYCPLeAl1HP8Atdfw&#xd;&#xa;rY0uJIvCMcUMhlRbZgrlCpbg9j0qnMjz+BrWGAK86W9u/l7gCdmxiPyBrbsr+K6soLgssZljVyhY&#xd;&#xa;ZXIziqGr3AvdLaS2LNBDcAXIxjdGh/eDH8QIzx3p2sTW0mimOEqZJFC2oXqspH7s/wCzg457VHCH&#xd;&#xa;XxPaLKcyDTWDEnPO9M0+3Ih8R3puyA0iK1szdowFDAHt83OPxrF18PKNZntDiwFo0coBwGuNyktj&#xd;&#xa;uduOfwrp7iCO30maGCNY41hYKijAHB6VT8J8eGbBT1WPBHoav6iQNOucnH7pv5VDoII0DTQRgi1i&#xd;&#xa;yD/uCr9FFY/i3/kWNQ/65H+dbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFZ+v/wDIv6l/16y/+gGrGn/8g+2/65L/ACFZ+t6O+pzROgsTsUj/AEm38w/gcjFLpWimzuhd&#xd;&#xa;zvG06w/Z0EEflxrHndjbk85zzmrEmi6ZNcm4ksLd5i24uYwST65q/VOPStPivDeR2cC3JYsZQg3Z&#xd;&#xa;PU598mopdB0maV5ZdOtnkdizM0YJJPU1eijSGJIolCRooVVAwAB0FVrfStPtbk3FvZwRTHOXVADz&#xd;&#xa;15qx5MRuBP5a+aFKB8c7Sc4z6ZAqO8srW+iEV3BHPGG3BZFyAfX9TR9itfsf2PyI/s23b5W35cem&#xd;&#xa;KsVnQaWbTUZLm2uHCXDl54nOVJxgFfQ8D14FN1DSjqc2Lm5lW2QqyRRHbkg5+b+9yBj05rTooorH&#xd;&#xa;8W/8ixqH/XI/zrYooooooooooooooooooooooooooooooooooooooooooooooooooooooorP1/8A&#xd;&#xa;5F/Uv+vWX/0A1Y0//kH23/XJf5CrFFFMaRFdEZ1DPkKCeW78etPqt/aFl53k/bLfzd23Z5q7t3TG&#xd;&#xa;M9as0VBZ3cN7bie3YtGSygkY5BIP6g1PRSEhVLMQAOST2qrFqNrO8iwSecI03s0Y3L9MjjPt16U+&#xd;&#xa;0vbe8Tdbyq5ABZc/MmezDqD7GrFFFFY/i3/kWNQ/65H+dbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFZ+v/8AIv6l/wBesv8A6Aasaf8A8g+2/wCuS/yFY2p6lKmozQya&#xd;&#xa;pFpUceBGZI1bzwQCSM+hOKsPqc9n4env5Giu/JUtHIjYEy8cnA45zwM9Ky31v7JtmXxDb6gQ6r9m&#xd;&#xa;WNFL7iF6jnjOfwq3r8F3Lr2j/Z73yNzSBf3QbawjYk89cjjFSXqXQl03Tru8eZbqWQSyIvlMQqFg&#xd;&#xa;AV6cgdKv/wBjaf5Pl/ZY87dvmbf3n139d3fOc55qO8ne1+yabaE+fMhWORzu2KoALEnqRkHB6+tR&#xd;&#xa;effaVLCL+4W8gnkWISBAjI7HAG0dR75qvol5Fp/hQ3c+7y4nmZtoycea1WPJ1xv9JNzCjdfsYUFP&#xd;&#xa;THmYzz16d6hv9Ynk0/TLvSlDfbLhUCS/LuUqxwTzjoKbqi6lp+kXMk+o/adxjjA8hUwGkVT09ia1&#xd;&#xa;7CwttNtVtrSIRxL2HU+5Pc1k3WNO8V6etoqxjUvN+0gAfPsTKn2OWP1rfooorH8W/wDIsah/1yP8&#xd;&#xa;62KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKz9f/5F/Uv+vWX/ANAN&#xd;&#xa;WNP/AOQfbf8AXJf5Cqd6uprcs1tBa3cTYKrM2wx8dBgHOetQLosk+j31rcSCJ75zIwT5hFkKMDpk&#xd;&#xa;fL7daVI9WmkVJLOytUJBM0b+Yy454UqM56deM5qzqtnPNLa3dqEee0ZmSNztV9ylTk84wCT07VWv&#xd;&#xa;9Lm1iwiN7GlveQSeZF5UhZQQR3wOo4/Gnebr0n7s2lnAG4Mqzlymf4gpXnHXFT3dhNIttcRyh761&#xd;&#xa;UhXYYEmQNwI7bto57dqhS0vtQlifU1ihihdZFhiffuYHIYtgEYPbvS2GkAaAdNvgGV2k3hGPIZ2Y&#xd;&#xa;c/Qim7dcX/Rg9u69PtpOH9c+XjHHTr2p1xpASDS7eyAWGyuVkIZjnaFYficsKsa1aG+0uaBSQflc&#xd;&#xa;YGSSrBgPxxj8aj0rVhe25N1C9ncou6SGXgqv94f7PXn2NUoQdZ16C+EcsNvp4byZGX5bnzFIJB9B&#xd;&#xa;gEHvmt+iiisfxb/yLGof9cj/ADrYoooooooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooorP1//AJF/Uv8Ar1l/9ANVbLxBo6WNuralahljUEGUcHFTf8JFo3/QUtP+/oo/4SLRv+gp&#xd;&#xa;af8Af0Uf8JFo3/QUtP8Av6KP+Ei0b/oKWn/f0Uf8JFo3/QUtP+/oo/4SLRv+gpaf9/RR/wAJFo3/&#xd;&#xa;AEFLT/v6KP8AhItG/wCgpaf9/RR/wkWjf9BS0/7+ij/hItG/6Clp/wB/RR/wkWjf9BS0/wC/oo/4&#xd;&#xa;SLRv+gpaf9/RSf8ACQaIST/aVnkjGfMHSlHiHRQABqdoAOgEoo/4SLRv+gpaf9/RR/wkWjf9BS0/&#xd;&#xa;7+ij/hItG/6Clp/39FH/AAkWjf8AQUtP+/orM8Ta5pVx4evoYNQtpJHjwqrICSa6eiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiikIBBBGQeoNR/Z4f+eMf/AHyKPs8P/PGP&#xd;&#xa;/vkUfZ4f+eMf/fIo+zw/88Y/++RR9nh/54x/98ij7PD/AM8Y/wDvkUfZ4f8AnjH/AN8ij7PD/wA8&#xd;&#xa;Y/8AvkUfZ4f+eMf/AHyKyfEUMUlrBYiJAL2YQOyqNyKQxyPxA/Ojw0Xm0xYdRRG1CEkXClBlSSSu&#xd;&#xa;ccfdI6VrfZ4f+eMf/fIo+zw/88Y/++RR9nh/54x/98ij7PD/AM8Y/wDvkUfZ4f8AnjH/AN8ij7PD&#xd;&#xa;/wA8Y/8AvkUfZ4f+eMf/AHyKPs8P/PGP/vkUfZ4f+eMf/fIqWiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisdf33i0yR/MlvaNFKf7rsyMB+I5oh/0XxRPEvK&#xd;&#xa;3sPnsT2ZNqAD8Oa2KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKQkAZJwBWN4dljmt59QkdRPdyt5gBwBsJRcD6KKPEUsaRWV0XXyrS6WaUg5IQKw&#xd;&#xa;zjvyRW1RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRTJY0mieKVQ8bqVZT0IPUVzXiXQtKtvD17NBp9vHIkeVZUAINaf8Awjei/wDQMtf+/YrVoooo&#xd;&#xa;oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooorH8W/8&#xd;&#xa;ixqH/XI/zrYoooooooooooooooooooooooooooooooooooooooooooooooooooorEvZNRuPEDWVp&#xd;&#xa;fLaxJarKcwh8kuw7/QU/+z9Z/wCg4v8A4Br/AI0f2frP/QcX/wAA1/xo/s/Wf+g4v/gGv+NH9n6z&#xd;&#xa;/wBBxf8AwDX/ABo/s/Wf+g4v/gGv+NH9n6z/ANBxf/ANf8aP7P1n/oOL/wCAa/40f2frP/QcX/wD&#xd;&#xa;X/Gj+z9Z/wCg4v8A4Br/AI0f2frP/QcX/wAA1/xo/s/Wf+g4v/gGv+NH9n6z/wBBxf8AwDX/ABo/&#xd;&#xa;s/Wf+g4v/gGv+NH9n6z/ANBxf/ANf8aP7P1n/oOL/wCAa/40f2frP/QcX/wDX/Gj+z9Z/wCg4v8A&#xd;&#xa;4Br/AI0f2frP/QcX/wAA1/xo/s/Wf+g4v/gGv+NH9n6z/wBBxf8AwDX/ABo/s/Wf+g4v/gGv+NH9&#xd;&#xa;n6z/ANBxf/ANf8azPEllqsfh+9efVxNGI/mj+yqu4fXPFaf9n6z/ANBxf/ANf8aP7P1n/oOL/wCA&#xd;&#xa;a/40f2frP/QcX/wDX/Gj+z9Z/wCg4v8A4Br/AI0f2frP/QcX/wAA1/xo/s/Wf+g4v/gGv+NH9n6z&#xd;&#xa;/wBBxf8AwDX/ABo/s/Wf+g4v/gGv+NH9n6z/ANBxf/ANf8aP7P1n/oOL/wCAa/40f2frP/QcX/wD&#xd;&#xa;X/Gj+z9Z/wCg4v8A4Br/AI0f2frP/QcX/wAA1/xo/s/Wf+g4v/gGv+NH9n6z/wBBxf8AwDX/ABo/&#xd;&#xa;s/Wf+g4v/gGv+NH9n6z/ANBxf/ANf8aP7P1n/oOL/wCAa/40f2frP/QcX/wDX/Gj+z9Z/wCg4v8A&#xd;&#xa;4Br/AI0f2frP/QcX/wAA1/xo/s/Wf+g4v/gGv+NH9n6z/wBBxf8AwDX/ABo/s/Wf+g4v/gGv+NRR&#xd;&#xa;PqVnrlla3WoLdRXEcrEeQqYK7cdP96t2iiiiiiiiiiiiiiiiiiiiiiiiiiisdP8AkcZv+wfH/wCj&#xd;&#xa;HrYooooooooooooooooooooorH8W/wDIsah/1yP862KKKKKKKKKKKKKKKKKKKKKKKKx7/wD5GfSP&#xd;&#xa;+uVx/JK2KKKKKKKKKKKKKKKKKKKKKKKKKKKKx0/5HGb/ALB8f/ox62KKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;x/Fv/Isah/1yP862KKKKKKKKKKKKKKKKKKKKKKKKx7//AJGfSP8ArlcfyStiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiisdP8AkcZv+wfH/wCjHrYooooooooooooooooooooorH8W/wDIsah/1yP862KKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKx7/wD5GfSP+uVx/JK2KKKKKKKKKKKKKKKKKKKKKKKKKKKKx0/5HGb/ALB8&#xd;&#xa;f/ox62KKKKKKKKKKKKKKKKKKKKKKx/Fv/Isah/1yP862KKKKKKKKKKKKKKKKKKKKKKKKx7//AJGf&#xd;&#xa;SP8ArlcfyStiiiiiiiiiiiiiiiiiisbUtauLTUhZWumS3j+SJWKOFwCSO/0qD+3dV/6Fy6/7/LR/&#xd;&#xa;buq/9C5df9/lo/t3Vf8AoXLr/v8ALR/buq/9C5df9/lo/t3Vf+hcuv8Av8tH9u6r/wBC5df9/lo/&#xd;&#xa;t3Vf+hcuv+/y0f27qv8A0Ll1/wB/lo/t3Vf+hcuv+/y1TW/1ca09/wD8I/c7Wt1h2eauchmOf1q5&#xd;&#xa;/buq/wDQuXX/AH+Wj+3dV/6Fy6/7/LR/buq/9C5df9/lo/t3Vf8AoXLr/v8ALR/buq/9C5df9/lo&#xd;&#xa;/t3Vf+hcuv8Av8tH9u6r/wBC5df9/lo/t3Vf+hcuv+/y0f27qv8A0Ll1/wB/lqxpOty39/PZXFhJ&#xd;&#xa;ZzQoHIdw2QfpWxRVe+uRZWFxdMpcQRNIVBxnAJx+lYya/qciK6eHbkqwBB85eRS/27qv/QuXX/f5&#xd;&#xa;aP7d1X/oXLr/AL/LR/buq/8AQuXX/f5aP7d1X/oXLr/v8tH9u6r/ANC5df8Af5aP7d1X/oXLr/v8&#xd;&#xa;tH9u6r/0Ll1/3+Wj+3dV/wChcuv+/wAtU9Yv9X1LSrmzXw/cxmZNoYyqcVc/t3Vf+hcuv+/y0f27&#xd;&#xa;qv8A0Ll1/wB/lo/t3Vf+hcuv+/y0f27qv/QuXX/f5aP7d1X/AKFy6/7/AC0f27qv/QuXX/f5aP7d&#xd;&#xa;1X/oXLr/AL/LR/buq/8AQuXX/f5aP7d1X/oXLr/v8tR3PiXULS3ee48P3McUYyzGVeBXSUU13WNG&#xd;&#xa;dzhVBJPoKwjr9+5LW2hXFxAeY5llUCRezDPqOaT+3dV/6Fy6/wC/y0f27qv/AELl1/3+Wj+3dV/6&#xd;&#xa;Fy6/7/LR/buq/wDQuXX/AH+Wj+3dV/6Fy6/7/LR/buq/9C5df9/lo/t3Vf8AoXLr/v8ALR/buq/9&#xd;&#xa;C5df9/lo/t3Vf+hcuv8Av8tH9u6r/wBC5df9/lqncX+rzarZ3g8P3IFskilfNX5t23/4mrn9u6r/&#xd;&#xa;ANC5df8Af5aP7d1X/oXLr/v8tH9u6r/0Ll1/3+Wj+3dV/wChcuv+/wAtH9u6r/0Ll1/3+Wj+3dV/&#xd;&#xa;6Fy6/wC/y0f27qv/AELl1/3+Wj+3dV/6Fy6/7/LR/buq/wDQuXX/AH+Wj+3dV/6Fy6/7/LR/buq/&#xd;&#xa;9C5df9/lrT03UEv4m+UxzxnbNCTkxt6E1dooooorHT/kcZv+wfH/AOjHrYoooooooooooooooooo&#xd;&#xa;rAs/+R31H/r1i/nW/RWfr/8AyL+pf9esv/oBqxp//IPtv+uS/wAhViiiiiiiiiiiiiiiiiisfxb/&#xd;&#xa;AMixqH/XI/zrYoqvqH/IPuf+uTfyNV9A/wCRf03/AK9Yv/QBWhRRRRRRRRRRRRRRRRRRRRRWB4d/&#xd;&#xa;5C+vf9fQ/wDQa36KKKKKx0/5HGb/ALB8f/ox62KKKKKKKKKKKKKKKKKKKwLP/kd9R/69Yv51v0Vn&#xd;&#xa;6/8A8i/qX/XrL/6Aasaf/wAg+2/65L/IVYooooooooooooooooorH8W/8ixqH/XI/wA62KKr6h/y&#xd;&#xa;D7n/AK5N/I1X0D/kX9N/69Yv/QBWhRRRRRRRRRRRRRRRRRRRRRWB4d/5C+vf9fQ/9BrfooooorHT&#xd;&#xa;/kcZv+wfH/6MetiiiiiiiiiiiiiiiiiiisCz/wCR31H/AK9Yv51v0Vn6/wD8i/qX/XrL/wCgGrGn&#xd;&#xa;/wDIPtv+uS/yFWKKKKKKKKKKKKKKKKKKx/Fv/Isah/1yP862KKr6h/yD7n/rk38jVfQP+Rf03/r1&#xd;&#xa;i/8AQBWhRRRRRRRRRRRRRRRRRRRRRWB4d/5C+vf9fQ/9BrfooooorHT/AJHGb/sHx/8Aox62KKKK&#xd;&#xa;KKKKKKKKKKKKKKKwLP8A5HfUf+vWL+db9FZ+v/8AIv6l/wBesv8A6Aasaf8A8g+2/wCuS/yFWKKK&#xd;&#xa;KKKKKKKKKKKKKKKx/Fv/ACLGof8AXI/zrYoqvqH/ACD7n/rk38jVfQP+Rf03/r1i/wDQBWhRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRWB4d/wCQvr3/AF9D/wBBrfooooorHT/kcZv+wfH/AOjHrYoooorKvtbigvG0&#xd;&#xa;+2Rri/KZEaLuCHjBfH3RyOfQ1WS98QwsJLzT7U268uLd2eTH+yO5pum3F+/im+hm1C3ltFQmO3R1&#xd;&#xa;LocryQBn16+tar6pYRmYPe26mDHmgyAbMnAz6cmhdUsHtHu0vbdrdDtaUSDap44J6dx+dNt9X026&#xd;&#xa;mWG3v7aWVs7USVSTxnpWR4Y1O8vtZ12C6mMkVrcbIV2gbRucY4HPQda27vULOx2fbLqG3352+a4X&#xd;&#xa;djrjP1FSW9xDdQrNbypLE2drowIPOOtS0UUUVgWf/I76j/16xfzrforP1/8A5F/Uv+vWX/0A1Y0/&#xd;&#xa;/kH23/XJf5CrFFFY3ibXP7EsFkji824lYJEhBwxyM5x7ZqkdU8TR2iXUmlW5jIVmjjLGUAkfw+oz&#xd;&#xa;0roFuE+yC5kzDHs8xvNG0oMZO7PTHeqf9v6P/wBBSz/7/r/jVmTULOGSGOW6hR58eUrOAXz0x606&#xd;&#xa;6vLayjEl3cRQITtDSMFBPpz9DRdXltZRiS7uIoEJ2hpGCgn05+hqO11SwvZDHaXtvO4G4rHIGIHr&#xd;&#xa;x9RT5b60huVt5bmJJ2UuI2cBiozzj04P5U201KxvmZbS7gnZRlhHIGwPwqNtZ0tJzA2oWolDbChl&#xd;&#xa;XIbOMYz1q9RRRWP4t/5FjUP+uR/nWxRVfUP+Qfc/9cm/kar6B/yL+m/9esX/AKAK0KKKKzdUl1eO&#xd;&#xa;RBplvbSoR85mcqQfbFYWjeINf1q0a5s7Cx8tXMZ3yMDkAH+orp5b60huVt5bmJJ2UuI2cBiozzj0&#xd;&#xa;4P5Vl6tq0Vxo902kapZrcxhSJDKpVAWA5zkDIyPxrR0+RzpVtLczJI/kK0kqkbWO0ZYEcY71FHre&#xd;&#xa;lSyJHFqVo7uQqqsykknoBzU93qFnY7Ptl1Db787fNcLux1xn6ioI9b0qWRI4tStHdyFVVmUkk9AO&#xd;&#xa;auTTRW8TSzSLHGgyzscAD3NUf7f0f/oKWf8A3/X/ABrNvtTvIvHmn6ckxFpNbl3j2jk4k5zjP8I/&#xd;&#xa;Kt+4uIbWFpriVIolxud2AA5x1qK01KxvmZbS7gnZRlhHIGwPwq1RRRRWB4d/5C+vf9fQ/wDQa36K&#xd;&#xa;KKKKx0/5HGb/ALB8f/ox62KKKKK4+JhYfEe7nu/3UV3AqQM3R2/djA/EGuquLqC2geaaVUjQZZj2&#xd;&#xa;FcdoH/JSNY/65P8A+hJUen6XZ6r4y1yK+h81FIIXey9/YirfiXTRpWk29tpUHlWT3SNcqDuB+ZQM&#xd;&#xa;k5PUL0robyHTUty1wkSRhl+ZRtOdwxyOeuK5/wAG/wDIweJv+vr/ANnkqOx/tmXxDrIaO0k2yLsF&#xd;&#xa;5kAR5fbt2j0/pVvwfp02mXmqRT3UErlo2McLMRFnce4HXPauooooorAs/wDkd9R/69Yv51v0Vn6/&#xd;&#xa;/wAi/qX/AF6y/wDoBqxp/wDyD7b/AK5L/IVYoorD8U2mmXtnFDqc/wBnZnAhkGcq2R07e3PrWXrc&#xd;&#xa;Wr6DpCXNlrDzRW21WilRMlchQAQuT17mq/inU3ntvDpuW8qzvSsl2g4BX5CRnrjDNU3jOGxTwdG1&#xd;&#xa;ikQizF5bKOdvbnr0qn4g/wCQ/wCFj2Hk8/8AA1q98S2B8PwYIP8ApS9/9h6teKdTvIr600qzSAPe&#xd;&#xa;A7ZphkRt69CP0rEu7aSx8f6VGbtpy6KS2xU43NxhQB2q5rtrDffEXTba5QvE9odyhiuf9Yeo57Vo&#xd;&#xa;aposOj6Hfy6BbGG7dFGVYsSu4Z+8SOmazW07VNS8KwwkaXFG9vG3nFn8wAANk8deOa6vSF2aPYoZ&#xd;&#xa;BLtt4x5ik4b5RyM881coorH8W/8AIsah/wBcj/Otiiq+of8AIPuf+uTfyNV9A/5F/Tf+vWL/ANAF&#xd;&#xa;aFFFFFch8M/+RfuP+vpv/QEqHXbWG++Ium21yheJ7Q7lDFc/6w9Rz2qXxPoem6T4V1GSwthC0gjD&#xd;&#xa;EOxyPMX1Jq1PqsmjeCNPu4oklYW8K7XzjBUVz+vQXj+Fk1O4u0BndJUghjQKityo3YDZGfWr/iUB&#xd;&#xa;7/wiHG4NKuc855iqX4jQxQaFbvDGkbi6X5kUA/deq/iS6T7VoVpfykadJGrzqSQCcY5I571N8R4o&#xd;&#xa;I9BgMUcat9qXlQAcbXqXUv8Akp2k/wDXq38pak8QHUz4s0yO3WNrUxttWfiMybXznAz0x+lR22k3&#xd;&#xa;sXi+01G6msYQ4ZBBbs3z4Ru2Me/PpXX0UUUVgeHf+Qvr3/X0P/Qa36KKKKKx0/5HGb/sHx/+jHrY&#xd;&#xa;ooooqOeGO5t5IJl3RSqUdc4yCMEVl2nhbRbK5jubeyCSxnKt5jnB/E1bg0mxttRm1CGALdTAiSTc&#xd;&#xa;TuBwemcdhS2+mWdrez3kMIS4uP8AWPuJ3fhnFSX1lb6haPa3cfmQyY3LkjODkdPcCqFj4Z0fT7tL&#xd;&#xa;q0sxHNHna3mMcZGD1PoTVuz0yzsbi5ntYRHLdNvmbcTuOSc8njqelM1PRtP1fyv7QtxN5WdnzMuM&#xd;&#xa;4z0I9BU9jZW+n2iWtpH5cMedq5Jxk5PX3JqxRRRRWBZ/8jvqP/XrF/Ot+is/X/8AkX9S/wCvWX/0&#xd;&#xa;A1Y0/wD5B9t/1yX+QqxRRVe+srfULR7W7j8yGTG5ckZwcjp7gVQsfDOj6fdpdWlmI5o87W8xjjIw&#xd;&#xa;ep9Cau6hp9rqdsba9i82IkHbuI5H0rnNZ8DWE9gU0q3it7ncCHeRyMd/X+Vb82l217pkVlfxCaNV&#xd;&#xa;UFdxAJA9sGs//hDPD/8A0Dx/39f/ABrS1LTLPVbdYL6ETRK28LuI5wRng+5qnaeFtFsrmO5t7IJL&#xd;&#xa;Gcq3mOcH8TVyTTLOXU4tReEG7hXYkm48DnjGcfxH86uVjyeFtFkvGu3sgZ2kMhfzH5YnOcZ9a2KK&#xd;&#xa;KKx/Fv8AyLGof9cj/Otiiq+of8g+5/65N/I1X0D/AJF/Tf8Ar1i/9AFaFFFFFU9N0yz0q3aCxhEM&#xd;&#xa;TNvK7iecAZ5PsKJNMs5dTi1F4QbuFdiSbjwOeMZx/EfzqS+srfULR7W7j8yGTG5ckZwcjp7gU6O2&#xd;&#xa;hjs1tETECxiMJk8KBjGfpWP/AMIZ4f8A+geP+/r/AONaNxpNjdSWkk8AdrM5gO4jYePfn7o6+lLq&#xd;&#xa;WmWeq26wX0ImiVt4XcRzgjPB9zVXXNKGoabFax21vMsbghJ5HVQACOq855rm5vAz3JjQ29haIHy8&#xd;&#xa;kE0rOVweAG49PyrrpNMs5dTi1F4QbuFdiSbjwOeMZx/EfzqS+srfULR7W7j8yGTG5ckZwcjp7gVW&#xd;&#xa;0zQ9N0mR5LC2ELSDDHexyPxJrRoooorA8O/8hfXv+vof+g1v0UUUUVjp/wAjjN/2D4//AEY9bFFF&#xd;&#xa;FFFFFFFFFFFFFFFFYFn/AMjvqP8A16xfzrforP1//kX9S/69Zf8A0A1Y0/8A5B9t/wBcl/kKsUUU&#xd;&#xa;UUUUUUUUUUUUUUVj+Lf+RY1D/rkf51sUVX1D/kH3P/XJv5Gq+gf8i/pv/XrF/wCgCtCiiiiiiiii&#xd;&#xa;iiiiiiiiiiiisDw7/wAhfXv+vof+g1v0UUUUVjp/yOM3/YPj/wDRj1sUUUUUUUUUUUUUUUUUUVgW&#xd;&#xa;f/I76j/16xfzrforP1//AJF/Uv8Ar1l/9ANWNP8A+Qfbf9cl/kKsUUUUUUUUUUUUUUUUUVj+Lf8A&#xd;&#xa;kWNQ/wCuR/nWxRVfUP8AkH3P/XJv5Gq+gf8AIv6b/wBesX/oArQooooooooooooooooooooorA8O&#xd;&#xa;/wDIX17/AK+h/wCg1v0UUUUVjp/yOM3/AGD4/wD0Y9bFFFFFFFFFFFFFFFFFFFYFn/yO+o/9esX8&#xd;&#xa;636Kz9f/AORf1L/r1l/9ANWNP/5B9t/1yX+QqxRRRRRRRRRRRRRRRRRWP4t/5FjUP+uR/nWxRVfU&#xd;&#xa;P+Qfc/8AXJv5Gq+gf8i/pv8A16xf+gCtCiiiiiiiiiiiiiiiiiiiiisDw7/yF9e/6+h/6DW/RRRR&#xd;&#xa;RWG08MHi+UzSpGDYR4LsBn94/rWn/aFl/wA/lv8A9/V/xo/tCy/5/Lf/AL+r/jR/aFl/z+W//f1f&#xd;&#xa;8aP7Qsv+fy3/AO/q/wCNH9oWX/P5b/8Af1f8aP7Qsv8An8t/+/q/40f2hZf8/lv/AN/V/wAaP7Qs&#xd;&#xa;v+fy3/7+r/jR/aFl/wA/lv8A9/V/xo/tCy/5/Lf/AL+r/jR/aFl/z+W//f1f8aP7Qsv+fy3/AO/q&#xd;&#xa;/wCNH9oWX/P5b/8Af1f8aP7Qsv8An8t/+/q/40f2hZf8/lv/AN/V/wAaP7Qsv+fy3/7+r/jR/aFl&#xd;&#xa;/wA/lv8A9/V/xo/tCy/5/Lf/AL+r/jR/aFl/z+W//f1f8axtOljm8a6i8UiyL9lj5U5HWuiorP1/&#xd;&#xa;/kX9S/69Zf8A0A0WF/ZiwtwbuAERLkGQeg96n/tCy/5/Lf8A7+r/AI0f2hZf8/lv/wB/V/xo/tCy&#xd;&#xa;/wCfy3/7+r/jR/aFl/z+W/8A39X/ABo/tCy/5/Lf/v6v+NH9oWX/AD+W/wD39X/Gj+0LL/n8t/8A&#xd;&#xa;v6v+NH9oWX/P5b/9/V/xo/tCy/5/Lf8A7+r/AI0f2hZf8/lv/wB/V/xo/tCy/wCfy3/7+r/jR/aF&#xd;&#xa;l/z+W/8A39X/ABo/tCy/5/Lf/v6v+NH9oWX/AD+W/wD39X/Gj+0LL/n8t/8Av6v+NH9oWX/P5b/9&#xd;&#xa;/V/xo/tCy/5/Lf8A7+r/AI0f2hZf8/lv/wB/V/xrJ8U3tpJ4bv0S5hZjEcBZASea36Kr6h/yD7n/&#xd;&#xa;AK5N/I1n6FfWiaDpytdQKwtYgQZACDtFX/7Qsv8An8t/+/q/40f2hZf8/lv/AN/V/wAaP7Qsv+fy&#xd;&#xa;3/7+r/jR/aFl/wA/lv8A9/V/xo/tCy/5/Lf/AL+r/jR/aFl/z+W//f1f8aP7Qsv+fy3/AO/q/wCN&#xd;&#xa;H9oWX/P5b/8Af1f8aP7Qsv8An8t/+/q/40f2hZf8/lv/AN/V/wAaP7Qsv+fy3/7+r/jR/aFl/wA/&#xd;&#xa;lv8A9/V/xo/tCy/5/Lf/AL+r/jR/aFl/z+W//f1f8aP7Qsv+fy3/AO/q/wCNH9oWX/P5b/8Af1f8&#xd;&#xa;aP7Qsv8An8t/+/q/40f2hZf8/lv/AN/V/wAaP7Qsv+fy3/7+r/jR/aFl/wA/lv8A9/V/xo/tCy/5&#xd;&#xa;/Lf/AL+r/jR/aFl/z+W//f1f8ax/DTrJqmuujBlN0MFTkH5a6Giiiiiqtzp1jdyCS6s7edwNoaSJ&#xd;&#xa;WIHpkiov7E0n/oF2X/gOn+FH9iaT/wBAuy/8B0/wo/sTSf8AoF2X/gOn+FH9iaT/ANAuy/8AAdP8&#xd;&#xa;KP7E0n/oF2X/AIDp/hR/Ymk/9Auy/wDAdP8ACj+xNJ/6Bdl/4Dp/hR/Ymk/9Auy/8B0/wo/sTSf+&#xd;&#xa;gXZf+A6f4Uf2JpP/AEC7L/wHT/Cj+xNJ/wCgXZf+A6f4Uf2JpP8A0C7L/wAB0/wo/sTSf+gXZf8A&#xd;&#xa;gOn+FH9iaT/0C7L/AMB0/wAKP7E0n/oF2X/gOn+FH9iaT/0C7L/wHT/Cj+xNJ/6Bdl/4Dp/hR/Ym&#xd;&#xa;k/8AQLsv/AdP8KP7E0n/AKBdl/4Dp/hU1tYWdmzNa2kEDMMExRhSfyFWaKbIiSxtHIqujgqysMgg&#xd;&#xa;9QRVL+xNJ/6Bdl/4Dp/hR/Ymk/8AQLsv/AdP8KP7E0n/AKBdl/4Dp/hR/Ymk/wDQLsv/AAHT/Cj+&#xd;&#xa;xNJ/6Bdl/wCA6f4Uf2JpP/QLsv8AwHT/AAo/sTSf+gXZf+A6f4Uf2JpP/QLsv/AdP8KP7E0n/oF2&#xd;&#xa;X/gOn+FH9iaT/wBAuy/8B0/wo/sTSf8AoF2X/gOn+FH9iaT/ANAuy/8AAdP8KP7E0n/oF2X/AIDp&#xd;&#xa;/hR/Ymk/9Auy/wDAdP8ACj+xNJ/6Bdl/4Dp/hR/Ymk/9Auy/8B0/wo/sTSf+gXZf+A6f4Uf2JpP/&#xd;&#xa;AEC7L/wHT/Cj+xNJ/wCgXZf+A6f4Uf2JpP8A0C7L/wAB0/wq/RVfUP8AkH3P/XJv5GsrQ9H0yXQt&#xd;&#xa;Pkk060d3to2ZmgUkkqMknFXv7E0n/oF2X/gOn+FH9iaT/wBAuy/8B0/wqIaboTW7XC2WnGFQSZBE&#xd;&#xa;m0AdecdsH8qkXRtIdQy6bYlSMgiBMEflS/2JpP8A0C7L/wAB0/wo/sTSf+gXZf8AgOn+FH9iaT/0&#xd;&#xa;C7L/AMB0/wAKP7E0n/oF2X/gOn+FH9iaT/0C7L/wHT/Cj+xNJ/6Bdl/4Dp/hR/Ymk/8AQLsv/AdP&#xd;&#xa;8KZDpWizxiSHT7CRCSAywoRkHB7eop/9iaT/ANAuy/8AAdP8KP7E0n/oF2X/AIDp/hR/Ymk/9Auy&#xd;&#xa;/wDAdP8ACmQ6Vos8Syw6fYSRsMq6QoQR7HFIumaG07QLY6eZkAZoxCm4A9CRili0rRZgxi0+wcKx&#xd;&#xa;RtsKHDDqDx1FP/sTSf8AoF2X/gOn+FH9iaT/ANAuy/8AAdP8KP7E0n/oF2X/AIDp/hR/Ymk/9Auy&#xd;&#xa;/wDAdP8ACszwxFHBqWuRQxrHGt0AqoMAfL2FdFRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRVfUP+Qfc/8AXJv5Gq+gf8i/pv8A16xf+gCszxH9jbWNKj1GYRWrJOWLTGMEjZjk&#xd;&#xa;EU+wsvDkl3H9iuI5Z0IdVS9ZzxznG45o0a4Fp4PluWjEghFzIUJwGxI5xVu/1gWFlY3H2Z5RcyJH&#xd;&#xa;si5ZcqW4AHPTpVW81zUdNjWfUNICWu7EkkM/mFBg8kbRxxVi1k+waxc2k75S7b7RFI5wCx+Xy1z1&#xd;&#xa;IC549elT6zdG2sWWNfMnmxHHGp+ZsnBIHU4BLfQVn2OoXgtxa6baLepZf6LLNLN5RMiDB4weOhzn&#xd;&#xa;vWjbaktxp81yI9rwb1kjzwHX7wB7jI61U0/V9Q1GO2ng0sLbShSzyzbWXOMkLt+YDse9ZdheasPE&#xd;&#xa;2tiKxjlYGHdG11tEY2HGPlOcjn29639EvP7Q0uO58hbcszgxq2QCHKnnA9M1DLqd3LKw0uyS7iQ4&#xd;&#xa;aVpvLUn/AGTg7sdD6EEVPNd3T2Uc9jZGV3PMU7+SVHPJyDz0496ZYahNNcvaXlstvdKgl2JJ5ilC&#xd;&#xa;cA5wOcg8e1ZOn3Rs/AVrKF3ExJH1xje4XP4bs/hW1pWmw6ZZxwR/O6qA8rZJc45PJPU847Vma4ke&#xd;&#xa;k3tvrESEsX8mSIMQH3kAN6AjntzmugooorA8O/8AIX17/r6H/oNb9FFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFV9Q/5B9z/wBcm/kar6B/yL+m/wDXrF/6AKi1Cza413TZWhEk&#xd;&#xa;EUcwckAhSdmP5GtCO2gibdHBGjeqoAaxLayuU8G3do0LC4eO5Cx9yWZyv55FN1t3tbHQ2MMkjx3U&#xd;&#xa;eY4wCxPlvwMmjU5b/XNOn0+10+a1aVcNJeAKu322ljnp29a0dZ09r62DW5RL2E7raRycI/rjv+IN&#xd;&#xa;QWqTajqaX1xbS28Fum2GKcAOshyGfgkEFWA5PY8d6xjo8dneXrXumXl81zcyTpJaSMFVGPCn5l+b&#xd;&#xa;g9j1HNbVjZfZ9DnhitfI80OyRb2ZvmHG4kn5vXkjNWtGikg0WwhlUpJHbxqynqCFAIrN8u50nXNR&#xd;&#xa;vvsk13Hf+VsFsASmxcHdkjrnjGelWvDUM0GiQpcRNFJvlYo/UZkYjP4EVUsHvtDtfsk9hLdrvd43&#xd;&#xa;tMNgMxbDbiMHntS6rBdzC3e/tnurcIRJb2TkMJc8MDlTtAyOvUjjvUOgWYi1u4ng0+7s7drZUxct&#xd;&#xa;uJcMScfM3GCKI9OuP+EHgtJF8qaJEd1ftscMR9cCtrTNRt9UsY7u1bdG46Hqp7g+4rJ8RSR6jcW+&#xd;&#xa;iwSL9rLrOd3RVUg8+57fSuhooorA8O/8hfXv+vof+g1v0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUVX1D/AJB9z/1yb+RqvoH/ACL+m/8AXrF/6AK0KKKhuLWG5aFpk3GGQSx8&#xd;&#xa;kYYAjP5E1NRRRRRRRRRRSEAggjIPaq8NjbQXDzwxBHdQrbSQMD26D8qWCzt7d3eKIB3YuzHk5Jye&#xd;&#xa;T/LpViiiisDw7/yF9e/6+h/6DW/RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRVfUP8AkH3P/XJv5Gq+gf8AIv6b/wBesX/oAqS/1Sx0zy/t1ykHmZ2bu+MZ/mKrQ+JNHnmSGLUI&#xd;&#xa;nkkYKqjPJPAFWbXUY7vTmvYIpWUb8R4G9ipIIHOOSOOatI25FYqVyM4PUU6ohcRG5NsHHnBBIU77&#xd;&#xa;SSAfzBouLiK1hMs7iOMEAsfUkAfqRUtFFQxTmS5mhMEqCLbiRgNsmRn5ee3fOKmooooqKC4iuA5h&#xd;&#xa;cOEcxtjswOCKlqte3sdikLSq5EsyQrtA4LHAz7Ut7e21hAZ7uZYogQNzdMmmLe79P+1pbTtwSIgB&#xd;&#xa;vYZwMDOOevXpRYaja6ijtayh/LO1x3Q+h96y/Dv/ACF9e/6+h/6DW/RRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRVfUP+Qfc/8AXJv5Gq+gf8i/pv8A16xf+gCqGuTTweINJe2t&#xd;&#xa;WupPLuB5auqn+DnJ4q9ZXt/POEudJktY8E+Y0yMPpgHNZmnSvB4HupomKSRpdMrDqCHkINTarc3q&#xd;&#xa;WGjmzmVJ5541ZpASrZjYkEDtkVX1m0vtH099RtNWu5mtzvaK6YMjr6YUA9cd6kvLi5t/F0htbF7t&#xd;&#xa;jYICqyKm394/PzEVBr99qE2lNHPo8tvGZYsytPGwX94vYHPtWpezS3epf2XDK9uBCJpZkPz4JIAU&#xd;&#xa;9AcrzkHg0ltJNp2ow6fNPJdJcK7xSSHLrtxuDEYBHzDGB61S0+C+1Vr1p9SuIYobyaOIW5CtgMRh&#xd;&#xa;iQcgYGMY79asaTcTv4i1q1kmeSK3FuIwx6ZQk/mah1GzFr8x1jVTLK2IoY5FyzHoPucDPGTwO5p0&#xd;&#xa;JvlW20aW6f7S8TzS3JPzhN+MA9Nw3LzyODUw87Rrm2R7qe8gu5RCDOQXRyCQQQANuFPGM5xVa0hv&#xd;&#xa;tTvNSWTUZ4LeC7ZI/IID/dU4JII289Mdc1ZsvOt9Vn0trqeeP7MJxLKQZFLMVwCABj5c9OpNZ/h/&#xd;&#xa;SndbpxqmoL5d9MpVZFw+HPJ+Xqe9T6vdWQvmEmsalbsAAY7VCyD8Qh5/Gqpvmv8ASLN2YuseqxRI&#xd;&#xa;7AhnVZAAWz/ER14HPYVqan+91/Srd/mhYSylD0LJsKn8CTWxWOP3Xi3ZH8qz2bSyAfxMrIoJ+g4q&#xd;&#xa;Dw7/AMhfXv8Ar6H/AKDW/RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRVfUP&#xd;&#xa;+Qfc/wDXJv5Gq+gf8i/pv/XrF/6AKdcWLTatZXgcBbdJVK45O7b/APE1erJh0iSPw5caYZVLypMo&#xd;&#xa;fHA3liPy3VW123uUtdHitdhmiu4wGdSVGI3GSBzin3Gl6lqsD2uq3cKWzDn7EpR2PoSxYY69uuKv&#xd;&#xa;LYsNbe/3ja1ssO3HOQzHP60axYtqOnPbI4Qs6Nkj+64b+lJfWMkkwvLJ0ivEXYC4JR154YDkgZJG&#xd;&#xa;COaSysZvPF3qMkct0AVTywQkY77QecnjPPYU7S7FrGO4VnD+dcyTDA6Bmzio7LTXtda1O+aRWW88&#xd;&#xa;raoHK7Fwc1S/s/XF1Ka8W505ncbE8yJz5acfKMN3wCferkljdywxXDSwpqcQIEkakRsM/dIJzt6E&#xd;&#xa;89RRb2N3NOk+qywytCcxJApVAf7xBJO7qOvQmpdOsWs5L1mcN9puTMMDoCqjH/jtC2LDW3v942tb&#xd;&#xa;LDtxzkMxz+tVY7DUbK4lFhNa/ZpZmmcTozPuY5bBBAx6cUgsNTs5Zhpk9oIJZWmIuI2ZgzHJ5UgY&#xd;&#xa;9Kjh0S5FikU08Rm+3i8copCn59xABqxrNvcia0v7GA3FzbMV8rcFDI2N/UjnC8c/nVpdQgOn/bW3&#xd;&#xa;rEASw2MSMHBGMZPNUtOjubvVZdSu7ZrcLH5Nuu4HdGcMScZ5yPbjtUHh3/kL69/19D/0Gt+iiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiq9+CbC5AGSYm4/A1iaR4g0620exgme&#xd;&#xa;dZYreNHX7NKcEKARwtW/+En0r/nrP/4Cy/8AxNH/AAk+lf8APWf/AMBZf/iaP+En0r/nrP8A+Asv&#xd;&#xa;/wATR/wk+lf89Z//AAFl/wDiaP8AhJ9K/wCes/8A4Cy//E0f8JPpX/PWf/wFl/8AiaP+En0r/nrP&#xd;&#xa;/wCAsv8A8TR/wk+lf89Z/wDwFl/+Jo/4SfSv+es//gLL/wDE0f8ACT6V/wA9Z/8AwFl/+Jo/4SfS&#xd;&#xa;v+es/wD4Cy//ABNH/CT6V/z1n/8AAWX/AOJo/wCEn0r/AJ6z/wDgLL/8TR/wk+lf89Z//AWX/wCJ&#xd;&#xa;o/4SfSv+es//AICy/wDxNH/CT6V/z1n/APAWX/4mj/hJ9K/56z/+Asv/AMTR/wAJPpX/AD1n/wDA&#xd;&#xa;WX/4mj/hJ9K/56z/APgLL/8AE0f8JPpX/PWf/wABZf8A4mj/AISfSv8AnrP/AOAsv/xNH/CT6V/z&#xd;&#xa;1n/8BZf/AImqvheQT32s3CK4iluQyFkK7ht9CAa6Kiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiv/9k=</binary>
<binary id="image10.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAIRAkkBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK5+8s&#xd;&#xa;YdR8VPDcmUxpZIyqkrIM73GflIqx/wAIzpf9y4/8Cpf/AIqj/hGdL/uXH/gVL/8AFUf8Izpf9y4/&#xd;&#xa;8Cpf/iqP+EZ0v+5cf+BUv/xVH/CM6X/cuP8AwKl/+Ko/4RnS/wC5cf8AgVL/APFUf8Izpf8AcuP/&#xd;&#xa;AAKl/wDiqP8AhGdL/uXH/gVL/wDFUf8ACM6X/cuP/AqX/wCKo/4RnS/7lx/4FS//ABVH/CM6X/cu&#xd;&#xa;P/AqX/4qj/hGdL/uXH/gVL/8VR/wjOl/3Lj/AMCpf/iqP+EZ0v8AuXH/AIFS/wDxVH/CM6X/AHLj&#xd;&#xa;/wACpf8A4qj/AIRnS/7lx/4FS/8AxVH/AAjOl/3Lj/wKl/8AiqP+EZ0v+5cf+BUv/wAVR/wjOl/3&#xd;&#xa;Lj/wKl/+KqqNPg0zxJpqWnmqs0U+8PM7g4C4+8T6muiooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooooooooooorHT/kcZv+wfH/AOjHrYoooooooooooooooooorHv/APkZ9I/65XH8krYo&#xd;&#xa;ooooooooooooooooooooooooooooooooooooooooooooooooooorHT/kcZv+wfH/AOjHrYoooooo&#xd;&#xa;oooooooooooorHv/APkZ9I/65XH8krYooooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooorHT/kcZv+wfH/AOjHrYoooooooooooooooooorHv/APkZ9I/65XH8krYooooooooooooo&#xd;&#xa;ooooooooooooooooooooooooooooooooooooooorHT/kcZv+wfH/AOjHrYooopGIVSzEAAZJPasc&#xd;&#xa;eKtGZmVbtnKHDbYZGwfwWppdcsxo0uqW7GeCNSSFGCcHGMHp+NWdMvU1LToLyNGRZl3BW6irVFFF&#xd;&#xa;FFFFFFFY9/8A8jPpH/XK4/klbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFY6f8jjN/2D4/8A0Y9bFFFFVtStmvNMurVGCtPC8YJ6AlSP61yeg/2j4X0ydLrRXdEYsZoZFy4z&#xd;&#xa;1I3Z/IdKc93pd74M1afTLf7OzKTPGQchs9/w54qx4b0mafw/ZSrq9/CGjyEjZNq/TK0vhnxA1z4W&#xd;&#xa;nvdWn8tYJDC0yqScYXBPXnLelZN9qt5Hp1xqGm3eqT28EiqJ5njEbcr1XAbHOK3db1O6XwN/aUL+&#xd;&#xa;TcvDDJuT+EsVzjP1NU57XU/+EWTU4NauxP8AZRcMrlSv3NxAwufpzRZeKbiLwUNUuY1lnUmFcdGb&#xd;&#xa;oGbn164qjf6y8FlHd6fqt/c3e9HNtJEfLI6kfcHHbrXcW0jS20UjjDOgYj0JFS0UUVj3/wDyM+kf&#xd;&#xa;9crj+SVsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVjp/yOM3/YPj/wDR&#xd;&#xa;j1sUUUUyaPzYXjLOm9Su5DhhnuD2NY1vpmt20Iij1qN0UnDTWxd8E55bfzSDwzbxaRfWVvKyNe8y&#xd;&#xa;SMNw3eoH9K0dIsf7N0u3sjJ5nkpt34xn8Kx9O8Jx2vh260e4uTMlxJ5m9U24Py44ye6iopPDGoy6&#xd;&#xa;GNIbVofsoUL/AMevzYBBHO71FP8AE9m9t4DkskJlaGKGPKry21kGcfhUdlo+p3+g2NvPqYjtGhj3&#xd;&#xa;xRwFXKbRlC27046fhWz/AGJp/wDZH9mfZ0+zbduMDOcY3f73fPrVddO1YKITqsQtgNm1Lcq4TpgN&#xd;&#xa;u4OO+K10XYirknAxknJNOooorHv/APkZ9I/65XH8krYooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooooooooooorHT/kcZv+wfH/AOjHrYoooooooooooooooooorHv/APkZ9I/65XH8krYo&#xd;&#xa;ooooooooooooooooooooooooooooooooooooooooooooooooooorHT/kcZv+wfH/AOjHrYoooooo&#xd;&#xa;oooooooooooorHv/APkZ9I/65XH8krYooooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooorHT/kcZv+wfH/AOjHrYoooooooooooooooooorHv/APkZ9I/65XH8krYooooooooooooo&#xd;&#xa;ooooooooooooooooooooooooooooooooooooooorHT/kcZv+wfH/AOjHrYoooooooooooooooooo&#xd;&#xa;rHv/APkZ9I/65XH8krYoooooooooooooooooooooooooooooooooooooooooooooooooooormtRO&#xd;&#xa;pjxa/wDZS2rP9hTf9pLAY8x+mKm3+LP+eWj/APfUlG/xZ/zy0f8A76ko3+LP+eWj/wDfUlG/xZ/z&#xd;&#xa;y0f/AL6ko3+LP+eWj/8AfUlG/wAWf88tH/76ko3+LP8Anlo//fUlG/xZ/wA8tH/76ko3+LP+eWj/&#xd;&#xa;APfUlG/xZ/zy0f8A76ko3+LP+eWj/wDfUlG/xZ/zy0f/AL6ko3+LP+eWj/8AfUlG/wAWf88tH/76&#xd;&#xa;ko3+LP8Anlo//fUlG/xZ/wA8tH/76ko3+LP+eWj/APfUlG/xZ/zy0f8A76ko3+LP+eWj/wDfUlV4&#xd;&#xa;jqx8T6b/AGslmv7qfy/sxY9kznP4frXT0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUVjp/yOM3/YPj/wDRj1sVG80UZxJKiHrhmAqlpWom9guJJTGojuZIVIPBCtgH6mrqzRM5&#xd;&#xa;RZELjqoYZpBcQFtomjLZxjcM5p+5d23I3YzjPOKAykkAgkdRnpSeYmzfvXZ13Z4rP0u/u9TgN0LY&#xd;&#xa;W0DJ+6WX75b1OD93268Gix1Gd71rC9t/KuEjD+Yp+SQZI+XnPY9ea06KKKKKKKKx7/8A5GfSP+uV&#xd;&#xa;x/JK2KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKx0/wCRxm/7B8f/AKMe&#xd;&#xa;tO5kMNrNKoBKIWAPsKxLTRrHWLGDUdUiF1NcRLLmQ4EYYbti4x8oJOM5PPWsO7hjj8LTQW/7uJdW&#xd;&#xa;ZI9h+6PMwMV08Ok6ZpJk1ExgTRozzXLZLNxlmOO55PArnr+1torW5vrXw3LFKiNNHdeanykAkPjd&#xd;&#xa;269K2Lh2t7jSdSzukmVbWQt90Iw3lvrlR7c1lLrNxZLe6h5UYe5hknIcHbujcRKBz3UZrS1uyj07&#xd;&#xa;wTdWcTMyQwbQW6nmuhrH1X/kPaH/ANdZf/RTVsUUUUUUUUVj3/8AyM+kf9crj+SVsUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVjp/wAjjN/2D4//AEY9azKrqVYAqwwQe4rK&#xd;&#xa;OgQ7vlvb9Is8QrORGB/dC/3e2PSnHw/YfYfsSqyQef54VTjDZzge3tWlLGk0TxSoHjcFWVhkEHqD&#xd;&#xa;WRL4chmjeJr/AFHynBUxi5O3ae2PT2q/dafBdaa1hLu8lkEZwecfWmXmk2l7bW1vcx+ZFburqjcg&#xd;&#xa;kAgZ9eDVqaGK4haKeNZI3GGRhkEfSs7TI9SsYmtbtje+XHvS5+6XP9wgknPGc+/tTbC0u574ajqJ&#xd;&#xa;VTsxFbEZ8g85O7OCSDjIxxWvRRRRRRRRWPf/APIz6R/1yuP5JWxRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRWOn/I4zf9g+P/ANGPWxRRRRRRRSMQqlmIAAySe1R/aYPIE/nx&#xd;&#xa;+ScYk3jacnA5+tS0UUUUUUUVj3//ACM+kf8AXK4/klbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFY6f8jjN/2D4//Rj1qyyLFE8j8Kilj9BWQusX8kQuYtKD2bL5izfaQCY+&#xd;&#xa;obbjPTnFPu9figbT/LglnS+iaSMopJ4CkZGO+7r2qxbXWoSQztcaaIZEXMSfaA3mHnjOOO351XXV&#xd;&#xa;ryGWIahpotYpZFiWQTiT52OFGAPXvU9/qMlvcJa2lt9qumQyeWZNgCA4JyR6kce9QjWJLeKaTVLJ&#xd;&#xa;7MRIZMq3mqVBA6gYzz0qOXWL+0jae/0oQWqDMkouQ5UeuAOabqcP9qa3Bp7SSxR28YuZCjY8wEso&#xd;&#xa;X8xmtaS1hktTbGNRERjaAAB9Ky9AVrO4vdLaSSb7MyyLLIxJKvuIX8NvXvW1RRRRRRRWPf8A/Iz6&#xd;&#xa;R/1yuP5JWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWOn/I4zf8AYPj/&#xd;&#xa;APRj1pXUbTWs0S43OjKM+pFcXDDY28EdjNp+tSXEaiF2RpfJZwMEg7vu59ulbwtJINU0JBDtSC2l&#xd;&#xa;jYISyp8qADcfpxnrirmti4OnMbctgEGZU++0X8YXHO4jOMY571yj/ZJ7uwWy0/WkkW8hYtciQoFD&#xd;&#xa;jJOWIroPEXlKIpLmzuJ4Om60LecG7D5cfLjOeeuOKyo7ObU7G+ttNjure2lgKFL8tuMuRggnJxjN&#xd;&#xa;QGPTr4fZodL1kyS/KounlWL/AIEdxwPwrdupI7HxPFcXDqkV3bi3jJOMOpZjnPbBAHvWyxCqWYgA&#xd;&#xa;DJJ7Vj6M63mqalqEDBreUpChB6mMsCfpyMGtmiiiiiiise//AORn0j/rlcfyStiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisdP8AkcZv+wfH/wCjHrYoooooooqG4tYLpNk8&#xd;&#xa;SSAdNwzj3HoajNhAbEWZ8wwjA5kbccHPJzk1NDDFAmyGNI067UUAfpUlFFFFFFFY9/8A8jPpH/XK&#xd;&#xa;4/klbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFY6f8jjN/2D4/8A0Y9b&#xd;&#xa;FFFFFFFFQ3NzBZwNPcyrFEmNzucAZOP5mq6apDJZSXkUcskKNgMq53jj5l55Xnr7Gp7S7t72ETWs&#xd;&#xa;yTRE43IcjNT0UUUUUUVj3/8AyM+kf9crj+SVsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUVjp/wAjjN/2D4//AEY9aN47R2U7ocMsbEH0OKwrOPVLrRYNRudSeNxbrIqQAbXG&#xd;&#xa;3dlsjO498cU2yg1O40oapcatMjyJ9oWGILsVSNwXlc+3WtBtWkXQ7G88tfPvFiVB/CryAYz32gn6&#xd;&#xa;4qKeC+0yCTUG1Ga4WFTJLDIF27QMttwAc4HGT9alt72VtcWDcWgubX7Sqt1jIKrgY7HJP1qourXM&#xd;&#xa;fhu81gkPIC5WJh8ibGKcd+cZPPU1kXHiCzs4HuLXxHcXk8YykEsYCyH0OEH866DWv32o6XZyfNb3&#xd;&#xa;Er+bGejbULL+TAH8K1wABgAAelZGlgQ67qtrGNsCiKVUHQM+8sfxIFbFFFFFFFFY9/8A8jPpH/XK&#xd;&#xa;4/klbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFY6f8jjN/2D4/8A0Y9a&#xd;&#xa;dzGZrWWJSAXQqCfcVWtrJ4dCisGZTIlsISw6ZC4zRbWTw6FFYMymRLYQlh0yFxmmRaUp0S0sJ2+e&#xd;&#xa;3ijVZE/hdQAGGfQjIzUBs9Vux9mv5rX7GeH8kNvkX+6c8YI64/CovE+hy6vpcNpZyJA0UisGbP3Q&#xd;&#xa;pGOPqKvXGmpdaKdOmYqrxCNmTr9RVP7JrU37uZtOhjbhngRt6j23ZGfrU+t285W3vrSIz3Vm+6OL&#xd;&#xa;IAfd8rZz6KSevUVKmqxGwkuZEkjMTbJI2GWV+MLxweo5HHNQ6NDcPPd6hdwNbz3LBPKJBwiZ2njP&#xd;&#xa;JDc81q0UUUUUUVj3/wDyM+kf9crj+SVsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUVjp/yOM3/YPj/wDRj1sUUUUUUUUUUUUUUUUUUVj3/wDyM+kf9crj+SVsUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVjp/yOM3/YPj/wDRj1sVm3WuWdtMYj50zLwx&#xd;&#xa;ghaQKfQlQcH261Jb6vZ3Fk12shSJXKHzFKHcOowec+1RW2uWdzOsQW4iZjgGaBo1J7DLADPtVXUv&#xd;&#xa;EC2Ot29mY5jGVcy7YHYk4UrtIHPU5xU8mtGQQpYWklxcSqZBFJ+5IQHaSdw9cce+abs12P8AfGa1&#xd;&#xa;mA5+zrFtY/7O8tj8cVo3d3DZQGWdiFzgADLMfQAck+wqoNThvLC6e3aSOSONjtkQxuOODg849/am&#xd;&#xa;eG7iSbw5ZT3Epd2i3O7nk+5NOj12ykufJBmUEkCVomEZ9w5GMHsc85FT32p2lhJFHcyFXlVmRQCS&#xd;&#xa;23GQPU8jA71Sm12J7GZ7VJknyIoRPAyBpGyEHIHGevpVqztLn7HIL25dridfnMZ2iM4x8g5x/jzU&#xd;&#xa;Gm3N3FqE2n38iSOF8yBlXG6MYBJ5POTj361rUUUVj3//ACM+kf8AXK4/klbFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFY6f8jjN/2D4//Rj1pXhcWc5jzvEbbdvXOOMVk6Le&#xd;&#xa;6faaRB5lxbx3LxrJcKXAkaUqNxYdd2evfNYVz5l34ZuZLZHy2qvIMocqPMJyR1GO9aEzXF5NZpPr&#xd;&#xa;NjcIl1FJ5dtCSxIYHsxwPU9q0NUdYfEGlzysI4UjnDSMcKpOzAJ6c4qG9ufJ12y1OMJNZSQtbNOk&#xd;&#xa;g2xksG3E+nykVoSaxpyRlheQykfwROHY/RRyapX4eHxHBdXh/wCJasAVNxyqT7idxHb5cjd74qHU&#xd;&#xa;5EvL6ObT3WRY4JBcyxnKlNjbVLDg4Y5x2zmorCO4l8BWqWu7zTGh+U4JUOCw/wC+c1dur3TJdINt&#xd;&#xa;C0T5jVY7ZRl1IxtGzqCDjtxj2qq9sz6p4cj1BRLPFbSM5f5v3irHzn1z3q74jBNtZtg7Y72B3PZV&#xd;&#xa;Dgkn0AHetZSGUMpBB5BHesg/P4vRk+YR2Lo5HO1i6EA+hxzWxRRRWPf/APIz6R/1yuP5JWxRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWOn/I4zf9g+P/ANGPWxWDP4fuJbuS&#xd;&#xa;dL23Te5cA2EbFcnPU8n61p2NjHZ2zRZ8wyMXlYj77tyxx2ye1PhsbO3k8yC0gifpuSMKfzFSTQRX&#xd;&#xa;EflzxJKnXa6hh+RpBbQLb/ZxBGIenlhBt/LpUUenWMUgkis7dHXkMsSgj8cVPJGksZjlRXRuCrDI&#xd;&#xa;P4U2K2ggjaOGCOONuSqIAD+Ap0caRRiOJFRF4CqMAfhUS2Vok/npawrNknzBGA2T1OalMaNIsjIp&#xd;&#xa;dchWI5GeuDTbmCO6tpbeYZjlQo4zjIIwarWtg9naS21vcuI8Yg3jeYuPU/e555+lLp2mwaf5rRF2&#xd;&#xa;kmIaV3YsWIGM89PpV2iiise//wCRn0j/AK5XH8krYooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooooooooorHT/kcZv+wfH/6Metiiiio4J4riISQyLIhJAZTkZBwf1BqO8vbWwiEt5PHB&#xd;&#xa;GW2hpGwCfT9DSWd/aX6M1ncxTqpwxjbODVmq9/eRWFq1xNu2KyqdoycswUfqRViiiql9qNrYBBcS&#xd;&#xa;gSSZ8qMH5pCOyjueR+dOubxLa2W4lSQRnG75fuA9S3oB39KktrmG7gWe2lSWJs7XQ5BwcVLRRRWP&#xd;&#xa;f/8AIz6R/wBcrj+SVsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVjp/yO&#xd;&#xa;M3/YPj/9GPWrMzJC7ou9lUkL6n0rkVvJZZRI/ihLedzuNiyp+7Y/8syevB+X1qxqepyyX5tJ9Wj0&#xd;&#xa;Z4IkdiNriUsOQN2OFx+Oas6JeyXyX9hHqQu2hRdl6oGcuG7Dj5cVS8MabqLWNvOusyrAszloPJXD&#xd;&#xa;ASNkZ684P51oeHbaG6tv7SuEEl5K0iPI3cLIVAx06KB07VrLaQLci4WJVlCFNw44JBxj8BWMqahr&#xd;&#xa;saX1nqclhbOP3Uaxq5Zf7xz0PbHtUer3xvfDl15kYjmguoopVByAwkjPB7jBFaup3jwGG2gGbm6J&#xd;&#xa;SIk4AwMkk+wBI96oKb/Q18++vm1C1dlV2ZAjREnau0D72SwzkjGKrWqaxqzXezUms4oLuaNGRFcu&#xd;&#xa;AxABBHGMceuat2ETS6/cR3cn2h7GCERSMMYLBt7YHrtB/CtsgEEEZB7VkaL+51DVLKP5be3lTyox&#xd;&#xa;0XcgZvzYk/jWxRRRWPf/APIz6R/1yuP5JWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRWOn/I4zf9g+P/ANGPWs4LIyhipIwGHUe9Yr2WsMGhP9nPEcp5rq3msvTccDG7v6Zp&#xd;&#xa;P7GurGRX01reUtDHDJ9sBPEYwpGO5yc/hV/Tbe6i8yS8eHzJMDy4BhFxnkZGcnPOfSqlnZalpzpb&#xd;&#xa;WrWjWKyFsybvNwzbm6cZyTj8KaulXmm3E7aN9lWK4be6XBY7Wx/Djsev1NXLGPUvOMuoSwDC7Vit&#xd;&#xa;87T0+Y55z29Oaqiy1LTwINKa0NoOUS43Zj/2Rjt9eeTS3Wi79Hls4JcyyzJLJLJ1dgykk474XHFX&#xd;&#xa;b+yF2qOjGO4hO6GQfwnofwIyD7Gqa2F/fMo1eS38hCD5NvnbIeo3Z54IBGD9as6VZPYx3KyMrGW5&#xd;&#xa;lmG3sGbIH1qnetJpWrNfpA8ttcoBdOCP3ATo30wzE9elaF1fw21otwSXD4ESr1kY/dUe596q6JBN&#xd;&#xa;tuL67iaC5vH3SREjCbflX81AP41qUUUVj3//ACM+kf8AXK4/klbFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFc9eaha6d4seS8l8pHsUVTtJyfMf0FWf+Eo0b/n8H/ft/8KP+&#xd;&#xa;Eo0b/n8H/ft/8KP+Eo0b/n8H/ft/8KP+Eo0b/n8H/ft/8KP+Eo0b/n8H/ft/8KP+Eo0b/n8H/ft/&#xd;&#xa;8KP+Eo0b/n8H/ft/8KP+Eo0b/n8H/ft/8KP+Eo0b/n8H/ft/8KQ+KtEDBTfLuPQeW2f5Uv8AwlGj&#xd;&#xa;f8/g/wC/b/4Uf8JRo3/P4P8Av2/+FB8T6KQQbwEHqDG/+FIfE2ikAG7BA6fun4/Sl/4SjRv+fwf9&#xd;&#xa;+3/wo/4SjRv+fwf9+3/wo/4SjRv+fwf9+3/wo/4SjRv+fwf9+3/wo/4SjRv+fwf9+3/wqoNTtNT8&#xd;&#xa;TaYbKXzRFFPvO0jGQmOo9jXR0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUVyF/8AP4lGvj/j301vsckf8bM2RkdsfvR+Rrr6KKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKgvZ/s1nNNuVSikjd0z2H54rI0uza68Oyy&#xd;&#xa;XEP+k3uZ5I3GAJMDGAemCqmr2iXBn0uESOXnhUQzk9fMUYfnvznmtCiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisXxLLG0NtYSyLCt3KP3znCpsIfn6&#xd;&#xa;7cfjV/8AtTT/APn/ALX/AL/L/jWfoc0X9qapa2sqS26us4ZWDfPIWLcjtkCtuiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiobi1t7pQtzBFMFOQJEDY/&#xd;&#xa;OsPU9MsE1vRkWytlV5ZQyiJQGxEx545rbt7S2td32a3ih3Y3eWgXOPXFT0UUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVj6r/wAh7Q/+usv/AKKatiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisS9k1G48QNZWl8trElqspzCHyS7Dv8A&#xd;&#xa;QU/+z9Z/6Di/+Aa/40f2frP/AEHF/wDANf8AGj+z9Z/6Di/+Aa/40f2frP8A0HF/8A1/xo/s/Wf+&#xd;&#xa;g4v/AIBr/jR/Z+s/9Bxf/ANf8aP7P1n/AKDi/wDgGv8AjR/Z+s/9Bxf/AADX/Gj+z9Z/6Di/+Aa/&#xd;&#xa;40f2frP/AEHF/wDANf8AGj+z9Z/6Di/+Aa/40f2frP8A0HF/8A1/xo/s/Wf+g4v/AIBr/jR/Z+s/&#xd;&#xa;9Bxf/ANf8aP7P1n/AKDi/wDgGv8AjR/Z+s/9Bxf/AADX/Gj+z9Z/6Di/+Aa/40f2frP/AEHF/wDA&#xd;&#xa;Nf8AGj+z9Z/6Di/+Aa/40f2frP8A0HF/8A1/xo/s/Wf+g4v/AIBr/jR/Z+s/9Bxf/ANf8aP7P1n/&#xd;&#xa;AKDi/wDgGv8AjR/Z+s/9Bxf/AADX/GszUbLVV1jSVfVw7tJJsf7Ko2Hy2zxnnjitP+z9Z/6Di/8A&#xd;&#xa;gGv+NH9n6z/0HF/8A1/xo/s/Wf8AoOL/AOAa/wCNH9n6z/0HF/8AANf8aP7P1n/oOL/4Br/jR/Z+&#xd;&#xa;s/8AQcX/AMA1/wAaP7P1n/oOL/4Br/jR/Z+s/wDQcX/wDX/Gj+z9Z/6Di/8AgGv+NH9n6z/0HF/8&#xd;&#xa;A1/xo/s/Wf8AoOL/AOAa/wCNH9n6z/0HF/8AANf8aP7P1n/oOL/4Br/jR/Z+s/8AQcX/AMA1/wAa&#xd;&#xa;P7P1n/oOL/4Br/jR/Z+s/wDQcX/wDX/Gj+z9Z/6Di/8AgGv+NH9n6z/0HF/8A1/xo/s/Wf8AoOL/&#xd;&#xa;AOAa/wCNH9n6z/0HF/8AANf8aP7P1n/oOL/4Br/jR/Z+s/8AQcX/AMA1/wAan8P3c19odpdXDBpZ&#xd;&#xa;Y9zEDGTWjRRRRRRRRRRRRRRRRRRRRRRRRWOn/I4zf9g+P/0Y9bFFFFFFFFFFFFFFFFFFFFFFFFY+&#xd;&#xa;q/8AIe0P/rrL/wCimrYooooooooooooooooooooorH8Jf8ixp/8A1yH862KKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKx0/5HGb/sHx/+jHrYooooooooooooooooooooooorH1X/AJD2h/8AXWX/ANFNWxRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRWP4S/5FjT/wDrkP51sUUUUUUUUUUUUUUUUUUUUUUUUVjp/wAjjN/2D4//AEY9&#xd;&#xa;bFFFFFFFFFFFFFFFFFFFFFFFFY+q/wDIe0P/AK6y/wDopq2KKKKKKKKKKKKKKKKKKKKKKx/CX/Is&#xd;&#xa;af8A9ch/OtiiiiiiiiiiiiiiiiiiiiiiiiisdP8AkcZv+wfH/wCjHrYooooooooooooooooooooo&#xd;&#xa;oorH1X/kPaH/ANdZf/RTVsUUUUUUUUUUUUUUUUUUUUUVj+Ev+RY0/wD65D+dbFFFFFFFFFFFFFFF&#xd;&#xa;ZV7qtzDqf2G009rtxCJmIlVMAsR3+lM/tLV/+gC//gVHR/aWr/8AQBf/AMCo6P7S1f8A6AL/APgV&#xd;&#xa;HR/aWr/9AF//AAKjo/tLV/8AoAv/AOBUdH9pav8A9AF//AqOj+0tX/6AL/8AgVHR/aWr/wDQBf8A&#xd;&#xa;8Co6P7S1f/oAv/4FR1TWTWRrT3/9iNta3WHZ9pjzkMxz196uf2lq/wD0AX/8Co6P7S1f/oAv/wCB&#xd;&#xa;UdH9pav/ANAF/wDwKjo/tLV/+gC//gVHR/aWr/8AQBf/AMCo6P7S1f8A6AL/APgVHR/aWr/9AF//&#xd;&#xa;AAKjo/tLV/8AoAv/AOBUdH9pav8A9AF//AqOprTU5nultr6yazllBaFTIJN4H3vu9MZHX1rSooor&#xd;&#xa;OvtSkguha2lo13cBBIyBwm1CSAcng8g8VB/aWr/9AF//AAKjo/tLV/8AoAv/AOBUdH9pav8A9AF/&#xd;&#xa;/AqOj+0tX/6AL/8AgVHR/aWr/wDQBf8A8Co6P7S1f/oAv/4FR0f2lq//AEAX/wDAqOj+0tX/AOgC&#xd;&#xa;/wD4FR0f2lq//QBf/wACo6p3cms3GoWFyNEZRau7FftMfzbkK+vvVz+0tX/6AL/+BUdH9pav/wBA&#xd;&#xa;F/8AwKjo/tLV/wDoAv8A+BUdH9pav/0AX/8AAqOj+0tX/wCgC/8A4FR0f2lq/wD0AX/8Co6P7S1f&#xd;&#xa;/oAv/wCBUdH9pav/ANAF/wDwKjo/tLV/+gC//gVHS2+rXTalBZ3mmtamdXZGMyvnbjPT6iteisK3&#xd;&#xa;1vULuLzrXRXlhLMqv9pRc7WKng+4NS/2lq//AEAX/wDAqOj+0tX/AOgC/wD4FR0f2lq//QBf/wAC&#xd;&#xa;o6P7S1f/AKAL/wDgVHR/aWr/APQBf/wKjo/tLV/+gC//AIFR0f2lq/8A0AX/APAqOj+0tX/6AL/+&#xd;&#xa;BUdH9pav/wBAF/8AwKjqno8ms6bpVtZtojSGFNpYXMYz+tXP7S1f/oAv/wCBUdH9pav/ANAF/wDw&#xd;&#xa;Kjo/tLV/+gC//gVHR/aWr/8AQBf/AMCo6P7S1f8A6AL/APgVHR/aWr/9AF//AAKjo/tLV/8AoAv/&#xd;&#xa;AOBUdH9pav8A9AF//AqOj+0tX/6AL/8AgVHV3S75dS02C8VDGJl3BSc4q3RRRRWOn/I4zf8AYPj/&#xd;&#xa;APRj1sUUUUUUUUUUUUUUUUUUVj3/APyM+kf9crj+SVsUUUVjp/yOM3/YPj/9GPWxRRRRRRRRRRRR&#xd;&#xa;RRRRRRWPf/8AIz6R/wBcrj+SVsUVj+Ff+QDF/wBdZv8A0a9bFFFFFFFFFFFFFFFFFFFY/hL/AJFj&#xd;&#xa;T/8ArkP51sUUUUVjp/yOM3/YPj/9GPWxRRRRRRRRRRRRRRRRRRWPf/8AIz6R/wBcrj+SVsUUUVjp&#xd;&#xa;/wAjjN/2D4//AEY9bFFFFFFFFFFFFFFFFFFFY9//AMjPpH/XK4/klbFFY/hX/kAxf9dZv/Rr1sUU&#xd;&#xa;UUUUUUUUUUUUUUUUVj+Ev+RY0/8A65D+dbFFFFFY6f8AI4zf9g+P/wBGPWxRRRRRRRRRRRRRRRRR&#xd;&#xa;RWPf/wDIz6R/1yuP5JWxRRRWOn/I4zf9g+P/ANGPWxRRRRRRRRRRRRRRRRRRWPf/APIz6R/1yuP5&#xd;&#xa;JWxRWP4V/wCQDF/11m/9GvWxRRRRRRRRRRRRRRRRRRWP4S/5FjT/APrkP51sUUUUVjp/yOM3/YPj&#xd;&#xa;/wDRj1sUUUUUUUUUUUUUUUUUUVj3/wDyM+kf9crj+SVsUUUVjp/yOM3/AGD4/wD0Y9bFFFFFFFFF&#xd;&#xa;FFFFFFFFFFY9/wD8jPpH/XK4/klbFFY/hX/kAxf9dZv/AEa9bFFFFFFFFFFFFFFFFFFFY/hL/kWN&#xd;&#xa;P/65D+dbFFFFFY6f8jjN/wBg+P8A9GPWxRRRRWRd60BqbaVYxGe+Cbzn7kY45c9ccjoD1pPO16H9&#xd;&#xa;5Pb2MsS8sluzmRh/s5AGfqar6bdXUnim+gk1OCaBEJS1UfPGcryflHqe561oS65pkLXCyXkatbY8&#xd;&#xa;4HPyZOBn8SKI9b02XT5L5LtGtYm2PIM4B44/UfnTbXX9LvLhLe2vEklfO1QDzgZ9Pas3wxqd5faz&#xd;&#xa;rsF1MZIrW42QrtA2jc4xwOeg61sX+q2OmlBe3Cw+ZnbkE5xjPT6ipbO7t762W4tZVlifOGHfBx/M&#xd;&#xa;VPRRRRWPf/8AIz6R/wBcrj+SVsUUUVjp/wAjjN/2D4//AEY9bFFFFczqfiW5TxAmjaZaLLcAgStM&#xd;&#xa;cKAQpBGDnAB54q9b3esx6hHBfWULwSKf3tqxIRs/xbscYz0q9f6haadEst5OsKM20Fu55OP0NVbf&#xd;&#xa;xFpFzcJbwX0byyHCqAck/lVqDULS4u5rWGdXng/1iDqtEmoWkeoR2DzqLqVd6R9yOef0P5VDe65p&#xd;&#xa;thOYLu7SKUAHaQen5VJBqdlcWUl5DcK9vGGLyDOAB1qs/iTR0gjna/iEUpYI3PJGM9vcVbutQtLS&#xd;&#xa;1FzcTrHC2MMc856UlhqdlqSu1lcLMEOG254/OrdFFFY9/wD8jPpH/XK4/klbFFY/hX/kAxf9dZv/&#xd;&#xa;AEa9bFFQ3f2kWz/YxEZ+NolJC9ec456Zrm59c1uDXrfR2t9PM9xGZFcO+0D5uvGf4T2rcF3JZac1&#xd;&#xa;zrD28Ow/M0RYoATgdRnvUf8Ab2l/aIYPtsfmzhTGvPzbvu/nmqPhm6urm51FbnU4L1Y3UIsQwYhl&#xd;&#xa;uD8o9B69KvXevaXZXL29zeJHKmNykHjIz6ehqZNTsn08363CG1AJMvOMA4P61THinRCMjUI/yb/C&#xd;&#xa;tO2uYbu3Se3kEkTjKsO9ULjxFpFtO8M19GkkZwy4PB/Kqev60P8AhFLrUdJugShUJKozg71B4I9D&#xd;&#xa;WnpE8lxo1jPM26SS3jd26ZJUEmof+Eg0oXf2U3sfn+Z5WzB+9nGOnrWlS0UVj+Ev+RY0/wD65D+d&#xd;&#xa;bFFFFFY6f8jjN/2D4/8A0Y9bFFFFFchAPsXxIvJbn93Hd24WFj0c4j4H5H8q6m4uoLaB5ppVSNBl&#xd;&#xa;mPYVx2gf8lI1j/rk/wD6ElJpenWeo+NdbS9t451QgqHGcHNWvFVh/Z+nWkWmQCC0N0rXCx8KeVAJ&#xd;&#xa;/ECukv3s/srfbShg3LkNyM7ht/XFc14N/wCRg8Tf9fX/ALPJVfQTr8esatkQGUmPP2x2B25fbjaD&#xd;&#xa;2z+lanhHTZNMbUY554JZXmDuISSEyM45A9a6Oiiiise//wCRn0j/AK5XH8krYooorHT/AJHGb/sH&#xd;&#xa;x/8Aox62KKKK5fWNK0jVdejVb02upwne3lD5mIClSSfQAY+tVIp9U0bxbbWc1+99aXa7U8xslOmS&#xd;&#xa;e2cg/gaRbiJ/iXcR37gpFCotQ/RXIQ8e/wB6ma8QfiPo+CD+6T/0J6seHiF8b67uOM46/Wk1Eg/E&#xd;&#xa;7SsEH/RW/lLSJeap4h1u6tYrv+z7bT5njkaJiHkBJCnnj+D9azdEjMVt4zjaRpWRHUyN1bAl5Pua&#xd;&#xa;u+CNF0y+8PpNd2UM0pkYbnXJxSXKapF4+xbLGIxBi2E7ERhdi7sY565q/pOnXcPjC61C+ntPNubb&#xd;&#xa;HlQMxwAUGeR04/WuoooorHv/APkZ9I/65XH8krYorH8K/wDIBi/66zf+jXrYoorkNS/5KdpP/Xq3&#xd;&#xa;8pa0PHX/ACKN9/2z/wDRi0mgaFpf9labd/YYftHkRSeZt53bQc/XNZHw9/5CGu/9dU/m9S2N1qXi&#xd;&#xa;W+uD9tbTre1ZosQN8ztngnPGMZrJ0hSnhTxIpYuRIRuPU+9dh4S/5FjT/wDrkP51x+hXM9p8OdTn&#xd;&#xa;tZGjmS6G1k6jPlg/pW/4Xez/AOELYWpQN5T+dt4/ebec++MVhW3/ACSq7/66j/0YtbGrC7Pw6tRZ&#xd;&#xa;7932SLzNv/PPYN34Yqpc2Oq6n4PtbeSTTobVLeOTeXfcFVQeRjrjrXZWS7LKBQwbEajI6Hip6KKx&#xd;&#xa;/CX/ACLGn/8AXIfzrYoooorHT/kcZv8AsHx/+jHrYooooqK4giuoHgnjWSJxhlboRVK30DSbWdJ4&#xd;&#xa;LCCOVDlWVeQasRadZwXsl5FbxpcyjDyAcsOOv5ClhsbWC6luYYESeb/WOBy31p91awXlu1vcxLLE&#xd;&#xa;+NyMMg4Of5iqlroWl2dwtxbWMMUqZ2uq4IyMfyNWLaxtbSaeW3gSOSdt0rKOXPJyfzP502+0yx1H&#xd;&#xa;Z9tto5/Lzs3jOM4z/IVLa2sFnbrb20SxRJnaijAGTn+Zqaiiiise/wD+Rn0j/rlcfyStiiiisdP+&#xd;&#xa;Rxm/7B8f/ox62KKKKqX2mWOo7PtttHP5edm8ZxnGf5ClsdOs9ORksreOBXOWCDGTTL7SbDUXV720&#xd;&#xa;inZBhS4zgViyeEYY/EVnqNj5NtBABuhVPvHJ5/UflWze6Pp2oTCW8s4p5Au0M4yQOuP1NMtdC0uz&#xd;&#xa;uFuLaxhilTO11XBGRj+Rp15oumX05nu7KGaUgDcy5OKW20fTrSGeK3s4o4512yqo4ccjB/M/nU9n&#xd;&#xa;Z29jAILSFIYgSdqjAzReWdvfQGC7hSaIkHawyM0yx06z05GSyt44Fc5YIMZNWqKKKx7/AP5GfSP+&#xd;&#xa;uVx/JK2KKx/Cv/IBi/66zf8Ao162KKKrPY2sl9HevAjXMa7UlI+ZRzx+p/On3VrBeW7W9zEssT43&#xd;&#xa;IwyDg5/mKfFEkEKRRKEjjUKqjoAOAKgs9Os7F5XtLeOFpjmQqMbjz1/M1BdaFpd5cNcXNjDLK+Nz&#xd;&#xa;suScDH8hT4dH06C1ltobOJIJv9YgHDfWrNvBFawJBBGscSDCqvQCo7KxtdPhMVnAkEZbcVQYBPTP&#xd;&#xa;6CuZfwlO6MvkaMuRjItnyP8Ax6tjS9AtbHQ10uYfaIjhpA/IZuCfwyOK1IokghSKJQkcahVUdABw&#xd;&#xa;BVH+wtL+1/a/sMP2jzPM8zbzuznP1zWjRRRWP4S/5FjT/wDrkP51sUUUUVjp/wAjjN/2D4//AEY9&#xd;&#xa;bFFFFFFFFFFFFFFFFFFFY9//AMjPpH/XK4/klbFFFFY6f8jjN/2D4/8A0Y9bFFFFFFFFFFFFFFFF&#xd;&#xa;FFFY9/8A8jPpH/XK4/klbFFY/hX/AJAMX/XWb/0a9bFFFFFFFFFFFFFFFFFFFY/hL/kWNP8A+uQ/&#xd;&#xa;nWxRRRRWOn/I4zf9g+P/ANGPWxRRRRRRRRRRRRRRRRRRWPf/APIz6R/1yuP5JWxRRRWOn/I4zf8A&#xd;&#xa;YPj/APRj1sUUUUUUUUUUUUUUUUUUVj3/APyM+kf9crj+SVsUVj+Ff+QDF/11m/8ARr1sUUUUUUUU&#xd;&#xa;UUUUUUUUUUVj+Ev+RY0//rkP51sUUUUVjp/yOM3/AGD4/wD0Y9bFFFFFFFFFFFFFFFFFFFY9/wD8&#xd;&#xa;jPpH/XK4/klbFFFFY6f8jjN/2D4//Rj1sUUUUUUUUUUUUUUUUUUVj3//ACM+kf8AXK4/klbFFY/h&#xd;&#xa;X/kAxf8AXWb/ANGvWxRRRRRRRRRRRRRRRRRRWP4S/wCRY0//AK5D+dbFFFFFYE97a2Xi6Rru5hgV&#xd;&#xa;rBAplcKCfMf1q9/b2j/9BWy/7/r/AI0f29o//QVsv+/6/wCNH9vaP/0FbL/v+v8AjR/b2j/9BWy/&#xd;&#xa;7/r/AI0f29o//QVsv+/6/wCNH9vaP/0FbL/v+v8AjR/b2j/9BWy/7/r/AI0f29o//QVsv+/6/wCN&#xd;&#xa;H9vaP/0FbL/v+v8AjR/b2j/9BWy/7/r/AI0f29o//QVsv+/6/wCNH9vaP/0FbL/v+v8AjR/b2j/9&#xd;&#xa;BWy/7/r/AI0f29o//QVsv+/6/wCNH9vaP/0FbL/v+v8AjR/b2j/9BWy/7/r/AI0f29o//QVsv+/6&#xd;&#xa;/wCNH9vaP/0FbL/v+v8AjR/b2j/9BWy/7/r/AI1Qkv7O+8T6X9juobjZFPu8qQNtyExnH0NdBRRR&#xd;&#xa;WBPe2tl4uka7uYYFawQKZXCgnzH9avf29o//AEFbL/v+v+NH9vaP/wBBWy/7/r/jR/b2j/8AQVsv&#xd;&#xa;+/6/40f29o//AEFbL/v+v+NH9vaP/wBBWy/7/r/jR/b2j/8AQVsv+/6/40f29o//AEFbL/v+v+NH&#xd;&#xa;9vaP/wBBWy/7/r/jR/b2j/8AQVsv+/6/40f29o//AEFbL/v+v+NH9vaP/wBBWy/7/r/jR/b2j/8A&#xd;&#xa;QVsv+/6/40f29o//AEFbL/v+v+NH9vaP/wBBWy/7/r/jR/b2j/8AQVsv+/6/40f29o//AEFbL/v+&#xd;&#xa;v+NH9vaP/wBBWy/7/r/jR/b2j/8AQVsv+/6/40f29o//AEFbL/v+v+NUJL+zvvE+l/Y7qG42RT7v&#xd;&#xa;KkDbchMZx9DXQUVzfh3V9NtdHSG4v7WKVZZtyPKqkfvWPQmtP+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3&#xd;&#xa;/X/Gj+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3/X/Gj+3tH/6C&#xd;&#xa;tl/3/X/Gj+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3/X/Gj+3t&#xd;&#xa;H/6Ctl/3/X/Gj+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3/X/G&#xd;&#xa;j+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3/X/Gj+3tH/6Ctl/3/X/GoPCX/Isaf/1yH862KKKKKxDDHL4w&#xd;&#xa;lEsaOBYR43KD/wAtHrU+xWv/AD7Q/wDfsUjWlmilmt4AoGSSgwBSR21lLGskcFu6OAysqKQQehBp&#xd;&#xa;32K1/wCfaH/v2KPsVr/z7Q/9+xR9itf+faH/AL9ij7Fa/wDPtD/37FH2K1/59of+/YqNYtPcSFY7&#xd;&#xa;YiIlZCFX5CBkg+nBpYYLCeJZYYreSNhlXRVII9jT/sVr/wA+0P8A37FH2K1/59of+/Yo+xWv/PtD&#xd;&#xa;/wB+xR9itf8An2h/79ij7Fa/8+0P/fsUfYrX/n2h/wC/Yo+xWv8Az7Q/9+xR9itf+faH/v2KPsVr&#xd;&#xa;/wA+0P8A37FZd3DFD4n0nyokTMVxnaoGeErbooorEMMcvjCUSxo4FhHjcoP/AC0etT7Fa/8APtD/&#xd;&#xa;AN+xR9itf+faH/v2KZFBYTBjFFbuFYo21VOGHUH3FP8AsVr/AM+0P/fsUfYrX/n2h/79ij7Fa/8A&#xd;&#xa;PtD/AN+xR9itf+faH/v2KPsVr/z7Q/8AfsVG0WnrI0bR2wdU3spVchfUj04PNLDBYTxLLDFbyRsM&#xd;&#xa;q6KpBHsaf9itf+faH/v2KPsVr/z7Q/8AfsUfYrX/AJ9of+/Yo+xWv/PtD/37FH2K1/59of8Av2KP&#xd;&#xa;sVr/AM+0P/fsUfYrX/n2h/79ij7Fa/8APtD/AN+xR9itf+faH/v2Ky7uGKHxPpPlRImYrjO1QM8J&#xd;&#xa;W3RWF4YtreTRI2kgiZjLNksgJP7161vsVr/z7Q/9+xTJILCIoJIrdDI2xNyqNzeg9Twaf9itf+fa&#xd;&#xa;H/v2KPsVr/z7Q/8AfsUfYrX/AJ9of+/Yo+xWv/PtD/37FH2K1/59of8Av2KbJbWUUbSSQW6IgLMz&#xd;&#xa;IoAA6kmmtFp6CMtHbASkLGSq/OSMgD14FSfYrX/n2h/79ij7Fa/8+0P/AH7FH2K1/wCfaH/v2KPs&#xd;&#xa;Vr/z7Q/9+xR9itf+faH/AL9ij7Fa/wDPtD/37FH2K1/59of+/Yo+xWv/AD7Q/wDfsUfYrX/n2h/7&#xd;&#xa;9ij7Fa/8+0P/AH7FZ3hL/kWNP/65D+dbFFFFFY6f8jjN/wBg+P8A9GPWld3UVnbPPO21Fx+JJwB+&#xd;&#xa;JIFY97LrstlO629jHA0bELJI4kVSOhAGN2PfGahtdUmsdO0C2htWuDc2YPy9VKomD16fNzWrbNq3&#xd;&#xa;kz/a0shKF/c+U7lScH72RwOnT3qob/U7OWE6lFZ+TLKsI+zOzMGY4H3gBj1q5Petb6pBBIgW3mQh&#xd;&#xa;ZT3lzwn4jcfwqtBrtu09350kcdvEN8UnPzoMB2/BjtqvqVxdXWi2UFzGbWbUJRBKFPMWQxyPf5f1&#xd;&#xa;rYtrWC0txBBGFjHYknP1J5P41lNBHpniK1a3BC6hujdNx2qVVm3Ads4Ax0rcoooooooorHv/APkZ&#xd;&#xa;9I/65XH8krYooorHT/kcZv8AsHx/+jHrWd1jRnc4VRkn0FZP27VL399plvbC26K10zKZO4ZdoPyk&#xd;&#xa;EYzg9eKybbVLjSdCurloUlnOpSI6ITjJc52/0zW7ZS6pLOHuYLaK1YFlUM3mr6BhjGfXBqtc3ms2&#xd;&#xa;aS3M8Wnm1hBkfZI5k2Dk4BGM4HrjNWTqRW9tUZAlrcxZSRupkOCE/LJ/CoYNdt2nu/Okjjt4hvik&#xd;&#xa;5+dBgO34MdtLc6ndWvhp9RuLZY7lIt7Qk8A56VPpOkwaXZiCMtIx+/JISzP+f8ulUmgj0zxFatbg&#xd;&#xa;hdQ3Rum47VKqzbgO2cAY6VuUUUUUUUUVj3//ACM+kf8AXK4/klbFFY/hX/kAxf8AXWb/ANGvVq/v&#xd;&#xa;WhdLa1QS3kgyiN91V/vN/s5wOMnkVj6idWN7pP8AaCWSxfblwYHctu2P6gcdatJqmp3l1eW9jawA&#xd;&#xa;205jMk7EIwwDgYyd3PpjGKuztqotYTAlkbj/AJah3cIP90gZ/Om6ZfTTz3FpdpGt1bhGcwklCGzj&#xd;&#xa;BPOflOeKgbWWjt74SRot3BIyRQkn95kkRf8AfWKX+2llis/smyaaeUIyAn5QCBIf+A5qEW0Wq+Ib&#xd;&#xa;o3IYpp+xEQOQrFlV9xAPOOmOla1zawXduYJ4w0Z7AkY+hHI/Csvw3O4W705iXXT5BCsjHLOMZya2&#xd;&#xa;6KKKKKKKKx/CX/Isaf8A9ch/OtiiiiisdP8AkcZv+wfH/wCjHqxrtpLfaVLBDjfuRwD32urEfXAq&#xd;&#xa;ldane3lrNb22kXcUsiMFe5VVQcc5KsT06cdcUyysrmOXw8XhYC2snjl/2GKRjB/I/lWhrcM9xpzR&#xd;&#xa;wDcpI86MdZYv40HuRkDp9RXL/wBjWQu7F9P8PX1rLHdRO0srZVVDAn+M9vaul163lls457ZDLPaS&#xd;&#xa;ieKMfxsARg/99Vh6j4fuhpcEVkN888b28gk4WNZHMjMcehAH41r+JP3VpbXzcx2NwLiQD7xUKwwP&#xd;&#xa;f5hWnb3EV1Ak8DiSJxlWHQisia4i1DxNaw27hm07dJNnp8ysgUe+cH6VuUUUUUUUUVj3/wDyM+kf&#xd;&#xa;9crj+SVsUUUVjp/yOM3/AGD4/wD0Y9ad1GZrWaJSAzoyjPTkVjWN9dWFjb2H9lXsklvGsPmqq+Wx&#xd;&#xa;UY3A7s7eM9M47VnT6bqMmgyRSW3+ktqZmZU5G3zM5Ge1dTeLO9nOtq6x3DRsInborY4J6964q90W&#xd;&#xa;xktJ1Tw3fm+aNgJt3ymTH3vv9M89PwrodRtZzo1nJDEz3NkUmSL++wUrtP5n8qytR8P3Q0uCKyG+&#xd;&#xa;eeN7eQScLGsjmRmOPQgD8a6DXLKTUdHurOFlWSZNqlzwPrS6TqttrFkt1aMdhOGVhgqfQ/mKozXE&#xd;&#xa;WoeJrWG3cM2nbpJs9PmVkCj3zg/Styiiiiiiiise/wD+Rn0j/rlcfyStiisfwr/yAYv+us3/AKNe&#xd;&#xa;jUEmtdYi1JLaW5jFu1uY4AC4JYNnBIGPl9e4qrdvqGp3mmyLYPBaw3as4m4lBCtzgEjbyOc5z2q/&#xd;&#xa;o1vLBLqZlQoJb1pEz/EuxBn9DVHxDYi6u42vbGbULERgJDAcMkmTljyvBGB17dKZ4WsEs7/UXt9O&#xd;&#xa;nsLaRYgiTHJJG7d3PqO9T32lPNrsUqhzFM8csrj+AwnKD/gW4/lVfTdGubPXU2gGzthI6yP952lw&#xd;&#xa;SAOnG39anS6g0zxJdRXcgRtRKPAe3Cqm0+5PT2rZuLiK1geedxHEgyzHoBWR4ZiaT7ZqQwIdQkE0&#xd;&#xa;Sn7yjGPm7Z+ma3KKKKKKKKKx/CX/ACLGn/8AXIfzrYoooorHT/kcZv8AsHx/+jHrYoooooooqFLW&#xd;&#xa;BFmVIlAnYtIB/ESMEn8AKW3gitYEggQRxIMKo6AVLRRRRRRRRWPf/wDIz6R/1yuP5JWxRRRWOn/I&#xd;&#xa;4zf9g+P/ANGPWxRRRRRRRULWsDzPM0SmR4/KZu5Xk4/U0tvBFawJBAgjiQYVR0AqWiiiiiiiise/&#xd;&#xa;/wCRn0j/AK5XH8krYorH8K/8gGL/AK6zf+jXrYoooooopk0STwvDKoeORSrKehB4Ipj2sDrCrxKR&#xd;&#xa;AwaMH+EgYBH4E1NRRRRRRRRRWP4S/wCRY0//AK5D+dbFFFFFY6f8jjN/2D4//Rj1sUUUUUUUVT1D&#xd;&#xa;UrbThGJ2bfMSsSKhYu2M44HH40rXM6af9oa0cSgAtBvUleeeehwOadYX9tqNv59o5eMMVJKlSCOo&#xd;&#xa;wQDVmiiiiiiise//AORn0j/rlcfyStiiiisdP+Rxm/7B8f8A6MetiiiiiiiiqeoalbacIxOzb5iV&#xd;&#xa;iRULF2xnHA4/Gla5nTT/ALQ1o4lABaDepK8889Dgc06wv7bUbfz7Ry8YYqSVKkEdRggGrNFFFFFF&#xd;&#xa;FY9//wAjPpH/AFyuP5JWxRWP4V/5AMX/AF1m/wDRr1sUUUUUUUVQOqwtqRsLdXmuIyPOABAjUjO7&#xd;&#xa;J4PUcA559jTW1aKG/W0u43geV9sBI3CX3yOB9DitGiiiiiiiisfwl/yLGn/9ch/OtiiiiisdP+Rx&#xd;&#xa;m/7B8f8A6MepvEN6+n6LPcxnDKUXODwGcKSMc5wTj3rm1uLaydJ9P1XWby5V1VYLoSmNgSAcgqOg&#xd;&#xa;JI56gVs62162taZb2dwIvNjn3hicEDZzgEcjJwe1Sx6bFpVheedqmoSJLHgyTT73j4PKcZB57Z5A&#xd;&#xa;rDgu7WxvbRrLVdVu5JZ44THe+YY9rMATyoGR25q5rbK+pSLqN9qNjCuBbGxL/vFwNxbaG5DZHbip&#xd;&#xa;Uvn0/wANXd1aXRvEgUtC1yGMvXnzM4PXOOBxisia4tLGJrqw1fW7u6iG6OC4Epjc+jDaOPxrov8A&#xd;&#xa;WeLmV/mWKyR4weQjF3BI9CRxn0rYrH035PEWrQp8sQSFwg4UM28scep7nvWxRRRRRRRWPf8A/Iz6&#xd;&#xa;R/1yuP5JWxRRRWOn/I4zf9g+P/0Y9ad1IYbWaVQCyIzDPTIFcTHdWc9ut8+s60t1IgmMEfm+UHIz&#xd;&#xa;tA2/dzx16d61rm51G8uNC8mVbeW6tZHmU7gudqE8Z6jJxnpV2PTYtKsLzztU1CRJY8GSafe8fB5T&#xd;&#xa;jIPPbPIFYcF3a2N7aNZarqt3JLPHCY73zDHtZgCeVAyO3Na3iJmMkMdzcXVpYYyZ7Mt5nm9l+UE7&#xd;&#xa;cbj06gc1QhvhpumX9zp2oT3qxRF9t+HLhsjGMhflxnPvjmqU1xaWMTXVhq+t3d1EN0cFwJTG59GG&#xd;&#xa;0cfjXRf6zxcyv8yxWSPGDyEYu4JHoSOM+lbFY+m/J4i1aFPliCQuEHChm3ljj1Pc962KKKKKKKKx&#xd;&#xa;7/8A5GfSP+uVx/JK2KKx/Cv/ACAYv+us3/o16qeI7yP+0ILC5u7q0t2iM3m2e7zCwIAX5QflwSen&#xd;&#xa;UDmmeHr0jVnsLW4u7uy8gzGe8V/MEm4DaCwHy45xjqTzUWg6bdappVje3uq3yOEG1YJyqsoOfnzn&#xd;&#xa;LZzk+mKn186fJfr5+r6pausYBjsi+zqeTtUjP9MVb0G+lvNHleMmVoXkhhaTIaQLwpbPO48Z6c+l&#xd;&#xa;YsbQm4WSbWNVh1HeGeBjIbZJc8qflx5Ybj72Md+9T6teRXGqPaX+oXtmtvEjRtp+8eYXB3bsBuBt&#xd;&#xa;GOnU9a0fDV0ZUuYElnntrdwsM9wG8yQEZO4sBnBJA4HAFP8AC/z6SJ3+aaWWXfIeWfEjAZPU4AAH&#xd;&#xa;sKPFfy+HbuZeJYU3xuPvI3TIPY8nn3rYoooooooorH8Jf8ixp/8A1yH862KKKKKx0/5HGb/sHx/+&#xd;&#xa;jHq/qFnHf2b20hIViCCOxBBB/MCqSadqjuou9XEkOcssNv5THHI+YMcc4+o4q1cWPnanaXvmbfsy&#xd;&#xa;SLs2/e37e/bG39aXUbJb63EZfY6OJI3xna68qSO4B7VnS6Pqd1Jb/a9WjkihnSbYtptLFTnGd3FW&#xd;&#xa;ruxv2uXlsdS+ziTBZJIvNGQMfLlhtpiaLHJZ3cV9KZ5L3H2iRV2BsDAwMnHAApn9natL8lzrCtC3&#xd;&#xa;DiK28tyPZg3FLqcNzb6jFqVlCspCeXcKz7cxjJGODyCc+/SrLalGNLF+kcrIwG1CpDEk4GR25NRa&#xd;&#xa;Pa3KSXN5fxrHd3DAFUfcFRSdgz6gE81p0UUUUUUVj3//ACM+kf8AXK4/klbFFFFY6f8AI4zf9g+P&#xd;&#xa;/wBGPWrLGssTxv8AddSp+hrIj0rU4I1t4NWSO1QBEj+y5ZUHAG7d1x3q22mg3thcCZyLOJ48P8zP&#xd;&#xa;uCjJbPX5fxzUmo2S31uIy+x0cSRvjO115UkdwD2rOl0fU7qS3+16tHJFDOk2xbTaWKnOM7uKvX9p&#xd;&#xa;czOktnem2lUbTuTzEK/7uQM9Ofr61U/sJrrzm1W6+1PJEYMxx+VhCQSMZPOQOaX+ztWl+S51hWhb&#xd;&#xa;hxFbeW5Hswbil1OG5t9Ri1KyhWUhPLuFZ9uYxkjHB5BOffpVltSjGli/SOVkYDahUhiScDI7cmot&#xd;&#xa;HtblJLm8v41ju7hgCqPuCopOwZ9QCea06KKKKKKKx7//AJGfSP8ArlcfyStiisfwr/yAYv8ArrN/&#xd;&#xa;6NerF/p0s9yl3Z3ItrpUMe9o/MBQnJGMjnIHPtS2NlcwzGe9vnuZSuwBVMcYXg/cyRuznn04p+k2&#xd;&#xa;P9m6Zb2Xmeb5Kbd+3GfwqrLpd5FcTSabqCWqTv5kiPb+ZlzwSDuGBgDj2qbStNexs5oZrnzpJpXl&#xd;&#xa;eRU8vljk4GTiqsmk6jLG1tJqqvZODG0bW+XMZ4IL7s5x/Fj3qSbSZ45zNpl4tq7oscm+HzdwUYXH&#xd;&#xa;IxjJ+uat2FrNbo5ubprmaQ5dsbV44G1cnbxj6nms+y8/SL1rNoM6dLLi2kVtzBm+Zgwx0zu5z6Cm&#xd;&#xa;6k82sStpsEB+yLJsu5HO0lcdFGOe3PtW7RRRRRRRRWP4S/5FjT/+uQ/nWxRRRRWBeXLWHid7h7S8&#xd;&#xa;mieyRA0EDSDcHY4OPYip/wDhIIv+gdqv/gE/+FH/AAkEX/QO1X/wCf8Awo/4SCL/AKB2q/8AgE/+&#xd;&#xa;FH/CQRf9A7Vf/AJ/8KP+Egi/6B2q/wDgE/8AhR/wkEX/AEDtV/8AAJ/8KP8AhIIv+gdqv/gE/wDh&#xd;&#xa;R/wkEX/QO1X/AMAn/wAKP+Egi/6B2q/+AT/4Uf8ACQRf9A7Vf/AJ/wDCj/hIIv8AoHar/wCAT/4U&#xd;&#xa;f8JBF/0DtV/8An/wo/4SCL/oHar/AOAT/wCFH/CQRf8AQO1X/wAAn/wo/wCEgi/6B2q/+AT/AOFH&#xd;&#xa;/CQRf9A7Vf8AwCf/AAo/4SCL/oHar/4BP/hR/wAJBF/0DtV/8An/AMKP+Egi/wCgdqv/AIBP/hUc&#xd;&#xa;Ur6prdndRW1zDFaxyq/2iFoyS+3GM9funP4VuUUUViXrvYa81+9vcTQyWqwjyIjIwYMxOQOgwRzT&#xd;&#xa;/wDhIIv+gdqv/gE/+FH/AAkEX/QO1X/wCf8Awo/4SCL/AKB2q/8AgE/+FH/CQRf9A7Vf/AJ/8KP+&#xd;&#xa;Egi/6B2q/wDgE/8AhR/wkEX/AEDtV/8AAJ/8KP8AhIIv+gdqv/gE/wDhR/wkEX/QO1X/AMAn/wAK&#xd;&#xa;P+Egi/6B2q/+AT/4Uf8ACQRf9A7Vf/AJ/wDCj/hIIv8AoHar/wCAT/4Uf8JBF/0DtV/8An/wo/4S&#xd;&#xa;CL/oHar/AOAT/wCFH/CQRf8AQO1X/wAAn/wo/wCEgi/6B2q/+AT/AOFH/CQRf9A7Vf8AwCf/AAo/&#xd;&#xa;4SCL/oHar/4BP/hR/wAJBF/0DtV/8An/AMKP+Egi/wCgdqv/AIBP/hVdbttR8RafLHZXsUcEUwd5&#xd;&#xa;7dowC23HJHsa6CiuZ0XUzp2nLaz6dqRkSWUkpaOwIMjEYOPQir3/AAkEX/QO1X/wCf8Awo/4SCL/&#xd;&#xa;AKB2q/8AgE/+FH/CQRf9A7Vf/AJ/8KP+Egi/6B2q/wDgE/8AhR/wkEX/AEDtV/8AAJ/8KP8AhIIv&#xd;&#xa;+gdqv/gE/wDhR/wkEX/QO1X/AMAn/wAKP+Egi/6B2q/+AT/4Uf8ACQRf9A7Vf/AJ/wDCj/hIIv8A&#xd;&#xa;oHar/wCAT/4Uf8JBF/0DtV/8An/wo/4SCL/oHar/AOAT/wCFH/CQRf8AQO1X/wAAn/wo/wCEgi/6&#xd;&#xa;B2q/+AT/AOFH/CQRf9A7Vf8AwCf/AAo/4SCL/oHar/4BP/hR/wAJBF/0DtV/8An/AMKP+Egi/wCg&#xd;&#xa;dqv/AIBP/hR/wkEX/QO1X/wCf/Cn+GIpIPDtjFNG8cixAMjqQQfcGtWiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiv/Z</binary>
<binary id="image11.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAGKArgBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKK5/VrWTUPEUFn9vvbWIWjyn7LMUJYOo5/M0v/AAi3/Ud1z/wL/wDrUf8ACLf9&#xd;&#xa;R3XP/Av/AOtR/wAIt/1Hdc/8C/8A61H/AAi3/Ud1z/wL/wDrUf8ACLf9R3XP/Av/AOtR/wAIt/1H&#xd;&#xa;dc/8C/8A61H/AAi3/Ud1z/wL/wDrUf8ACLf9R3XP/Av/AOtR/wAIt/1Hdc/8C/8A61H/AAi3/Ud1&#xd;&#xa;z/wL/wDrUf8ACLf9R3XP/Av/AOtR/wAIt/1Hdc/8C/8A61H/AAi3/Ud1z/wL/wDrUf8ACLf9R3XP&#xd;&#xa;/Av/AOtR/wAIt/1Hdc/8C/8A61H/AAi3/Ud1z/wL/wDrUf8ACLf9R3XP/Av/AOtR/wAIt/1Hdc/8&#xd;&#xa;C/8A61H/AAi3/Ud1z/wL/wDrUf8ACLf9R3XP/Av/AOtR/wAIt/1Hdc/8C/8A61H/AAi3/Ud1z/wL&#xd;&#xa;/wDrUf8ACLf9R3XP/Av/AOtR/wAIt/1Hdc/8C/8A61H/AAi3/Ud1z/wL/wDrUf8ACLf9R3XP/Av/&#xd;&#xa;AOtR/wAIt/1Hdc/8C/8A61H/AAi3/Ud1z/wL/wDrVW1Dw81rp1zcR67rReKJ3UNd8EgE88VsaBI8&#xd;&#xa;2g2Ekrs8jwIWZjkk46k1oUUUUUUUUUUUUUUUUVga1byX2u2NmL68tY2gldjbSlCSCuM/maP+EW/6&#xd;&#xa;juuf+Bf/ANaj/hFv+o7rn/gX/wDWo/4Rb/qO65/4F/8A1qP+EW/6juuf+Bf/ANaj/hFv+o7rn/gX&#xd;&#xa;/wDWo/4Rb/qO65/4F/8A1qP+EW/6juuf+Bf/ANaj/hFv+o7rn/gX/wDWo/4Rb/qO65/4F/8A1qP+&#xd;&#xa;EW/6juuf+Bf/ANaj/hFv+o7rn/gX/wDWo/4Rb/qO65/4F/8A1qP+EW/6juuf+Bf/ANaj/hFv+o7r&#xd;&#xa;n/gX/wDWo/4Rb/qO65/4F/8A1qP+EW/6juuf+Bf/ANaj/hFv+o7rn/gX/wDWo/4Rb/qO65/4F/8A&#xd;&#xa;1qP+EW/6juuf+Bf/ANaj/hFv+o7rn/gX/wDWo/4Rb/qO65/4F/8A1qP+EW/6juuf+Bf/ANaj/hFv&#xd;&#xa;+o7rn/gX/wDWqpqugPZaVd3UWua0XhheRQ13wSATzxW7ozvLothJIzO7W8bMzHJJKjJJq7RRRRRR&#xd;&#xa;RRRRRRWO/wDyOMP/AF4Sf+jErYoooooooooooooooooooooooooooqlrX/IEv/8Ar2k/9BNQ+G/+&#xd;&#xa;Rc07/r2T/wBBFadFFFFFFFFFFFFFFFFY91/yNdh/16zfzStiiiiiiiiiiiiiiiiiiiiiiis7xD/y&#xd;&#xa;L2pf9esn/oJp2hf8gHTv+vWP/wBBFX6KKKKKKKKKKKKx3/5HGH/rwk/9GJWxRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRVLWv+QJf/APXtJ/6Cah8N/wDIuad/17J/6CK06KKKKKKKKKKKKKKKKx7r/ka7D/r1&#xd;&#xa;m/mlbFFFFFFFFFFFFFFFFFFFFFFFZ3iH/kXtS/69ZP8A0E07Qv8AkA6d/wBesf8A6CKv0UUUUUUU&#xd;&#xa;UUUUVjv/AMjjD/14Sf8AoxK2KKKKKKKKKKKKKKKKKKKKKKKKKKKKpa1/yBL/AP69pP8A0E1D4b/5&#xd;&#xa;FzTv+vZP/QRWnRRRRRRRRRTDLGJliMiCVgWVCwyQOpA/EU+iiiiise6/5Guw/wCvWb+aVsUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUVneIf+Re1L/r1k/9BNO0L/kA6d/16x/+gir9FFFFFFFFFFFFY7/8jjD/ANeE&#xd;&#xa;n/oxK2KKKKKKKrT39rb3UNtNOiTzf6tD1b6VZoooooooooooooooooooqlrX/IEv/wDr2k/9BNQ+&#xd;&#xa;G/8AkXNO/wCvZP8A0EVp1iyefqmq3lkbhoba22LJGgH74MuTluq/gRU0GhWtnOk1k00Dg/NmVpA6&#xd;&#xa;91wxIGeORzS3N9dS3D2+lRwyyRH968zFUU/3cgE7uQemMGq15rktjp9w1xAovrcKxiU/K6lgNynq&#xd;&#xa;RzjnHIp7XOuMpnS1skgxuCzSOJAvoQARn8azvFV/Pc+GLe8scJDM0bkuxVwCRtHGR9eavXeparpt&#xd;&#xa;k1xe21q/7yNES2dmLbmwfvAc88VZguNTDma9is4bIKXJEjeYoxkZGMZ9eai+36nL/pVtZxPY9QrM&#xd;&#xa;fOdfVV+7z1GT6dKhS7gvvEmnz20gkja1mAI9QyAip5b/AFC5u7iHS4bUrbMI5DcuyktgHjaDxgjr&#xd;&#xa;V2xmuJYmW7gEUyHaxU5Ru+VJ5I+oHOatUUUVj3X/ACNdh/16zfzStiiiiioLu7t7G3a4upViiXGX&#xd;&#xa;boM8U2e/tbeyF5NOiWxAYSHpg9P51NFIk0SSxsGR1DKw7g9DT6KKKKKKKKKKKKKKzvEP/Ival/16&#xd;&#xa;yf8AoJp2hf8AIB07/r1j/wDQRV+iiiiiiiiiiiisd/8AkcYf+vCT/wBGJWxRRRRVO/0y11Hy/tSO&#xd;&#xa;3l527JXTrjP3SM9K5DwjpltqTakLzz5fJuCkf+kSDA544apvFKyx+K9CW0VDIoIjErHb17nk1oap&#xd;&#xa;rmqaHFFc6nbWbWzSiNvs0jM4yCeAwA7etaOpasLe6g0+28t7+5GYkkJCgDJJYjkDCnoDzVSDXLuH&#xd;&#xa;xBDpGpwQLLcR+ZE1sxZf4uu4D+6elZ//AAll/LqOpWVppZuJbVysew9cNjLc8cenen3PijUrGLTv&#xd;&#xa;tml7JruZo2iB+YAFcbfUndU974jvNMvLQX1iPIvCRCkJzMDxgMDgA/MOhNE/iK80/WLK01G1iWO8&#xd;&#xa;OIzCxLrkgDcDgDrzjNX9d1pNKjjjijM97OdsEC9WPqfaqk2uX2lXMP8Abdvbx2s3yie3dmCN2Dbg&#xd;&#xa;McZ6Z6U3xH4nGkX1tZxJGZZgHMkxKxqpJGSRk9R6VbkfW/sF000WnhvKJj8uVzz3zlfTP41heCZt&#xd;&#xa;al0VWgFpLD5zZaeV9/bPQH+ddFrd9c6fbrPC1mkYOJGunZQPTG0H3rK0rxTJf6lJp221knaIvDJA&#xd;&#xa;7NGSAeGJAI7dAazPCU+tSTap9n+yylbjD+fK+FOTwuAeK7mPf5a+YFD4G7b0z3xTqKKKpa1/yBL/&#xd;&#xa;AP69pP8A0E1D4b/5FzTv+vZP/QRWnWHcQXWm6zNqUKzXNtcqFlt4UUuHAAVhnHGAc89xxViDU7q7&#xd;&#xa;nSOLTLq3Gcu90oVdvfG0n5v061E4m0i8uZ47Wa7hu38wrCAXR8AdCQNuF65zk1R1Swu9StLq++zu&#xd;&#xa;kskSQxW5+/tEgYlvQ9ehPGK6OcFreRQMkqQB+Fc/LpF1d+DLSwVVjuEjiLLIcY24JHHfipNQnuNV&#xd;&#xa;s1jj028gaO4hf98qjIDgnGGPQCtq7gF1aTW7MVEqMhI7ZGKyobq+soU09dPllmjURxzqB5JHRSxz&#xd;&#xa;kcYzgeuM1Bpuivpep2KR7pIYoJt0hHAZnU4/n+VGrW8T3zNd6Rd3Of8AVyWUjL8v+38y/NnPrxjm&#xd;&#xa;r+hRTxW0gkR4rcvm3hlOXjTHIY885yep4IrTooorndfu2sNXhu0UO0NjcOFPQ4KVW8O258R6Sl9r&#xd;&#xa;E0tw7MwRVYxCMA4/gxnoOtbtjpkWnSt9lkkWBl5iZy/zf3ssSenGM4rNXXLzUb2aHRLeGaGAYeed&#xd;&#xa;iqs391cZz174707TfE9rc28/2wG0ubQf6RE/8PQEjnpk4quuua1c2DajZ6ZE9qW/do7ESunHzYHH&#xd;&#xa;f17VX8Uanbav4Gnu7RiY2ZAQeqncvB9+al1iWGHwDBJcWy3MYggzGzFQfu9xzU+pa02jeFbO+t7d&#xd;&#xa;CGSJREWOFBXpnrxSSaprsekHUjbad5Ih8/aJX3bcZ/u4z+NWh4ksV0GLVpy8cUoO1CBuZhngc4zw&#xd;&#xa;e9UbjWdct9HfU5LGzSFV3eW8j+ZjOBxjH61t6ReNqGlW146BGmjDlR0Ga5Dx1cTxazaLdTXMOmFM&#xd;&#xa;7oAM7+c9xn+HvWhaQ6HPqVt/Y2qvFcoSdiytL5gxyMOSOma0PEWtyaPLYJHCkn2qbyzuJG0cc/rU&#xd;&#xa;er+IxYa5p+mwrHK9xIElyTmMEjB/U/lTNU8RyQa7FpFmkHnsBlrliqEnG0Ark559KfrEmrr4b1Bp&#xd;&#xa;0s0lEbcxSPgJtOSCQPm9Kq+DZdWk0WxZhavaHdl2kcykbj2xjr71o3GsNNqDadpPkTXkSl5fOYqi&#xd;&#xa;gHBGQCd2SO2MUzRdckvru+sbqFY7uzbDeWcoR2wTznOe1Z2leJtT1bS5ru2sYEMBYu0jsEIABwpG&#xd;&#xa;Tu+uB0qe08R3mp6X9s06xCiNC0rXJ2oSByEK5J5z1xT5NVTWfBN7eIjJutZFZT2YKc49s1p6F/yA&#xd;&#xa;dO/69Y//AEEVfoooooooooooorHf/kcYf+vCT/0YlbFFFFFFcz4NsLqxbVPtUDxebcFk3fxDnmjX&#xd;&#xa;bC6uPFejXMMDvBCT5jjovPejx7YXWo6JFDZwPNILhWKr1xtbn9RTvEOhRXeo2mqS273awJ5ctsuC&#xd;&#xa;XXnG0ccgtnkjgUml2Fr/AGnBNZaEbHyiTJJcJhsFSBswx5yec9s1X8NabeWvirWbm4t3jhmdzG56&#xd;&#xa;Nl88fhU/iuwurzVtCltoHkSC43Ssv8A3JyfyNHiuwurzVtCltoHkSC43Ssv8A3JyfyNQeKdNvLzx&#xd;&#xa;Ho1xb27yRQyKZHXoo3g8/hVzxRpVzcSWuqaeokvbJtyROflde4wOSc47jvVTVoL3xRNbWL2NxZ2K&#xd;&#xa;N5s8k6hXJHGFILDoT1HatPXBbSeVb3Wj3WoIo3KYkVlU9O7Dms3w7pl3FcaoyQNZWE+RBbS8MrYH&#xd;&#xa;zYGRj8ab4Y+16DYNp1zpl5K6zN+9hVTGQe4JIOPwo1nS5k8XW2rPZSXtsI8bIRl1dehIJA6n17Ul&#xd;&#xa;tDeXnjmLUjp9zb2wgKEzKAc4PoT60mixXnh++1NJ9OurpbibzEktlDLg5P8AERzzXWxtvjVyrLuA&#xd;&#xa;O1uo9jTqKKKpa1/yBL//AK9pP/QTUPhv/kXNO/69k/8AQRWnRRRRRRRRRRRRRRRRWBrFpHfa9bWk&#xd;&#xa;pYRzWU6MVPIBKdKraLFqHhqxFlc2b3kW4mJrIbiozk79xX1GMe9bFjeXd5cM7Wj2tsqY2zriQvnq&#xd;&#xa;MEjbj8c1h6fbXvhm/u4ILKa8sJ/3sbRANIr8DDZKjHB6e1R6V4Xmu4dQu9XPlXOor80cJwEBIbHI&#xd;&#xa;ODkep4pba61zTdDOmppbS3cBEUUqpmFkGBkncDnr29Kbe+HJ7HwNLptsrXFy7rI6qcgtlc7eBxxV&#xd;&#xa;vXbC6uPA0dnDA73IihUxjrkbc/yqDxJpt5deC7K0gt3kuEEW6MdRhcGtO4tZ28GtaLExuDYiPy++&#xd;&#xa;7ZjH51z934e1C88CWFmkQS5tmaR4n4Y/e4GO/IqTVtUvZPB09vf6Vdwz+UFeQIBEMMMfxZ6Y7da6&#xd;&#xa;Hwv/AMi1p3/XBabqV7qllqMBhsxdaeykSCFSZlbn1IGOn61j6rps3iLULO5gsJbKS2dWke7AXeoO&#xd;&#xa;QF2ls456461ueI7KO/0K7gmZ1Xyy+UIByvzD9RXNeBLeW/uX1e6QoYoUtoSnCuoGDnOTn5R+dbet&#xd;&#xa;i0uLhY7zQ7u/8ofJJHGpUZ64yw9Ko6HpGojwtfWVwREbhZFt4nJ/dA5GDxxzzxnrU/haW5sNNtNL&#xd;&#xa;udNvFeMsrTbV8vlic5znHPpVbUPDlrb61LqUtjNqMNwpDwqAzLITnIHA24BHUnmtDQ7KKGW4mtdL&#xd;&#xa;FhA6BNsi4lZhnJOCRt5GO+c1n+EtNvLLwpe21zbvFO7yFUbqcoAP1qfwzYXVp4PltbiB45yJcIev&#xd;&#xa;OcVV0uzuLD4e30F3C0UohnJVuuCDXQ6F/wAgHTv+vWP/ANBFX6KKKKKKKKKKKKx3/wCRxh/68JP/&#xd;&#xa;AEYlbFFFFFFFFFFFFFFFFFFFFFFFFFFFFUta/wCQJf8A/XtJ/wCgmqfh28tU8PaerXMKsLdAQXAI&#xd;&#xa;4FaP26z/AOfqD/v4KPt1n/z9Qf8AfwUfbrP/AJ+oP+/go+3Wf/P1B/38FH26z/5+oP8Av4KPt1n/&#xd;&#xa;AM/UH/fwUfbrP/n6g/7+Cj7dZ/8AP1B/38FH26z/AOfqD/v4KPt1n/z9Qf8AfwUfbrP/AJ+oP+/g&#xd;&#xa;o+3Wf/P1B/38FH26z/5+oP8Av4KPt1n/AM/UH/fwUfbrP/n6g/7+Cj7dZ/8AP1B/38FH26z/AOfq&#xd;&#xa;D/v4KzJZ4pvFdj5MqSYtZs7GBxylbdFFFFFFFFRzwx3ELwzIHjkUqynoQe1Zg8L6ICCNNgyPY1r0&#xd;&#xa;UU2RFkjaNwGRgQwPcGorOzt7C3EFpEsUQJIVenNT0UUUUUVneIf+Re1L/r1k/wDQTTtC/wCQDp3/&#xd;&#xa;AF6x/wDoIq/RRRRRRRRRRRRWO/8AyOMP/XhJ/wCjErYoooooooooooooooooooooooooooqlrX/I&#xd;&#xa;Ev8A/r2k/wDQTWLoXhzR7jQ7GabT4XkkgRmYjkkjrV//AIRbQ/8AoGwfkaP+EW0P/oGwfkaP+EW0&#xd;&#xa;P/oGwfkaP+EW0P8A6BsH5Gj/AIRbQ/8AoGwfkaP+EW0P/oGwfkaP+EW0P/oGwfkaP+EW0P8A6BsH&#xd;&#xa;5Gj/AIRbQ/8AoGwfkaP+EW0P/oGwfkaP+EW0P/oGwfkaP+EW0P8A6BsH5Gj/AIRbQ/8AoGwfkaP+&#xd;&#xa;EW0P/oGwfkaP+EW0P/oGwfkaP+EW0P8A6BsH5Gj/AIRbQ/8AoGwfkaqRaZZab4qsxZWyQCS2lLbO&#xd;&#xa;+CmK6Oiiiiiiiiiiiiiiiiiiiiiis7xD/wAi9qX/AF6yf+gmnaF/yAdO/wCvWP8A9BFX6KKKKKKK&#xd;&#xa;KKKKKx3/AORxh/68JP8A0YlbFFFFFFFFFFFFFFFFFFFFFFFFFFFFUta/5Al//wBe0n/oJqHw3/yL&#xd;&#xa;mnf9eyf+gitOiiiiiiiiiiiiiiiise6/5Guw/wCvWb+aVsUUUUUUUUUUUUUUUUUUUUUUVneIf+Re&#xd;&#xa;1L/r1k/9BNO0L/kA6d/16x/+gir9FFFFFFFFFFFFY7/8jjD/ANeEn/oxK2KKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKpa1/yBL/8A69pP/QTUPhv/AJFzTv8Ar2T/ANBFadFFFFFFFFFFFFFFFFY91/yNdh/1&#xd;&#xa;6zfzStiiiiiiiiiiiiiiiiiiiiiiis7xD/yL2pf9esn/AKCadoX/ACAdO/69Y/8A0EVfoooooooo&#xd;&#xa;oooorn9RluofFVu1lapcyGycFGl8sAb15zg+3FWPt2uf9AWD/wADh/8AEUfbtc/6AsH/AIHD/wCI&#xd;&#xa;o+3a5/0BYP8AwOH/AMRR9u1z/oCwf+Bw/wDiKPt2uf8AQFg/8Dh/8RR9u1z/AKAsH/gcP/iKPt2u&#xd;&#xa;f9AWD/wOH/xFH27XP+gLB/4HD/4ij7drn/QFg/8AA4f/ABFH27XP+gLB/wCBw/8AiKPt2uf9AWD/&#xd;&#xa;AMDh/wDEUfbtc/6AsH/gcP8A4ij7drn/AEBYP/A4f/EUfbtc/wCgLB/4HD/4ij7drn/QFg/8Dh/8&#xd;&#xa;RR9u1z/oCwf+Bw/+Io+3a5/0BYP/AAOH/wARR9u1z/oCwf8AgcP/AIij7drn/QFg/wDA4f8AxFH2&#xd;&#xa;7XP+gLB/4HD/AOIo+3a5/wBAWD/wOH/xFH27XP8AoCwf+Bw/+Io+3a5/0BYP/A4f/EUfbtc/6AsH&#xd;&#xa;/gcP/iKPt2uf9AWD/wADh/8AEUfbtc/6AsH/AIHD/wCIo+3a5/0BYP8AwOH/AMRR9u1z/oCwf+Bw&#xd;&#xa;/wDiKq6reay2k3iyaPCiGBwzC8B2jacnG3mr/hv/AJFzTv8Ar2T/ANBFadFFFFFFFFFFFFFFFFc/&#xd;&#xa;q8t1F4l09rO2W4k+zzDY0vljGU5zg1Y+3a5/0BYP/A4f/EUfbtc/6AsH/gcP/iKPt2uf9AWD/wAD&#xd;&#xa;h/8AEUfbtc/6AsH/AIHD/wCIo+3a5/0BYP8AwOH/AMRR9u1z/oCwf+Bw/wDiKPt2uf8AQFg/8Dh/&#xd;&#xa;8RR9u1z/AKAsH/gcP/iKPt2uf9AWD/wOH/xFH27XP+gLB/4HD/4ij7drn/QFg/8AA4f/ABFH27XP&#xd;&#xa;+gLB/wCBw/8AiKPt2uf9AWD/AMDh/wDEUfbtc/6AsH/gcP8A4ij7drn/AEBYP/A4f/EUfbtc/wCg&#xd;&#xa;LB/4HD/4ij7drn/QFg/8Dh/8RR9u1z/oCwf+Bw/+Io+3a5/0BYP/AAOH/wARR9u1z/oCwf8AgcP/&#xd;&#xa;AIij7drn/QFg/wDA4f8AxFH27XP+gLB/4HD/AOIo+3a5/wBAWD/wOH/xFUtbvNYfRL9ZtIhjjNu4&#xd;&#xa;Zxebio2nJxt5rW0L/kA6d/16x/8AoIq/RRRRRRRRRRRRWO//ACOMP/XhJ/6MSr+o3senWE15MrtH&#xd;&#xa;Cu5ggBJHtmrFLRRRRRWbd69pVlcNb3V9FFMmNyMeRkZFQ/8ACU6H/wBBKD8zWvS0UUUUUUUUyWRI&#xd;&#xa;YnllYKiKWZj2A6mkgmjuIUmhcPHIoZWHQg9DUlFFFVb/AFG106NXu5ljDnauf4j6Co7jU4rW0iub&#xd;&#xa;mKWGJ8by4H7nj+PnjnjjPJpmpzR3Hh68mhcPHJauysOhBU803w3/AMi5p3/Xsn/oIrTooooooooo&#xd;&#xa;ooooooorHuv+RrsP+vWb+aVsUUUUVWv72OwtxNKrspdEwoBOWYKP1NOu7u3sbdri6lWKJcZdugzx&#xd;&#xa;Vc6rEtgL1oZhAW5YgcJ/fPP3cc+uO1WLO8t763E9pKssRJAZenFT0UUUUUUUUUUUUVneIf8AkXtS&#xd;&#xa;/wCvWT/0E07Qv+QDp3/XrH/6CKv0UUUUUUUUUUUVjv8A8jjD/wBeEn/oxKPFn/Isah/1yNXNV1GH&#xd;&#xa;SdNlvrhXaKLG4RgFuSBxkj1qk8WsQI17JfoxQb2tAi+XjuA23d05Hv7VEmrSpfW91I7HT763D28Q&#xd;&#xa;Ub0YIXJb8B6nmq8OvTSWNyu9/tMzIbV9i4jE+fJ3f7vfg/jV3U7650rQrd7mZBcExwzTgcKWwGcD&#xd;&#xa;GOOTjFZUeupDdWwi8QDUmlmSIwGJF4ZgC2VAPFX9+qX2talaw3otra3aPa6orOCUB24Ixg5Jz14F&#xd;&#xa;acGnosKi72Xc/wDFNJEoZvToMdOPwrN8K2dtJ4bsWe3hZjHySgJPJqnea2r6jdQy64NL+zyeUsYj&#xd;&#xa;R94wDu+YH1x+FSNrdzL4Wuby1mVpoZxDHNgYkAkVdxGMDIPYd6fqZ1mwthcDUVead1hWExr5cbuc&#xd;&#xa;Ahtu4hSe/XHNOY6tpUVpPe6kbtpJY4ZIvKRUBcgEggA8Z4p2r3mor4hsbCxmSNJ4XL7wOMfxDg8j&#xd;&#xa;sOh702VtW0rUbIzagL20uZBAyyRqjKx5BG1fQHv3qHU9ZVdXubSXWRpgt9oUCNXMu5Qc/MDjGcUJ&#xd;&#xa;rc8vhrVLm3uhNJZlkjuQo+fCg7sYx3x07VqWdtqZmjuLvUflPLW0calOnQMQG96yL/VYoLq4H/CU&#xd;&#xa;eW0bt/o/kxnaQfu5259qvX882peDZLpZPs7zWZlbaA3BTJXn16ZrKsxqVjoOkXMeqyNFI1unkGGP&#xd;&#xa;AViBjOM9DXTapNJb6VeTRNtkjgd1OM4IUkVkSXep3F7pttbXCRi4sjLK7KMg/L8w4PPPTpzTtSuL&#xd;&#xa;vRbBGudUaTz51i8+SJF8kEHLAAYPTvVK318Q6jZwQ6yuqfaZREyGNU8sf3htAzWpcIt34ojt7hRJ&#xd;&#xa;FBbCeNSOA5Yrn347HitaWKOaJopUDowwVPQ1z9uxHhrWIM/urU3EES/3UVcKPf6nmtDw3/yLmnf9&#xd;&#xa;eyf+gitOiiiiiiiiiiiiiiiise6/5Guw/wCvWb+aVoX13HY2U13KGMcKF2CjkgelZy2+sSqLpdRV&#xd;&#xa;GI3LaiNTF7Att3YPepr26uJbxNNtZBBcNF5zzYBCLnHyg5yc46jGKiWe60q4hivrpryO5YokmxVd&#xd;&#xa;XwTggADbgHnrmo4P7R1eBL631FrOCUbooliRsr2LEg4PqAcVX1S9N7ojeYgSaC9ihlC/d3iRM7T3&#xd;&#xa;HPfFXNZAuNS0yxmAe2nd2kjP8RRdy89eCK1jGhj8souzGNuOMemKyNHUW+ranZQgJbRGN0QfwlwS&#xd;&#xa;3vyf/rVs0UUUUUUUUUUUUVneIf8AkXtS/wCvWT/0E07Qv+QDp3/XrH/6CKv0UUUUUUUUUUUVjv8A&#xd;&#xa;8jjD/wBeEn/oxKs65ZSajo91ZwsiyTJtUuSAD74qzd2sF7bNb3USywvjcjdDg5/mKyRZa08v2Sa5&#xd;&#xa;tzpvQyhm+0svXk428ng8dM1Z1PShcadFBZrHFJBtEJOQEXgMB9UyPxqveaBHNf2D25EFtAVMqIcF&#xd;&#xa;ymPKHQ8Dn061e1WyN9aBEYCWJ1mi3H5d6nK7v9nOM45xVK1i8QzXEY1GWwjt1YMTZlw5I7fMMYPe&#xd;&#xa;rdlZSW+p6jcuyFLp42QAnI2oFOfxFX6oaHZSado9taTMjSRLtYoSR17ZqlcWWsWl3O+jNYmK5fzZ&#xd;&#xa;PtZfcHwAcbe2AOvOc1Jeabd3ehPayTq91K6SOWJ2KQ6sQvGdvBxnmrOr2Ul9BAkTIDHcxSncT0Vg&#xd;&#xa;T+PFGr2Ul9BAkTIDHcxSncT0VgT+PFYuvfbv+Es0z+zfs/2jyJcfaN2zHGfu81dg03Ub2eGfWp4V&#xd;&#xa;a2kEkUdmTsYjPLbhnPPY068stVt7+a50ZrIm52mYXZbgqABt29setLc6dfXfh+7tbieNry5U5wT5&#xd;&#xa;SE8YXjO3jvnqa1WjDwGJjwy7Tj6Vz/2LxJbW32GybSjZxp5URmMnmbAMDdjjOPStS004p4fi0y5b&#xd;&#xa;kWwgkaM/7OCRkf0rK/sjVzCliXsfsNrg2xy/mkpzHv4xjIG7HvinXFl4k1C1ntb2bToYpI2G61Mg&#xd;&#xa;bOOAdwI2k9e+KvW+mzRahY3DNGUt7MwMATksSvI46fKan1aye8t4zAyi4gkE0O8/IXAON2Occ9qq&#xd;&#xa;2cGuTXCtqk9pFFGdyiyLAufRtw6fSk1QS2WqW+pQW8s4ZfInVADtjGWDDkc5x36dqtXeqQw2UdxD&#xd;&#xa;m4acfuEjGTKcZ4zjtz9BVBLZ4PCl9JMrJcXMMs8yHorsuWA9s/Wrfhv/AJFzTv8Ar2T/ANBFadFF&#xd;&#xa;FFFFFFFFFFFFFFY91/yNdh/16zfzStC+tI76ymtJSwjmQoxU8gH0rKFnr0bi0iubU2AwvnOzfaQv&#xd;&#xa;c5A27hzjjHSrmoWMz7bmxdFvol2o0pO1x/dfAzjvx3AqGysb64lFxrZtnliP7qO2LeWOPvfNzu5I&#xd;&#xa;9MVDJZazZP5GjvY/YuoW6L7o/wDZXaMbQMYz71Nd6Nu0sWlq+XM8czySnlyGUkkgdSB6U7XIplFv&#xd;&#xa;f2sLz3No/wAkSjO5Wwrccc7c45HNTHVrYWAuxvYM3liMAbzJ/cxnG7PHWoNDimdrrULqF4Li6fBi&#xd;&#xa;YY2ouQnHPODzzWtRRRRRRRRRRRRRWd4h/wCRe1L/AK9ZP/QTTtC/5AOnf9esf/oIq/RRRRRRRRRR&#xd;&#xa;RRWJqMq2GvQ6jch1tfsrQb1Qud5ZWAwoJ6KecYp//CT6V/z2n/8AAWX/AOJo/wCEn0r/AJ7T/wDg&#xd;&#xa;LL/8TR/wk+lf89p//AWX/wCJo/4SfSv+e0//AICy/wDxNH/CT6V/z2n/APAWX/4mj/hJ9K/57T/+&#xd;&#xa;Asv/AMTR/wAJPpX/AD2n/wDAWX/4mj/hJ9K/57T/APgLL/8AE0f8JPpX/Paf/wABZf8A4mj/AISf&#xd;&#xa;Sv8AntP/AOAsv/xNH/CT6V/z2n/8BZf/AImj/hJ9K/57T/8AgLL/APE0f8JPpX/Paf8A8BZf/iaP&#xd;&#xa;+En0r/ntP/4Cy/8AxNH/AAk+lf8APaf/AMBZf/iaP+En0r/ntP8A+Asv/wATR/wk+lf89p//AAFl&#xd;&#xa;/wDiaP8AhJ9K/wCe0/8A4Cy//E0f8JPpX/Paf/wFl/8AiaP+En0r/ntP/wCAsv8A8TR/wk+lf89p&#xd;&#xa;/wDwFl/+Jo/4SfSv+e0//gLL/wDE0f8ACT6V/wA9p/8AwFl/+Jo/4SfSv+e0/wD4Cy//ABNH/CT6&#xd;&#xa;V/z2n/8AAWX/AOJo/wCEn0r/AJ7T/wDgLL/8TR/wk+lf89p//AWX/wCJo/4SfSv+e0//AICy/wDx&#xd;&#xa;NQX+u6fe2FxaW7zPNPE0cam2kXLMCAMlcDk9TWjolvLaaLZW867JYoUR1yDggc9KvUUUUUUUUUUU&#xd;&#xa;UUUUUVi6q4s9as9QnDC1jhkjZ1UuQzFSBgZPY9qd/wAJPpX/AD2n/wDAWX/4mj/hJ9K/57T/APgL&#xd;&#xa;L/8AE0f8JPpX/Paf/wABZf8A4mj/AISfSv8AntP/AOAsv/xNH/CT6V/z2n/8BZf/AImj/hJ9K/57&#xd;&#xa;T/8AgLL/APE0f8JPpX/Paf8A8BZf/iaP+En0r/ntP/4Cy/8AxNH/AAk+lf8APaf/AMBZf/iaP+En&#xd;&#xa;0r/ntP8A+Asv/wATR/wk+lf89p//AAFl/wDiaZJ4s0WEAy3MiAnALW0o5/75p/8Awk+lf89p/wDw&#xd;&#xa;Fl/+Jo/4SfSv+e0//gLL/wDE0f8ACT6V/wA9p/8AwFl/+Jo/4SfSv+e0/wD4Cy//ABNH/CT6V/z2&#xd;&#xa;n/8AAWX/AOJo/wCEn0r/AJ7T/wDgLL/8TR/wk+lf89p//AWX/wCJo/4SfSv+e0//AICy/wDxNH/C&#xd;&#xa;T6V/z2n/APAWX/4mj/hJ9K/57T/+Asv/AMTR/wAJPpX/AD2n/wDAWX/4mqes6/p11o17bwPO0ssD&#xd;&#xa;oi/ZpRklSAOVrW0RSuh6erAhhbRgg9R8oq9RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWF4gt49SvbCw2CZkk+0SRngCMKy5/76I461b0C4kn0uNL&#xd;&#xa;hy91B+6uM9RIByM9D1HI4rSooooooooooooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooooooooooooooooooopKxNGd73V9QvJhkwubeBgMAx8N+PPepNM/0TWNQsfv+Y32&#xd;&#xa;zf0xvO3bj229ffpWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRVTVLiS106eaG3e5kVeIkzlu3GAaxbDWbbR9Igt5rbUvLt4wpleyd&#xd;&#xa;B9eelNudUL6zY3UGm6mqLvWdhZuCy7TtB45AJz7V09FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFY/iz/kW73/AHR/6EK2KKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKx/Fn/It3v+6P8A0IVsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUVW1GV4NNupYzteOF2U4zggEisqxs9WurG3uG16ZTLGrkC2i4yM/3am/szVf8A&#xd;&#xa;oYJ//AaL/wCJo/szVf8AoYJ//AaL/wCJo/szVf8AoYJ//AaL/wCJo/szVf8AoYJ//AaL/wCJo/sz&#xd;&#xa;Vf8AoYJ//AaL/wCJo/szVf8AoYJ//AaL/wCJo/szVf8AoYJ//AaL/wCJo/szVf8AoYJ//AaL/wCJ&#xd;&#xa;o/szVf8AoYJ//AaL/wCJo/szVf8AoYJ//AaL/wCJo/szVf8AoYJ//AaL/wCJo/szVf8AoYJ//AaL&#xd;&#xa;/wCJqG70K/vbZ7e512d4nGGX7PEM9+wqb+zNV/6GCf8A8Bov/iaP7M1X/oYJ/wDwGi/+Jo/szVf+&#xd;&#xa;hgn/APAaL/4mj+zNV/6GCf8A8Bov/iaP7M1X/oYJ/wDwGi/+Jo/szVf+hgn/APAaL/4mj+zNV/6G&#xd;&#xa;Cf8A8Bov/iaP7M1X/oYJ/wDwGi/+Jo/szVf+hgn/APAaL/4mj+zNV/6GCf8A8Bov/iaiurHVoLSa&#xd;&#xa;Ya9MTGjMAbaLnAz/AHa0tKmkuNJsp5m3SSwI7tjGSVBJq3RRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRVPV/wDkD3v/AF7yf+gmjR/+QNY/9e8f/oIq5RRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRVXUv+QZd/9cX/APQTUWhf8gHTv+vaP/0EVfoooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooooooooooooooooooqnq/wDyB73/AK95P/QTRo//ACBrH/r3j/8AQRVyiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiqupf8AIMu/+uL/APoJqLQv+QDp3/XtH/6CKv0UUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVT1f/kD3v8A17yf+gmjR/8AkDWP/XvH/wCgirlFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFVdS/wCQZd/9cX/9BNRaF/yAdO/69o//AEEVfooooooooooooooooooooooo&#xd;&#xa;ooooooooooooooooooooooooooooooooooooqnq//IHvf+veT/0E0aP/AMgax/694/8A0EVcoooo&#xd;&#xa;ooooooooooooooooooqrqX/IMu/+uL/+gmotC/5AOnf9e0f/AKCKv0UUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUVix+JbaZA8NlqUqHo6Wjsp+hFO/4SCL/oHar/4BP/hR/wAJBF/0&#xd;&#xa;DtV/8An/AMKP+Egi/wCgdqv/AIBP/hR/wkEX/QO1X/wCf/Cj/hIIv+gdqv8A4BP/AIUf8JBF/wBA&#xd;&#xa;7Vf/AACf/Cj/AISCL/oHar/4BP8A4Uf8JBF/0DtV/wDAJ/8ACj/hIIv+gdqv/gE/+FH/AAkEX/QO&#xd;&#xa;1X/wCf8AwqvqGtrcafcwx6bqm+SJkXNm/Ugj0o07W1t9OtYJNN1TfHEiNizfqAAe1WP+Egi/6B2q&#xd;&#xa;/wDgE/8AhR/wkEX/AEDtV/8AAJ/8KP8AhIIv+gdqv/gE/wDhR/wkEX/QO1X/AMAn/wAKP+Egi/6B&#xd;&#xa;2q/+AT/4Uf8ACQRf9A7Vf/AJ/wDCj/hIIv8AoHar/wCAT/4Uf8JBF/0DtV/8An/wo/4SCL/oHar/&#xd;&#xa;AOAT/wCFH/CQRf8AQO1X/wAAn/wo/wCEgi/6B2q/+AT/AOFX7C9i1CzjuoN3lyZxuGDwSDx9RVmk&#xd;&#xa;JCgk9BzWNF4ltpollhsdSkjYZVks3II9jinf8JBF/wBA7Vf/AACf/Cj/AISCL/oHar/4BP8A4Uf8&#xd;&#xa;JBF/0DtV/wDAJ/8ACj/hIIv+gdqv/gE/+FH/AAkEX/QO1X/wCf8Awo/4SCL/AKB2q/8AgE/+FH/C&#xd;&#xa;QRf9A7Vf/AJ/8KP+Egi/6B2q/wDgE/8AhUN7riTWU8Sadqm542UZsn6kfSmaXrK2ul2lvLpuqeZF&#xd;&#xa;AiNizcjIUA9qs/8ACQRf9A7Vf/AJ/wDCj/hIIv8AoHar/wCAT/4Uf8JBF/0DtV/8An/wo/4SCL/o&#xd;&#xa;Har/AOAT/wCFH/CQRf8AQO1X/wAAn/wo/wCEgi/6B2q/+AT/AOFH/CQRf9A7Vf8AwCf/AAo/4SCL&#xd;&#xa;/oHar/4BP/hR/wAJBF/0DtV/8An/AMKv6few6jZpdQb/AC3JA3rg8Eg5H1BqzRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRWP4T/AORcs/o3/oRrYoooooooooooooooooooooorH8Kf8i9b/wC9&#xd;&#xa;J/6MatimS/6p/wDdNZnhb/kWtO/64LWtRRRRRRRRRRRRRRRRRRWP4V/5AMX/AF1m/wDRr1sUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVj+E/8AkXLP6N/6Ea2KKKKKKKKKKKKKKKKKKKKKKKx/&#xd;&#xa;Cn/IvW/+9J/6MatimS/6p/8AdNZnhb/kWtO/64LWtRRRRRRRRRRRRRRRRRRWP4V/5AMX/XWb/wBG&#xd;&#xa;vWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWP4T/5Fyz+jf+hGtiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiisfwp/wAi9b/70n/oxq2KZL/qn/3TWZ4W/wCRa07/AK4LWtRRRRRRRRRRRRRRRRRRWP4V/wCQ&#xd;&#xa;DF/11m/9GvWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWP4T/5Fyz+jf8AoRrYoooooooo&#xd;&#xa;oooooooooooooorH8Kf8i9b/AO9J/wCjGrYpkv8Aqn/3TWZ4W/5FrTv+uC1rUUUUUUUUUUUUUUUU&#xd;&#xa;UUVj+Ff+QDF/11m/9GvWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWP4T/AORcs/o3/oRq&#xd;&#xa;rB4tgm8RHRxayCQStH5m4Yyuef0q7rc+sQm3/se0huAzHzvMONo4xj5h7+tatFFYqeIUvS39j2sm&#xd;&#xa;oiM4lKMI9h7D58Z79PSrVjqTXFw1tdWr2lyF8wRMwfKZxuyuR14x1rQoooqvfTNbWFxOgBaKJnAP&#xd;&#xa;TIBNYNlrOtal4Xhv7C0tpb15Spj+6m0EjPLD271o65rK6JpiXlxC0mWVCiEDBI/+tVy6luP7Okls&#xd;&#xa;o1e48stEjngtjgHkfzpulyXsunwvqMKQ3ZB8xEOQDk4xye2O9W6KKKKKKx/Cn/IvW/8AvSf+jGrY&#xd;&#xa;pkv+qf8A3TWZ4W/5FrTv+uC1PrWppo+mS30kbSLGVBVTgnJA/rVmzuBd2cFyqlRNGsgB7ZGaoaRr&#xd;&#xa;ceq3d/bxwvGbKXy2LEHcckZH/fNatFFY/iHxBFoMcDywPL5zFRtIGMVsVHcSiC3lmIJEaFiB3wM1&#xd;&#xa;z1v4qnudNfUYdGna0QMzSedGMBevBOaveHvEFrr9vJJbqyPEQHjbquc456c4Na9FFFFFFFY/hX/k&#xd;&#xa;Axf9dZv/AEa9bFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFcvY6hHpngWO5kG7CMAgOCxLk&#xd;&#xa;cfnXIC1ih8NRxCaRrlbgXJh+zSA/dAK524yPXNa/jW+j1Gy0K7i4WVy23OSudvB96v8Aj1PMvdCQ&#xd;&#xa;OyFrkjcvUcryPetHTPCNjpmqDUYri6kn+YnzWUglupOFHrV3xIrP4d1BUUsxgYAAZJ4rO8AMp8Lw&#xd;&#xa;IGBZXfcM8j5j1rX1W7ez066ltwr3EUTSJGec49hziuW0rRtP1bw7JqOoSF7yfLyTlhujYHAA446D&#xd;&#xa;r61AuqXuqfD7UZL5Rvj2or7SC4yvJz1P0rS0bw9pE/hy1uJbCF5XtwzORyTjrWXpOsXll8PJ7qOQ&#xd;&#xa;NLFL5MZfnYp2jj6Z4rRh8P6U/hh7x4VubmS3aZpnOW3lSx6ehrn7j/kmNr/19H+bVt+P7eJvDVtc&#xd;&#xa;MgMqOiq/cAjkfoKvX+kafYeGb+a0tY4ZHs2DMo5I25qDSLuew+HcV1aoHmjjYqpBOfnI6Cq+meH9&#xd;&#xa;Lv8Aw+19dytLdXCiWW4Z13RvwcA44/H1qnd6jd6n8N7ia9H7xZUQNgguAy8n1PNX7DQNKk8Hx3T2&#xd;&#xa;MTTmzLlyOd20nNRadqt9b/Dr7ZETLcR5jUsCdq7tvb0H8qp3Wm3l1pVtd2GiG3vfknN6Z4xuOMlu&#xd;&#xa;W4yeaseI45ptR8LRzyuk74DyIwLBvkyQeRnNb2ieF7LRLyW6tprmSSVCjeaykckHsB6VJ4U/5F63&#xd;&#xa;/wB6T/0Y1bFMl/1T/wC6azPC3/Itad/1wWqfjz/kU7v6x/8AoYpNJTX/AOyLLyZtNEfkJsDxSE42&#xd;&#xa;jGfm61Q8CeZ/aev+cVMn2kbygwM7nzj2qtYy3GuXN7LqGhf2g8UuxMOqCIY6AMc89fxq7oL3nh/w&#xd;&#xa;/qD6lCRHbvujgEisVU844Jx171iXmnPc6Bd6nDpVhZ2u0PCdpMpXI5yGwD9RUfioC58P6HfT/PdT&#xd;&#xa;JtklPVh1x+pr0Cw0mw01naytY4GcYYqOtP1L/kGXf/XF/wD0E1yHhC91OHwwI7DSmuDufZKZUC7v&#xd;&#xa;cEg4zV2PRpNN8N63dXTf6ZfQSSzIv3UO1jgfTce5q94H/wCRSsfo/wD6G1ctpv8AyKfiX/rsf50+&#xd;&#xa;30u2f4dG+mUyzrG5iL/8svnIwv8APv1qXVbKO48B/wBrXTPc3zJGwnlILIC4G0Y7cn8zV3WJ5br4&#xd;&#xa;Z+fO5kleOMsx6k+YtO/4RvR5vCMU8lukMrWiSGZTht20HqeOT/Or/gaWeXwzAbguSpKruH8I6fhi&#xd;&#xa;uhrH8K/8gGL/AK6zf+jXrYoooooooooooooooooooooooooooooooooooooormdJ0i11fwxp0d2H&#xd;&#xa;KxM0i7WxzuaukdQ6Mp6MMGsL/hENJ+yQW2yXy4ZGkT95zk4z/IVoalpFrqc1rLchy1q/mR7Wxzx1&#xd;&#xa;/IVforLm0Gycg2/m2X94WbmHf7ttxn8ansdMhsSzq800jcebPIZHA/uhjzjviqM3hbTpWmwZ4opm&#xd;&#xa;DSQRSlImPHVRx2rQu9NtbvTX094wlsyhdkfy4AOQBjp0p9raRWtjHaRAiKNNignJxjFU7Xw/p1rp&#xd;&#xa;UmmpDvtpCWZZDu5Pfn6VVi8KWUNubeG51COAggxrdMF568dKlbwzpz6OmlFZPsqP5gG/nPPf8avX&#xd;&#xa;unWt/YmzuYhJCVxgjJHGMj0PvVWPQbdIJ4Hub2aKaMxMstwzgA+gPQ1b0+xg06xjs7cHyYwQoY5P&#xd;&#xa;Jz/Wsx/Cemt5yobiKGZtzwRSlYyf90cVfvtKtL7TTp8sey2OMJH8oGDkYx06VJDYQQ6aNPQN5Aj8&#xd;&#xa;oAnnbjHWmadpdrpunixt0Jg5+Vzuznrmqw0C28zJuLxos/6hrhjFj+7s6be2OmKlu9Fsru5sp5Iy&#xd;&#xa;rWRzCEO1V6cY9OBWjWP4U/5F63/3pP8A0Y1bFMl/1T/7prM8Lf8AItad/wBcFq3qenwapYvZ3QYx&#xd;&#xa;PjIU4PBz/SpreBLa2igizsiQIuT2AwKq6dpFrptxdzWwcPdv5km5s85J4/M0280eC6nMwmubd2++&#xd;&#xa;baYxbz6tjqccZNSwaZaxWj2zR+ckn+sab52k/wB4n73pz6Cs0+FLI2v2U3OoG3xt8r7U2zHpjpVq&#xd;&#xa;48P6fc6VFp0sRaCEARnPzrj0Pap7DTUsWdlububcMYnnaQD6Z6VamjWaF4nztdSpx6Gq2l6bb6TZ&#xd;&#xa;LaWgYRKSRuOTk1ZkjSWNo5UV0cFWVhkEHsRWRH4ZtYU8uC71CGMEkRxXTKq5OeAOBTrfw1p9tp91&#xd;&#xa;YoJTDdHMu5yST9anTRLNNEOkqr/ZSpXG7nBOev1ol0Szl0UaS6v9lChcbucA5HP1FUde0Z38Iy6X&#xd;&#xa;pkRkZQixoWAJAcHqfYGmWXheF9LtYb6e9YrHH5kDXLNGGAHG3OMAj6V0EaJFGscaKiIAqqowAB0A&#xd;&#xa;FOrH8K/8gGL/AK6zf+jXrYoooooooooooooooooooooooooooooooooooooorH8J/wDIuWf0b/0I&#xd;&#xa;1sUUUUUUUUUUUUUUUUUUUUUUVj+FP+Ret/8Aek/9GNWxTJf9U/8Aumszwt/yLWnf9cFrWooooooo&#xd;&#xa;ooooooooooorH8K/8gGL/rrN/wCjXrYoooooooooooooooooooooooooooooooooooooorH8J/8A&#xd;&#xa;IuWf0b/0I1sUUUUUUUUUUUUUUUUUUUUUUVj+FP8AkXrf/ek/9GNWxTJf9U/+6azPC3/Itad/1wWt&#xd;&#xa;aiiiiiiiiiiiiiiiiiisfwr/AMgGL/rrN/6Netiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;isfwn/yLln9G/wDQjWxRRRRRRRRRRRRRRRRRRRRRRWP4U/5F63/3pP8A0Y1bFMl/1T/7prM8Lf8A&#xd;&#xa;Itad/wBcFrWoooooooooooooooooorH8K/8AIBi/66zf+jXrYooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooorH8J/8i5Z/Rv/AEI1sUUUUUUUUUUUUUUUUUUUUUUVj+FP+Ret/wDek/8ARjVsUyX/&#xd;&#xa;AFT/AO6azPC3/Itad/1wWtaiiiiiiiiiiiiiiiiiisfwr/yAYv8ArrN/6Netiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiuV8O+H9Ju9Etp7ixiklfcWZhyfmNaX/CLaH/0DYPyNH/CLaH/ANA2&#xd;&#xa;D8jR/wAItof/AEDYPyNH/CLaH/0DYPyNH/CLaH/0DYPyNH/CLaH/ANA2D8jR/wAItof/AEDYPyNH&#xd;&#xa;/CLaH/0DYPyNH/CLaH/0DYPyNH/CLaH/ANA2D8jR/wAItof/AEDYPyNH/CLaH/0DYPyNH/CLaH/0&#xd;&#xa;DYPyNH/CLaH/ANA2D8jR/wAItof/AEDYPyNH/CLaH/0DYPyNH/CLaH/0DYPyNH/CLaH/ANA2D8jR&#xd;&#xa;/wAItof/AEDYPyNH/CLaH/0DYPyNH/CLaH/0DYPyNH/CLaH/ANA2D8jR/wAItof/AEDYPyNJ4SUL&#xd;&#xa;4ctVUYAMgA/4G1bNMl/1T/7prmfD3h3SLnQbGeewheV4gzMRyTWj/wAItof/AEDYPyNH/CLaH/0D&#xd;&#xa;YPyNH/CLaH/0DYPyNH/CLaH/ANA2D8jR/wAItof/AEDYPyNH/CLaH/0DYPyNH/CLaH/0DYPyNH/C&#xd;&#xa;LaH/ANA2D8jR/wAItof/AEDYPyNH/CLaH/0DYPyNH/CLaH/0DYPyNH/CLaH/ANA2D8jR/wAItof/&#xd;&#xa;AEDYPyNH/CLaH/0DYPyNH/CLaH/0DYPyNH/CLaH/ANA2D8jR/wAItof/AEDYPyNH/CLaH/0DYPyN&#xd;&#xa;H/CLaH/0DYPyNJ4SVU8PQIowqySgD0HmtWzRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWP4&#xd;&#xa;T/5Fyz+jf+hGrmoXwskjCxtNPM2yKJTgu2MkZPA4BPPpTdP1A3UkkE9u1tdRgM0LMGIU5wcjjnB7&#xd;&#xa;9qrza06yym3spJ7aBis9wHVRGV+98p5OBzwDntVu41GCCwW7yWjkC+XgH5y33R7ZJHWobLU5Jrn7&#xd;&#xa;NeWb2c7KXjR3V96jqcrkDGR19ag03/kYtZ/7Yf8AoBqHSrcas/8Aat1I8kbSb7aByNsOOM/XIP50&#xd;&#xa;7WIjpkn9rQSyJGjhrmBSNs2flB6deR+ArcoooooooooooooorH8Kf8i9b/70n/oxq2KZL/qn/wB0&#xd;&#xa;1meFv+Ra07/rgtXr67jsbVp5ScAhQB3YnAH4kgVVs9TkluhbXtm9lM6lokd1feB945XIGMjr61DL&#xd;&#xa;rhVpZI7KSWxhZllug6gJtOH+U/McYPQc9qu3l/Fa2qTYLmUhYkHBkZvur7Z9TxUVjqT3Fwba6tXt&#xd;&#xa;LnZ5ixs4fcmcZyuR1OMdaz/DhxqOvH0vD/6CKl0OE3+3WLiWSTzSZLaJiMQKRjA469al1qxZka/t&#xd;&#xa;Z3t7mFQWZD/rEU5Kn8M49zV+zuBd2UFyqlRNGsgB7ZGanooooooooorH8K/8gGL/AK6zf+jXrYoo&#xd;&#xa;oooooooooooooooooooooooooooooooooooorH8J/wDIuWf0b/0I0y+aWx8QDUZLd2svsvlSSqQd&#xd;&#xa;h3k/dHzHt0HerlrfJqkc32dH8jbtWV1K7mOcjacHjjnHes+x1CPR7KHTLpJftUKCONVjZhLjgEMA&#xd;&#xa;QuT6kY71Wi0i5sJrPUXG/wCzmZ5Il+8BI2T9doPbrjirctxHrs9otlvMVtOs8krxsgGOi4YAknJ5&#xd;&#xa;HHFT6cjDxBrDFSFbycEjg/JTPDDrFpq2DsBdWrMs0eeVJO4fXgjpR4ndZdNawRgbq6ZVhjzyxBDH&#xd;&#xa;6cA9a2aKKKKKKKKKKKKKKx/Cn/IvW/8AvSf+jGrYpkv+qf8A3TWZ4W/5FrTv+uC03WkuE1DTb2G3&#xd;&#xa;aeO2aQy7WAKqVxnnr9BTZ7yLXrO6srESFJYXR5njZBGSMDhgCc89PSmWuqR6daQ6dNDKb2FFiSJU&#xd;&#xa;JEpAwpDAbRn3PGeaqW+kz6RLZX8n71LaKRJVQcqGcsW98A9Bye1XGmTXLyzezD+RaTec8roUydpG&#xd;&#xa;0BgD/FnPTimeH43W+13cjDfdkrkYz8vap/C7omjw2bMPtFovlTR55Rh1Hv16jirOs3MNvpk4mkCG&#xd;&#xa;VDGgPVmbgD8yKk0qGS30mzgmXbJHAiOuc4IUA1booooooooorH8K/wDIBi/66zf+jXrYoooooooo&#xd;&#xa;oooooooooooooooooooooooooooooorH8J/8i5Z/Rv8A0I1sUUUUUVTk0y1e7W6SPyZwwZpIvkaT&#xd;&#xa;HZiPvD2NKunWovGu3iEk+cq8g3GPjGFJ+6PYepq3RRRRRRRRRRRRRRWP4U/5F63/AN6T/wBGNWxT&#xd;&#xa;Jf8AVP8A7prM8Lf8i1p3/XBa1qKKKKKqDTrVbwXcUQimyS7Rjb5mRj58fe/GifTrW5uhPcRCZlAC&#xd;&#xa;LINyoQc5APQ+/sKt0UUUUUUUUUVj+Ff+QDF/11m/9GvWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRWLHpOo2iCDT9UjgtU/wBXG9rvK9/vbhnnNO+w65/0GoP/AABH/wAXR9h1z/oNQf8AgCP/&#xd;&#xa;AIuj7Drn/Qag/wDAEf8AxdH2HXP+g1B/4Aj/AOLo+w65/wBBqD/wBH/xdH2HXP8AoNQf+AI/+Lo+&#xd;&#xa;w65/0GoP/AEf/F0fYdc/6DUH/gCP/i6PsOuf9BqD/wAAR/8AF0fYdc/6DUH/AIAj/wCLo+w65/0G&#xd;&#xa;oP8AwBH/AMXR9h1z/oNQf+AI/wDi6PsOuf8AQag/8AR/8XR9h1z/AKDUH/gCP/i6PsOuf9BqD/wB&#xd;&#xa;H/xdH2HXP+g1B/4Aj/4uj7Drn/Qag/8AAEf/ABdH2HXP+g1B/wCAI/8Ai6PsOuf9BqD/AMAR/wDF&#xd;&#xa;0fYdc/6DUH/gCP8A4uj7Drn/AEGoP/AEf/F0fYdc/wCg1B/4Aj/4uj7Drn/Qag/8AR/8XV+ws47C&#xd;&#xa;zjtoslEzye5JJP6mrNMl/wBU/wDumszwt/yLWnf9cFq9NdxQXVvbuT5lwWCYHHyjJ/SrFFFFMklj&#xd;&#xa;iKCSREMjbUDMBuPXA9TwabPcQ20JmuJY4Yl6vIwVR+JqO3vorm3knhDvGhIDBciTAzlf7w9CKSz1&#xd;&#xa;C0vci3njeRQC8YYb4/Zl6g9sGrVFFFFFFFFFY/hX/kAxf9dZv/Rr1sUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUyX/VP/umszwt/yLWnf9cFqvr7TrrGj/ZU&#xd;&#xa;VpS8oG44AynX8OuO+KdJLqely2z3l7FeRTzpBsWDyiCxxuzk9PSo9R1Zv7Ums11S00z7OqndcBW8&#xd;&#xa;3cM8AkYxj369qt6FqRvluYmniuTbOE+0RY2y5AbIAzjGcdT0rLu9ZksFkuTr+n3giOfsiKqu/OMZ&#xd;&#xa;3Eg/h2qx4miu5L3Sfs90kIN0FUNFvw2xvm6jtkYpupW1xO1jpOp3K3UV5I/mMkXlnCruUdT3FdBF&#xd;&#xa;FHBEsUMaxxqMKiDAA9hWLLbQ6d4ltJbSNY21Aus+BgNtUsD9c9T3rdooooooooorH8K/8gGL/rrN&#xd;&#xa;/wCjXrYoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooopkv8A&#xd;&#xa;qn/3TWZ4W/5FrTv+uC1Ne2ks+rabcIB5du0hfJ5+ZMD9aNYtJbxbMQgHyruOVsnHyqeaoalYXkWo&#xd;&#xa;y3lhZ214blVEguCB5e0YGPrk/lVm1sLibSrmG6KW0l0pUpAABDxjggc+vPrWLf6drV1YyWY0nT0V&#xd;&#xa;gFEwkG7APXp14rf1i0muYoJrYBri1l86NGOFc4IwT26msy/bVVsodUnsla+spD5dtATIJFYBSeOe&#xd;&#xa;Mk/hW3a3sF1bGdG2qud4f5TGRyQw7EehrKt531bX0lEEsdrYgtDMUIWcspU4J4I7gjrW9RRRRRRR&#xd;&#xa;RRWP4V/5AMX/AF1m/wDRr1sUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUyX/VP/umuZ8PeItIttBsYJ7+FJUiCspPINaP/CU6H/0EoPzNH/CU6H/0EoPzNH/C&#xd;&#xa;U6H/ANBKD8zR/wAJTof/AEEoPzNH/CU6H/0EoPzNH/CU6H/0EoPzNH/CU6H/ANBKD8zTR4l0ABgN&#xd;&#xa;QtgGOWHr9eKVfE+hKoVdRtwoGAB0FL/wlOh/9BKD8zR/wlOh/wDQSg/M0f8ACU6H/wBBKD8zR/wl&#xd;&#xa;Oh/9BKD8zR/wlOh/9BKD8zR/wlOh/wDQSg/M0f8ACU6H/wBBKD8zR/wlOh/9BKD8zR/wlOh/9BKD&#xd;&#xa;8zR/wlOh/wDQSg/M0/w1FJDokKSqVYvI2D6GRiD+RFatFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFf/2Q==</binary>
<binary id="image12.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2Nj&#xd;&#xa;Y2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCAFIAqIDASIA&#xd;&#xa;AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA&#xd;&#xa;AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3&#xd;&#xa;ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm&#xd;&#xa;p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA&#xd;&#xa;AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx&#xd;&#xa;BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK&#xd;&#xa;U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3&#xd;&#xa;uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDsb/VU&#xd;&#xa;s5hAltcXUxXeY7dQWVckAnJHGQRVb+3Zf+gHqv8A36T/AOLoT/kcpv8AsHx/+jHrYoAx/wC3Zf8A&#xd;&#xa;oB6r/wB+k/8Ai6P7dl/6Aeq/9+k/+LrYooAx/wC3Zf8AoB6r/wB+k/8Ai6P7dl/6Aeq/9+k/+LrY&#xd;&#xa;ooAx/wC3Zf8AoB6r/wB+k/8Ai6P7dl/6Aeq/9+k/+LrYooAx/wC3Zf8AoB6r/wB+k/8Ai6P7dl/6&#xd;&#xa;Aeq/9+k/+LrYooAx/wC3Zf8AoB6r/wB+k/8Ai6P7dl/6Aeq/9+k/+LrYooAx/wC3Zf8AoB6r/wB+&#xd;&#xa;k/8Ai6P7dl/6Aeq/9+k/+LrYooAx/wC3Zf8AoB6r/wB+k/8Ai6P7dl/6Aeq/9+k/+LrYooAx/wC3&#xd;&#xa;Zf8AoB6r/wB+k/8Ai6P7dl/6Aeq/9+k/+LrYooAx/wC3Zf8AoB6r/wB+k/8Ai6P7dl/6Aeq/9+k/&#xd;&#xa;+LrYooA5+58Vw2bwrd6ZqMHnOEQyRoAT/wB9V0Fcf8Qf+YR/19j+ldhQAUUUUAFFFFABRRRQAUUU&#xd;&#xa;UAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAUdavm03SLm&#xd;&#xa;9RA7QpuCk8Gqu/xJ/wA8NK/7/Sf/ABNHi7/kV9R/65H+dbFAGPv8Sf8APDSv+/0n/wATRv8AEn/P&#xd;&#xa;DSv+/wBJ/wDE1sUUAY+/xJ/zw0r/AL/Sf/E0b/En/PDSv+/0n/xNbFFAGPv8Sf8APDSv+/0n/wAT&#xd;&#xa;Rv8AEn/PDSv+/wBJ/wDE1sUUAY+/xJ/zw0r/AL/Sf/E0b/En/PDSv+/0n/xNbFFAGPv8Sf8APDSv&#xd;&#xa;+/0n/wATRv8AEn/PDSv+/wBJ/wDE1sUUAY+/xJ/zw0r/AL/Sf/E0b/En/PDSv+/0n/xNbFFAGPv8&#xd;&#xa;Sf8APDSv+/0n/wATRv8AEn/PDSv+/wBJ/wDE1sUUAY+/xJ/zw0r/AL/Sf/E1W1HUNf02wmvJrbTW&#xd;&#xa;jhXcwSaQkj2ytdDWP4u/5FfUf+uR/nQBNoWt22vWb3VokqIkhjIlAByAD2J9a0q4/wCGP/IvXH/X&#xd;&#xa;23/oCV2FABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAGOn/I5Tf9g+P/0Y9bFY6f8AI5Tf9g+P/wBG&#xd;&#xa;PWxQAUVjeLXePw5dtGzKwXgqcEVyck+mLZWbaVdyPqbOuQJ3fuM5BOOme1C1YM9ForndJvN+t6jE&#xd;&#xa;0G2WJVLv5jEMfm7HgdO1M03WtY1ZZXs7OzVYnKEzSsM4J6YB9KFqB0tFcld67f39pfmytovssAKP&#xd;&#xa;IXIYtx93H1Hp3rN0q8uL+DSdLMz+XKpec7vmYALxnqOp6ULXYHod/RWXYaKmnXjTWtxMIWXBhdi4&#xd;&#xa;zxzliT2/WqEmv3s8t02mWsUtvanEjSsQxI5O0DOeCOuKLoDo6K5DUfGhgGmtaWyyrecEMcFT8vH/&#xd;&#xa;AI9VuPXtQGqf2fcWtskskXmQlXYgnjg5HHWgDpKK4bRte1K28N3Wo3CRXGJgBliGJOwdMYA5rXl1&#xd;&#xa;2+tLGO5u7a3Budotkjckkt03ZAx1HTPegDoqK5TUdaulgvNO1CKOC78rzI2gclWGexODng9qrvPL&#xd;&#xa;/wAIO8nmvv8AsqHduOc7D3o6N9g6pdzs6K559ZOnaJY7UM1zOAkak8E4J5PpxSx69cw3NxZ6hbxJ&#xd;&#xa;dRxGVPKYlGHPc4PY9qHpcFqkzoKKw9B1TUtWhjuntraK1cc/O2/PsMYx+NblNqwHH/EH/mEf9fY/&#xd;&#xa;pXYVx/xB/wCYR/19j+ldhSAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKA&#xd;&#xa;CiiigAooooAKKKKACiiigAooooAKKKKAMfxd/wAivqP/AFyP862Kx/F3/Ir6j/1yP862KACiiigA&#xd;&#xa;ooooAQkAZJwKojW9JJwNUss+n2hP8at3H+of6V53pM6DwnNENJnmkJ4uBEuxen8Wc/pSvv5Dtseh&#xd;&#xa;SXVvDGJJZ4kjI3BmcAEeufSpEdZEDxsGU8hlOQa4+e8ltPCNm1vOkrC1bLFA4yEHqKn1jVb+00PT&#xd;&#xa;ZbSZY5ZpFVjsXBG1j0xx0HSn9prs0vvF0T7q51R4GTUUNzb3BcQTxylDtbY4bafQ46Vy0c2tT63P&#xd;&#xa;pqau2yCPe7tBGCeowBjpwPzp/gZXV9VWU5cXJ3H1O5s0LX7v1B6f15XOsooooAKKKKACsfxd/wAi&#xd;&#xa;vqP/AFyP862Kx/F3/Ir6j/1yP86AMf4Y/wDIvXH/AF9t/wCgJXYVx/wx/wCReuP+vtv/AEBK7CgA&#xd;&#xa;ooooAKKKKACiiigAooooAKKKKACiiigDHT/kcpv+wfH/AOjHrYrHT/kcpv8AsHx/+jHrYoAyvEtp&#xd;&#xa;PfaHc29snmSuuFXIGfzrEvLbVr/RI9MOjPC2VBmeaMhcMDnAbPauwooQHM6HpF5Y6pfPNH+6eJES&#xd;&#xa;TcPnIDA8fiKs+FdPutPtJ0u4vLZ5WYDcDkEn0rdooQHHR6bq+mRajY2tmbiG5YvHN5igKSAMEEg9&#xd;&#xa;v1plnoWo2Vppl3Hb7ru14kg3rllO3ODnGeD3rtKKFp/XYHqZVjdavc3p+0WKWlqF6SMGcnjurEet&#xd;&#xa;ZEWn6ppP260s7I3UF0xZJA6gJkAHIJBPA7etdZRSauBwF/4U1GNtGS2h89bd90zb1AU5TPUj0NbV&#xd;&#xa;xpd4/imzvFhzbxw7WfcODx2zntXS0U/+D+IHCwaNqyeG7nS2sG8wzLIj+amGG5M9/wDZNbWraRcX&#xd;&#xa;WlaeYVH2qy2OEJHzFcErnp2roKKP6+4Ot/61OQvtJ1HV7qfUJrQ2zpD5UMBdSW5PJIJH8R/Kpm0m&#xd;&#xa;+PhFrIQf6SbdE2bl+8FIIznHWupoo6NB1T7HKazoFze6LYqsKyT2uC0DkYfg8Zz7+tNtNGk33EkW&#xd;&#xa;hwWA8orHlw0hYgjqGIxz/Outooet/MFpbyMnwxZz2GiQW91H5cqjlcg449q1qKKbd3cSVjj/AIg/&#xd;&#xa;8wj/AK+x/Suwrj/iD/zCP+vsf0rsKQwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACii&#xd;&#xa;igAooooAKKKKACiiigAooooAKKKKACiiigAooooAx/F3/Ir6j/1yP862Kx/F3/Ir6j/1yP8AOrP9&#xd;&#xa;t6T/ANBSy/8AAhP8aAL9FUP7b0n/AKCll/4EJ/jR/bek/wDQUsv/AAIT/GgC/RVD+29J/wCgpZf+&#xd;&#xa;BCf40f23pP8A0FLL/wACE/xoAuSLvjZRxkVzFhoet6fpb6fDdWBhfOWaN93IA9cdvStv+29J/wCg&#xd;&#xa;pZf+BCf40f23pP8A0FLL/wACE/xpW3Ay5vDB/sKLToJwCsTKzvzlmAGeO3FSajoE15ptjarMitbO&#xd;&#xa;GYkHBwCOPzrQ/tvSf+gpZf8AgQn+NH9t6T/0FLL/AMCE/wAafW/zB6qxQvdEuhrB1HTZ4o5JE2SL&#xd;&#xa;MCQevIx35/SpPDmjTaQLszzJK1xJvyoIxyT/AFq3/bek/wDQUsv/AAIT/Gj+29J/6Cll/wCBCf40&#xd;&#xa;LQHqX6Kof23pP/QUsv8AwIT/ABo/tvSf+gpZf+BCf40AX6Kof23pP/QUsv8AwIT/ABo/tvSf+gpZ&#xd;&#xa;f+BCf40AX6x/F3/Ir6j/ANcj/OrP9t6T/wBBSy/8CE/xrK8Uatps/hu/ih1C0kkaIhVSZST9BmgC&#xd;&#xa;n8Mf+ReuP+vtv/QErsK4/wCGP/IvXH/X23/oCV2FABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAHOX&#xd;&#xa;mnW+o+L5EuRIQlghGyVk/wCWj/3SKt/8Ixpn925/8C5f/iqE/wCRym/7B8f/AKMetigDH/4RjTP7&#xd;&#xa;tz/4Fy//ABVH/CMaZ/duf/AuX/4qtiigDH/4RjTP7tz/AOBcv/xVH/CMaZ/duf8AwLl/+KrYooAx&#xd;&#xa;/wDhGNM/u3P/AIFy/wDxVH/CMaZ/duf/AALl/wDiq2KKAMf/AIRjTP7tz/4Fy/8AxVH/AAjGmf3b&#xd;&#xa;n/wLl/8Aiq2KKAMf/hGNM/u3P/gXL/8AFUf8Ixpn925/8C5f/iq2KKAMf/hGNM/u3P8A4Fy//FUf&#xd;&#xa;8Ixpn925/wDAuX/4qtiigDH/AOEY0z+7c/8AgXL/APFUf8Ixpn925/8AAuX/AOKrYooAx/8AhGNM&#xd;&#xa;/u3P/gXL/wDFUf8ACMaZ/duf/AuX/wCKrYooAx/+EY0z+7c/+Bcv/wAVR/wjGmf3bn/wLl/+KrYo&#xd;&#xa;oA4HxlpVppraXJbiUFrkBjJM7jHH94nFdv8AbLX/AJ+Yf++xXJ/EaNZotLifO17nacehqz/wr/Q/&#xd;&#xa;7tx/39/+tQB0f2y1/wCfmH/vsUfbLX/n5h/77Fc5/wAK/wBD/u3H/f3/AOtR/wAK/wBD/u3H/f3/&#xd;&#xa;AOtQB0f2y1/5+Yf++xR9stf+fmH/AL7Fc5/wr/Q/7tx/39/+tR/wr/Q/7tx/39/+tQB0f2y1/wCf&#xd;&#xa;mH/vsUfbLX/n5h/77Fc5/wAK/wBD/u3H/f3/AOtR/wAK/wBD/u3H/f3/AOtQB0f2y1/5+Yf++xR9&#xd;&#xa;stf+fmH/AL7Fc5/wr/Q/7tx/39/+tR/wr/Q/7tx/39/+tQB0f2y1/wCfmH/vsUfbLX/n5h/77Fc5&#xd;&#xa;/wAK/wBD/u3H/f3/AOtR/wAK/wBD/u3H/f3/AOtQB0f2y1/5+Yf++xR9stf+fmH/AL7Fc5/wr/Q/&#xd;&#xa;7tx/39/+tR/wr/Q/7tx/39/+tQB0f2y1/wCfmH/vsUfbLX/n5h/77Fc5/wAK/wBD/u3H/f3/AOtR&#xd;&#xa;/wAK/wBD/u3H/f3/AOtQB0f2y1/5+Yf++xR9stf+fmH/AL7Fc5/wr/Q/7tx/39/+tR/wr/Q/7tx/&#xd;&#xa;39/+tQB0f2y1/wCfmH/vsUfbLX/n5h/77Fc5/wAK/wBD/u3H/f3/AOtR/wAK/wBD/u3H/f3/AOtQ&#xd;&#xa;B0f2y1/5+Yf++xR9stf+fmH/AL7Fc5/wr/Q/7tx/39/+tR/wr/Q/7tx/39/+tQB0f2y1/wCfmH/v&#xd;&#xa;sUfbLX/n5h/77Fc5/wAK/wBD/u3H/f3/AOtR/wAK/wBD/u3H/f3/AOtQB0f2y1/5+Yf++xR9stf+&#xd;&#xa;fmH/AL7Fc5/wr/Q/7tx/39/+tR/wr/Q/7tx/39/+tQB0f2y1/wCfmH/vsUfbLX/n5h/77Fc5/wAK&#xd;&#xa;/wBD/u3H/f3/AOtR/wAK/wBD/u3H/f3/AOtQB0f2y1/5+Yf++xR9stf+fmH/AL7Fc5/wr/Q/7tx/&#xd;&#xa;39/+tR/wr/Q/7tx/39/+tQB0f2y1/wCfmH/vsUfbLX/n5h/77Fc5/wAK/wBD/u3H/f3/AOtR/wAK&#xd;&#xa;/wBD/u3H/f3/AOtQB0f2y1/5+Yf++xR9stf+fmH/AL7Fc5/wr/Q/7tx/39/+tR/wr/Q/7tx/39/+&#xd;&#xa;tQBc8V3Vu/hnUFSeJmMRwA4JPNan9nWP/Pnb/wDfpf8ACuP1/wAF6Rp+iXd3AJ/Nij3LukyM/lXd&#xd;&#xa;UAVf7Osf+fO3/wC/S/4Uf2dY/wDPnb/9+l/wq1RQBV/s6x/587f/AL9L/hR/Z1j/AM+dv/36X/Cr&#xd;&#xa;VFAFX+zrH/nzt/8Av0v+FH9nWP8Az52//fpf8KtUUAVf7Osf+fO3/wC/S/4Uf2dY/wDPnb/9+l/w&#xd;&#xa;q1RQBV/s6x/587f/AL9L/hR/Z1j/AM+dv/36X/CrVFAFX+zrH/nzt/8Av0v+FH9nWP8Az52//fpf&#xd;&#xa;8KtUUAVf7Osf+fO3/wC/S/4Uf2dY/wDPnb/9+l/wq1RQBV/s6x/587f/AL9L/hWT4qsbSPw1fvHa&#xd;&#xa;wKwiOGWMAjmugrH8Xf8AIr6j/wBcj/OgDH+GP/IvXH/X23/oCV2Fcf8ADH/kXrj/AK+2/wDQErsK&#xd;&#xa;ACiiigAooooAKKKKACiiigAooooAKKKKAMdP+Rym/wCwfH/6MerOrarb6RbC4uVkKFgvyAE5P1NV&#xd;&#xa;k/5HKb/sHx/+jHqr41Rn02AIpY/aE4Az3FJjRZfxHbRWhuJ7W7hUkBBIgBkJGfl55qC58RJLY3gg&#xd;&#xa;Se1u4E3BJ0Abr1xk+9U/FtpPJY6fcxCQJbsrSGLG5RtPIzWbNb29293dW1xqN48cO3zpgqqeT8uN&#xd;&#xa;oPfP40PZ/MFuvkdJY6ysXhy2v9QkLO8Sk7QAXYgHAHAyTUtjr9teXLW7RT20qpv23ChSV45GCfUV&#xd;&#xa;z89nO/hjRp0jZhaeXJKnfaNpPH4Gm6jC/ibU4n05WEUEG1pHUqN2Rxg4P/6q0STnZ9/0M22oX8jp&#xd;&#xa;NQ1u3sLlLbyp7idhu8qBQzAc8nJHoarDxRZPHGYormWZ2K+QiAyAjGcjPvVC7f8Asjxa19do4tZ4&#xd;&#xa;dokVS2CNxxgZPp+dUtT1eS/vbYzQ3NtpDMyuwXPnDI6gAkDHsDzWa2Ro+p0llrkF9BO8MFwJIOHg&#xd;&#xa;ZQJPyzWNo3i8TWMk19BP5jS7YkjQfNwPlXkZI5P0qPwVGiXupCGB4YWYGNWBHGBXN2cMkcduzG4h&#xd;&#xa;NtMTKYk+ZAVABGQQeTjjNPr62F0fkeh6drVtqDyxqksE0RAaKZQrDOccAn0NVU1C6u/E09jBJ5dv&#xd;&#xa;bRZc7QdznaR+hNZWkWNveas93BNqNzseMmaXYobBPbaDirGhgw+L9WhfO5lVwT3G1P8AGnbb0Yr7&#xd;&#xa;/Iv+GNSn1CxkW8ObqCQxyHAGTgHPH1rarl/B677nVLhSTG9wQvv8q11FLdJ+Q+rXmFFFFABRRRQA&#xd;&#xa;UUUUAcf8Qf8AmEf9fY/pXYVx/wAQf+YR/wBfY/pXYUAFFFFABRRRQAUU2QsI2KjLAHGfWsZ9ZmGj&#xd;&#xa;yXKpH9pWQwhMHbvzgDr60m7DsbdFYh1qY6Jb3SJGbiZzGEIO3cN3v/s1W1PxI+neJILCVYltXj3v&#xd;&#xa;IVYsPvdMfQdqq2thLVXOkoqnZapZX8UkttNuSP75Kldv4ED0qG217Tbq5+zw3BaXsDGwB/EjFIDS&#xd;&#xa;orF0LXU1aa7jBXMMhCYRhlMDk575zTtU1pdM1O1hmKrbyq5dtpLAjGMY+vpR2Dv5GxRVHT9YsNSd&#xd;&#xa;ltJ/MZRkgoyn9QKi/wCEg0v7T9n+0/vM4/1bYz/vYx+tAGnRWWfEOlrOIDdfvC/l48tsBs4wTjA5&#xd;&#xa;qW81iwsXCXM+xiu4AIzZH4CgC/RVE6vYLp/243A+z/39pz6dMZ7+lJY6xYagXFrPvKDJBRl4/EDP&#xd;&#xa;TtQBforK/wCEj0nzBH9r+Ykj/VvjP1xin3Ovaba3BgmuSsg4IEbMB+IGKANKikDBlDA5B5BqtFqF&#xd;&#xa;rNaNdRygwr1bBGKALVFZGqa9bWeinUIZUYOhMO5Ww5xke/pS6d4gsL4xRLOPtDqCV8tgM+xIx+tA&#xd;&#xa;GtRWfd61p9lcrb3FxtlYA4CM3U45IGBTbnXtMtJCk1zhlAJCozcHp0FAGlRUVvcRXUCzQOHjfkH1&#xd;&#xa;qWgAooooAKKKKAMfxd/yK+o/9cj/ADqTxDqr6PpjXccQlYMo2k46sB/Wo/F3/Ir6j/1yP86Z4ssb&#xd;&#xa;nUNHaC0i8yQuh25A4DAnr9KTGiifEeprd2tu9hBuvE3Q4kbjpjdxx1GcZrS0LWJNSa5huYUiuLdt&#xd;&#xa;rqjZU9+CfwqhNpd42r6LMISY7aLbK24fKcJ7+xqfQdPurTVtSmniKRzODG2Qd3A9PpVL/P8APQl7&#xd;&#xa;fd/wRkviC8nluW020imt7U4kaRyrE99oAOeCPSn2fiRbq8tUEQWC5iLq5PIYAEg/nVKKw1PSft1p&#xd;&#xa;aWRuobpi6SB1ATIAOckHoO3rTbvw7d2/h60hswJbyA5xkAc43enpUrb7invY0IfEa/2TcajcxbIY&#xd;&#xa;3KoEOS2CR3+lRxa/eQXVrHqlpDDHcg7GictggE4OQPSnXWgvceFhpqkRy43c9NxJJ/mazNP0R3nt&#xd;&#xa;lfw9DbbQfNmkk3c4P3cMfbrT6i6XL2htJqmp6pcTSN5aTeVGoYgAKWHb14qTwxcyrc3+nTSGQ20m&#xd;&#xa;VYnJw3zf+zVD4UH2S91e1lAQrcFlyeoZmx/Kl8MxedrOq34UhJHCIfXAAP6rTXRdLf5CfXvf/M6a&#xd;&#xa;iiikMKKKKACiiigArH8Xf8ivqP8A1yP862Kx/F3/ACK+o/8AXI/zoAx/hj/yL1x/19t/6AldhXH/&#xd;&#xa;AAx/5F64/wCvtv8A0BK7CgAooooAKKKKACiiigAooooAKKKKACiiigDHT/kcpv8AsHx/+jHrYrHT&#xd;&#xa;/kcpv+wfH/6MetigAooooAKKKKACiiigAooooAKpyabBJfi9y6TBChKNjIyDz+Qq5RQBV0+xg060&#xd;&#xa;W2twQi92OSfcmrVFFABRRRQAUUUUAFFFFAHH/EH/AJhH/X2P6V2Fcf8AEH/mEf8AX2P6V2FABRRR&#xd;&#xa;QAUUUUAJXLKpHiBtNwdhn+1/+Pbq6qmeVH5vm+WnmYxvwM/nQt7h0sczbRlvEH9m4Pl2sn2hQRkc&#xd;&#xa;j/7OqmpoknxG08OoYeSeCPaSuxEUYkMgRRIRgtjkj60hghaYTGKMygYDlRuH4046WB9fM50SrBq2&#xd;&#xa;vu8PnosCMYsff4fj8az5715rjS2N7ZtCLhSLaFRui+VupB/oOtdn5Ue5m8tdzjDHHLfWolsLNG3L&#xd;&#xa;aQK3XIjANJaWB63Mnw46Ld6pEWUSfambYTzjavOPTijUkV/FWl71DYSUjI6H5K2lhiSRpFiRZG6s&#xd;&#xa;FAJ/GlMaM6uUUuvRiORR28g7+ZgJhPFiYHH2R8gd/nWsTUb9rnRh5U9lbQl0/wBAVAZF+de+Rj8u&#xd;&#xa;1d15UfmeZsXfjG7HOPrULafZklvskG8/xeWM/wAqmKtFLsU3d3OQsruxOiavblo/tM0syxocbnYl&#xd;&#xa;tuB35P61bEsFl4hsDfsiYsiAz8BWyvc9K1tI0ZLRZjcwwPI1w8sbBQSoLZHJHBpZ9KM+vLeSpFJb&#xd;&#xa;iAxlXGTksp6Yx2NX1X9dCLaNf1ucrdJIX+2QskVibx3Ejxb4wDGADjI4J4+tadkTc6haOdVtrkxw&#xd;&#xa;ttS2t9u0EDhiGOOnQ+9dQbeEw+SYY/K/ubRt/KkhtLaAkw28UZPUogGfypdLDerucgURfAdyyqAx&#xd;&#xa;eUkgdf3jVNNLHbtdmz1K2hDuWltbqIFpHwPu5YcEYHQ9DXVeRD5Ri8qPyz1TaMflTHsrSSTzJLWF&#xd;&#xa;n/vNGCfzoYDrRt9pE2zy8oPkxjbx0rkL+6NreXGhKpL3kwljwOAnGRj/AIAa7So2t4WlErQxmQcB&#xd;&#xa;yoyPxo3d2C2scHdwuYb3TyCYtPjnbpxgj5P/AEE1s3iLHbaAI1Cjz04Ax/A1dIYISXJijJkGH+Uf&#xd;&#xa;MPf1pTFGwUGNCEOVyo+X6ULzD08zjG8+C+1SObUbaz82QttuINzSKQBlSWGeQeParHhq3RL69BPm&#xd;&#xa;lbWAK7JtONrdj0+ldRLaW07h5reKRhwGdASKesUaMWWNFLAAkKBkClbS3kDMbwmT/ZEfP8cv/oxq&#xd;&#xa;3KYkaRrtjRUHooxT6pu4krXCiiikMKKKKAMfxd/yK+o/9cj/ADrYrH8Xf8ivqP8A1yP862KACiii&#xd;&#xa;gAooooAKKKKAIGs7ZpmmaCMyNjLlRk46c0+CCK2jEcESRoCTtQYHJyf1qSigAooooAKKKKACiiig&#xd;&#xa;ArH8Xf8AIr6j/wBcj/Otisfxd/yK+o/9cj/OgDH+GP8AyL1x/wBfbf8AoCV2Fcf8Mf8AkXrj/r7b&#xd;&#xa;/wBASuwoAKKKKACiiigAooooAKKKKACiiigAooooAx0/5HKb/sHx/wDox62K53XbPWo9UXUNE8h3&#xd;&#xa;eEQSRyjoAxbOc+9UfO8c/wDPvY/mP8aAOworj/O8c/8APvY/mP8AGjzvHP8Az72P5j/GgDsKK4/z&#xd;&#xa;vHP/AD72P5j/ABo87xz/AM+9j+Y/xoA7CiuP87xz/wA+9j+Y/wAaPO8c/wDPvY/mP8aAOworj/O8&#xd;&#xa;c/8APvY/mP8AGjzvHP8Az72P5j/GgDsKK4/zvHP/AD72P5j/ABo87xz/AM+9j+Y/xoA7CiuP87xz&#xd;&#xa;/wA+9j+Y/wAaPO8c/wDPvY/mP8aAOworj/O8c/8APvY/mP8AGjzvHP8Az72P5j/GgDsKK4/zvHP/&#xd;&#xa;AD72P5j/ABo87xz/AM+9j+Y/xoA7CiuP87xz/wA+9j+Y/wAaPO8c/wDPvY/mP8aAD4g/8wj/AK+x&#xd;&#xa;/SuwrgtQ0zxZq81p/aFvaiOCYSfu3APXnvXe0AFFFFABRRRQAUUUUAIxCgknAFZTeJdIXbm74cZB&#xd;&#xa;ETkfnitKf/Uv9K53Ro0XwOu1QN0JJwOppN7vsO23makeu6bLdLbR3IMrHCjY2D+OMUsuuabDeG0k&#xd;&#xa;uQJgQCNjEDIz1xj9awZI1j8N6D5ahSZbc8DuStRNLAnhq8sZipv2Z8xf8tGJYlcDqflIpvqJdDqh&#xd;&#xa;qNobJbzzh9nbGHwe5wOOvU1BNrmnQXS20lziViABsYjnpk4wK521jlF7HoTq2xZDKfTZj5f/AB5a&#xd;&#xa;r4mjGrW82o2tqJJpN0UsG6R1JbG35hn2wO9AI67U74WNn5yrvdjtjX+8euP0qKxvrhrySyvljWdV&#xd;&#xa;8xTGDtZDx375BrNvYmhTSS8peIXCcspGPkb8quXHzeKbUL1WElsenzAfrTtZ/wBdhJ3V/wCty5qF&#xd;&#xa;2bUQESRJ5kqp+8DHOTjAx3+vFQ3mu6bYzeTc3GyQDJAjZsfkDVXxP9zT/wDr9i/9DFUruSODUbt7&#xd;&#xa;TVLazkfb50V1HncdowVyw7YqblWOmjkWVA8bBlPQjvVW/wBWsdNKC7n8svnACM3T6A+tN0STztJt&#xd;&#xa;3+zi2yv+qC42/hWcJoLLxFfPfukSSxoInlYAMBu3AZ+opvR2EtVc1pNRtIrIXjzAQHkPgnP4dazb&#xd;&#xa;zxHb/YHuNPkWZkdFKujLjLAdDj1qO/vbOLS7aS2tI/KefEbSJtSI/N8/P0P51zeqTySahMZr23u2&#xd;&#xa;McIWS3Xav+uzjqeaFvYa2OxsNSe4vr+GUIiWzKFYd8qDz+dJbeIdKup0ghut0j/dBjcA/iRisG7i&#xd;&#xa;mmj8RR26s0hMeAvU/ItRzSG6so4m1rT3U7NscNtmThgQAA+Rz7Uk9vkI39W8QWenx3CCZTdRxsyo&#xd;&#xa;UYgnBwCQMdfeoW1W/ufssFhDD58sfmu8oby1HTHBznkVkie1ttE1q1vWUXJMx2yHDPndtIB6/wD1&#xd;&#xa;624ppoPDMclt5YlEQ2eYwVR9SafT7g/4JNpF/PdGeG8jRLiB9reX908DkZPvWlVLTLBLC3Kh3kkc&#xd;&#xa;7nkc5Zj9fwq7TYkFFFFIYUUUUAFFFFAGP4u/5FfUf+uR/nWxVLWLE6npVzZCTyzMm3fjOPwrnP8A&#xd;&#xa;hFNd/wChpuvyb/4qgDsKK4//AIRTXf8Aoabr8m/+Ko/4RTXf+hpuvyb/AOKoA7CiuP8A+EU13/oa&#xd;&#xa;br8m/wDiqP8AhFNd/wChpuvyb/4qgDsKK4//AIRTXf8Aoabr8m/+Ko/4RTXf+hpuvyb/AOKoA7Ci&#xd;&#xa;uP8A+EU13/oabr8m/wDiq5y7/tu08QnTJdeu1hWRY2u2dgillDc84/XtQB6nRXH/APCKa7/0NN1+&#xd;&#xa;Tf8AxVH/AAimu/8AQ03X5N/8VQB2FFcf/wAIprv/AENN1+Tf/FUf8Iprv/Q03X5N/wDFUAdhRXH/&#xd;&#xa;APCKa7/0NN1+Tf8AxVH/AAimu/8AQ03X5N/8VQB2FY/i7/kV9R/65H+dY/8Awimu/wDQ03X5N/8A&#xd;&#xa;FVHP4O1m4haGfxNPJG4wyMrEEfTdQBJ8Mf8AkXrj/r7b/wBASuwrG8L6EfD+nSWjXAnLzGTcE24y&#xd;&#xa;AMdT6Vs0AFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFF&#xd;&#xa;FABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAhGRg01Yo0i8pY0WPGNgUY/Kn0UARmCEoiGJN&#xd;&#xa;qY2rtGFx0x6Uw2ls03nG3iMv98oN351PRQAzyo/N83y18zGN2Ocemajks7WWUSy20LyDo7ICR+NT&#xd;&#xa;0UAVr6zjvrRreThT0I6r9KisNPNtLJPNObieTjzCoXC+mB75/Or1FADHjSTHmIrbTkbhnB9ailsr&#xd;&#xa;Sd981rDI3954wT+tWKKAEAAGAMCop7W3ucfaIIpdvTegbH51NRQBE8EMkXlPFG0f9wqCPyqNbCzU&#xd;&#xa;YW0gH0jH+FWaKAGLFGjMyoqs33iBgn61Cmn2Ubh0s7dXHRliUEfpVmigCCWztZn3y20Mj4xuZATU&#xd;&#xa;hhjaPy2jQx9NpUY/Kn0UAJS0UUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAEN3cpZ2c91KC&#xd;&#xa;Y4Y2kbaOcAZOPyrmL/RWu/BckcsRuLslriMoSWZizbc+uFbGDVnxA19e6rZWOnlpLdXA1GMYA8py&#xd;&#xa;MZz6gP0rokRY41RBhVAAHoKAMvwxqR1XQ7e5kmWWbG2UrgYb0wOnBFa1cf4f/wCJN4rvtIb/AEe2&#xd;&#xa;uP31pD1DepB+inr6V2FABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUU&#xd;&#xa;UUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRR&#xd;&#xa;QAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFA&#xd;&#xa;BRRRQAUUUUAY1xpmorqtze2F7BCLhEVklgL/AHc453D1Nc9N4h12HxSND+0WhYuq+d5Bxyobpu9/&#xd;&#xa;Wu6rze+/5Kuv/XWP/wBFrQB0sXh++fxJa6xfX8Mr28ZjCRwFMghh/eP96ujoooAKKKKACiiigAoo&#xd;&#xa;ooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiii&#xd;&#xa;gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKA&#xd;&#xa;CiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArze+/5Kuv/AF1j/wDRa16R&#xd;&#xa;Xm99/wAlXX/rrH/6LWgD0iiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAo&#xd;&#xa;oooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACii&#xd;&#xa;igAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKK&#xd;&#xa;ACiiigAooooAKKKKACvN77/kq6/9dY//AEWtekV5vff8lXX/AK6x/wDotaAPSKKKKACiiigAoooo&#xd;&#xa;AKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigA&#xd;&#xa;ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACi&#xd;&#xa;iigAooooAKKKKACiiigAooooAKKKKACiiigDi5fHFzNqk9ppekSXgi7hiGwMAnAB4ycVJ/wlOv8A&#xd;&#xa;/Qr3H5t/8TWP4B/5HLUf+uUv/oxa9IoA4/8A4SnX/wDoV7j82/8AiaP+Ep1//oV7j82/+JrsKKAO&#xd;&#xa;P/4SnX/+hXuPzb/4mj/hKdf/AOhXuPzb/wCJrsKKAOP/AOEp1/8A6Fe4/Nv/AImj/hKdf/6Fe4/N&#xd;&#xa;v/ia7CigDj/+Ep1//oV7j82/+JrnZl1ybxSNc/sK6DB1bytrY4UL1x7V6lRQBx//AAlOv/8AQr3H&#xd;&#xa;5t/8TR/wlOv/APQr3H5t/wDE12FFAHH/APCU6/8A9Cvcfm3/AMTR/wAJTr//AEK9x+bf/E12FFAH&#xd;&#xa;H/8ACU6//wBCvcfm3/xNH/CU6/8A9Cvcfm3/AMTXYUUAcf8A8JTr/wD0K9x+bf8AxNH/AAlOv/8A&#xd;&#xa;Qr3H5t/8TXYUUAcf/wAJTr//AEK9x+bf/E0f8JTr/wD0K9x+bf8AxNdhRQBwl5481GwdVvNCaBmG&#xd;&#xa;VEkhXI/75ru683+KP/IRsf8Ark3869IoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigA&#xd;&#xa;ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACi&#xd;&#xa;iigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDzfwD/wAjlqP/AFyl/wDRi16R&#xd;&#xa;Xm/gH/kctR/65S/+jFr0igAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDzf4o/&#xd;&#xa;8hGx/wCuTfzr0ivN/ij/AMhGx/65N/OvSKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo&#xd;&#xa;oAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiig&#xd;&#xa;AooooAKKKKACiiigAooooAKKKKACiis+/wBZs9OnSC4aXzXUuqxxM5wDjPyg0AaFFY//AAk2n/3b&#xd;&#xa;z/wEl/8AiaP+Em0/+7ef+Akv/wATQBsUVj/8JNp/928/8BJf/iaP+Em0/wDu3n/gJL/8TQBsUVj/&#xd;&#xa;APCTaf8A3bz/AMBJf/iaP+Em0/8Au3n/AICS/wDxNAGxRWP/AMJNp/8AdvP/AAEl/wDiaP8AhJtP&#xd;&#xa;/u3n/gJL/wDE0Acf4B/5HLUf+uUv/oxa9IrzLwlM2meJb28u7a6SCWN1RhbuckupHAHoDXa/8JNp&#xd;&#xa;/wDdvP8AwEl/+JoA2KKx/wDhJtP/ALt5/wCAkv8A8TR/wk2n/wB28/8AASX/AOJoA2KKx/8AhJtP&#xd;&#xa;/u3n/gJL/wDE0f8ACTaf/dvP/ASX/wCJoA2KKx/+Em0/+7ef+Akv/wATR/wk2n/3bz/wEl/+JoA2&#xd;&#xa;KKx/+Em0/wDu3n/gJL/8TVnStYstXSV7GVnETbXyhXB/EUAX6KKiuZ47W2luJm2xRIXc4zgAZNAE&#xd;&#xa;tFYw8T6cwBAuyDyCLSXn/wAdpf8AhJtP/u3n/gJL/wDE0AbFFY//AAk2n/3bz/wEl/8AiaP+Em0/&#xd;&#xa;+7ef+Akv/wATQBsUVj/8JNp/928/8BJf/iaP+Em0/wDu3n/gJL/8TQBsUVj/APCTaf8A3bz/AMBJ&#xd;&#xa;f/iaP+Em0/8Au3n/AICS/wDxNAHH/FH/AJCNj/1yb+dekV5l47mbWby1ksLa6kWOMqxNu64OfcV2&#xd;&#xa;v/CTaf8A3bz/AMBJf/iaANiisf8A4SbT/wC7ef8AgJL/APE0f8JNp/8AdvP/AAEl/wDiaANiisf/&#xd;&#xa;AISbT/7t5/4CS/8AxNH/AAk2n/3bz/wEl/8AiaANiisf/hJtP/u3n/gJL/8AE0f8JNp/928/8BJf&#xd;&#xa;/iaANiisf/hJtP8A7t5/4CS//E0Q+JtMmvIbQSTJPMcIskDpu/MUAbFFFFABRRRQAUUUUAFFFFAB&#xd;&#xa;RRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFF&#xd;&#xa;FFABRRRQAUUUUAFFFFABRRRQAVjv/wAjlD/2D5P/AEYlbFY7/wDI5Q/9g+T/ANGJQBsUUUUAFFFF&#xd;&#xa;ABRTJpUgieWVgqICzE9gKoWmvaXe3HkW14kkpGdoBH8xQBpUUUUAFFFFABRRRQAUUUUAFFFFABXH&#xd;&#xa;/D7/AJi//X2f612Fcf8AD7/mL/8AX2f60AdhWf4g/wCRe1P/AK9Jf/QDWhWf4g/5F7U/+vSX/wBA&#xd;&#xa;NAFjT/8AkHW3/XJf5CrFV9P/AOQdbf8AXJP5CrFABRRSUALRWOvijRGYKuoRkk4HDdfyrWVg6hlO&#xd;&#xa;QRkGgB1FFFABRRRQAUUVXuL23tZI0nlCNKdqAg8mgCxRRRQAUUUUAFcf4j/5HnQPx/nXYVx/iP8A&#xd;&#xa;5HnQPx/nQB2FFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAF&#xd;&#xa;FFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVjv/yOUP8A2D5P/RiV&#xd;&#xa;sVjv/wAjlD/2D5P/AEYlAGxRRRQAUUUUAc14xcltLtTzFPdKsg9RuXj9TVm9vtEhvbe2vY/38RAi&#xd;&#xa;LQsQDjIw2MdKsa9pR1S0URuEuIWEkLY6MOQPzArJu9M1rVbqxF3FBbwW7BmZZd5YgEZxgetEd/mE&#xd;&#xa;tvkSX9xd6h4j/s23uZoIYod7tA21t3zcEntwKZo19d2WpXmn39w8vlxCVGlO5uhJ5HHpVm90y+tt&#xd;&#xa;aOp6YkcrSx7JIpH2DvznB9fTtSado11LfXF/qmxZ5Y/KEcZyAuCDzx6+lSr/AIP7+g3b8jGe71S4&#xd;&#xa;0a51uO8nVkkOyJXxEVBK9OvYd6n1DVpbzWLSA301nazW5dJIm8sM3z8EnjsKm/sTVotOm0eEQmzk&#xd;&#xa;Y4uC/wAyqSSRsx6n17VavtIu4xBFbW1pfWsabPJuFAKnnkMQfUVX9fgL+vxMddU1Iy2Wm3d8sSu7&#xd;&#xa;b7iOZd+wEYO7JGcE1r+GdRll1C90+W6NysBBjkZtzMCAeSOD1rKh8HXVuYrtY7eaVZWdrSTBjCkg&#xd;&#xa;4BI/DpXQaHp89tJNNcWtnal+Fit41+Ue7ADPT0przE/I2aKKKQwooooAK4/4ff8AMX/6+z/Wuwrj&#xd;&#xa;/h9/zF/+vs/1oA7Cs/xB/wAi9qf/AF6S/wDoBrQrP8Qf8i9qf/XpL/6AaALGn/8AIOtv+uSfyFWK&#xd;&#xa;r6f/AMg62/65J/IVYoAKRvumlpDyKUtmBwlnc2f/AAgM0EssZlZXCR5BYsRxx161bvL+70/w5plu&#xd;&#xa;svkzTtsZicFV+Y8HoOgrS8PeHoLHTo0vrK1e5Vi2/wAtWPtzin+JdFfVbeFrfyzNA4ZUkXKtwRg/&#xd;&#xa;nVS3+aBf5mJHqM+nX2n/APE0kukuFIlWSYSbWw2MAdO1VxdanPp+sXZ1C6Q2c0nlBJMAgFuD7DAr&#xd;&#xa;VsdGvvNgWbTdMtkjB3yJGrs5wcfwjHOKWHQb1NH1e1Pl+ZdvI0fzcYbdjP5ilLrbz/NBHpf+tGQa&#xd;&#xa;lrF5LpGlR20xS4vGCsyZDYw2cH6gVVnudR0/Xrmz+33UkK25dPMfJ/i5/SrOpaW9lo2mPLdW9vdW&#xd;&#xa;b8ebIFRvvHGT9f0qpapPrviO4m3wlfs2zdC/mIp+bjcMev60S1bt5/loEdEr+X5l7+0bz/hDY7r7&#xd;&#xa;RJ55tXcyZ5yEBzUT6neiz0Jhcybp5MSHP3x83X8hSnRtcOif2YIrdVjiaJX83O8EY6Y46frVhtAv&#xd;&#xa;Ta6RGPL3Wj7pPm7fN0/MUL4m+l0D+FLrZjL+a+uPFrWEd3PDbm33nynwVPzYI/ICrfhC+uLqC8hu&#xd;&#xa;pmme3nZAznLYyRyfwqU6Vc/8JQ+ofJ5Bg8sfNznLdvxFHhvSrnTJNQa52YuJzIm1s8Esefzojt8v&#xd;&#xa;1/yCW/z/AEN2iiigArj/ABH/AMjzoH4/zrsK4/xH/wAjzoH4/wA6AOwooooAKKKKACiiigAooooA&#xd;&#xa;KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAo&#xd;&#xa;oooAKKKKACiiigAooooAKKKKACsd/wDkcof+wfJ/6MStiue1K0N74st4xdXFtixdt8DBWP7xeOQe&#xd;&#xa;OaAOhorH/sF/+g1qv/f5f/iaP7Bf/oNar/3+X/4mgDYorH/sF/8AoNar/wB/l/8AiaP7Bf8A6DWq&#xd;&#xa;/wDf5f8A4mgDYorH/sF/+g1qv/f5f/iaP7Bf/oNar/3+X/4mgDYorH/sF/8AoNar/wB/l/8AiaP7&#xd;&#xa;Bf8A6DWq/wDf5f8A4mgDYorH/sF/+g1qv/f5f/iaP7Bf/oNar/3+X/4mgDYorH/sF/8AoNar/wB/&#xd;&#xa;l/8AiaP7Bf8A6DWq/wDf5f8A4mgDYorH/sF/+g1qv/f5f/iaP7Bf/oNar/3+X/4mgDYorH/sF/8A&#xd;&#xa;oNar/wB/l/8AiaP7Bf8A6DWq/wDf5f8A4mgDYrj/AIff8xf/AK+z/Wtj+wX/AOg1qv8A3+X/AOJr&#xd;&#xa;F+Ha7E1ZdxbF1jLdT160AdlWf4g/5F7U/wDr0l/9ANaFZ/iD/kXtT/69Jf8A0A0AWNP/AOQdbf8A&#xd;&#xa;XJf5CrFYFlobvZW7f2xqi5jU4WZcDjt8tT/2C/8A0GtV/wC/y/8AxNAGxRWP/YL/APQa1X/v8v8A&#xd;&#xa;8TR/YL/9BrVf+/y//E0AbFFY/wDYL/8AQa1X/v8AL/8AE0f2C/8A0GtV/wC/y/8AxNAGxRWP/YL/&#xd;&#xa;APQa1X/v8v8A8TR/YL/9BrVf+/y//E0AaskUcoxIiuPRhmiOGOLPlxomf7qgVlf2C/8A0GtV/wC/&#xd;&#xa;y/8AxNH9gv8A9BrVf+/y/wDxNAGxRWP/AGC//Qa1X/v8v/xNH9gv/wBBrVf+/wAv/wATQBsUVj/2&#xd;&#xa;C/8A0GtV/wC/y/8AxNH9gv8A9BrVf+/y/wDxNAGxRWP/AGC//Qa1X/v8v/xNH9gv/wBBrVf+/wAv&#xd;&#xa;/wATQBsVx/iP/kedA/H+dbH9gv8A9BrVf+/y/wDxNc5qlkbLxtoam7ubncSc3DhiOe2AKAO7oooo&#xd;&#xa;AKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigA&#xd;&#xa;ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACsd/8Akcof+wfJ/wCjErYrHf8A5HKH/sHy&#xd;&#xa;f+jEoA2KKyNb11NImt4jbvM1wcKFYDmqS+KpTNcW/wDZM32m3Xc8fmr93nJz07UXA6SisqDX7OTR&#xd;&#xa;xqUjGKLByDkkYJB6fSqsPiRvOiS80+W1E6kxM0isHIBOOOnTvR1sF+pv0Vh/8JJD/Zv2vyH3ef5H&#xd;&#xa;lbhndnH86mvtbFtNDbQWz3N3KobyVYKQvqSePT86ANWjI9RXN3niOObQLyVIjHcIRC0LnJUkqOv/&#xd;&#xa;AAKsW30yaw8Ji6bma2uBOVyMEId39KFs300/EPLqd9S1BZTi6s4Zx0dAanoatoJO6uFFFFAwoooo&#xd;&#xa;AKKKKACuP+H3/MX/AOvs/wBa7CuP+H3/ADF/+vs/1oA7Cs/xB/yL2p/9ekv/AKAa0Kz/ABB/yL2p&#xd;&#xa;/wDXpL/6AaALGn/8g62/65L/ACFWKybjUl0nw7FePGZFjhT5QcE/LVGfxVLb2iXkukzLauRiXzV7&#xd;&#xa;nA469aAOkorFsvEAudSSzms5LdpU8yJmcHevrx06jg+tJd+ICl5NbWNjJevAMylHC7Onr16jpQBt&#xd;&#xa;0Vj2viG2ury3gRG2XEXmJJng8AkfqKWDxBbSafPfTK0MELldxOd2CRxj6UPQNzXpM1zw8VIUW5+w&#xd;&#xa;y/YGfYLreMdsfL97qR2qK4cat4rghX/U2kRYuOp3gY/9BoA6brS1zvhOZohd6ZIAGtZSQfUMd3/s&#xd;&#xa;1dFQHkFFFFABRRRQAUUUUAFcf4j/AOR50D8f512Fcf4j/wCR50D8f50AdhRRRQAUUUUAFFFFABRR&#xd;&#xa;RQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFF&#xd;&#xa;ABRRRQAUUUUAFFFFABRRRQAUUUUAFY7/API5Q/8AYPk/9GJWxWO//I5Q/wDYPk/9GJQBR8T2lxPq&#xd;&#xa;+lPDBLIkchLsiEheD19KZHaXI8R6vKbeXy5IAEfYcMcNwD36iupopJWVvX8R31v6fgcNBol7d+Fm&#xd;&#xa;tPJkimzIwWRSufnbH6HNWrhbnX7jTolsbm1W3bzJXmiKDoeBkc9vzrr6Kq+tybfr+Jx76VcnxP5H&#xd;&#xa;2dzYmYXPmbTsDbt2PSneINNmXX4dQ8u8ktmTy2+xFhIvTn5eccfyrrqKXbyH3OAvNMxoN7dRWV3A&#xd;&#xa;fOQ4nkZnkAZOSCMj/wCtWhPeR3Hgi6df+WgeNQOckggV1ksaTRNHIu5GGCD3FUItA0yGBIY7bEaO&#xd;&#xa;JAvmMRuByD1p391x72D7Sl2uP0OFrfR7WJs5Cc59+av0gAAwOgpaG7u4krKwUUUUhhRRRQAUUUUA&#xd;&#xa;Fcf8Pv8AmL/9fZ/rXYVx/wAPv+Yv/wBfZ/rQB2FZ/iD/AJF7U/8Ar0l/9ANaFZ/iD/kXtT/69Jf/&#xd;&#xa;AEA0AZmvwTXPg0RW8TyyNCmERSxPy+gqHWrS5l8JQQR28rygx5RUJYYcHpXQ6f8A8g62/wCuSfyF&#xd;&#xa;WKVt/VP7h3/X8TlpLS5PiXSpRby+XHAQ77DhTheCe1Mh+06DquoM1jc3UdyQ8bwRF+cAYOBx3rrK&#xd;&#xa;Kb1/H8Rf8D8DirnRb3T/AA9ZPBE015ASSkYOfmxkcfSr13oU03g8WEChZzlyCMZJJOD+ddPRQ9b+&#xd;&#xa;YLSx55Z6W8Vithd6fqs06yBdiyyLARwc5xj1/KtbSoDYeL5oWVlWSBNm45+6DkZ79RXW1WnsLa4u&#xd;&#xa;Ip5Y90sQIRgxGM4z0+gp31v/AFsFtLGD4bj83X9Xu13eWzKikjg4Vc/yNdPUFnZ29jD5VtHsTJOM&#xd;&#xa;k8k5PJ9zU9Lol2Dq33CiiigAooooAKKKKACuP8R/8jzoH4/zrsK4/wAR/wDI86B+P86AOwooooAK&#xd;&#xa;KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoo&#xd;&#xa;ooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACsd/+Ryh/wCwfJ/6MStisd/+Ryh/7B8n/oxK&#xd;&#xa;ANiiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK4/4ff8xf8A6+z/AFrsK4/4ff8AMX/6&#xd;&#xa;+z/WgDsKz/EH/Ivan/16S/8AoBrQrP8AEH/Ivan/ANekv/oBoAsaf/yDrb/rkn8hViq+n/8AIOtv&#xd;&#xa;+uSfyFWKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArj/Ef/I86B+P867CuP8R/8jzoH4/z&#xd;&#xa;oA7CiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo&#xd;&#xa;oAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK57X9L1q41OC90W7t7Z0haJzLy&#xd;&#xa;SCwPTaR2FFFAFD+zvHP/AEGbH/vgf/G6P7O8c/8AQZsf++B/8boooAP7O8c/9Bmx/wC+B/8AG6P7&#xd;&#xa;O8c/9Bmx/wC+B/8AG6KKAD+zvHP/AEGbH/vgf/G6P7O8c/8AQZsf++B/8boooAP7O8c/9Bmx/wC+&#xd;&#xa;B/8AG6P7O8c/9Bmx/wC+B/8AG6KKAD+zvHP/AEGbH/vgf/G6P7O8c/8AQZsf++B/8boooAP7O8c/&#xd;&#xa;9Bmx/wC+B/8AG6P7O8c/9Bmx/wC+B/8AG6KKAD+zvHP/AEGbH/vgf/G6P7O8c/8AQZsf++B/8boo&#xd;&#xa;oAP7O8c/9Bmx/wC+B/8AG6P7O8c/9Bmx/wC+B/8AG6KKAD+zvHP/AEGbH/vgf/G6v+EdDvNFhuxf&#xd;&#xa;SwySTy+ZmIkjpznIFFFAHQ1BfWy3thcWrMVWeJoyw6gMCM/rRRQBlQL4jhgjiEOlEIoUEzSc4GP7&#xd;&#xa;tSb/ABJ/zw0r/v8ASf8AxNFFABv8Sf8APDSv+/0n/wATRv8AEn/PDSv+/wBJ/wDE0UUAG/xJ/wA8&#xd;&#xa;NK/7/Sf/ABNG/wASf88NK/7/AEn/AMTRRQAb/En/ADw0r/v9J/8AE0b/ABJ/zw0r/v8ASf8AxNFF&#xd;&#xa;ABv8Sf8APDSv+/0n/wATRv8AEn/PDSv+/wBJ/wDE0UUAG/xJ/wA8NK/7/Sf/ABNG/wASf88NK/7/&#xd;&#xa;AEn/AMTRRQAb/En/ADw0r/v9J/8AE0b/ABJ/zw0r/v8ASf8AxNFFABv8Sf8APDSv+/0n/wATRv8A&#xd;&#xa;En/PDSv+/wBJ/wDE0UUAG/xJ/wA8NK/7/Sf/ABNZ0+jazf8AiDT9RvPsEaWh5WKRySPxWiigDqaK&#xd;&#xa;KKAP/9k=</binary>
<binary id="image13.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAFCAl0BAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKjmcxwyOMZVSRn6Vh6fceIb6wt7tJNLRZow4UxSZGRn+9VjZ4j/AOe2lf8AfqT/AOKo&#xd;&#xa;2eI/+e2lf9+pP/iqNniP/ntpX/fqT/4qjZ4j/wCe2lf9+pP/AIqjZ4j/AOe2lf8AfqT/AOKo2eI/&#xd;&#xa;+e2lf9+pP/iqNniP/ntpX/fqT/4qjZ4j/wCe2lf9+pP/AIqjZ4j/AOe2lf8AfqT/AOKo2eI/+e2l&#xd;&#xa;f9+pP/iqNniP/ntpX/fqT/4qjZ4j/wCe2lf9+pP/AIqjZ4j/AOe2lf8AfqT/AOKo2eI/+e2lf9+p&#xd;&#xa;P/iqNniP/ntpX/fqT/4qjZ4j/wCe2lf9+pP/AIqjZ4j/AOe2lf8AfqT/AOKo2eI/+e2lf9+pP/iq&#xd;&#xa;juZPEVvayztLpZESFyBFJzgZ/vVqafO11p9tcOAHliV2C9ASAeKsUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUVFdf8es3+438qo+G/8AkXNO/wCvdP5CtOiiiiiiiiiiiiii&#xd;&#xa;iiiqmq/8gm8/64P/AOgmm6L/AMgSw/694/8A0EVdoooooooooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooooooqK6/wCPWb/cb+VUfDf/ACLmnf8AXun8hWnRRRRRRRRRRRRRRRRRVTVf+QTe&#xd;&#xa;f9cH/wDQTTdF/wCQJYf9e8f/AKCKu0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUVFdf8AHrN/uN/KqPhv/kXNO/690/kK06KKKKKKKKKKKKKKKKKqar/yCbz/AK4P/wCgmm6L&#xd;&#xa;/wAgSw/694//AEEVdoooooooooooooooooooooooooooooooooooooooooooooooooooooqK6/49&#xd;&#xa;Zv8Acb+VUfDf/Iuad/17p/IVp0UUUUVC91bx3CW7zxLM4ykZcBm+g6mpqKKKKKKKKKKqar/yCbz/&#xd;&#xa;AK4P/wCgmm6L/wAgSw/694//AEEVdooooooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooqK6/49Zv8Acb+VUfDf/Iuad/17p/IVp0UUVxPj65vobi1XzZ4dMO3zZIVGQ2T0PHOO2cVY&#xd;&#xa;t4dFuLq1Gk6y8V2GyB5zS7+DkbWJFQ+IzOPHekG1WNpvJO0SMQp+91IBq9qPiHUNFuLQaraW3k3D&#xd;&#xa;Fc28jMwx7ED1FamtXtxYWyzw/ZBGDiRrmQoB6YwDWZo/ikX2sf2dMtu7um6OS1cunGSQSQMdPSk0&#xd;&#xa;/XtV1W7vorKzs9tpKYyZZWBPJA6A+lS6N4hnvNYuNK1Cz+zXUQ3LtOVZR3yfqMcVKmtz6lcTxaJH&#xd;&#xa;bzi2IWV53Kgk9NuAc9DnOKl8Oa2ut2TymIxyxOY5F6jPse4xiteiiiqmq/8AIJvP+uD/APoJpui/&#xd;&#xa;8gSw/wCveP8A9BFXaKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK5/wAPXsd/&#xd;&#xa;rGtTQhwgljTDDByq4P6iugoqK6/49Zv9xv5VR8N/8i5p3/Xun8hWnRRRWZq13f2ckL29iLu2LASB&#xd;&#xa;CTIOvIXoRj3rB1zTpfEktu1rp81ncQMC0t0uwFP7owTzk5q1qtjdS+ONKu44Ha3iiIeQDhT83X8x&#xd;&#xa;UPjzTry//s37HbyTeXIxfYM7R8tGu6ZN/wAJZaanJZyXlmse0xwjcysMkEjgdSO/amwRXV545ttR&#xd;&#xa;Gn3VvbLAULTIFwcN6E+tU/C2oGy1LWwLK7ud90ebdA23luuSK1tF066uNfudevIjbGRfKjgb720c&#xd;&#xa;Zb0PA9etZtv4bt9Iurr7bp0+pxzMGhaBclB33DIxyffpXR6DaxW1tIYLAWUUj7ljOd/TGWHY8die&#xd;&#xa;MVqUUUVU1X/kE3n/AFwf/wBBNN0X/kCWH/XvH/6CKu0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUVm6vcy7PsFk5W9uEJRh/yzXoXPsCRx15rH3R6bdiWKPDadtju3P3Ckg3vIB1z&#xd;&#xa;kfqeK6O0uoL61jubZ/MhkGVbBGfzqeorr/j1m/3G/lVHw3/yLmnf9e6fyFadFFFFFFFFFVbTT7Sx&#xd;&#xa;eZ7WBYmnbfIR/EfX9TVqiiiiiiqmq/8AIJvP+uD/APoJpui/8gSw/wCveP8A9BFXaKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKazKilmIUDqSaCyggEgE9BnrTqKKKKKKKKKKKKKKaGU5wwO3g89KFZXUMrBlP&#xd;&#xa;Qg5FOoopMDOe9UrWxaDUr+6ZlZLoxlV7jauOaugADAGBS1Fdf8es3+438qo+G/8AkXNO/wCvdP5C&#xd;&#xa;tOiiiiiiiiiiiiiiiiiqmq/8gm8/64P/AOgmm6L/AMgSw/694/8A0EVdoooooooooooooooooooo&#xd;&#xa;ooooooorN8RW015oN5b26b5ZIyFXIGT+NJqFtNNq2lTRpujgkkMjZHygxsB+pqv4ZuJrg6t50rye&#xd;&#xa;XqM0abmztUYwB7VqXrFLKdlJDCNiCOxxWFpviA/Y7W0FvPd3otIZSARmTcuScnjjHc960rTVGknE&#xd;&#xa;N5Zy2Tv/AKoSsrb8dcFScY46+tSX2o/ZpBDb28l3cEbjFGQCF9STgenGc80ljqL3MxguLOW0m271&#xd;&#xa;SQhty9CcqSOpFVv7ZuZPntNIubiA/clV0UMPXDEEfiKfZ6/Z3WkvqHzxpG2yRGU7lc4wv6j86jbW&#xd;&#xa;L9ELNoN2Aoyf3sf/AMVVK71m8bVNJktrG5eKeB5PKDqu/KqcEE9V9/XitC5v2+wwS3Vtc2rNcxxh&#xd;&#xa;FkXdksAMkEjb6imTeIETU7nTobSae6gCEImBvBGTgngY96ItfxqENnfWM9k84/dNIVYMc9PlJwfr&#xd;&#xa;6VbvtR+zSLDBbyXdwRu8qMgEL6knA7jjOeaqf23cR3FvHdaTc26zyiJXZ0IDHPoSexp1lZzxf2xv&#xd;&#xa;jx9onZ4uR8wMajP5g0/w1azWWgWdtcp5c0aYZcg4OT6VqUUUVn2V5LPq2o2z7fLtzGEwOfmXJzWh&#xd;&#xa;RUV1/wAes3+438qo+G/+Rc07/r3T+QrToooooooooooooooooqpqv/IJvP8Arg//AKCabov/ACBL&#xd;&#xa;D/r3j/8AQRV2iiiiiiiiiiiiiiiiiiiiiiiiiiiiiuf0hk0e41KLUZEtzcXklzE7sArIxAHzHjPB&#xd;&#xa;461cvdWsZLSWOC5juJJFKKkDCRskY6DnHvWTockOlahPb39xDbyJZWiESSAZKqwOM9avapcQ6obO&#xd;&#xa;3sJo7h1uY5mMTBlRVYE5I4HHTPXBp0Mkena3qMl46wxXRR4pHOFO1ApGTwDnt7U/UdYX7DcnSnW6&#xd;&#xa;uY4i6eUPMXIIGCR356VR2WEw8y58Sv5zcv5N6I0z7Lk4qnp4sW0PWReTXQtDejdJISJRxHgnPPXF&#xd;&#xa;TOfskry6d4nikUx48m6lE5Lcnj5hjPAqw1xIbrQL6/xB/o8hmZxsVGZU4OenOeDU+vXENzYWclvN&#xd;&#xa;HKn26Abo2DD747io9J/5HDX/APdt/wD0A1Y8Qf6zSf8AsIR/+gtTYpE07XNQlvHWGK6MbRSOcKdq&#xd;&#xa;BSCegOe3tVbWdStbq80qG2k87/TUYyR/Mg4bjcOM+3WujoooooqNIYklklSNVkkxvYDlsDAzUlFR&#xd;&#xa;XX/HrN/uN/KqPhv/AJFzTv8Ar3T+QrToooooooooooooooooqpqv/IJvP+uD/wDoJpui/wDIEsP+&#xd;&#xa;veP/ANBFXaKKKKKKKKKKKKKKKKKKKKKKKKKKKKKimt4LgATwxygcgOobH50yKytIH3w2sMb9NyRg&#xd;&#xa;H9Koppaya5fXV1bxSxSxxLGXUNyu7d16dRWhBa29tu8iCKLd12IFz+VOmghuECTxJKoOcOoYZ/Gk&#xd;&#xa;gt4LcEQQxxA9Qihc/lUP9mWH/Pjbf9+l/wAKma3gdHRoY2SQ5dSowx9T69BUQ02wBBFlbAjoREv+&#xd;&#xa;FTSwxTpsmjSRP7rqCP1pqWtukYjSCJUDbgoQAA+uPWnrFGsjyKih3xuYDlsdMmleNH270Vtp3LkZ&#xd;&#xa;wfUVQ1VLltjQ2kN9EOGgkwvPZtxyOORjHeqttp891LC9zaQ2EEEglS3iIYtIOjFhgYwSMY7da26K&#xd;&#xa;KKKKzLATDW9VMgk8omLy92dv3OcfjWnRUVyCbaUAZJQ4A+lc/outQ2ejWdtNaX4lihVGAtJDggfS&#xd;&#xa;rv8Awkdr/wA+2of+Acn+FH/CR2v/AD7ah/4Byf4Uf8JHa/8APtqH/gHJ/hR/wkdr/wA+2of+Acn+&#xd;&#xa;FH/CR2v/AD7ah/4Byf4Uf8JHa/8APtqH/gHJ/hR/wkdr/wA+2of+Acn+FH/CR2v/AD7ah/4Byf4U&#xd;&#xa;jeJbNELPb36qoySbSQAD8qF8S2boGS3v2VhkEWkhBH5Uv/CR2v8Az7ah/wCAcn+FH/CR2v8Az7ah&#xd;&#xa;/wCAcn+FH/CR2v8Az7ah/wCAcn+FH/CR2v8Az7ah/wCAcn+FH/CR2v8Az7ah/wCAcn+FH/CR2v8A&#xd;&#xa;z7ah/wCAcn+FH/CR2v8Az7ah/wCAcn+FH/CR2v8Az7ah/wCAcn+FQX+vW8+n3MMdrqBeSJlUfY5O&#xd;&#xa;pBHpWnpCsmj2SOpVlt4wQRgg7RVyiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iimLJGzuiupdMblB5XPTPpT6KKKKKKKKKKKyvEErrYrBEcyXEiRlAMlkLAPgf7pPPaq/huJ9Pa60&#xd;&#xa;qZ2eSJ/OT5iwWJjhBk85G08Vu0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUVn2dnLBquo3LlfLuTGUweflXBzWhRRRRRRRRRRRWO/+l+KI0Py/YIfMBHO/zMrj2xto&#xd;&#xa;vv8AQtctLtfkiuAYriQ9OP8AVj2+Zj9a2KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKrQXkU93c2yBvMtiofI4+YZGKs0UUUUUUUUUUhIUEk4A5JrmNI13SvtN/c3&#xd;&#xa;OoW4ma4ZEZnAzEPu49uTTte1rSrrTgsOpWrNHLHKV8wZIVgxA98Diuht5lubaKePOyVA6564IzUt&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFZ97/AGv5/wDoJsfJwP8AXB92fwq2&#xd;&#xa;3n/Zjt8vz9nGc7d2Pzxmqtj/AGt5x+3my8rbx5Afdn8e3WnX/wDae5P7P+ybcfN5+7OfbFWLbz/s&#xd;&#xa;6favL87Hz+Xnbn2zzVK1/tr7Sv2s6f5HO7yg+72xnirl19o+zv8AZPK8/wDh83O3r3xz0qCw/tLL&#xd;&#xa;/wBo/ZMcbPs+78c5/CmXv9r+f/oJsfJx/wAtg+7P4VbPn/Zjjy/P2cZzt3Y/PGaq2P8Aa3nH7ebL&#xd;&#xa;ytvHkB92fx7dalt7JIL26ulZi9yULA9BtGBirVFFFFFFFFFFJVHV4oxo96RGmfs8n8I/umjSIozo&#xd;&#xa;9kTGmfs8f8I/uirwGBgdKWiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiorpmS1m&#xd;&#xa;ZDhgjEH3xVfRpZZ9Gspp2LSyQIzkjBJKjNXaKKKKKKKKKKKKKKKKKKKKKKp6v/yB77/r3k/9BNGk&#xd;&#xa;f8gex/694/8A0EVcoooooooooooooooooooooooooooooooooooooooooooooooopOlAIIBByD3F&#xd;&#xa;LRRRRRRRRRRRRRRRRRRRRRRVPV/+QPff9e8n/oJo0j/kD2P/AF7x/wDoIq5RRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUVyjSWsqKMsyED64qvo9vJaaPZW8w2yxQIjgHOCAAau1j&#xd;&#xa;6jc6gdYgsbCWCIPA8rNLGX6MBjgj1o+z6/8A9BCx/wDAVv8A4uj7Pr//AEELH/wFb/4uj7Pr/wD0&#xd;&#xa;ELH/AMBW/wDi6Ps+v/8AQQsf/AVv/i6Ps+v/APQQsf8AwFb/AOLo+z6//wBBCx/8BW/+Lo+z6/8A&#xd;&#xa;9BCx/wDAVv8A4uj7Pr//AEELH/wFb/4uj7Pr/wD0ELH/AMBW/wDi6Ps+v/8AQQsf/AVv/i6Ps+v/&#xd;&#xa;APQQsf8AwFb/AOLo+z6//wBBCx/8BW/+Lo+z6/8A9BCx/wDAVv8A4uj7Pr//AEELH/wFb/4uj7Pr&#xd;&#xa;/wD0ELH/AMBW/wDi6Ps+v/8AQQsf/AVv/i6Ps+v/APQQsf8AwFb/AOLo+z6//wBBCx/8BW/+Lo+z&#xd;&#xa;6/8A9BCx/wDAVv8A4uj7Pr//AEELH/wFb/4uj7Pr/wD0ELH/AMBW/wDi6ranBrg0u7Ml/ZMghfcB&#xd;&#xa;bMCRtOed1GmQa4dLtDHf2SoYU2g2zEgbRjndVn7Pr/8A0ELH/wABW/8Ai6Ps+v8A/QQsf/AVv/i6&#xd;&#xa;Ps+v/wDQQsf/AAFb/wCLo+z6/wD9BCx/8BW/+Lo+z6//ANBCx/8AAVv/AIuj7Pr/AP0ELH/wFb/4&#xd;&#xa;uj7Pr/8A0ELH/wABW/8Ai6Ps+v8A/QQsf/AVv/i6Ps+v/wDQQsf/AAFb/wCLo+z6/wD9BCx/8BW/&#xd;&#xa;+Lo+z6//ANBCx/8AAVv/AIuj7Pr/AP0ELH/wFb/4uj7Pr/8A0ELH/wABW/8Ai6Ps+v8A/QQsf/AV&#xd;&#xa;v/i6Ps+v/wDQQsf/AAFb/wCLo+z6/wD9BCx/8BW/+Lo+z6//ANBCx/8AAVv/AIuj7Pr/AP0ELH/w&#xd;&#xa;Fb/4uj7Pr/8A0ELH/wABW/8Ai6Ps+v8A/QQsf/AVv/i6Ps+v/wDQQsf/AAFb/wCLqKwvdSTxG+mX&#xd;&#xa;0tvMotfPDRRFOd23HJPvW7RRRRRRRRRRRRRRRRRRRRRRRRRRTZHWONnY4VQSfpTLa4ju7aK4hO6K&#xd;&#xa;VA6HGMgjIqWseb/kb7X/AK8pf/Q0rYooooooooooooooooooooqnq/8AyB77/r3k/wDQTRpH/IHs&#xd;&#xa;f+veP/0EVcoooooooooooooooooooorAX/kf3/7Bg/8ARlb9FFFFFFFFFFFFFFFFFFFFFFFFFFRz&#xd;&#xa;R+bDJHnG9SufTIqPT7UWOn29oH3iCNY92MZwMZqxWPN/yN9r/wBeUv8A6GlbFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFU9X/wCQPff9e8n/AKCaNI/5A9j/ANe8f/oIq5RRRRRRRRRRRRRRRRRRRRWAv/I/v/2DB/6M&#xd;&#xa;rfooooooooooooooooooooooooooqOeTyoJJMZ2KWx64FRabdG+022uymwzxLJtznGRnFWax5v8A&#xd;&#xa;kb7X/ryl/wDQ0rYooooooooooooooooooooqnq//ACB77/r3k/8AQTRpH/IHsf8Ar3j/APQRVyii&#xd;&#xa;iiiiiiiiiiiiiiiiiisBf+R/f/sGD/0ZW/RRRRRRRRRRRRRRRRTJpBDC8rAkIpYgewqiwk1bT7W4&#xd;&#xa;tbuezWVFlGxVJIYZAOQfWrNlBLbweXNcyXL5J8yQAH6cACqv9nXf2zzv7WufL8zf5OxNuM52525x&#xd;&#xa;265q1eQS3EBjhuZLZ8g+ZGAT+oIplhaz2qOJ72W7LHIMiqNv/fIFQXenXc9w0kWrXNuhxiNEQgce&#xd;&#xa;6k1dto3hgSOSZpnUYMjgAt9ccVStdOu4LlZZdWuZ0XOY3RAG49lzVi/tZrpFWC9ltCDktGqkn25B&#xd;&#xa;pbW1eK1MFxcyXRbOXkABIPbgCpbeCO2t44IV2RRqERfQDgCpKx5v+Rvtf+vKX/0NK2KKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKp6v8A8ge+/wCveT/0E0aR/wAgex/694//AEEVcoooooooooooooooooooorAX/kf3&#xd;&#xa;/wCwYP8A0ZW/RRRRRRRRRRRRRRRRUVzGZraWJSAXQqCfcVFpls1npdpayEM8MKRsV6EhQOKtUUUU&#xd;&#xa;UUUUUUVjzf8AI32v/XlL/wChpWxRRRRRRRRRRRRRRRRRRRRVPV/+QPff9e8n/oJo0j/kD2P/AF7x&#xd;&#xa;/wDoIq5RRRRRRRRRRRRRRRRRRRRWAv8AyP7/APYMH/oyt+iiiiiiiiiiiiiiiiormQw20soAJRCw&#xd;&#xa;B9hUWmXLXumWl06hWnhSQgdASAf61aoooooooooorHm/5G+1/wCvKX/0NK2KKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKp6v/AMge+/695P8A0E0aR/yB7H/r3j/9BFXKKKKKKKKKKKKKKKKKKKKKwF/5H9/+wYP/AEZW&#xd;&#xa;/RRRRRRRRRRRRRRRRTXVXQqwBVhgg9xSRRJBEkUShI0UKqjoAOgp9YmsrLcazplol3cW0cqTM5gf&#xd;&#xa;aTtC4/maf/YLf9BjVf8Av+P/AImj+wW/6DGq/wDf8f8AxNH9gt/0GNV/7/j/AOJo/sFv+gxqv/f8&#xd;&#xa;f/E0f2C3/QY1X/v+P/iaP7Bb/oMar/3/AB/8TR/YLf8AQY1X/v8Aj/4mj+wW/wCgxqv/AH/H/wAT&#xd;&#xa;R/YLf9BjVf8Av+P/AImoz4aQ3CznVNT81VKB/OGQCckfd9hUn9gt/wBBjVf+/wCP/iaP7Bb/AKDG&#xd;&#xa;q/8Af8f/ABNH9gt/0GNV/wC/4/8AiaP7Bb/oMar/AN/x/wDE0f2C3/QY1X/v+P8A4mj+wW/6DGq/&#xd;&#xa;9/x/8TR/YLf9BjVf+/4/+Jo/sFv+gxqv/f8AH/xNH9gt/wBBjVf+/wCP/iap2iT2Xi5LL7ddXED2&#xd;&#xa;RlKzybvm349BXSVFcErbSspwQhIP4VgaRpct7pFpdS6vqYkmiV2CzgDJHbirn9gt/wBBjVf+/wCP&#xd;&#xa;/iaP7Bb/AKDGq/8Af8f/ABNH9gt/0GNV/wC/4/8AiaP7Bb/oMar/AN/x/wDE0f2C3/QY1X/v+P8A&#xd;&#xa;4mj+wW/6DGq/9/x/8TR/YLf9BjVf+/4/+Jo/sFv+gxqv/f8AH/xNNk8PCWNo5NW1RkcFWBnGCD/w&#xd;&#xa;GiPw8Io1jj1bVFRAFUCcYAH/AAGnf2C3/QY1X/v+P/iaP7Bb/oMar/3/AB/8TR/YLf8AQY1X/v8A&#xd;&#xa;j/4mj+wW/wCgxqv/AH/H/wATR/YLf9BjVf8Av+P/AImj+wW/6DGq/wDf8f8AxNH9gt/0GNV/7/j/&#xd;&#xa;AOJo/sFv+gxqv/f8f/E1BfaPJb2NxMmr6pujiZxmcYyBn0rU0qR5dJs5JGLO8CMzHqSVGTVusK/i&#xd;&#xa;mvPEcdoL26t4haGXED7ctvxzwexqX+wW/wCgxqv/AH/H/wATR/YLf9BjVf8Av+P/AImj+wW/6DGq&#xd;&#xa;/wDf8f8AxNH9gt/0GNV/7/j/AOJo/sFv+gxqv/f8f/E0f2C3/QY1X/v+P/iaP7Bb/oMar/3/AB/8&#xd;&#xa;TR/YLf8AQY1X/v8Aj/4mj+wW/wCgxqv/AH/H/wATUX/CMRC7N1/aepeeU8vzPOGduc4+70zUv9gt&#xd;&#xa;/wBBjVf+/wCP/iaP7Bb/AKDGq/8Af8f/ABNH9gt/0GNV/wC/4/8AiaP7Bb/oMar/AN/x/wDE0f2C&#xd;&#xa;3/QY1X/v+P8A4mj+wW/6DGq/9/x/8TR/YLf9BjVf+/4/+Jo/sFv+gxqv/f8AH/xNH9gt/wBBjVf+&#xd;&#xa;/wCP/iarNazadrmlouo3s8c7yK6TyhgcRkjsO9dDRRRRRRUN2WWznMed4jYrjrnFQ6O0r6NYvcFj&#xd;&#xa;M1vGZC/XdtGc++auVj6h/wAjNpH/AFzuP5JWxRRRRRRRRRRRRRRRRRRWBJ/yP0P/AGDm/wDRlb9R&#xd;&#xa;XX/HrN/uN/KqPhv/AJFzTv8Ar3T+QrToooooooooooooooooqpqv/IJvP+uD/wDoJpui/wDIEsP+&#xd;&#xa;veP/ANBFXaxz/wAjiv8A2Dz/AOjBWxRRRRRRRRRRRRRRRRRRWPqn/Ie0T/rrN/6KatiiiiiiikJC&#xd;&#xa;gkkADkk0iMroHRgysMgg5BFOrH1D/kZtI/653H8krYoooooooooooooooooorAk/5H6H/sHN/wCj&#xd;&#xa;K36iuv8Aj1m/3G/lVHw3/wAi5p3/AF7p/IVp0UUUUUUUUUUUUUUUUVU1X/kE3n/XB/8A0E03Rf8A&#xd;&#xa;kCWH/XvH/wCgirtY5/5HFf8AsHn/ANGCtiiiiiiiiiiiiiiiiiiisfVP+Q9on/XWb/0U1bFFFFFF&#xd;&#xa;FRXUbS2s0a43OjKM+pFQ6VbvaaTZ20uPMhgSNsHIyFANW6x9Q/5GbSP+udx/JK2KKKKKKKKKKKKK&#xd;&#xa;KKKKKKwJP+R+h/7Bzf8Aoyt+orr/AI9Zv9xv5VR8N/8AIuad/wBe6fyFadFFFFFFFFFFFFFFFFFV&#xd;&#xa;NV/5BN5/1wf/ANBNN0X/AJAlh/17x/8AoIq7WOf+RxX/ALB5/wDRgrYoooooooooooooooooorH1&#xd;&#xa;T/kPaJ/11m/9FNWxRRRRRRVDWNWttGsWubpwMcImeXPoKg0DX7TXbXzIDsmUDzIieVOBn6jJxn2r&#xd;&#xa;WrH1D/kZtI/653H8krYooooooqD7ZbC7Fp9oi+0EbvK3Ddj1x1qeiiq8d9aSXT2sdzE1wgy0QcFl&#xd;&#xa;HuPxFWKKKKKKKwJP+R+h/wCwc3/oyt+orr/j1m/3G/lVHw3/AMi5p3/Xun8hWnRRRRRRRRRRRRRR&#xd;&#xa;RRRVTVf+QTef9cH/APQTTdF/5Alh/wBe8f8A6CKu1jn/AJHFf+wef/RgrYoooooqG5urezi826nj&#xd;&#xa;hjzjdIwUZ+pqVWDKGUggjII70tFFFFQfbLb7X9k+0RfaAN3lbhux6461PRRRRWPqn/Ie0T/rrN/6&#xd;&#xa;KatiiiiiiivN/iZDONUtpyrfZzCEDZ43bmJ/HBFQfD3TLubV01BPltYCyuSfvEqRgf8AfQNen1j6&#xd;&#xa;h/yM2kf9c7j+SVsUUUUVzWtajdt4nsNFgmMENxGZJJFALEYb5ef92rv/AAjOljlIZFYdG8+Q4Pry&#xd;&#xa;1Z0cscfjmG1kgWW5W1GbtmIduD/CPl/Si+8UXlv4kuNKt7AXBSPcmw/MW2AjOSBjJpx8Q6hZ6Ld3&#xd;&#xa;urWMdnKhCwIScSMQTj9KuQXeuNbx3UltZSQsocpC7mQgjOACAM/jWHonPxK1T/rk380rfuNWln1G&#xd;&#xa;TTtK8iS5hXfMZyQqjOMcc56VHoutzXmpXmm3kSJdWpyWiJKFeO55zz6VuUUUUVgSf8j9D/2Dm/8A&#xd;&#xa;Rlb9RXX/AB6zf7jfyqj4b/5FzTv+vdP5CtOiiuf8bvex+HZWsSwO796VxxHg5/pWBZN4Vm0dFlv5&#xd;&#xa;YrlkIMkkrh1PrgHbXU3upRaDpEcl3O9y/CodoDSk9BgYH/6qzrrV/EFno76lc2VjGqDLRF33jnHp&#xd;&#xa;j9aj1TxVcWOl6TdpbxM18uXUk4XgdPzrW8SapJo2jy3sUayOhUBW6ckCpXu7h9EjvIBAsrQrKfOJ&#xd;&#xa;CKMZPTnpmufg8abdRt7e4NpcRznYGsyxKsSAM7scc1o+INfm0jUtPtorX7QLpiGA+9wR93nGee9M&#xd;&#xa;03WdXa4lbV9NWyso42czE9MevPpUV3r+pDSJNYtILRrADcgkZhIRnbyBx19+lbek6gmqabBexKyJ&#xd;&#xa;KMgN1GDj+lXKKKqar/yCbz/rg/8A6Cabov8AyBLD/r3j/wDQRV2sc/8AI4r/ANg8/wDowVsUUVka&#xd;&#xa;7pVndW1xdTRuZo4G2sJXXGASOAcVieCtKtL7RILy6SSS4EjfOZnHQ8cA4q5qPiS9tvEE+l2th9pZ&#xd;&#xa;Yd6bD8xbHGckcVm6zqt/L4fnk1zRY1VJoxHGzsA2d2TkHPGB+ddLfXU9po8dzbfZY1RVLm4Zgqrj&#xd;&#xa;2BPXFY+m+LjcazBYTG1mE4IR7QsQrejbsds9Kn1jxBe2niO20izgt3a4jDB5SwAJLen0ovNb1LSL&#xd;&#xa;uzXVILRobmTywbZmLA9vvYHUires62bK4hsLKIXGoz4KRHoF7s3tgHp6Vm6r4g1fR7yygvLexcXT&#xd;&#xa;7QYmc4wQD1A9ajT/AJKc/wD16/0FbF7rH/ExGl6cYZL/AAWZZSQiAAHkjnJBGKi0nW57jWrvSL6G&#xd;&#xa;Nbq3UPuhJKFcL3POfmHatyiisfVP+Q9on/XWb/0U1bFFFFFFFMkijlAEkauB03DNEcccS7Y0VBnO&#xd;&#xa;FGKfWPqH/IzaR/1zuP5JWxRRRRWDq+jXEuuWes2bRtNbIUaKQkBlw3TA6/NU39tXLcLomoBjwCyp&#xd;&#xa;gfX5ulZ0en6gfHEN/NAPKFqFeRDlA+DkDPPWmR6Zej4iS6gbd/shjwJe2dgH860PF+lNq+hSQxbz&#xd;&#xa;LG3mxqv8TAEY/Wm2eo3y2cFrHpF3HMsaoHmCiMEDGSQxOPwqjpWmXsPjvUL6W3ZbaWMhZOxPy/4G&#xd;&#xa;jUPD8UGuXGoy2tzfxXKj93A5Vkf16rxgevWr2gafBBdzXNvpklirpsbz3JkY5z/eI2/jnNb1FFFF&#xd;&#xa;YEn/ACP0P/YOb/0ZW/UV1/x6zf7jfyqj4b/5FzTv+vdP5CtOiiqWrveR2Ej2MEVxKOTFIThh6D3r&#xd;&#xa;B1OFdZsGsv7AuYJX+5K6IqRv2YlWzgZ9DUGs+HtRbwpYWsZS4urOTewDE7+T0yPfvik8Qare3HhS&#xd;&#xa;5ivdIureVkG98L5a/MO+7P6VBqGjXeqeFNDltFDm1iVmjz8zZC9Pyq74mnvdY0WWyt9Gv0kdlIMi&#xd;&#xa;oBwQezGjXtIvbrR9IEUbuLVUFxAjEM64UEDt2PeqGrWFzf6npDWOi3NtBaOofzFUcbl9Cc4ArW8R&#xd;&#xa;afd3XiPRLiCBpIoJCZWHRRlev5Vu6haLf2E9o7FVmQoWHUZFclb6Ha2VotleaJfXskeQ0sMh8t+c&#xd;&#xa;jA3j27V1Wk2v2LTYbcQxwhAf3cbFguST1PPerlFFVNV/5BN5/wBcH/8AQTTdF/5Alh/17x/+girt&#xd;&#xa;Y5/5HFf+wef/AEYK2KKKr6gjS6dcxoNzvEyqB3JBrJ8F2VxYeHore7iaKUOxKt15NV49Pux4/kvj&#xd;&#xa;A32U2+0S9s4HFS+N7G51DQTBZwtNL5qttXrjmqXiHR7m5udMna3lurSOMR3FtExDNwTnqBjp3qGS&#xd;&#xa;zubvxTpV1b6RcWltbja5kVR688E1Y1XTL2bx5p19Fbu1tFGoeQdAct/iKm8Y6fd30ulm1gaUQ3G5&#xd;&#xa;9v8ACOOah8QWWo2/imx1mythdJHH5TRqfmH3sn8m45rI8X3z32q6Lusrm22SnHnBfmyydME+lbq6&#xd;&#xa;fdjx+995DfZTb7fN7ZwOKi1fw5H/AG62rtDPeRyjbJbxNtcHACkYI44Oeat6Fp1vDfyXdvpUtkDG&#xd;&#xa;UZriRjIxyDwNxGOPrXQUUVj6p/yHtE/66zf+imrYooooooooorH1D/kZtI/653H8krYooooooooo&#xd;&#xa;ooooooooorAk/wCR+h/7Bzf+jK36iuv+PWb/AHG/lVHw3/yLmnf9e6fyFadFFFFFRXNtDd27wXEa&#xd;&#xa;yRPwyN0NLBDHbwpDCgSNAFVR0AqSiiiiiiiiiqmq/wDIJvP+uD/+gmm6L/yBLD/r3j/9BFXaxz/y&#xd;&#xa;OK/9g8/+jBWxRRRRRRRRRRVW+06z1FUW9t451Q5UOM4qC00LS7K4W4tbGGKVc7XVeRkYrRooooor&#xd;&#xa;H1T/AJD2if8AXWb/ANFNWxRRRRRRRRRWPqH/ACM2kf8AXO4/klbFFFFFFFFFFFFFFFFFFFYEn/I/&#xd;&#xa;Q/8AYOb/ANGVv1Fdf8es3+438qo+G/8AkXNO/wCvdP5CtOiiiiiiiiiiiiiiiiiqmq/8gm8/64P/&#xd;&#xa;AOgmm6L/AMgSw/694/8A0EVdrHP/ACOK/wDYPP8A6MFbFFFFFFFFFFFFFFFFFFFY+qf8h7RP+us3&#xd;&#xa;/opq2KKKKKKKKKKx9Q/5GbSP+udx/JK2KKKKKKKKKKKKKKKKKKKwJP8Akfof+wc3/oyt+orr/j1m&#xd;&#xa;/wBxv5VR8N/8i5p3/Xun8hWnRRRRRRRRRRRRRRRRRVTVf+QTef8AXB//AEE03Rf+QJYf9e8f/oIq&#xd;&#xa;7WOf+RxX/sHn/wBGCtiiiiiiiiiiiiiiiiiiisfVP+Q9on/XWb/0U1bFFFFFFFFFFY+of8jNpH/X&#xd;&#xa;O4/klbFFFFFFFFFFFFFFFFFFFYEn/I/Q/wDYOb/0ZW/UV1/x6zf7jfyqj4b/AORc07/r3T+QrToo&#xd;&#xa;oooooooooooooooqpqv/ACCbz/rg/wD6Cabov/IEsP8Ar3j/APQRV2sc/wDI4r/2Dz/6MFbFFFFF&#xd;&#xa;FFFFFFFFFFFFFFY+qf8AIe0T/rrN/wCimrYooooooooorH1eC+/tOwvLG3juPs6yq6PL5f3tuOcH&#xd;&#xa;0NH23XP+gNB/4G//AGFH23XP+gNB/wCBv/2FH23XP+gNB/4G/wD2FH23XP8AoDQf+Bv/ANhR9t1z&#xd;&#xa;/oDQf+Bv/wBhR9t1z/oDQf8Agb/9hR9t1z/oDQf+Bv8A9hR9t1z/AKA0H/gb/wDYUfbdc/6A0H/g&#xd;&#xa;b/8AYUfbdc/6A0H/AIG//YUfbdc/6A0H/gb/APYUfbdc/wCgNB/4G/8A2FH23XP+gNB/4G//AGFH&#xd;&#xa;23XP+gNB/wCBv/2FH23XP+gNB/4G/wD2FH23XP8AoDQf+Bv/ANhR9t1z/oDQf+Bv/wBhR9t1z/oD&#xd;&#xa;Qf8Agb/9hR9t1z/oDQf+Bv8A9hUFna6lP4lXUry0ito1tTAFWbzCTuznoK36jnUvBIi9WUgflWFp&#xd;&#xa;ra5YadbWn9kwSeRGse77ZjdgYzjbVn7brn/QGg/8Df8A7Cj7brn/AEBoP/A3/wCwo+265/0BoP8A&#xd;&#xa;wN/+wo+265/0BoP/AAN/+wo+265/0BoP/A3/AOwo+265/wBAaD/wN/8AsKPtuuf9AaD/AMDf/sKP&#xd;&#xa;tuuf9AaD/wADf/sKPtuuf9AaD/wN/wDsKPtuuf8AQGg/8Df/ALCj7brn/QGg/wDA3/7Cj7brn/QG&#xd;&#xa;g/8AA3/7Cj7brn/QGg/8Df8A7Cj7brn/AEBoP/A3/wCwo+265/0BoP8AwN/+wo+265/0BoP/AAN/&#xd;&#xa;+wo+265/0BoP/A3/AOwo+265/wBAaD/wN/8AsKiu59cubSaD+x4F82Nk3fbc4yMZ+5WppsL22m2s&#xd;&#xa;EmN8UKI2PUAA1ZrFv4dQi1xL6ytI7lPsxhZXm8vB3Zz0PpTvtuuf9AaD/wADf/sKPtuuf9AaD/wN&#xd;&#xa;/wDsKPtuuf8AQGg/8Df/ALCj7brn/QGg/wDA3/7Cj7brn/QGg/8AA3/7Cj7brn/QGg/8Df8A7Cj7&#xd;&#xa;brn/AEBoP/A3/wCwo+265/0BoP8AwN/+wo+265/0BoP/AAN/+wo+265/0BoP/A3/AOwo+265/wBA&#xd;&#xa;aD/wN/8AsKPtuuf9AaD/AMDf/sKPtuuf9AaD/wADf/sKPtuuf9AaD/wN/wDsKPtuuf8AQGg/8Df/&#xd;&#xa;ALCj7brn/QGg/wDA3/7Cj7brn/QGg/8AA3/7Cj7brn/QGg/8Df8A7Cj7brn/AEBoP/A3/wCwqIR6&#xd;&#xa;re6xp891YQ20NszszLceYTuQqONo7mt2iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiv//Z</binary>
<binary id="image14.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCADPAK0BAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/AOq1C/v01WKw0+G2d3ga&#xd;&#xa;ZmndlAAYDHAPrTd/iP8A54aX/wB/pP8A4mjf4j/54aX/AN/pP/iaN/iP/nhpf/f6T/4mjf4j/wCe&#xd;&#xa;Gl/9/pP/AImjf4j/AOeGl/8Af6T/AOJo3+I/+eGl/wDf6T/4mjf4j/54aX/3+k/+Jo3+I/8Anhpf&#xd;&#xa;/f6T/wCJo3+I/wDnhpf/AH+k/wDiaN/iP/nhpf8A3+k/+Jo3+I/+eGl/9/pP/iaN/iP/AJ4aX/3+&#xd;&#xa;k/8AiaN/iP8A54aX/wB/pP8A4mjf4j/54aX/AN/pP/iaN/iP/nhpf/f6T/4mjf4j/wCeGl/9/pP/&#xd;&#xa;AImjf4j/AOeGl/8Af6T/AOJo3+I/+eGl/wDf6T/4mjf4j/54aX/3+k/+Jo3+I/8Anhpf/f6T/wCJ&#xd;&#xa;qxpWpG+NxDImy4tX8ubbym7GflPUj6gVXf8A5HCD/rwk/wDRiVsUUUUUUUUUUUUUUUUUUUVz/h3/&#xd;&#xa;AJC+vf8AX2P/AEGrD/8AI4Qf9eEn/oxK2KKjjnhlJEUqOR1CsDipKKKazKgyzBQTjk45p1FFFFFF&#xd;&#xa;FFFNR0kGUZWHTIOadRXP+Hf+Qvr3/X2P/QasP/yOEH/XhJ/6MStiisHw3aW1veauYLeKMrdlAUQD&#xd;&#xa;C7EOPpk0seoateXl7b2cVqi20+wSzAlWG0HGAc5569MVZsb+5866tb5YmuLaNZC0AIVg2cAAknPy&#xd;&#xa;mqcOpapcIlzFJpwikAdbdtwmwedv3sbu3pmk8VG8fTrNoBFHm5hLrKCSG3rtHB7Hr+lGp6lq+k2c&#xd;&#xa;UtwlnPLLcxxKkKsuQc56nrwMdqlurzWbLT7u9uBZeXFC0iRhW3A9QGOcH3xWzExeJGPVgDWANfvD&#xd;&#xa;pumXKWqTS3czRtEh28Dd90k4B+UdaL/UNdsEjDQ2U81y/lwRxqww2M/MS2MYB6d6spealZ3dtHqX&#xd;&#xa;2SRLl/KT7OrAq2CcncTxgGl1DUrldRNjZyWkMiRrK73WdrAkgAYI54p+l6jNPdzWV01vJNGiy+Zb&#xd;&#xa;Z2bSSAOSTng/pVW01DWtR882sVpCsM8kW+YMRIAxAwA2QRjnPrxVqyvb2Zr2zlFv9utlUh1VvLJY&#xd;&#xa;ErxnPbmsbwcNV+wAxvZfZvtL7wyPv+982DnH0rrqK5/w7/yF9e/6+x/6DVh/+Rwg/wCvCT/0YlbF&#xd;&#xa;FYuhQ6hDc37XtokCXExmUrMHxwox09s5qzpdpLa3GovKABPcmRMHOV2qP5g0kNnOmt311wsc0MSI&#xd;&#xa;3Xld2ePxFZU2m3MrujaHZGdyQdQV1V9x/wCWoXGQc84zn3rU1DT5bnSoYBLvmgaOTc3/AC0ZCDg+&#xd;&#xa;mcde2ao6lb6pq1vbLLYpbNBeRS488PlRnJ6CtbVLP+0NNubPf5fnRlN2M4z3xVFbjWmUQLpsUHG0&#xd;&#xa;Tm4D7P8Aa24Gfpmq1lpF5DZaLFIF32k7vLhuxD9P++hWjqdpLc3emyRAFbe48x8nGBsYfzIo1O0l&#xd;&#xa;ubvTZIgCtvceY+TjA2MP5kVR1bSmk1Q3w0231LfEsXlTFV8vBJyCQc5z+lWdFsWt5JZjp1rp4cBf&#xd;&#xa;JhVSTj+IsAM9emOMe9S6LaS2dtOkwAZ7mWQYOflZyR+hotLSWLWtRunA8qdYghzydobP86paVa6h&#xd;&#xa;o+LKK1S5t2lLtceaEKhjk/Jg5x9ea3qK5/w7/wAhfXv+vsf+g1Yf/kcIP+vCT/0YlbFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFc/4d/5C+vf9fY/9Bqw/wDyOEH/AF4Sf+jErYooooooooooooooooooorn/AA7/AMhf&#xd;&#xa;Xv8Ar7H/AKDVzUNLnudQjvbW/a0lSIxHESvlSQe/0FR/2bq//Qef/wABY6P7N1f/AKDz/wDgLHR/&#xd;&#xa;Zur/APQef/wFjo/s3V/+g8//AICx0f2bq/8A0Hn/APAWOj+zdX/6Dz/+AsdH9m6v/wBB5/8AwFjo&#xd;&#xa;/s3V/wDoPP8A+AsdH9m6v/0Hn/8AAWOqepx6xYwRlNbd5ZpBDEDaxgbz0yew4p+nRapqFjFdRa7K&#xd;&#xa;Ekzw1pHngkH+VWf7N1f/AKDz/wDgLHR/Zur/APQef/wFjo/s3V/+g8//AICx0f2bq/8A0Hn/APAW&#xd;&#xa;Oj+zdX/6Dz/+AsdH9m6v/wBB5/8AwFjo/s3V/wDoPP8A+AsdH9m6v/0Hn/8AAWOj+zdX/wCg8/8A&#xd;&#xa;4Cx1Lo+ktpr3ckl01zLdSCR2KBecY6CtOiiiiiiiiisfVP8AStY06xPyqpN3vHXKEDb+O79KPDv7&#xd;&#xa;iG504crZTeWH7vkB847fex+FbFFFFFFFFFFFFFFFFFFFFYXh6NprrUNUGPIvXVoQfvAKCpyO3IqW&#xd;&#xa;5/0XxLbXD/6u5h+zKF678lsn2wK2KKKKKKKKKKKKKKKKKKKjnjaWB40laJmGA6YyvuM1zd9pNzou&#xd;&#xa;hXElnrF6FtomdEITGeT/AHfWrJ0Ca6FvNNrN8zxkSIcR/KxGM/d9Ca3lGFAJJwOp70tFFFFFFFFF&#xd;&#xa;FFFFFFFFFZfib/kW9R/693/lWhb/APHvF/uD+VSUUUUUUUUUUUUUUUUUUUVl+Jv+Rb1H/r3f+VaF&#xd;&#xa;v/x7xf7g/lUlFFFFFFFFFFFFFFFFFFFZfib/AJFvUf8Ar3f+VaFv/wAe8X+4P5VJRRRRRRRRRXPa&#xd;&#xa;tZnUvElvaPdXUEQtHk/cSlMkOo5/M0v/AAikH/QT1X/wKP8AhR/wikH/AEE9V/8AAo/4Uf8ACKQf&#xd;&#xa;9BPVf/Ao/wCFH/CKQf8AQT1X/wACj/hR/wAIpB/0E9V/8Cj/AIUf8IpB/wBBPVf/AAKP+FH/AAik&#xd;&#xa;H/QT1X/wKP8AhR/wikH/AEE9V/8AAo/4Uf8ACKQf9BPVf/Ao/wCFJJ4QtZUZJNR1R0YYKtckgj8q&#xd;&#xa;UeE7cDA1PVQB/wBPR/wo/wCEUg/6Ceq/+BR/wo/4RSD/AKCeq/8AgUf8KP8AhFIP+gnqv/gUf8KP&#xd;&#xa;+EUg/wCgnqv/AIFH/Cj/AIRSD/oJ6r/4FH/Cj/hFIP8AoJ6r/wCBR/wo/wCEUg/6Ceq/+BR/wo/4&#xd;&#xa;RSD/AKCeq/8AgUf8KP8AhFIP+gnqv/gUf8Kb4VR4bvV7ZrieZILgIhmcuQNvrVp/+Rwg/wCvCT/0&#xd;&#xa;YlbFFFFFFFFFFFFFFFFFFFFc/wCHf+Qvr3/X2P8A0GrD/wDI4Qf9eEn/AKMStiiiiiiq8d5FJfTW&#xd;&#xa;a7vNhRXbjjDZx/I0PeRJfx2Z3ebJG0i8cYBAP8xRPeRQTwwtuaWU4VEGSB3Yj0HGT706FrhpphLE&#xd;&#xa;iRKR5TK+SwxzkY4qaimu21GbrgZqtpV4dQ0y2vCnlmaMPtznGferdFFFFFc/4d/5C+vf9fY/9Bqw&#xd;&#xa;/wDyOEH/AF4Sf+jErYooooorH1v/AEW6sdRXkxyiEp03eYQuSfbrWRewTXxutUt2xbx3ccnJwwSI&#xd;&#xa;ESDH1HTvWpZTLqevvdJlEtIFVQf4xKFfJ9MYpmhszeIdeBYkLLFgE9Pkqn4d0WDUNHhn1FnuSxby&#xd;&#xa;wWZPLXceODzzk5PrUsV82k2WsCJS8NlMqQxlvugqp6nJ6sTzVpvDdg0DPdq9xclSZJvMZd7euAcC&#xd;&#xa;pvC//Itad/1wX+VatFFFFFc/4d/5C+vf9fY/9Bqw/wDyOEH/AF4Sf+jErYoooooqG7t1u7SW3ckC&#xd;&#xa;RCuR1GR1HvRbW6W9rHbr8yogXkfe46motOsY9PgaKNi252cs3Xkk4+gzimWemx2d9e3SOzNdsrMD&#xd;&#xa;0XAxxUmm2SadYx2kbs6x5wW6nJJ/rUJ0i3cXyy7pEvXDup4wQABjH+6DVc6LcTAx3erXNxA3DxMi&#xd;&#xa;KG/FQD+Rq/p1mun2EFpGxZYUCBm6nFWaKKKKK5/w7/yF9e/6+x/6DVh/+Rwg/wCvCT/0YlbFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFc/wCHf+Qvr3/X2P8A0GrEhA8YQZOP9Ak/9GJWtvX+8Pzo3r/eH50b1/vD86N6&#xd;&#xa;/wB4fnRvX+8Pzo3r/eH50b1/vD86N6/3h+dG9f7w/Ojev94fnRvX+8Pzo3r/AHh+dG9f7w/Ojev9&#xd;&#xa;4fnRvX+8Pzo3r/eH50b1/vD86N6/3h+dG9f7w/Ojev8AeH51g+HOdW17H/P0P/Qa077SbDUXV720&#xd;&#xa;inZBhS4zgVW/4RjRP+gZb/8AfNH/AAjGif8AQMt/++aP+EY0T/oGW/8A3zR/wjGif9Ay3/75o/4R&#xd;&#xa;jRP+gZb/APfNH/CMaJ/0DLf/AL5o/wCEY0T/AKBlv/3zR/wjGif9Ay3/AO+aP+EY0T/oGW//AHzR&#xd;&#xa;/wAIxon/AEDLf/vmj/hGNE/6Blv/AN80f8Ixon/QMt/++aP+EY0T/oGW/wD3zR/wjGif9Ay3/wC+&#xd;&#xa;aP8AhGNE/wCgZb/980f8Ixon/QMt/wDvmj/hGNE/6Blv/wB80f8ACMaJ/wBAy3/75o/4RjRP+gZb&#xd;&#xa;/wDfNH/CMaJ/0DLf/vmrljp1npyMllbxwK5ywQYyatUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUV//2Q==</binary>
<binary id="image15.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAGIAqkBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKoyaxpcUjRyalZo6EqytOoII6gjNN&#xd;&#xa;/tzSf+gpZf8AgQn+NH9uaT/0FLL/AMCE/wAaP7c0n/oKWX/gQn+NH9uaT/0FLL/wIT/Gj+3NJ/6C&#xd;&#xa;ll/4EJ/jR/bmk/8AQUsv/AhP8aP7c0n/AKCll/4EJ/jR/bmk/wDQUsv/AAIT/Gj+3NJ/6Cll/wCB&#xd;&#xa;Cf40f25pP/QUsv8AwIT/ABo/tzSf+gpZf+BCf40f25pP/QUsv/AhP8aP7c0n/oKWX/gQn+NH9uaT&#xd;&#xa;/wBBSy/8CE/xo/tzSf8AoKWX/gQn+NWbW8tbxWa0uYZ1U4JicMB+VT0UUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVhaBa280d+8tvE7fb7jlkBP3zWp9gs&#xd;&#xa;/wDn0g/79j/Cj7BZ/wDPpB/37H+FH2Cz/wCfSD/v2P8ACj7BZ/8APpB/37H+FH2Cz/59IP8Av2P8&#xd;&#xa;KPsFn/z6Qf8Afsf4UfYLP/n0g/79j/Cj7BZ/8+kH/fsf4UfYLP8A59IP+/Y/wo+wWf8Az6Qf9+x/&#xd;&#xa;hR9gs/8An0g/79j/AAo+wWf/AD6Qf9+x/hR9gs/+fSD/AL9j/Cj7BZ/8+kH/AH7H+FH2Cz/59IP+&#xd;&#xa;/Y/wrO0aNItb1tI0VFEsWFUYA/dLW1RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRVa8vrayUG&#xd;&#xa;4mRWYHZHkb5COyjqx6cD1FVINdtJZAkqXFoD917qIxKx/ugtjJ9vY1qUUUyOWOUuI5Fco21tpztP&#xd;&#xa;ofQ8in1l2+r+e+lr5G3+0Ldpvv58vCqcdOfve3StSiisi81z7LFqz/Z939nbeN+PMyob046+9a9N&#xd;&#xa;Z0RkVmVS52qCcbjgnA9eAT+FVYL7ztTu7Ly9v2ZI237vvb93btjbVyiiiiiiiiiiiiiiisfw5/qL&#xd;&#xa;/wD7CFx/6Ga2KKjuJfJt5ZcbtiFsZ64Ga5HQ5Ytcj+13uuSxXNy52WkF2Y/LAJAG0HnIGeg61T8T&#xd;&#xa;WmoWOg6lFdTSTWpuY2tmllLvjnIJP0H61vw+I7G1soPMW4aFY0U3CRFoskAff6deD78Vq3N9FBaL&#xd;&#xa;cqsk8bYK/Z0MhYHoQB1HvVJPEdkbmKCaO6tTMSqNcwNEpOM4y3FSXOvWNrfyWMjP9pSPzAirkuPR&#xd;&#xa;fU+wqTTdXtNTMqwMyyRNteKVdjr05KnnHNR3uu2dnefYyJp7gLvaO3jMjKOOoHTqPzq3Y3tvqFpH&#xd;&#xa;c2siyRSAEEHp7H0PtViiisfSv+Q9rn/XWL/0UtbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FZbQx3PiJjOgc2lvG8Of4GdnDH/xxfpjirl5Z299B5NzGJE3BgM4wQcg5FZOparFFfPDLqktsiAb&#xd;&#xa;RbW5kJPfcSjD0xjHfNMs9Wu7vR76azP2iS3uPKjd02syfISxHHIDMeg6DirOnTPcsktpqsl0m7Ek&#xd;&#xa;dxEqEL3IAVTnOOTxyaq6BaT/AGrUm/tG4wl+25dseJPlTr8vfpxiuiqrHp1rE1oyRYNpGYofmPyq&#xd;&#xa;QAR78KOtV9Aupr3SY57h98hklUnAHAkYDp7AVnrqGoyWcpgmj8/+0nt0MifLsDEAHHsPrVq8kutI&#xd;&#xa;iF3JeSXcAdVkSVUDfMQoKlVHcjOc8Vcm0uznW7WWLcLzHn/MRuwAB344A6VcrI1mCWW+0ry7uWDN&#xd;&#xa;ww+QIcHypDn5lPPGPTmqFna3v/CS6nEmoSbfKgMkpRPM6PgD5duOueKvRXk9nqdzZzTPcxxWgud7&#xd;&#xa;qofO5ht+UAY+X0zz1rLTxElxB9pXUpIZWG6O3+yM0YB6BjsJJ9SGx6V0enXYv7CG6Ebxeau7Y/Vf&#xd;&#xa;rVmiiiiiiqf9oR/2uNOAzJ5JmJBHABAwf++quUUUUVj+HP8AUX//AGELj/0M1sUVHO4jgkcrvCqS&#xd;&#xa;V9eOlcjYaN4a1XT1vo4msZpSxBFyQ8ZDEZwTgdPSsG8Mv/CMaqI55rjThdxfZpZvvNwd3UA/3fb9&#xd;&#xa;a6fxOix/D+VUUKvlQ8AYH31qvc6peWGleGLa1cQxXccSTTbQSgwg4zkD7x6jtVHxg6i50yL+0prx&#xd;&#xa;xOrYZU2qM46qoGfbNaiNCnxGuWnMagWIKlyODuXpnv1qMf6b8QoLjT/nt7eApdOnC7sP1/vdV6Zq&#xd;&#xa;r4dhkttX1O3vb+axvDJvAxGd6cc7mU+q8A/hxW14attNt59QGnXs9yxl/fCQYVWy2duFA656egrf&#xd;&#xa;oorH0r/kPa5/11i/9FLWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWZqNldveQ3tjMqSQqw&#xd;&#xa;kiK8XA6hSc8Y+bBwcbiaryjWdSQQPCumKGVzMk3mswBB2gDGM+vtjHNJFHqelyXEVrYx3kUs7ziQ&#xd;&#xa;ziPG9s7cYPT1pdMsNSs7TUA80RuprozJIE+VhhB93PGdpHXjrTY7a+vNShuZrCLT3jYM88cwkaZR&#xd;&#xa;x5ZwAcc57j5RxUsEF9p+oTrBbJc293cec8plCGLICkbcHdgLntnOK2KKwbSLVdLh+w21lHcRK7Fb&#xd;&#xa;kzhPvMWzswem7HXnHvVb7LfabpqCREuLptSMqgNsEm5ic99ufTtV54dQ1YCDULRLO2DB3CzCQyEH&#xd;&#xa;IAOBtwQD3z0rZoqjqkM7rbz2sYlltpfMWIttD5Rkxu7ffz+GO9VdIgvv7Uv729tktvPSJURZRJ93&#xd;&#xa;dnnA9RUr2Ekmuz3DgfZ5bNYMg853MT+hFQR/2rpka2drYx3lvEAsUhnEZCjgKRg5IHfvWrbrKkCL&#xd;&#xa;cSLLKB8zqu0E/TJxUtFFFFFFcpbsiy/8JGw8tZ7rZKAMsqBWhC5/iBcI2O34Zrq6KKKKx/Dn+ov/&#xd;&#xa;APsIXH/oZrYoorPbQ9JdizaZZlickmBck/lU72FnJaravawtbr0iMYKj8OlPmtoJ7c280MckBABj&#xd;&#xa;ZQVwOnH4U2WytZrVbaW2he3UALEyAqAOmB04qJdI01Y1jWwtQivvVREuA3qBjrwOaypNB+1eLZr6&#xd;&#xa;8toJ7NrYIokAb58jsfbPNbdraW1lGY7S3igQncVjQKCfXA+lMutOsr1la7s4J2UYUyxhiB+NSW1t&#xd;&#xa;BaReVbQxwx5zsjUKM/QVNRRWPpX/ACHtc/66xf8Aopa2KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKazKi7mYKPUnFOoqG3uobpZDA+8RyNG3BGGU4I596moopu5d+zcN2M4zzimyRRy7PMUNsY&#xd;&#xa;MuexHepKKKKKKKKKKKKKKzfEDqui3UWcSXEbQRD+9I4IUe2Saybu2D6lFBNHkppLHb6MroR+RArb&#xd;&#xa;0aZ7jRrKWV98rQIZCeu7aM5981dooorl9I1uwsTqEFzK6yC/nOBC7fxnuARWh/wk+k/8/Ev/AIDy&#xd;&#xa;f/E0f8JPpP8Az8S/+A8n/wATR/wk+k/8/Ev/AIDyf/E0f8JPpP8Az8S/+A8n/wATR/wk+k/8/Ev/&#xd;&#xa;AIDyf/E0f8JPpP8Az8S/+A8n/wATR/wk+k/8/Ev/AIDyf/E0f8JPpP8Az8S/+A8n/wATR/wk+k/8&#xd;&#xa;/Ev/AIDyf/E0f8JPpP8Az8S/+A8n/wATR/wk+k/8/Ev/AIDyf/E0f8JPpP8Az8S/+A8n/wATR/wk&#xd;&#xa;+k/8/Ev/AIDyf/E0f8JPpP8Az8S/+A8n/wATR/wk+k/8/Ev/AIDyf/E1D4fuobzVdZuLdi0byxYJ&#xd;&#xa;UqeI1HQ89q3qKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKoa1dCy015zEkwDxrsfocuo/TOf&#xd;&#xa;wqHVdUnsr6ztLe2M73SybeeFK7cE/wCz83J7Ckgv76G+gttTgt0NyWWI27luQpY7sgYGB71m6RNq&#xd;&#xa;edQTT7a3ZFv59zXDsuSXP3cA5rUt9YT7HNJdJtmt5fIdI+d8mAQqZ65yAM45qMajf2v7/U7aCKzP&#xd;&#xa;8cTlmj9C4IAAx1wTzikn1W9bVrnT7K0SSSJI3EkjEIN2chiMkHjjj1qSyvLh9WNpeW8CXAtVlZ4m&#xd;&#xa;LdXYAZIBxgZ+pNZ0U2tf8JHqiW8Vo4VYsLJM4AX59pGFPJHX+tadxcas87rYWlv5SHaWuZGQsfVc&#xd;&#xa;A5Xkc+uarT+INmnWV5DayTfaLjyGjUfNkbwcDPPKflT/AO0NTs5YTqVvarBLKsINvIzMGY4HBA4q&#xd;&#xa;e7v7hrhrXTIopriPBlMrFUQY6EgE7jkEDHTNQ/2pdw/6Nc2qi/f/AFSxkmN/fJwcLxu44z3qa0v7&#xd;&#xa;hbhbXU4oobiTJiMTFkcY6AkA7hgkjHTFaVFFFFFFFZOoq13rVha4LwRAzzKP4WBHlEn6hvrip2sp&#xd;&#xa;Tr8d9lfKW1aEjPO4up/Lg1W0f/R9T1OxHzKkguNx6kyliR+GK2KKKKx/Dn+ov/8AsIXH/oZrYooo&#xd;&#xa;ooooooooooorH0r/AJD2uf8AXWL/ANFLWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWV4l&#xd;&#xa;ikm0WRIo2kcyxHaoyeJFJ/Si9ikbxHpcixsY0inDMBwudmMnt0NGpRSPrWjukbMkcspdgMhcxsBn&#xd;&#xa;05o0CKSKG9EkbIWvp2G4YyC5wfpWa2kyX9rqkTxHH9peesbggTKqp8uewOCM9qrmz0ST91F4euGu&#xd;&#xa;DwEeKREJ9N54x71tWUUi+I9UkaNhG8UAViOGxvzg9+ooSKT/AISuWXy28s2KKHxxnzHOM+tQSzHS&#xd;&#xa;9bvLqeC4kiuo4ljMETSHKbs5x0+8P1rJhtbARKmq6TdXOpYxNIIHKu/+8OMe9S6faXEei6FGbWSN&#xd;&#xa;otQZnj2k+WuZeT7cjn3FbGvxSSw2QjjZyt9Ax2jOAHGT9KjkLaRqV5dvDNPBeMpzDGXZGVQoG0ZJ&#xd;&#xa;BAJz26VR1GEa1LBfS6dLJaWgYeVKrK8gbG4hcZ+XbwP4s9qfpVtpf9pQyafo00LpktNNG8ewEEcb&#xd;&#xa;vvZ6fjXSUUUUUUUVVt7Vo7y4uZJA7y7UXC42ouSB7nLNz7j0qUzKLkQbX3FC+7aduAQMZ6Z56VBP&#xd;&#xa;Y+dqlpeiTb9nSRSmPvbtvf22/rVyiiisfw5/qL//ALCFx/6Ga1J5oreJpZ5UijXq7sFA/E1jXGtW&#xd;&#xa;za3YpBqEDW3lTNPtlUqMbdpJ7dTWqL6za6+zLdwG4zjyhIN/r060yfU9Pt5WinvraKReqPKqkfgT&#xd;&#xa;VhpY1kSNpFEjglVJ5bHXA79RR5sfmiLzF8wruCZ5x0zj0qtfahFaW1w4ZJJoUyIQ4DMxB2r9WIwP&#xd;&#xa;WnWSSmzBnkcySjec8bMjoB2xUVhNIlzNZXEokkj+aNjwzofbvjgE+vpV+iiiiisfSv8AkPa5/wBd&#xd;&#xa;Yv8A0UtbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFQm5hF&#xd;&#xa;2LQv+/aMyBMH7oIBP5kVNRRRRWP4c/1F/wD9hC4/9DNE4Fz4lFtcgPbx2yyxo33S5Zgc/wB7gDg9&#xd;&#xa;OtYXjWC2gaNbeKKNvslxuCKAf4MZx+NdRHZ2WnwebHbqPJUneRufGOfmPJP41jR218IBKmmaU0Tf&#xd;&#xa;OHnmZmweeSVPr68VBaO6+H9Bv9zG4SRIzIxzhHYB859gOe1WftEpuTrzBvswk8lF2/OIj8rDHT/W&#xd;&#xa;hWzn7o/CqkwMyfbJBmWTWIot/TMaSkJ7dD17119Y7/8AI4w/9g+T/wBGJWxRRRRRWPpX/Ie1z/rr&#xd;&#xa;F/6KWtiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisHxLq9tDot8tvqEKXaIQqpMA4YHp&#xd;&#xa;gHOa17Z2Zp91xHNtlIAQY8sYHynnr3/EUlzfWloyrdXUEBYZAkkC5/OpPOi8jz/NTydu/wAzcNu3&#xd;&#xa;Gc59Md6gh1OwuJVigvraWRuiJKrE/gDSy6jYwgGa9t4wWK/PKo5HUdeo71Jc3dtaKrXVxFAGOAZH&#xd;&#xa;C5/OgXds1t9pW4iNvjPmhxs9OvSkW9tXuTbJcwtOvWISAsPw60kF9aXErRQXUEsijLIkgYjtyBVi&#xd;&#xa;iiiiiiiiiisd/wDkcYf+wfJ/6MStiiiiisfw5/qL/wD7CFx/6GavX1jFfRhZC6OpyksbbXQ99rds&#xd;&#xa;jj6Gs+XwxYTr++aeWQo0bSvJl2VscFu+McenNbDKrqVYAqRgg9xWWPD9vv8A3l1eSxZ5gknLRkeh&#xd;&#xa;Xpj2qzHpdvFpB0xd/wBnMRi5PO0gg8/jU/2dPsn2bny9nl9ecYxVabTIn0cafEdgjiCQyMNxjYDC&#xd;&#xa;sPccGn2Nw7WZ86OVZIPkfKkliAOR659qi06N57iXUJojG0oCxK4+ZY/6Z4JXsa0aKKKKKx9K/wCQ&#xd;&#xa;9rn/AF1i/wDRS1sUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVl+I5JYtFmaEkMXjUkf3S&#xd;&#xa;6hv0Jqr4mjt4PCV2kQRYxAFjx6cYA/CptA/1+sf9hB//AEBKrWr6jfNNf6bHp8cU7kHz1cuSnyc4&#xd;&#xa;OP4e3bFZ2kNJLe2sNyyPG15dvIE+4ZFdSpH4k4rY1PYPEGiKNobzJTgdceU1M8NW0KnU5xGPNkv5&#xd;&#xa;g7eoDnH8zSM97falczabHZKbdvsrtcqxZiPm4wcY+Ye/Wse6M50rxR9paFpR5e4wZ2fcXpn/ADmt&#xd;&#xa;bxBY20emWNokKrAbyCMoP7pcAir19GkV3pCxqFAuSAB6eTLWlRRRRRRRRRRVU2UZ1Nb/AHN5iwmE&#xd;&#xa;L2wWBz9eKtUUUUVj+HP9Rf8A/YQuP/QzWxRRRRRRVC7vZBdpZWiq1yyiRi/3Y0yeT65wQMd8Z4qa&#xd;&#xa;+kuooRJaRLMytl4zwWXnhTkDOcdeOtPtbmG8to7i3ffFIMq2CMj8amoooorH0r/kPa5/11i/9FLW&#xd;&#xa;xRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTWVXUqwBUjBB7isibwzY3EckU0lxJA4wkLS&#xd;&#xa;ZSL02DouBwMdAcVo2tnFaNcNFuzcSmV8nPzEAcfkKpS6DC8jNFd3tshOfKt5yiA98AdMnk+5NMn0&#xd;&#xa;qGy0qSCztt8fmmbYpwyZOSY+OGH8Pvjmqel6Z5+o29+Y7uMWxbD3pzM5Kkbf9wZyOeueK3LOzis1&#xd;&#xa;lWHdiWV5Wyc/Mxyaq3Wiw3E7Sx3N3al+XW2lMYZv7xA6noM+wpg8P2C2t5bIjLHeY80KcdABke5x&#xd;&#xa;k+9XbyzivFiWbdiKVJVwcfMpyKdNbpNJBI+d0DmRMHvtZf5MamooooooooooqImb7SAFTyNhJbcd&#xd;&#xa;27IwMemM1LRRRRWP4c/1F/8A9hC4/wDQzVfW9Rl/tP8As1Yb1ozAszPZD95yxGM5G0fL179KzL7U&#xd;&#xa;L+10q7jt4dTSIQs/n3fDxsMYwwJzn8MYroYtONvcfbZ9QunZQWdTKRF0/udAKxZpWuZWmdPERLHI&#xd;&#xa;Nv8AJGR2wN3pj69aFu7i/wBPsLy+kvY4JIAzSWLFFjbJ3tJz93G3HXo1Xpb8ab4dkvbO5bUIQyiJ&#xd;&#xa;nbexy4U/N/FyT+WKofaruBmuYLbXZbnlvLmTMTH027vlH54rS8PM1xPqVxOv78XJiBbkouxDsz6A&#xd;&#xa;k8e5rbrH8PfL/aUK8RQ3rRxIOiLsQ4A7Dk/nWxRRRRWPpX/Ie1z/AK6xf+ilrYoooooooooooooo&#xd;&#xa;ooooooooooooooooooooooooooooooooooooooooooooooooqqb1BqiWGxt7QtNu7YDAY/WrVFFF&#xd;&#xa;FY/hz/UX/wD2ELj/ANDNWb6ylecXli6R3irs/eZKOuTw2OcDJIxjmqF7pmranYXNveXNtGXjKIsA&#xd;&#xa;YKSe7ZyeMcY9TW1NGJoZImJAdSpI9xWUlrrexbZrizitwNnmRK3mhR0Izxn8KjtNN1XTtOtbaznt&#xd;&#xa;XMcQjkWdWK5BPK4wec859B71Pb6Pvguvt5R5btlaRYshFK4Clc89gee9N8jXP9R9ptPI+55u1vO2&#xd;&#xa;9N393djnpjPakt1Oj6jKkjE2l23m+e/aUjBBPQDCrjPUnFaV5dw2UBlmJxnAVRlmPoB1J9hVXRbS&#xd;&#xa;a2tZJLkBbm5kM0yqcqrEAYHt8orRoooorH0r/kPa5/11i/8ARS1sUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVjv/yOMP8A2D5P/RiVsUUUUVj+HP8AUX//AGEL&#xd;&#xa;j/0M1sUUUUUUU140kXbIiuvBwwyKHjRypdFbady5GcH1FOooooorH0r/AJD2uf8AXWL/ANFLWxRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUfkxGcT+WvmhSgfH&#xd;&#xa;O3OcZ9MgVJRRRRXPWX9r6c93HHpSzxyXUsyv9pVchmJHGKs/2hrX/QDX/wADF/wo/tDWv+gGv/gY&#xd;&#xa;v+FH9oa1/wBANf8AwMX/AAo/tDWv+gGv/gYv+FH9oa1/0A1/8DF/wo/tDWv+gGv/AIGL/hR/aGtf&#xd;&#xa;9ANf/Axf8Kqad4i1DU4pZLTRQyxSmJs3SjDDGe3vVv8AtDWv+gGv/gYv+FH9oa1/0A1/8DF/wo/t&#xd;&#xa;DWv+gGv/AIGL/hR/aGtf9ANf/Axf8KP7Q1r/AKAa/wDgYv8AhR/aGtf9ANf/AAMX/Cj+0Na/6Aa/&#xd;&#xa;+Bi/4UuiwXi3mo3d7bi3NzIjKgkD4CoF6j6Vr0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVG08KM&#xd;&#xa;VeVFI7FgKcjq67kYMPUHNKGDZwQcHBx2pjTwoxV5UUjsWAoSaJ22pKjH0DA08kAgEgZ4HvQSFBJI&#xd;&#xa;AHJJqP7TB/z3j/77FPR1ddyMGHqDmlDBs4IODg47Uxp4UYq8qKR2LAUJNE7bUlRj6BgaeWAIBIBP&#xd;&#xa;QetI7qi7nYKPUnFM+0wf894/++xT1ZXUMjBge4OaUMGzgg4ODjtTGnhRiryopHYsBQk0TttSVGPo&#xd;&#xa;GBp5YAgEgE9B60jukYy7Ko6ZY4pn2mD/AJ7x/wDfYp6srqGRgwPcHNKGDZ2kHBwcUxp4UYq8qKR2&#xd;&#xa;LAUJNE7bUlRj6BgaeWAIBIBPQetI7pGMuyqOmWOKZ9pg/wCe8f8A32KF+eQSpMTHtI2DBUnPXPX2&#xd;&#xa;61LRRRRRRRRRRRVPV7h7XSLyeFgsscLtGcZ+YKccd+ayrGMadqlhtG2K+twgRe0gDOzH6jj8K6Gi&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisn+wrOe+vbi+s7edppQyM6BiFEaLjn3U/nWh&#xd;&#xa;a2tvZw+Tawxwxg52IuBmnRQxQmQxRqhkbe+0Y3N0yffgVVudG0y7nae5sLeWVsbneMEnAx1pbXSN&#xd;&#xa;Os5vOtbG3hkAxvSMA4q08aOyM6hjG25CR904IyPwJH40SxpNE8Uqh43UqysMgg9Qaz/+Ee0b/oF2&#xd;&#xa;n/fpau2trb2cPk2sMcMYOdiLgZp0UMUJkMUaoZG3vtGNzdMn34FVbnRtMu52nubC3llbG53jBJwM&#xd;&#xa;daW10jTrObzrWxt4ZAMb0jAOKsvDFJJHI8as8RJRiOVJGDj8KbdWtveQ+TdQxzRk52OuRmqX/CPa&#xd;&#xa;N/0C7T/v0tXra3htIFgtokiiXO1EGAMnPSlihihMhijVDI299oxubpk+/Aqrc6Npl3O09zYW8srY&#xd;&#xa;3O8YJOBjrS2ukadZzeda2NvDIBjekYBxVl4YpJI5HjVniJKMRypIwcfhTLuztr6IRXcEc8YbcFkU&#xd;&#xa;MAfX9TVP/hHtG/6Bdp/36Wr1tbw2kCwW0SRRLnaiDAGTnpSxQxQBhFGqB2LttGMseSfqaq3OjaZd&#xd;&#xa;ztPc2FvLK2NzvGCTgY60trpGnWc3nWtjbwyAY3pGAcVZeGKSSOR41Z4iSjEcqSMHH4Uy7s7a+iEV&#xd;&#xa;3BHPGG3BZFDAH1/U1T/4R7Rv+gXaf9+lq9bW8NpAsFtEkUS52ogwBk56VLRRRRRRRRRRRWPrX+kX&#xd;&#xa;+mWA+UvN9p39ceUVOMe+afr8TrbxX0Clri0cMg6jDEK5I9lLGtKKVJokliYPG6hlYdCD0NPooooo&#xd;&#xa;ooooooooooooooooooooooooooooooooooopiOzPIGjZQjYBOPmGAcj8yPwp9FFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFYs9jqkWr3N5YPZlJ0RSs4YlduemPXNVYLjX9SjvYB/ZqCKRrdyR&#xd;&#xa;JydoORz/ALVa2jW1zZ6Xb2t00TPAgjBizgqAAOvfir1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFMSRJGdUYM0bbXAP3TgHB/Ag/jT6KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKx&#xd;&#xa;9A/1+sf9hB//AEBK2KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKz9N/4/dW/6+l/9ExV&#xd;&#xa;oUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVj6B/r9Y/7CD/+gJWxRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRVe3thBNdSBt32iUSEY+7hFXH/jufxqxRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRWPoH+v1j/sIP/6AlbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFMQSB5C7KVLfIAMYGBwfXnP50+iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisfQP8A&#xd;&#xa;X6x/2EH/APQErYoooooooooooooooooooooooooooooooooooooooooqCC5WeW5jVSDbyCNie5KK&#xd;&#xa;3H4MKnoooooooooooooooooorLutWlhvJLaDTbm6MYUs0ZQAZGcckVH/AGxe/wDQCvv++o//AIqj&#xd;&#xa;+2L3/oBX3/fUf/xVH9sXv/QCvv8AvqP/AOKo/ti9/wCgFff99R//ABVH9sXv/QCvv++o/wD4qj+2&#xd;&#xa;L3/oBX3/AH1H/wDFUf2xe/8AQCvv++o//iqP7Yvf+gFff99R/wDxVH9sXv8A0Ar7/vqP/wCKo/ti&#xd;&#xa;9/6AV9/31H/8VR/bF7/0Ar7/AL6j/wDiqP7Yvf8AoBX3/fUf/wAVR/bF7/0Ar7/vqP8A+Ko/ti9/&#xd;&#xa;6AV9/wB9R/8AxVH9sXv/AEAr7/vqP/4qj+2L3/oBX3/fUf8A8VR/bF7/ANAK+/76j/8AiqP7Yvf+&#xd;&#xa;gFff99R//FUf2xe/9AK+/wC+o/8A4qj+2L3/AKAV9/31H/8AFUf2xe/9AK+/76j/APiqP7Yvf+gF&#xd;&#xa;ff8AfUf/AMVWZo2p3ccupldHu5N96zEKyfIdifKct14/WtP+2L3/AKAV9/31H/8AFUf2xe/9AK+/&#xd;&#xa;76j/APiqP7Yvf+gFff8AfUf/AMVR/bF7/wBAK+/76j/+Ko/ti9/6AV9/31H/APFUf2xe/wDQCvv+&#xd;&#xa;+o//AIqj+2L3/oBX3/fUf/xVH9sXv/QCvv8AvqP/AOKo/ti9/wCgFff99R//ABVH9sXv/QCvv++o&#xd;&#xa;/wD4qj+2L3/oBX3/AH1H/wDFUf2xe/8AQCvv++o//iqP7Yvf+gFff99R/wDxVH9sXv8A0Ar7/vqP&#xd;&#xa;/wCKo/ti9/6AV9/31H/8VR/bF7/0Ar7/AL6j/wDiqP7Yvf8AoBX3/fUf/wAVR/bF7/0Ar7/vqP8A&#xd;&#xa;+Ko/ti9/6AV9/wB9R/8AxVH9sXv/AEAr7/vqP/4qmT69c28Ek82iXqxxqXdi0fAAyT96teGQTQRy&#xd;&#xa;qCA6hgD7ipKKKKKKKKKKKKKKKKKKKKz9N/4/dW/6+l/9ExVoUUUUUUUUUUUUUUUUUUVn2f8AyF9R&#xd;&#xa;/wC2X/oNaFFFFFFFFFFFFFFFFFFFFFFY+gf6/WP+wg//AKAlbFFFFFFFFFFFFFFFFFFFFZ+v/wDI&#xd;&#xa;v6l/16y/+gGrGn/8g+2/65L/ACFWKKKKKKKKKKKKKKKKKKKKjjhjieV0XDStvc+pwFz+Sj8qkooo&#xd;&#xa;ooooooooooooooorPs/+QvqP/bL/ANBrQooooooooooooooooooooorH0D/X6x/2EH/9AStiiiii&#xd;&#xa;iiiiiiiiiiiiiiis/X/+Rf1L/r1l/wDQDVjT/wDkH23/AFyX+QqxRRRRRRRRRRRRRRRRRRRTEjVH&#xd;&#xa;kYFiZG3HJJwcAcenT+dPoooooooooooooooooorPs/8AkL6j/wBsv/Qa0KKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKx9A/1+sf9hB//AEBK2KKKKKKKKKKKKKKKKKKKKz9f/wCRf1L/AK9Zf/QDVjT/APkH23/XJf5C&#xd;&#xa;rFFFFFFFFFFFFFFFFFFFFVLO4ea5vo3xiCcRpj08tG5/FjVuiiiiiiiiiiiiiiiiiis+z/5C+o/9&#xd;&#xa;sv8A0GtCiiiiiiiiiiiiiiiiiiiiisfQP9frH/YQf/0BK2KKKKKKKKKKKKKKKKKKKKz9f/5F/Uv+&#xd;&#xa;vWX/ANANWNP/AOQfbf8AXJf5CrFFFFFFFFFFFFFFFFFFFFZ+nAi91XjrdL/6JirQoooooooooooo&#xd;&#xa;oooooorPs/8AkL6j/wBsv/Qa0KKKKKKKKKKKKKKKKKKKKKKx9A/1+sf9hB//AEBK2KKKKKKKKKKK&#xd;&#xa;KKKKKKKKKz9f/wCRf1L/AK9Zf/QDVjT/APkH23/XJf5CrFFFFFFFFFFFFFFFFFFFFMSRHZ1Rgxjb&#xd;&#xa;a4B+6cA4P4EH8afRRRRRRRRRRRRRRRRRRWfZ/wDIX1H/ALZf+g1oUUUUUUUUUUUUUUUUUUUUUVj6&#xd;&#xa;B/r9Y/7CD/8AoCVsUUUUUUUUUUUUUUUUUUUVn6//AMi/qX/XrL/6Aasaf/yD7b/rkv8AIVYooooo&#xd;&#xa;oooooooooooooopAACSABnk+9LRRRRRRRRRRRRRRRRRRWfZ/8hfUf+2X/oNaFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFY+gf6/WP8AsIP/AOgJWxRRRRRRRRRRRRRRRRRRRWfr/wDyL+pf9esv/oBqxp//ACD7b/rk&#xd;&#xa;v8hViiiiiiiiiiiiiiiiiiiiqOnuzXmphmJCXKhQT0HkxnA/En86vUUUUUUUUUUVl3GtxwXc1utl&#xd;&#xa;fTtCwV2hgLqCVDYz9CKj/t9f+gXqv/gKaP7fX/oF6r/4Cmj+31/6Beq/+Apo/t9f+gXqv/gKaP7f&#xd;&#xa;X/oF6r/4Cmj+31/6Beq/+Apo/t9f+gXqv/gKaq2+rtHf3czaXqmyXZt/0U54GDVr+31/6Beq/wDg&#xd;&#xa;KaP7fX/oF6r/AOApo/t9f+gXqv8A4Cmj+31/6Beq/wDgKaP7fX/oF6r/AOApo/t9f+gXqv8A4Cmj&#xd;&#xa;+31/6Beq/wDgKat6ZqUWpxSvFHNGYpDE6SptYMAD0/EVdooooorHPiGEyzJFY6hMIpGiZ4rcsu5T&#xd;&#xa;g4NH9vr/ANAvVf8AwFNH9vr/ANAvVf8AwFNH9vr/ANAvVf8AwFNH9vr/ANAvVf8AwFNH9vr/ANAv&#xd;&#xa;Vf8AwFNH9vr/ANAvVf8AwFNH9vr/ANAvVf8AwFNUNK1N7STUGl0vU8XF00yYtiflKqOfyNX/AO31&#xd;&#xa;/wCgXqv/AICmj+31/wCgXqv/AICmj+31/wCgXqv/AICmj+31/wCgXqv/AICmj+31/wCgXqv/AICm&#xd;&#xa;j+31/wCgXqv/AICmj+31/wCgXqv/AICmrWm6pFqJnWOKeJ4GCukybGBIyOPpV6iiiisSHxLDcQrN&#xd;&#xa;Bp2pyRuMq62xII/On/2+v/QL1X/wFNH9vr/0C9V/8BTR/b6/9AvVf/AU0f2+v/QL1X/wFNH9vr/0&#xd;&#xa;C9V/8BTR/b6/9AvVf/AU1V1XV2u9JvLaLS9U8yaB41zakDJUgVLa635NpDG2l6puRFU4tT1AqX+3&#xd;&#xa;1/6Beq/+Apo/t9f+gXqv/gKaP7fX/oF6r/4Cmj+31/6Beq/+Apo/t9f+gXqv/gKaP7fX/oF6r/4C&#xd;&#xa;mkbxCiKWbTNUCqMkm1PArTtbhLu0huYs+XMiyLkYOCMipqKKKKKKKKKKKp2UEkV1qDuuFmuA6HPU&#xd;&#xa;eUi/zU1coooooooooorP03/j91b/AK+l/wDRMVaFFFNdlRC7sFVRkknAAqGK+tJpBHFdQSOeirIC&#xd;&#xa;T+FRWOq2eoXN1b20peS0fZMNpG05I79fumrtFRXE8drbS3EzbY4kLucZwAMmo9PvrfUrOO7tHLwy&#xd;&#xa;Z2sQRnBIPB9xVmiiiisfQP8AX6x/2EH/APQErYooooorH8Of6i//AOwhcf8AoZrYopksscMZkldY&#xd;&#xa;0HVmOAPxqGO/s5XCR3cDu3AVZASf1qzRRRRRRRRRRWPpX/Ie1z/rrF/6KWtiiiiisfwl/wAixp//&#xd;&#xa;AFyH862KglvbWB9k1zDG/Xa8gB/WkivrSaQRxXUEjnoqyAk/hViqUuq2cWqw6Y8pF3Mm9E2nkc9+&#xd;&#xa;n8Jq7RRRRVK51Wztb+3sppStxcf6tdpOfx7VdooqvqH/ACD7n/rk38jVfQP+Rf03/r1i/wDQBWhR&#xd;&#xa;RRRRRRRRRRTVbczjaw2nGT34ByPzx+FOoooooooooorP03/j91b/AK+l/wDRMVaFFFcp4hR9U8UW&#xd;&#xa;Oj+fLBb+Q003luR5qk4KEDHZTz71o3vhu1mjthZBLGS3lV/NhjAdgAQVJGDzmo/D+pw32qaxBFYx&#xd;&#xa;WzWs2x5ExmY7nGTwPQ+vWqsHijULyCV7HRXuGiuGhbEoC4AHOcdeelXJ9dnEttZWtj5upSRrLNA0&#xd;&#xa;m1YVI5y2OxIHSmXt3eXHh/V0vrE2siW8oBV96ONh5B49+1UvDWqWukeBrK5vHKR5dRgZLHe5wPyN&#xd;&#xa;Wm8Q3dl5EurWEdtay4DSRz+YYycYDDA9e2eldAjrIiuhyrAEH1FOoorH0D/X6x/2EH/9AStiiiii&#xd;&#xa;isfw5/qL/wD7CFx/6Ga2KK43xjcvFrVimoLK2ild0ixj78g3YB9einFMuW8Pa9DbQaddRaZd+aGU&#xd;&#xa;xwbZOARjjGOuetblzrM76i1lpVql3JCP9IZ5PLWInoM4OScGq1n4juZNYvdNurGOGW0tzMSk28Hh&#xd;&#xa;SB0HZqu+HNXOt6Wt6YRCS5XYG3dPfApND1h9Xs7uYW4jaCd4Qu/IbaAc5xx1qpfa1q1hZy3U2m2h&#xd;&#xa;jiXc227ycf8AfNQ3Hi4/2haW1jYPci7tjPH821ifnwMf8B6571Zj8QyWunS3muWTaeFcIi795kJB&#xd;&#xa;PGPoajbxDd2XkS6tYR21rLgNJHP5hjJxgMMD17Z6V0COsiK6HKsAQfUU6isfSv8AkPa5/wBdYv8A&#xd;&#xa;0UtbFFFFFY/hL/kWNP8A+uQ/nWxWR4jsbSXRtRuJLWB5ltZCJGjBYYU4561Q8C2dr/wjdjdfZoft&#xd;&#xa;H7z97sG/77Dr16cU1PFN5cXOpW1npD3EtlN5Q2ygBhlhk5HH3fenprG7xLptndaVFFd3FuZDKzAv&#xd;&#xa;Dw/yg4/2fXvWjeXeqRXLpbWVrLEMbXe52E8em045qpaeInmtNWaa1WO50xSzxrJuVhtJGGx7HtUd&#xd;&#xa;l4g1HUNJTULXS4/L2sz+ZPt6Ej5flOentVm18S2U2gLq0xaGLoykZO/HKj156VUvfEGqWWltqUml&#xd;&#xa;Qi2ADDNz8+CQBxt9x3rN1K5+2+J/DF0U2efEJNuc43DOP1rotV1pLG5hsoEE9/Pgxwltoxnli3YY&#xd;&#xa;DflUNprzf2kNP1O3W0uJOYdknmLJ06HA5/wrbqvqH/IPuf8Ark38jVfQP+Rf03/r1i/9AFaFFFFF&#xd;&#xa;FFFFFFFNDKxYKwJU4IB6HGf6inUUUUUUUUUUVn6b/wAfurf9fS/+iYq0KKK5nxFa31trVprenW32&#xd;&#xa;gwwslwhYf6sHPyjrnlvXtxUlz4hmuhaRaPbyPcySgSLPA6qqYJb5jgZ4Heq3hGCWLXvEbyROiyXW&#xd;&#xa;ULKQGG6Tp61P4IhlhsL8SxvGWvpGAZSMjC80zUFl0nxWNXeGSa0uIBbsY1LGM5ByQMkj5fSp7jUp&#xd;&#xa;NW0XWFhspkhW3lSORxgyHZ2UjPesSPQrvVPh5Y2kSlLiGVpfLcbS3zOMc9PvZqcvoDwQ/Z/DzS3U&#xd;&#xa;pVfINuybSfViMcetdjCNsKDZ5eFA2f3fan0UVj6B/r9Y/wCwg/8A6AlbFFFFFFY/hz/UX/8A2ELj&#xd;&#xa;/wBDNbFFYeq6rfadrVoGgDaXIh82RI2d1fDcYHOPu9u9YWvWdt4nvIoNMs3Sd2Ek95JCyYUDbj5g&#xd;&#xa;M9V6elaCE+HvEd9PcxyyW2pYkWWKMt5ZXOVIAJ/iHNZ2nNLeeOtaJhMUktiQsZYE9IwPzGD+NWfC&#xd;&#xa;l7/ZGkHTri3uPtyTOqxCJtrNnAG/G0AnvnFVtLttSPg3WY7aGWG7ku2ZVPynHybsE9eM/Wq09rps&#xd;&#xa;vhcRWekPJqKWy+axgZChAAZskfMc9hzzTtGtbhPEnhx2glVEsSrsUICnEvB9Ooro/GWjz61owgtS&#xd;&#xa;PNjlEoU/xYBGM9utZJfQHgh+z+HmlupSq+Qbdk2k+rEY49a7GEbYUGzy8KBs/u+1PorH0r/kPa5/&#xd;&#xa;11i/9FLWxRRRRWP4S/5FjT/+uQ/nWxVDXVZ9B1FEUszWsgAAySdpqj4Kikh8K2UcqMjjflWGCPnb&#xd;&#xa;tVHwjBLFr3iN5InRZLrKFlIDDdJ09aNQglb4kaXMsTmJbVgXCnaDiTv+IrOsILSHUNS/4SWzknuW&#xd;&#xa;mBR2gaX5MccqCOmKXSrOaK38WJ9ge1DwYjhAyPuPwCOD17Vr+GIZY/A0cUkbpJ5Uw2MpB+83asfT&#xd;&#xa;NFutR8ANZKrRTiZpFSRcFiOg56Z9ak8Q6qbnwbLaraTLJGkaz71KiPDqOpGGyR29aZ5Ez6n4RkSJ&#xd;&#xa;2jS1j3MFJC/KOpq/4n0nfrtlq9xb/arKJBDPCF3EAlgGx1OCwOAO1PsBpD6vAmmaISVG9rgxGLyu&#xd;&#xa;cfxAZ69q6mq+of8AIPuf+uTfyNV9A/5F/Tf+vWL/ANAFaFFFFFFFFFFFFZ+m/wDH7q3/AF9L/wCi&#xd;&#xa;Yq0KKKKKKKKKKKz9N/4/dW/6+l/9ExVoUUUUUUUUUUUUUUVj6B/r9Y/7CD/+gJWxRRRRRWP4c/1F&#xd;&#xa;/wD9hC4/9DNbFFFFFZcGiRQeIbnWFlcy3EYjKHG0Abf/AIkVqUUUUUUUUVj6V/yHtc/66xf+ilrY&#xd;&#xa;oooorH8Jf8ixp/8A1yH862KKKKKKKKZMjSQuiSGNmUgOACVPrzWNJ4ea6mhbUdSuL2KJtwhdVVSc&#xd;&#xa;cZ2gH0P4VtgBQAoAA4AHalooqvqH/IPuf+uTfyNV9A/5F/Tf+vWL/wBAFaFFFFZev3NzbWkH2SUR&#xd;&#xa;SzXMUO8pu2hmxnFR/YNa/wCg5H/4BL/8VR9g1r/oOR/+AS//ABVH2DWv+g5H/wCAS/8AxVH2DWv+&#xd;&#xa;g5H/AOAS/wDxVH2DWv8AoOR/+AS//FUfYNa/6Dkf/gEv/wAVR9g1r/oOR/8AgEv/AMVUcWkavDJM&#xd;&#xa;6a2gaZw7/wChrydoX+96KKk+wa1/0HI//AJf/iqPsGtf9ByP/wAAl/8AiqPsGtf9ByP/AMAl/wDi&#xd;&#xa;qPsGtf8AQcj/APAJf/iqPsGtf9ByP/wCX/4qj7BrX/Qcj/8AAJf/AIqod+qWWsadBc6ilzDcu6so&#xd;&#xa;twhGELDnJ7it6iiisCO21CbVNUaz1FbaMXCgobcSZPkx85JHt+VT/YNa/wCg5H/4BL/8VR9g1r/o&#xd;&#xa;OR/+AS//ABVH2DWv+g5H/wCAS/8AxVH2DWv+g5H/AOAS/wDxVH2DWv8AoOR/+AS//FUfYNa/6Dkf&#xd;&#xa;/gEv/wAVR9g1r/oOR/8AgEv/AMVR9g1r/oOR/wDgEv8A8VR9g1r/AKDkf/gEv/xVH2DWv+g5H/4B&#xd;&#xa;L/8AFUfYNa/6Dkf/AIBL/wDFUfYNa/6Dkf8A4BL/APFUfYNa/wCg5H/4BL/8VR9g1r/oOR/+AS//&#xd;&#xa;ABVH2DWv+g5H/wCAS/8AxVR+GEljGqpPKJpRftucLt3HYnbtW5RRRRRXL6Ra6lMdQe01NbeL7fP8&#xd;&#xa;htg/O8981ofYNa/6Dkf/AIBL/wDFUfYNa/6Dkf8A4BL/APFUfYNa/wCg5H/4BL/8VR9g1r/oOR/+&#xd;&#xa;AS//ABVH2DWv+g5H/wCAS/8AxVH2DWv+g5H/AOAS/wDxVH2DWv8AoOR/+AS//FUfYNa/6Dkf/gEv&#xd;&#xa;/wAVR9g1r/oOR/8AgEv/AMVR9g1r/oOR/wDgEv8A8VR9g1r/AKDkf/gEv/xVH2DWv+g5H/4BL/8A&#xd;&#xa;FUfYNa/6Dkf/AIBL/wDFUfYNa/6Dkf8A4BL/APFUfYNa/wCg5H/4BL/8VUPh+OeLVdZS5nE8oli3&#xd;&#xa;SBNmf3a9u3Fb1FFFFcp4bs9Vk8P2TwaskMRj+VDahto+uea0/sGtf9ByP/wCX/4qj7BrX/Qcj/8A&#xd;&#xa;AJf/AIqj7BrX/Qcj/wDAJf8A4qj7BrX/AEHI/wDwCX/4qj7BrX/Qcj/8Al/+Ko+wa1/0HI//AACX&#xd;&#xa;/wCKo+wa1/0HI/8AwCX/AOKo+wa1/wBByP8A8Al/+Ko+wa1/0HI//AJf/iqPsGtf9ByP/wAAl/8A&#xd;&#xa;iqPsGtf9ByP/AMAl/wDiqPsGtf8AQcj/APAJf/iqPsGtf9ByP/wCX/4qj7BrX/Qcj/8AAJf/AIqo&#xd;&#xa;b2x1kWU5bWkZRG2R9jUZGP8Aeq9oH/Iv6b/16xf+gCtCiiisfxH/AKiw/wCwhb/+hitiiimu6RoX&#xd;&#xa;kZUUdWY4ArIjvtXv4o7iwtIIIXXhb1irk+uFzgfXnrU8GoTzyeUYBbyRSrHL55wHBXP7sgnJ6frV&#xd;&#xa;2S5gi3eZNGm3G7cwGM9M0faYPI8/zo/J/wCem4beuOv1qnd36N9n+yXEb7rhEfYwbg54/Sr0kiQo&#xd;&#xa;XldUQdWY4AojkSZA8Tq6HoynINPoorH1X/kPaH/11l/9FNWxRRRWfpv/AB+6t/19L/6JirQqAXUJ&#xd;&#xa;vWtA/wC/WMSlcH7pJAOfqDU9FFFISFBJIAHJJqK2uYrqMyQsWQMVzggEj0z1Hv0pLS6hvIBNA+5D&#xd;&#xa;6ggg+hB5B+tT0UUUUVj6B/r9Y/7CD/8AoCVsUUUUUVj+HP8AUX//AGELj/0M1sVBJdQxXUNs74lm&#xd;&#xa;DMi4PIXGefxFT0UUUVBFeQzRzPGxZYWKsdp6gZOPXr2p1tcRXUCzQtuRhkdiPYjsfY1LRRRRRWPp&#xd;&#xa;X/Ie1z/rrF/6KWtiiiiisfwl/wAixp//AFyH862KgtrqG7WRoH3CORom4IwynBH51PRRRUVzcRWs&#xd;&#xa;DTTNtRRk9yfYDufYU2a6igtftMhYRcchSTyQBx171KrK6hkYMrDIIOQRTqKKKKr6h/yD7n/rk38j&#xd;&#xa;VfQP+Rf03/r1i/8AQBWhRRRWP4j/ANRYf9hC3/8AQxWxRRWV4mhluPDt9FDG0kjxkKiDJJ9hWjDN&#xd;&#xa;FcRLLBIkkbDKuhyD+NZGuTRSXWlxxyIzx6ggdQclSY3Iz6cVFFY2954q1M3KCVY4YMRvyhyH5K9C&#xd;&#xa;Rjj0qRreCXXRprQxixhtRMtuqgIWZ2ByvQ9AcevNGoaZZ21xYS20CW7C5UFYQEV/94Drjtnpk+tQ&#xd;&#xa;avJd3GvrZxWkV5Alssphll2KWLMORghug4PQjNT6Pb6hBqEnm2kFnZNGSIYpt4D5GCowNoxnOOpO&#xd;&#xa;a3KKKx9V/wCQ9of/AF1l/wDRTVsUUUVn6b/x+6t/19L/AOiYqW9v5I5RbWMAurrGWQvtVB/tHBxn&#xd;&#xa;txzg+lZVtc3a+Irye9tY4ZI9PUhEl3ggO564HvV6y1HUL1oZU01Y7SQA75JSrgY5+Tb69OeRg0tz&#xd;&#xa;f6h9odLLT0ljjO1nmm8olvYbTkdOfr6U6PWIpLO0ugu2GaUxSOxwIiNwyT/vKFH+8KfcapHBqdvZ&#xd;&#xa;nYRICJH348tjjYCPVucfSs3V9Re71WHQ4FKx3H37tGyEZcu0ZA7lVGRno1dBGiRxrHGqoigBVUYA&#xd;&#xa;A6ACs0xfZdfjkjOI7uMq0Y4AdeS/uSCB+ArUooooorH0D/X6x/2EH/8AQErYooooorH8Of6i/wD+&#xd;&#xa;whcf+hmrV9ftBItvaxC4u3G5Yt20BfVjg7RwcHHJ4rntX1S/stTtL2+sIo/It52REn3b/uZydox2&#xd;&#xa;9a3bS91C5uULaeIrRskSSSkSAY4ym3g596hfUdTd2a00yNoc4Uz3HlOccHK7TjnOPUYNSR61FMdP&#xd;&#xa;kjjP2W9VsTOdu1uAqn3Yk457VKdST+2BYAKR5ZJk3dH4ITHqVy30FUNT1Z5FurSBCqPJHaJco/3X&#xd;&#xa;kJViPdDjjP5Vs20It7aOFcYRQMgYz71nwOLXxDLZogCXEJueOArBgp49TuyTWrRRRRRWPpX/ACHt&#xd;&#xa;c/66xf8Aopa2KKKKKx/CX/Isaf8A9ch/Ony6ldzSsNLs47qJDhpXm2KT/snB3Y6H0IIrL07U5NN0&#xd;&#xa;me4mti8kmqSRvFG24gtJg44+bHb1ras7q+k8x7uxWCILuTZLvZvYrgYNUptavbeJru409I7FRvL+&#xd;&#xa;f+8Cdspt6+2a0GvtmrCyePYrxB45Scb2ycqB3IAz+NR2WqR3l9c267MRkGJw+fNXA3EewY7T7is+&#xd;&#xa;0uf7b1xyU221hho+dyXO/wC647fKUODz1PSt9lDKVYAgjBB71k6Mxt76/wBNyWSBllRuyrIWIQDs&#xd;&#xa;FC4H9K16KKKKr6h/yD7n/rk38jVfQP8AkX9N/wCvWL/0AVoUUUVj+I/9RYf9hC3/APQxWxRRRWQf&#xd;&#xa;D1vHxY3N1YR9TFauFUn+8QQeeg/AVImhWMYh8qMxGKYT5TALuARlvX7xq1FZRQ31xdqW8y4VFcE8&#xd;&#xa;ALnGPzNJf2Ed8ihnkikQ5jmiIDoe+Cc9Rx9DVOLQYFninnurq6lhcPE07hinqBgDg8Z+gq5f2Ed8&#xd;&#xa;ihnkikQ5jmiIDoe+Cc9Rx9DUVjpcdnMZmuLi5mK7BJOwZlXqQMAcZAq/RRWPqv8AyHtD/wCusv8A&#xd;&#xa;6Katiiiis/Tf+P3Vv+vpf/RMVVp2/snVrnUJld7a6SNGZFLGMpnGQMk53dhxiqSTSX2sahcLbypC&#xd;&#xa;2nBYmYf6wbn5x1HXoea3rAEWFuCCCIlyD9BXK20OlfZ0i1TTmudYI2yBoWPmSdhvxt545zirOn2E&#xd;&#xa;k3gdbbyzA6yNJ5ZHICzF8fkMVctdNa90qe4lwt3efvo3cfNCeTGD7pms+C2lsns9TumPk/bJJZmI&#xd;&#xa;5TfGIlyOpy2OnrXW1m3DrLr1pChzJDG0rj0VvlB/MGtKiiiiisfQP9frH/YQf/0BK2KKKKKKx/Dn&#xd;&#xa;+ov/APsIXH/oZovQbDWDqkis9s1usEhRSxjwzEHA5OSwHA96wPFFy+q7HtbWdoFtZ1WQoRuJ2ZG0&#xd;&#xa;jI6d+vauyuRIbaUQ/wCsKHZz3xxXKpDoEiLGNJNxfkYKG3dd79/nI29c85xU1ray/wDCF6e5Rg9n&#xd;&#xa;suTGVO5vLO7aB6nGKtDTZhohmEn+nlxcmbHzcHp9dhKVWe1kTQorxgQjXq6jKDwYoy3mMD6kD09K&#xd;&#xa;6WN1ljWRDlXAYH2NZgRpfFXnIMxw2jROfRmZWA/IGtaiiiiisfSv+Q9rn/XWL/0UtbFFFFFY/hL/&#xd;&#xa;AJFjT/8ArkP51BZ3cegW/wBhvll+V3eOSOJnEgZi3RQcY3Y59Kz4Y7h9MRpLeSORtbEjRkZKjzcn&#xd;&#xa;kdR79K39dS4k0iZbTPmZTODgldw3f+O5rlNZh0KbSblNK0tmutmVItnQqO5ywH5V0XiGKVRa30O4&#xd;&#xa;tauw2qMsS48sEfTdn8Kj1Cz/ALMsLe7tI/3lnzIIx80yHJZR9WIb8Kbo1r/Y97DYzyBnks444mA4&#xd;&#xa;cxtIW+mA69fWt+sfS/32t6rdx8wt5cIb/bj3hxj2JFbFFFFFV9Q/5B9z/wBcm/kar6B/yL+m/wDX&#xd;&#xa;rF/6AK0KKKKx/Ef+osP+whb/APoYrWd1jRnc4VRkn0FZkPiTR55Uiiv4meRgqgZ5J6dq1aKoX2qL&#xd;&#xa;aTiCO2nupyu8xwAEquSATkjjINXUbcisVKkjOD1FOooooooorH1X/kPaH/11l/8ARTVsUUUVn6b/&#xd;&#xa;AMfurf8AX0v/AKJirQoooooqK4gjuYWhmQOjdQR+R+ueaS1ha3gWJpXlC8Kz8tjsCe59+9R2dkls&#xd;&#xa;zys5mnk+/K/XHoPRfYccn1q1RRRRRWPoH+v1j/sIP/6AlbFFFFFFY/hz/UX/AP2ELj/0M1sUUUUU&#xd;&#xa;U2REljaORVdGBVlYZBB6gioba2a2gaFZmZcnyywyUHYe+KSztFtUb52kkkbdJI5yWP8AQeg7VZoo&#xd;&#xa;ooorH0r/AJD2uf8AXWL/ANFLWxRRRRWP4S/5FjT/APrkP51sUUUUUVWvLJLsIxJjmiOY5V+8p/wO&#xd;&#xa;BkdDjmnzRPLbGJZmRyADIo596LW2itIFihXCjqT1Y9yT3J7nvU1FFFFV9Q/5B9z/ANcm/kar6B/y&#xd;&#xa;L+m/9esX/oArQooorH8R/wCosP8AsIW//oYrQ1D/AJB9z/1yb+RrF0vVtJPhuztpru3lY2iRvbrI&#xd;&#xa;GdzsAKBc5JPTFXIrqXR/D0c+rSF5YlUStnOWLYHP1IrP/wCElW2Z7i61DTJrfr5NvIDKnp/EQ2On&#xd;&#xa;AGaJk1U+L7j7LNZqfsaFfMjY/JvbA4brnPND+IjcYNtqWl2oTKsLpvmZhwTt3DaMg9asz6+ZNMgu&#xd;&#xa;7BEkL3aW7KTkElsHDD9D0qaS9vNMtZ7zVpLY267dqwoQVJYAZJJHcc1QPiQW7NcXOpaXLbDJ8mB8&#xd;&#xa;yqO3O7DEew5q1Fe6vfT3sdoLSJba5MQklVm3AKpxgEc89akh1g29vf8A9pbS+nlfOeFTtbcAwwCc&#xd;&#xa;9CB1p5/t0y+aDYrFnPklWL49N2cZ98VW1DXgl1JZw3dlZ3EO0yNePxyoOAMgnqOfarej6tFqXmwr&#xd;&#xa;LFLNbhfMeFg0bZzgg/geO1Rar/yHtD/66y/+imrYooorP03/AI/dW/6+l/8ARMVWrm5gtIvNuZo4&#xd;&#xa;Y843yMFGfqaWO4hlgE8cqPCRuEisCpHrmof7TsPtItvttv57YxF5g3HIyOOvTmi61OwspBHd3tvA&#xd;&#xa;5G4LJIFJHrg/Sn3F7a2sKzXFzDDE5AV5HCqSRkYJp1tcwXcXm200c0ecb42DDP1FRrqNk139kW8g&#xd;&#xa;NzkjyRIN+QMnjr0qtfSz3N4NOtmaIFN8069UHTaD2Y5yM9geKt3sMs0BEEzQyqQyMOhI6BvVfUel&#xd;&#xa;R6Ze/bbfMieXOhKyxH7yHPGR1GRyPYirlFFFFY+gf6/WP+wg/wD6AlbFFFFFFY/hz/UX/wD2ELj/&#xd;&#xa;ANDNadxcQ2sLTXEqRRL953YKB26mo0v7OS1a6S6ha3XrKJAVH49KRdRsmu/si3kBuckeSJBvyBk8&#xd;&#xa;delMuNX021maG4v7WKVfvI8qqR36E1Jd39nY7Ptl1Db787fNkC7sdcZ+oqS3uIbqFZreVJYm+66M&#xd;&#xa;GB7dRUUWo2U101tFeQPcKSGiWQFgR1yOvFVZ55b3UDZW0hSGIBp54+u7P+rB6BuASD2b8at30M80&#xd;&#xa;I+yz+TMjblJ5Vjzww7jntjoKbpt8uoWizBDE/SSJj80bf3W9DyPzq3RRRRWPpX/Ie1z/AK6xf+il&#xd;&#xa;rYoooorH8Jf8ixp//XIfzq9dajZWTKt3eQQMwyolkCkj8amlmjhCmWRUDMEXccZY9APc1Fb39ndy&#xd;&#xa;PHbXUMzx/fWOQMV+oFMXVdPa6+zLfWxuNxTyhKu7cOoxnOaW61OwspBHd3tvA5G4LJIFJHrg/Spp&#xd;&#xa;LiGKAzySokIG4yMwCgeuaba3dtexmS0uIp0B2lo3DAH0yPrVS3uZb/UXMTbbO3OA68idsY4PQqMk&#xd;&#xa;Ef3lHpikv5Z9PuFuwzSWzsqTI3SIf3wewGSWz6DpWirB1DKQVIyCOhFOoooqvqH/ACD7n/rk38jV&#xd;&#xa;fQP+Rf03/r1i/wDQBWhRRRWP4j/1Fh/2ELf/ANDFaN6jSWU6IMs0bAD1OKo6ZpcA0K0t7m1RZPsy&#xd;&#xa;JINuGB2gHkcg+9Rz2d1fWM+mXrFyNrpc4G1wGBAb0bK84GMEVD58rf6OugkXP3fNaNfI3dznO7b6&#xd;&#xa;cZ9quJbyjxPLclD5Js0jD9twdiR+RFUY4P7HU2x0qS/iLM8csMas3zEkhtxHOScYzxipLy3urmws&#xd;&#xa;iLRYiL6GXykGCkYcH5vcDritHVrEalp0lqW27irA9sqwYA+2RWZ58rf6OugkXP3fNaNfI3dznO7b&#xd;&#xa;6cZ9quaNbywS6mZUKCW8aRM/xLsQZ/Q1VbSnvZ9dgnDxQ3jRhJB3AjUEj8RUv9qX6/6O2lTm5+75&#xd;&#xa;qgeRu7HOd2314z7VFPavY30989j9uW62+YkShnRwoHG7A24B75yRxV3S3eXzZDYiziOAiMoWQkZz&#xd;&#xa;uA4x0xz61X1X/kPaH/11l/8ARTVsUUUVn6b/AMfurf8AX0v/AKJirLu/7Qu/EdzHbx2k0drFGUW5&#xd;&#xa;ZgF35zgKDnO0demOOpqW3s9RtotQe6+yxwSQMRDbszDfg5b5hxxgYHHHSr+kWNrb6da+VCoIjUhj&#xd;&#xa;8zZIz1PPesq1+238RvrGy04290fNU3TuZPTnggdOgOKr6PaXUulWl7GIZ5U86N4ZSShXzWJK8feG&#xd;&#xa;ABnsavtdwppmrXNnbyWV7Fbl3jkAymFYodoJX1+veqkdhq9xpsai20ob0DCTzJA+eucheuf8Olae&#xd;&#xa;jrOl3dLdOslwscIldejNs5I/GtasfSv+Q9rn/XWL/wBFLWxRRRRWPoH+v1j/ALCD/wDoCVsUUUUU&#xd;&#xa;Vj+HP9Rf/wDYQuP/AEM1V1T7fceJUt7ZLaWOG1WUJcswUMWZSflBzwBweKztcstUh0y/nmWxgga3&#xd;&#xa;Iljt2Y7yMbeCMDHPTGc85rp0tbTTrYvFAoWFCQcZbAHqeT+dZFva6n5KtBY6SYn+dTK8jNg88kqf&#xd;&#xa;X1qvo0F0dGsL6OKG7U2yrNHMSXwrMfk7FjuI5I6CptQu0j0O+m06JrS7MkSSwycFCWVcEAkDKnt6&#xd;&#xa;560kumaw1qsUVtpMLRgeXKssm5COhzt5x75z3zVvw0HB1QSsGkF824joT5aZrbrH0D/X6x/2EH/9&#xd;&#xa;AStiiiiisfSv+Q9rn/XWL/0UtbFFFFFY/hL/AJFjT/8ArkP51l6UmrXkEl4sGmzmWVwXuGfcdrFR&#xd;&#xa;wFwOBjjr1PNP1CyuU0OytNSeOTOoQoBExwsZcALu4PA4z1962NQa10rTJZVtxtwseEGCdxCjJ69S&#xd;&#xa;K5/W7bVLXw/c7rXTIo44sb4ncyAD0JHJ+prVntLixup7hbWO+tpXMjqRumUkAbUB42jAPJHU1QlZ&#xd;&#xa;7q+sbXSVgktRDJOIrh2Chw+08jJJBZhg8fkK0bCz1WPU1mnWxggKFZI7ZmO8/wAJwVGMZPTrnnOB&#xd;&#xa;TvCv/IBi/wCus3/o16sa/wD8i/qX/XrL/wCgGrGn/wDIPtv+uS/yFWKKKKr6h/yD7n/rk38jVfQP&#xd;&#xa;+Rf03/r1i/8AQBWhRRRWP4j/ANRYf9hC3/8AQxWxRRRRRRRRRRRRRWPqv/Ie0P8A66y/+imrYooo&#xd;&#xa;rP03/j91b/r6X/0TFUt9YQ3yKJTIjp92SJyjrnqAw5AOBmmWulW9tFKgaWVpQVaSaQu+3+7uPOO+&#xd;&#xa;Pc1bijWKJI0+6ihR9BWadAtPN3CS5WLP/HuszCHH93Z02+3Sl/sCyW0itofNgERba8MhRwCSSu4c&#xd;&#xa;7cnOOnA9Ks2NhDYowiMju/3pJXLu2OgLHkgZOKqyaDbPMzi4vEUnPlJcMsf02jjHtSXUD6fdx31r&#xd;&#xa;EzwJF5MltCuPl4wwA6kYwBjoetXr24e2gLxwvNISFRFHVj0yew9T2qLSrJrK02yv5lw7F5ZSPmYk&#xd;&#xa;kgE98AhR7CrtFFFFY+gf6/WP+wg//oCVsUUUUUVj+HP9Rf8A/YQuP/QzV+9sob6IJLuVgcrJG210&#xd;&#xa;/wB1hyM9OO1Uv+Eesmgmhme4uBKuzdPMZGQd9pP3c8Zx1wK1WUMpVgCpGCD0NZS+H7USZea7ljzz&#xd;&#xa;DJcM0ZHoVPGPalOgWgt4IYpLmBYE2AwzMjMvUBiOuMnGemT61btLCC0gaJAz7/vvKd7yf7zHk8cc&#xd;&#xa;9uKp/wDCP2vmbvOu/LznyPtDeVj+7s6be23pjiiWB9O1H7XbxM1rKixywwr91s/6wKPvE5UH0Azn&#xd;&#xa;jFXb64ltoQYLdriV22og4GeeWODtHHX6UzS7H+z7FIGk86QcyTFcNI394+p6flVyiiiisfSv+Q9r&#xd;&#xa;n/XWL/0UtbFFFFFY/hL/AJFjT/8ArkP51YvNHt7uczebcQO33jbzGPf6FsdTjjmnnSrU20MGw7YZ&#xd;&#xa;VmBzyzqc7mPck8knrVi4giuYGhmQOjdQR+R+oPNZcnhqzmieK4nvbiNxgrNcs4HuAe/vU91otvcz&#xd;&#xa;mUTXVuzfeFvM0QY/3iB1Pv7CppNNtZLJbTy9kaHKFPlZG/vAjo3J568mmWOkwWUplEk88mMK1xKZ&#xd;&#xa;CnrtJ6Z7464FR21vLYanKqIWs7psoEGFgYLyMdAGwxzxycd80moxzahcJZIjpAjrJPIwO11znywO&#xd;&#xa;jBhkH09DmtNVCqFUAKBgAdBS0UUVX1D/AJB9z/1yb+RqvoH/ACL+m/8AXrF/6AK0KKKKqajYJqEC&#xd;&#xa;RvJJEY5FlV48ZDKcjqCOvtUX9nXP/QYvv++Yf/jdH9nXP/QYvv8AvmH/AON0f2dc/wDQYvv++Yf/&#xd;&#xa;AI3R/Z1z/wBBi+/75h/+N0f2dc/9Bi+/75h/+N0f2dc/9Bi+/wC+Yf8A43R/Z1z/ANBi+/75h/8A&#xd;&#xa;jdH9nXP/AEGL7/vmH/43R/Z1z/0GL7/vmH/43R/Z1z/0GL7/AL5h/wDjdH9nXP8A0GL7/vmH/wCN&#xd;&#xa;0f2dc/8AQYvv++Yf/jdH9nXP/QYvv++Yf/jdH9nXP/QYvv8AvmH/AON01dJJvba6nv7q4a3LNGsg&#xd;&#xa;jC5KlT91AehrSooorP03/j91b/r6X/0TFWhRRRRRRRRRRRRRRWPoH+v1j/sIP/6AlbFFFFFFY/hz&#xd;&#xa;/UX/AP2ELj/0M1sUUUUUUUUUUUUUUVj6V/yHtc/66xf+ilrYoooorH8Jf8ixp/8A1yH862KKKKKK&#xd;&#xa;KKKKKKKKr6h/yD7n/rk38jVfQP8AkX9N/wCvWL/0AVoUUUUUUUUUUUUUUUUUUUUUUUVkS6bqIvbm&#xd;&#xa;ay1OOCO4cSGNrYPghFXruH90Un2HXP8AoNw/+AQ/+Lo+w65/0G4f/AIf/F0fYdc/6DcP/gEP/i6P&#xd;&#xa;sOuf9BuH/wAAh/8AF0fYdc/6DcP/AIBD/wCLo+w65/0G4f8AwCH/AMXR9h1z/oNw/wDgEP8A4uj7&#xd;&#xa;Drn/AEG4f/AIf/F0fYdc/wCg3D/4BD/4uj7Drn/Qbh/8Ah/8XR9h1z/oNw/+AQ/+Lo+w65/0G4f/&#xd;&#xa;AACH/wAXR9h1z/oNw/8AgEP/AIuj7Drn/Qbh/wDAIf8AxdH2HXP+g3D/AOAQ/wDi6saPp0unx3Pn&#xd;&#xa;3IuZbiczM4j2DJAGMZP92tCiiiiisOLR9TtpLj7Jq0cUU07zbGtAxUsc4zu5qT7Drn/Qbh/8Ah/8&#xd;&#xa;XR9h1z/oNw/+AQ/+Lo+w65/0G4f/AACH/wAXR9h1z/oNw/8AgEP/AIuj7Drn/Qbh/wDAIf8AxdH2&#xd;&#xa;HXP+g3D/AOAQ/wDi6PsOuf8AQbh/8Ah/8XR9h1z/AKDcP/gEP/i6PsOuf9BuH/wCH/xdH2HXP+g3&#xd;&#xa;D/4BD/4uj7Drn/Qbh/8AAIf/ABdH2HXP+g3D/wCAQ/8Ai6PsOuf9BuH/AMAh/wDF0fYdc/6DcP8A&#xd;&#xa;4BD/AOLo+w65/wBBuH/wCH/xdWtOsGszNLNN59zcMGlkC7AxAwMLk44AFXqKKKKwLHRdWsLOK1t9&#xd;&#xa;aiEUS7VBswTj/vqp/sOuf9BuH/wCH/xdH2HXP+g3D/4BD/4uj7Drn/Qbh/8AAIf/ABdH2HXP+g3D&#xd;&#xa;/wCAQ/8Ai6PsOuf9BuH/AMAh/wDF0fYdc/6DcP8A4BD/AOLo+w65/wBBuH/wCH/xdH2HXP8AoNw/&#xd;&#xa;+AQ/+Lo+w65/0G4f/AIf/F0fYdc/6DcP/gEP/i6PsOuf9BuH/wAAh/8AF0fYdc/6DcP/AIBD/wCL&#xd;&#xa;o+w65/0G4f8AwCH/AMXR9h1z/oNw/wDgEP8A4umy6brUsTxvrUO11Kn/AEIdD/wOtLT7b7Fp9ta7&#xd;&#xa;9/kRLHuxjdtAGcfhViiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiv/9k=</binary>
<binary id="image16.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCALeAnUBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKyZPEuixSNG+owq6kqwJ6EU3/hKdD/6CUH5mj/hKdD/6CUH5mj/hKdD/AOglB+Zo/wCE&#xd;&#xa;p0P/AKCUH5mj/hKdD/6CUH5mj/hKdD/6CUH5mj/hKdD/AOglB+Zo/wCEp0P/AKCUH5mj/hKdD/6C&#xd;&#xa;UH5mj/hKdD/6CUH5mj/hKdD/AOglB+Zo/wCEp0P/AKCUH5mj/hKdD/6CUH5mj/hKdD/6CUH5mj/h&#xd;&#xa;KdD/AOglB+Zo/wCEp0P/AKCUH5mj/hKdD/6CUH5mj/hKdD/6CUH5mj/hKdD/AOglB+Zo/wCEp0P/&#xd;&#xa;AKCUH5mj/hKdD/6CUH5mj/hKdD/6CUH5mj/hKdD/AOglB+Zo/wCEp0P/AKCUH5mj/hKdD/6CUH5m&#xd;&#xa;j/hKdD/6CUH5mj/hKdD/AOglB+Zo/wCEp0P/AKCUH5mj/hKdD/6CUH5mj/hKdD/6CUH5mrdhq1hq&#xd;&#xa;TOtldRzlACwQ9Ku0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVj+F/8AkEH/AK+J&#xd;&#xa;/wD0Y1a9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFZEH/I3Xf/XnF/6G9bFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFY/hf/kEH/r4n/8ARjVsUUUUUUVElxDI5RJo2cdVVgSKlooprOql&#xd;&#xa;QzAFjgAnrTqKKKKKKKKa7pGu6R1RfVjgU6iiiiiiiseD/kbrv/rzi/8AQ3rYoooooooooooooooo&#xd;&#xa;oooooooooooooooooooooooooooooorH8L/8gg/9fE//AKMatiiiiiiisHSLS2i8S6y8dvEjAxYZ&#xd;&#xa;UAIyuT+Z5ND3eq3euX1haNHBDAI2FwyB9uVzt25BOc5z2x71PaXF7bapHYX1wl0ZomlWRIvL2bSB&#xd;&#xa;jGTnO717VTgvNQv4hcpq1rYq+cW8sIdkwccksM9M9O9RasNSubrRJPMSzlaZh5ZQS7G2P82QRkEd&#xd;&#xa;verOo3eraZHYxq8d9cT3BQgIIsrtJ7k4xjNOu5dU0y0Es99Fcl54o1xb7NoZwD/Ec8GtXUJnt9Ou&#xd;&#xa;Zo8b44ndc+oBIrButY1IXOjQWsaSNfW5eQcDado+bnsMk474xS3c+u217badFcw3E1yS5n8kIIUU&#xd;&#xa;gN8pb5vvDuOlXrW4vbXVI7C+uEujPE0iyJF5ezaQCMZOc7v0qCa+urq/uobfUbewW1cRkSxiQyEq&#xd;&#xa;G3ckY64xz0qGbWrqLRNSkR45rmxdYxMoAWUnac47fex1PSrXla5JH9oa+htcjebc24kKf7O8Nz9c&#xd;&#xa;Vl+KLmbUvB0F7GywJL5bvERvJywxzx0PtzXQ2EF/Czm9vo7kEDaEg8vb+pzV2iiiiiiseD/kbrv/&#xd;&#xa;AK84v/Q3rYoooooooooooooooooooooooooooooooooooooooooooooorH8L/wDIIP8A18T/APox&#xd;&#xa;q2KKKKKKKxtMh1CPXNQnuLRI4LnaVcTbiNowOMd+vtViytJYdX1K5cDy7gx7MHn5VwaJrSV9ftrw&#xd;&#xa;AeTHbyRsc85JUj+RrMuLG5M7mbw/p2oSZ5uXZEMnuVKnHp17VZk0u7isdPZZftdzYyGQBzt83IIx&#xd;&#xa;uOcYDe/SnSQX99Np089qlu1vcM7oJd/y7CAc4Hc9Kt6xZPfWPlxsA6SJKoP8RVg2PbOMZ7Vn3ja5&#xd;&#xa;qFnPa/YIbPzY2XzftAl7dNuB16ZzxRHpV0upaJOVXZZ2zRy/N0YqBx68irs1pK+vWt2oHlRQSIxz&#xd;&#xa;zlipH8jRPaSvr1rdqB5UUEiMc85Yrj+RrNvNIePUbq4XR7PU/tLiTdOyqY8ADaMqc9M9utOm0ieT&#xd;&#xa;w/d28VpbWstwyssEKhVTBHBYY3HjOcD0relUtE6jqVIFYbaHLc+ErfSpZBDKiRhiBuGVIOO3pWlY&#xd;&#xa;XF/Mzi9sUtQANpWfzN36DFXaKKKKKKx4P+Ruu/8Arzi/9Detiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiisfwv/AMgg/wDXxP8A+jGrYooooooooooooooooooooooooooooorHg/5G&#xd;&#xa;67/684v/AEN62KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK5DRteFjZyW50vU7j&#xd;&#xa;bcTfvILfehzIx4Oav/8ACUj/AKAetf8AgJ/9ej/hKR/0A9a/8BP/AK9H/CUj/oB61/4Cf/Xo/wCE&#xd;&#xa;pH/QD1r/AMBP/r0f8JSP+gHrX/gJ/wDXo/4Skf8AQD1r/wABP/r0f8JSP+gHrX/gJ/8AXo/4Skf9&#xd;&#xa;APWv/AT/AOvR/wAJSP8AoB61/wCAn/16P+EpH/QD1r/wE/8Ar0f8JSP+gHrX/gJ/9ej/AISkf9AP&#xd;&#xa;Wv8AwE/+vR/wlI/6Aetf+An/ANej/hKR/wBAPWv/AAE/+vR/wlI/6Aetf+An/wBej/hKR/0A9a/8&#xd;&#xa;BP8A69H/AAlI/wCgHrX/AICf/Xo/4Skf9APWv/AT/wCvR/wlI/6Aetf+An/16P8AhKR/0A9a/wDA&#xd;&#xa;T/69H/CUj/oB61/4Cf8A16P+EpH/AEA9a/8AAT/69H/CUj/oB61/4Cf/AF6P+EpH/QD1r/wE/wDr&#xd;&#xa;0f8ACUj/AKAetf8AgJ/9ej/hKR/0A9a/8BP/AK9H/CUj/oB61/4Cf/Xo/wCEpH/QD1r/AMBP/r0f&#xd;&#xa;8JSP+gHrX/gJ/wDXo/4Skf8AQD1r/wABP/r0zRr8aj4lvJha3Nti1jXZcx7G+83OPTmujooooooo&#xd;&#xa;ooooooooooooooooooooooooooooooooooooooorH8L/APIIP/XxP/6Matiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiseD/AJG67/684v8A0N62KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKx/C//ACCD/wBfE/8A6MatiiiopZTHJEgikfzGxuUcJxnJ9u1S1WmvY4L22tGDGS537CBwNoyc&#xd;&#xa;/nVmiq99dx2FlNdzBjHChdgoycD0qZWDIGHQjNOooqlHqlrPfGzgYzSoSJdnIiI/vemaItUtXvms&#xd;&#xa;mYxXIJ2xPwXA/iHt1/KrtFFFFFFFFFFFFFFY8H/I3Xf/AF5xf+hvWxRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRWP4X/wCQQf8Ar4n/APRjVKbiWHxEtrvLxXEDS7W/gKlRhfY5JOc0&#xd;&#xa;eH7iW90tL2dyz3BLlf4U5xhfbjPOetVbVbnW7ddQW+ntI3z5UUJAGAf48g5Oc9McYqIardS6hZW0&#xd;&#xa;jKkkd40Fx5Ywkn7osMA845H5Vcu57i91GTTbaU26xorzSr9/DZxs7A5XnIPBqi1i9n4l0ovfXV1u&#xd;&#xa;WbAnKnb8o6YArpK5vS4L/VbeSWfU7iFEnlSP7OQGIDkfNkHOMcYxVW5lvE0TxBYXs4uDaxfJKR8z&#xd;&#xa;Kylhu9xwOBXRXUkcWkvJNO9vGsWWlT7yDHUcH+Vc7put2h1a0t7DWLjUTcOUkS4X7ihScj5V5yAO&#xd;&#xa;/Wtj7VNBrlxa7zJG1t9pG/8AgOdu0e3GfqetO0ieafQkvJZGaW4j84jshIztX2Hvmk8NKDodrOR+&#xd;&#xa;9uEEsrd3cjkmmeI/3UFtdR/LPHcRojjqAzgMPxHFbFFFFFFFFFFFFFFFY8H/ACN13/15xf8Aob1s&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVj+F/+QQf+vif/ANGNSeKdGl1zTFtY&#xd;&#xa;ZUiZZQ+5gegBGOPrWui7UVfQYrKNhqFmfJ0qa3S1POydWJj9QmCOO/OeSaBogjnspIpSzQztNLJJ&#xd;&#xa;y8pKFcnHGeR+VOu7G9S/e902SASzIqSi4UsuFzjbtx6nOfaootMv5NVtNQvrqJmgDqYogQmCMAjP&#xd;&#xa;OfXn0rarmNFj1tbSUWrWKQ/aJionjcv/AKxvQirkmgs2n6lGbp5LnUEAkeTG1TjHGBnHPvVzULBr&#xd;&#xa;u0hVHCzW7rLGW+6XUcbvbmqQ0/VrjULKa9lsfKtpDJiBHDElSvcn1pniOwXV7uwsf3mEl86UpwVT&#xd;&#xa;BAOTx97Ax1rddA8bIeAwxxWRo0k1iRpdzbtHHGSlpLkN5qKOpx0OPXHXim3xl1W+is47d/sMUu6e&#xd;&#xa;4yAQ6EMFAPPUDJwRzwa26KKKKKKKKKKKKKKx4P8Akbrv/rzi/wDQ3rYooooooooooooooooooooo&#xd;&#xa;ooooooooooooooooooooooooorH8L/8AIIP/AF8T/wDoxq2KKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;Kx4P+Ruu/wDrzi/9Detiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisfwv8A8gg/&#xd;&#xa;9fE//oxqZNqN3d6vc6XZPDbSW4VzNIQ5YEA4EfB79c9vep7eLWLedGnuoLyJjtZVh8ooP72cnOPT&#xd;&#xa;3qrc+IDbeIJLNre6eFIA2I7dmJbd1GOq47+tWn1+yjKI4nWV4vNWExESMM4wF6k8E49OaZ/aVrc3&#xd;&#xa;mnljewSSO6xROjRhyFydynqMdKmu9as7S5ktnMjzoqv5UaFmYHPQDk9OfSnWWrW95L5QjngkxlVu&#xd;&#xa;IjGX9dueuO+KS91e3s5vKMdxO4+8tvEZCnpux0z707TtUg1JplhSZHhIDrNGUIyMjg1PeXUVlaS3&#xd;&#xa;M5IiiUsxAycCmzXsMMlsjk7rltkfHU4J/kKbPeRCeS0DMJxAZun8OcdfrWPpHiCJdHsvMW8u5fIX&#xd;&#xa;zJIYWlG7HILDPPqK2ob2Ge0a5i3MqglkC/OpAyVK9Q3t1qpBrttNMsbQ3cG44Dz27RrnsMnjJqPx&#xd;&#xa;Fq76VBCYo5WeSVBlYi6hdwBGR0JB4qCfWZr6WKz0tZra6dtxa6tmUCMfeIBxkjIrUisvLsGtTcXD&#xd;&#xa;bgQZTId4z6N1HtVXTLi6jvp9P1CVZZlHmwsibd0fAyeTznNatFFFFFFFFFFY8H/I3Xf/AF5xf+hv&#xd;&#xa;WxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWP4X/wCQQf8Ar4n/APRjUzUl0h7u&#xd;&#xa;T7TOLC6GM3AcQPIMdA/Vh0z9BWcmbfV7OTStbkv4pHEU1s0/nlVJ5frwBgDp3rRuJorTxT9oupEg&#xd;&#xa;gayCCSVgqlt5OMnjOO1MT7Nd+L0uE8qdVsA0cgwwB8wjIP5ik1z/AJGbw/8A9dJv/QKkt4Y38YXs&#xd;&#xa;rRq0kdtFsYjlcl84Pan6j/yMejfSf/0EVBo19aWkM/8AaF1BBePPJv8APkCyFQ52ZzzjbjHtTtDu&#xd;&#xa;Uu9b1maIMELQgFlxnCdR7Hse9bUsUc8TRTIskbjDKwyCPQiuNFlqt7azQxzO11Zw+UGaXlJt+7IP&#xd;&#xa;r5bYz+FaehS/bo9SvmWRgzFIZJFIOwIMgE9twP41b8Kwxw+G7Dyo1TfCrttGNzEDJPvVKzupLOx1&#xd;&#xa;WWGMu39oyLnsgJALn2HU/SqGqXU0sVuj69p94DdQ/uYY1DH5x6Of5Vu+JVZtMQqpIW4hdsDoocEk&#xd;&#xa;+wHNV3vLW48TWU0FzDLEsEkZdJAyh2K7VyO5wcDvg1vVjp+88Wu6fMkdl5bsOQrb87T6HHOK2KKK&#xd;&#xa;KKKKKKKKx4P+Ruu/+vOL/wBDetiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisfw&#xd;&#xa;v/yCD/18T/8Aoxq05raCcgzQRyEdN6A4/OkitLaB90NvFG2MZRADTpoIZ1CzRJIAcgOoOPzojgii&#xd;&#xa;IMcSJgbRtUDA9KVo0d1dkVmT7pI5X6UoRA5cKocjBbHJFBRGdXKqWXO0kcj6Vk6ho015dvOl6kSs&#xd;&#xa;B8htY3xx6sM1a03ThYiR3lM1xLjzJSoXdgYX5RwMDjir1NVEUsVVQWOWIHU+9CRoibERVQfwgYFC&#xd;&#xa;IqIERQqgYAAwBSCKMKyhFAcksMfez1zUK2FmrBltIAQcgiMcfpVhlDKVYAgjBB71SutHsLqAQyWy&#xd;&#xa;qgcPiImM7h0OVwe9PitrhLBoDeM02CFnMa5X046HFJp+m22mpItsrAytvkZnLFmxjPJ9quUUUUUU&#xd;&#xa;UUUUVjwf8jdd/wDXnF/6G9bFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFY/hf8A&#xd;&#xa;5BB/6+J//RjVsUUVFJPFFJFHJIqvK21Af4jjOB+AqWonnijmjheRRJLnYp6tjripaKKKit54rmFZ&#xd;&#xa;oJFkjboy9DRbzxXMKzQSLJG3Rl6HtUtFFFRJPFJNJCkitJFjeo6rnkZpLW6gvIRNbSrLGSRuU8ZH&#xd;&#xa;BqaiiiiiiiiiiiseD/kbrv8A684v/Q3rYooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooorH8L/APIIP/XxP/6MarYvmXVzYyoBvjMsTKc5UYDbvQ5PHWjSr5tRtftQQJDIx8rn5ivT5h2O&#xd;&#xa;c+tVW1G+uiZdLt4JbVePMlcqX9SmAcjtzjnNH9tJJPZRxRENPM0UiScPEQhbkDvwPzqe91B45vsl&#xd;&#xa;lF592RnBOEjHYueoBwcYB5FZbPqTeJdK/tCG2jG2bZ5EjNn5RnOQK6Ss68k1hbhhZ29k8PG0yysr&#xd;&#xa;e/AU0+z1OGfTWvJSIUjLLKW6KVJDfhkGqv2rWp/3trZWqwNyguJWV8e4CkD86q6C1+vhaxNjFbvJ&#xd;&#xa;824TOVAG5uhANT6LrcmozQRPAkfmWxnO1s4IkK4/Sr19fNa3VjCEDC6mMZJP3flLZ/Sqh1DUbuec&#xd;&#xa;aZb2rxQSGFjcSMrbx1wADx0o1Ge8l8O3p+zrHcLG6ursQp45KnqRjOOn4Vlm61aLw/bJPb2YtZ44&#xd;&#xa;oN6SsXAcBQcbcZ59a6DS9Og0qwjtLcHYg5JJJJ7n86zdRtYdP1u01WJf31xItrIuTghsfN9Rt/Wt&#xd;&#xa;6iiiiiiiiiiiseD/AJG67/684v8A0N62KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKx/C//ACCD/wBfE/8A6Maq3i+G++xxXOkRyG+V9m+MZYRkEkfTIFbVnbx2trHBCgjRBwo7VjRy&#xd;&#xa;3ehRpp8Gnz3kK/6qWMfdBPR/fOenbFN/sq4h1CwuHHmSyXbT3BjHyIfKKjGeQOB171LfNc6Zq8t9&#xd;&#xa;FZTXq3MSR7IRym0nk59d36VFFJqGoa5p13LYvbW0QlXbIPnUlRye2D2+hroq468tFju5Rf6FcanM&#xd;&#xa;XJ+0x9CpOVHUdBgfhV3S9Mmm8Hz2BhNo83mhUkH3AzHGfwNSxazqMm22i0W6ic/IsswHlqfU4OcV&#xd;&#xa;b8NQTW2g2sNwhjlUNuUjp8xrB0f7RY2VlqUNpLeK1u1uYoR8wPmM27nt2q80mpalqWmXL2LW9tFO&#xd;&#xa;xZJFPmKdjDcTnG3nFRaxCjag5vPD8moN/BNACAE7A5PX/GtGwsp30G4tnzEJ1cQxv1hRlwqH6VlX&#xd;&#xa;M93JpsdhJptzElkEdrhwNjCLDHH128fWuj06+h1Kxiu7dg0cgzweh7j8KzdUnivdYstMikXz4ZVu&#xd;&#xa;n/2VXHH1O7j6VuUUUUUUUUUUUVjwf8jdd/8AXnF/6G9bFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFY/hf/AJBB/wCvif8A9GNWxRRRRRRRRRVG+0fT9RlWS8tlmdV2gkngfhV1VCqF&#xd;&#xa;UYA4ApaKKSo47eGKaWWOMLJLjeR3xwKba2lvZxCK2iWNAScD1JyanooooooooooorHg/5G67/wCv&#xd;&#xa;OL/0N62KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKx/C/8AyCD/ANfE/wD6Mati&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiseD/kbrv/rzi/8AQ3rYoooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooooooorktI8Q2WmWklrcrciVJ5SdsDEcyMRz+NXf+Ew0v0u//Adv8KP+Ew0v0u//&#xd;&#xa;AAHb/Cj/AITDS/S7/wDAdv8ACj/hMNL9Lv8A8B2/wo/4TDS/S7/8B2/wo/4TDS/S7/8AAdv8KP8A&#xd;&#xa;hMNL9Lv/AMB2/wAKP+Ew0v0u/wDwHb/Cj/hMNL9Lv/wHb/Cj/hMNL9Lv/wAB2/wo/wCEw0v0u/8A&#xd;&#xa;wHb/AAo/4TDS/S7/APAdv8KP+Ew0v0u//Adv8KP+Ew0v0u//AAHb/CkbxlpKjLfagOnNu1L/AMJh&#xd;&#xa;pfpd/wDgO3+FH/CYaX6Xf/gO3+FH/CYaX6Xf/gO3+FH/AAmGl+l3/wCA7f4Uf8Jhpfpd/wDgO3+F&#xd;&#xa;H/CYaX6Xf/gO3+FH/CYaX6Xf/gO3+FH/AAmGl+l3/wCA7f4Uf8Jhpfpd/wDgO3+FH/CYaX6Xf/gO&#xd;&#xa;3+FH/CYaX6Xf/gO3+FH/AAmGl+l3/wCA7f4Uf8Jhpfpd/wDgO3+FH/CYaX6Xf/gO3+FH/CYaX6Xf&#xd;&#xa;/gO3+FN0a/h1PxHeXNusoi+yxpmRCvIZj3+oroqKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKK5zxCsl9ex29u0h+xxtcyxqSAxxmPj+L5l6Vs6dcG60+CZmUuyDzN&#xd;&#xa;vZsfMPbBzxVqiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiisfRP393qV1LzMLlrcN0+RD8ox/wI80eHv3CXdlJxPDO7uOwDsWXn6VsUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVFcxGe2lhD&#xd;&#xa;lDIhXcOq5GM1zV3ZanomnRfZtYYr5sceDbJk7mC5J6k89609P0i7s9Rlu5dTe487HmoYVXdgYHI6&#xd;&#xa;Y9q16KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKx/E/wDyDYv+vqD/ANGLWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRWP4n/AOQbF/19Qf8Aoxa2KKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKx/E/8AyDYv+vqD/wBGLWxRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWP4n&#xd;&#xa;/wCQbF/19Qf+jFrYoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooooooooorH8T/8AINi/6+oP/Ri1sUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUVBfXP2OxuLorvEMTSbc4zgZx+lZNrrGrXdrFcQ6IpjlQOpN2oyCMjtUv9oa1/wBA&#xd;&#xa;Nf8AwMX/AAo/tDWv+gGv/gYv+FH9oa1/0A1/8DF/wo/tDWv+gGv/AIGL/hR/aGtf9ANf/Axf8KP7&#xd;&#xa;Q1r/AKAa/wDgYv8AhR/aGtf9ANf/AAMX/Cj+0Na/6Aa/+Bi/4Uf2hrX/AEA1/wDAxf8ACj+0Na/6&#xd;&#xa;Aa/+Bi/4Uf2hrX/QDX/wMX/Cj+0Na/6Aa/8AgYv+FH9oa1/0A1/8DF/wo/tDWv8AoBr/AOBi/wCF&#xd;&#xa;H9oa1/0A1/8AAxf8KP7Q1r/oBr/4GL/hR/aGtf8AQDX/AMDF/wAKP7Q1r/oBr/4GL/hR/aGtf9AN&#xd;&#xa;f/Axf8KP7Q1r/oBr/wCBi/4Uf2hrX/QDX/wMX/Cj+0Na/wCgGv8A4GL/AIUf2hrX/QDX/wADF/wo&#xd;&#xa;/tDWv+gGv/gYv+FZmv3uqvYRibSFiX7RCQ32pWyd4wOnc8Vp/wBoa1/0A1/8DF/wo/tDWv8AoBr/&#xd;&#xa;AOBi/wCFH9oa1/0A1/8AAxf8KP7Q1r/oBr/4GL/hR/aGtf8AQDX/AMDF/wAKP7Q1r/oBr/4GL/hR&#xd;&#xa;/aGtf9ANf/Axf8KP7Q1r/oBr/wCBi/4Uf2hrX/QDX/wMX/Cj+0Na/wCgGv8A4GL/AIUf2hrX/QDX&#xd;&#xa;/wADF/wo/tDWv+gGv/gYv+FH9oa1/wBANf8AwMX/AAo/tDWv+gGv/gYv+FH9oa1/0A1/8DF/wo/t&#xd;&#xa;DWv+gGv/AIGL/hR/aGtf9ANf/Axf8KP7Q1r/AKAa/wDgYv8AhR/aGtf9ANf/AAMX/Cj+0Na/6Aa/&#xd;&#xa;+Bi/4Uf2hrX/AEA1/wDAxf8ACj+0Na/6Aa/+Bi/4Uf2hrX/QDX/wMX/Cj+0Na/6Aa/8AgYv+FH9o&#xd;&#xa;a1/0A1/8DF/wo/tDWv8AoBr/AOBi/wCFRXWsataWstxNoiiOJC7EXanAAye1bMMnmwRyYxvUNj0y&#xd;&#xa;Kkoooooooooooooooooooooooqhrv/IB1H/r1k/9BNN8O/8AIu6b/wBe0f8A6CK0aKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKx/E//INi/wCvqD/0YtbFFFFFFFFFFFFFFFFFFFFFFFFFFZ3iH/kXtS/69ZP/AEE1&#xd;&#xa;asv+PG3/AOua/wAqnoooooooooooooooooooooooqhrv/IB1H/r1k/8AQTTfDv8AyLum/wDXtH/6&#xd;&#xa;CK0aKKKKKKKKKKKKKKKKKKKKKKKx/E//ACDYv+vqD/0YtbFFFFFFFFFFFFFFFFFFFFFFFFFFZ3iH&#xd;&#xa;/kXtS/69ZP8A0E1asv8Ajxt/+ua/yqeiiiiiiiiiiiiiiiiiiiiiiiqGu/8AIB1H/r1k/wDQTTfD&#xd;&#xa;v/Iu6b/17R/+gitGiiiiiiiiiiiiiiiiiiiiiiisfxP/AMg2L/r6g/8ARi1sUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUVneIf8AkXtS/wCvWT/0E1asv+PG3/65r/Kp6KKKKKKKKKKKKKKKKKKKKKKKoa7/AMgH&#xd;&#xa;Uf8Ar1k/9BNN8O/8i7pv/XtH/wCgitGiiiiiiiiiiiiiiiiiiiiiiisfxP8A8g2L/r6g/wDRi1sU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUVneIf+Re1L/r1k/9BNWrL/jxt/8Armv8qnoooooooooooooooooo&#xd;&#xa;oooooqhrv/IB1H/r1k/9BNN8O/8AIu6b/wBe0f8A6CK0aKKKKKKKKKKKKKKKKKKKKKKKx/E//INi&#xd;&#xa;/wCvqD/0YtbFFFFFFFFFFFFFFFFFFFFFFFFFFZ3iH/kXtS/69ZP/AEE1asv+PG3/AOua/wAqnooo&#xd;&#xa;ooooooooooooooooooooqhrv/IB1H/r1k/8AQTTfDv8AyLum/wDXtH/6CK0aKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKx/E//ACDYv+vqD/0YtbFFFFFFFFFFFFFFFFFFFFFFFFFFZ3iH/kXtS/69ZP8A0E1asv8A&#xd;&#xa;jxt/+ua/yqeiiiiiiiiiiiiiiiiiiiiiiiqGu/8AIB1H/r1k/wDQTTfDv/Iu6b/17R/+gitGiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiisfxP/AMg2L/r6g/8ARi1sUUUUUUUUUUUUUUUUUUUUUUUUUVneIf8AkXtS&#xd;&#xa;/wCvWT/0E1asv+PG3/65r/Kp6KKKKKKKKKKKKKKKKKKKKKKKoa7/AMgHUf8Ar1k/9BNN8O/8i7pv&#xd;&#xa;/XtH/wCgitGiiiiiiiiiiiiiiiiiiiiiiisfxP8A8g2L/r6g/wDRi1sUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUVneIf+Re1L/r1k/9BNWrL/jxt/8Armv8qnoooooooooooorJ1mWVrvT7FJXiS7kdXeNtrgKh&#xd;&#xa;YYPbkflTf7AH/QV1X/wJ/wDrUf2AP+grqv8A4E//AFqP7AH/AEFdV/8AAn/61H9gD/oK6r/4E/8A&#xd;&#xa;1qP7AH/QV1X/AMCf/rUf2AP+grqv/gT/APWo/sAf9BXVf/An/wCtR/YA/wCgrqv/AIE//Wo/sAf9&#xd;&#xa;BXVf/An/AOtR/YA/6Cuq/wDgT/8AWpsnhyOWJ45NT1N0cFWU3OQQeo6UReHI4Ykii1PU0jQBVVbn&#xd;&#xa;AAHQDinf2AP+grqv/gT/APWo/sAf9BXVf/An/wCtR/YA/wCgrqv/AIE//Wo/sAf9BXVf/An/AOtR&#xd;&#xa;/YA/6Cuq/wDgT/8AWo/sAf8AQV1X/wACf/rUf2AP+grqv/gT/wDWo/sAf9BXVf8AwJ/+tR/YA/6C&#xd;&#xa;uq/+BP8A9aj+wB/0FdV/8Cf/AK1M0NZYNT1S0e5uLiOFothnfcRlMnmtuiiub0+xk1KW/ll1LUI9&#xd;&#xa;l5LGqxTlVCg8DFXP7AH/AEFdV/8AAn/61H9gD/oK6r/4E/8A1qP7AH/QV1X/AMCf/rUf2AP+grqv&#xd;&#xa;/gT/APWo/sAf9BXVf/An/wCtR/YA/wCgrqv/AIE//Wo/sAf9BXVf/An/AOtR/YA/6Cuq/wDgT/8A&#xd;&#xa;Wo/sAf8AQV1X/wACf/rUybw1FOgSbUtTdQwYBrjPIOQenrT/AOwB/wBBXVf/AAJ/+tR/YA/6Cuq/&#xd;&#xa;+BP/ANaj+wB/0FdV/wDAn/61H9gD/oK6r/4E/wD1qP7AH/QV1X/wJ/8ArUf2AP8AoK6r/wCBP/1q&#xd;&#xa;P7AH/QV1X/wJ/wDrUf2AP+grqv8A4E//AFqP7AH/AEFdV/8AAn/61H9gD/oK6r/4E/8A1qP7AH/Q&#xd;&#xa;V1X/AMCf/rVTt45rDxdBaC+u54JLRpCs8pf5t2K6SiioL2VoLG4mTG6ONmGemQM1kWWlNfWUF3Jq&#xd;&#xa;eoo9xGsrLHcEKCwyQBjgc1N/YA/6Cuq/+BP/ANaj+wB/0FdV/wDAn/61H9gD/oK6r/4E/wD1qP7A&#xd;&#xa;H/QV1X/wJ/8ArUf2AP8AoK6r/wCBP/1qP7AH/QV1X/wJ/wDrUf2AP+grqv8A4E//AFqP7AH/AEFd&#xd;&#xa;V/8AAn/61H9gD/oK6r/4E/8A1qbL4cjmieKXU9TeNwVZWucgg9QeKVfD6qoVdU1QKBgAXPT9KX+w&#xd;&#xa;B/0FdV/8Cf8A61H9gD/oK6r/AOBP/wBaj+wB/wBBXVf/AAJ/+tR/YA/6Cuq/+BP/ANaj+wB/0FdV&#xd;&#xa;/wDAn/61H9gD/oK6r/4E/wD1qP7AH/QV1X/wJ/8ArUf2AP8AoK6r/wCBP/1qP7AH/QV1X/wJ/wDr&#xd;&#xa;Uf2AP+grqv8A4E//AFqf4Z1CbVdBtr252+bLu3bBgcMR/StWisfVf+Q7of8A11l/9FNWxRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRWPpn/Iw61/vQ/+i62KKKx/Dv3dS/7CE38xWxRRRRRRRRRRRRRRRRRRRRWBcf8A&#xd;&#xa;I92n/Xi//oVb9FFVNU/5BV5/1wf/ANBNM0T/AJAen/8AXtH/AOgir1FFFFFFFFFFFFFFFFFFFJWD&#xd;&#xa;4F/5FGx/7af+jGrforH1X/kO6H/11l/9FNWxRRRRRRWXrl9JpkMV8WxZwsTcqACzKRhcf8CIo1y/&#xd;&#xa;ktbeKO2bbczt+7JAIAX5mz/wEH8aL7VhHoA1K2UkSLGyBuCA5ABP03VJZPGL+4t2kllu4oovOduF&#xd;&#xa;bO7BAzgHg5x7VXPiK2MksUFvdXMkMjRyJBGGKEHGTzwDzj6Gr1jfxXyMUWSORDh4pRtdPTI7ZHNV&#xd;&#xa;JddiWRlhsr26RTjzYIt6EjqAc9jx9RVfwXNJP4ZtpJpHkctJlnOT99q3aKKKKKKx9M/5GHWv96H/&#xd;&#xa;ANF1sUUVj+Hfu6l/2EJv5itiiiud04avqUElwur+SvnSIqC2RsBXIHP4VfsdXjlW7S72wy2WBcHP&#xd;&#xa;yDIzkH6VGPEEIOZ7O9toe880W2NR6k5qW91u1s7tbVxJJO8XmxpGoJkGcYXnk9T9BUsWpRNYvdzx&#xd;&#xa;TWsaHBFwuw/55qOz1eK6nEL29zayMPkW4j2b8ddvPOKsWd5Feef5Qb9zK0Lbhj5h1x7UiahA1xdw&#xd;&#xa;klTaBWlZuAARnOfpVL/hIId2Ws71IP8An4aLEQX+9uz93vmprvWIrebyo7e5u3ABcWyb9meRnnjP&#xd;&#xa;aq0+q2E5sjKLlJGuljWMEqySYyA4B6Y5xz1FaN9exWMQeQO7MdqRxjLufQDucZP4VFY6nFeu0fkz&#xd;&#xa;28yjd5U6bWK/3gM9M8VWbxDbedNDDBdXMsEhjkSGMMy47kZ6Ht9DVuw1GK+3qI5YJU5aKZdrgHoc&#xd;&#xa;eh5/KrlFFYFx/wAj3af9eL/+hVv0UVU1T/kFXn/XB/8A0E0zRP8AkB6f/wBe0f8A6CKvUUUVgtf3&#xd;&#xa;moazd6Za3MVmbXB8zAkdwVB+6RgD5uue1W7a21W3uEaa/W8iY4dWiWPYP7wx1PbHvVKXXpofEFxa&#xd;&#xa;mzvZYY4VIWKEE7tzZbr0PH5GrUviC2imWBoLn7S0SyrB5Y8xgSRgDPUYJPtTRqNrPqWnCWG8guJf&#xd;&#xa;N8lJAUHA+bcucHjp1o/4SK2d5Et7e7uXikaORYIwxQqcc88A4OPpV2w1CK+V9qSRSJjfFKu11z0J&#xd;&#xa;HvioLvWIra4aGO2urp0+/wDZ49+w9QDzwcc1HF4gtpIpmMFzHJFII/JeMCRmI3AAZ5OOafa6zFPO&#xd;&#xa;sUtrd2pfhGuI9gdv7o55PU49jVm+vorGNS6vJI5wkUQ3O/rgd8Dn6VjSaq93r2kxLa3tqpeXd5yb&#xd;&#xa;A/7s8dea6OiiikrB8C/8ijY/9tP/AEY1b9FY+q/8h3Q/+usv/opq2KKKKKKKRlDDDAEehrmNCsZJ&#xd;&#xa;zFb3ZDx6ahgIB584g7iD3GxwPrRaRS/2xaaYSpGnO8gHbyCpWMe5HGc/nWhZf8jTqn/XCD/2ejw4&#xd;&#xa;Bs1E4GTfz5P/AAKqjpJJceKI4lZpGjUKF6kmHjFWLPXNNgsYIBcxyXKRqpt4yDIWA5AHrmovA3Ph&#xd;&#xa;W1/3pP8A0Nq6CiiiiiisfTP+Rh1r/eh/9F1sUUVj+Hfu6l/2EJv5itiiiuW0Oz1Kazle21X7PEbm&#xd;&#xa;bEf2dXx+8bua0NU04Q+F7yysomdjAyqo5Zif51hXrrqGnPZP4jF15igG2gt0MjYwcAA54x+lbcag&#xd;&#xa;eLEBH3dOGMjkfPTtf8xJ9NnWCWaOG4LSrEu4hdjDJHpkirNtq9he3KRWcq3LckvFhhH/ALx7Z7Vn&#xd;&#xa;adqNnpcuoRahcxW0kl5JKiyttLIcYYe3BpumzxX+oa85ilaF0jG3GGddhHH1HT61UGofZoglrrcc&#xd;&#xa;5jGI9OMSB2x0jJ5Oe3rVrUJoba/kkGpf2TNMqmQzRqyzYHG3ce3Q49ao3d1LdPpJkdZkTU0VLlVA&#xd;&#xa;E42/eAHHByPwraviLLW49RuDi0+z+SX7Rtuzub0HbPqajluIdY1GxfTpFmjtpTJLKhyuNpG3I78g&#xd;&#xa;49Kk8PAbtUOBn7fLz+VFv/yNt7/16Rf+hPWxRRWBcf8AI92n/Xi//oVb9FFVNU/5BV5/1wf/ANBN&#xd;&#xa;M0T/AJAen/8AXtH/AOgir1FFFYOtSaJcu1rq7i3KMGUu/l+Zx1BB5HOPrWXYW1ha69bS+H74TJJ+&#xd;&#xa;7uIFfzNqckuSScchRWrcXMGneJZrm9lS3gktERJJDgMwZiQD64IpbOWG58VTTwuskbWMRR15BG9+&#xd;&#xa;lM1b/kcNA/3bj/0AVP4aAFreEAZN9Pk/8DNGn/8AIzax/wBc7f8Ak1VNF1Sw03TltdQu4be6R5C8&#xd;&#xa;crAMMuxGfwIrJuZXu726u4Xe0RNRidpZEB8pRARuIPGOn5ir8Drf6jZD+3RqPkzCQRQQJ8vBG5iD&#xd;&#xa;wOcfiKu3VzBYeJXub6VIIHtESOSQ4UsHYkA+uCKhuNTtr/xFowtH86NXlJmTlM+W3y59e+PcV0dF&#xd;&#xa;FFJWD4F/5FGx/wC2n/oxq36Kx9V/5Duh/wDXWX/0U1bFFFFFFFFIABnAAzyaNo3bsDPrRgAk4GT1&#xd;&#xa;NAAHQAZ54oAAJIAyevvTRFGG3CNQfXFOVQowoAHoKWiiiiiisfTP+Rh1r/eh/wDRdbFFFY/h37up&#xd;&#xa;f9hCb+YrYoopAABgAD6UtMEUanIjUH1Ap2BnOBnpmikWNE+4irn0GKRo43OWRWPqRmlCqvQAfQUn&#xd;&#xa;lRht3lrnrnFK0aP99FbHqM0bEwBtXA5Ax0pSAwwwBB7GkVFQYRQo9hilAAzgAZ5NGBnOBn1paKKw&#xd;&#xa;Lj/ke7T/AK8X/wDQq36KKqap/wAgq8/64P8A+gmmaJ/yA9P/AOvaP/0EVeooopjRo5y6K31GaFjR&#xd;&#xa;DlUVT7DFKyK/31DY9RmgKq/dUDjHApSoJBIGR0PpQAB0AHfijABJAGT1NZd5pEt1dPMupXEIbHyI&#xd;&#xa;kZA4x3UmrNjp8dnG4LtNLKcyyyYzIRwMgccDA4HarKxohyqKp9hilZFf76hvqM0ixouNqKMcjAp9&#xd;&#xa;FFFJWD4F/wCRRsf+2n/oxq36Kx9V/wCQ7of/AF1l/wDRTVsUUUUUUUUUUUUUUUUUUUUUVj6Z/wAj&#xd;&#xa;DrX+9D/6LrYoorH8O/d1L/sITfzFbFFFFFFFFFFFFFFFFFFFFFYFx/yPdp/14v8A+hVv0UVU1T/k&#xd;&#xa;FXn/AFwf/wBBNM0T/kB6f/17R/8AoIq9RRRRRRRRRRRRRRRRRRRSVg+Bf+RRsf8Atp/6Mat+iuf8&#xd;&#xa;R2zXepaPAlxLbs8smJYjhlxGTwf0pf8AhG7j/oYNV/7+j/Cj/hG7j/oYNV/7+j/Cj/hG7j/oYNV/&#xd;&#xa;7+j/AAo/4Ru4/wChg1X/AL+j/Cj/AIRu4/6GDVf+/o/wo/4Ru4/6GDVf+/o/wo/4Ru4/6GDVf+/o&#xd;&#xa;/wAKP+EbuP8AoYNV/wC/o/wo/wCEbuP+hg1X/v6P8KP+EbuP+hg1X/v6P8KP+EbuP+hg1X/v6P8A&#xd;&#xa;Cj/hG7j/AKGDVf8Av6P8KP8AhG7j/oYNV/7+j/Cj/hG7j/oYNV/7+j/Cj/hG7j/oYNV/7+j/AAo/&#xd;&#xa;4Ru4/wChg1X/AL+j/Cj/AIRu4/6GDVf+/o/wo/4Ru4/6GDVf+/o/wo/4Ru4/6GDVf+/o/wAKP+Eb&#xd;&#xa;uP8AoYNV/wC/o/wo/wCEbuP+hg1X/v6P8KP+EbuP+hg1X/v6P8KTw7atZ6trED3M1yytF+8mOWOU&#xd;&#xa;zzXQUUVyen6PLfT6lMmq31qPt0o8uBwF69elXf8AhG7j/oYNV/7+j/Cj/hG7j/oYNV/7+j/Cj/hG&#xd;&#xa;7j/oYNV/7+j/AAo/4Ru4/wChg1X/AL+j/Cj/AIRu4/6GDVf+/o/wo/4Ru4/6GDVf+/o/wo/4Ru4/&#xd;&#xa;6GDVf+/o/wAKP+EbuP8AoYNV/wC/o/wo/wCEbuP+hg1X/v6P8KP+EbuP+hg1X/v6P8KP+EbuP+hg&#xd;&#xa;1X/v6P8ACj/hG7j/AKGDVf8Av6P8KP8AhG7j/oYNV/7+j/Cj/hG7j/oYNV/7+j/Cj/hG7j/oYNV/&#xd;&#xa;7+j/AAo/4Ru4/wChg1X/AL+j/Cj/AIRu4/6GDVf+/o/wo/4Ru4/6GDVf+/o/wo/4Ru4/6GDVf+/o&#xd;&#xa;/wAKP+EbuP8AoYNV/wC/o/wo/wCEbuP+hg1X/v6P8KpWdg9h41t0kvbm7LWbndO2SPmHArrKKKqa&#xd;&#xa;p/yCrz/rg/8A6CawdL8Pzy6VZyDXNTjDwIwRJAAuVHA46Va/4Ru4/wChg1X/AL+j/Cj/AIRu4/6G&#xd;&#xa;DVf+/o/wo/4Ru4/6GDVf+/o/wo/4Ru4/6GDVf+/o/wAKP+EbuP8AoYNV/wC/o/wo/wCEbuP+hg1X&#xd;&#xa;/v6P8KP+EbuP+hg1X/v6P8KP+EbuP+hg1X/v6P8ACj/hG7j/AKGDVf8Av6P8KP8AhG7j/oYNV/7+&#xd;&#xa;j/Cj/hG7j/oYNV/7+j/Cj/hG7j/oYNV/7+j/AAo/4Ru4/wChg1X/AL+j/Cj/AIRu4/6GDVf+/o/w&#xd;&#xa;o/4Ru4/6GDVf+/o/wo/4Ru4/6GDVf+/o/wAKP+EbuP8AoYNV/wC/o/wo/wCEbuP+hg1X/v6P8KP+&#xd;&#xa;EbuP+hg1X/v6P8KP+EbuP+hg1X/v6P8ACk/4Ru4/6GDVf+/o/wAKXwL/AMijY/8AbT/0Y1b9FY+q&#xd;&#xa;/wDId0P/AK6y/wDopq2KKKKQEEkAjI6j0paQMCSAQSOuD0paKQkAgEgE9PeloooppdRnLAbevPSl&#xd;&#xa;paKKKKKx9M/5GHWv96H/ANF1sUUVj+Hfu6l/2EJv5itiiikJCgkkADuaKGYKMsQAO5opaQkAZPAo&#xd;&#xa;BBAIIIPcUtFFIWC4yQM8DJ60ZGcZGeuKWiiiiisC4/5Hu0/68X/9Crfooqpqn/IKvP8Arg//AKCa&#xd;&#xa;Zon/ACA9P/69o/8A0EVeoopCQMZIGeBS0hIGMkDPApaKQnAyaAQQCDkGloopCQMZIGeBQCDnBBxw&#xd;&#xa;aWiiiikrB8C/8ijY/wDbT/0Y1b9FY+q/8h3Q/wDrrL/6KatZyQjFV3MBwM4yazxrEA0yS8kUp5T+&#xd;&#xa;VInXbJkKVz3+Y4z0q090sFkLi7HknaCyZ3ENj7ox1PbjrVFNWukdXvNNa3tWOBN5obGehKgZA9Se&#xd;&#xa;neprG5gm1HUEhhVXjaPfKD/rcoCD+A4qOfVLhpmTTrE3qpw7iUIoPoCev4dDxWf4VeWTUtbeeHyZ&#xd;&#xa;DcLuj3Btvy+o61q61qQ0jSp75ojKIsfIDjOWA6/jVG5128ht2u00iWSzGD5nmANtzjOzG6lvbiO6&#xd;&#xa;1Hw/cQndHLI7oSMZBiYitC/uLyDy/sdj9r3Z3fvQm3069aitNSluBcRPaGK9gQObfzAcg52/N05w&#xd;&#xa;fpSHWIP7MW8VS29/KVOmZN23bn/e4z0pmt3Ey6fDDGWgnvJFgV1bmJmBOffGKnt9KtobWSCQNcec&#xd;&#xa;MSvMdzSf7x74HFVNL8yx1S40yW4muQUFzHJK2Sqk7dn5gn8a2aKKKKKx9M/5GHWv96H/ANF1sUUV&#xd;&#xa;j+Hfu6l/2EJv5irt9fCxaAyRkwyOI2kB+6xICjHfJP4Ufbg2p/Yo4y7Im+Vs42A52/XOD06VWuNU&#xd;&#xa;nMzR6dYm9EfEjCUIoPoCevvjpTbvUraTQ7u4mg8wQxt51s/B46qc9vfvV6a7htbQTynYmBhQMk8d&#xd;&#xa;AO59hXM+Kr3UpfDl4s2kmGFlGZftCtgbh2611UH+oj/3R/Ksq710waw2mQ2bzz+SJE2tgNk9CcYX&#xd;&#xa;oeTVW81qWSK90++sXs5ntZGi+fer/K2eQMcYq74eZl8L2DIm9xbKVXONxx0zTRq95A6HUNMNrAzB&#xd;&#xa;PNE6vhicAYHPJIq7d3wtLi3SWM+VO3liQHo5+6Me/PPtQl8JdSks4oy3kqDK+cbCeVGO+Rn8qzdH&#xd;&#xa;t11Rjq1y7yLI+6CBzlYNvGR75BOferWs6cbuEzW872t0i/LNGcEqDnafUe1WdNvBqGnW92EKCZA+&#xd;&#xa;0nOM1aoooorAuP8Ake7T/rxf/wBCrfooqpqn/IKvP+uD/wDoJpmif8gPT/8Ar2j/APQRT/twXUxZ&#xd;&#xa;SxlGdC8TZzvAxu+mMjr1zTbXUY7n7TIAEt4GKeczYBKkhuO2COtVTq90SZotMkeyHPn7wG2jqQmN&#xd;&#xa;x78d6lvL21Lac/lJcCe42xPkfI21ufrwR+NTX18LUKkcZnuZP9XCpwT7k9h7nisW+ur+fUdIW703&#xd;&#xa;7KgvAQ/nq+TsfjArpqxRrk89xc29lpr3EltMY3zIEXAA5BIx36U2LVhqWm6nFJbvbXNtG6yxPzjh&#xd;&#xa;sEHGCDg9KtaSzp4bsmij8yRbSMqm7G47BgZ7VEmrXcU0S6hpptIpXEayeesnzk4AwP51cjvgdTks&#xd;&#xa;ZIykgTzIznO9OAT7cnGKSwvhfxSTRxkQBisbk/fxweO2CCPwrM0O2bUMavdTySpOfNt7dzlYPp79&#xd;&#xa;efc0muj+xT/bUDyCKJsz2qNtWYt8oY++SDn2FdBRRRRSVg+Bf+RRsf8Atp/6Mat+isfVf+Q7of8A&#xd;&#xa;11l/9FNWxXH3ENz/AMJWNJWGQ6TcOZ5fkODJy+d/b5gOM10Gs2cl5ax+TgyQTJOqnjeUOdue2cYz&#xd;&#xa;VK61JdUtJtOt7e4E86NE++JlWMEYLbiMHGenen6JbSW2pamjq20GFVcjAbESgkflVbTNQj0a0+w3&#xd;&#xa;kNyJkkkY+Xbu64Zyw5AIPBFO8MLcnUNYlurZ7dpbhWCscj7vY9DTvHH/ACKV99E/9DWnza3Hd2z2&#xd;&#xa;9la3UtxIhVEeF41PHOWYYHGahjs57f8A4RqGSM77cFZdvIUiEjkj3pdZx/aLf2ibwWmwfZ/sm/O7&#xd;&#xa;+Pds5/u4z7471H4ajiGr6lJbLdiBo4QrXIfcSN+eX59KgtrS6l8ST6cqg6RaSLNtyNyyECQHPU/M&#xd;&#xa;Sa1fEY2W9pdN/qbS5WeY/wB1AGBOO/UVpwzRXEQlhkWSNujIcg/jWTZSJfeI7i8tnWS3itxbM6nj&#xd;&#xa;zA24gevDDmtqiiiiisfTP+Rh1r/eh/8ARdbFFFY/h37upf8AYQm/mKs63AJ9Kn+Us8S+bGB13r8y&#xd;&#xa;/XkDis3wgbq7tJdQ1KN1vZW8tiybMov3ePxNPtbldBR7W7indWleSOWKJnDBmLEEKDjGcc9agvrS&#xd;&#xa;eXSNbvDEwe9hGyEDLAKuB+JHOO1XdZikazsJVRmW2uI5pAoyQqg5wOpPsKy/Euqf2noF3bWFndSu&#xd;&#xa;yjduhZNo3DkZHzfQV1EIxBGD12j+Vc1cX8Nh43nkmWVg1iqjyomc/e9ADS6m8+ryLc2tpL9lgt7h&#xd;&#xa;S7gozM0ZGAhGfTn3qe3S8i8HWSQK6SrFGJVxhgnG/HfOM+9ZN5Hp8ot1sV1Z5hcRECYTlcBxkndx&#xd;&#xa;0rovEigaLPcj/W2gM8R9HUHB96Z4ctrtLRrvUlAv7nBlKkYIHC8DjpTfDMiQ2H9nO6i7tWYSx55G&#xd;&#xa;TuH1GGHNXtUvbewspJbmURqRtGepJ7Ad6ZodtLZ6LZ206hZYolVgDnBAq/RRRRWBcf8AI92n/Xi/&#xd;&#xa;/oVb9FFVNU/5BV5/1wf/ANBNM0T/AJAen/8AXtH/AOgiszxebq1tItQ06N2vYm8tCqb8K33uPwFW&#xd;&#xa;LbTvtHhhrXmKW8gLSFh0kkGWOPqTxSR6x9njW0ezuPtiAIIxGxRj2+fG0Z457ZqsdOlsrfQ7fBkM&#xd;&#xa;V4XcqvCgiQ8/nirOoP8AYNej1CaOVrc2xgzEhc7ywboOcYB5qreXsmpahpTW9nP9ljugWmdSpB2N&#xd;&#xa;xtIzjkc9K6SuY03V7awutVimS5ZjfO2Y4HcY2r3A9qmgiupm1q9ktmijuoFEAJyzgK3OOoJyODzT&#xd;&#xa;2W6j8LaekayLtihFwFBDiPaN+O+cenNZE0djJdWH2FdVeVbyJj54mKhQ3JO7itDxdJdWRs7vTMLf&#xd;&#xa;zSraKWwQVbJxg8dQOa2tOtFstPjt0XbtBJGc/MSSf1JrP8LXESabHpjSKLuyURzR55U+3qOeoqPx&#xd;&#xa;di80xtIgZWvroqYosgEhWDEn04U/lW/RRRRSVg+Bf+RRsf8Atp/6Mat+isfVf+Q7of8A11l/9FNW&#xd;&#xa;xRRRRRRVbULGDUrKS0ulLQyY3AEjOCD1HuKsDgYpaKKgtbSG1VhEpy7FmZjlmPuTyfb0FSSRpLG0&#xd;&#xa;ciK6MMFWGQfwqsumWyRTxRK0UcwwyxuVC8fw4+7+FT29tBaoUt4Y4lJyQihQT68VLRRRRRWPpn/I&#xd;&#xa;w61/vQ/+i62KKKx/Dv3dS/7CE38xWxRRRRRRVZbG3XUXvwp+0PGIi2TjaDnpVmiioLq1iu0VJgWR&#xd;&#xa;WDbc4DY7H1HsamAAGAMAVVl061luEuPL2TKwbfGdpbHZiOo9jTp7C2uZxNPEJSq7Qr/Mo5znB4z7&#xd;&#xa;9as0UUUUVgXH/I92n/Xi/wD6FW/RRVTVP+QVef8AXB//AEE0zRP+QHp//XtH/wCgir1FFFFFFQW1&#xd;&#xa;pDamYwqQZpDK+TnLEAH+Qqeiiq8tnBNcpcSpveMYUMcqpznIHTPv1qxVVtPtWuFuBCqTK24vGNpb&#xd;&#xa;2YjqPY+1LHYW0dw1wIg0zMW8x/mZcjGAT0HsPU1ZoooopKwfAv8AyKNj/wBtP/RjVv0Vj6r/AMh3&#xd;&#xa;Q/8ArrL/AOimrYqldavp1lN5N1fQQyYztdwDip7W7t72HzrWZJo843I2Rmlt7mG6QvbypKoYqSpy&#xd;&#xa;AR1FS1FHNvmlj8uRfLIG5lwrZGeD3qWiiiiiq95eRWUcbzbsSSpENozyxwKsUUVH50XnmDzF80Lv&#xd;&#xa;2Z525xnHpmq93qdraSrC77rhwCkCcyMM4yB37/kade6hb2BjN0xjjfOZW4Rcep7Z7VPFLHPEksTq&#xd;&#xa;8bgMrKcgg96fRWPpn/Iw61/vQ/8Aoutiiisfw793Uv8AsITfzFa0jpFG0kjBUQFmYngAd6z49f0i&#xd;&#xa;WRY49StWdyFVRIMkntV2e5htghnlSMO4RSxxlj0H1qWoppvJ8v8AdyPvcJ8i5257n0HvUtFFFFFF&#xd;&#xa;V4byKa8ubVN3mW+3fkcfMMjFWKKjnmit4mlnkWONerMcAU8kAEk4Aqlb6pbXYla0LXEcS7vMiG5W&#xd;&#xa;P90Hu3t7in2WpWl+WW3mRpEA8yPI3Rn0YdjVuisC4/5Hu0/68X/9Crfooqpqn/IKvP8Arg//AKCa&#xd;&#xa;Zon/ACA9P/69o/8A0EVPd3dvZQ+bdTxwx5xudsDNQ2mr6dezeVa3sE0mM7UcE4qy00SzJC0iiVwS&#xd;&#xa;qE8kDqR+YqSovO/0kQ+XJym/ft+XrjGfX2qWiiiiiiq9heRX9otzBu8tiwG4YPDEH9RViio3mijl&#xd;&#xa;jjeRVeUkIpPLYGTj8KS5uYbSBp7mVIolxudzgDJxUUV8k1m91FHK0ahioC8yAdCvqD29aLHUbW/D&#xd;&#xa;fZ5VZ48eZHn5oyezDseDx7VapKwfAv8AyKNj/wBtP/RjVv0Vj6r/AMh3Q/8ArrL/AOimrTuUaW1l&#xd;&#xa;jThnQqPqRXO6Wz6NYR2V7pM80yD5pLaIyq3vuPf1FaGmXVhqa3r2G+2uf9VMCAHjIyASvIHf8qyP&#xd;&#xa;CFhcvZvKup3CIl3JuiCptfDc54zzVnSE1XVrRpptSkt0WWRYzCFJcByPmyOMYwMdq0dMnnfVNTt5&#xd;&#xa;ZTIlu0SpkDjMYJ6ep5rM0NdY1fSoLm61F7YFfkaAKTIPVsjg/SrUGsfYdO1Ca/d5UsJ/JMgUb3GF&#xd;&#xa;wSOBnLUS2WqPaSXU2qzW8uwuYYVQopA6Alc4rQ0WaS50WxnmbfLJAju3qSoJNVbnUH07VJzduxtp&#xd;&#xa;IDJCqgHb5YJkz9QVxVCHXJH0+7Uyv9omZWtW2j5VmyIc/Tv1/Gp/EguU0SzA2PdC5t/vH5S+4dfb&#xd;&#xa;NN1CLUdM0+bUm1OeV4U8w27Knlk/3cgZx+NaGryxpZI8upHTgXH70FRk4Py/MCP/ANVUdE1ES6nL&#xd;&#xa;YxaiNRiWETeeSpKsWxt+UAY4z+NQXFjczeL5hHqVxBmzVwUVDgbyNvI6d6k8Mq891qM13Ibi5trl&#xd;&#xa;7VJnADeWuCBxx1J/Ot+SNJYykihlYYINZfh1j9luoc/u7a6kgiX+6inCj8BWvRWPpn/Iw61/vQ/+&#xd;&#xa;i62KKKx/Dv3dS/7CE38xUfiGwubm6sLmGFJorVmeWNmILDjoB1PBwKiuda09IiLzS7y3gchGklt9&#xd;&#xa;ijPHJzx1qt4ug8yy0k21y8cP2qFECYI56Nk9x2p88erW2tW1jDqks6XELtI0qoDGAVG5cL1578Va&#xd;&#xa;u1vNMFmDqM9x597HGxkVRhSDkcAdaTUJdRm8RpYWlx5Nu1r5kjDG5PmIyuR16DntTj9r0vULKOS/&#xd;&#xa;mvEu5DERMqjZhS2RtA54pzSXerXU8drctaWtu5jMkYHmNIOowQRt569aTSjdwa3eWVxey3UaQxyK&#xd;&#xa;ZFUEElgegHoK1bpZWtJlt2CzFGEZPZscfrXP3GvMdPtYopHF4cmR9owREf3v5gNj+lX7W/fUNXT7&#xd;&#xa;K7C1igDSowAyzgMhH4ZqgsF7c+J9Vit7g20OIS8qYL528AAgjHXP0FXrGS5tdYbTprp7pTb+eJJQ&#xd;&#xa;AwO7bjgAYqrqd1bxXs27xKbV15+z5j+XjpyM8/1qHW5ptU8EJeGQwNIiSOsYGGyRxz25z+FO11b7&#xd;&#xa;SNDuJ11S4nctGoMip8oLAHGB3BroLW2hs7dILeMRxIMKo7Csu5jS08S2D26iNrzzBOR/GFTK/l7V&#xd;&#xa;tUVgXH/I92n/AF4v/wChVv0UVU1T/kFXn/XB/wD0E0zRP+QHp/8A17R/+gisu6tp7PxDPqctmbq1&#xd;&#xa;kRUURAvIpA7L0x71Iuq6ZcX1ta3NlPaSu4eEzxeUGYEYAOeTyOKg1SyuJfFVn5eo3EPmQyldqp+7&#xd;&#xa;A2ZAyO/vTbGPVrnUdQsW1SUW9tIoWcKnmklQduNuMcn34FX7aS5g16KxkupJ4xZtIWcAFm8wDJwP&#xd;&#xa;Q4qpaHVtSvdQi+2G3tIbllSWMAyZAHy4II24Oc9c1ZtLqaxv7qzuriS6jhtxc+a4AfksCOABj5f1&#xd;&#xa;plut5rUIvotQms4JP9SkSqcp2LbgcN19uBVjw7NPNYzC5nad4rmWIOwAJCsQOn0qXW5p7ayFzA+x&#xd;&#xa;IJFln9TEvLAe+KpXGsY1i2WN3Fuu1JV2jlpceX+WGz/WrWj3M16bq7LlrWSTFupGCoUbWz/wIGsf&#xd;&#xa;w9Z6hd6UpF/JZwrJIIhAFJceY2S24HnOenatTQ76e4kv7Wd95spvKEpGGcYzk9s/SsS+1qPTLV7u&#xd;&#xa;18RDUJY8bbZzHh8nB+6AeAc/hWhr9rNPr+keVezQbmkUbAp2kIxJGQeSOKfe28i3OladdXMl3DPL&#xd;&#xa;IZfMABfapZegHQgGt4AAAAYA6AVjzgW3iezEACfbIpTPj+Mpt2/luP51s0lYPgX/AJFGx/7af+jG&#xd;&#xa;rforH1X/AJDuh/8AXWX/ANFNWs4LIyhipIwCO1ZOzxBH8kb6fIi8K8u8Ow9WwMZ9cVNpdhPBc3N5&#xd;&#xa;dmL7TchVdYc7AFzgjPOfmOar2OnX+lyeRZPbPZvKZHM27zPmOWxjj6Vc0ayfT9OW3lZWYSSNlenz&#xd;&#xa;OWH86LOye31LULlmUrdOjKB1G1Apz+VGi2T6dpFtZysrPEu0leh5qlLoIurLVLS5l2x31x5oMfVR&#xd;&#xa;hOOe+VrIl16e7he2fULGNZFK7rdJfMz2A3Ljk8c9jXSaLDJb6LYwTKUkjt0V1PYhQCKj1jTP7QWE&#xd;&#xa;rtDo21ixPMTYEi/iBiqt34ejku7JrVhb28JQyopyX8sgxjnPA5/Or2rWT30ECRsqmO4jlO7uFYEj&#xd;&#xa;9KXWbN9Q0i6tImVXmjKgt0FQajYXMlxDd2ZhaeOMxbLjPllSQSeOc8D9ai03T76PV5L69+xrugEI&#xd;&#xa;W23dmzk5+tS31leDUBf6e0HnmIQss+du0EnIxznJqjZifQr2X7RCXtrtvtE9wnKxzMcFQOu3gY4z&#xd;&#xa;zWrqN/8AY0VY4XuLiTPlxJjLY69cDjPrUeiWr21iXmUpPcuZ5UP8DtyVHsDWjRWPpn/Iw61/vQ/+&#xd;&#xa;i62KKKx/Dv3dS/7CE38xVy/jvWCSWEsayJn93L9x8+uOeO2KoT2+uXkL21yNNEMoKOU37gDwSM8Z&#xd;&#xa;qe/0dbrTbW1SQhrRkkiJ6MyDjd7euKitbLVH1mK+1BrMLFC8arAWydxU9/pVvVLJ702flsq+RcpM&#xd;&#xa;27uBnge/NH2J/wC3ft+5fL+zeTt753Zz9KL+ye6vLCZGULbTGRgepBRl4/OsS9vX0K9nhgurNVnk&#xd;&#xa;NwwuFkLAt1xtGMcVN4dMtzqt5ftP9ojlijXzFGFDAsSq5AOBkdfWujrHh0GBb+4lmjR4SCIEBOU3&#xd;&#xa;g+Z/30T/APqp+iaS+mtcySzeY8zAADoiLkIBx2XAqe0sng1W/u2ZSlz5e0DqNq4OaPsT/wBu/b9y&#xd;&#xa;+X9m8nb3zuzn6VmrpmqWsJtbQafLAMhXuAxkOeecDHerMejFvDUWkzycrEqM6eoweM/So7rTtQ1X&#xd;&#xa;T57XVGtkRtrIbXdnIOed30FWNN1R57Zvt8DWt1Cm+aM8gD+8MZ44PvxVa0a41TWUu5bZ4LW1Ba2c&#xd;&#xa;4/fbhgk89MYI6da3KKwLj/ke7T/rxf8A9Crfooqpqn/IKvP+uD/+gmmaJ/yA9P8A+vaP/wBBFMvI&#xd;&#xa;9VW4MlhLbujgZS5zhMf3do7981Waw1O+nt/7SNksUEqzKbfdu3KcgfN2qxqVlcS3Vve2TRfaYFZF&#xd;&#xa;WbOwhsZzjnPApuj2V5bTXs980BlupFfEOdowoXv9KmNk511b/cvli2MO3vksDn6cUaZZPZNel2Vv&#xd;&#xa;tFy0y7ewIAwffio5NMaXVLq4ZwIp7RbfA+8DliT/AOPVgjU30gDS476xWG3/AHQZ0lMoHrwu3P6V&#xd;&#xa;seGIJINLfzWZ/MnkkV2xmRWYkNx6jmtSeGO5gkgmXfFIpR19QeCKxYdCmGm3CzyRvqDHdFOM4Urn&#xd;&#xa;yj/wHPp+daOk2A03TYbTzDIUyS57kkk/qaTRrJ9O0yO2lZWZWckr0+Zy39aox6E7Jq8c021L+Xep&#xd;&#xa;jPzKMD178VT1XSNa1TT5LORdKiWTbl4w+4YIPp7VsanZTXEltc2rILm1ZmjEudh3Dac456E/jVS/&#xd;&#xa;g1H7NbXzwxTX9pIWSGAnY4b5T97HIUk/UVoQ6hBLYvdMTGkYPmhhzGV+8D9PaqFmZdT1cX0kDw29&#xd;&#xa;shFq5x++D9W+nyrjp1rapKwfAv8AyKNj/wBtP/RjVv0Vj6r/AMh3Q/8ArrL/AOimrYoooooooooo&#xd;&#xa;ooooooooooorH0z/AJGHWv8Aeh/9F1sUUVj+Hfu6l/2EJv5itiiiiiiiiiiiiiiiiiiiiisC4/5H&#xd;&#xa;u0/68X/9Crfooqpqn/IKvP8Arg//AKCaZon/ACA9P/69o/8A0EVeooooooooooooooooooopKwfA&#xd;&#xa;v/Io2P8A20/9GNW/RWPqv/Id0P8A66y/+imrWdlRGdjhVGSfao0uoZLUXKyAwld4f2xmnRTRzQJN&#xd;&#xa;GwMbqHVumQRnNU7bWtOuro20Fyrzc/LtI6e5FTW7xNeXax3DySKy+ZGx4jO0YA+o5qO+1ew06RUu&#xd;&#xa;7gRswyBtJ/kKzvDeotqN9qzrO00CzqIc5wF29gelb9Zltr+l3dwsEF2rStnC7WGe/cVoyOsaM7kK&#xd;&#xa;qjJJ7VzupeI7KcWkVhekzPdwqQqsMqXGRyPStFNSsLnVkto71/tMO9TCuQGPfPHOMVetrmG6i82B&#xd;&#xa;w6ZK5HqDg/qDSJdQyTTRLIC8BAkH93IyP0qjD4i0qedYYrxWkc4A2MMn8qra/r6aTfWEHmIomkHn&#xd;&#xa;blJxHzyMe4pJtZOpTwW2h3EbszEzuyN+7TB57d+K1ZLVmsBbLcTKwUAS7vnJHcn3xzVXR7u5lNxb&#xd;&#xa;agY/tcDnIjUqCh+62Mnrg9606KKx9M/5GHWv96H/ANF1sUUVj+Hfu6l/2EJv5itOS5himihkcLJL&#xd;&#xa;nYD3x1oe5hjuI4GcCWXJRfXHWq1/q9jpzql5cCNnGQNpP8hT7ue3fTJJ2uGitzHuM0ZwVGOoqypU&#xd;&#xa;Rg7vlx1Ncx4j8TWX9iXS2F8VusDYUVgc7hnnHpmumhJMKEnJKioL7ULXTo1kvJREjHaDgnJ/Clsb&#xd;&#xa;+11CEy2kokQHBIBHP41Bea3p1hP5N1ciOTGdu1jx+Aqlo2rRDQ3vry5Ji+0SgSMCfl3kL79MVcsr&#xd;&#xa;+y+xxSx3jTRTzFI3fJJYk/L0/D8KuXE8VrbyTzuEijUszHsBUN7qdnYRJLdTiNHOFOCc/lUK63YS&#xd;&#xa;2M93Dcq0UI+Ztp4P0xnuKp6L4lsr+1tVluE+2SIC6KjABsZPb+tS6VJeahO97LMBaK7fZkjBHmIR&#xd;&#xa;wzc8+3Si5lu9N1OF3mD6dO58wyAlo2PCgHPQnAAxWxRRWBcf8j3af9eL/wDoVb9FFVNU/wCQVef9&#xd;&#xa;cH/9BNM0T/kB6f8A9e0f/oIqylzC9xJArgyxgFl9M9KI7mGWeWGNw0kWN4HbPT+VVJNb06O9+xvd&#xd;&#xa;KJ9wXbtPU9OcY71NdvCstqJbh4i0uIwpwJGwflPtjJ/CpLq5htIGnuHCRr1Y1h3Wv2l3f6ZBp94W&#xd;&#xa;Z7nEiqGGV2N1yPXFdFVC+1nT9PmEN3cCOQruA2sePwHtVuGaOeFJonDRuoYN6isPWvEenxadfRQX&#xd;&#xa;u26SJ1TarZDgHGDj1q3d6nZ2mmwrf3bW5nh4kXO7oMkEA4PNXYrmAyx2yy7pWi8xQerJwM/qKfNc&#xd;&#xa;w27RLK4UzP5aA/xNgnH5A1VvtY0/T5Fju7kRswyBtJ/kKe+p2aaf9uMw+zYB34Pc4HHXvWNYeLLO&#xd;&#xa;fSIpJrmMXzx/6sI2N/YfnjvWppMN75S3WozMbmVF3QrxHH7Ac89ic1BJLd6dq0KyzB9PuXYbnBLJ&#xd;&#xa;ISNq5z0JJA44xWxRSVg+Bf8AkUbH/tp/6Mat+isfVf8AkO6H/wBdZf8A0U1bFcZcS41Sbwzj95eX&#xd;&#xa;BuhP2UbvM24/4Dj8a6DX45pNPURBmjEqNOo/iiB+cY75XPHeq+p3Vjc6S1vayRyTlcW0aHLJJj5D&#xd;&#xa;j+HBxyelJoIkXVdWWY5kBgD5OefKXNN0K7toLN3vbiKK8klk83zXCuQHIXOefu4x7YqHwtOlzqWt&#xd;&#xa;zRhgj3CkblKn7voea2NVvW07TpbpLd7ho8Yij+82SBx+dczrd1eSaYyy6tps6GSPMUKYc/vF6fMf&#xd;&#xa;5Vta6R9r01JiPsbTN5+77mAhK7u33gMe+Kq+INRtJksIYZ0mdr2E/uzuAw46kcD8etWtQ/5GbR/9&#xd;&#xa;y4/ktQ+H7u2tNM8m6uIoJRNMSkjhWAMjEcH2OaqQvaajL4iMpmNrIY1Yoh3EBADgYyfyour26W0k&#xd;&#xa;8+/0y/hC/NaxR/PKP7o+Y8/hVnxGD9r0WXaRHHdBnbsgweSewqSG4hm8WGWKaN42shGrKwILBySo&#xd;&#xa;PrjnFblY9j83ibUpF5TyYU3DpuBfIz6itiiisfTP+Rh1r/eh/wDRdbFFFY/h37upf9hCb+YqXxBC&#xd;&#xa;ZdLdw2Ps7LcEf3gh3Y/HFUvDN2NYmudZVDEsyrAIickbMnOffd+lSaTPDZG5TUZUhvGlYu8rAb1y&#xd;&#xa;dmCeuFwOOnSqF6rf2Lr8sQK2MkZMAxgZwd5A925z361o65k2FgjZ8h7iNZwfumPB3bvaqXjHUrJv&#xd;&#xa;DN1DDPHKzhVAiO/HzDrjoOOpro4P9RH/ALo/lWTqep3MeofY4JILQLGJPtNyuUbJxtHI579azbSa&#xd;&#xa;5e/1qQ3UFzOLFNklqMDPz4A5POav6HfWdrosBuLiJLlkEk6lh5jSY5yOpb9af4UcS6Q8i52vczMM&#xd;&#xa;jB5kbtWVED/ZVo/8EesM7t2VRI+SfQVoeJtUsj4evkjuY5XeFlCxNvPI6nHQe9F7iK7t7iC8htbo&#xd;&#xa;2wQtcoTGUznAOR82ffp2pbC4kmvZkna2u5vs5IurZcKBn/Vnk855607QbmBfD1natNGLlbcKYSw3&#xd;&#xa;g46beuan8MnHh6xQ/fjiVHXurAcg+hpnib5tPiiXmRrmEqo6kCRScD2FbFFFYFx/yPdp/wBeL/8A&#xd;&#xa;oVb9FFVNU/5BV5/1wf8A9BNM0T/kB6f/ANe0f/oIrN8TXQ0iW11lkMqwBoTEDgnfjnPtt/Wn2Vtc&#xd;&#xa;/wDCMXDWjn7RdrJcQ4OCrSZYDPtnrUlveaUmkC3kaJU8sq9uR8x67hs6nJz25zVHy7mK10BLzPnC&#xd;&#xa;9OcnJxtk2/pirt7IieJIDduqWqWxdDIcIJd2AQTxu2k/hmoNW1C1udV0iCCTzWF2HLIMpjY4xuHG&#xd;&#xa;fbrXQ1gXGpXkl3OkV5ZWCQuYwl0uWfH8Y+YcHOPwNZ9s8/8Awil0ySB3a/YO8Q4ZTMNxH+yRn8K0&#xd;&#xa;Nd1DTovDd5BbzxMPszRpHCQ+PlIHA6D36Cp9U/5FC6/68W/9AqtFIlvrllPO6xQ/2bs8xztXduU4&#xd;&#xa;ye+AeKNXv7W41HR4YJllb7YGJj+ZQNjjqOM89KjbFpqF42n6jb2rSy7plvYzy3qnK5H51o6JL51t&#xd;&#xa;csYo1cTMHkjGFnbA+cex6dT0rCEsf/CEWlp5ifaU8ndDn5xiRScr14AJrr0ZXRXRgysMgg5BFZPi&#xd;&#xa;H5l0+NeXN9C20dcBxk49BWxRSVg+Bf8AkUbH/tp/6Mat+isfVf8AkO6H/wBdZf8A0U1bFQm1tzci&#xd;&#xa;4MERnAwJSg3D8etTVXisbOGYzRWkEcpzl1jAbnrzUqxxo7uqKrvgswGC2OBn1qCbTrG4lMs9lbyS&#xd;&#xa;N1Z4lJP4kVMkMUbO0caIznLlVALH39akqmNJ00MGGn2oIOQRCv8AhViaGOeIxzRpJG3VXUEH8DVc&#xd;&#xa;6dbRQyLaWtrFIeVPkjG4fdJA64NVrXT7x76K71K4hlkgDCEQxlAN33s5Jz0GKtzadY3Epkns7eWQ&#xd;&#xa;9WeJST+JFTRwxRFjHGiFsZKqBnAwP0qCPTLCKQSR2NsjqchliUEH64qxJGksbRyorowwVYZBH0rO&#xd;&#xa;vdBs7mKJYQbQwyGRDb4j+bGOcD0q1LHdPYeWJo1uSoDSBTtz3IGc+uOaZpWmw6VatBDJLIGcyM0r&#xd;&#xa;bmJPXJq7RRWPpn/Iw61/vQ/+i62KKKx/Dv3dS/7CE38xWs6q6FHUMrDBBGQRTILeG2j8u3hjiTOd&#xd;&#xa;sahRn6Cm3Fna3RU3NtDMV6GSMNj86e0MTQ+S0aGLG3YVG3Hpj0pXjSSMxyIrRsMFWGQR6YqummWC&#xd;&#xa;K6pY2yq4wwESgMOuDxzVoAAYHAqK4tre6ULcwRTKDkCRAwB/Gkt7O1tSxtraGEt18tAufyph06xa&#xd;&#xa;bzmsrcy7t28xLuz65x1qK7t75di6XLa26ZJcSQlsknORgj3p1jp0VrYm2cCUOWeQMMhmY5bj0yTx&#xd;&#xa;Tk0ywj3eXY2yblKttiUZB7HjpUs9rb3KKlxBFKinIV0DAfnRb21vaqVtoIoVJyRGgUE/hTRY2YuP&#xd;&#xa;tAtIBNnPmCMbs+uetVLXSfsWpTXVtO+y5dnnikORk9Cvpz160LpPmauupXM7vLFuWFFOEVSMcj+9&#xd;&#xa;z1+ladFFYFx/yPdp/wBeL/8AoVb9FFVNU/5BV5/1wf8A9BNM0T/kB6f/ANe0f/oIqzPbw3Mfl3EM&#xd;&#xa;cqZztdQwz9DT0VURURQqqMBQMACoWsbN7j7Q1pA02QfMMY3ZHQ561K8cchUuisUO5SRnafUU24to&#xd;&#xa;LpAlxBHMoOQsiBgD6802KytYVVYraFFVt6hYwAGxjI98d6nqvPYWdy4e4tIJnAxukjDHHpzT4raC&#xd;&#xa;GEwxQxxxHPyKoC89eKhj0ywj3eXY2yblKnbEoyD1HTpVbULG+vC9slxbx2EqeW8flHftIwcNnA46&#xd;&#xa;cVceztpbeOCaGOaOMDaJVDdBjPNEVjZwgCK1gjAbeNsYGG6Z+tFxZWl0wa5tYZiowDJGGx+dSxxp&#xd;&#xa;DGscSKiKMBVGAPwqCTTbORpHNtEJZAQZVQB+Rg84z0NQaTpsmlobZLhpbRVAjWTJdT/vdMegxTYd&#xd;&#xa;J/4mx1K4neSddyRopwiofb1wBk9606KSsHwL/wAijY/9tP8A0Y1b9FY+q/8AId0P/rrL/wCimrYo&#xd;&#xa;oooooooooooooooooooorH0z/kYda/3of/RdbFFFY/h37upf9hCb+YrYoooooooooooooooooooo&#xd;&#xa;rAuP+R7tP+vF/wD0Kt+iiqmqf8gq8/64P/6CaZon/ID0/wD69o//AEEVeooooooooooooooooooo&#xd;&#xa;pKwfAv8AyKNj/wBtP/RjVv0Vj6r/AMh3Q/8ArrL/AOimrYooooooooooooooooooooorH0z/AJGH&#xd;&#xa;Wv8Aeh/9F1sUUVj+Hfu6l/2EJv5itiiiiiiiiiiiiiiiiiiiiisC4/5Hu0/68X/9Crfooqpqn/IK&#xd;&#xa;vP8Arg//AKCaZon/ACA9P/69o/8A0EVeooooooooooooooooooopKwfAv/Io2P8A20/9GNW/RVHU&#xd;&#xa;7A30SGKY29zEcwzhdxjJ4PB4ORkc+tZ39ja3/wBDLL/4CpR/Y2t/9DLL/wCAqUf2Nrf/AEMsv/gK&#xd;&#xa;lH9ja3/0Msv/AICpR/Y2t/8AQyy/+AqUf2Nrf/Qyy/8AgKlH9ja3/wBDLL/4CpR/Y2t/9DLL/wCA&#xd;&#xa;qUf2Nrf/AEMsv/gKlH9ja3/0Msv/AICpVbULHWrKyln/AOEkkZ1U+WhtkHmP/Co9yeKq6BD4g1aw&#xd;&#xa;aefXJraRZWjaI2yEqR69K0/7G1v/AKGWX/wFSj+xtb/6GWX/AMBUo/sbW/8AoZZf/AVKP7G1v/oZ&#xd;&#xa;Zf8AwFSj+xtb/wChll/8BUo/sbW/+hll/wDAVKP7G1v/AKGWX/wFSj+xtb/6GWX/AMBUo/sbW/8A&#xd;&#xa;oZZf/AVKP7G1v/oZZf8AwFSrej6VNp8t1Nc3zXk1wVLO0YTG0YHArUoornzoGox3Fy9nrkltHPM0&#xd;&#xa;vli3VsFj6k0v9ja3/wBDLL/4CpR/Y2t/9DLL/wCAqUf2Nrf/AEMsv/gKlH9ja3/0Msv/AICpR/Y2&#xd;&#xa;t/8AQyy/+AqUf2Nrf/Qyy/8AgKlH9ja3/wBDLL/4CpR/Y2t/9DLL/wCAqUf2Nrf/AEMsv/gKlH9j&#xd;&#xa;a3/0Msv/AICpR/Y2t/8AQyy/+AqUf2Nrf/Qyy/8AgKlH9ja3/wBDLL/4CpR/Y2t/9DLL/wCAqUf2&#xd;&#xa;Nrf/AEMsv/gKlH9ja3/0Msv/AICpR/Y2t/8AQyy/+AqUf2Nrf/Qyy/8AgKlH9ja3/wBDLL/4CpR/&#xd;&#xa;Y2t/9DLL/wCAqUf2Nrf/AEMsv/gKlP0/Qrq31ddQvdUe8kSIxKGhCYBOexrcoopksaSxPHINyOpV&#xd;&#xa;h6g1hnQ9VQ7LbX5IIF4jiFshCL2XJ5OBxR/Y2t/9DLL/AOAqUf2Nrf8A0Msv/gKlH9ja3/0Msv8A&#xd;&#xa;4CpR/Y2t/wDQyy/+AqUf2Nrf/Qyy/wDgKlH9ja3/ANDLL/4CpR/Y2t/9DLL/AOAqUf2Nrf8A0Msv&#xd;&#xa;/gKlH9ja3/0Msv8A4CpR/Y2t/wDQyy/+AqUf2Nrf/Qyy/wDgKlH9ja3/ANDLL/4CpR/Y2t/9DLL/&#xd;&#xa;AOAqUf2Nrf8A0Msv/gKlH9ja3/0Msv8A4CpR/Y2t/wDQyy/+AqUf2Nrf/Qyy/wDgKlH9ja3/ANDL&#xd;&#xa;L/4CpR/Y2t/9DLL/AOAqUf2Nrf8A0Msv/gKlH9ja3/0Msv8A4CpWvZWdvp9qlraRiOFM7VBJxk5P&#xd;&#xa;X3NWKKKKKKKKKKKKKx9Z/wBI1LTLBuEkkM5YdQYirAfQ5oX/AEPxM4bldQiHlhf4THksT9dw/Kti&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;uZlvrmw1nUb6bSruS2EahXXYQAm7c3LdCCKQ39zqV5pl/a6VeKFPyvJs2GOTbluGzwBkV09FFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFUNd/5&#xd;&#xa;AOo/9esn/oJpvh3/AJF3Tf8Ar2j/APQRWjRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRVDXf8AkA6j/wBesn/oJpvh3/kXdN/69o//AEEVo0UU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVQ1&#xd;&#xa;3/kA6j/16yf+gmm+Hf8AkXdN/wCvaP8A9BFaNFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFUNd/wCQDqP/AF6yf+gmm+Hf+Rd03/r2j/8AQRWj&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;VDXf+QDqP/XrJ/6CaydEudaXRLBYdNtnjFugRmuiCRtGDjbxV37Xr3/QKtP/AAMP/wARR9r17/oF&#xd;&#xa;Wn/gYf8A4ij7Xr3/AECrT/wMP/xFH2vXv+gVaf8AgYf/AIij7Xr3/QKtP/Aw/wDxFH2vXv8AoFWn&#xd;&#xa;/gYf/iKPtevf9Aq0/wDAw/8AxFH2vXv+gVaf+Bh/+Io+169/0CrT/wADD/8AEUfa9e/6BVp/4GH/&#xd;&#xa;AOIo+169/wBAq0/8DD/8RR9r17/oFWn/AIGH/wCIo+169/0CrT/wMP8A8RR9r17/AKBVp/4GH/4i&#xd;&#xa;j7Xr3/QKtP8AwMP/AMRR9r17/oFWn/gYf/iKPtevf9Aq0/8AAw//ABFH2vXv+gVaf+Bh/wDiKPte&#xd;&#xa;vf8AQKtP/Aw//EUfa9e/6BVp/wCBh/8AiKPtevf9Aq0/8DD/APEUfa9e/wCgVaf+Bh/+Io+169/0&#xd;&#xa;CrT/AMDD/wDEUfa9e/6BVp/4GH/4ij7Xr3/QKtP/AAMP/wARR9r17/oFWn/gYf8A4iltdTvzqsVj&#xd;&#xa;fWMUHmxNIrRz7/ukDH3R61r0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVQ13&#xd;&#xa;/kA6j/16yf8AoJpvh3/kXdN/69o//QRWjRRRRRRRRRRRRRRRRRRRRRRRRRWPc/8AI2WH/XrN/wCh&#xd;&#xa;JWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRVDXf+QDqP/XrJ/6Cab4d/wCR&#xd;&#xa;d03/AK9o/wD0EVo0UUUUUUUUUUUUUUUUUUUUUUUUVj3P/I2WH/XrN/6ElbFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFUNd/5AOo/wDXrJ/6Cab4d/5F3Tf+vaP/ANBFaNFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFY9z/yNlh/16zf+hJWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRVDXf8AkA6j/wBesn/oJpvh3/kXdN/69o//AEEVo0UUUUUUUUUUUUUUUUUUUUUUUUVj&#xd;&#xa;3P8AyNlh/wBes3/oSVsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVQ13/kA6&#xd;&#xa;j/16yf8AoJpvh3/kXdN/69o//QRWjRRRRRRRRRRRRRRRRRRRRRRRRRWPc/8AI2WH/XrN/wChJWxR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRVDXf+QDqP/XrJ/6Cab4d/wCRd03/&#xd;&#xa;AK9o/wD0EVo0UUUUUUUUUUUUUUUUUUUUUUUUVj3P/I2WH/XrN/6ElbFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFRTTwwAGaWOMHgF2Az+dRf2jY/8AP5b/APf1f8aP7Rsf+fy3/wC/q/40f2jY&#xd;&#xa;/wDP5b/9/V/xo/tGx/5/Lf8A7+r/AI0f2jY/8/lv/wB/V/xo/tGx/wCfy3/7+r/jR/aNj/z+W/8A&#xd;&#xa;39X/ABo/tGx/5/Lf/v6v+NH9o2P/AD+W/wD39X/Gj+0bH/n8t/8Av6v+NUtbv7N9D1BVu4GY20gA&#xd;&#xa;EgJJ2n3pugX9mmgacr3cCsttGCDIAQdoq/8A2jY/8/lv/wB/V/xo/tGx/wCfy3/7+r/jR/aNj/z+&#xd;&#xa;W/8A39X/ABo/tGx/5/Lf/v6v+NH9o2P/AD+W/wD39X/Gj+0bH/n8t/8Av6v+NH9o2P8Az+W//f1f&#xd;&#xa;8aP7Rsf+fy3/AO/q/wCNH9o2P/P5b/8Af1f8aP7Rsf8An8t/+/q/41LDcQ3AJgmjlA67GBx+VS0U&#xd;&#xa;UUVWbULJWKtd24IOCDIOP1pP7Rsf+fy3/wC/q/40f2jY/wDP5b/9/V/xo/tGx/5/Lf8A7+r/AI0f&#xd;&#xa;2jY/8/lv/wB/V/xo/tGx/wCfy3/7+r/jR/aNj/z+W/8A39X/ABo/tGx/5/Lf/v6v+NH9o2P/AD+W&#xd;&#xa;/wD39X/Gj+0bH/n8t/8Av6v+NZVzfWh8UWLi6gKC2mBbzBgHclav9o2P/P5b/wDf1f8AGj+0bH/n&#xd;&#xa;8t/+/q/40f2jY/8AP5b/APf1f8aP7Rsf+fy3/wC/q/40f2jY/wDP5b/9/V/xo/tGx/5/Lf8A7+r/&#xd;&#xa;AI0f2jY/8/lv/wB/V/xo/tGx/wCfy3/7+r/jR/aNj/z+W/8A39X/ABo/tGx/5/Lf/v6v+NWQQRkH&#xd;&#xa;INLRRRRRRRRRRRRRRRRRRRRRRRRRRRWJrkMVxrGixTxJLG0suUdQwP7puxq7/Yulf9Ayz/78L/hR&#xd;&#xa;/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78&#xd;&#xa;L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ay&#xd;&#xa;z/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yul&#xd;&#xa;f9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hR&#xd;&#xa;/Yulf9Ayz/78L/hR/Yulf9Ayz/78L/hVHRYIbbXNZit4kijDQ4RFCgfJ6CtyiiiiuW8LadY3Vrey&#xd;&#xa;XNnbzP8AbZhukiVjjPqRW3/Yulf9Ayz/AO/C/wCFH9i6V/0DLP8A78L/AIUf2LpX/QMs/wDvwv8A&#xd;&#xa;hR/Yulf9Ayz/AO/C/wCFH9i6V/0DLP8A78L/AIUf2LpX/QMs/wDvwv8AhR/Yulf9Ayz/AO/C/wCF&#xd;&#xa;H9i6V/0DLP8A78L/AIUf2LpX/QMs/wDvwv8AhR/Yulf9Ayz/AO/C/wCFH9i6V/0DLP8A78L/AIUf&#xd;&#xa;2LpX/QMs/wDvwv8AhR/Yulf9Ayz/AO/C/wCFH9i6V/0DLP8A78L/AIUf2LpX/QMs/wDvwv8AhR/Y&#xd;&#xa;ulf9Ayz/AO/C/wCFH9i6V/0DLP8A78L/AIUf2LpX/QMs/wDvwv8AhR/Yulf9Ayz/AO/C/wCFZ3iD&#xd;&#xa;SdNi0DUJI9PtEdbdyrLCoIOOoOK2rX/j1h/3F/lUtFFFFFFFFFFFFFFFFFFFFFFFFFFFY+q/8h3Q&#xd;&#xa;/wDrrL/6Katiiiiiiiiiiio1mjaZ4lkUyIAWQHlQemR+BqSiore4huoRLbypLG2cOjAg446ipaKj&#xd;&#xa;mmjgjMk0ixoMZZjgDJwKkooorH0z/kYda/3of/RdbFFFFFc/4O/48b7/AK/pv510FFFFFFFFFFFF&#xd;&#xa;FFFFFFFZniT/AJFzUf8Ar2f/ANBNXrX/AI9Yf9xf5VLRRRRRRRRRRRRRRRRRRRRRRRRRRRWPqv8A&#xd;&#xa;yHdD/wCusv8A6KatiiiobuD7VZz25dkEsbJuXquRjIrMtdSki8P3M0iKLmyik3RMeRtzt3DqMgA/&#xd;&#xa;jUWgXqw293DcSKsVqVkMsjY/1i+Yck9gWx9BTtJm+waLHeX6yi8ucGVSDvkfnAC+uB0ApbfU9Qtp&#xd;&#xa;N2t29vbW7cLLG5Kqf9snhR2+pq3qV9LDi3sUWa9cbkjY/KB6sR0HBAPrxTNP1G4MotdUhW3umyU2&#xd;&#xa;ZMbjrhWPU4ySKjvdQv5JjFo1vDcGIkTPKxVQfQEdSMHI7cVnabcaimpa3PdW0X2xLWJkihJYNgOQ&#xd;&#xa;PXmtC41xI7K1mjaF5ZWXem77i5xI30XnPpjmrKagZdWW1gCyQ+SZHkU52NkbQfqCTWdaa27eEH1Z&#xd;&#xa;beJHRXYRLwvDEf0pWvvEE582z062Fu3Kee7I+PcdqvDWLd9MivItzGcYhjx8zn0A7+p9hmsDXZ9f&#xd;&#xa;fSpFvbOzjty8e9o5SWHzrjA+uK7CiiisfTP+Rh1r/eh/9F1sUUUUVz/g7/jxvv8Ar+m/nXQUUUUV&#xd;&#xa;HccW8v8AuH+Vcfo8XhmTSbR728hFy0SmXdesp3Y5yN3Fauj3+3RdRmhkWaG0llWD5sjYoyoz3+tF&#xd;&#xa;pqWtXwt57ewgW0kCFjMzK46biB6dcevFWNQn11LtlsLOzlt8Da0shDHjnikOuxzaTHd2ilpJ5PIi&#xd;&#xa;VxgGTkYPoMjrSWd7q6XCLqdjGschCq1sTJhvVvQe9Jd6jqct5NDpFtbzLbkJKZ3KkNgHjHUYIq/p&#xd;&#xa;1zNcwH7TA8M8Z2yAqQpPcqT1HvVuiiiiszxJ/wAi5qP/AF7P/wCgmr1r/wAesP8AuL/KpaKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKx9V/wCQ7of/AF1l/wDRTVsUUUVz93o73Guk5kW3ldLqRx03xgKIz7EZ&#xd;&#xa;J+lP17SWu5I/IDbbhfsswQDCIed/1G0D8avarYyXcMBgZRNbSiaMP91mAIwcc45rPvluPEVo+nyW&#xd;&#xa;VxZQSY82SYKDgHI24Jycgde1Wr2Ca11EanBE1x+5EMkK/eKgkgr2zk85PSmRR3Op39teTwNaw2rM&#xd;&#xa;0ccn+sZipU5AyMYPHNQW0tzo8l1CdOuroTXEk6yW4UrhjkDkjmpNIjvW1rULu7t/JSeOLyhnnA3c&#xd;&#xa;H/aGRnHFVIPDpku7iOVpEhhSWKF8D94JgSx/AsR+FW/Dlld27Xc92ixmZlVEB5CoNgJ+oAP41n2e&#xd;&#xa;m3kfgCWwe3YXRSQCLvkuSK6lBhFB9K5q0sLu10jRpmt3aSxZmkgXG9shlwO38WevSnaxcahqunPb&#xd;&#xa;22l3EPzIz/aAoJAcH5cE88d+2a6WiiisfTP+Rh1r/eh/9F1sUUUUVz/g7/jxvv8Ar+m/nXQUUUUV&#xd;&#xa;HOC0EigZJUgD8K5rSpms9Ltbafw7ePLFGqOwijIJA92p9rbX1zHq9zJZ/ZUngMMFv0Y4DckDjJ3D&#xd;&#xa;v2rc0yN4dLtI5FKukKKwPYhRmueubMfaZTqWl31/OXJE1tJtQpn5RjevIGAeO3en6NYXNt4TS2ns&#xd;&#xa;SxEjmSBjh9hY/dIP3sdOR9aLGzkF7C2mWF3pwVwbhrp9wkj7qPmbnp6dOtTavbRyXrNd6Rc3YP8A&#xd;&#xa;q5LSQr8v+18y85z68Yq9oUF3BbSC5JWJnzbxNy0UeOFY9z+J+talFFFFZniT/kXNR/69n/8AQTV6&#xd;&#xa;1/49Yf8AcX+VS0UUUUUUUUUUUUUUUUUUUUUUUUUUVj6r/wAh3Q/+usv/AKKatiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiisfTP+Rh1r/eh/9F1sUUUUVz/g7/jxvv8Ar+m/nXQUUUUUUUUUUUUUUUUUUVmeJP8AkXNR&#xd;&#xa;/wCvZ/8A0E1etf8Aj1h/3F/lUtFFFFFFFFFFFFFFFFFFFFFFFFFFFYPiC6gstV0a4uZBHEksu5j0&#xd;&#xa;GY2H8zU3/CU6J/0EYv1/wo/4SnRP+gjF+v8AhR/wlOif9BGL9f8ACj/hKdE/6CMX6/4Uf8JTon/Q&#xd;&#xa;Ri/X/Cj/AISnRP8AoIxfr/hR/wAJTon/AEEYv1/wo/4SnRP+gjF+v+FH/CU6J/0EYv1/wo/4SnRP&#xd;&#xa;+gjF+v8AhR/wlOif9BGL9f8ACj/hKdE/6CMX6/4Uf8JTon/QRi/X/Cj/AISnRP8AoIxfr/hR/wAJ&#xd;&#xa;Ton/AEEYv1/wo/4SnRP+gjF+v+FH/CU6J/0EYv1/wo/4SnRP+gjF+v8AhR/wlOif9BGL9f8ACj/h&#xd;&#xa;KdE/6CMX6/4Uf8JTon/QRi/X/Cj/AISnRP8AoIxfr/hUOg3cF9rGsXFrKJYmaHDDocJit6iiiiuQ&#xd;&#xa;8Oa3punwXsN3dpFJ9tlba2ema1/+Ep0T/oIxfr/hR/wlOif9BGL9f8KP+Ep0T/oIxfr/AIUf8JTo&#xd;&#xa;n/QRi/X/AAo/4SnRP+gjF+v+FH/CU6J/0EYv1/wo/wCEp0T/AKCMX6/4Uf8ACU6J/wBBGL9f8KP+&#xd;&#xa;Ep0T/oIxfr/hR/wlOif9BGL9f8KP+Ep0T/oIxfr/AIUf8JTon/QRi/X/AAo/4SnRP+gjF+v+FH/C&#xd;&#xa;U6J/0EYv1/wo/wCEp0T/AKCMX6/4Uf8ACU6J/wBBGL9f8KP+Ep0T/oIxfr/hR/wlOif9BGL9f8KP&#xd;&#xa;+Ep0T/oIxfr/AIVQ13xHpFxod9DDfRvJJA6qozySPpXRWv8Ax6w/7i/yqWiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiisfVf+Q7of8A11l/9FNWxRRRRRRRRRRRRRRRRRRRRRWPpn/Iw61/vQ/+i62KKKKK5/wd&#xd;&#xa;/wAeN9/1/TfzroKKKKKKKKKKKKKKKKKKKzPEn/Iuaj/17P8A+gmr1r/x6w/7i/yqWiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiisfVf+Q7of/XWX/0U1bFFFFRRzxyTSxKW3xEBsqQORkYPf8Klqvb3tvdT3EMM&#xd;&#xa;m6S3bZKNpG04z+NWKKhmuoYJ4IZHxJOxWMYJ3EAk/oDU1FFNd1jQu7BVHJJOAKrf2lamOeRZC6QA&#xd;&#xa;F2RCw6Z4wPm/DNTwzRTruhkSRc4yrZqSiiiiisfTP+Rh1r/eh/8ARdbFFFFFc/4O/wCPG+/6/pv5&#xd;&#xa;10FFFQ3VxHaW7zzFhGnXapY/kOalBBAI6Goru6hsrZ7i4fZEmNzYJxk47fWpqKKhtbqG8iMkD70D&#xd;&#xa;shOCOVOCOfcVNRRVe6vbezXM8oU9Qo5Y/QDk0kl9bRXBglmWOQKG+f5QQfQng9OlWaKKKzPEn/Iu&#xd;&#xa;aj/17P8A+gmr1r/x6w/7i/yqWiiiiiiiiiiiiiiiiiiiiiiiiiiisfVf+Q7of/XWX/0U1azhijBW&#xd;&#xa;2sRwcZwaxf7Zmj0S5uXQPNbT/ZS2cB2DhN+O3XOPwzV67u206wjaY+fOxWJcDaJJDwPXaCfriqcj&#xd;&#xa;arp8bXt1dxXEEYLywLEEKL1JDZOcDtjn2qfS7973UNQQkGGIxeVxg4aMNz+dQrNf6tmfT7tLS2Vi&#xd;&#xa;il4RIZCDgnGRtwQR3z1qp4VSWPUtbWeUTSi4Xc4TaGO307Vf8T38+maBdXlqVE0e3aWGRywH9aq3&#xd;&#xa;a6+to95FdQI6jf8AZDECAO48zPpnnFJNdfbrnw3d7Nnns0m3OduYWOM1oaqZwIvI1OGx6582MPv6&#xd;&#xa;dMkdP61W0y9uLiW9sDdxTzQxqy3SINuX3Y+UHtj15pn9szPocVyqBZpbj7KGzkK28pvx35Gcfhmn&#xd;&#xa;6/uazs7OVtyXdwlvOQMblKnOPTpWpb28NrCsNvEkUa9ERQoH4Csmwij0/wAQ3FjaxrFbywC5KKMA&#xd;&#xa;OW2nHoMKOK26KKKKKx9M/wCRh1r/AHof/RdbFFFFFc/4O/48b7/r+m/nVvWdQl0yS0mXEkU0y27R&#xd;&#xa;9Dljw2fbB475qS3u5bjWbu3BCQ2iqGGMmQsMg57Y5GOc5qGW9uL+8nstNlW3e2IE0zpvwSMhQvGc&#xd;&#xa;+ueMVS1XWLzTNMvYpHRr63iEqShflkQsFyV7HJIxz0zWre37W0FuqIJLm5ISJScAtjJye3ANYniK&#xd;&#xa;01WPRZ3uNVjmiBTdGLUIW+cd9xxXVVh3N1qU+uz6fZyRxRLAknnMu4xklv4f4s4x1GKZbX2pWWvx&#xd;&#xa;aZqDx3UdyrNFOi+WV2jJBXnv71P4Y/5Bsv8A19T/APoxqp3d7eWEE122uWlykILm3WFVLgfw53HH&#xd;&#xa;1xV3UNSlsrrTmwHhvJFg8voUY87s9+OMfrU1ldy3ep3qZCQ2rCLZjJZiA27Pbg4xVDSAuo61qF3d&#xd;&#xa;IjzWc7W0LbR8idfz5PNaOsaZaanZmO7iD7PmVv4lI54PbpS6JdS3ujWdzOQZZYlZiBgZIq9RRWZ4&#xd;&#xa;k/5FzUf+vZ//AEE1etf+PWH/AHF/lUtFFFFFFFFFFFFFFFFFFFFFFFFFFFY+q/8AId0P/rrL/wCi&#xd;&#xa;mrYrmptGvX8Vx3C7f7JOWlg3/Kz4PzFOhO7Bz6jNbeo2S31uIyxR0cSRvjO11OVOO+D2rPkTVb+N&#xd;&#xa;rK6toYLdwUlmWXeXXoQFwMZHfPHvU+mae9lf6hJgCGYxeVzk4WMLz+VVbWPVdKiNpa2MN3Crs6yt&#xd;&#xa;ceWTuYsfl2nGCcde1P0DTbywutSkvZEla4lDq6jbuGMdO1ReOP8AkUr76J/6GtSO+tXsJtms4LJZ&#xd;&#xa;F2mcT+aUH+7gZz0696cNJlhOiRxsJEsMq7ngkeWVBx9aZqmnzvfNcLY2+pxyKFENywVYCOpXIP3s&#xd;&#xa;88D7o60mg6fPa6he3Mthb2McyRqkUDhhld2TwB6iq1hpxuvEl3dJOTp0Lr5VuFzCz7Rll5xkPnOB&#xd;&#xa;1z3rS1+GR7OK5hRpZLOUXCxKMmUgEbR6dfep7bU7ae1edmMAi/1qz/I0f+8D09ee1U9LL3+q3Gpv&#xd;&#xa;BNbKqC2SOaMqXUHdv5+pGPbrWzRRRRRWPpn/ACMOtf70P/outiiiiiuf8Hf8eN9/1/TfzrV1S1F5&#xd;&#xa;p80QRGl2ExFh918HawPYg96p+GrC6sNLVdQIe9Ykyy7tzPyduW6nApZrK4sbye90yJZnuSDNDI+w&#xd;&#xa;MQMBg2DjHpjnNUdV0a81PTLyWRUW/uIhEkYb5Y0DBsbu/IJzgdcVo6lZTyJZT24V5rN96xMdokO0&#xd;&#xa;rjd2656HpVDVINb1awktmtYLQEqTibzPMwwO3oNvrnnpiuirnJpr2HxVefYbSO5JtYtweby9vzP7&#xd;&#xa;HNWIdNvbrWLbVb6RIDArqtqg343DGd/GfXpT7PTLhNFurNpjbyzSTMssZyUDMSCOnPNZN9pF1cWM&#xd;&#xa;1vH4c02OR0KCcSruB/vfc6/jWr4gWNNBdG2fahHi26b/ADdvGzvu9Mc1a0WxNhp0cUkhmnI3SzMu&#xd;&#xa;GkPq3UkgYHPpWdbkaHq90kyyNbXrm4NzsISJicbGPTt1yOvSretaqbKIw21rLeXLAfuogSVUnG5s&#xd;&#xa;A4HXHriremWf9n6bb2fmeZ5MYTfjGcd8VaoorM8Sf8i5qP8A17P/AOgmr1r/AMesP+4v8qlooooo&#xd;&#xa;oooooooooooooooooooooorH1X/kO6H/ANdZf/RTVsUUUUUUU10SRCkiqynqGGQaWloopqqqDCKF&#xd;&#xa;HXAGKdTDFG27KKd/3sj731p1LRRRRRWPpn/Iw61/vQ/+i62KKKKK5/wd/wAeN9/1/TfzroKKKKKK&#xd;&#xa;KaFUOWCjcRgnHJp1FFNZEcqXVW2nIyM4PrTqayq6lXUMp6gjIo2qHLhRuIwTjnFOooorM8Sf8i5q&#xd;&#xa;P/Xs/wD6CavWv/HrD/uL/KpaKKKKKKKKKKKKKKKKKKKKKKKKKKKx9V/5Duh/9dZf/RTVqzSCGF5W&#xd;&#xa;BKopY468Vjw6hq2owpdada20dtIoZBduyuQe+FBGPxq5a3dzHDOdUijhMC72ljJMZXk8E85GOeKz&#xd;&#xa;dG8WWF+oSe4hiuHmMccYJ+YZwp/Gr8+v6VbKjTX0SLJu2k55wcH9Rip7SdJri48u784AofLwB5QK&#xd;&#xa;gjnvnrz61BPr+lW8UMk19EiTLujJz8w9au21xDd26T28gkicZVh0Iqhc+IdItLh4Li/ijlQ4ZTnI&#xd;&#xa;NaEM0dxCk0LB45FDKw6EHoaRLiJ7iSBXBljAZ17gHOP5GmC9tjBNMJVMcBYSN2Ur97P0qnrF7JDZ&#xd;&#xa;2k1rJgS3MKbgAcozAHr6g06PX9Kluxax30TTltgQZzn0qzfX9rp0ImvJ1hjLbQzdM+n6UlhqFpqU&#xd;&#xa;LS2U6TRq20svY9cfrWbc+J7C01qSxuLiKOOOIMXJOQ+fu/lg0qanPq12I9JmiNkFBku15ZWz90Aj&#xd;&#xa;BOMdexq9qK3wRZdPeMumcwycLJ+IBII7YpdLvPt1kkrgLMPlmQf8s3H3l/A1corH0z/kYda/3of/&#xd;&#xa;AEXWxRRRRXP+Dv8Ajxvv+v6b+dbbXES3K25cCZ1LqncgYyf1FDXES3K25cCZ1LqncgYyf1FR319a&#xd;&#xa;6dAJryZYYy23c3TNQXV9by6O95Dfi3gYZFyqhgvOM4I/CroYCMMWyAMlv61zur+KtPGmy/2dqMRu&#xd;&#xa;sqIwoyfvDPUema6Wqd/qllpqob65SASZC7u+Kls7y3vrdbi1lWWJsgMvQ4qG/wBWsNMZBfXSQGTJ&#xd;&#xa;Xd3xWXZ+JLN7vUZpb6M2ETRLE+OASpyM4z1FaNrqFqtlau98s4uH2RSkAeYxJwAAPw/CrdxcRWsD&#xd;&#xa;TTuI416seg7VFf6jaabEst7OkKM20Fu5pbLULS/tzcWk6yxAkFl6ZFY9n4v0qb7R9ovIItkzJHyf&#xd;&#xa;nQYw341b0yfUb6UXM3lQWgZvKROWmX+FmyOBjBGD3pdSub7T51uVMctizKJg/BgXuwwOR1Jya0op&#xd;&#xa;EmiSWNgyOoZWHcHoaz/En/Iuaj/17P8A+gmr1r/x6w/7i/yqWiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;sfVf+Q7of/XWX/0U1ak4jMEgl/1ZU7vpjmse30llt4zo+qy2tkyho41RZBgjqC4Jp2izXxvNQ07U&#xd;&#xa;pY7kwbWSUKAXR92AwAAzhf1qr4Ot4DpsztDGXW7lwSoyMNxUnhawtTpRmaBXkknlLF/m6SMOAen4&#xd;&#xa;VY0oAa9rYAwBJDgf9slqr4R060Hh61lMCu8qbmL5bnJ6Z6fhVO7vLjTtE8QT2cnlSQ3oEZABCgiM&#xd;&#xa;YAPHc1sXttp2n6NM8kUSRpGRvcbjk8Dk5PU1L4e/5F7Tf+vWP/0EVQ10z2F4LuyzG1xDJHI+Ad0g&#xd;&#xa;H7kc99zH696yXlu7KKOzuyYhqLW+9GA/eO5xcfTqOnTPGK2fEtvEdKtLbaRD9qgj2hiPl3gYz16U&#xd;&#xa;viO0t7bw3etBCiPHCdrgfMPx65qbUbmRpoLC2ggmuHjM3+k58sKMA9ATnLDt61T0oXcfieWO7jto&#xd;&#xa;j9jVglsSU++eTkDmpjbwP4wk3wxsDYqTuUHJ8w81F4TVUk1pVAVRqMoAAwAMCugrI8O/c1H/AK/5&#xd;&#xa;v51sUVj6Z/yMOtf70P8A6LrYoooorn/B3/Hjff8AX9N/OrHiS1kms4riJlQ2kyzyHOCY1yWUfX06&#xd;&#xa;VH4emXU5brWIwRBdFRCr/fTaNrZ7DJHY0lsGn8Q3sepKGC4+xq4GCmBvIHQ845PNZHif5LPWIrTi&#xd;&#xa;zECmVV+6s29ePb5ccDitrVWZv7KtSx8i5l2SqDjcAhYDPUcgdKr+LVsbbQ5AY4Y5JGRY8IASdwPH&#xd;&#xa;4A10VY+oXE9xfmys7a1llhQSObvIXDZA24B5+U5/CoPD/wBpXVtWjukgjdTD8kBJQZU9MgVLoccd&#xd;&#xa;7DcXV2izTNcSIWcZ+VXKqAOg4Hbr3qvobWN7rGsG3WGW3zDgBRtyFOeKyoxjR/DOOg1D/wBmetvx&#xd;&#xa;hcQw+H5kkkCtKVVAf4juBx+QNO1OCSTVUe0a1luRBg290SE2bvvjAPOeKXSW26hcW9xbQxXixqz/&#xd;&#xa;AGdiYihJxwcc5Bzx6c1QtbW3Ol6+TBFlbi4CnYOPlHStvRv+QLY/9e8f/oIqHxJ/yLmo/wDXu/8A&#xd;&#xa;I1No3/IFsP8Ar3j/APQRUPiT/kXNR/69n/8AQTV61/49Yf8AcX+VS0UUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUVj6r/wAh3Q/+usv/AKKatisubw5o88zzS6fC8kjFmYjkk8k1cs7K2sIPItIVhiBJ2r0zUU+k&#xd;&#xa;afcXqXk1rG9yhBWQjkEdKsW9vFbRCKBBGgJO0epOT+pNEdvFFNLKiBZJiDIw6tgYGfwot7eK1gSC&#xd;&#xa;BBHEgwqjoKIreKBpGiQIZX3uR/E2AM/oK5O38O6rBOJI7LQYjyC8Yl3AEYOPfBNdVZ2yWVnBaxFi&#xd;&#xa;kMaxqW6kAY5p09vFcKqzIHCuHUHswOQfzoe3iknjndAZYgQjHquev8hRPbxXCqsyBwrhwD2YHIP5&#xd;&#xa;0txBFcwPBOgkicYZT0IqK9sLXUIBDeQJNEG3BW6A+v61FY6Rp+nSM9laRwM4wxQdRUl9p1nqMape&#xd;&#xa;26TqhyocdDVK40cx3EV3psnkzwxLAkTHEJQHowAz0Jxz1AqzqVrc3ojgjnMFuwbznjOJPYLwRjrn&#xd;&#xa;NT2VqllZQWsRYxwoEUt1IAxzU9FY+mf8jDrX+9D/AOi62KKKKK5/wd/x433/AF/TfzrdljSaJ45F&#xd;&#xa;DI6lWU9weoqO0tLext1gtYliiXOEXoM80l7Y2uoQCG8hSaMNu2t0z603+zbP+z/sH2dPsuMeVj5c&#xd;&#xa;Zz/OpLi1gurZraeJZIWABQ9CKpw6BpNusiw2MKCQBXAH3hkH+YFaVVL/AEyy1IIL22ScJkrvHTNF&#xd;&#xa;hpllpquLK2SAPgtsHXFQ3mhaXfXDT3VlFLK2AXYcnFRX9tqUM/m6LHp6NIAJmud+WxwuNvtmrFpp&#xd;&#xa;kFvpS6ewMsO0qwfndkkn+dRw+H9JgWRYbCFBIu1wB94ZBx+YFWL7T7TUYljvYEmRTuCuOhp1lY2u&#xd;&#xa;nwGGzhSGMtu2r0z61Fc6Rp93dpdXFrHJOmNrsORg5FV7LS5dOvC1rcO9tM7vNHM2dhOSNmAO55z2&#xd;&#xa;p11pst9qEctzOVt7aRJYI4jjcw678j16Y9TWnWZ4k/5FzUf+vZ//AEE1etf+PWH/AHF/lUtFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFY+q/8AId0P/rrL/wCimrYooooooooooooooooooooorH0z/kYda/3o&#xd;&#xa;f/RdbFFFFFc/4O/48b7/AK/pv510FFFFFFFFFFFFFFFFFFFZniT/AJFzUf8Ar2f/ANBNXrX/AI9Y&#xd;&#xa;f9xf5VLRRRRRRRRRRRRRRRRRRRRRRRRRRRWPq5Caxo0rnbGksu5zwFzGwGT25rQ+32f/AD9wf9/B&#xd;&#xa;R9vs/wDn7g/7+Cj7fZ/8/cH/AH8FH2+z/wCfuD/v4KPt9n/z9wf9/BR9vs/+fuD/AL+Cj7fZ/wDP&#xd;&#xa;3B/38FH2+z/5+4P+/go+32f/AD9wf9/BR9vs/wDn7g/7+Cj7fZ/8/cH/AH8FH2+z/wCfuD/v4KPt&#xd;&#xa;9n/z9wf9/BR9vs/+fuD/AL+Cj7fZ/wDP3B/38FH2+z/5+4P+/go+32f/AD9wf9/BR9vs/wDn7g/7&#xd;&#xa;+Cj7fZ/8/cH/AH8FH2+z/wCfuD/v4KPt9n/z9wf9/BR9vs/+fuD/AL+Cs3SJEl17WnjdXUtDgqcj&#xd;&#xa;7lbVFFFFc54WmitbS9S4kSFzeysFkYKSCevNbf2+z/5+4P8Av4KPt9n/AM/cH/fwUfb7P/n7g/7+&#xd;&#xa;Cj7fZ/8AP3B/38FH2+z/AOfuD/v4KPt9n/z9wf8AfwUfb7P/AJ+4P+/go+32f/P3B/38FH2+z/5+&#xd;&#xa;4P8Av4KPt9n/AM/cH/fwUfb7P/n7g/7+Cj7fZ/8AP3B/38FH2+z/AOfuD/v4KPt9n/z9wf8AfwUf&#xd;&#xa;b7P/AJ+4P+/go+32f/P3B/38FH2+z/5+4P8Av4KPt9n/AM/cH/fwUfb7P/n7g/7+Cs7xFeWr+HtQ&#xd;&#xa;VLmFmNu4AEgJPBrUtf8Aj1h/3F/lUtFFFFFFFFFFFFFFFFFFFFFFFFFFFRzwQ3MLQ3ESSxN95JFD&#xd;&#xa;Ke/Q1T/sPSP+gVY/+A6f4Uf2HpH/AECrH/wHT/Cj+w9I/wCgVY/+A6f4Uf2HpH/QKsf/AAHT/Cj+&#xd;&#xa;w9I/6BVj/wCA6f4Uf2HpH/QKsf8AwHT/AAo/sPSP+gVY/wDgOn+FH9h6R/0CrH/wHT/Cj+w9I/6B&#xd;&#xa;Vj/4Dp/hR/Yekf8AQKsf/AdP8KP7D0j/AKBVj/4Dp/hR/Yekf9Aqx/8AAdP8KP7D0j/oFWP/AIDp&#xd;&#xa;/hR/Yekf9Aqx/wDAdP8ACj+w9I/6BVj/AOA6f4Uf2HpH/QKsf/AdP8KP7D0j/oFWP/gOn+FH9h6R&#xd;&#xa;/wBAqx/8B0/wo/sPSP8AoFWP/gOn+FH9h6R/0CrH/wAB0/wo/sPSP+gVY/8AgOn+FH9h6R/0CrH/&#xd;&#xa;AMB0/wAKsWtla2QYWltDbhuWEUYXP1xViiiiiqlzplhdy+ZdWNtPJjG6SJWOPqRUX9h6R/0CrH/w&#xd;&#xa;HT/Cj+w9I/6BVj/4Dp/hR/Yekf8AQKsf/AdP8KP7D0j/AKBVj/4Dp/hR/Yekf9Aqx/8AAdP8KP7D&#xd;&#xa;0j/oFWP/AIDp/hR/Yekf9Aqx/wDAdP8ACj+w9I/6BVj/AOA6f4Uf2HpH/QKsf/AdP8KP7D0j/oFW&#xd;&#xa;P/gOn+FH9h6R/wBAqx/8B0/wo/sPSP8AoFWP/gOn+FH9h6R/0CrH/wAB0/wo/sPSP+gVY/8AgOn+&#xd;&#xa;FH9h6R/0CrH/AMB0/wAKP7D0j/oFWP8A4Dp/hR/Yekf9Aqx/8B0/wo/sPSP+gVY/+A6f4Uf2HpH/&#xd;&#xa;AECrH/wHT/Cj+w9I/wCgVY/+A6f4VfACgAAADgAUtFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFf/2Q==&#xd;&#xa;</binary>
<binary id="image17.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAGKAiUBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KK59be41HW9UQ6ne28du8aokDqAAY1J6qe5qx/Ycv/Qb1X/v4n/xFH9hy/8AQb1X/v4n/wARR/Yc&#xd;&#xa;v/Qb1X/v4n/xFH9hy/8AQb1X/v4n/wARR/Ycv/Qb1X/v4n/xFH9hy/8AQb1X/v4n/wARR/Ycv/Qb&#xd;&#xa;1X/v4n/xFH9hy/8AQb1X/v4n/wARR/Ycv/Qb1X/v4n/xFH9hy/8AQb1X/v4n/wARR/Ycv/Qb1X/v&#xd;&#xa;4n/xFH9hy/8AQb1X/v4n/wARR/Ycv/Qb1X/v4n/xFH9hy/8AQb1X/v4n/wARR/Ycv/Qb1X/v4n/x&#xd;&#xa;FH9hy/8AQb1X/v4n/wARVHXLC507R7q8h1nUmkhTcoeRCCffC101FFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFY+lf8AIe1z/rrF/wCilrYooqOWeGHHnSpHnpvYDNNjureVtsU8&#xd;&#xa;Tt6K4Jquur2L6q+mLPm8Qbmj2NwMA9cY6Ed6vUUUUUUUUUVj+Lf+RY1D/rkf51sUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVj6V/yHtc/66xf+ilrYoorgfGFtI3ie2mv4bqbT&#xd;&#xa;to8sRHcAwxu45wOmeOa04f8AhGrzWbT7BM1ldwEsI4ITB5oyOGyoyOOme5rMkF2fidd/YWhWbyxg&#xd;&#xa;zKWXHlr2BBrbOs6jYa9Z6dqQtZVu1OxrdGUq2e+4njrVjXtVl09o/JvLKIE7CksUkrliMjAQ56D0&#xd;&#xa;qr4b8TSarqVzp9wiGWIF1liRkVlBUfdbkHJNMg1nWL7xBqGnWf2GNLQ8NLG5JH4NTrLXdTi8Tro2&#xd;&#xa;q29uDMhaGSAEAgBjk5Y/3SMdaml117u/ubTTLmziNo2yZrtWwzZIwvI6FTnr1FP8Na5Lq0t/bXCx&#xd;&#xa;edZS7GkhyEcZYAjJJ/h/Wt2iisfxb/yLGof9cj/Otiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiisfSv+Q9rn/XWL/0UtbFFFZV+2sQ38ctikN1alSHgdvLKnjB3c578Y7VnXGiX&#xd;&#xa;Ws6rZ395bQ6fJZSq/wAjCUzgEHBOFxjb7/eoh0S8Tx1PqxVPsrxhQd3Odijp9Qam1fSLq88TaXfw&#xd;&#xa;hDBbZ8wlsHr2FV7rRbu38Vy6zbWsN8JowBHI4jMTAKAQSDk4U9h1pug6PqMHiq91W9gjhjuImAVZ&#xd;&#xa;d5BLKcdB6GqGmTXkPjTWzZWiXLEjcGm8vAz9Dmtmw0i6udd/trVQkU8QMdvDG24IuDyW7/ebtUE/&#xd;&#xa;h5LPUbq7t9LttTF429kuWVfKbJJIJBznd7Yx3rT0Wya286VrG1sfN2jyLdV4xnksAN2c9McfjWpR&#xd;&#xa;RWP4t/5FjUP+uR/nWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWPpX/Ie1&#xd;&#xa;z/rrF/6KWtiiiiiiiiioY7S2inknit4kmk+/IqAM31PepqKKKKKx/Fv/ACLGof8AXI/zrYoooooo&#xd;&#xa;oooooooooooooooooooooooooooooooooooooooooooorlhZ6ldeItYaw1b7CqyRBl+zrJuPlLzk&#xd;&#xa;9Ktf2T4h/wChm/8AJCP/ABo/snxD/wBDN/5IR/40f2T4h/6Gb/yQj/xo/snxD/0M3/khH/jR/ZPi&#xd;&#xa;H/oZv/JCP/Gj+yfEP/Qzf+SEf+NH9k+If+hm/wDJCP8Axo/snxD/ANDN/wCSEf8AjR/ZPiH/AKGb&#xd;&#xa;/wAkI/8AGj+yfEP/AEM3/khH/jR/ZPiH/oZv/JCP/Gj+yfEP/Qzf+SEf+NH9k+If+hm/8kI/8aP7&#xd;&#xa;J8Q/9DN/5IR/40f2T4h/6Gb/AMkI/wDGj+yfEP8A0M3/AJIR/wCNZviHTdbi0K8kudf+0QrHlovs&#xd;&#xa;aJuHpkHiuxoooooooooooooooooooooooooooooooooooooooooooooooooorH0r/kPa5/11i/8A&#xd;&#xa;RS1sUUUUUUUUUUUUUUUVj+Lf+RY1D/rkf51sUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUVj6V/yHtc/66xf+ilrTuLiK1geedxHEgyzHoBWKfENreazptrp17HKsryecqjOQIyR&#xd;&#xa;1HHI7Vfm1zTLdGea9iRUlaFiT0cdV+opbnWtOtIYJri7jjjuF3RMx4ccHI/MfnU9ne21/AJ7SZZo&#xd;&#xa;iSNy9M0Le2zWb3azKbdAxaTsAuQ35YNOe6gRYWeVQJ2Cxn+8SMgD8Aap6rfXMEkFtp8cU13K2Skj&#xd;&#xa;EBY+cucds4H41JNBfLZRrb3Ye5jOS0qgCXrw2BwPoO1GkXzX9kskqCO4U7Jogf8AVv12/kR+dXqK&#xd;&#xa;KKKKx/Fv/Isah/1yP862KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKx9K/5&#xd;&#xa;D2uf9dYv/RS0kiLceLBFMN6QWiTRKf4HLsCw98AUzVLiI+J9Ftg484NLIU77TGwB/MGq/hK3iFzr&#xd;&#xa;dyEHnHUpoy/faCCB+ZNW7+91Oa/ks9GW0EluqtObsNghvu7dv+62c+1V/D/27+3dW/tL7N9o8uDP&#xd;&#xa;2fdsx8+Pvc1SuIrqHVLrTUV1s7i4g8mEfdeLrPj2+bn607RpXn1m2sL1i8lpDLKYm6xsJQIz/wB8&#xd;&#xa;Nx7GtR/+Rxh/7B8n/oxK2Kx9A/1+sf8AYQf/ANAStiiiiiisfxb/AMixqH/XI/zrYooooooooooo&#xd;&#xa;ooooooooooooooooooooooooooooooooooooooorH0r/AJD2uf8AXWL/ANFLV2/02z1JES9t0nVD&#xd;&#xa;lQ3Y0y10jT7MR/ZrWOLy3MibR0YjaT+XFWLe1gtfN8iJY/NkMr4/iY9TUN/pdjqfl/brZJ/Lzs39&#xd;&#xa;s4z/ACFFhpdjpnmfYbZIPMxv2d8Zx/M1O9vE88c7oDLEGCN3UHGf5CiO3iimllRAskxBkYdWIGB+&#xd;&#xa;gqtqmmpqcUKPPNA0MolR4SAwYAjuD6miaG+nso4muI4pmOJpIgRgc52Zzg9Oue9S6dZR6dYQ2cLO&#xd;&#xa;0cK7VLkEke+Ks0UUUUVj+Lf+RY1D/rkf51sUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUVj6V/yHtc/66xf+ilrYoooooooprOq43MBuOBk9T6Ub137Nw3Yztzzj1p1FFFFFY/i3&#xd;&#xa;/kWNQ/65H+dbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFY+lf8h7XP+usX&#xd;&#xa;/opak1PVLi2uFtdPsft1zsEjx+aItqEkA5IweQRinaXqU11I9vfWn2K8Ub/J8wSZjPAbcBjqCMde&#xd;&#xa;Kz08SXVzLdwafpRuZ7W5eF088INq8BtxGOT/AA9RV69vtUht7Z7XR/tMsiZmj+0qnknA4yfvdTyP&#xd;&#xa;SpNL1GS982K6tvsl3DgyQeZv2hs7TuAwc4NUZNa1KWRm0vRfttpkqk/2pY9xHDfKwyMEEfhU1xrc&#xd;&#xa;hhgXT7I3d3Ipc25fyiqg7WO5hjhsD3zkcVJpmqXFzcNa6hY/YbnYZEj80S7kBAJyBgckDFVdBtxf&#xd;&#xa;xrrFzJLKbg+bFBI5ZIOgG0HjIwfmAHUirWt2AuLdrmGaS2uYVDebESpZVOdrYxkHnjtnNWNJvv7S&#xd;&#xa;0u3vfL8rzk3bN2cfjVyiiiisfxb/AMixqH/XI/zrYooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooooooorH0r/AJD2uf8AXWL/ANFLVLW7QjWxeyjUfIa2WIGwL7twZidwXtgip9BtoxeT&#xd;&#xa;XUcOoYMYj82+dt5wc7QrDOOc5z3NO8MQTQf2v50Tx+ZqUzpvUjcpxgjPUe9R6z5328/av7S+y7R5&#xd;&#xa;H9n785/j37f+A4z70zwzEV1TU5Vj1AQukIR71X3sRvzy3XGRVe5SFLiRZbbW7Z9xzHYGQwj3XaAO&#xd;&#xa;ep9yaZc2l4ZLO91EX2FgeImxL+bkvldwXnG0c++KvaHbRnUmuoodSwITGZb933DJB2hWHTjOc9qk&#xd;&#xa;8LzwxadHpbSp9ssx5csW4ZGMcgdx8w5q5rd7b2enSefIqmUeXGueWZuBgd+v5UaBaS2GiWlrOAJY&#xd;&#xa;o9rYORmtCiiiisfxb/yLGof9cj/Otiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiisfSv+Q9rn/XWL/0UtbFFFFFFFFVZrC3mmjmKbZI5PMDJ8pY4IwT3HPSlexgkvPtUib5NgQBu&#xd;&#xa;VABJyB689as0UUUUVj+Lf+RY1D/rkf51sUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUVz9pqFlZ+INaW7vLeBmliIEsqqSPKX1NaH9u6R/0FbH/wIT/Gj+3dI/6Ctj/4EJ/jR/bu&#xd;&#xa;kf8AQVsf/AhP8aP7d0j/AKCtj/4EJ/jR/bukf9BWx/8AAhP8aP7d0j/oK2P/AIEJ/jR/bukf9BWx&#xd;&#xa;/wDAhP8AGj+3dI/6Ctj/AOBCf40f27pH/QVsf/AhP8aP7d0j/oK2P/gQn+NH9u6R/wBBWx/8CE/x&#xd;&#xa;o/t3SP8AoK2P/gQn+NH9u6R/0FbH/wACE/xo/t3SP+grY/8AgQn+NH9u6R/0FbH/AMCE/wAaP7d0&#xd;&#xa;j/oK2P8A4EJ/jWX4n1fTJ/Dt9FDqNpJI0RCok6kk+wBrpKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKhktLaVy8lvE7HqzICTTfsNn/AM+sH/fsUfYbP/n1g/79ij7DZ/8APrB/&#xd;&#xa;37FH2Gz/AOfWD/v2KPsNn/z6wf8AfsUfYbP/AJ9YP+/Yo+w2f/PrB/37FZPiWztm0z7JFbwpPeuL&#xd;&#xa;eJwgAViCck9QPlPSjw1Z2y6Z9klt4XnsnNvK5QEMwAOQepHzDrWt9hs/+fWD/v2KPsNn/wA+sH/f&#xd;&#xa;sUfYbP8A59YP+/Yo+w2f/PrB/wB+xR9hs/8An1g/79ij7DZ/8+sH/fsUfYbP/n1g/wC/Yo+w2f8A&#xd;&#xa;z6wf9+xViiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiise/8A9L16&#xd;&#xa;xsm+VYVN4GHUsp2bfp85/KovnsfFfeKxuoP+Avclv/Qtq/kK3aKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKx9B/0mS91IfKl5L8qHquweWc/UrmjxP+60k3&#xd;&#xa;y8y2Li4jB+6WAIwfb5j6VsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUVkv4Z0WR2d9OhLMck4PJrK8N+HtIuvD9lPPYQySvHlmI5Jrpre3itYEggQRxIMKo&#xd;&#xa;6AVLRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWP4S/5&#xd;&#xa;FjT/APrkP51sUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUVj+Ev+RY0/wD65D+dbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFY/hL/kWNP8A+uQ/nWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRWP4S/5FjT/APrkP51sUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUVW1G9j06wmvJldo4V3MEAJI9s1Q/tyX/oCar/37T/4uj+3Jf+gJqv8A37T/AOLo/tyX/oCa&#xd;&#xa;r/37T/4uj+3Jf+gJqv8A37T/AOLo/tyX/oCar/37T/4uj+3Jf+gJqv8A37T/AOLo/tyX/oCar/37&#xd;&#xa;T/4uj+3Jf+gJqv8A37T/AOLo/tyX/oCar/37T/4uj+3Jf+gJqv8A37T/AOLo/tyX/oCar/37T/4u&#xd;&#xa;j+3Jf+gJqv8A37T/AOLo/tyX/oCar/37T/4uj+3Jf+gJqv8A37T/AOLo/tyX/oCar/37T/4uj+3J&#xd;&#xa;f+gJqv8A37T/AOLo/tyX/oCar/37T/4uj+3Jf+gJqv8A37T/AOLo/tyX/oCar/37T/4uj+3Jf+gJ&#xd;&#xa;qv8A37T/AOLo/tyX/oCar/37T/4uj+3Jf+gJqv8A37T/AOLo/tyX/oCar/37T/4uj+3Jf+gJqv8A&#xd;&#xa;37T/AOLo/tyX/oCar/37T/4uszw3q8kHh+yiGk6jKFjxvjjQq30ywrT/ALcl/wCgJqv/AH7T/wCL&#xd;&#xa;o/tyX/oCar/37T/4uj+3Jf8AoCar/wB+0/8Ai6P7cl/6Amq/9+0/+Lo/tyX/AKAmq/8AftP/AIuj&#xd;&#xa;+3Jf+gJqv/ftP/i6P7cl/wCgJqv/AH7T/wCLo/tyX/oCar/37T/4uj+3Jf8AoCar/wB+0/8Ai6P7&#xd;&#xa;cl/6Amq/9+0/+Lo/tyX/AKAmq/8AftP/AIuj+3Jf+gJqv/ftP/i6P7cl/wCgJqv/AH7T/wCLo/ty&#xd;&#xa;X/oCar/37T/4uj+3Jf8AoCar/wB+0/8Ai6P7cl/6Amq/9+0/+Lo/tyX/AKAmq/8AftP/AIuj+3Jf&#xd;&#xa;+gJqv/ftP/i6P7cl/wCgJqv/AH7T/wCLo/tyX/oCar/37T/4uj+3Jf8AoCar/wB+0/8Ai6P7cl/6&#xd;&#xa;Amq/9+0/+LqO48SfZYHnn0fU44kGWYxpgD/vutmGQTQpKoIV1DDPXBp9FFFFFFFFFFFFFFFFFY/i&#xd;&#xa;3/kWNQ/65H+dbFFFFFFFFFFFFFFFFFFFFFFFFFY/hL/kWNP/AOuQ/nWxRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RWP4t/5FjUP+uR/nWhp//IPtv+uS/wAhViiiiiiiiiiiiiiiiiisfxb/AMixqH/XI/zrYooooooo&#xd;&#xa;ooooooooooooooooorH8Jf8AIsaf/wBch/Otiiiiiiiiiiiiiiiiiiiiiisfxb/yLGof9cj/ADrQ&#xd;&#xa;0/8A5B9t/wBcl/kKsUUUUUUUUUUUUUUUUUVj+Lf+RY1D/rkf51sUUUUUUUUUUUUUUUUUUUUUUUUV&#xd;&#xa;j+Ev+RY0/wD65D+dbFFFFFFFFFFFFFFFFFFFFFFY/i3/AJFjUP8Arkf51oaf/wAg+2/65L/IVYoo&#xd;&#xa;ooooooooooooooorH8W/8ixqH/XI/wA62KKKKKKKKKKKKKKKKKKKKKKKKKx/CX/Isaf/ANch/Oti&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiisfxb/yLGof9cj/OtDT/APkH23/XJf5CrFFFFFFFFFFFFFFFFFFY/i3/&#xd;&#xa;AJFjUP8Arkf51sUUUUUUUUUUUUUUUUUUUUUUUUVj+Ev+RY0//rkP51sUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;Vj+Lf+RY1D/rkf51oaf/AMg+2/65L/IVYooooooooooooooooorH8W/8ixqH/XI/zrYooooooooo&#xd;&#xa;ooooooooooooooorH8Jf8ixp/wD1yH862KKKKKKKKKKKKKKKKKKKKKKx/Fv/ACLGof8AXI/zrQ0/&#xd;&#xa;/kH23/XJf5CrFFFFFFFFFFFFFFFFFFY/i3/kWNQ/65H+dbFFFFFFFFFFFFFFFFFFFFFFFFFY/hL/&#xd;&#xa;AJFjT/8ArkP51sUUUUUUUUUUUUUUUUUUUUUVj+Lf+RY1D/rkf51oaf8A8g+2/wCuS/yFWKKKKKKK&#xd;&#xa;KKKKKKKKKKKx/Fv/ACLGof8AXI/zrYoooooooooooooooooooooooorH8Jf8ixp//XIfzrYooooo&#xd;&#xa;oooooooooooooooorH8W/wDIsah/1yP860NP/wCQfbf9cl/kKsUUUUUUUUUVzmk6pruradFfW9tp&#xd;&#xa;yxS52iSVw3BI7KfSre/xH/zw0r/v9J/8TRv8R/8APDSv+/0n/wATRv8AEf8Azw0r/v8ASf8AxNG/&#xd;&#xa;xH/zw0r/AL/Sf/E0b/Ef/PDSv+/0n/xNG/xH/wA8NK/7/Sf/ABNG/wAR/wDPDSv+/wBJ/wDE1V1O&#xd;&#xa;08Q6lp09m8emIsy7SwmkyP8Ax2rW/wAR/wDPDSv+/wBJ/wDE0b/Ef/PDSv8Av9J/8TRv8R/88NK/&#xd;&#xa;7/Sf/E0b/Ef/ADw0r/v9J/8AE0b/ABH/AM8NK/7/AEn/AMTRv8R/88NK/wC/0n/xNG/xH/zw0r/v&#xd;&#xa;9J/8TRv8R/8APDSv+/0n/wATUb3+sWl1ZrfQWPlXM4hzDI5YEgnPKj0rcoooooorEe/1afVL22sI&#xd;&#xa;LIx2rIpaeR1JLIG7A+tP3+I/+eGlf9/pP/iaN/iP/nhpX/f6T/4mjf4j/wCeGlf9/pP/AImjf4j/&#xd;&#xa;AOeGlf8Af6T/AOJo3+I/+eGlf9/pP/iaN/iP/nhpX/f6T/4mjf4j/wCeGlf9/pP/AImjf4j/AOeG&#xd;&#xa;lf8Af6T/AOJqrplp4h03ToLNI9MdYV2hjNJk/wDjtWt/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/&#xd;&#xa;+Jo3+I/+eGlf9/pP/iaN/iP/AJ4aV/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jo3&#xd;&#xa;+I/+eGlf9/pP/iar6jqGvadYTXk1tprRwruYJLISR7ZWugooooorAstQ1zULf7TbW+nCFndV8yVw&#xd;&#xa;3ysV5wp9Kn3+I/8AnhpX/f6T/wCJo3+I/wDnhpX/AH+k/wDiaN/iP/nhpX/f6T/4mjf4j/54aV/3&#xd;&#xa;+k/+Jo3+I/8AnhpX/f6T/wCJo3+I/wDnhpX/AH+k/wDiaN/iP/nhpX/f6T/4mqup2niHUtOns3j0&#xd;&#xa;xFmXaWE0mR/47U8C+IoYI4hDpZCKFz50nOB/u0/f4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN/iP/&#xd;&#xa;AJ4aV/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN/iP/AJ4a&#xd;&#xa;V/3+k/8Aiaje/wBYtLqzW+gsfKuZxDmGRywJBOeVHpW5RWB4F/5FGx/7af8Aoxq36KKKKKKKKKKK&#xd;&#xa;KKKKx9f/ANfo/wD2EE/9AetiiiiiiisfSv8AkPa5/wBdYv8A0UtbFFFFFFFFFFFFFFFFY/i3/kWN&#xd;&#xa;Q/65H+dbFFFFFFY/hX/kAxf9dZv/AEa9bFFFFFFFFFFFFFFFFY+v/wCv0f8A7CCf+gPWxRWB4F/5&#xd;&#xa;FGx/7af+jGrfoorM8QasNF0t7wxmTBChR6npVOxtL3VrG3vrrU7m3kniVxHZkKgBGRwwJzzzzVLx&#xd;&#xa;PALTw/NFqk011ZrInlMhAnJ5zuYjaeemAOK0dU1uDQdEtLpoZJY32RqoIyMqSM/lUFr4siu9ThtI&#xd;&#xa;bC5aOUqBOUIUZGT1HbpU665c3E9wthpUl3FBKYjKk8agkAHjJ9xWF4xu/tcOlM0TwyJebJI26q3B&#xd;&#xa;xnoeo5HFdff30Gn2xmuHCjICjuxJwAPxIrJm8StZXtrBqmnS2S3JKpI0iyDI9lyepA/Gt+iiisfX&#xd;&#xa;/wDX6P8A9hBP/QHrYoooooorH0r/AJD2uf8AXWL/ANFLWxRXNeONTvNN02H7G/ledJtkmCkmMcHI&#xd;&#xa;x+VQpazTWFtNZ+J5WuHVH/eyL5bZAJ+XAYZ9Cc10UlytnYeffyxp5ce6V1BC5A5wOvrgdayB4jun&#xd;&#xa;sHv49FuGtFVn80youVXOTtJz29KbceLYIPDttrBtZDHcSmMRhhkEbuf/AB39a1L3Uks9HfUWjZkS&#xd;&#xa;ISbAecHt+tJaai17o8d/bWzu0ib1h3AE+2TxWZ/wlSQ3UEV9Zm2SdtgkE6SgHHHCEn2/GptW8TW+&#xd;&#xa;lavFYTwysZIjKHQbv72Bgc/w/rS6P4jj1KG6mmtZrKO2Clmm4Bznp+X61Hc+JWtYY7ufTpU0+R1C&#xd;&#xa;3XmKQUbo20fN05xjNbsbrLGsiHKsAwPqDTqKx/Fv/Isah/1yP862KKKKKKx/Cv8AyAYv+us3/o16&#xd;&#xa;2KqX9m14iKt5c2u05zAwBP1yDXK6Ut7e+I9T06XWNQENrjYyuu4/X5a1tQ8RW+i6jb6ZOk8zNBv8&#xd;&#xa;77xOAw5AHJJXsO9LpuurrVlf77K4tlhj58zgsCG6fl+tReD3t18Ml9NhnZFZyscrrvZvTOAOaLjx&#xd;&#xa;UbPa97p7QQ7wjuLiN9mT12qSePpVzXdeh0XTYb5onnjlcIoU4PIJB5+lV5/EF7b2LXs2hzrbqm8v&#xd;&#xa;58Z49cZzWi2r2K6YNRa4AtGXcJCp5H0xn9KyZvFFzBpn9ozaJcJagAlzKmRk4Hy5z1PpWV4svl1L&#xd;&#xa;TtBvEQos1wGCk8iuvv7+30+3MtxIF6BV7sSQAB+JFZv/AAkLW9/a2mpafLZG7YpCzSK4ZsgY+XOO&#xd;&#xa;SOtblFY+v/6/R/8AsIJ/6A9bFFYHgX/kUbH/ALaf+jGrfoorH8UaVLrOjSWkDqsm4ON3fHaq+m6x&#xd;&#xa;Dpem2tlqcc1tcwQpGyCJpQcADOUBHOPWs/xfdSap4anNtazGDzY/Kk28y8nPy/eGCMcge1M8cQyy&#xd;&#xa;+EdPSOJ3YSx5VVJI/dtXV2AIsLYEYIiXj8BXK+F7i28N2t5p1/JJ5qXTEMlvIwYbVGQQD6GmeLZZ&#xd;&#xa;NSh0uaG2l8sXnyHacsvHzY6jvwcHitPxjpE+qWdu9u2GtpRIQPvEcZI9wMn8Ky57PS9UubbGoavf&#xd;&#xa;3MT5ijkXYOoJ5aMAcDPXtxzXbUUUVj6//r9H/wCwgn/oD1sUUUUUUVj6V/yHtc/66xf+ilrYorK8&#xd;&#xa;Qzxw6cftNg95asyiVVI+UZGDjqecdK5TWdK0rUo4h4bt5Fv423KixNErDjJJcAcY4571r+JrK/u/&#xd;&#xa;BMcTRtJdxxxvONwJyq5Y+/fpUM3iKyn8JzwSLPDcNaPH5bQOcHaQPm24569e9Y89lcXvwy04W0Rk&#xd;&#xa;MU7SOB1ChpBn35I6VsatrNlceFpbKFp2uGtwgT7NIOcDjO3FQ3P9q2/gHT20zzY54tpl28MEw2eD&#xd;&#xa;744rJ1Wz0lBpkWiwzSSRzjzZGgdWIz1JKgVv6jFIfiTpcojcxrasC4U4BxJ3rZ8R6dJquhXVlCwW&#xd;&#xa;SQKVJ6cMGx+lcsbKxuNMh0281DVpLhEWM2irhBKBjYG2bcZ4Bzj3rt7ZPLtoo8FdqAYJBIwPapaK&#xd;&#xa;x/Fv/Isah/1yP862KKKKKKx/Cv8AyAYv+us3/o162KK5Pw/FInjTXHaN1RsbWKkA89qNRikPxJ0u&#xd;&#xa;URuY1tWBcKcA4k710l+CbC5AGSYm4/A1xOmJqlv8PmOnrLFcxzM5x8rBByetUdYtdH/4R1I7CGeb&#xd;&#xa;USwZ5Ht3Dkk5bJ2gd62fHEMsvhHT0jid2EseVVSSP3bVq63G7eC50VGLm1UbQOc4Fc/q9hdXPw70&#xd;&#xa;1IYHZ4WWSRehCgMOh+oqz4n8Q2eo+EriNVmiuJAh8p4XG3DqcFsY7etUb+KSXwx4a8uN32ygnapO&#xd;&#xa;Bmt3xnolxqqWdxbvg2bFmUfeIJXJH0AJqmtrp2o6lYyR3+rX9xbzK6LKuxUGQSSWQccDjOT2rsqK&#xd;&#xa;x9f/ANfo/wD2EE/9AetiisDwL/yKNj/20/8ARjVv0UUUUUUUUUUUUUUVj6//AK/R/wDsIJ/6A9bF&#xd;&#xa;FFFFFFY+lf8AIe1z/rrF/wCilrYooooqK6t0u7Wa2lyY5kaNsHBwRg1FpthBpdjHZ2oYQx52hjk8&#xd;&#xa;kk/qatUUUUUUUUVj+Lf+RY1D/rkf51sUUUUUVj+Ff+QDF/11m/8ARr1sUUUUUUUUVFcQi4geIvIg&#xd;&#xa;cY3RsVYfQjpWVJ4ZtZk2XF3qE8ZIJjlumdWwc8g8HpWvDFHBEsUMaRxqMKiKAAPYCn0UUVj6/wD6&#xd;&#xa;/R/+wgn/AKA9bFFcd4QutVj8NWiWulxTwjftka62E/O2eNpxzWz9u1z/AKAsH/gcP/iKPt2uf9AW&#xd;&#xa;D/wOH/xFH27XP+gLB/4HD/4ij7drn/QFg/8AA4f/ABFH27XP+gLB/wCBw/8AiKPt2uf9AWD/AMDh&#xd;&#xa;/wDEUfbtc/6AsH/gcP8A4ij7drn/AEBYP/A4f/EUfbtc/wCgLB/4HD/4ij7drn/QFg/8Dh/8RR9u&#xd;&#xa;1z/oCwf+Bw/+Io+3a5/0BYP/AAOH/wARR9u1z/oCwf8AgcP/AIij7drn/QFg/wDA4f8AxFH27XP+&#xd;&#xa;gLB/4HD/AOIo+3a5/wBAWD/wOH/xFUdRudRmvdJW90+O2jF8pDrceYSdj8Y2j35rpqKKKKKK5qG4&#xd;&#xa;1CHxDrIsrCO5UyRbi1x5eD5S/wCyc1d+3a5/0BYP/A4f/EUfbtc/6AsH/gcP/iKPt2uf9AWD/wAD&#xd;&#xa;h/8AEUfbtc/6AsH/AIHD/wCIo+3a5/0BYP8AwOH/AMRR9u1z/oCwf+Bw/wDiKPt2uf8AQFg/8Dh/&#xd;&#xa;8RR9u1z/AKAsH/gcP/iKPt2uf9AWD/wOH/xFH27XP+gLB/4HD/4ij7drn/QFg/8AA4f/ABFH27XP&#xd;&#xa;+gLB/wCBw/8AiKPt2uf9AWD/AMDh/wDEUfbtc/6AsH/gcP8A4ij7drn/AEBYP/A4f/EUfbtc/wCg&#xd;&#xa;LB/4HD/4iszxJd6u/h+9WfSoYojH8zi73FR9NozXV0UUUUVy2gXWqx6UqWulxTwiWXbI11sJ/eNn&#xd;&#xa;jacc1o/btc/6AsH/AIHD/wCIo+3a5/0BYP8AwOH/AMRR9u1z/oCwf+Bw/wDiKPt2uf8AQFg/8Dh/&#xd;&#xa;8RR9u1z/AKAsH/gcP/iKPt2uf9AWD/wOH/xFH27XP+gLB/4HD/4ij7drn/QFg/8AA4f/ABFH27XP&#xd;&#xa;+gLB/wCBw/8AiKPt2uf9AWD/AMDh/wDEUfbtc/6AsH/gcP8A4ij7drn/AEBYP/A4f/EUfbtc/wCg&#xd;&#xa;LB/4HD/4ij7drn/QFg/8Dh/8RR9u1z/oCwf+Bw/+Io+3a5/0BYP/AAOH/wARVHUbnUZr3SVvdPjt&#xd;&#xa;oxfKQ63HmEnY/GNo9+a6aisDwL/yKNj/ANtP/RjVv0UUUUUUUUUUUUUUVj6//r9H/wCwgn/oD1sU&#xd;&#xa;UUUUUVj6V/yHtc/66xf+ilrYooooooooooooooorH8W/8ixqH/XI/wA62KKKKKKx/Cv/ACAYv+us&#xd;&#xa;3/o162KKKKKKKKKKKKKKKKx9f/1+j/8AYQT/ANAetiisDwL/AMijY/8AbT/0Y1b9Uby+a31HT7YI&#xd;&#xa;Ct07qxJ5Xahb+lXqKKKKzNR1Vra9isLa3kmu50Lodv7tQDjLkcge+KsajcT2lt58MBnCNmSNAS5X&#xd;&#xa;/ZA6nOOPrTtOvY9RsIbyFXWOZdyhwAQPfFWaKKKKKx9f/wBfo/8A2EE/9AetiiiiiiisfSv+Q9rn&#xd;&#xa;/XWL/wBFLWxVG8vmt9R0+2CArdO6sSeV2oW/pV6iiiiqGr6rHpMEUskFxOZZREkdugZixBPTI9DR&#xd;&#xa;c3N7a6ek726TSoczRwbmJXnOwY5PTrjvU2nXseo2EN5CrrHMu5Q4AIHvirNFFFFFY/i3/kWNQ/65&#xd;&#xa;H+dbFFFFFFY/hX/kAxf9dZv/AEa9bFUVvmOtvYbBtW2WbdnnJZhj9KvUUUUVmajqrW17FYW1vJNd&#xd;&#xa;zoXQ7f3agHGXI5A98U3VtVk0eBLq5tnmtguJPs4LOj+uDgbODznritWiiiiiisfX/wDX6P8A9hBP&#xd;&#xa;/QHrYorA8C/8ijY/9tP/AEY1T3pe+1g6W0jR2626zSBODICzLtz1HTORg1Sm0mz07xDoz2qSKzyS&#xd;&#xa;g7pnf/lk394moNE05dUm1c3s00sMeozKkQkZQp45ypB6cY6cVd1ZdPJgs2sb29a2TGy1kYGJSBjc&#xd;&#xa;d4znHGc9DUGjZu31fTI47qytxCixpMcyRlw4Zs5J7Dv2qtdatNLpVicbTGs85IY/MbduAfZsc1qa&#xd;&#xa;ZO+oa1cXDkoLaFIggPDb1WTJ9x0p+mfNr+sluSskSqT2BjUkD8a2Kx/D/EmqoOFS+ZVXso2JwK2K&#xd;&#xa;KKKKKx9f/wBfo/8A2EE/9AetiiiiiiisfSv+Q9rn/XWL/wBFLRel77WDpbSNHbrbrNIE4MgLMu3P&#xd;&#xa;UdM5GDVKbSbPTvEOjPapIrPJKDumd/8Alk394moNE05dUm1c3s00sMeozKkQkZQp45ypB6cY6cVd&#xd;&#xa;1ZdPJgs2sb29a2TGy1kYGJSBjcd4znHGc9DSeG5yb/ULSOC5treFYmjhuDl1LbtxzknnA71Ra9lt&#xd;&#xa;xqGhgllSeK3E5Y78XBJJ+q54+lWNPvZNVn023cmIQrJOWUnLmNzEAfYg5+tXpfm8XQI3KixdgD0D&#xd;&#xa;eYoz9eTWxWP4f4k1VBwqXzKq9lGxOBWxRRRRRWP4t/5FjUP+uR/nWxRRRRRWP4V/5AMX/XWb/wBG&#xd;&#xa;vTHiXWdUvbS7L/ZrNkVY0cpuZkDbiwIPGSMZxzUWnWNvp/iu4itVdUNijENIznO9h1Yk9qr+G9Ih&#xd;&#xa;vdFsbu/lmuJtgKHzWTYueFwpAPOTk881LqkmnX14x/s/UL9ocxO9pIVVGBOVOHXkZ9O4qx4flkvt&#xd;&#xa;IuI5DJGFmlgjV/vxoDhQfUgd8n6msi41KZLCC1Gf9Badg+45k+zYxn/e71p6deSarr8pf90unxJh&#xd;&#xa;VPEnmoGOfpjj61Ppnza/rJbkrJEqk9gY1JA/GtZ0WRSrqGU9QRkGsvwq7SeGrBnYsxiGSTknmtai&#xd;&#xa;iiiisfX/APX6P/2EE/8AQHrYorA8C/8AIo2P/bT/ANGNV3U9Ka9lWa3u5bOcLsaWIAll5IU57ZJN&#xd;&#xa;VrXw8Ir62vbi8lurq3ZsSyAZKlSNv0GSfxq7pmmppv2vZIz/AGm5e4OR90tjj9Kh1LSHu5xPaX01&#xd;&#xa;jKwxK0IGZAPu5z6c/nRpGkPps9zPLfTXctwEBaUAEBc46f71TWumpa6pf3yyMzXnl7lI4XYuBik0&#xd;&#xa;nSoNJgeOEZaR2d3IwWJJPP0zj8KrXkF5Z6qdQs4kkt3jxcwqT5kjDADKOhIAxyRV++mnhhH2WHzZ&#xd;&#xa;nbaueFXryx6gcds9RUOjWUljp6R3DI9053zyKSQ79CfyAq/RRRRRWPr/APr9H/7CCf8AoD1sUUUU&#xd;&#xa;UUVj6V/yHtc/66xf+ilqbU9Ka9lWa3u5bOcLsaWIAll5IU57ZJNVrXw8Ir62vbi8lurq3ZsSyAZK&#xd;&#xa;lSNv0GSfxq7pmmppv2vZIz/abl7g5H3S2OP0qHUtIe7nE9pfTWMrDErQgZkA+7nPpz+dGkaQ+mz3&#xd;&#xa;M8t9Ndy3AQFpQAQFzjp/vVZnsVm1G1vC5DW6yKFxwd2P/iajttKgt9Wu9SA3XFyFBJH3VAAwP++Q&#xd;&#xa;aj1azu5Zbe603yVuonwxlYqGjwcrkA99p/CpZru4NlHJbWknnzHascvHlnnl8E4HHbPUUmjWUljp&#xd;&#xa;6R3DI9053zyKSQ79CfyAq/RRRRRWP4t/5FjUP+uR/nWxRRRRRWP4V/5AMX/XWb/0a9O1DRpLm6ae&#xd;&#xa;01CaxaTHm+SB+8IGATn2GKXTdEj0+9e7EzyzSxCOVmAy5BJ3H35x+FWtMsV03ToLNHLrCu0MRyao&#xd;&#xa;Xegu9w8lhqM9gshLyRwgYdyeWOe54/Krekad/Zdo0JnednkaRpHABYscmpILFYdRurwOS1wsalcc&#xd;&#xa;Dbn/AOKqLSNHttJjkEC5klYtJIRgv8xIz9N2Kr3kF5Z6qdQs4kkt3jxcwqT5kjDADKOhIAxyRT9X&#xd;&#xa;bUbi1+zaWnkzypu86U7VjHpkZO7pxjGM81oW9vFawJBAgjiQYVR0AqWiiiiisfX/APX6P/2EE/8A&#xd;&#xa;QHrYorA8C/8AIo2P/bT/ANGNW/RRRRRRRRRRRRRRRWPr/wDr9H/7CCf+gPWxRRRRRRWPpX/Ie1z/&#xd;&#xa;AK6xf+ilrYooooooooooooooorH8W/8AIsah/wBcj/Otiiiiiisfwr/yAYv+us3/AKNetiiiiiii&#xd;&#xa;iiiiiiiiisfX/wDX6P8A9hBP/QHrYorA8C/8ijY/9tP/AEY1ad/qlpp237VIylugSNnP5KDSWuqW&#xd;&#xa;d5BJNBKSkeS25GQgAZzggHFQnxBpmYQtwz+cquhSF2GD0yQOD7Hmp7/U7TTfL+1O6+Znbsid+mM/&#xd;&#xa;dBx1p1pqNrewNNBLlF+9vUoV+oYAiqi+ItMaYRCaTcW25NvIFz/vbcY984qW81mwsZBHPM24jOI4&#xd;&#xa;nk/PaDirFneQX0Amtn3IfVSpH1BwR+NZ2nT32qzfajLHHpwk3W5iBDzLjgtkn5eTxgHIFLeT3mmX&#xd;&#xa;0czyo+mSP++aQEvCTwoXH8JbaMYJ5POOmxRRRRRWPr/+v0f/ALCCf+gPWxRRRRRRWPpX/Ie1z/rr&#xd;&#xa;F/6KWrl/qlpp237VIylugSNnP5KDS2Oo2uoIzWshYKcEMjIfyYA496rP4h0uPzM3DExStC4SJ2Ku&#xd;&#xa;vUYA/XpUtzrFlaQwSzPIEnXdGVhdiRweQBkdR1xU1lf21/EZLaQsoOCGUqR+BANVbjxBpttO0Mk0&#xd;&#xa;hdeuyCRx+aqRUtzq1ja28c8s37uT7uxGcn8FBPanWGqWmo7vssjMV6h42Q/kwFUtOnvtVm+1GWOP&#xd;&#xa;ThJutzECHmXHBbJPy8njAOQKl1c6hbf6ZYOjhQBLDL93bnll5HzYJ79B0q9aXUN7ax3Ns++GQblb&#xd;&#xa;BGR9DU1FFFFY/i3/AJFjUP8Arkf51sUUUUUVj+Ff+QDF/wBdZv8A0a9Wb3WLGwlEVxK4cjOEid8f&#xd;&#xa;XaDirNrdQ3kCzW770PsQR9QeR+NUF8RaW/k7Lh3EwBQpC7Dk45IHH0NTX2sWWnzCK6eRXK7gFhdx&#xd;&#xa;jkdVBHarUFxDcW6zxOGjYZB6Y+oPT6GqH/CQ6Z9o8jz3379mfIk25zj723GPfOKlvdYsbFlW4mO5&#xd;&#xa;ugjjaQjp12g4696UatYnTnv/ADsW8YJdijArzjlcZ/SodIOoXP8Apl+6IGBEUMX3dueGbk/NgDv0&#xd;&#xa;PSotRnvtKm+1CWOTTjJuuDKCXhXHJXBHy8DjBOSa2aKKKKKx9f8A9fo//YQT/wBAetiisDwL/wAi&#xd;&#xa;jY/9tP8A0Y1V9WF8vikvZXdvaZskBedcq3zvwPektYrk3WoT3l/b3cxsdg8iMhQoLHr0zknjOa1P&#xd;&#xa;DUEMHh+w8mJI/Mt43fYoG5igyTjqfeq2qXt89+1rY3VvZeSoZ3uVyJd3Tb9MHP1FUNLV5bvX01S6&#xd;&#xa;iuVa2iEslupxs2yZwBk5xQ8uowWzM2pafc2UaZNt5eXkjA+5g9yOKjQ6gNZ1GSxvLWwikMJCXCdf&#xd;&#xa;3S9Pp0rU8OxSpcahLcXcV1PLIhdokKqMIAMHoeMdKk8J8eG7FDwyR7WXup9DR4p+bRXjHLtLFtUd&#xd;&#xa;TiRScD6VsUUUUUVj6/8A6/R/+wgn/oD1sUUUUUUVj6V/yHtc/wCusX/opaoasL5fFJeyu7e0zZIC&#xd;&#xa;865Vvnfge9T6LFcnWp57y/t7uY26oPIjIUKGJ69M5J4zmm+EooxNrc3lp5p1OZS+0btvBxn05NS6&#xd;&#xa;pe3z37WtjdW9l5Khne5XIl3dNv0wc/UVB4bNydb1Y3dzDcy+XB+8hGFx8/FRIt5Duj0nV7KCzDsU&#xd;&#xa;juIzvUkktnOD97OPbFVTJdTahZT6e1vp2bWVWaaMBCfNGcDpkkbq0NJium1/z73Uba6kFqyKsEZA&#xd;&#xa;ALqck9O3TrVvwnx4bsUPDJHtZe6n0NX9RYLp1yWIA8phye5FUvCqNH4asFdSrCIZBGCOa1qKKKKx&#xd;&#xa;/Fv/ACLGof8AXI/zrYooooorH8K/8gGL/rrN/wCjXrLlGpJ4h1ZrO/tbONniOLhM7/3a8itPw1C8&#xd;&#xa;UF6011HcyyXTO7xoVXO1RgZ69Oo4pvg+KOLwzZGONELpufaoG5vU+p4FVp9R1G9up/sV5bWEcErQ&#xd;&#xa;lLpcs5U/fH+ycj8jUnhob9GvhdSLJm6n814xw3zHJFUt95bWf7rUbGfTYo/ltGj/AHjwgcRkH+Ir&#xd;&#xa;xyOtV4vt48R6rLY3Ntp8ciW5xcJww8vov071JcW850LX3luY7y5mCljBGQvCgADseAOldRpzBtOt&#xd;&#xa;ipBHlKOD3Aqh4s58N3yDlnj2qvdj6CtiiiiiisfX/wDX6P8A9hBP/QHrYorA8C/8ijY/9tP/AEY1&#xd;&#xa;bF1ZWt4qrd20M6qcgSxhgD+NEFla2sLQ29tDDExJZI4wqkng5AqWONIo1jjRURAFVVGAAOgAqG6s&#xd;&#xa;bO92/a7WC42Z2+bGH2564z9BRa2NnZbvslrBb78bvKjCbsdM4+pqJdI0xZhMunWglDbg4gXcG65z&#xd;&#xa;jrUl1p9leMrXdnbzsowDLErED8RUsEENtCsNvEkUS/dSNQqjv0FUY9JFvqD3drcyxmaTfNGzFkfI&#xd;&#xa;5wucA8Dn2xTv7LEmqJf3M8kkkLHyEBKoikEcjOCeTz9PStCiiiiisfX/APX6P/2EE/8AQHrYoooo&#xd;&#xa;oorH0r/kPa5/11i/9FLWjdWVreKq3dtDOqnIEsYYA/jS21pbWcZjtbeKBCdxWJAoJ9cD6U6GCGDf&#xd;&#xa;5MSR+Y5d9igbmPUnHU+9R3VjZ3u37XawXGzO3zYw+3PXGfoKLWxs7Ld9ktYLffjd5UYTdjpnH1NR&#xd;&#xa;z6Tp1zM01xp9rLK33nkhVmPbqRUs9la3UKw3FtDNEpBVJIwygjgYBotbK1s1ZbS2hgVjkiKMKCfw&#xd;&#xa;qpHpIt9Qe7tbmWMzSb5o2Ysj5HOFzgHgc+2KdqGljUpUFxPILZNrCFCVy4Ocsc8jpxjtmtCiiiii&#xd;&#xa;sfxb/wAixqH/AFyP862KKKKKKx/Cv/IBi/66zf8Ao16v3Wn2V4ytd2dvOyjAMsSsQPxFTQxRwRLF&#xd;&#xa;DGkcajCoigAD2AohijgiWKGNI41GFRFAAHsBUFzptjeSCS6sradwNoaWJWIHpkj3qW3toLSLyraC&#xd;&#xa;OGPOdkaBRn6CoP7J077R9o/s+18/fv8AM8ld27Oc5xnOe9SXVjZ3u37XawXGzO3zYw+3PXGfoKkg&#xd;&#xa;ghtoVht4kiiX7qRqFUd+gqnp+ljTZXFvPIbZ9zGFyWw5Ocqc8DrxjvmmyaSLjUEu7q5lkMMm+GNW&#xd;&#xa;KomBxlc4J5PPvitKiiiiisfX/wDX6P8A9hBP/QHrYorA8C/8ijY/9tP/AEY1b9FFFFFFFFFFFFFF&#xd;&#xa;FY+v/wCv0f8A7CCf+gPWxRRRRRRWPpX/ACHtc/66xf8Aopa2KKKKKKKKKKKKKKKKx/Fv/Isah/1y&#xd;&#xa;P862KKKKKKx/Cv8AyAYv+us3/o162KKKKKKKKKKKKKKKKx9f/wBfo/8A2EE/9AetiisWPwro8SBI&#xd;&#xa;7eVFHRVuZQB/49Tv+EY0r/njP/4FS/8AxVH/AAjGlf8APGf/AMCpf/iqP+EY0r/njP8A+BUv/wAV&#xd;&#xa;R/wjGlf88Z//AAKl/wDiqP8AhGNK/wCeM/8A4FS//FUf8IxpX/PGf/wKl/8AiqP+EY0r/njP/wCB&#xd;&#xa;Uv8A8VR/wjGlf88Z/wDwKl/+Ko/4RjSv+eM//gVL/wDFUf8ACMaV/wA8Z/8AwKl/+Ko/4RjSv+eM&#xd;&#xa;/wD4FS//ABVH/CMaV/zxn/8AAqX/AOKo/wCEY0r/AJ4z/wDgVL/8VR/wjGlf88Z//AqX/wCKo/4R&#xd;&#xa;jSv+eM//AIFS/wDxVH/CMaV/zxn/APAqX/4qnw+HdMguI50hk8yJtyFriRgD64LYrVoooooorMuv&#xd;&#xa;D+m3d1JczQyedLjeyzyJnAAHAYDoBUX/AAjGlf8APGf/AMCpf/iqP+EY0r/njP8A+BUv/wAVR/wj&#xd;&#xa;Glf88Z//AAKl/wDiqP8AhGNK/wCeM/8A4FS//FUf8IxpX/PGf/wKl/8AiqP+EY0r/njP/wCBUv8A&#xd;&#xa;8VR/wjGlf88Z/wDwKl/+Ko/4RjSv+eM//gVL/wDFUf8ACMaV/wA8Z/8AwKl/+Ko/4RjSv+eM/wD4&#xd;&#xa;FS//ABVH/CMaV/zxn/8AAqX/AOKo/wCEY0r/AJ4z/wDgVL/8VR/wjGlf88Z//AqX/wCKo/4RjSv+&#xd;&#xa;eM//AIFS/wDxVH/CMaV/zxn/APAqX/4qj/hGNK/54z/+BUv/AMVSP4W0iRSrwTMp6g3UpB/8erZo&#xd;&#xa;oooorH/4RjSckiCVcksQtzKBknJ4DUf8IxpX/PGf/wACpf8A4qj/AIRjSv8AnjP/AOBUv/xVH/CM&#xd;&#xa;aV/zxn/8Cpf/AIqj/hGNK/54z/8AgVL/APFUf8IxpX/PGf8A8Cpf/iqP+EY0r/njP/4FS/8AxVH/&#xd;&#xa;AAjGlf8APGf/AMCpf/iqP+EY0r/njP8A+BUv/wAVR/wjGlf88Z//AAKl/wDiqP8AhGNK/wCeM/8A&#xd;&#xa;4FS//FUf8IxpX/PGf/wKl/8AiqP+EY0r/njP/wCBUv8A8VR/wjGlf88Z/wDwKl/+Ko/4RjSv+eM/&#xd;&#xa;/gVL/wDFUf8ACMaV/wA8Z/8AwKl/+Ko/4RjSv+eM/wD4FS//ABVPh8O6ZBcRzpDJ5kTbkLXEjAH1&#xd;&#xa;wWxWrRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRX/&#xd;&#xa;2Q==</binary>
<binary id="image18.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCACKAlwBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKx5tYuv7QurS00qW6+&#xd;&#xa;zFVd1mRRkqG/iI9aP7T1X/oX5/8AwJi/+Ko/tPVf+hfn/wDAmL/4qj+09V/6F+f/AMCYv/iqP7T1&#xd;&#xa;X/oX5/8AwJi/+Ko/tPVf+hfn/wDAmL/4qj+09V/6F+f/AMCYv/iqP7T1X/oX5/8AwJi/+Ko/tPVf&#xd;&#xa;+hfn/wDAmL/4qj+09V/6F+f/AMCYv/iqP7T1X/oX5/8AwJi/+Ko/tPVf+hfn/wDAmL/4qj+09V/6&#xd;&#xa;F+f/AMCYv/iqP7T1X/oX5/8AwJi/+Ko/tPVf+hfn/wDAmL/4qj+09V/6F+f/AMCYv/iqP7T1X/oX&#xd;&#xa;5/8AwJi/+Ko/tPVf+hfn/wDAmL/4qj+09V/6F+f/AMCYv/iqP7T1X/oX5/8AwJi/+Ko/tPVf+hfn&#xd;&#xa;/wDAmL/4qj+09V/6F+f/AMCYv/iqP7T1X/oX5/8AwJi/+Ko/tPVf+hfn/wDAmL/4qrmlX41LT47s&#xd;&#xa;RNFvLKUYgkFWKnp9KuUUUUUUUUUUUUUUUUUUVg2mu397ax3NtoU7wyDcrfaIhkfQmpv7T1X/AKF+&#xd;&#xa;f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/&#xd;&#xa;AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7&#xd;&#xa;T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8A&#xd;&#xa;iqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJ&#xd;&#xa;i/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+&#xd;&#xa;f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/&#xd;&#xa;AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiqP7&#xd;&#xa;T1X/AKF+f/wJi/8AiqP7T1X/AKF+f/wJi/8AiquaVfjUtPjuxE0W8spRiCQVYqen0q5WPpX/ACHt&#xd;&#xa;c/66xf8Aopa2KKKKKKKKKKKKKKKKKKKKKKKx/Cv/ACAYv+us3/o162KKKKKKKKKKKKKKKKKKKx/C&#xd;&#xa;X/Isaf8A9ch/Otiiiiiiiiiiiiiiiiiiiiiiiiiiiiisfwr/AMgGL/rrN/6NetisfSv+Q9rn/XWL&#xd;&#xa;/wBFLWxRRRTFljaV4lkQyIAWQMMqD0yO2cGiOWOYMYpEcKxVtrA4YdQfcU+iiiiiiimySJFG0kjq&#xd;&#xa;iICzMxwAB1JNKrBlDKQVIyCDwRS0UUUUUVj+Ff8AkAxf9dZv/Rr1sUUUUUUUUUUUUUUUUUyKWOeM&#xd;&#xa;SQyJIhJAZGBGQcHn6in1j+Ev+RY0/wD65D+dbFFFFVrrULKzZVu7y3gZhkCWVVJH4mg3sBsjdwN9&#xd;&#xa;phAJBt/3m7BxxjrVmiiqsd/BJqMtgpbz4kEjDHGD05q1RRTJpY4ImlmkSONRlndgAB7k1S/t3SP+&#xd;&#xa;grY/+BCf41oUUUUUUUUUUUUUVj+Ff+QDF/11m/8ARr1sVj6V/wAh7XP+usX/AKKWtO4hFxA8ReRA&#xd;&#xa;4xujYqw+hHSucvtK8jVNMt01LU/LuZJFkzePnAQsO/qK1Y7CTTIZZbN7q9mIAWK5u2Knn1Occe1N&#xd;&#xa;t9TuheQ22o2KWrXBIiKT+ZuIBJB4GOBTLD/kZ9X/AOuVv/J6h0a5itLHUZZmwBqFwAB1Y7zhVHcn&#xd;&#xa;oB3q9NqT2+nR3E9tsmlcRxw7+rMcICccZ4zxxmmW9/qPnol7pfkRudqvFN5uG9wFGB15+nrWnXOT&#xd;&#xa;X2rJ4pnit7NZo1tVKxtdbVI3t8+NpwT0x7dautql4+I7XT0nuVH79RcYSI/3d+0gt0OODgirVhfr&#xd;&#xa;d7o5I2guY/8AWQv1HuM/eXOQGxg4qe5Z0tpWiGZFQlRjOTjiuZtzps1vFLf6/Pb3boGnh/tEx+W5&#xd;&#xa;HzLtz8uDkY7VcuY9nhnVGh1D7baNayeSxbew+Vt2Xyd3P5YxS2Woao9lAbTSBJD5ahWmuPKY4GDl&#xd;&#xa;SpxznHqOa0Le/a80v7XZw+Y53BY2bblgSpGceoPOKrx6peRXEMepaelqk7+XG6XHmZcjIBG0YGAe&#xd;&#xa;faohrV3Pc3VvZaYZntpjGzPLsQjAOQ20jPPT8e9Safrbzy3dvfWb2dxbLvZMlwyf3gcDPOR+FRrq&#xd;&#xa;+oyQi6i0qNrNl8xZTdYYx9Q23bwcc4zWta3CXdrDcxZMcyLIuRg4IyKlrC8LXMC6CczxjyJZjLlx&#xd;&#xa;+7HmOfm9OOea021KxS1S6a9tlt3O1ZTKoRjzwDnB6H8qkku7aKeOCW4iSaT7kbOAzfQd6YuoWTXf&#xd;&#xa;2Rby3NzkjyRKu/IGfu5z0py3tq8ssSXMLSQjMiCQEoPcdqaNQsjaG7F5bm2U4MwlXYDnH3s460rX&#xd;&#xa;1mnkb7qBftGPJzIB5ucY2+vUdPUU77Xbfavsv2iL7Rjd5W8b8euOtNjvrOWOWSO6gdIc+YyyAhMd&#xd;&#xa;cnt+NNbUrFLVLpr22W3c7VlMqhGPPAOcHofyqSS7top44JbiJJpPuRs4DN9B3pJL21iuUtpLmFJ3&#xd;&#xa;GUiaQBmHsOp6Ghb21eWWJLmFpIRmRBICUHuO1MXUrF7V7pb22a3Q7WlEqlFPHBOcDqPzpZNQsoVh&#xd;&#xa;aW8t0WcZiLSqBIOPu889R09af9rtvtX2X7RF9oxu8reN+PXHWmR6hZTLM0V5busAzKVlUiMc/e54&#xd;&#xa;6Hr6UjalYpapdNe2y27nasplUIx54Bzg9D+VeZ3uq6l4Z126trO/aaEcqrZMeHw+QuSB16/X1rs9&#xd;&#xa;I8aaVqIVZZVtJtm5lmcBRz0DHGTzVvwl/wAixp//AFyH862KKKqatcPaaTe3MWBJDA8i5GRkKSKp&#xd;&#xa;2Wj2U1tHNeRfbZJVD5uv3u3IyQu7OB7Cm6mo0PRL6508CIqm9I8fu0P+yvQZ6nHc5qTXr66sUsjZ&#xd;&#xa;RpLJNdLEUZtoYFWOM9ug5qvfXeoaDpd1qF7cx36xhdsSxeTyWA65b19KnS31q3dZXv4bxQeYfs4i&#xd;&#xa;3A8fe3HGOvTnGO9VrP8A5HfUf+vWL+dV31h7m5uduuWOmiGZ4fJmVXY7SRuyWHX0xWtomoHUbJpC&#xd;&#xa;yOY5Wh8xDlZdpxvHoD1xz9TWjWVr8Uktvbssbywxzh7iJVLGSPawK7f4uSOPas3zND/6Fmf/AMFR&#xd;&#xa;/wDia0ZdRg0+ztI7Z2vHuDsty0u7zD15fn86p6kda0yzN2+qQzKskamP7IFyGcL13HHWtJbuU+IZ&#xd;&#xa;LIkeStokoGOdxdgefoBRdXcsWt6faoR5U8czPxzlduP5mqmq3TxXhRfEFjYjaP3M0alh78uP5VDJ&#xd;&#xa;rlzJoFnfWkaNLNdLDtLcOPMKdccZx17Z71NcT6jpNlc6je3Md1HHEWFusXlkHI/jyc45HSs2XXpL&#xd;&#xa;W1N8de0+5Crv+xoqq7f7O7cTn3x2rraKKKKKx/Cv/IBi/wCus3/o162Kx9K/5D2uf9dYv/RS1sVl&#xd;&#xa;alFI+taPIkbskcspdgpIUGNgMntzSa+krxwZSaWyDH7VFACZHGPlxt+b72Dweme1Y1pbWp8QaZJY&#xd;&#xa;adqUIjeQyvcpLtAMbAcuSBzW1ZRSL4i1SVo3EbxQBXKnDEb84PfGRWbY6M4F9exRvHfC9mkjEhO2&#xd;&#xa;QbyQNp4AP94DPcGtO7lkutHEhsncMcTQsrK4UEhio654O3HXjFZdhFEL+3OkWeoWrB/9Ia6WUK0X&#xd;&#xa;cDeSM529OeD711FYl672GvNfvb3E0MlqsI8iIyMGDMTkDoMEc1Hb3LabLNcfZLyW2vX88bYGMiOQ&#xd;&#xa;AVKjoMKDk+tWtNgnnv5tUuY/JaSMQxR9/LBLKzA8hvmOR2xWnIWEbGMAuAdoPQmsL+0bYcXWiXRu&#xd;&#xa;B/rTHYs6lu+GxyM9+9VVtLmW08RXMdvLHb3ltttoGQq4IjZWGztk/nmuisVK2NurAhhEoII5BxXP&#xd;&#xa;QW93H4Zto2hmCC5kNzEqkSNEXkOABzk5U8c1VFtZtqWmtp+m6pE6XSs73CTbQm1s/eJA5Iq5p2qJ&#xd;&#xa;Y3urRNaXsxN8zboLdpFHyJxkd+Kmggvb7Ub2+kt/JhmtPIgD5Vzyx+ZT0PzVlW9hp0NnFaz6Vqsl&#xd;&#xa;0kYjcqJ/LZwMHBBxtz3HGK63T4jBp9tCY1iMcSqY1YsFwAMAnrj1qxWL4WjjOgrlF+eWbdx97964&#xd;&#xa;59a1TbQGIRGCMxqchCgwD9Kc0UburtGjOv3WKgkfSmi3gEvmiGMSf39oz+dKIYgzMIkDP94hRlvr&#xd;&#xa;SC3gERiEMflnqm0Y/KlMELeXmJD5f3MqPl+npS+VH5vm+WnmYxv2jOPrSLBCiuqxIqv94BRhvr60&#xd;&#xa;htoDEIjBGY1OQhQYB+lOaKN3V2jRnX7rFQSPpSNDE0gkaJDIvRioyPxoEMQZmESBn+8Qoy31pBbQ&#xd;&#xa;CIxCCMRsclAgwT9KGt4HCBoY2CfcBUHb9PSneVH5vm+WnmYxv2jOPrTVt4EDhYY1D/fAUDd9fWg2&#xd;&#xa;0BiERgjManIQoMA/SvLNZs7jxF4pu30u3lkiZ1j37CFUhQDk9B0NdJo3gCzijSXVN08jJhodxCq2&#xd;&#xa;eoKkE/8A163PCX/Isaf/ANch/Otiiio7iCO5t5YJl3RSoUdc4yCMEcVgxQ65pMYstOtLe5tYifLk&#xd;&#xa;mmIcgnOD9CcfQVLeWep6h4evYbnYLq4TCwqRsj7YDdTnGefWruq2kt1Lp7RAEQXayvk4+UKw/qKd&#xd;&#xa;rOmpq+lzWMkjRrLtyyjJGGB/pVGCXxFcTJFcW1taRE5aaKTey45wARjnp+NTW9hPH4mvL9gvkSwJ&#xd;&#xa;GpzzkHniqEun6jZXNwtjp1leRTStN5k7AMCxyR06CrsrXGneHrh2kRLxo2aJEVQFlI+VFAHzc8Du&#xd;&#xa;a07Vna1haXPmFFLZGDnHPFQ6it2bbdYsBMjbgjYxIP7pJ6D3HpWX9r8Uf9Ayx/8AAg0y/wDD0y6P&#xd;&#xa;ZQ6dcst1p/zQMwHzN754qnrT61PpbtqEUNrCksJ2wuH8zMijByOMdeK1tStr+HURqGmQxTyvEIHS&#xd;&#xa;V9oCglgQfXJqC2s9WuNYs7+/EaLEkqGFGBCZ24IPU5xz6YqK4stTtbqcWmn2d7FJI0vmXD4YFjnb&#xd;&#xa;9B2pbXSLxNB061kSNZob1Z5FVuAvmlzg/Q1sanYrqWnT2buUWZdpYDkVhxWWrHbanTrCCEfJ9pXa&#xd;&#xa;zqB/FtIwTWr4guprTR53tH23RG2AAAsz+gB6nAPFaVFFFFY/hX/kAxf9dZv/AEa9bFY+lf8AIe1z&#xd;&#xa;/rrF/wCilrYoooooooooooooooooqpY2K2b3TK5b7TOZjkdCQBj/AMdq3RRRWP4V/wCQDF/11m/9&#xd;&#xa;GvWxRRVaG/tbi6mtYZ0eeH/WIOq/Wi8v7Wx8v7XOkXmttTd/EfSrNFFFFFFFFFFFV7Oyt7GExWsQ&#xd;&#xa;jQsWIHJJJJPJ9zVisfwl/wAixp//AFyH862KKKKKKKKKKKayK+NyhsHIyM4PrTqKKKhu7WG8gMFw&#xd;&#xa;m+MlWK5I5BBHT3AqaiiiiimsitjcoO05GR0PrTqKKKKx/Cv/ACAYv+us3/o162Kx9K/5D2uf9dYv&#xd;&#xa;/RS1sUUUUUUUUUUUUUUUUUUUUUUVj+Ff+QDF/wBdZv8A0a9bFFFchb/6Bqeo6svCLqBhuQOWdCqB&#xd;&#xa;AAeOHYE9OPXpTNeD6nHdXrsDa2lxHFAh4ZJRKqu3HUEdMn8BWt4h1T7DPZ2zXosUuBITcbQxXbtw&#xd;&#xa;MEEc7qraTrAk1aGzj1YaosyOzNsVDFtxj7oGc57+lO1bUpIdRlhuNW/sqJMeSfLV/OBAJPzA9DkU&#xd;&#xa;r6hdpo6Tx30c9u8u37eqjckeDucrjbww20aRfNc3qpba9HqXGZInjVNqd2G1eTnAweOak1y+jtrx&#xd;&#xa;EfX/AOziYwfK8pGzyfmyQfp+FNsNfB0a7u3k+1LbXAt0lUAebnaAxHAHL847CpLmz1hbaW4OtPG4&#xd;&#xa;QuYkgjZVOM7QSuSO2TzVO61uSLTtGFxfiza9tvNkutikhgqHGCMclj2p+k6wJNWhs49WGqLMjszb&#xd;&#xa;FQxbcY+6BnOe/pXS0UUVj+Ev+RY0/wD65D+dbFFVrK9jvkmaJXAimeFtwHLKcHHtUk5nATyBGTvG&#xd;&#xa;7eSPlzzjHfHSpaKKKKKKKKKKKKKKKrTXscN/bWbK5kuFdlIAwAuM5/76FWaKKKKKKKx/Cv8AyAYv&#xd;&#xa;+us3/o162KxHsNWg1S9ubCeyEd0yMVnjdiCqBexHpT9niP8A576V/wB+ZP8A4qjZ4j/576V/35k/&#xd;&#xa;+Ko2eI/+e+lf9+ZP/iqNniP/AJ76V/35k/8AiqNniP8A576V/wB+ZP8A4qjZ4j/576V/35k/+Ko2&#xd;&#xa;eI/+e+lf9+ZP/iqNniP/AJ76V/35k/8AiqNniP8A576V/wB+ZP8A4qjZ4j/576V/35k/+Ko2eI/+&#xd;&#xa;e+lf9+ZP/iqNniP/AJ76V/35k/8AiqNniP8A576V/wB+ZP8A4qjZ4j/576V/35k/+Ko2eI/+e+lf&#xd;&#xa;9+ZP/iqNniP/AJ76V/35k/8AiqNniP8A576V/wB+ZP8A4qjZ4j/576V/35k/+Ko2eI/+e+lf9+ZP&#xd;&#xa;/iqNniP/AJ76V/35k/8AiqNniP8A576V/wB+ZP8A4qjZ4j/576V/35k/+Ko2eI/+e+lf9+ZP/iqs&#xd;&#xa;6JYyadpcdtM6PIrOzMgIBLOW4z9av0UVn2emmFdRSR9y3k7SfLwVBVVx9eKZeaSJdCj0yCTasQiV&#xd;&#xa;Wfk4RlPOO+Fp+pWM889vd2ckaXVuHVPNBKENjOQMHPyjHNFlBqRnEuo3MJCAhEtlKq2eu7cTnGBj&#xd;&#xa;GO/Wm3cGqLcvJp9zb7JMFkuUZghAx8u0jA7855qGPS7xI5rkXSJqE0iyPsBELFV2gY67cYzz1HXt&#xd;&#xa;QlhqN3cwNqk1qY7eQTRi2RlJcAgZ3E8YJ/Sh7DUbS5nbS5rUR3EhmkFyjMQ5ABxtI4wB+tRwaJO+&#xd;&#xa;m30F9NGZbq5FxuhBVQRsIHOeMpUOq/2tHplw2pX1lBahDve3jdXz2AJJHJwDx0Jp1lYzz6Not3Zy&#xd;&#xa;RpdW9oqp5oJQhkXOQMHPyjHNaFlBqRnEuo3MJCAhEtlKq2eu7cTnGBjGO/WtCiiisfwl/wAixp//&#xd;&#xa;AFyH862KKx/Dn+ov/wDsIXH/AKGaPEf+osP+whb/APoYqvqNmt94rt4ZJJEj+wuXVCAJF3qCrZH3&#xd;&#xa;Tnmm3em2ej3mmy6bbpbPNdrDIyfxIVYlT7ZUflWTPL9s1rUku9Gm1ZYJtkRBGIhj7tb/AIYW4Wyu&#xd;&#xa;FntZLSMTnyIH/gj2rgD2zmtms/XbuWx0mWeHG/ciAntudVJ+uDVC+0i00yxuNStUK3tvE0xn/ilZ&#xd;&#xa;Rk7/AFDEc4x17VVuF/tm88OvcsUFxaSySrHwGBWMlec/Kc4+net6w02z01HSyt0gVzlgvc1neJ4j&#xd;&#xa;ONKiEskRa/Ub4yAy/I/TINVdc0XTtL0e6vrC0jguoE3RyoOVPqKi8QP5viAW02mSanAtqsiwqRhG&#xd;&#xa;LsC35ACrHhyOaPUJxHpcum2PlAiJ8YaTJy35YH4VWvpDos2qWlsA8dwEunMnJDzS+WwGMcADj39a&#xd;&#xa;ZF/p4sdFm+W2hmmjVk4ci3KhMnpznnj6Yrr65rV9I0+68UaeZ7WOQ3EcxlyPvlQgXP0qfUbWDSU0&#xd;&#xa;+eziW3ht5tszL0SE7iwPtu2mjSEF9rl5q6zPLblBDakEbCmFLY4z95T+tUvDegadeeH7Ke9h+1SN&#xd;&#xa;H8pl52L/AHRjt1P4moA0umeF9Vt4JZpVtL1YItxG7YTHlenfcfzqEwMjI2m+GLixug67bgEfINw3&#xd;&#xa;d+65H413FFFY/hX/AJAMX/XWb/0a9bFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFNdFkRkcZV&#xd;&#xa;hgj1FZaeGdFjdXTToQynIODwa1qKKKKKx/CX/Isaf/1yH862KKxh4fCSzPBqmowLNK0rJHIgUMxy&#xd;&#xa;cZWpF0RSirPf3tyFmjmXzXU7WQ5GMKOD3+lXDZRnUlv9z+asJhAyNu0kH8+BReWUd49s0jODbzCZ&#xd;&#xa;NpHLAEc+3JqrcaLHLO81vd3Vk0h3SfZ2UeYfU5B5qRLc6XYSfZIZLuYtvYF1DyscAkk4GcD9KXRr&#xd;&#xa;FtN0m2s3cO0KbSwHBq46LIjI4yrDBHqKzIdChimRmubmWGJg0Vs7KY4yPu4AGeO3NXJrKOa/trxm&#xd;&#xa;cSW6uqgEYIbGc/8AfIqzVa8so7x7ZpGcG3mEybSOWAI59uTRqNlHqNhNZzM6xzLtYoQCB7ZqG+0t&#xd;&#xa;LyYTpcXFrMF2GSBgGZeSAcg8ZJpbDTUsneVp5rmdhtM05Bbb2XgDjOT+JqW4so7i7tbl2cPaszIA&#xd;&#xa;RgllKnP4Gok0q1XVpNT2lrl0VAT0UDPT655+lXqp3+nR33lsZZYJo87JoSA6g4yBkHrgVn65aunh&#xd;&#xa;qXT0lmup5wYomkwWdiScEgADgHk4HFXdD09dK0i2skLkRrzvIJySSenuTWL4e0WZ9Cs2bVNStyY+&#xd;&#xa;YkdQF9gCua2k0awisJLKG2SKCRt5VP73GD9eB+VQJoS71+06jfXcQOTDO6lGI5GcKDwcHr1Fa1FF&#xd;&#xa;Y/hX/kAxf9dZv/Rr1sUUUUUUUVQ1a9ksY7ZolQmW6ihbcDwrMAce9RxajcPd6pCluJjaMgiRDtZ9&#xd;&#xa;yBjkk46n2pdC1Y6zYi8Fq8ETEiMswO/BIJ46cg9atveW0bFXuIVYdQXAIqekJABJOAO9RR3VvK22&#xd;&#xa;KeJ29FcE1Wub2SHWLGzVUMdwkrMSDkFduMf99GjRb2TUNMS5mVFdnkUhAQMK7KP0FX6KKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKx/CX/Isaf/ANch/Otiiiiiiiiiiiiiiiiiiiiiiiiiiiiisfwr/wAgGL/r&#xd;&#xa;rN/6NetiiiiiiiimSRRzBRLGjhWDLuUHDDoR7ihIo0keRI0V5CC7BQCxAwMnvxWH4F/5FGx/7af+&#xd;&#xa;jGqpDps0cSo2h6fqpA5vZpV3zf7RypP6mtS3E17pFpJpN+0UZXIkuI/NZx75I5pHe70y0nuNUvI7&#xd;&#xa;yLAQItv5fLEKM8ngkgVgawlzY28MsWiWmmMZ41M9tMu/BPK/KoOD9a7Noo2lSVo0MiAhXKjKg9cH&#xd;&#xa;tnAoiijgjEcMaRoCSFRQBknJ4+pp9FFFFFFFFFFFFFFFFFFFFFFFFFFFY/hL/kWNP/65D+dbFFFF&#xd;&#xa;FFFFZ+p6vbaWE88SuX6LEhcj3IHaku9Vhi0STUY97IIwwAXLAnGAR7EjPpWN4a1C3vbmGQzam13L&#xd;&#xa;FvkWVn8jcRk7QeMZ6Vt6xePZ20flAeZPMkCseiFzgNjvjOccZ9arfYdc/wCg1B/4Aj/4uo9TurmG&#xd;&#xa;LSWuH+zu16qS7ZPlZdr9TxwcA4/wpbfxTYXE6RCO6QucbpISqj6k9Ku6pqkGlxo9wkzBzgeVGXP6&#xd;&#xa;UaZqlvqkTSW4kXa2CsqbW7c4PbnrVSbxNp8Ql/1zmKdoHWOMsQy9eB296sWWtWV7ZPdxSFY4yVZX&#xd;&#xa;G1gR2xUNj4jsr65WCNLiNm6GWIoD7ZPeteiiiiiiiisfwr/yAYv+us3/AKNetiiiiiiiiioriEXE&#xd;&#xa;DxF5EDjG6NirD6EdKq6TpVvpFsbe1aYxZyFkkLBfp6VA/h+3LExXV9bp2iguWjRfYKOAK04Yo4Il&#xd;&#xa;ihjSONRhURQAB7AU24giuoGhmQOjdQRn3B+oPNZT+GbWXaJ7vUJlVg4WW6ZlyOnBraoooooooooo&#xd;&#xa;ooooooooooooooooooorH8Jf8ixp/wD1yH862KKKKKKKKw7aeHTdRvm1SVIXmlLQzzMAPKwMIGPo&#xd;&#xa;Qx29s571BDHLJc6reQZXTpYGEa9Fd+dzgdCG67u9aegf8i/pv/XrF/6AKfqv2b7GftasYiwG9RzE&#xd;&#xa;f7+f4dvXd2xmsXy9D/6Gaf8A8Gp/+KplxvvtL0QahEJC+obWWVMhlAkCkg9cgA+/WtLxb/yLGof9&#xd;&#xa;cj/Om6vfzQ3q2y3kOmxeWJPtNwoZZCSRsGSBkYz179Kp6JM03ia4ZtSt9QIs0HmwKFUfO3y8E89/&#xd;&#xa;xqHw5e6ZZ3WtNdXNpBcNqMwzLIquUyMdecZz+tZ+qwNdPqk+n2kiRSTWzrKsB2vguWkHZhyDu981&#xd;&#xa;ouzX1xaRv4htb0JcxyeTa26sx2sDk4c4HqccV1dFFFFFFFFY/hX/AJAMX/XWb/0a9bFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFY/hL/AJFjT/8ArkP51sUUUUUUUVHLDFMAJYkkA6Bl&#xd;&#xa;BxTgihAgUBQMbccY9KVVCqFUAKBgADgChlDKVYAqRggjgioPsNn/AM+sH/fsVMY0IUFFO05Xjofa&#xd;&#xa;h0WRSrqGU9QRkGmywxTACWJJAOgZQcUkVvBCSYoY4yepVQM1k6Lo/wBmbUWvYIXae+lmjJAY7Gxj&#xd;&#xa;+vFbIRQgQKAoGNuOMelRx2tvE26KCJG9VQA1NRRRRRRRRWP4V/5AMX/XWb/0a9bFFFFUNT1a20t7&#xd;&#xa;dbnePPYqhAGMgZwee/Qe5qOPWV8mWW5sry0jjA+adFAYk4AGGPOSKbDratMkdxYXtosjBFknRQpY&#xd;&#xa;8AcMeTSWLsfEuqqWJVYrfAzwOHqS71WS2uXhXS9QnC4/eRIpU8Z4ywqdb+OXT/tlukk64OEjALEg&#xd;&#xa;4I5OMggjr2rmNP8AEbz+F1l1ex1C5RlbzriJFVWG49CGBGOB0HSutuLiK1geedxHEgyzHoBVK01h&#xd;&#xa;Li5SCazurR5M+X9oVRvIGSBgnsM0l9rlvZX/ANhMU0t00QlSOJQTICSMDJHIwSfan2WrJcziCW1u&#xd;&#xa;bSVgSi3CqDIB1xgnpxn6ioptbVZnjt7C9u1jYo0kCKVDDgjlhyKo6hq8C6ro90kjtFJHcKqL1dxs&#xd;&#xa;AXHTdnI+taFvrKyzpFPZXln5h2o1wihWb+6MMecZP4GpbOa3k1HUI4UkE0boJixyrEoCMc8cY7Cq&#xd;&#xa;Nv4mgvIEnsrC+uo2HzGJFOxv7py3XofxFXtI1W11iyW7tGJQnaQ3VT6H35FXqKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKx/CX/Isaf/1yH862KKKKKKKKKKKKKKKKKKKKKKKKKKKKKx/Cv/IBi/66zf8Ao162KKKK&#xd;&#xa;xtXRX1zRFdQy+bLwRkf6pqf4ohluNBnjhzv3RtkDJAEikn8ACfwrGSeHUbq0iHiCXUSlxHIII4Ix&#xd;&#xa;91gckgDgd617D/kZ9X/65W/8nrLm1ZvOf7Zr/wDZc4Yg2nko2wdjkgnkYb8a0fB53eG7dg/mZeU7&#xd;&#xa;8fe/etzXOfbbbT/AcmkXkyw6gsbhrdvvAlyw/Qg102vWk872VxEplitpTJLCv3pVxjAHQ/jiq99f&#xd;&#xa;2uuwrZ6VOk0+9W8xekQDBiSeoyARx3NTqit4ykYqCy2CbSRyP3j0t/8A8jPpH/XK4/klZl1dWtle&#xd;&#xa;XEaa1JpO6VnaB4kbcxPLgkE4bqP5CpYGe51TQnuYER/LuTt2jHBXDfiMH8ava/8A6/R/+wgn/oD0&#xd;&#xa;aV/yHtc/66xf+ilrL8M69o1loFnDLewRSqnzr0OfetPw3FJHHfyPayWqzXbSRxyKFIXao6Djsa2a&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKwbS01rTbWOys00+W3hG2N5pHDke4C4qbf4j/54aV/3+k/+Jo3+I/+&#xd;&#xa;eGlf9/pP/iaN/iP/AJ4aV/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jo3+I/+eGlf&#xd;&#xa;9/pP/iaN/iP/AJ4aV/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jo3+I/+eGlf9/pP&#xd;&#xa;/iaN/iP/AJ4aV/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN&#xd;&#xa;/iP/AJ4aV/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN/iP/&#xd;&#xa;AJ4aV/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN/iP/AJ4a&#xd;&#xa;V/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN/iP/AJ4aV/3+&#xd;&#xa;k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+JqxoVlPp+kxW1yYzMrOzeWSV+Z2bjIHrWhR&#xd;&#xa;RRRRRRRRRRRRRRRRRVDQ7KTTtHtbOZkaSFNrFCSCfbNX6KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKK//Z</binary>
<binary id="image19.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCACzAiEBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKx5tZuf7QubS00ua6+zFQ7rKi&#xd;&#xa;jJUN/ER60f2pqn/QAuP/AAIi/wDiqP7U1T/oAXH/AIERf/FUf2pqn/QAuP8AwIi/+Ko/tTVP+gBc&#xd;&#xa;f+BEX/xVH9qap/0ALj/wIi/+Ko/tTVP+gBcf+BEX/wAVR/amqf8AQAuP/AiL/wCKo/tTVP8AoAXH&#xd;&#xa;/gRF/wDFUf2pqn/QAuP/AAIi/wDiqP7U1T/oAXH/AIERf/FUf2pqn/QAuP8AwIi/+Ko/tTVP+gBc&#xd;&#xa;f+BEX/xVH9qap/0ALj/wIi/+Ko/tTVP+gBcf+BEX/wAVR/amqf8AQAuP/AiL/wCKo/tTVP8AoAXH&#xd;&#xa;/gRF/wDFUf2pqn/QAuP/AAIi/wDiqP7U1T/oAXH/AIERf/FUf2pqn/QAuP8AwIi/+Ko/tTVP+gBc&#xd;&#xa;f+BEX/xVH9qap/0ALj/wIi/+Ko/tTVP+gBcf+BEX/wAVR/amqf8AQAuP/AiL/wCKq3pV+NSshc+U&#xd;&#xa;0J3shRiCQVYg9PpV2iiiiiiiiiiiiiiiiiisK2129u4RPa6JcSwsSFfz4xnBI6E57VL/AGpqn/QA&#xd;&#xa;uP8AwIi/+Ko/tTVP+gBcf+BEX/xVH9qap/0ALj/wIi/+Ko/tTVP+gBcf+BEX/wAVR/amqf8AQAuP&#xd;&#xa;/AiL/wCKo/tTVP8AoAXH/gRF/wDFUf2pqn/QAuP/AAIi/wDiqP7U1T/oAXH/AIERf/FUf2pqn/QA&#xd;&#xa;uP8AwIi/+Ko/tTVP+gBcf+BEX/xVH9qap/0ALj/wIi/+Ko/tTVP+gBcf+BEX/wAVR/amqf8AQAuP&#xd;&#xa;/AiL/wCKo/tTVP8AoAXH/gRF/wDFUf2pqn/QAuP/AAIi/wDiqP7U1T/oAXH/AIERf/FUf2pqn/QA&#xd;&#xa;uP8AwIi/+Ko/tTVP+gBcf+BEX/xVH9qap/0ALj/wIi/+Ko/tTVP+gBcf+BEX/wAVR/amqf8AQAuP&#xd;&#xa;/AiL/wCKqOfXL21jEt1os8UO5VZzNGcbiAOAc9SK3KKx9K/5D2uf9dYv/RS1rMyopZ2CqOpJwBUX&#xd;&#xa;2y1/5+Yf+/gp8c8MpIilRyOoVgakqFLqGS6ltkfM0IVnXB4DZx/I0W91DdCQwPvEcjRtwRhlOCOa&#xd;&#xa;moopu5d+zcNxGcZ5xTqKQkAZPAoVgyhlIKkZBHekDKWKhgWHJGeRTqKKp3+p2mnBTdSld3QKjOfy&#xd;&#xa;UGp7a4iurdJ4SWjcZUlSp/I8092CIzMcKoyTTLaeK6t47iBt8UqhkbBGQenWpax/C/8AyCW/6+Z/&#xd;&#xa;/RjVsUUUUUUUUUUUUUUUUUUVj+FP+Retv96T/wBDatiiiiiiiiiiiiiiiiiiiiisfxV/yApP+usP&#xd;&#xa;/o1K2KKx9K/5D2uf9dYv/RS1qTQxzxNFNGskbDDI4yCPcVz2t6NpkUuliPTrVBJeqj7YVG5dj8Hj&#xd;&#xa;kcCtmDTrOyEjWVrb2zsuC8cQX88dayZ76+02MXU+qWl5GrKpgjiCM24heDuOMZz07Vasf+Ro1b/r&#xd;&#xa;jb/+z1V0q/js7TUjxJMb+cRwg8uxc7R7ZPGTwK0xNdWmkz3N1iaaONpfLRdvQZCd+e2azkn1Ro1u&#xd;&#xa;E1O0kyN4tRCFZu+zdu4PbOPwrdjZmiRnTYxAJXOdp9M1zl7b6k/i6PyL6GMtayFC1vu2ruXIPzcn&#xd;&#xa;PetCe5vFaHTYZo3vmTfLP5eFjXJw2zPOSNuM980ttc3dpex2epSpMZ8mGdE2AsASU25PQAnOe+Kv&#xd;&#xa;Xn/HlP8A9c2/lVTw7/yLum/9e0f/AKCKhs/+Rp1P/r3g/wDZ6rJd6hfb54tStrFN7IIJYQ7DaSM5&#xd;&#xa;3DrjPTvTptSvnktrIvDY3EkbyGaTEikKwXgZH3shuvHSptPvrlNUWwubqG8MkTSrJEmwJtIGCMnO&#xd;&#xa;c+vaqVxBqT+L5fs19FETZgqWt92F3nj7w5zzmtHQ7m7mN9DeypLJbXHlB0TYCNqnpk+tJdXkv9rX&#xd;&#xa;Flx5IsTL053biP5VJ4b/AORc03/r2T/0EVpVj+F/+QS3/XzP/wCjGrYoooooooooooooooopqsrj&#xd;&#xa;KsCM44NOrH8Kf8i9bf70n/obVsUUUUUUUUUUUUUUUUUUUUVj+Kv+QFJ/11h/9GpWxRWPpX/Ie1z/&#xd;&#xa;AK6xf+ilrYrO1a0lupNPaIAiC7WV8nGFCsP6ipdVtpbvT5YIJTFI2CGHfBBI/EDH41zl3pE9zAIo&#xd;&#xa;fDVjaOXQiZJUyoDAnGFHYEfjW9a2ksWuX90wHlTxxKhzySu7P8xVKz0EILyZkSC9e6lliuEALbS2&#xd;&#xa;VBI5I9VzWnA15LZOJkS3ucFVbO8Z7Njj64rCk0yeUsg8P2UMr5AvUkTcjH/loBtzkHnGfxrpIEaO&#xd;&#xa;CNHcuyqAWPViB1rO1C3uo9Sh1GzhW5dImgMJcJwSDu3c/wB3GMd6bLBeebHqkNuovPKEUlsZAQy5&#xd;&#xa;JAD9iCc5x2xToLe7vryG71CBbb7MSYoVcP8AMQQWLccYJGMds1pSIJI2jb7rAg/jWRENU0uJbO1s&#xd;&#xa;UvLeIBYnM4jIUcBSMHJA796tadZyRzTXtzgXNwFDIvRFGcL7kZPPes28sZ3upGm0Cx1Fyf8Aj5dk&#xd;&#xa;QsOwwQTwOOvaopdCnVLSeW2i1N4kdPs8xAChm3DBOfugbRx+VXdHsGhuzcHSrPTgEKbYgrM+SDnc&#xd;&#xa;AMDjp3qyLSX/AISJr3A8k2giznndvJ6fSqvlajpt5dvZ2SXiXUvnFjMI9hwF24IOfu5z70y3sdSf&#xd;&#xa;Vbi8u/L2zWfloi/8syWJ2k/xYz14rR0a2ks9Hs7aYASRQqjAHPIHNXawvDFzANMnQzxhoZ5mkG8Z&#xd;&#xa;QeYxyfStQ6hZLbC5N5biBjgSmVdpPpnOO1Oa8tUeJGuYVab/AFYLgF/p6/hTTqFktz9mN5bifOPK&#xd;&#xa;Mq7s+mM5p63du80kK3ETSxjLoHBZR7jtTE1Cykt3uEvLdoUOGkEqlVPuc4FEl/ZxRxySXcCJL/q2&#xd;&#xa;aQAP9Dnmnm6txci2M8QnIyIt43EeuOtNjvrSUyiO6gcw/wCs2yA7Pr6dDSHULIWwuTeW4gJwJTKu&#xd;&#xa;0n0znFE2oWVuqNPeW8QkGULyqu4eoyeafJdW8UkcclxEjy/6tWcAv9B3oS6t5Lh4EniaZBlow4LL&#xd;&#xa;9R1FMW/s3heZbuBoozh3EgKqfc54pZL60jhSaS6gSKT7jtIArfQ96cbq3FyLYzxCdhkRFxuI9cda&#xd;&#xa;Rby1d5UW5hZof9YA4JT6+n40n26z+zfaftUH2fOPN8wbPTr0rzfVtcn0TxDcf2Pe+bat84QyeZHu&#xd;&#xa;bliADjrXRaP49sb2QRXsZtHJVVYtuVs9STgbRWt4TIPh22IOQTJgj/fatiikPAyabFIk0ayROrow&#xd;&#xa;yrKcgj2NIs0TTNCsqGVACyBhuUHpkVJRRWfd6xbWk/klLiZx94QQtJs9mx0P1rQpCcDNQ2V1FfWk&#xd;&#xa;V1ASYpV3KSMHFT0UUUUzzY/NEW9fMK7tmecdM49KfRRWP4q/5AUn/XWH/wBGpWxRWPpX/Ie1z/rr&#xd;&#xa;F/6KWtiiiiiiiiiiiiiiiiiiiiiiisTwxDEdLlYxpmS4mDnaPmHmNwfWtU2lsYRCbeIxA5CbBtB+&#xd;&#xa;lKbeBmRmhjLR/cJUZX6elIbS2M3nG3iMuc79g3Z+tOEEKyNIsSB3GGYKMt9TTVtLZYmiW3iEbcsg&#xd;&#xa;QYP1FD2tu6Ij28TLH9wFAQv09KcYIjMJjEnmgYD7Rux9aaltboXKQRr5n38IBu+vrQbS2MIhNvEY&#xd;&#xa;gchNg2g/SiS0tpgolt4nCDChkB2j2pzwQu6O8SMyfcJUEr9PShYIllaVYkEjcM4UZP1NNFrbrG0a&#xd;&#xa;28Qjc5ZQgw31FDW1u8axvBEyJ91SgIX6CnGCIzCYxIZQMB9o3AfWkFvArSMsMYMn3yFHzfX1pPst&#xd;&#xa;v5Hk+RF5XXZsG38q8y8T6bJqPiuaHSbcSINiEwr8iNjHJHA5z1rU0b4ekgS6tMRkEGGPqD2O7P8A&#xd;&#xa;Sum8IoI/Ddoi9F3gf99tWzRTJf8AVP8A7prN8Lf8i1p3/XBaq2H/ACOuq/8AXvD/AFqOXU7qWeX/&#xd;&#xa;AImtlpoSRkEFygLkA43csOD1HFPu9XuYls7aS4tbSWdXYXUjBo2C4wQMj72c9ePel0zWHbVk06W8&#xd;&#xa;tr9pIzKJrfChMcbSATz+NVdOt9WbV9X8nULdCJ03k22d37tcY+bjjArZsLyW41HUoJNuy2lREwOc&#xd;&#xa;FA3P4mmi8lbXbiyO3yUtUlHHO4swP8hUfhX/AJFnT/8AriKNZvry2vNPt7KNHa5d1YMcYwuc59uv&#xd;&#xa;vjFUb6+1jRZbea7kgvbWVxE+yPyijEgA9Tnv+VaOsTywmHytUtLDOc/aFB39OmWHT+tRaFqzX9xe&#xd;&#xa;WjyRXDWezNzERsl3Angc4xjHU1V0241vVbMTxz29qod1BaLzPMwxGcZG3GMfrUd1BqbeLUEF7DGx&#xd;&#xa;siVLQbsDcuR97uef0robdZUgRbiRZJQPmdV2gn6c4qWisfxV/wAgKT/rrD/6NStiisfSv+Q9rn/X&#xd;&#xa;WL/0UtbFFFFFFFFUtRvmsnswqB/tFwsJycbQQTn9Ku1DdG4W3c2iRvNxtWRiqnnuQD2qUdOaWiq1&#xd;&#xa;7exWMcbyhiJJUiG0Z5Y4H86s0UUUUUUVj+F/+QS3/XzP/wCjGrYooqJ7mBJ0geeNZnGVjLgM30HU&#xd;&#xa;06aWOCJpZpEjjXqzsAB+JpY5EljWSN1dGGVZTkEexp1FFFFFFFFFFRxwQws7RRIhc5YqoG4+/rUl&#xd;&#xa;Y/hT/kXrb/ek/wDQ2rYopCAQQehrHS21TTUFrp0VrNaoP3fnSMjRj+7wDkD1PPNWdP0/yJpby4Ie&#xd;&#xa;9nAErDoAOij2HTOMmqd1Z6iblytlp16pJKy3HyuB2XAU9OmahfQriNLadVt7meIyHyJz+7G8gkA4&#xd;&#xa;PC4wOOnpVvTbG6S6+0XEFnahVKiK2QHd7lioI+lWLCylttQ1GdypS5lV0weQAgXn8RVaS11Gzv7q&#xd;&#xa;fT47aZbpldxNIU2kKFwMA56Umn6ffpq1xfXskTedbrGET/lmQWO0cDI56nmrWiWcmn6PaWkxUyQx&#xd;&#xa;hWKnIz7VQ19rldX0Y2aRvN5ku1ZGKqf3ZzkgHtRdaZqWsLGmoyQ2kUMiyBID5nmEHPJIGMe3rUmo&#xd;&#xa;afdG/kubeC1vBKqgx3TECLb/AHeD1zz06CmaBpd3ZahqV1dRW0IujHsjt2JVdoIPYVe0Syl0/S47&#xd;&#xa;aYqXV5GO05HzOzD9DUV/aXa6hHqFgsUkyxGAxzMVXaSGzkA85A496v25mMCG5VEmI+dUYlQfYmpa&#xd;&#xa;Kx/FX/ICk/66w/8Ao1K2KKx9K/5D2uf9dYv/AEUtbFFFFFFFYNpapr8Jvbx5gC7pHFFKyBArFTyp&#xd;&#xa;Gc4zz0zWdqUtzLNBpouCslpqMKJcbQTho2YZHTgHHvirer6XBpWlXN/aSXK3FuhdC9w7gH3Ukg/j&#xd;&#xa;SeNbZRoVxqCSTJcxIgRklZQMuOwOD1NN1m48zWks54L24txarKEtCQwYsRkkEHGBU2gPdLqU8KW1&#xd;&#xa;5BpwiDRi6BLb888kk9PeizsYtZkvJ715y8V1JCvlzPGAqnAGFIH41F4g0xBptnHNNLKEvIkj+cqV&#xd;&#xa;RnUYJB5IHc81t2GnQaerrbmUhzk+ZKz/APoROKt0UUUUUVj+F/8AkEt/18z/APoxq2KKK5fWrWSf&#xd;&#xa;xMJrcqt1bWIkhZjwp8wg/X5SafeX0XiK3gtrcMLaaE3E6yDaWjBIABHfcAfpT7S+Om+BrW7VQxjt&#xd;&#xa;o+CcDnA/rVQa2LaaFk8QQ6iXlSP7OI0UncQM5HPGc1f1nUJYL7yX1BdLgCBkmdFYSk5yvzemB+dM&#xd;&#xa;OpX0WlGaCePUI2kCC7jAG1Tnc5UDHy/rSaZfSTXqJb69b6l/fh2KhC92BUckenvVrXLoWzwg61Hp&#xd;&#xa;u4Hh41bf09fT+tV7HxBEml311cT/AGuGykCGeJRmUEA5x0H3sfhUzW+sTxG5/tQW25dwhSBXCj/e&#xd;&#xa;IyaqSa3NH4f0qee5SCS9CrJcsoxGdpbOOnbH40abrGdWt7RdXi1MXAbO1FUxbRnPy9c10tFFFY/h&#xd;&#xa;T/kXrb/ek/8AQ2rYoooooooooooqCW1hmuIJ5FzJbljGcnjIwf0qeiiiiiiisfxV/wAgKT/rrD/6&#xd;&#xa;NStiisfSv+Q9rn/XWL/0UtbFFFFFFFZF/o889yZrDUZLBn/1ojQNvI4B56cUl7oQn0+2tra5a1eC&#xd;&#xa;YTCVV3Etg5OD6liagXQL2Rgl7rU11bHiSFolAcehI5qHxbd215o95pVrMkt+20LbocuSGBPH0BNa&#xd;&#xa;Oo6VJdvHPa3j2VyFCNKiBiy9dvPuc1JpmmGyLS3Fw13dONrTuNpK9hgcVVutEumuZJLDVZbGORi7&#xd;&#xa;RJGGBc9WyfWrH9kRHTDaM5aQnzDMRz5vXzMeuecdKfpdldWaSC71CS9LEFS6Bdv5VfoooooorH8L&#xd;&#xa;/wDIJb/r5n/9GNWxRRWf9il/t832V8n7L5OM87t+fyxSwacLdr5kfcbpy4BGNvygY/TNVl0d5PC8&#xd;&#xa;OlTOqyLCiMy8jK4P9KakWsXEiJNBZ2kYYM0kMhdsA5xgqOvSp7+PUVufNs1guEZQpinbYEI7ggHO&#xd;&#xa;c/pVaPTNQK3Fz5yW11M6OYo/mTCAjbkjo3c44o+yalez2/223tbaOCVZg0EhZmK/w4Kjg5ok0++s&#xd;&#xa;9Rurqxjt7r7Wys6zuU8vaMADAOc1DHodzeafqtvfmK3a+lDjyTvCABR3A/u0t7Jq8enyJc/Y7K3V&#xd;&#xa;MNcpMWZB2OCuOenXvUen2Ut14a0WaDY01qiyokhwrnaVwT261oWcWpyXcct3Hb20cefkgbf5mRjn&#xd;&#xa;IGMda1aKKKx/Cn/IvW3+9J/6G1bFFFFFFFFFFFFFFFFFFFFFY/ir/kBSf9dYf/RqVsUVzCa3p2le&#xd;&#xa;IdZS+ulhZ5IioKk5HlL6Crf/AAmGgf8AQRT/AL4b/Cj/AITDQP8AoIp/3w3+FH/CYaB/0EU/74b/&#xd;&#xa;AAo/4TDQP+gin/fDf4Uf8JhoH/QRT/vhv8KP+Ew0D/oIp/3w3+FH/CYaB/0EU/74b/Cj/hMNA/6C&#xd;&#xa;Kf8AfDf4Uf8ACYaB/wBBFP8Avhv8KP8AhMNA/wCgin/fDf4U3/hLPD27d9vi3evltn+VO/4TDQP+&#xd;&#xa;gin/AHw3+FH/AAmGgf8AQRT/AL4b/Cj/AITDQP8AoIp/3w3+FH/CYaB/0EU/74b/AAo/4TDQP+gi&#xd;&#xa;n/fDf4Uf8JhoH/QRT/vhv8KP+Ew0D/oIp/3w3+FH/CYaB/0EU/74b/Cj/hMNA/6CKf8AfDf4Uf8A&#xd;&#xa;CYaB/wBBFP8Avhv8KP8AhMNA/wCgin/fDf4Uf8JhoH/QRT/vhv8ACneE5Em0USxncjzzMp9QZGxW&#xd;&#xa;1RRRRRRRRRRRWQ3hjRmYs1kpJOeXb/GtYAAYAwBS0UUUVyWgeJdHsdIhtrq9WOaNn3KVY4+dj2Fa&#xd;&#xa;P/CYaB/0EU/74b/Cj/hMNA/6CKf98N/hR/wmGgf9BFP++G/wo/4TDQP+gin/AHw3+FH/AAmGgf8A&#xd;&#xa;QRT/AL4b/Cj/AITDQP8AoIp/3w3+FH/CYaB/0EU/74b/AAo/4TDQP+gin/fDf4Uf8JhoH/QRT/vh&#xd;&#xa;v8KP+Ew0D/oIp/3w3+FH/CYaB/0EU/74b/Cj/hMNA/6CKf8AfDf4Uf8ACYaB/wBBFP8Avhv8KP8A&#xd;&#xa;hMNA/wCgin/fDf4Uf8JhoH/QRT/vhv8ACj/hMNA/6CKf98N/hR/wmGgf9BFP++G/wo/4TDQP+gin&#xd;&#xa;/fDf4Uf8JhoH/QRT/vhv8KP+Ew0D/oIp/wB8N/hR/wAJhoH/AEEU/wC+G/wrP13xJpF/phtrS9WW&#xd;&#xa;Z5YtqhWGcSKT1HoK6yimNFGxy0ak+pFJ5MX/ADyT/vkUeTF/zyT/AL5FHkxf88k/75FHkxf88k/7&#xd;&#xa;5FHkxf8APJP++RR5MX/PJP8AvkUeTF/zyT/vkUeTF/zyT/vkUeTF/wA8k/75FHkxf88k/wC+RR5M&#xd;&#xa;X/PJP++RR5MX/PJP++RR5MX/ADyT/vkUeTF/zyT/AL5FHkxf88k/75FHkxf88k/75FHkxf8APJP+&#xd;&#xa;+RR5MX/PJP8AvkUeTF/zyT/vkUeTF/zyT/vkUeTF/wA8k/75FHkxf88k/wC+RR5MX/PJP++RT1UK&#xd;&#xa;MKAB6AUtFFFFFFFFFFFFFFFFFFcvomi2WoaHaTyxAXKeYI5h95D5jYI7H8RV3bf6bxJbJqFuOFZF&#xd;&#xa;UTeuWzhcdRx7VPZ6ppN9IY7aSNmA3EGMrx+IFaHkxf8APJP++RR5MX/PJP8AvkUeTF/zyT/vkUeT&#xd;&#xa;F/zyT/vkUeTF/wA8k/75FHkxf88k/wC+RR5MX/PJP++RR5MX/PJP++RR5MX/ADyT/vkUeTF/zyT/&#xd;&#xa;AL5FHkxf88k/75FHkxf88k/75FHkxf8APJP++RR5MX/PJP8AvkUeTF/zyT/vkUeTF/zyT/vkUeTF&#xd;&#xa;/wA8k/75FU7690+wC+fs3udqoqZLH046fjVTy9Q1LhbddNtzwxYKZwRzlcZXB4HPv7VU1nSLPTtD&#xd;&#xa;uHgiHnSywGWU/ekbzV5PYdT0x1rpqKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKx/&#xd;&#xa;Cn/IvW3+9J/6G1bFV7yxtb+MR3cCTIp3AOucH1rMMOqaXKGt5Hv7MDLRyNunLHjgnAwOD+dXLLVr&#xd;&#xa;a8ZogxiuI8eZC4wUPpnofwNX6KKKKKKKKKKKKqX2pWmnxh7qYRgtt6EnOM9BWex1jU5RtX+z7M/L&#xd;&#xa;IrnE/wBVKkgdvyNX7HTLWxLPEmZnGJJm5eT/AHj3q5WP4q/5AUn/AF1h/wDRqVsUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVj+FP+Retv8Aek/9DatiimsdqlvQZrD027s/FVgJrmzE&#xd;&#xa;TxsfLVyC6jAw68cex9qzf7X1Ow8RJpdojahbEHa8r/OzBSSN544PbFb9vrVpJuWd/ssqcOk/yDPc&#xd;&#xa;KTgNj1FXEuYHgM6TRtEMkyBwVGOvNMN9aCYQm6gEpIATzBuOenFJLf2cMhjlu4EcdVaQAj8M03Vb&#xd;&#xa;4abp0140ZkEQztBxnnFW6p2V+t39ryvli2naFiT1wAc+3WnxX9nPII4buCRz0VJASfwzT57q3ttv&#xd;&#xa;2i4ii3dPMcLn86VLmCSEzJNG0QyS4cFRjrzXNHxKfLTUJNRs4LMy7Tb+WZJQA2DyD3wTnHcVpA6n&#xd;&#xa;qYB4sLVuu1t0jqeQysD8v4g1A0Vvpk9hNZ7J5rq4+zy3UhDyOuGOCw9CoH4Vv0UVj+Kv+QFJ/wBd&#xd;&#xa;Yf8A0albFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFY/hT/kXrb/AHpP/Q2rYopk&#xd;&#xa;v+qf/dNcjpxl07SNM1KAAiW1WCUtyAefLwPd2wfb0q5HaGz1HQkcESyPPLKM5AdkJYD2yTT77T7f&#xd;&#xa;W9aubbUk+SCILb9id4+cjPUjA5HTNY2pWlx4ftr3TtPZ7uxmtZGeN2+a3wvXPTnJOMc4rW0aHQpU&#xd;&#xa;t5WRWvF24luk2ys3bG4AnHAGPSs7T4JL6z+0zeHo7+V3fN1JMgZ8MQOvPAAH4VdljvZPAEiXTm4u&#xd;&#xa;jGdzK4kLfP6jOeK6dJEkjDxurowyGU5B/GubgiefTdX8qYRCW/LI5OFkX5OAemGwV/GoltoLORJ5&#xd;&#xa;9BXS0DqPtUEyFkJOAMAZwSQD7GqmsajC/iS5t5tLOrxqI1jA+ZYWOd3Y4ycZ+lW7LSbq8mvbOVP7&#xd;&#xa;N05kUG1glVmGQc8jgA98jn8Kp2mi6b/wg9xcNZxNOkNxiVlBbKs4Bz+ArrrWRItNgeR1RFiUlmOA&#xd;&#xa;OBXMWRDaRoBBBB1NyCPrLXYUUVj+Kv8AkBSf9dYf/RqVsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUVj+FP+Retv96T/ANDatiikIDAg9DxVe3sba3sorNIg0EQAVX+bGOnWnTWkM1zb&#xd;&#xa;3DqTJbljGc9MjB/So77T4L9FE29WX7rxuUceoDDnFRx6RaJYzWm13SdSkjO5Z2B4wWPPepJ9NtLi&#xd;&#xa;NUlgRiqbEkx86D/ZbqD7iudufCc9q7zaff3bwpyliJmQN6jfu45yelaunanbxRi0uoE06ZAd0WMR&#xd;&#xa;rz0D4CkkHOB7+lOfw9ZtIWWS7iBPCRXDog9goOAKNQu9OgtjZbFlJ+RYIU3bT2ztHy845PSsez8M&#xd;&#xa;3F9IsupS3drCpwbM3bSh8cht+eOccf7NbUugWLqgQTQlRgtDK0bSe7Ecsfc+p9atWNhBYRssO8lv&#xd;&#xa;vPIxd29MseTiltrG3trP7JHGDB82Uf5gdxJOc/U1TTw/ZLKHZrmRc58uSdmjPsVJxj2qaLSLOG3t&#xd;&#xa;oI4ysdrKZohuPDHd/wDFGr9FFY/ir/kBSf8AXWH/ANGpWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRWP4U/5F62/wB6T/0Nq2KKKKKKKKKytUv9OLG1mgF/MhBNvHGJXTj7xXsOevvW&#xd;&#xa;fFperixkQTNEpPNsbhpC/Tnzj8y/QDt71Y027sbBhDc2/wBhuThGlm6TN6CQ8vW7RRRRRRRRWP4q&#xd;&#xa;/wCQFJ/11h/9GpWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWP4U/5F62/3pP8A&#xd;&#xa;0Nq2KKKKKKKyLrxFY26u8Ymuo4wTJJbJ5ix467iOlYl5rkl9FI95HcQ6ZjDNbRmVJV9fN424PB9w&#xd;&#xa;a37FbGw0lZrBWuYEU7Wi/eu4zzg9Tz/KltdZguJlhkhuLV34QXMfl+YfRc9TVe71mwnM9qbe4upI&#xd;&#xa;naKSOGLe6cdcDkDng+1Yt1d3Phy5sodJtbu4guVMjWsiEsWK/wB85IIwMrjjHvW9Z6/bypGL1JNP&#xd;&#xa;mcDEd0PL3MeoXP3sH+YrWoooooorH8Vf8gKT/rrD/wCjUrYooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooooorH8Kf8i9bf70n/obVsUUUUVk3etIJhbafG15OzFGaL5kgboPMI5UZ/kab/Zd&#xd;&#xa;zf8AOrzhoz1toCRGD2O7AbP44p+uwxweGtRWJFRfs0nAH+yarprWlppSRQzQ3UgiAFtAys7nHQLn&#xd;&#xa;k1Q0xrzTPCGmwuHs2aRknldcG3UlzuOeB2HPrVWeWOTX9FCa4NSxO3yjy/k+Xr8ord8Pqvn6u2Bu&#xd;&#xa;N+4zjnG1aNZZYNV0q6mIjt4Xk8yVuFTKEDJ6DJIFX0ay1O33xtDcxHKh1IYe+CKo/wBmXdhzpFwo&#xd;&#xa;jHS2uCSnud2C2fxxTrLXYZpfIu4ZbGYsEQXICec3T5Mn5ucfmK1qKKKKx/FX/ICk/wCusP8A6NSt&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisfwp/yL1t/vSf+htWxRSE461mT61F5&#xd;&#xa;721jG93cIdrrGBiI9i2SOPpmo/7MvL7nVboeU337WDiM46HdgN79a07e2htoxHBGqKABx1OPU96l&#xd;&#xa;qpqtq97pV3axlVeaFo1LdASMc062s4YIoh5MQdFA3Ko64qdlV1KuoZT1BGQajW2gRgyQRqw6EIAR&#xd;&#xa;Uiqq52qBk5OB1NDosilXUMp6gjIoSNI12xoqL6KMCnVDc2sN1G0c8aupBXnqAeuD1H4Vm/2PJY/N&#xd;&#xa;o85hxyYJGLpIfcnLD8KP7aNl8msxfZiOPtC8wu3UBT97OPUdjWuCD0OaWisfxV/yApP+usP/AKNS&#xd;&#xa;tiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisfwp/yL1t/vSf+htWvWZPrlss729q&#xd;&#xa;kl5cxnDxQAFk9zkjjOPzqH+ybrUJRJrE0bRY2tZwktC/oTkA5z/IVrQQRW0CQwIEjQYVR0AqSiii&#xd;&#xa;iiiiiiiiikrFfQ3tJRLo8/2VU5+yjiKRvVsc9MfkKlTWhbusOqxG1kJ2iT/llI3oh6/mBWrnPSsj&#xd;&#xa;xV/yApP+usP/AKNStiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiuCsPGFrpmmwWC&#xd;&#xa;AmYFw0rKSkRLtjIHJGCDxU3/AAkGk33/ACF9YEiDgwW9vIsTj/aBBJOfQitSDxd4btoEhgu9kaDa&#xd;&#xa;qiCTAH/fNP8A+E18P/8AP8f+/Mn/AMTR/wAJr4f/AOf4/wDfmT/4mj/hNfD/APz/AB/78yf/ABNH&#xd;&#xa;/Ca+H/8An+P/AH5k/wDiaP8AhNfD/wDz/H/vzJ/8TR/wmvh//n+P/fmT/wCJo/4TXw//AM/x/wC/&#xd;&#xa;Mn/xNH/Ca+H/APn+P/fmT/4mj/hNfD//AD/H/vzJ/wDE0f8ACa+H/wDn+P8A35k/+Jo/4TXw/wD8&#xd;&#xa;/wAf+/Mn/wATR/wmvh//AJ/j/wB+ZP8A4mj/AITXw/8A8/x/78yf/E0f8Jr4f/5/j/35k/8AiaP+&#xd;&#xa;E18P/wDP8f8AvzJ/8TR/wmvh/wD5/j/35k/+Jo/4TXw//wA/x/78yf8AxNI/jLw9IjI97lWGCDDJ&#xd;&#xa;yP8Avmsk614fsvn0bUzaMORAYJDAx6FmULknHv2FR3ni601bTZbFsrcebCEYKds2JFJI/ujjODzz&#xd;&#xa;Xd0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUV//2Q==</binary>
<binary id="image20.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2Nj&#xd;&#xa;Y2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCALbAnYDASIA&#xd;&#xa;AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA&#xd;&#xa;AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3&#xd;&#xa;ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm&#xd;&#xa;p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA&#xd;&#xa;AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx&#xd;&#xa;BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK&#xd;&#xa;U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3&#xd;&#xa;uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD0Ciii&#xd;&#xa;gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopKAFopM1mS+ItJhleKW+iV0Y&#xd;&#xa;qyk9CKANSisj/hJ9G/6CEP50f8JPo3/QQh/OgDXorI/4SfRv+ghD+dH/AAk+jf8AQQh/OgDXorI/&#xd;&#xa;4SfRv+ghD+dH/CT6N/0EIfzoA16KyP8AhJ9G/wCghD+dH/CT6N/0EIfzoA16KyP+En0b/oIQ/nR/&#xd;&#xa;wk+jf9BCH86ANeisj/hJ9G/6CEP50f8ACT6N/wBBCH86ANeisj/hJ9G/6CEP50f8JPo3/QQh/OgD&#xd;&#xa;XorI/wCEn0b/AKCEP50f8JPo3/QQh/OgDXorI/4SfRv+ghD+dH/CT6N/0EIfzoA16KyP+En0b/oI&#xd;&#xa;Q/nR/wAJPo3/AEEIfzoA16KyP+En0b/oIQ/nR/wk+jf9BCH86ANeisj/AISfRv8AoIQ/nR/wk+jf&#xd;&#xa;9BCH86ANeisj/hJ9G/6CEP50f8JPo3/QQh/OgDXorI/4SfRv+ghD+dH/AAk+jf8AQQh/OgDXorI/&#xd;&#xa;4SfRv+ghD+dH/CT6L/0EIfzoA16KoWWsafqEpjs7qOZwu4hT2zir9ABRRRQAUUUUAFFFFABRRRQA&#xd;&#xa;UUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABR&#xd;&#xa;RRQAUUUUAFFFFABRRRQAUlLSUAJx6VkeHhldRPf7dN/Otg1keHfuah/1/TfzoA1sfSjH0p1FADcf&#xd;&#xa;SjH0p1FADcfSjH0p1IaAEx9KMfSgngkGohcwNL5YnjMmcBQ4zn6UAS4+lGPpSA+9LzmgAx9KMfSk&#xd;&#xa;yenekZ1XG5wuTgZPU0AOx9KMfSkyfX6UA8d6AFx9KMfSjNJyeh4oAXH0ox9KAcjPrRnmgAx9KMfS&#xd;&#xa;g0ZP4UAGPpRj6UZ56013CKWYhVHUk8CgB2PpRj6UAg9Dn8adQA3H0ox9KdRQA3H0ox9KdRQA3H0o&#xd;&#xa;xTqSgDH6eL1x3sTn/v4K2axz/wAjev8A14n/ANDFbFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAB&#xd;&#xa;RRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFF&#xd;&#xa;FFABRRRQAUUUUAIayPDv3NQ/6/pv51rmsjw79zUP+v6b+dAGxRRRQAUUUUAFIelLSHpQAh9/zrBt&#xd;&#xa;bK1Hiu9kW2hV0hidX2DKkl8ke5rdJOPX8KxbeHUU8RT3L2kYt5VWPcJskBd2DjHfPSgBZ7rUp9an&#xd;&#xa;sLOSOKJIkfzmXd5ZJbt3zj1GKfFPf2Wo29reXUd39qDbWWLyvL2jPqc5z7VNBayprl1dnb5csMaD&#xd;&#xa;B5JBbPH4ii7tZZdWsLhcFIfM3+oyABQBmvqVxLLI0msWmllXZfs88algAcBslgecZ6d+9M1oX9xb&#xd;&#xa;6U4uIomN0igqokDHnbIOR25x79auTpfrO/8AxK7W9GciZpAhI7DG09Omc9qadJnTTIFDh54Lj7UI&#xd;&#xa;zwM5J8vPYc4z7dKAG31xqumW8JNzFeyy3KRqvleUNpzkZyfbntTdTl1XS9Iu72S+imZUGxBBt2nc&#xd;&#xa;O+TnipZ4tQ1EWxns47Yw3UcuBPvyoznsPar2r2H9p6ZNZrL5RlAG/buxyD0yM9KAJ95+yeYT82zc&#xd;&#xa;frisN9Wvzpujywqjz3hAcE7QcoT17dKsF9ZlgNqLKG3UrtE/nh8e+3Az+femwaXcx2miIwUtZsDL&#xd;&#xa;z/sFePXk0AQX8+u2ckNrDdQXM90T5bGERiMLyc8nOR9KtwzXtlqVta3l0l0t0G2ssXl+XtGT3Oc/&#xd;&#xa;hU95Zyz6rp9wg/dweYXyefmXApby2lm1bT50A8uHzN/4rgUAZ+oaw/8Aas1gt9bad9nVW82cBhLu&#xd;&#xa;HYEjGPqfwpqa3KdM1Qx3EV1LZR7luIgNrkgnoCcYx6mpLzTZ4dWn1CC1hvTcKqmOVwnl7RjIJBzn&#xd;&#xa;6Cny2N3caPfRGCG3luYiiQR4O04I5YYzn6cUANsxrV9ZwXX22C0MiKfL8gSduu7I69cY4qLU7mbU&#xd;&#xa;vBtxcxsICYn3qRuyBkEZ4xnFbNhE9vp9tDIBvjiVDjnkACs+10uX/hGzpszCN3R0LfexuJ7fjQBP&#xd;&#xa;pNvfxIr3d9HcRmMBUWDZg8c5yc1qVnadJflvLurJII0XCus+/d+GBitGgAooooAKKKKACkpaSgDI&#xd;&#xa;P/I3r/14n/0MVsVjn/kb1/68T/6GK2KACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK&#xd;&#xa;KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigApK&#xd;&#xa;WkoATPrxWT4d+7qP/X9N/OtY1zWlak9pJqEa6de3I+2ynzIkUr192FAHTUVk/wBuS/8AQG1P/v2n&#xd;&#xa;/wAVR/bkv/QG1P8A79p/8VQBrUVk/wBuS/8AQG1P/v2n/wAVR/bkv/QG1P8A79p/8VQBrUVk/wBu&#xd;&#xa;S/8AQG1P/v2n/wAVR/bkv/QG1P8A79p/8VQBrYorJ/tyX/oDan/37T/4qj+3Jf8AoDan/wB+0/8A&#xd;&#xa;iqANb8KMD0rJ/tyX/oDan/37T/4qj+3Jf+gNqf8A37T/AOKoA1qMD0rJ/tyX/oDan/37T/4qj+3J&#xd;&#xa;f+gNqf8A37T/AOKoA1qKyf7cl/6A2p/9+0/+Ko/tyX/oDan/AN+0/wDiqANbA9KKyf7bl/6A2p/9&#xd;&#xa;+0/+Ko/tyX/oDan/AN+0/wDiqANajFZP9uS/9AbU/wDv2n/xVH9uS/8AQG1P/v2n/wAVQBrEA9qK&#xd;&#xa;yf7cl/6A2p/9+0/+Ko/tyX/oDan/AN+0/wDiqANaisn+3Jf+gNqf/ftP/iqP7cl/6A2p/wDftP8A&#xd;&#xa;4qgDWorJ/tyX/oDan/37T/4qj+3Jf+gNqf8A37T/AOKoA1qKyf7cl/6A2p/9+0/+Ko/tyX/oDan/&#xd;&#xa;AN+0/wDiqANaisn+3Jf+gNqf/ftP/iqP7cl/6A2p/wDftP8A4qgDWoNZP9uS/wDQG1P/AL9p/wDF&#xd;&#xa;Uh1uU/8AMG1PH/XNP/i6AD/mbh/14n/0MVsVztldtd+K9zWtxbEWRG2dQCfnHoTXRUAFFFFABRRR&#xd;&#xa;QAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFA&#xd;&#xa;BRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAhrI8O/c1D/AK/pv51rmsjw99zUP+v6b+dAGvRR&#xd;&#xa;SZoAWiop7iO3UNK21ScA4qTPT0oAWikz601pFUhWIDHoPWgB9FGaQk+lAC0UmaQyBQS3ygckmgB1&#xd;&#xa;FNDhlDAgg8gilBzQAtFIDmkyfSgB1FRxTpMu6NgwzjOMUj3MaSpE7BXc4UetAEtFIDRk46fhQAtF&#xd;&#xa;QpdRSTvCjgyR43L6ZqXNAC0UmeaQuFUs3AHUmgB1FRwzLNGJE+6elEc8ckkiIwLIcMPfrQBJRQPe&#xd;&#xa;igAooooAKKKKAMg/8jcv/Xif/RgrYrHP/I3r/wBeJ/8AQxWxQAUUUUAFFFFABRRRQAUUUUAFFFFA&#xd;&#xa;BRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAF&#xd;&#xa;FFFABRRRQAUUUUAFFFFACGsnw993Uf8Ar+m/nWse1ZPh77uof9f0v86ANese8ur9bqSKE20Ma4Ie&#xd;&#xa;Y5LcZ6Bs1sVz02n3Q1KeZ7OK8VyNjSuBs49CDQBWvtQlvNG8wqrSxz4wnCsfm9T7VfN3qFlJbm98&#xd;&#xa;hopmEeYwQVJ+pPpVMaPfLYSQqsau0wdcHAA5/wAatvb39/JbpcwpDFE4ckSbixHtgetIZC+rXstx&#xd;&#xa;OsD2sflnAjmVgzcDocgUl+95Jq2nOhhRjn5WBODhvQ+lLd2N3K0qSabbXRb/AFcxYIyj8j/OnnTr&#xd;&#xa;y3WweIC5e3J3h32Zznvz60AEGpajd6jc28EcCpBKylmB5A/HrTri+1EGV91nCiE4jckuw9eGqbTb&#xd;&#xa;Ce2ub6STCrNIzKc561Qi0y6RZo5LKC4lYki5kcFsH2I4/OgCyNXmuLeyFsifaLtd3zA4GACe/vTb&#xd;&#xa;59UFheRXCQEeUSHUHGMHPGc5plvpd3a21lLGFe4tVK7C2AwIAPNWWh1C8S4FwqwLJEUSMPv5IPPb&#xd;&#xa;1FAE+iCYaTbecYyfLGCoI4x796SK/ZdQube4CoqKGQ+oxz/OpNJS4isI4rlAjRjaMNnIHGfaqet6&#xd;&#xa;ZPetG9qwR8GNzn+E9f5CmAwatdtaxOIo/MuH2RDB46jJ5qeK8vIL6O1v1hYSj5HiBAz6HJPoaW/0&#xd;&#xa;+RorZrXAlt2DAEcN7e1Mjtry71GK5u4kgWEfIitvyfXPGOpoArx6tILNfKhhWaWUxxqFIHTOTz7G&#xd;&#xa;opTejXbFbsQnDk7owR/C3qTUg0i5S0jK7RPDMZFGevGP61L9n1G51O1uJ4UijibJCvu7EenvQBoa&#xd;&#xa;lcvaWTTRgMy4wG781mjUNRjtYby4S38iQrlVU7lyQPX3q5rvGlyY9Rjj3rPt4dQvdOtreSJEhG1m&#xd;&#xa;k8zcWAIPTHtSASxkYa9qskS7m8qNlz34NPfVb23aJ7hrQq7hTHGDuUH33EUp0m6F5qEkbhFniRYy&#xd;&#xa;DzwP0qs+k3cltDGtjBDJEwZpQwLSY98CgDVh1BzqDwTBVjKCSI9yMc5/MVRutRnudJBIVftMoiQr&#xd;&#xa;kcHIz19RTNdhZobRIZQl2cQkKeQGxk/TgVb1e08rSoTEnNrIsuFHpkmmBqQII4URR8qjFZkzG18Q&#xd;&#xa;xFeBcR7SD0z1z+QrThkEsayKQQw4xWbOhudfgCH5bdd7H36Y/WgRoWxuC0nnhANx2Y6le3erFU7G&#xd;&#xa;4lnecSIFCSFQc9QMVcoAKKKKACkpaSgDIP8AyN6/9eJ/9DFbFY5/5G9f+vE/+hitigAooooAKKKK&#xd;&#xa;ACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA&#xd;&#xa;KKKKACiiigAooooAKKKKACiiigAooooAKKKKAEPasnw993UP+v6X+dax7Vk+Hvu6h/1/S/zoA16a&#xd;&#xa;adWHe317Lqj2VkyJsxuY4zyM9DQBs4PP6UvX2rKsrq7imlh1BcIi7hLj5SPc9O9JpGsw39n58ssS&#xd;&#xa;EMQwLgY5OKQGqevGaB+dZ89+srwG1u4Npk2uN6nPt9asSahZwk+bdwIQcEGQDB9PrQMsdsdRR9P/&#xd;&#xa;ANdRm4hEXnGRPKxnfuGKjjv7OVlEd3C5YkALIDmgRYHp/SjA/GmySpEAZXVASAMnHJpHniSRI2kV&#xd;&#xa;Xf7qkjJxTAfSfyrN1jUTaQqYZE8wSqrrkfKD61attQtbjCRXMMkuMlFcEg/SgCzjpg0Dj1NV5tQs&#xd;&#xa;7dtk91BE46q0gB/WquqatDZxQussZErYB3DAHPP6UAaQHOT1pe9Z1zektbwWzBnm5yDnC88/pV+T&#xd;&#xa;dsbb1xxQA2eGO5iMcoypPSljjWJFjThVGAPaqulXRurTMn+tRtjj3HWk1i5e0sS8PEjOqA/Ugf1o&#xd;&#xa;AvY6UhP6Uy2Egt0Exy+OTVG8vpIr0pENyxRFpOO/GP60AWGsbd7v7Sy5kGMZ6CrLosiFGAKtwQR1&#xd;&#xa;rJ0XUpr6SVJVHyE9vfj9K11GBQAyGBYIljTIVabFbxxSySIPmkOWJ+mP6VNSHpQAiqqZKKAScnAx&#xd;&#xa;ml3Vl63qE9lbkxL8zEBeM80579v7LF1gKzlQv4kAfzoA08460A5qunmtZjJIm29SOhqvo1zLc27i&#xd;&#xa;cgyRyMhPrgkf0oA0aSlpKAMg/wDI3r/14n/0MVsVjn/kb1/68T/6GK2KACiiigAooooAKKKKACii&#xd;&#xa;igAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKK&#xd;&#xa;ACiiigAooooAKKKKACiiigAooooAQ9qyfD33dQ/6/pf51rGsjw99zUP+v6X+dAGxWBdR6fqGpSxS&#xd;&#xa;CSG6jxhgxBbj2PNb9U7vTbS9/wCPmFJD6tQBl2TzW2rHT5Lj7TC0Zf5lGU5HB496yLWNG8JlSAGM&#xd;&#xa;pDEcHq1dbaWFtYoVtoUjDdQveo10mxXdttoxu60h3MnWoI7d9KEaKmblc478U6xtoZb/AFZ5UD4k&#xd;&#xa;xz2+Ra2prWCcxmWMMYjuTP8ACfWlS3ijaRkUK0hy5/vHp/SgDlISRYQJISbcXGHGf4dvH64q3qCW&#xd;&#xa;yeJtKWFQshL5A4BG3j+tal5aeVaFLS3jYFsuhz81Z1ppZfUoJ4rRbWGEk7TwTkYz3pgamsQ+dp0u&#xd;&#xa;B8yDev1XkfyrnZrr7Wyair5W0EQJ9Dn5/wBK68rlSp5Bqsmn2scMkKQII5CSw9c0Bc5u8UT6SLqT&#xd;&#xa;rdXS8nuuWA/Sr93bx202lvCio29UJHf/ABrYazt3gSFolaNCCq+hHSnPbRSGMugJjOU9qAOehb7T&#xd;&#xa;PdS2trAIwRvknYk9O3WqkRV9CsWkCsVlYHP/AAKukfR7CS4M720ZlPVsdae2m2ZtTbm3Tyicle2a&#xd;&#xa;AM6LA8ShSAALTKDt96tusy5sDBPazWihViO1lH93np+JrRkLCNiASccCgRk6Rxqeoqn3fMyfrk5p&#xd;&#xa;daDtJaq+PsxlUt65BG39ataVatb2xaTHmSne2PU03WreS5sdsQDOsiOB/usD/SgC+cBcngCs3S1E&#xd;&#xa;8t3dMMiV9mD6LkVeiZpbcF0KMRyDSwRLBHsUcZJ/OgBUijjJKIqk9cCldlQAscDpTqjnt4rlNkyB&#xd;&#xa;1Bzg+tAC7xv25G7Gce1CurbgDnBw1Ma1hadZig8xV2g+gpIbWG3L+VGF3nJxQBI0aufnVWx0zzWb&#xd;&#xa;fqJL2ztFGFJLsB045H6itU8c1D5C/aTP/FjFAEtZGls/9pXSw824c7iex5z+takzFYmYKWIGdo71&#xd;&#xa;R0S3lhtnacYeWRnAPUAkkfzoA06SlpKAMg/8jev/AF4n/wBDFbFY5/5G9f8ArxP/AKGK2KACiiig&#xd;&#xa;AooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAC&#xd;&#xa;iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAQ1keHfuah/1/TfzrXNZHh37mof9f0386AN&#xd;&#xa;iikrJvLy/W7eOFrWGNcYM3Jbj2NAGnNNHCgaRtoJwPrTgQRkVzF9qMt7o29lUyxT4OzgH72MZq99&#xd;&#xa;s1Cye3N6LcwSuEBiUgqT0zkn3pAbP401nRWVSwDN0Hc1gtq97LczJA9rEIjgRyqwZuPXIFJfPeya&#xd;&#xa;vpzJ5MbHOVYE4OG9D6UDOi96D9awYdT1K71C5ggS3CQSlcsDyB+PWnz3+oI0zb7OFEYhEkyzMPU4&#xd;&#xa;amI2qazBQXJwAOSfSsYaxNcw2S2yJ590pbDA4XABPf3pt7Jqv2C8injg4iJEig4xg54znNAG6jB1&#xd;&#xa;DKQQeQR3paztE87+yrfzmQ5QEFQR296ItQcajcW1wERY1DIw7jHNAGjQawl1i6a0ikEUZkuJAkS4&#xd;&#xa;OB1GTz9Knivb2G+jtb8QkSj5XiBHPpyT6UAaMUscqlkORnBoknijlSN3w7H5R61iQ6rIlkDBFF50&#xd;&#xa;0xjRQCATjOTz7Go5Gvf7esVvBEfn4aMED7repNIDoxR+FRXDvFCzInmMOi5Az+dYj6ve2xhe4a1Y&#xd;&#xa;SOqGOPJYZIHXJHegDoKg+2QFWIcYVtp+v+RWc2oXtzfzW9gsIWEAlpQTnPbgis21nkhtLh5Yo2c3&#xd;&#xa;QBDcjOW6YNAzqlYMoI6EUo6VmWd9LJfNbFUEaRqwwDnJGfXpULaxMtrfS+Upa3fagAP93PNAGzUa&#xd;&#xa;SK2drBivBwaybG+vrhuZLWWJlJ3xgqVPoQTn9Kz9NuLq0sdQuJjCVRh91TnOB79KYjpYpo5txjbd&#xd;&#xa;tO0/Wjz4/P8AJzh8bsVX0qHyLCNTkuRuZj3PrVXVz9lu7W7Xj5xG3uCcD+dAGt1pRUGbg3WCE8ja&#xd;&#xa;Oe+eff6VN3oAdSUtJQBkH/kb1/68T/6GK2Kxz/yN6/8AXif/AEMVsUAFFFFABRRRQAUUUUAFFFFA&#xd;&#xa;BRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAF&#xd;&#xa;FFFABRRRQAUUUUAFFFFABRRRQAhrI8O/c1D/AK/pv51rmsjw79zUP+v6b+dAGvXOT2d4mqTyNpyX&#xd;&#xa;0chBVpHXCcdgc10lJQByyaTqA06WIQBJDMHTDLgDn37Zq35epajJbR3tkLaKJxIzear7iOg46da3&#xd;&#xa;qMUrBc5q+tb55JkfSYrzP+rmLohHHvk1LJYX1vHp7xRm6lgJ3gsFznPOSfeugxRRYLmPpljcQXV/&#xd;&#xa;JLHsWWRmQ5ByD3rPjsb2MTxSaXHcSMx23UjoSR9Dz+veuoo/CmBzkOm31raWM0cO65tgVaPeBuBA&#xd;&#xa;HXP1qwqanqEV19og+yq0RRIvMD7iQRnIP0rbo+lAFDSFuUsI4rqDyXjATG8NkDjPFVNe024uzG9o&#xd;&#xa;MOcxuQQPkPU9R6CtqigDJ1GwlMED2iDzrdgypwA47j2zUdvDe32pRXF7ai1SAZRd6vk9O3Tqa2qM&#xd;&#xa;YoA5xdLu0sUdY/8ASYZjKibh83GOueODUiw6pd6ra3FxZ/Z4o2yw81W7EdvrW/iigdyjq9vPc6e8&#xd;&#xa;ds5SUkYKnB6/WsE6bezW9uiaTHbvFIjM4dCz4YEnP4V1lHSgRgPbX2n6hLcWlt9oSfGU8wJsPrz1&#xd;&#xa;5NU5be5g09vtiBHluQwXIPUk44+tdUe1VriyhupY5JQzeWcgZ4zSsBlPFfW11Hd2Vr9oDxBWUyBM&#xd;&#xa;cD1os7LUYbK93IBPJJvUEhg42gY61vAAYA6AYFLTsBzljY3UmpRTtpyWCoDvMbqQ/wCA/wA8UhsL&#xd;&#xa;wQ6jZvB+5lAdJSw+Yjbxj8DzXSU0jIweQaAKulTCfToJM5JUZ+tVNbU3EtnbLyzSByB6KQf6Vo29&#xd;&#xa;ulsrrEMBmLY9KBbxi5M+MvtwCewoAh+0TDU/s3l5i8sNvz354x+FW1/z7UmxdxbA3EYzTh6UALSU&#xd;&#xa;tJQBkH/kb1/68T/6GK2Kxz/yN6/9eJ/9DFbFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAU&#xd;&#xa;UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRR&#xd;&#xa;RQAUlLSUAJnnk4FZPh37mo/9f03861utc9YXdxpsl7E+l302+6kkV40UhgTx1YUAdFRWT/bkv/QG&#xd;&#xa;1P8A79p/8VR/bkv/AEBtT/79p/8AFUAa1FZP9uS/9AbU/wDv2n/xVH9uS/8AQG1P/v2n/wAVQBrU&#xd;&#xa;Vk/25L/0BtT/AO/af/FUf25L/wBAbU/+/af/ABVAGtRWT/bkv/QG1P8A79p/8VR/bkv/AEBtT/79&#xd;&#xa;p/8AFUAa1FZP9uS/9AbU/wDv2n/xVH9uS/8AQG1P/v2n/wAVQBrUVk/25L/0BtT/AO/af/FUf25L&#xd;&#xa;/wBAbU/+/af/ABVAGtRWT/bkv/QG1P8A79p/8VSf25L/ANAbU/8Av2n/AMVQBr0ViXHiP7NCZZ9J&#xd;&#xa;1JI16sY0wO396pP7dk/6A2p/9+0/+KoA16Kyf7ck/wCgNqf/AH7T/wCKo/tyX/oDan/37T/4qgDW&#xd;&#xa;orJ/tyX/AKA2p/8AftP/AIqj+3Jf+gNqf/ftP/iqANaisn+3Jf8AoDan/wB+0/8AiqP7cl/6A2p/&#xd;&#xa;9+0/+KoA1qMVk/25L/0BtT/79p/8VR/bkv8A0BtT/wC/af8AxVAGtRgVk/25L/0BtT/79p/8VR/b&#xd;&#xa;kv8A0BtT/wC/af8AxVAGtRWT/bkv/QG1P/v2n/xVH9uS/wDQG1P/AL9p/wDFUAa1FZP9uS/9AbU/&#xd;&#xa;+/af/FUn9ty/9AbU/wDv2n/xdAB/zNy5/wCfE/8AoYrYrCspJ7zxF9qaxuraJbUx5nUDJ3g9ia3a&#xd;&#xa;ACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA&#xd;&#xa;KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooASiiigAooooAKKKKACiiigAooooAK&#xd;&#xa;KKKACiiigApGGRilpGIUZNAGBr9tHquoWunsufJBuXBOAVwVGCOc7iKv6JdSXOnRfaH3XSDbOCAC&#xd;&#xa;HA5HFQ6X+91bU5ZBl45REhP8KbVOPzOaj0uQWmsXunMu55Ga7DjphiBj68UAbQpaQUtABRRRQAUU&#xd;&#xa;UUAFFFFABRRRQAUUUUAFGKKKADFLSUtABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAF&#xd;&#xa;FFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUU&#xd;&#xa;UUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABSHOOKWkoA5bVNKfR9HllstTv1EZBCF1xyw/&#xd;&#xa;2fetC20BbfUlvzfXss4XYTI6kFfQ4UU7xV/yALn6p/6EK1x0oAQZz606iigAooooAKKKKACiiigA&#xd;&#xa;ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACi&#xd;&#xa;iigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKK&#xd;&#xa;KACiiigAooooAKKKKACiiigAooooAKSlpKAMjxV/yALn6p/6EK1x0rI8Vf8AIAufqn/oQrXHSgBa&#xd;&#xa;KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoo&#xd;&#xa;ooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAopCcUZ9jQAtFJR&#xd;&#xa;QAtFJRQAtFJRQAtFJRQAtFJRQAtFJRQAtFJRQAtFJRQAtFJRQAtFJRQAtFJRQAtJRQTQBkeKv+QB&#xd;&#xa;c/VP/QhWuOlZHio/8U/cn/c/9DFa9AC0UlFAC0UlFAC0UlFAC0UlFAC0UlFAC0UlFAC0UlFAC0Ul&#xd;&#xa;FAC0UlFAC0UlFAC0UlFAC0UlFAC0UlFAC0UmRmigBaKKKACiiigAooooAKKKKACiiigAooooAKKK&#xd;&#xa;KACiiigAooooAKKKKACiiigAooooAiuXMVtJIuMqpIz06ViWM2v3tlBcrJpqpLGrgGKTPIz/AHq2&#xd;&#xa;b7/jxn/65t/Kqvh/nw/p+f8An3j/APQRQBBs8Q/899N/79Sf/FUbPEP/AD303/vzJ/8AFVr0tAGP&#xd;&#xa;s8Q/899N/wC/Mn/xVGzxD/z303/vzJ/8VWxRQBj7PEP/AD303/vzJ/8AFUbPEP8Az303/vzJ/wDF&#xd;&#xa;VsUUAY+zxD/z303/AL8yf/FUbPEP/PfTf+/Mn/xVbFFAGPs8Q/8APfTf+/Mn/wAVRs8Q/wDPfTf+&#xd;&#xa;/Mn/AMVWxRQBj7PEP/PfTf8AvzJ/8VRs8Q/899N/78yf/FVsUUAY+zxD/wA99N/78yf/ABVGzxD/&#xd;&#xa;AM99N/78yf8AxVbFFAGPs8Q/899N/wC/Mn/xVGzxD/z303/vzJ/8VWxRQBj7PEP/AD303/vzJ/8A&#xd;&#xa;FUbPEP8Az303/vzJ/wDFVsUUAY+zxD/z303/AL8yf/FUbPEP/PfTf+/Mn/xVbFFAGPs8Q/8APfTf&#xd;&#xa;+/Mn/wAVRs8Q/wDPfTf+/Mn/AMVWxRQBj7PEP/PfTf8AvzJ/8VSbPEPefTcf9cZP/iq2aSgDlfEK&#xd;&#xa;64NGnNxNY+V8u7y43B+8MYy30rSCeIcf67Tf+/Mn/wAVS+KeNAuf+Af+hCtcdKAMjZ4h/wCe+m/9&#xd;&#xa;+ZP/AIqjZ4h/576b/wB+ZP8A4qtiigDH2eIf+e+m/wDfmT/4qjZ4h/576b/35k/+KrYooAx9niH/&#xd;&#xa;AJ76b/35k/8AiqNniH/nvpv/AH5k/wDiq2KKAMfZ4h/576b/AN+ZP/iqNniH/nvpv/fmT/4qtiig&#xd;&#xa;DH2eIf8Anvpv/fmT/wCKo2eIf+e+m/8AfmT/AOKrYooAx9niH/nvpv8A35k/+Ko2eIf+e+m/9+ZP&#xd;&#xa;/iq2KKAMfZ4h/wCe+m/9+ZP/AIqjZ4h/576b/wB+ZP8A4qtiigDH2eIf+e+m/wDfmT/4qjZ4h/57&#xd;&#xa;6b/35k/+KrYooAx9niH/AJ76b/35k/8AiqNniH/nvpv/AH5k/wDiq2KKAMfZ4h/576b/AN+ZP/iq&#xd;&#xa;NniH/nvpv/fmT/4qtiigDH2eIf8Anvpv/fmT/wCKo2eIf+e+m/8AfmT/AOKrYooAx9niH/nvpv8A&#xd;&#xa;35k/+Ko2eIf+e+m/9+ZP/iq2KKAMfZ4h/wCe+m/9+ZP/AIqkZfEIUnztNOO3kyf/ABVbNNf7jfSg&#xd;&#xa;Clo11Jf6Ta3U23fKgZgo4zV4Vk+FufDdj/1yFa1AC0UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUU&#xd;&#xa;UAFFFFABRRRQAUUUlABRRRnNABQSBRUc00UOPNkVc8DcaAGX3/HlP/1zb+VVvD//ACL+n/8AXtH/&#xd;&#xa;AOgirN7/AMeM5zn9238qreH/APkX9P8A+vaP/wBBFAGhRRmg0AFFQW91FchvKOdpIP54/pU9ABS0&#xd;&#xa;lLQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUlLSUAFLSUtACUVG0qJIqM4DP0Gaf360AZPir/kA&#xd;&#xa;XP1T/wBCFa46Vk+Kf+Rfuf8AgH/oYrWHSgAopGIVSScAVHb3EdzCJYjlT0oAlpaQdKWgAooooAKK&#xd;&#xa;KKACiiigAooooAKKKKACiiigAooooAKKKKACkpaSgAozSZHbn6UfhQAuRSP9xvpUF3dx2aK0vR22&#xd;&#xa;ipZCAjEnjHegDM8Lf8i5Y/8AXIVrZrJ8MAjw7YDniIfjWqDn+nNAC5ozSEgfX0qrZXi3RmCgjynK&#xd;&#xa;Hnjgkf0oAt5ozSAjOOKPegBaWkpaACiiigAooooAKKKKACiiigAooooAKKKKAEoooPIoAqajerY2&#xd;&#xa;ck7YO0HAzjnBPX8KxF1uaGOO4e9t5gx+a3QAMo+uefyrcv7QXlrJbtxvUjPpxj+tZcen6jiKFhaJ&#xd;&#xa;HGeZEXLMB2wVx/8AqoAfqGqz6VOXuF823cfJsXkN2H86pawt+9raNPOiuzHIEfTg+9X7jSJL+6c3&#xd;&#xa;zK1soIiRGOR7npz171HcaZqE2nxRmSFrmFjtZidrDHfj69qQyDVNTlV5LL7VDDshJeRwPm6jAGeP&#xd;&#xa;zqvo+tSp4bVUjCy20SAZOeMgVc1DTrpRLeIluzNCVljbJHflTjPpUOkaZcTeGolMsbNNFGVyMALw&#xd;&#xa;RkgdaAJze6lbmznnkjeK5dVMYTBTcR379fQdKna5vby+nhtJUhSDglk3bzzx1GOn61JeadNPbWcc&#xd;&#xa;bIrQyI7ZzghSCe3tUbWV9bXs01l5JWf7yyE/K3PI4PrQBm2F1c2mlXEiIWn80hjjO3Lt82O+OtaO&#xd;&#xa;k3s88+1ry3uo9uTswrKfcZPvUdvpd/BZSIssQnd9+eqn5icHI96dZ6ddDUlu7hIItqFdsBPzHI5I&#xd;&#xa;IHpQBtZ5p1NHWnUxBRRRQAUUUUAFFFFABRRRQAUUUUAFJS0lABWdrGo/YLQOuN7sEBY4AycZ/WtG&#xd;&#xa;qGrWH262CrgSKwZc9Mg55/KgDNh1mSC5iSS7hvEmIX92ApQkj0JzT7rVry0uns2QPPKcW7AYGD6/&#xd;&#xa;TIqSGxv3uEadbWJI+f3S5Ln8V4/CmTaLPdvNcXEi/ag2YGUnCY6due2eDSGRX8d5/a1iPtagkEnE&#xd;&#xa;XTkds0j6vNPczLHe21qsR2gOAxY4HPUY61durK9le0uFMJmhyGViQpGfYe1QHTby2mma2itZklO7&#xd;&#xa;E2Rg4HcA+lAGbreqyXfh0jCgtKI3I5B5zn+Vaa3d/ZajDBdTJPFLwCsezBwT6n0qjr+nzx+HwZnR&#xd;&#xa;mjlV32jA64wMDnr3rYvLGW4vbWdSgSFyzAk5PykcfnQBUSfUL+Ke4gmjjhViqxmPduHrnPv6VStr&#xd;&#xa;64s9Gsgh8kScPMy7hHwOvT+dX47DUbQTQWjW5gkYspdm3Lnt0psem39tYQRRPC7xffV+Vcce1MCz&#xd;&#xa;pN1PM0gkuYLmMAbZIiOfwBNaeaxtM0u4t76W7mEUfmADy4SSB+YFbOOlADqKKKBBRRRQAUUUUAFF&#xd;&#xa;FFABRRRQAUUUUAFFFFABRRRQAVQ1m6ez0yeaMfOFO0jscVfqC5gW5gkhkGVYEUAcz51xHFHPB/ab&#xd;&#xa;zcM24OY29sdKsavqFzpUy3KOZfPQAwM/3D/e+nHp3q7/AGNOQkcmoSvAhz5W1Vz7ZHNTrpkZupJp&#xd;&#xa;mMoZNiqw4VeMj8xQMx9StS2m2bS3U0rPLkuJCRyGPHNO1C6kfUTZn7WYYkJPk7izEHHJHbmtB9FD&#xd;&#xa;WItRcOFV98ZwPk6/n1PWluNLdys0Vy8dwi7Wl2j5x9OlAHPaReXsfhRwWkRUVPLk5XqwGAf89a0J&#xd;&#xa;o7iztLa++2XDyFlDqZCUOSB0zgdaPD+kxz+Fok3sDcKrkkkheRx+la9zpqz2Udt5jKEZSDjrgg/0&#xd;&#xa;oAz4xNqeq3SPcTRxxcKsblec47VTtkuorC9jtpHeQXLBipIYruOcHrmtifSS101za3L20jjD7QCC&#xd;&#xa;PxqOPQ1jtZIhcS73k8zzO+7JP9aBFTSpgt8kbz3kUhX5orosdx/2S3+HpXQA8dKzLfSZFuo57q6e&#xd;&#xa;4aIYjDIF2j8OvQda1MHFAC0tJS0AFFFFABRRRQAUUUUAFFFJQAtFJRQAtFJRQAUUUUAFFFFAC0Ul&#xd;&#xa;FAEN9/x4z/8AXNv5VV8P/wDIv6f/ANe8f/oIqzff8eM//XNv5VW8Pn/in9P/AOveP/0EUAaNFJRQ&#xd;&#xa;AtFJRSAWikopgLRSUUALRSUUALRSUUALRRRQAUUlFAC0lFFABRRRQAUtJRQAtJRRQBkeKv8AkAXP&#xd;&#xa;1T/0IVrjpWR4q/5AFz9U/wDQhWuOlABRRRQAUUUUALRSUUALRSUUALRSUUALRSUtABRRRQAUUlFA&#xd;&#xa;C0UlFAC0UlFAC0UlFABRRRQAUj/cb6UtNf7jfSgDL8Lf8i5Yf9chWtWT4W/5Fyw/65CtagApaSig&#xd;&#xa;BaKSigBaKSigBaKSigBaKSigBaKSigBaa7qilnYKo6knAFLWR4g+dbCAn91cXaxyr/eUqxx+goAv&#xd;&#xa;/brT/n6h/wC/go+3Wn/P1D/38FZ//CM6KBzp8I9MDpTv+EY0X/oHQ/kaAL/260/5+of+/gpPt1p/&#xd;&#xa;z9Q/9/BVH/hGNF/6B0P5Uf8ACMaL/wBA6H8qAL/260/5+of+/gpPt1p/z9Q/9/BVH/hGNF/6B0P5&#xd;&#xa;Uf8ACMaL/wBA6H8qAL/260/5+of+/go+3Wn/AD9Q/wDfwVQ/4RjRf+gdD+VH/CMaL/0DofyoAv8A&#xd;&#xa;260/5+of+/go+3Wn/P1D/wB/BVD/AIRjRf8AoHQ/lR/wjGi/9A6H8qALF7fWhspwLmEkxt/GPSq2&#xd;&#xa;g3tqmg2CtcRKwt4wQXGR8opf+EY0X/oHQ/lSf8Ivov8A0DofyoAv/brT/n6h/wC/gpft1p/z9Q/9&#xd;&#xa;/BVD/hGNF/6B0P5Uf8Ixov8A0DofyoAvfbrT/n6h/wC/go+3Wn/P1D/38FUf+EY0X/oHQ/lR/wAI&#xd;&#xa;xov/AEDofyoAv/brT/n6h/7+Ck+3Wn/P1D/38FUf+EY0X/oHQ/lR/wAIxov/AEDofyoAv/brT/n6&#xd;&#xa;h/7+Cj7daf8AP1D/AN/BVD/hGNF/6B0P5Uf8Ixov/QOh/KgC/wDbrT/n6h/7+Ck+3Wn/AD8w/wDf&#xd;&#xa;wVR/4RjRf+gdD+VB8MaL206H8qANKK4hmz5UqPjrtYHFSVgaPZW9h4h1CC0iWKPyYjtX6vW/QAtJ&#xd;&#xa;RR2oAhe7to3KvcRKw4ILgEU37daf8/UP/fwVhWmkWGoanq0t3axzyLc4Xd2GxavDwxouf+QdD+Ro&#xd;&#xa;Av8A260/5+of+/gpft1p/wA/UP8A38FUP+EY0X/oHQ/lR/wjGi/9A6H8qAL3260/5+of+/gpft1p&#xd;&#xa;/wA/UP8A38FUP+EY0X/oHQ/lR/wjGi/9A6H8qAL3260/5+of+/gpft1p/wA/UP8A38FUP+EY0X/o&#xd;&#xa;HQ/lR/wjGi/9A6H8qAL/ANutP+fqH/v4KT7daf8AP1D/AN/BVH/hGNF/6B0P5Uf8Ixov/QOh/KgC&#xd;&#xa;DxPeWz6DcKlxEzErwHBP3hWqL60x/wAfUP8A38FUP+EX0X/oHQ/lS/8ACMaL/wBA6H8qAL/260/5&#xd;&#xa;+of+/gpPt1p/z9Q/9/BVH/hGNF/6B0P5Uf8ACMaL/wBA6H8qAL3260/5+of+/go+3Wn/AD9Q/wDf&#xd;&#xa;wVR/4RjRf+gdD+VH/CMaL/0DofyoAvfbrT/n6h/7+Cj7daf8/UP/AH8FUf8AhGNF/wCgdD+VH/CM&#xd;&#xa;aL/0DofyoAvfbrT/AJ+of+/gpft1p/z9Q/8AfwVQ/wCEY0X/AKB0P5Uf8Ixov/QOh/KgC99utP8A&#xd;&#xa;n6h/7+Cl+3Wn/P1D/wB/BVD/AIRjRf8AoHQ/lR/wjGi/9A6H8qANCO6t5WCxzxOx6BXBNTVzkml2&#xd;&#xa;OneItKNnbJCXMobaOvyV0Q60AOooooASoZLu3jYq88SsOoZwCKmPSub0nSbHVdPS8v7WO4uJWffI&#xd;&#xa;3VsMQP0A/KgDc+3Wn/P1D/38FH260/5+of8Av4KoDwxov/QOh/I0v/CMaL/0DofyoAv/AG60/wCf&#xd;&#xa;qH/v4KT7daf8/UP/AH8FUf8AhGNF/wCgdD+VH/CMaL/0DofyoAvfbrT/AJ+of+/go+3Wn/P1D/38&#xd;&#xa;FUf+EY0X/oHQ/lR/wjGi/wDQOh/KgC99utP+fqH/AL+Cl+3Wn/P1D/38FUP+EY0X/oHQ/lR/wjGi&#xd;&#xa;/wDQOh/KgC99utP+fqH/AL+Cke+tNjf6TD0/56CqX/CMaL/0Dofyo/4RjRf+gdD+VAEPhi8tk8PW&#xd;&#xa;KvcRKwjGQXAIrU+3Wn/P1D/38FUP+EX0X/oHQ/lS/wDCMaL/ANA6H8qAL3260/5+of8Av4KPt1p/&#xd;&#xa;z9Q/9/BVH/hGNF/6B0P5Uf8ACMaL/wBA6H8qAL3260/5+of+/go+3Wn/AD9Q/wDfwVR/4RjRf+gd&#xd;&#xa;D+VH/CMaL/0DofyoAvfbrT/n6h/7+Cj7daf8/UP/AH8FUf8AhGNF/wCgdD+VH/CMaL/0DofyoAvf&#xd;&#xa;brT/AJ+of+/go+3Wn/P1D/38FUf+EY0X/oHQ/lR/wjGi/wDQOh/KgC/9utP+fqH/AL+CplYMoZSC&#xd;&#xa;pGQQeDWUfDGi4406H8qPDzMbS4iLErBcywxr/dRWIUfgBQBrUUi9KKAFrI17/XaT/wBfy/8AoD1r&#xd;&#xa;1k69/r9J/wCv5f8A0B6ANbFFFLQAlFLRQAlFLRQAlBpazdc+0JZrcWxlZ7ZxKYos5mABGzj1z79O&#xd;&#xa;lAGgCCT7UZrH1i783T4I7SfH22QQpPE/+rJBO4Y+nqKgu9Znk8MLe2UQF5MB5UA+csd3IA78ZPSg&#xd;&#xa;De8xS+zI3AZK55xS54z2rLtZI4NTFksReVbVZPtEjbnYFiNpJGffrUEet3d1LcRWemtI8EzxsXkK&#xd;&#xa;IQDjIbaQT7UAbmaTPtWfZ6kZTPHeRJay26h5F8zcqqc4JbA9DULalfTbm0/T1uYOiytceXu91G05&#xd;&#xa;Hoe9AGokiuu5CGXOMg5p9YvhUudGVnXaxllyAc4PmNxW0OlABRS0UAJRS0UAJRS0lAGRaf8AI0aj&#xd;&#xa;/wBcIf5vWvWRZ/8AI0aj/wBcIf5vWxQAlHaijtQBkaKM32r/APX3/wCyJWvisnRf+P7V/wDr7/8A&#xd;&#xa;ZErWoAKCcUtNb6UAAOaM1zlhYHUZr+Wa/vlKXUkaiO6YAKDxwDVyxvmi+1xzSfaYbRN32leQQM5Q&#xd;&#xa;9csuOec89BQBr5ozWL/a2oiL7SdMj+ybfM8z7VltnXO3b1x2zT7rWzHcWkNtaPcG6iMkeCRjpjdw&#xd;&#xa;cDnk9qANfPtS1mJqFxFbyTajarbYIEaJL5jSH0AwOfQUW97fvMsd3pxgR+Fkjk8znryNoxx3oA0g&#xd;&#xa;QaAwNU7O/N1PdxGLZ9mlEed2d3yg5/Wo/wC1ANal08w8RW4n8wN74xjH9aANDOKN351ixarqNwgn&#xd;&#xa;tdMSW2cbo3NztZh67dvH0qSXVpnmWKxsjNL5ayOkzeUUVs46g88HigDVeRUGWIAzjJOKXNYlzqrL&#xd;&#xa;b7b7TCJFljUo3zIdzAAqxGCR1wOlaF7eC1VURPOuZP8AVxA4Le59B0ye2aALefb6UA5GazbbUZxO&#xd;&#xa;sOo2i2jSHEZEu9WPoWwMH0Hfn0qBtZuHvbqztdPeaWBwu4uVQjaD97BAPPSgDZz7UtZtjqE0t2bW&#xd;&#xa;9tVt7jZ5iqknmArnGc4GDntWnQAlFLRQBj6l/wAjBo/uZv8A0CtfHNZGpf8AIwaP9Zv/AECtegBa&#xd;&#xa;KKKAEPSsfwsP+JDB/vSf+htWwelZHhb/AJAMH+9J/wChtQBr0UUtACUHilpD0oATdx0ozzXPahcS&#xd;&#xa;vq01ve3U1lp6qpSZQYwzEcjzcgD6d/wp9jFZG6Q2GuyXEqnLI935wK9/l3fr2oA3s9falzXOajfa&#xd;&#xa;nF4jtYra18yIxyFV+07RJ93kjHGM++c1Yk1m5guobSXTmNzLCXCxuXCtuwAWC8A9d3agDZaRV27i&#xd;&#xa;BuOBk4yaXNZD304ezGoabGjyXAjj/eiTYdrHcPl68EfjUSa7c3F5d2tppzTSW0mwlpNqEeu7aQD7&#xd;&#xa;UAbgNBbAzWfYX8k9xJaXdsLe5RRIUD71Kk4B3YHcHim3OoT+aYdPtRdvH/rD5uxVPpuwefb3FAGk&#xd;&#xa;Dn8aCcY4rAXxDJFPdQ31kLd7dUPyzbwxc4UdBjkipxql7DLF9vsEt4pXWMOlxvO5jgDG0fnQBsk4&#xd;&#xa;prSKgBYgAnHJxk+lVb69W1jRUQzTy8RQg8uff0XkZOOM1h6rc6lK1gl3p8cEX22HMi3G853DGBtF&#xd;&#xa;AHUUUUtACUUtFACHpWR4dGYL7n/l+n/9DNa56VkeHP8AUX3/AF/T/wDoZoA1xRRRQAVk69/r9J/6&#xd;&#xa;/l/9AetasnXv9dpP/X8v/oD0Aa1LSZFFAC0UlFAC0UlFAC0hooIoA53Q7CSG9eKaOQQ2C+TCzqQJ&#xd;&#xa;MkNv9MjpketSRaayeIRgSeRGTdI235QzAoUB6cAZx71u4PrSkUAZSxSf8JO83lv5Zs1Xfg4zvY4z&#xd;&#xa;60aFFJGl75qMha9mYZGMqW4NamPWjHNAGFcWc0+oa0ixsBcWiRo5GAWw46/iKZY6hLY6dDYCxvGu&#xd;&#xa;YYliDG3by2cDA+bGMZ710GMmjHNAGR4ZSeHRlFzE0U3mSsyMCMZdj37VsA5ANNC/SnDgUALRSUUA&#xd;&#xa;LRSUUALSUUUAZFn/AMjRqP8A1wh/m9bFY9n/AMjRqP8A1wh/m9a9ABR2oo7UAZOi/wDH9q//AF9/&#xd;&#xa;+yJWtWTopxfav/19/wDsiVrZFAC0096WgjP0oA5vT9Ct7mW/mvYZg7XcjL+9dAVJ4OARWvdWajSp&#xd;&#xa;7S2VVLwsij3K45/xq4Bj0o2igDjY7HT1tVtm0vU3uFTZyJxGz4xnOcbc/hitiO2lj1nTmEJVI7N0&#xd;&#xa;baCVU5TjP4Gtor0oxQBl6/bXVxBbGyRJJobhJdrtgYGaS31Se6uEiisrhMHMrTxMgAx2J6nOOPSt&#xd;&#xa;Xb+dGPegDCjnbSdQvjNa3UouZRJG0ELScbQOcdDkGq+ni9n8T3V5LaPFG9qFiLqQCu7IDZ6N6iuk&#xd;&#xa;2nHalx+VAHJyQ2W4mbS9RW6P3vIExiDf7JBxirF3E3l241qyuLlxEB5toHLF/wCLITHHTH410m0U&#xd;&#xa;bTnrQByUltePauLeG4Fh58BghkRvMUhwXJz82O/Jra1GF47231GJGlaFWR4wMkocEkDueBxWpim7&#xd;&#xa;RQBjNI+tXFuBbzwQW8omZpojGSwPygA9R1zU2lQyR6jqjSRsqvcKULAjcNijI9ea09uQQT19KXHF&#xd;&#xa;AGX5Un/CUCXY3l/Yyu/HG7fnH5VrU3FLQAtFJRQBkal/yMGj/Wb/ANArXrI1L/kYNH+s3/oFa9AC&#xd;&#xa;0UUUAIelZHhb/kAwf70n/obVrnpWR4W/5AUH+9J/6G1AGvS0lFAC01ulLQRmgDKvr428zR3djLcQ&#xd;&#xa;HHlmGEy899wA49vxrMmSDUb6ye0065tpoJlcyPA0S7MjcD2PQda6fHFG2gDH1MPb6naagIZZYoY5&#xd;&#xa;EZYULtltuOB9DSQO914ghuxBPHGbNlPmxlcHeODnoeM1sgH2oxQBmazFLLc6WURmCXYZioyFGxhk&#xd;&#xa;+g5qDQYJor/V2kidFkudyFlIDDA5HqK28UYoAykikHiaefy38s2iKGwcE7myM/iKqW9y2kXN6k9r&#xd;&#xa;dSefcNMhghaRdpAGCR34Nb+Oh4zVG90azv5hNcpI0gXaCszoMfRSB3oA5SeG51bU9WV4CrPHC6oM&#xd;&#xa;hjGHDDI6g7R09av29pYS3dv9k0q/EiSq+66MyooB6gscE+grobPT7axj2W0e0erMWP5kk1Z20AY+&#xd;&#xa;qrJb6lY3/lSyxwpIjiJC7ZbbjAH0NUtRu7nUZbBbawuVgju4mkaaFkYfMMEA9R1ye3FdKQTRtoAU&#xd;&#xa;dKWkooAWikooAD0rI8Of6i+/6/p//QzWuelZHhz/AFF7730//oZoA16KKKACsfxBgS6UTwPty/8A&#xd;&#xa;oD1sVi+JoI7n+zIZkDxvfKGU9D8j0AbBPXse1OyKyP8AhF9F4/4l0PHsaX/hGNF/6B0P5UAa2RRk&#xd;&#xa;Vk/8Ixov/QOh/Kj/AIRjRf8AoHQ/lQBrZFGRWT/wjGi/9A6H8qP+EY0X/oHQ/lQBrZFGRWT/AMIx&#xd;&#xa;ov8A0DofyNH/AAjGi/8AQOh/I0Aa2RRkVk/8Ixov/QOh/Kj/AIRjRf8AoHQ/kaANbIoyKyf+EY0X&#xd;&#xa;/oHQ/kaP+EY0X/oHQ/lQBrZFGRWT/wAIxov/AEDofyo/4RjRf+gdD+VAGtkUZFZP/CMaL/0Dofyo&#xd;&#xa;/wCEY0X/AKB0P5UAa2RRkVk/8Ixov/QOh/Kj/hGNF/6B0P5UAa2RRkVk/wDCMaL/ANA6H8qP+EY0&#xd;&#xa;X/oHQ/lQBrZFISOKyv8AhGNF/wCgdD+VH/CMaL/0DofyoAbZ8+KNQI/54RD9XrYrB0eyt7HxFqMN&#xd;&#xa;pCsUfkwnavTq9b1ABR2oo7UAY+jH/iYawB1+1dP+ALWuDzXOWWj2Goanqsl5axzOt1gFh0Gxavf8&#xd;&#xa;Ixov/QOh/KgDWyKMisn/AIRjRf8AoHQ/lR/wjGi/9A6H8qANbIoyKyf+EY0X/oHQ/lR/wjGi/wDQ&#xd;&#xa;Oh/KgDWyKMisn/hGNF/6B0P5Gj/hGNF/6B0P5GgDWyKMisn/AIRjRf8AoHQ/lR/wjGi/9A6H8qAN&#xd;&#xa;bIoyKyf+EY0X/oHQ/kaP+EY0X/oHQ/lQBrZFGRWT/wAIxov/AEDofyo/4RjRf+gdD+VAGtkUZFZP&#xd;&#xa;/CMaL/0Dofyo/wCEY0X/AKB0P5UAa2RRkVk/8Ixov/QOh/Kj/hGNF/6B0P5UAa2RRkVk/wDCMaL/&#xd;&#xa;ANA6H8qP+EY0X/oHQ/lQBrZFGRWT/wAIxov/AEDofyo/4RjRf+gdD+VACaj/AMjBpHPeX/0CtcVz&#xd;&#xa;kmlWOneIdJNnbJCWMu4qOvyV0fegBaKKKAEPSsjwv/yAoc/3pM/99tWuelcv4f0HS7vSIpriyikl&#xd;&#xa;Zn3Mw5PztQB04ORmlyKyf+EY0X/oHQ/lR/wjGi/9A6H8qANbIoyKyf8AhGNF/wCgdD+VH/CMaL/0&#xd;&#xa;DofyNAGtkUZFZP8AwjGi/wDQOh/I0f8ACMaL/wBA6H8jQBrZFGRWT/wjGi/9A6H8jR/wjGi/9A6H&#xd;&#xa;8qANbIoyKyf+EY0X/oHQ/kaP+EY0X/oHQ/kaANbIoyKyf+EY0X/oHQ/lR/wjGi/9A6H8qANbIoyK&#xd;&#xa;yf8AhGNF/wCgdD+VH/CMaL/0DofyNAGtkUZFZP8AwjGi/wDQOh/I0f8ACMaL/wBA6H8qANbIoyKy&#xd;&#xa;f+EY0X/oHQ/lR/wjGi/9A6H8qANbIoyKyf8AhGNF/wCgdD+VH/CMaL/0DofyoA1T0NZPh3/j3vcf&#xd;&#xa;8/s2P++zS/8ACMaL/wBA6H8jTPC8SQ2V3FEoVEvJlVR2Ac0AbI6UUdqKACsjXv8AXaT/ANfy/wDo&#xd;&#xa;D1r1ka//AK7Sv+v5f/QHoA16KYd3HY/yrE/tiaHS7uWRRJNazi3LgYDklRux2+/09qAN7I9aKp3F&#xd;&#xa;yLCw866kDmNVBYLgMxwBgDOMkj86oNJrFtGL2ZklQ8vaBApiB6/vMndt+nOKANdZ43nkhUnfGAWG&#xd;&#xa;04wc456HpUg5rK0/Uje6ldIjBrZYYZIiBgkOGOf0FRCe/wBTkc6dOlrbRnakzR+Z5x6N8uQV2kEe&#xd;&#xa;9AGrFdQzTzQxvmSAgSDB+XIyP0qXNYOgJPHqerLcyiaTzI8uE25+Qdsmr2uXUtlo91cwECWJCykj&#xd;&#xa;IzQBoVDNdQwTQxSvtedisYwTuIGT9OBWNMviGSza6hmihmZdy2ZjVyp/u79wH44qMXp1Kbw9dFPL&#xd;&#xa;86SQlc5x+7bvQB0eaKoan53lJ5F/FZnPLSxh8+3JFUtM1GeW+uNNknjnkiiEguUAA5OMbcnp9aAN&#xd;&#xa;ykZlVSzMAAMknoBWGdXmXTmJVTMt19j8zsW3bd+36nOP1qTWWmi0qKGR1czyR28rBcZVyFbA7cE0&#xd;&#xa;AX01G1fz9ku8QLukKqSMYzwcc9O2alguYbhN8MquOOh6fX0plpbQWdtHb28axRRjAVRxWZBDHZeJ&#xd;&#xa;TBbRLHHdwNNKFAA3KVA4/E0AbdFIBg06gBKKWigBKKWkoAyLP/kaNR/64Q/zetisez/5GjUf+uEP&#xd;&#xa;83rYoASjtRR2oAyNF/4/tX/6+/8A2RK16yNGz9v1fHP+l/l8i1LrF3NYWn2uMgpGw3xkffBOOvbr&#xd;&#xa;np2oA0siis17yVtZjso8Iqw+czHncMkY9uec1FJcXuo3EqadOlvFbtseR4vM3v3XBIxjjnkHPtQB&#xd;&#xa;qySLFG0jkhUBY4GePoKSORJI1dSdrDIyCP51lDUZo7K+jmx9stImYnHDjB2vjoMkHjPFTHUBFo8N&#xd;&#xa;3NzI8aEL2Z2AwPbJP4UAX5pUgheWVtqIpZjjOAOTRFKk0SSxncjqGU46g1galb6w2l3MsuoRqjQs&#xd;&#xa;xh+zglcqeN27nHTOK1tK/wCQVZ+vkJ/6CKALlFYuqXl/Hq9rZWKqRPG5djj91gqN/P3sZ6d6h+1a&#xd;&#xa;tp+rW0F48d3b3QKLIqCLY/JxjJJ4Ht1oA27W6hvLdJ7d98T52tgjODjv9KlyM9ax/DOR4dtsEAjf&#xd;&#xa;g+nzGqdze3mnRm7k1a1vFjIzbpEEL5OODuOOvpQB0lFZWt382l2iXiAMiMFeI9X3EAfN2x16c08X&#xd;&#xa;c0utNaKAkcMQkc9S+7IA9sYoAtT3ttbsFlmUMSF2jlsnpwOaWa8t4JUimlCM4JG4YHHv071k6Jaw&#xd;&#xa;3U9xqkqK120rxbyPuhWKjA7HHX1rSvrC31C1a3ukWSNh3GcH1HvQBaDKwBVgQRkEd6Wsrw9I0uml&#xd;&#xa;W4EMskKf7qsVH6AVqigAopaKAEopaKAMfUv+Rg0f6zf+gVr1kal/yMGj/Wb/ANArXoAWiiigBD0r&#xd;&#xa;J8Lf8gGD/ek/9DatY9DWT4X/AOQDB/vSf+htQBrUVn6hdy2l9ZjIaG5fySuMFTgtuz36Yx79aSwv&#xd;&#xa;ZLu4vGOEhgkMITGSSOS2ffI49qANHIqOeeO3j3ykhcheFJ5JwOlY63GpaijXljPHFbDmKNog5nUc&#xd;&#xa;hskjbnpgjjFLc6z5mkfabbAlSaOGVTyEfcoZffGcZFAG3kVFcXUNqIzM+0SOI14Jyx6Diqeo3skD&#xd;&#xa;RW9tEJLqbO1c7dq8Zb0OMjjvWTqttqUb2DXWoR3Ef22H5Ft/Lx83ruNAHT5oyPWmjryf/rVgi51W&#xd;&#xa;91a+s7eSO2ht2XE5QSclQdu3I9c59sUAb5YAZJqO1uoby2juLd98Ui7lbBGR+NYthdaimrXGm35W&#xd;&#xa;QeV5sVwqhdw4B+UE45J79qs+GOPDliemYh2oA1hzRXM3upXmk2zXkup21+sZGYI4xGz5OOu44xnP&#xd;&#xa;TtWrcXklvqtpDkNDdBlAxgoVBbPvngY4oA0agmvbeCRI5JQHdgoUAk5PTgdveqmmXc99LcysVWFJ&#xd;&#xa;XhWPGTlWILZ9/THFVtGijubq91CWJWuTO8AfHREYgY9OOvrQBqfbbYXLW5lCyrj5WBGc9ME8H8Kn&#xd;&#xa;yKyPENvE2myXbRK09krTwsQCQyjI/MgVoWzGW2hkY/MyBjj6UAT0UUtACUUtFACdqyfDv+ovv+v6&#xd;&#xa;f/0M1rHpWR4c/wBRff8AX9P/AOhmgDXooooAKyde/wBfpP8A1/L/AOgPWtWTr3+u0r/r+X/0B6AN&#xd;&#xa;YgdcVz95pN1L4nt7iIL/AGaUzcRbsK8nzYYr0J+5yfQeldATSe9AFa/s0vrN7eTIVsEEdiCCP1Aq&#xd;&#xa;gRq9wptJI4YUxta6Db/MHf5OMZ+px71seuOtN5/PtQBmaZprWGoXBRQLYwQxRc5OEDDn8xUFsmp6&#xd;&#xa;VF9ltrCK5hV3YSm48vO5i33cHGM4684rbx0x09KMYbPTPWgDK0azvLe8v57xkZrh0ZSvHAUDH4dP&#xd;&#xa;fGaXxRz4bv8Ag/6o1qkc+lNKKybXAIPUHnNAGSLnWZ1EYsIbbcMed9oEmz/a27Rn6ZpkOjzWq6RE&#xd;&#xa;sgkSyZy7Y25BVh/M1tYAxjvS0AY2rWE8t2twLSHUI9gT7NO4Cock7hkEZ7dKr6Jplxb61cXclhBZ&#xd;&#xa;RPCEEcTAjcDyeAK6HvQOtAHOwWX2nxRcTJIfsUIVvJC/u3mJOT6bgQDnGea0dbt3uNP3ICXgdZwi&#xd;&#xa;jJcodwUfXGP6VfCIpOFADHJwMc0uOOO3SgClY6lBdWxlJ8h413SxS/K0P+8DyBwTk4yOaqWTtqOt&#xd;&#xa;tfCGWKG3jMMZdCPN3EHcPbj3zWt5SEuSiEuMMcD5vrSgYAA6DoAOlADlp1NFLQAtFJRketAC0lLS&#xd;&#xa;UAZFn/yNGo/9cIf5vWxWPZ/8jRqP/XCH+b1sUAJR2oo7UAZOi/8AH9q//X3/AOyJWhdwJPayxNGj&#xd;&#xa;hl+6wyM9v1rP0X/j+1f/AK+//ZErVPI4NAGD4W02/soJm1ZvOumfCyu+9tmB8uTyBnJxVh4LzTpp&#xd;&#xa;n0+3S6SdzI0bybCjHqd2DkH0xxitbgUYoAyP7Onltr6aXaby7hMe0H5VGDtXPfBY806fTpZtEtrb&#xd;&#xa;gSweU2D0LJg4z2yRjNag6daAOx5oAw7z+2tQsprb7LDZ7kYb/OEu7IxtxgYznrWrYRNb2FtC4+dI&#xd;&#xa;1RseoGDU6jjHWgg8UAYWqy3EXiSya0tluJPs8o2tJ5YIyvfBqT7JqGo3lrc3ey0S2cssKnzC52kZ&#xd;&#xa;3cY69MHpWwUUtuKgt0BxzSjnjt3oAxrTTLhPDa2Bl+zzgHLIc4+bOO3UfzrMvdKubq1aGLw5YW0h&#xd;&#xa;IKzJKu5cEHjCD+ddYRkelL24oAqaj9m+wyfa/K8rH/LUjbnt14zmqHhexmttKSa8keW7nUM7ygiR&#xd;&#xa;RjhCTzxz+dbDxpIu10Vl64IyKUADoOvagDC065Ol3s+nXEMgiMhkS6ZSEYuS23PQYJx15rQ1TUl0&#xd;&#xa;+AssL3E5BKQxDLP+Ayce+OM1dZVYYZQRnPIzSbFLByAXAOGxyBQBQ0W2a209fMBDzO0xUrjaXJbb&#xd;&#xa;+GcVpCm+v604UALRSZFGRQAtFJS0AY+pf8jBo/1m/wDQK16yNS/5GDR/rN/6BWvQAtFFFACHpWR4&#xd;&#xa;W/5AMH+9J/6G1a56VkeFv+QDB/vSf+htQBLr9pNeaVLHagC6xmJ84KN6g9jjNO0e0ktdKiiuAPPK&#xd;&#xa;5mbu7dyT3PvWgaTgdKAMWOHUdNjWxsreKa3HEcrS7DEvoVwd2OvUZ9qbPohTSZLa2IeaW5S4kZuN&#xd;&#xa;zb1LEDt06VtnPTOPwoxgcGgDN1K2uDe21/aRrNJAjx+UzbAQ2Od3PTb6d6p3cGr6nJaGa3htY4Li&#xd;&#xa;OR4xKJN4ByTnAxj0759q3iOeuKMH1x6+9AC/hxXN29xfxa3q4s7FLlTKmS03l4/dr7Guk7detMVF&#xd;&#xa;UsVUAt1I70AZlpZXcmoNqN46IzQGFbZeQnIP3+/TPQdaba6bdJ4Zi0/zjb3CxBPMQ8qf0rXPtRyc&#xd;&#xa;88/yoA5DU9Hur6yeC38PWFrIxBEyyruABB/uD09a1vFCNLpix27FLx3UQsn+sX5huK45+7nOO2a2&#xd;&#xa;sUwopKswBZehx0oAhsLUWVpFBkMyrh3C48xscsfcnms3T5v7N1C4sJ0cJLKZYp2UqjFyTsz0z0HX&#xd;&#xa;n0raA56U1kVwAyhgCCM9jQBla5dCSFtNiieaW6HkuY1LeQrcb2A6DnIzjODzWpBH5MEcWc7FC5xj&#xd;&#xa;PFOCqpLhQGI5OOeKXnHTI+tADqWkzRQAtFJmloAQ9KyPDn+ovv8Ar+n/APQzWuelZHhz/UX3/X9P&#xd;&#xa;/wChmgDXooooAKyNeGZtK/6/l/8AQHrXrI1//XaT2/05f/QHoA1SRjPGO9ZX9vQyDNla3V6g4LwK&#xd;&#xa;pUH+7yRz0P41q9eD0PasKz07U9It1tdPe1uIF53XBKMD6fKpz9TzQBoWOopeSPE0UtvMg3eVMAG2&#xd;&#xa;/wB7gnjPH4VJZXsd6spiDL5UzxNuA6qcHHtWfpWoTXl3dWeoWQguY1PzJ91484BB69c1S0LRNPkW&#xd;&#xa;7kdJcx3sqr+/kHRuOjc/jQB0xIwckCoYjP8AaJhIIhB8vllWJY8c5GMDnpisLS9Lj1Fr572WWVEv&#xd;&#xa;ZljQSMgT5jnlSCc8demOKn0ksviXWYt7GONYBGuc7fkNAG4M5IoGMcHjpXNaLpMWo2HnX0s0376X&#xd;&#xa;ywJWQRgSMMZUjP45qRbyTSodZWEF4bHYYYmOSMqGPJ5OSSeTQB0Oe3el61kDQLOZfMummnmYZdxM&#xd;&#xa;6bj64UgD8Kd4XYyeHbJmYsSnUnOeTQBq0mfT1rH1KZrHV7a4Ql/tEbQmMngbVZ8j37Vjwa1NBbXS&#xd;&#xa;lAxlijucsx+QysAV+gzxQB0mp3rWMULqgYyTxxcngBmAJq5npWDrlq8OiWNtHO+9J4EEpAJ4YDP1&#xd;&#xa;pb7R7e1sLi+DTPeRRNKJTKwy4BOdudvXtjFAG71zyM+1JkevSsi8uLeXSbZLyOa5kuEVvKgba74A&#xd;&#xa;JIwR0z61S0iUQ64LS3tbu0ge3aRkuTuLMGUAglmPQnvQBuG8jTUI7LD+ZJE0oOOMAgH+dVb7VTBq&#xd;&#xa;KafbQPLdSReYp42AZx8xzkD6A1Qv9LtbrxXCZlc+Zau7bZXXkMoHQ8cdqm8PW0dvcalGgO2G5KIW&#xd;&#xa;YsyjYpxk5OOfWgDTv7ie1iE8cXmxpzKiffxj+EdDz6kcUabexalYxXcKuscoyFcYYfXBqySDkHkH&#xd;&#xa;qKytDGy61SMcIt3hF7AbF4FAGxSUtJQBkWf/ACNGo/8AXCH+b1sVj2f/ACNGo/8AXCH+b1sUAJR2&#xd;&#xa;oo7UAZGjcX+rnHW7/wDZEq5fX9tYIr3UgQMcL7n0qnov/H/q/wD19/8AsiVLq2m/2iLdlnMUlvJv&#xd;&#xa;U7QwJwRgg/WgCFtbcctpOoqo6sY0wPr81WrjU7e2037cWaWEhSDGASwJAB5x61n3V1r1rbvM9nYz&#xd;&#xa;InJSKRyxHsCoH61B4gS21LwvHdpG6jajRKCV2hmXqAcdKAOjDAjI71FP5wC+QEL7hneSOM89Paud&#xd;&#xa;vNHgt9Z02GylmgWYSCT96z7lCjj5iccE8jmrGqadBptkjWQkjL3MIbMztkbx6k+tAG//ADoyMVh6&#xd;&#xa;pDLc+ILKCO5eGNoJC4T+MblyPbr1HIpt3YQaRPZzWPmRvLcpC+6VnDKc5GGJ9OtAG8RyOelCj3ya&#xd;&#xa;w1P9tane2lxuW3s3UbEYqXJGQSRgjHPAOOaSxsodP8TtBbeYsZs9xVpWfnf15JoA3ieaTIxnPFEi&#xd;&#xa;b42XJGRjIrlmupW0xdNDN8ty1oZwfmwi7t31OMfjQB1PNU4r1n1eey2ALHEkgbPJJJGP0rM0u9k1&#xd;&#xa;fULWRx5IhtVm2KSQxkBGD7DHFJLYC+8T3Uckji3+zR70U438vjkcj8DQB0GeP8aDgc54rDFrFpWs&#xd;&#xa;2MNkXSK58wShpGfO1cj7xOPwqDUP7Pu7ySUadqF2R8hlt5CEJHBGN46Yx0oA3L26WysprqYM0cKF&#xd;&#xa;yEAJIFSpIHjWQcKwzzXLSt/aPgm8a5En7nzQisdpXaSFBwecD1z+NWbzS7Ww0C6ubZZVnNqwDec7&#xd;&#xa;duwJxQBpaZqUmqBp4bdorXBCtLwzMDjIAyNvXnr7UljqMkt+1hdQGO6SPzGZOYmGcfKTz39B3q5Z&#xd;&#xa;qq2sSoAo2DgdKztY41HSivDNc7SRxkbG4P40Aa4606mqck06gDH1L/kYNH+s3/oFa9ZGpf8AIwaP&#xd;&#xa;9Zv/AECtegBaKKKAEPQ1k+Fv+QDB/vSf+htWsehrJ8Lf8gGD/ek/9DagCxf6pbWMqxOWkuHGY4E5&#xd;&#xa;eT6A8VWGuBT/AKTp97bRj70sqKEX6kNmnajps0uox6haTILiKPYscijYwznk4JH4VRv9U1TTlSTU&#xd;&#xa;bG2ltGP7w27M5UeuGAHpQBsz3scF3bW8gbdclghHQYGTmrGQfoOK5/XNPtrvXtLM6uwk8xW2yMuQ&#xd;&#xa;FJHQjHNQRaND/wAJDPZxyTLafZkd4vNY7zub+InI6DoaAOiJl89NnlmEg7ySd2eMYHT1qXnI96xP&#xd;&#xa;syWOuadbW5dYfJmJUuzc5TuTmo/sX9oeIdRiuJpDbIkOYVYrkkHByMEfgec80Ab/ABk4PI60ZxWJ&#xd;&#xa;FbppeuWttaF0hnikaVXcvuK7dvLEkY3HpTbK0i1y3F7fmQs7MqRrIyCNQSMfKRnOM8+tAG6D26/S&#xd;&#xa;lPT3rF0CFLa/1S3iLiOKZAiu5YgFFJ5JJ6mtHUbb7ZYTW/mvEXXG9eooAsZ5pTxyTXHXmvztDb6i&#xd;&#xa;IlU29uk/l7jtcyMUwfYdR71uaa5u9Svrpiy+U/2YIDkYX5t31O7H4UAWNLvjewzu6BPLuJIhg9Qr&#xd;&#xa;EZq59Prmub0jSkvheNdyyvF9smKRKxQId5ycqQT+NWtPdNPvtTtvMMdpbJHIN7FtmQxJycntQBs5&#xd;&#xa;GeTVe8vIrJYWlDESSpCNo7scAn2rmdQktY4Lm+tdM1ISgNLFc7yYy3JD4L4255xjp27Vd1+2ivbD&#xd;&#xa;SpbjcztcQqSHK8ORu6Ef/W7UAbOoXkenWM13KGaOJdxC9abp1zNeQm5eExRPgxK338d9w6demCeM&#xd;&#xa;Vl6hYW1g2mw26uEkvVDK8jPu+R+PmJ4rfUALwBgelAGZZasZtRbTLq3eO8ji81iv+rZc4ypznqe4&#xd;&#xa;FatY2t4W70phxIbtVLDqV2vx9PatmgAPSsjw5/qL7/r+n/8AQzWuelZHhz/UX3/X9P8A+hmgDXoo&#xd;&#xa;ooAKyNe/1+k/9fyf+gPWvWTr3+v0n/r+X/0B6ANMgEYIyD1rKbQtnEGo3tvGOFjidQiewyp4rYpa&#xd;&#xa;AKFjpyWjtI0s08xGzzZyC20duAOM5P41C+jr57SwXl3bqzb2iiZQhOck8qTz9a1KKAKtlZR2aSCM&#xd;&#xa;ufNlaZtxHVjk0yDTorfULu9Qt5l3sD8jA2jAq35i7yoYbgMkZ5pc8UAVrCySxtxBE7FQzNluuWYt&#xd;&#xa;/Wozplsz3rSKZBebfNRunAx/SraurM6qwLLjIz92njpQBxR+3OWWex1q4hPDRSyRlXHocKOK6bRr&#xd;&#xa;JtP0u2tHYMYlxuAq/RQBVv7KPULRraZmCMVJKHB4YMP1FR3+l22otbtdKXWB96r2JxjmrkjrGu52&#xd;&#xa;CqO5OKQuoIDMAWPAJ60AQX1ml7HGkhbEcqSjHqpyP5U+5t0urSa3kLBJkZGx1wwwcVOOlFAGfcaV&#xd;&#xa;FNBDGsssT267I5YyA6jAB5IxyAO1R2ejLa3wu3vbu5lEZjHnMpABIPYD0FalIc54oAo3unJeOsiz&#xd;&#xa;TW0y8CWEgNj05B46flWe9hfaZc/aLGZp4QmZopOXmfPXIwM4AH4VvDrnNRmWPyvN8xdgGd+eMUAV&#xd;&#xa;tQe7ESR2SDzZSQHYZWPjOSBz7fWk0myeysgkzB7iQ7ppR1dumfyAFXhyKWgBaSlpKAMiz/5GjUf+&#xd;&#xa;uEP83rYrHs/+Ro1H/rhD/N62KAEo7UUdqAMfRv8Aj+1fnj7X/wC00q7e2Md6qhmeKRDlJUIDp7jO&#xd;&#xa;fp+NVNF/4/tX/wCvv/2RK1qAMYaJJn5tV1Fh3UyJg/8AjvSr72Fs9gLIxD7OFChB0AHT+VW6SgDJ&#xd;&#xa;t9FEV9DdyX15cvDu2rM6kDcMdlFXL6zjvY1jl3ACRZOPVSCP5VZZgqkkgADJJpAwZQQQQehBoArv&#xd;&#xa;ZRvfxXhZ/MjjaNRkYwSCf5Ci7sku/J8xmHkyrKu31Hr+dWGYKrMxAUDJPpQrBlVlIII4PrQBz2uW&#xd;&#xa;8kFysljBf75smVrR1UEjGC24Gl8O2Mg1CW/kt57dmi8pxcEGSQ5B3kjjpx+FdFRQAVSGnQrqz6iG&#xd;&#xa;czPEISMjbtBz6VdpgcPu2ENg4OD0PpQBVstLtrG5uZ4VPnXLl5HPf2+lPSyjTUJbwbvMlRYz6YUk&#xd;&#xa;j+dTo4cnDBscHB6Gn0AVZ7KKe8trpiwktt2wA8fMMHNU5NEBkZoL67tUYljHCyhcnknlT1PNa1FA&#xd;&#xa;FCz0uC1097ImSeJyxfzSCW3HJzgD1qKHRljWRJry7uYZEKGCZlKYPsAD+taQPPSkZ1XG5guTgZPU&#xd;&#xa;+lAGZpY1C1JtbzFwioXjnQEDGeEOe/8ASm2cF3fXq318ixwqv7q2YHdG/TcT0zjP4GtUOrMQrAlT&#xd;&#xa;ggdqkoAQDFLRRQBj6l/yMGj/AFm/9ArXrI1L/kYNH+s3/oFa9AC0UUUAIehrJ8L/APIBg/3pP/Q2&#xd;&#xa;rWPSsjwt/wAgGD/ek/8AQ2oAtX+mreSLKs81vMowJYSAxHpyDx3qqNCViFn1G+uYj96KZ1Kv9cKK&#xd;&#xa;16KAKl9Ypeqm6R4pIyTHLGQGTPBxkHtxUFhpC2V1JctdXNzLIgjLTspIAJPGAPU1pU12VFyzKo9W&#xd;&#xa;NAFeWyjkvoLslvMgRkUD0bH+FENkkV7cXSs3mXAQMGPA256fnVjOeh9+aR3RcbmAyQBnvntQBDJZ&#xd;&#xa;xyX8N2xbzIUZVAPBDYzn8hXN38N1a3skNjb6ssCnKi3kQRjPJwCpPUmusHWloAxPDdibSK5mMDW6&#xd;&#xa;3LhxC/3kwMHP1xn8a2vxpaD0oAqWtjFafaPKMhM8hkYkjgkAYHHTimaVpdtpNitpaKQgOST1Y+p9&#xd;&#xa;+Ktq6uu9GDKeQwPBFKjrIoZWDKehBzQBXsbOOySVYy2JJXlOfVjk0w6ZbtPdyvuf7WipKrfdKgEY&#xd;&#xa;/ImrtFAGJN4dSWF4BqN/HbsuzyUdAgXptHy9McVfmsYZ7NbZ9wWMDy3H3lYdGHuKuGkBP/16AMm4&#xd;&#xa;0aQ6fJFFezyXAbfDLOQTG3TIwB6mrOmyXflPFfIPNhwPNQYWXjOQDz7H3Bq0XXzPLLDdjO3uRTg6&#xd;&#xa;sWVWBK8EA9KAMa0tb271CO+v9qW6pmG0wcxvnhj/ALWCR+NbdJnuOlLQAHpWR4c/1F9/1/T/APoZ&#xd;&#xa;rXPSsjw5/qL7/r+n/wDQzQBr0UUUAFZGvf67Sf8Ar+X/ANAetesjX/8AXaT/ANfyf+gPQBrE47Vn&#xd;&#xa;rrMH2GW5lVozC/lyxnkq5xhcjr94cjjmr5G7PcVzN9a3P/CRLYRwTHTbw/aLhwhOJBkj5u3KJx/j&#xd;&#xa;QB0QuAtoJ7hfI+UMysQdvtx1rPXWXVhJPYzRWbH5LgkHcD907R8wz7jjvVjV7JtQ0+S3RgrEqwYj&#xd;&#xa;OSrBsfjj9apy6jcXUbWkenXC3DqVcyIVjXscORhvb1oAtW91bzapdRQwr5sccbNMAPnDbsDP4H86&#xd;&#xa;jn1VvOaHT7OS9eP/AFgR1RUz05bAPfpnGOaraJYy2Oo3MTB2RLa3jSQqQHKhgcfpx2qPTrs6RbGz&#xd;&#xa;uLO9eRJHYtDbs6EMxYYYdeCPxoAfoMss2p6u88DW7mSMGJmDbf3Y7jj3rczgewrG0X7S+panPc2z&#xd;&#xa;2/nPGUVskEBAODgc+voeK0b/AO0/YZvsO37Tt/d7umaAKD61dQKZb3Spbe3TmSYyowQeuFJJ/CtG&#xd;&#xa;7vIbODzpmwvYAEk/QDmuO1SNZ9NuIoI/EMkpXCJIspUn3z2rodXjkSaxu1ieVLV2Z1RSzkFSowo5&#xd;&#xa;PJoAz9fv72fSnWTSpYYzJH+9aVCAN69gc1fkv2/te2trnTWUPIywTs6MMhScgDkZA/WqWs302pac&#xd;&#xa;8Fpp14cuhczRMm0B1PAI+bp07dau6oM6xo2Of3z57H/VtQBfsb1b0TlUK+TM8Jz3KnBNRtqcKXN5&#xd;&#xa;FICi2kSyvJ1GDnPHXjbWbbXLaTLdw3FpeSGS5eZWghaRdrHI5HSix+03Op6rPLp5Ec0EYijl4Eo+&#xd;&#xa;fg5HBORkc4zQBYGsXZAlOkzC2+8ZhKh+T+9tB3dOcYzUHiG/uof7NezglkSWdSWRwm7g/IQSDz15&#xd;&#xa;44qhtCki3j1tLnpGhMnkq/YHtsz+GK19ViuXs7CZkMj28yTTKgySApzgd+TQBTuLi81O7g06SC40&#xd;&#xa;0k+czrOMug4IBQ8csPyrcW0txbC28mLyMY8vYNv5VgyalEusW+oTxzWtsI2ti9zGY/mYhh17YU81&#xd;&#xa;0RI4OeooAytKD2OpXOnSTTT7l+0RvLIWKofl28+4J/GtisSwmjv9envrZ1kgjgFuWB/jDbuPwIra&#xd;&#xa;7c0AOpKWkoAyLP8A5GjUf+uEP83rYrHs/wDkaNR/64Q/zetigBKO1FHagDJ0X/j/ANX/AOvv/wBk&#xd;&#xa;Srd9frYxrLKh8ndh5B/BnoSOp5wOPWqei/8AH9rH/X3/AOyJVzUrVLuxmikDEMucL1JByP1AoAWW&#xd;&#xa;+VL+KzRC8jrvbHGxefm9+RjioLrU3Scw2Vo95InMgR1UJ6ctgHvwOlZnhY394Zb/AFWCSG7H7lQ0&#xd;&#xa;ZQFOD0PuTzVhHfRprkSW9xPFcTNOrwRFyC3VSo6Y457/AIUAXP7Rhl065lliOYUbzoGGSMDkehHb&#xd;&#xa;PQ0+G6gj06O5KLDAYw4UD7oIyBgf0rOe2nuLfUr4xyI1za+XHCVO7ADYOOoJ3dMcYpbu1nl8O2aI&#xd;&#xa;jF4fJkdCDu+QgkY7njpQBHqmpX0mmXW3SJvJaF8SmZOhU/NjOenOOtaulf8AIKsz/wBME/8AQRWX&#xd;&#xa;f6pNeadcQWWm3jyPEwPnRNEAMEHBI5PovetTTFZNMtVcMrLCgIYYIOBxQA+9uJreEPb2rXLk/cVw&#xd;&#xa;px65PFQ2GpNcTtbXNs9rchd4iZg2Uzjdlcjr261U13zxJCT9r+xgHf8AYwxk38bfu84xnP4VR0WJ&#xd;&#xa;v7fllij1IRG12mS9D/e35wC3tQBqT6rM0zJYWMl6qcO6SKgB9PmIz9RxVPQp51sdSmFoxn+2SHyA&#xd;&#xa;65zxxnOKbpl62k2MdhLY3ryx5BMduzIcknhgMd6s+HUuFhvWuoGt5JLuR9h5GDjocDI96AIk1yG1&#xd;&#xa;0q5vWsWhKXHlyRArkuSATkcd62bmcW9rLOwJEaFyB3wM4rmJLKbUNI1W3twDJ/aDMAT1AZSf5Vcv&#xd;&#xa;tVe60+4gtdNvmmkiZQJYWReh7kdfbvQBem1YJbWrxQNLPdKGigDAFuATyeBgHvTYtTuGEiTadLDc&#xd;&#xa;BC0URdW8zH+0Dgdup71UuIiNF08TWlwfLiUPJbkiaI7QOABnnoenFGjed9sxb/bxa7D5v27fndxt&#xd;&#xa;27u3XOPagCLw/qGoyxlZdPndTcSBpWnQ7BvPGM546celT6TAuoyvqs8kkkcr7oIHYlYtvGdp4zkE&#xd;&#xa;5HrSaVM+nu9hNbXJd53cSLEzR4ZiR83Qdad4dmhhtv7LklT7Xbs2+PcM8ndkeoww5oANah+wypqs&#xd;&#xa;MkiLGwaeJGKiYfd5HTPI5PpW4DWJ4kljls/7NR1+13ZAijJ9DnJ9uDzW2KAClpKWgDH1L/kYNH+s&#xd;&#xa;3/oFa9ZGpf8AIwaP9Zv/AECtegBaKKKAEPSsjwt/yAYP96T/ANDatc9KyPC3/IBg/wB6T/0NqALt&#xd;&#xa;xfLbXkMEqFVn+VJM5Bfrtx16AnPTii2vkuriZIkJjhO1pOg391x14GOenNVPEcUh043NtG0l1bN5&#xd;&#xa;kIVdx3dOnfgmk0GCQaWss6NHcXWZZ1YYIcjnjt0FADpdXk81vstjJc26HEkyuqhSOuAeWwOcjOe1&#xd;&#xa;Ov8AULT+zVuGRbmFnjG3HcsAMg9CMg81Ts7iXR7SPTns7mZ4lCRyRxsyOOxJAwv05xVefSp7bRJ0&#xd;&#xa;CtLNcXqXDIi52ZdSRx1AweaANy8vYbKIPJyzHCKoJLHsOP59BWHql7fTvp6z6ZJbIb2H940yN/F0&#xd;&#xa;wDmrupiSDVLO+8qWWGGORHESF2y23GAPoaqajeTajJYrbaddiOO7iaV5YmQrz1AI5HXJ7fjQB0Yx&#xd;&#xa;2qnfXd3byKttp0l2CMlllRce3zEVcHNc7qfmi/mF3/aflceR9g34xgZ3be+c0Aa1nqUdxFKZV+zy&#xd;&#xa;wHE0bkHyyeRyODwQePWqj6reSoWttJnmhYfLJ5qJkeuGII/Gsi10+a60zWooI7pfPdfKN4GDNhVy&#xd;&#xa;SW57GtZtaaYGO2029aVh8olhaNc+hYj5aAK+jXNxb+F9Oa3sWuiYgGVXVNv/AH0RVux1W3aDTEgt&#xd;&#xa;jGl6G8tBgBAFJ/pR4fjeLw9ZxToY3EIDK64IPuDWVpySJpGg3oikljtUYyLGpZvmUqMAdeTQB0Op&#xd;&#xa;Xy6famd0LjeqYB/vMF/rVe61ORLlrezs3vJYwDKFdU2A/d+9jOcHp6VmavfT6lYiG0067wJY2kMs&#xd;&#xa;TR4AdTwCPm6fh1qXWFjF2Wlt9QTcvE1gXLSeocKO3bJ7mgDRt7+WaCfdZyR3MK5MBYZOc4w33ece&#xd;&#xa;vHesPS9a1CDRTcz6bPNHH5jNN56dAzdic8Yx+FaehGfE24XP2X5fJ+1bvNzzuzu59MVnKZ7fRJ9G&#xd;&#xa;a0uWuJBLGrpCxjy5Yg7sYwNwye3NAGpoliYLdbieV57mUFvMkYsVUnIUZ6Dpx7VBrsAs8arC7x+Q&#xd;&#xa;weZI2KiZcY5HQnpyewxVvSL6C8sE8mQMYx5bjPKkcHP5VV8TSRyac2nLIn2q8/dxRkjJ75x6cUAb&#xd;&#xa;XpS00U6gAPSsjw5/qL7/AK/p/wD0M1rnpWR4c/1F9/1/T/8AoZoA16KKKACsnXv9fpP/AF/L/wCg&#xd;&#xa;PWtWRr3+u0n/AK/k/wDQHoA16KM0UAFFFFABgelGB6UUUAFFFFABgUUUUANkQMhXkZGOODVC00iG&#xd;&#xa;1uBMZbi4dfu/aJS+w9yueh7VomkxzmgBcA0YHpRRQAYHpRgelFFAENza293F5d1BFNGDkLIgYZ9c&#xd;&#xa;GoxaL9gNt5s2Nu3zN58z8+tWqTB/+vQBFbWlvaxlLaCKFSdxEaBQT6nHepqBRQAtJRRQBkWf/I0a&#xd;&#xa;j/1wh/m9bFY9n/yNGo/9e8P83rXoAKO1FHagDJ0X/j+1f/r7/wDaaVrVk6Lxfav/ANff/siVrZFA&#xd;&#xa;BiiiigAoxRRQAYFGKKKACjFFFABiqt9Zi9jCNPcRAHOYJChP5VapMGgCGztYrOERRL7ljyzn1J7n&#xd;&#xa;3qfA9KQDFLQAYHpRgUUUAGB6VTl021e4FysKx3AYMZYwFZsdmI5I9quUEZoAqDT7b7Wbp41lnzlX&#xd;&#xa;kG4x8YwpPQfT1NW6TBpaAClpKKAMjUv+Rg0f6zf+gVr1kal/yMGj/Wb/ANArXzQAtFFFACHpWR4W&#xd;&#xa;/wCQDB/vSf8AobVrnpWR4WP/ABIoP96T/wBDagDX60YoooAKKKKADA9KMUUUAFGBRRQAYHpRgDJw&#xd;&#xa;BRQaAM+80tbycStc3cWF27IZmVfqQPrV2CKOCJYoUVI1GFVRgAfSnbeaUUAGBRgelFFABgelGB6U&#xd;&#xa;UUAVINPtra5aW3iEW5SGSMbUYk5yQOCfegafbNeNdSRrLNkFGkG7y+MfLnp+FWsUAUALRRRQAHpW&#xd;&#xa;R4c/1F9/1/T/APoZrXPSsjw6cQX3/X9P/wChmgDXooFFABWRr2BLpWen25f/AEB616juIIrmFoZk&#xd;&#xa;DxuMMp6GgBcjnnHPNPyKyR4Y0UY/4l0PHsaP+EY0X/oHQ/kaANbIoyKyf+EY0X/oHQ/kaP8AhGNF&#xd;&#xa;/wCgdD+RoA1sijIrJ/4RjRf+gdD+Ro/4RjRf+gdD+RoA1sijIrJ/4RjRf+gdD+Ro/wCEY0X/AKB0&#xd;&#xa;P5GgDWyKMisn/hGNF/6B0P5Gj/hGNF/6B0P5GgDWyKMiud1bQ9EstOmnOnRZACrtHOSQB39TWd4b&#xd;&#xa;8PaekMlnqVrFJexOxbdk5TOAw9jQB2eRRkVk/wDCMaL/ANA6H8qP+EY0X/oHQ/kaANbIoyKyf+EY&#xd;&#xa;0X/oHQ/kaP8AhGNF/wCgdD+RoA1sijIrJ/4RjRf+gdD+Ro/4RjRf+gdD+RoA1sijIrJ/4RjRf+gd&#xd;&#xa;D+Ro/wCEY0X/AKB0P5GgDWyKQkcVlf8ACMaL/wBA6H8jR/wjGi/9A6H8jQA20OfE+oEf88Ih+r1s&#xd;&#xa;VTsdKsdOLmztkhLgBtvfHT+dXKACjtRRQBj6Mf8AT9YA6/aun/AFrXB5rOudA0q6neeeyiklc5Zi&#xd;&#xa;OSaj/wCEY0X/AKB0P5GgDWyKMisn/hGNF/6B0P5Gj/hGNF/6B0P5GgDWyKMisn/hGNF/6B0P5Gj/&#xd;&#xa;AIRjRf8AoHQ/kaANbIoyKyf+EY0X/oHQ/kaP+EY0X/oHQ/kaANbIoyKyf+EY0X/oHQ/kaP8AhGNF&#xd;&#xa;/wCgdD+RoA1sijIrJ/4RjRf+gdD+Ro/4RjRf+gdD+RoA1sijIrJ/4RjRf+gdD+Ro/wCEY0X/AKB0&#xd;&#xa;P5GgDWyKMisn/hGNF/6B0P5Gj/hGNF/6B0P5GgDWyKMisn/hGNF/6B0P5Gj/AIRjRf8AoHQ/kaAN&#xd;&#xa;bIoyKyf+EY0X/oHQ/kaP+EY0X/oHQ/kaANbIoyKyf+EY0X/oHQ/kaP8AhGNF/wCgdD+RoATUv+Rg&#xd;&#xa;0jB7y5/74rWHWqFpoemWU6z21lFFKmdrKORkYNaA60ALRRRQAh4FY/hfjQoBj+KTg9fvtWxWddaD&#xd;&#xa;pd5O81xZRSSv95mHJoA0BS5FZP8AwjGi/wDQOh/I0f8ACMaL/wBA6H8jQBrZFGRWT/wjGi/9A6H8&#xd;&#xa;jR/wjGi/9A6H8jQBrZFGRWT/AMIxov8A0DofyNH/AAjGi/8AQOh/I0Aa2RRkVk/8Ixov/QOh/I0f&#xd;&#xa;8Ixov/QOh/I0Aa2RRkVk/wDCMaL/ANA6H8jR/wAIxov/AEDofyNAGtkUZFZP/CMaL/0DofyNH/CM&#xd;&#xa;aL/0DofyNAGtkUZFZP8AwjGi/wDQOh/I0f8ACMaL/wBA6H8jQBrZFGRWT/wjGi/9A6H8jR/wjGi/&#xd;&#xa;9A6H8jQBrZFGRWT/AMIxov8A0DofyNH/AAjGi/8AQOh/I0Aa2RRkVk/8Ixov/QOh/I0f8Ixov/QO&#xd;&#xa;h/I0AapIxWR4d5hvve+nI/77NO/4RjRf+gdD+RrTiiSCFIolCxooVVHQAdBQA9elFA6UUALSUtFA&#xd;&#xa;CUUtFACUUtFACUUtFACUUtFACUUtM/iyaAMrVP8ATNTs7AHegJmuYzwCmDtJ9fnA6VHdRiz8RWlz&#xd;&#xa;GSXvcwyBugCqWBHvke9R3lrqsepXGpW01lgQ+WEkjcnaCW7HryagSHWtZsLW5eWwiDqkqNHG4kjB&#xd;&#xa;wcA7uDjg/U0AdNiigdBS0AJRS0UAJRS0UAJRS0UAJRS0UAJRS0UAFFFFACUUtFACUUtFACUUtFAC&#xd;&#xa;UUtFACUUtFACUUtFACUUtFACUUtFACUUtFACUUtFACUUtFACUUtFABRRRQAlFLRQAlFLRQAlFLRQ&#xd;&#xa;AlFLRQAlFLRQAlFLRQAlFLRQAlFLRQAlFLRQAlFLRQAlFLRQAlFLRQAlFLRQAUUUUAFFFFABRRRQ&#xd;&#xa;AUUUUAFFFFABSYFLRQBXvQBY3GB/yzb+VVvD4/4p/T/+veP/ANBFWr7/AI8Z/wDrm38qq+H/APkX&#xd;&#xa;9P8A+vaP/wBBFAGhS0lLQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAF&#xd;&#xa;FFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUU&#xd;&#xa;UUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAEF9/&#xd;&#xa;x4z/APXNv5VV8P8A/Iv6f/17R/8AoIq1ff8AHlP/ANc2/lVTw+f+JBp+P+feP/0EUAaNLSUUALRS&#xd;&#xa;UUALRSUUALRSUUALRSUUALRSUUALRSUUALRSUUALRSUUALRSUUALRSUUALRSUUALRSUZoAWik570&#xd;&#xa;tABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUU&#xd;&#xa;AFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQBBff8eU//AFzb+Vc3&#xd;&#xa;pGjXsukWUqa1dojQIRGAuF+UdK6S+/48Z/8Arm38qq+H/wDkX9P/AOvaP/0EUAUf7Av/APoP3n/f&#xd;&#xa;K0f2Bf8A/QfvP++VrepaAMD+wL//AKD95/3ytH9gX/8A0H7z/vla36KAMD+wL/8A6D95/wB8rR/Y&#xd;&#xa;F/8A9B+8/wC+VrfooAwP7Av/APoP3n/fK0f2Bf8A/QfvP++VrfooAwP7Av8A/oP3n/fK0f2Bf/8A&#xd;&#xa;QfvP++VrfooAwP7Av/8AoP3n/fK0f2Bf/wDQfvP++VrfooAwP7Av/wDoP3n/AHytH9gX/wD0H7z/&#xd;&#xa;AL5Wt+igDA/sC/8A+g/ef98rR/YF/wD9B+8/75Wt+igDA/sC/wD+g/ef98rR/YF//wBB+8/75Wt+&#xd;&#xa;igDA/sC//wCg/ef98rR/YF//ANB+8/75Wt+igDA/sC//AOg/ef8AfK0f2Bf/APQfvP8Avla36KAM&#xd;&#xa;D+wL/wD6D95/3ytH9gX/AP0H7z/vla36KAMD+wL/AP6D95/3ytJ/YOof9DBe/wDfK10FJQBzkNve&#xd;&#xa;afrthHJqdxdRTiTKOBjhc10dZOpf8jBpH/bb/wBArWoAKWkpaACiiigAooooAKKKKACiiigAoooo&#xd;&#xa;AKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigA&#xd;&#xa;ooooAKKKKACkpaQ9KADNGaY7qil2OEAJJPaqUWsWM0whWU7icAlGAP4kYoA0M0Zqqt/bNcPAJR5q&#xd;&#xa;DJBBH6njvWZqeuxQpbyWshIlYjPltyMfSkBrXx/0Gf8A65t/Kqvh8j/hH9O/69o//QRTdS1K1isn&#xd;&#xa;DyENJGdoCsT09McVDol7bx+HbOR5QEihRWOD8pwB/OmBs5ozWdFrNjNcCFJiWbhcxsA34kYp91qd&#xd;&#xa;payiKVyGIyQqM2PyFAF0mlzWHpWphrWa4uZcxqxwxz03HAxV601O1vZGjgclwM7WRlyPxAoAvZ5p&#xd;&#xa;aaKdQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFACZzRniqN1qlnaPsllO4dQqMxH5A0&#xd;&#xa;6TUrSO3W4ab90xwCFP8AhQBczRmqU+o28TGPzf3mzeAqk8fhVXSdXS6sGnnfBX72VIHb2pAGpH/i&#xd;&#xa;oNI/7bf+gVr5rnZtRt7zX9L8lmYJ52SysvVfcCtGfWbG3d0klO9DhgsbHH5CmBobqM1VN/bC0F0Z&#xd;&#xa;QIT0bB/l1rObVkudWtIraRthDFsqy55HYgUAbmaBWZJrVhHKY2lPBwSI2wD35xitJDlQQcg9DQAt&#xd;&#xa;LSUtABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAU&#xd;&#xa;UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUh6UtJQBm65HLJpUyxE5CseOp+U8CsFlWewt4DqUbEkAQ&#xd;&#xa;xxAuh55wGz/+uuuZcjAHtUQtIVbckKK/94LQBz2uodRnEOnKTPGMyujYOP7px9R+VO1C5tpNOsp4&#xd;&#xa;gscKMQy5wE47+nWujWJFZmVFVm6kDrSG3hKFDChQnJXaMUh3OW1EkajPMbuOGN7fEbsoKt1+UHNV&#xd;&#xa;NLhUeG5HDuymNAUMZVQdy9D3+tdbf28LWEoaJCFjbGR04qvoMaN4e08FVINvHkY6/KKYXKWoRrHZ&#xd;&#xa;aVtUDbLEB7crTreeG11S++2uieZgoZCBkc8AnrW2YkbG5FIGMAjpTZLeKVgZIkbHQkZoC5y1sLeT&#xd;&#xa;SpjIGji87crKPu/Ofm+neremXJGqJCJ4b5TGcTIo3IMjgkE/5Fb/AJEewpsTaeo2jFNjto4mzFGi&#xd;&#xa;euFAzQBKO1OpuDmnUCCiiigAooooAKKKKACiiigAooooAKKKKACiiigBKKKKAORgWSDV743F7HaM&#xd;&#xa;xBDSxghhjoCSKlha3g0SYS7roTSfIuzbuP8Asjn07V0kltFKcyxI/pkdKXyE4GxcD7o29KAOd0RG&#xd;&#xa;spZre8BM8qko7HJZf7oqsT5vh0xQODLG/wC8UcsBx1WusMSEhiq7h0OOlIIIgSRGgz1woGaQ7nH3&#xd;&#xa;WLnUdOSPUEuMb+IVAZBjoQCa19OjQ3upsVGSxGSO3NOvYI4fEOlGONF3ednaMZ+SthY1UkhAC3U+&#xd;&#xa;tMLnLICNKt5GGYY7py/HAG/vVq4ubW51yya2ZJcIctGQe68ZFb/lJtK7F2nqMcGmLawocpEin1Ax&#xd;&#xa;QFzl55I7cXb213GBuYvaTqCWOT0BPfnt3rqLRzJaxsUMZI+6e1DWluzbmgjLepFSqCBgnNAhaWkp&#xd;&#xa;aACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoooo&#xd;&#xa;AKKKKACiiigAopKpanqSabFE7wzTebII1WEAnJBPcj0oAvUVjjW5T/zB9T+nlp/8VR/bkv8A0BtT&#xd;&#xa;/wC/af8AxVAGxRWP/bkv/QG1P/v2n/xVH9uS/wDQG1P/AL9p/wDFUAbFFY/9uS/9AbU/+/af/FUf&#xd;&#xa;25L/ANAbU/8Av2n/AMVQBsUVj/25L/0BtT/79p/8VR/bkv8A0BtT/wC/af8AxVAGxRWP/bkv/QG1&#xd;&#xa;P/v2n/xVH9uS/wDQG1P/AL9p/wDFUAaN9/x4z/8AXNv5VV8P/wDIv6f/ANe0f/oIqpc6xNLbyRro&#xd;&#xa;2ogupUZRPT/eqHTNSuLLS7W2k0fUi8MSoxWNMEgAf3qAOhpax/7bl/6A2pf9+0/+Ko/tyX/oDan/&#xd;&#xa;AN+0/wDiqANiisf+3Jf+gNqf/ftP/iqP7cl/6A2p/wDftP8A4qgDYorH/tyX/oDan/37T/4qj+3J&#xd;&#xa;f+gNqf8A37T/AOKoA2KKx/7cl/6A2p/9+0/+Ko/tyX/oDan/AN+0/wDiqANiisf+3Jf+gNqf/ftP&#xd;&#xa;/iqP7cl/6A2p/wDftP8A4qgDYorN0/V1v7iaD7NcW8kSqxWZQDzn0J9K0aAFooooAKKKQ8CgBaKx&#xd;&#xa;R4hWSeeKDTr6fyJDG7RopGR9Wpw1yX/oDakf+2af/FUAbFFY/wDbkv8A0BtT/wC/af8AxVH9uS/9&#xd;&#xa;AbU/+/af/FUAbFFY/wDbkv8A0BtT/wC/af8AxVH9uS/9AbU/+/af/FUAbFFY/wDbkv8A0BtT/wC/&#xd;&#xa;af8AxVH9uS/9AbU/+/af/FUAbFJWR/bkv/QG1P8A79p/8VR/bkv/AEBtS/79p/8AFUALqX/IwaR/&#xd;&#xa;22/9ArWrmrrULifVbG5XSNQ2W3mbhsTJ3LgfxVe/tuX/AKA2pf8AftP/AIqgDXpax/7cl/6A2p/9&#xd;&#xa;+0/+Ko/tyX/oDan/AN+0/wDiqANiisf+3Jf+gNqf/ftP/iqP7cl/6A2p/wDftP8A4qgDYorH/tyX&#xd;&#xa;/oDan/37T/4qj+3Jf+gNqf8A37T/AOKoA2KKx/7cl/6A2p/9+0/+Ko/tyX/oDan/AN+0/wDiqANi&#xd;&#xa;isWTX2ijaSTSNSVVBJYxpgf+PVp2s4uraKdAQkqBwD1GRmgCeiiigAooooAKKKKACiiigAooooAK&#xd;&#xa;KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooASsjXxmbSQf+f5P/QHrXrJ17/X6T/1&#xd;&#xa;/L/6A9AGrz3paKWgBKOPWg9KZJIscbO5wqjJOM8d6AH0cVDbzx3FvFPA2+OVA6N0yCMjiktrqG7h&#xd;&#xa;Etu2+PcVDYI5BIPX3BoAn49aKrw3MU0kiQtuMRw2Acc89e/4VMD1FADuKKQ8UUAKaTgfzNGfWqMe&#xd;&#xa;oI+sS6eEO6KMSls8HJxQBe4FLTfbjml6cUALRUEMkkke6WIxMSRtJB4zwePXrUoOB1oAdxQcDqaQ&#xd;&#xa;HI6mquo3i2FhNdspYQqWIHegC3RimxHdGp6ZGeafQAmKQinUlAGRaf8AI0ajjP8AqIf5vWvWRZ/8&#xd;&#xa;jRqP/XCH+b1sUAFFFFABSHpS0lAGD4ZGbnWeB/x/yfyFbwHFYPhj/j41n/r/AH/kK3qADFGKWigB&#xd;&#xa;MUYpaKAE4opCe5/MVjjxLpTAlZ5nB/u28h/XbQBs8UmOagtbqG8g823fcvuCD+IPIqYn8QKAF7+4&#xd;&#xa;pabnml9+KAFopM0UALRSA0ooAMUYpaKAExRilooAp6qP+JXecf8ALF/5Gm6N/wAgax/690/9BFO1&#xd;&#xa;X/kFXf8A1xf+RpNG/wCQNY/9e8f/AKCKALtFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQ&#xd;&#xa;AUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAlZOvf6/Sf8Ar+X/ANAetasnXv8AX6T/ANfy/wDoD0Aa&#xd;&#xa;1LSUtACHpTXClSrAFSMEHpTj0pMc5oA5ppzY2mp6aHZZhxbMhwAZdwjRf7uCAB0A9qbZSy6JdX32&#xd;&#xa;xXWI26y28QbIYomZcAcA5PJOMk55rZuNLjn1G3ujsAjzvTZnzDxsJP8As8469e1LqWnLfrFlgrRu&#xd;&#xa;Du25ymRuT6MBg+tAGXFcPo2g2iAhpbycxxvjhWlZmUn1xnmn3VvLo9sdRW7uZjF806SSs6svcKD0&#xd;&#xa;OcYrWubKC6txBLEpRfuYGDGcYDL6EdiOlUo9KupGCX999ptV6Q+Vt3em45O4Y7Ec0ALqE0lxeQ6b&#xd;&#xa;FI0RlQyySKcHYCAVBHQ5I59qihD6VqNtaiaaeC7JUedIXZXALE5PbAAx61fvrH7SFkik8i5j/wBX&#xd;&#xa;Kq9PYjjK+2ewqG00+ZJhcX84u7hOEIj2Kg9lycHk8+nFAFYq+sXlwnnzwW9q/lYhkKMz4BJyO2CO&#xd;&#xa;PaqFhZ/ZvFOoQRTzOzWi4eWQuwJPqa05NMvI7iaTT75bZZ38yRXg8zL4xkHIxwBTdP0V7PU5r+S6&#xd;&#xa;eeWaMI25ehzk45OB7dqAMybVJV06C28yUzWzv5su8/vPIwX9/m//AF1fsr9tW1G2khZ4o4bcSyIT&#xd;&#xa;w/mD5R742n86tx6RCt9cXLpG6TKAIjGMITneR7tkZ45xzmm6XpCafNdTCRnadvlB6RoCdqgdgM0A&#xd;&#xa;UbW4uG8KXk3myGYLc7XLncMM+MHtjApbHSZruwgmvr+8M7opbybhkTGOOM9cYyfWrkOkmLR59O84&#xd;&#xa;kSiXL7em8k9M89avW8PkW0UOdwjQJnHXAxQBhwapcDRIMP8A6RPcNbRyMMhSGYAn14WofEGjJDod&#xd;&#xa;5N9sv2KRk7XuWKn8M1orom3T47dZ8SxTtPFLsyFYsxGVzzjd61BeaLqGoWklreatujcceXBs59/m&#xd;&#xa;5HtQBuRHMS/QU+moCqAHtTqACkpaSgDIs/8AkaNR/wCuEP8AN62Kx7P/AJGjUf8ArhD/ADetigAo&#xd;&#xa;oooAKSlpKAMHwx/x8az/ANf7/wAhW9WD4Y/4+NZ/6/3/AJCt6gBaKKKACiiigBjZwccHtXL+H73U&#xd;&#xa;IdHgWDSZZ0G7DrNGM/MfU11B3ViWmj6rY2y29tq0SwoTtBtMkZOf73vQBHpUssdzqaXMJtbmc+ek&#xd;&#xa;RYMQm0LnK5HUVFomnXF9plrdXt/dmVo1KiKdlG3tu55PqavWOiywXNzd3l61zczp5YYJsVF44C5P&#xd;&#xa;cZq7p1mbHT7e0Db/ACUCbsYzgdcUAZOsTad9sxPf38ThQCts0u38doxmorS+ubrQrlrR3kWK4MSu&#xd;&#xa;2Q/kgjJ55zgn3q++l3sU0raffpbpK5kdXt/MJY9TncPyos9Int7K4hkvGM80xm86NPLwxxxgHpx6&#xd;&#xa;80AZ1pLZG6iFjqd8Z93S6MpQjuPmAGcZxUurSKNQcajcXdvb4H2c2pcbuPmzsz3x1q1/ZN9cOi6h&#xd;&#xa;qKTwKwfYlvsJIORzuPcD61YvLK9e4aSyvvs+8fOrx+YOOmORj+tAEeiMjRyeTdPcW+R5fm7vMU99&#xd;&#xa;27nr0rVHSqGnWElq8008wnuZtvmSBNgIXgYGT2q+OKAFooooAKKKKAKeq/8AIKu/+uL/AMjSaN/y&#xd;&#xa;BrH/AK94/wD0EUuq/wDIKu/+uL/yNJo3/IGsf+veP/0EUAXaKKKACiiigAooooAKKKKACiiigAoo&#xd;&#xa;ooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigBKyde/1+k/9fy/+gPWtWJ4nMyjTDbhG&#xd;&#xa;lF6u0OSATsf0oA26Kx9/iH/njpnv++k/+Jp2/wAQ/wDPDTP+/wBJ/wDE0Aa1FZO/xD/zw0z/AL/S&#xd;&#xa;f/E0b/EP/PDTP+/0n/xNAGtRWTv8Q/8APDTP+/0n/wATSb/EP/PDTP8Av9J/8TQBr0Vkb/EP/PDT&#xd;&#xa;P+/0n/xNG/xD/wA8NM/7/Sf/ABNAGvRWTv8AEP8Azw0z/v8ASf8AxNG/xD/zw0z/AL/Sf/E0Aa1F&#xd;&#xa;ZO/xD/zw0z/v9J/8TRv8Q/8APDTP+/0n/wATQBrUVk7/ABD/AM8NM/7/AEn/AMTRv8Q/88NM/wC/&#xd;&#xa;0n/xNAGtRWRv8Q/88NM/7/Sf/E0u/wAQ/wDPDTP+/wBJ/wDE0Aa1FZO/xD/zw0z/AL/Sf/E0b/EP&#xd;&#xa;/PDTP+/0n/xNAGtRWTv8Q/8APDTP+/0n/wATRv8AEP8Azw0z/v8ASf8AxNAGtRWTv8Q/88NM/wC/&#xd;&#xa;0n/xNJv8Q/8APDTP+/0n/wATQAWf/I0aj/1wh/m9a9YGjm7PiHUTerCkvkxDELEjGX9QK36AFooo&#xd;&#xa;oAKSlpD0oAwvDH/HxrP/AF/v/IVu1yejtqi3mriwSzeP7c5JmkZT29Aa1d/iE9INM/7/AEn/AMTQ&#xd;&#xa;Br0Vkb/EP/PDTP8Av9J/8TS7/EP/ADw0z/v9J/8AE0Aa1FZO/wAQ/wDPDTP+/wBJ/wDE0b/EP/PD&#xd;&#xa;TP8Av9J/8TQBrUVk7/EP/PDTP+/0n/xNG/xD/wA8NM/7/Sf/ABNAGtRWTv8AEP8Azw0z/v8ASf8A&#xd;&#xa;xNG/xD/zw0z/AL/Sf/E0Aa1FZO/xD/zw0z/v9J/8TSb/ABD/AM8NM/7/AEn/AMTQBr0Vkb/EP/PD&#xd;&#xa;TP8Av9J/8TRv8Q/88NM/7/Sf/E0Aa9FZO/xD/wA8NM/7/Sf/ABNG/wAQ/wDPDTP+/wBJ/wDE0Aa1&#xd;&#xa;FZG/xD/zw0z/AL/Sf/E0u/xD/wA8NM/7/Sf/ABNAGtRWTv8AEP8Azw0z/v8ASf8AxNG/xD/zw0z/&#xd;&#xa;AL/Sf/E0AXNV/wCQVd/9cX/kabo3/IGsf+veP/0EVl6k+u/2dciSHTtnlNu2yvnGO3y1p6N/yBrH&#xd;&#xa;n/l3j/8AQRQBeooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiig&#xd;&#xa;AooooAKKKKAErI1/PnaVj/n+X/0B616yNf8A9dpPTH25M5/3HoA1cdQOMmnU059uvel9aAFopo54&#xd;&#xa;o5HXn6UAOoqCM3H2mXzPK8gBfL25355zu7emMe9SjpgUAOorPsr2S41LULdgoS3ZFQgc8qCc/iav&#xd;&#xa;EHH8iaAHUU0ZBwf/AK9Ub29lgv7CGNVK3DsrZHIwhb+lAGhRSccc0g69KAHUUnrUN1OtrazXDglI&#xd;&#xa;ULsF64AycUAT0VmWd3fX0E1wkccMUiZtElBD5wfv4JGM4xjtS6ZqX22SaGSJ4p7YgSqwABJGcrye&#xd;&#xa;PrQBpUUgPPNOoASilooASg0tJQBkWn/I0aj0/wBRD/N616yLP/kaNR/64Q/zetigAooooAKQ9KWk&#xd;&#xa;oAwPDIzca0QP+X9x+grfHtWD4Y/4+NZ/6/3/AJCt0jnPNAC0U3k/UdhRn86AHUVFKZPJfyNpl2nZ&#xd;&#xa;v+7n3x2zRCJPKj84p5m0b9nTd7e1AEtFUtXu3stLubmMKWijLLnpnHerMTF4kZhjcoJoAkopoPHT&#xd;&#xa;86UnHU4oAWiqGmXkt59r8xUHk3LxDaDyoxjPvzV05x160AOopo9f8ml+vb0oAWiszUtRe2njs7aJ&#xd;&#xa;pLu4RjESMxrjAy/OccjpTdSv7nTcXMsIlskjzKIhmQN6jJA24/GgDVoqONw6q46MM1LQAlFLRQBT&#xd;&#xa;1X/kFXn/AFxf/wBBNN0Yf8Sax/694/8A0EU7Vf8AkFXf/XF/5Gk0b/kDWP8A17x/+gigC7RRRQAU&#xd;&#xa;UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAJWRr/wDr&#xd;&#xa;tJ/6/l/9AetesjXv9dpP/X8v/oD0AapUEEEcHrXLTyyWgudFiYpdSzBrOEf88MruwegGFk4Jz+Yr&#xd;&#xa;qzWbPo1tPrlvqzvKJ4EMaqCNuPm68Z/iPegBNUkbTdHJs0A8oJGi4J2gsF7egP6VUl0ewtbZry3Y&#xd;&#xa;xXIXd9pVhulPXk9Du74654rcZVYFWGQRgg9DWTD4ft47rzXuLmaIElbWRw0Kem1McY7elAFfQZ5b&#xd;&#xa;nU7qeZQkklpbOygYAJDEjBosrK3123N7qSCcs7qsTfci2sV+UdRnaCck/hWrHZxxX092pYyTqiMM&#xd;&#xa;jAC5xj8+az7jw8k87Sw6hqForHPlW03loD3wMdzyfqaAI/D8Fta6pq0NmqJCskYUJ0HyDI/PNWfF&#xd;&#xa;A/4pu/x/zyP4VNp+l2+myTtb7v35UuDjGQMZGB1PU+5puu2st5ol3bQJvlkQhVyBk/jQBSuPDOlT&#xd;&#xa;WbfaVLSMvzXTkb/rnGM/hVSxnkuYfDU0zmSRnkyx7/u3q7B4bRXUzanqVzGPvQzz7429ipHIrQfT&#xd;&#xa;rdntSieUtqS0YjAUDII6Y9DQBR1w211Ilm2nf2jMo83ydwXaucbsnA6g8daoaEzrrl5YvaGzthAG&#xd;&#xa;FsXVhknGeCetbOpaVHqLK4uLi1lXgy2z7HYehOOR7VDpmhxabdy3S3V1czyIEJnkDHGfXFAGW0sg&#xd;&#xa;J0TcRObr5Ie32XdyM9Mbe2c1oa7CkFhYxQoFjju4FUD+EBxU1tYn+2brUJ4QrMBFFnBZQM5YHtnI&#xd;&#xa;49qt6hai7sZYBgOyny3I+4+Plb6g85oAsN0rJk/5Gu2GTj7JJ+e5KmsWv4bZ4ryHzZYE+WRGGJzj&#xd;&#xa;pgnIPQZPemabZ3SXk95fMjSy4Earn9yuPu8k+gzjjNAGr3paaOtOoAKKKKACkpaSgDIs/wDkaNR/&#xd;&#xa;64Q/zetisez/AORo1H/rhD/N62KACiiigApKWkoAwfDH/HxrP/X+/wDIVa1+1eWy8+2TN3B80TZw&#xd;&#xa;V5G7r7Zqr4Y/4+NZ/wCv9/5CtyRBIjIejAg4oAxdLuI9X1SS/hbzrSNAkDkYw/O/g89NtOuY11HV&#xd;&#xa;5LC9GbWONXVOgkY5zn1xgEY6d6taNpEGi2X2W1aRkLl8yEE5P0A9KfqOnxahCEaSWF1PyzQnbInr&#xd;&#xa;hscZ70AY96iaeLqws1xavZyyMnaJgOMemcknNTy3EsWh6VHE2w3JhgZx95Qy8ke/HersGkwwafLa&#xd;&#xa;mSaZplKyTysGlYHI5bHOAeKkk06GXT1tCzhY0Co4I3oQMBgccN70AYniDQtIttEvJxaQpKImKueu&#xd;&#xa;7H866O2/494v90fyrFPhaCSOSK51DULlHXaEnmDhD/eAI4PvW2qLHFtBO0cfSgDCvrKK+8VLFMze&#xd;&#xa;V9i3MgIw/wA/Q+3f8Kgm0yz0jxBYSac32d7hzFJCjDay7WPI69QPyq1qOjzX+vJP59zbQLbbPMt5&#xd;&#xa;QhLbs4/KrljolrZlXYvdXCnK3Fzh5B7bsZx/jQBBoBVF1MngLey8/lWRfRwTwz6hbaAZNwaWO781&#xd;&#xa;BnjIfBOffGM101pYxWgnVNzCeVpW3YPJ6j6Vlz+GIpWkVdS1GGGT/lhFPtjQf3VXGAPagAuhNLod&#xd;&#xa;jfJzcwrHI0meQpxvP/fOak0iVNT1C41KNvNtsKltIRjHHzjB5HIFWru1aLRjZW0bS5iEK5YAgY25&#xd;&#xa;JOBwOal020SxsILZFRRGgB2DAJxycfWgCjp3/Iw6sfXycn/gJrY4rKvrS6TUEv7DYSEKzQ9DN0xz&#xd;&#xa;kDIwQCemadqq6hcxG1slEHmx/NcM33D6AA5z79KAI/Cx/wCJFbZJ6vn/AL7atmq9tAtvCkMaqqqM&#xd;&#xa;YUYHuasUAFFFFAFPVf8AkFXf/XF/5Gk0b/kDWP8A17x/+gil1X/kFXf/AFxf+RpNG/5A1j/17x/+&#xd;&#xa;gigC7RRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUU&#xd;&#xa;UUAJWRr/ABNpX/X8v/oD1r1ka9/rtJ/6/l/9AegDW7/0pD97k8Yob8M9jiuUs5kvLZZdc1S4sbvp&#xd;&#xa;5BlNrhf90n5uc/N+HagDrB7/AKUA55rL0tI0jley1E30GMANL5hD+m/JwMY4/HvWdot/rEguQ1gs&#xd;&#xa;qi6kDM119z5uVHy9B2oA6Q+4z71Gk0Uk0kSSI0seN6AjK56ZrJi1m8upJ47HTDKbeZ4nMk2xTg4B&#xd;&#xa;B2nJ4OR2qfTr1J9X1C3+xpDNAIi8gIJk3LnB4HTp/hQBp57nj3pawrfWr2/iLWemCQI7Ixkm2DIY&#xd;&#xa;gYO35ulXbPU1ljuBdqlrLbY84GQFUyMj5uO2KANDPA4orH/tHVJf3ltpSvCeUMk/ltj3UrxV3Sb0&#xd;&#xa;6jpsF4Y/L81c7c5xz60AW/SiqT34i1P7LKgSMxb1lZsBjk5Ue4Az9KgttaglguXdo0MJO0GQZdM4&#xd;&#xa;Vh7Nxg9896ANCWRIlHmyKoZgoLHGSeAPrTxwMHNYOuXTvodldSQSI5ngkaEAl1O4HbjqT2qZ9U1G&#xd;&#xa;OIzvpiraqN7O02HCdSSm3Ocds0AbP50nfj8arTXExslnsoVnZwGVHfZwffBqvZajNJe/Zb61W2nZ&#xd;&#xa;DIoSXzAVBAOTgYPIoA0ehxTZZY4EMksiIijLM7AAD1zWDfXepxeJ4ora2E0X2ZiqG42B+Vyx4PI6&#xd;&#xa;fjTbWOfW9QlnvN0EVqfIezWUukjcNk9AeGxjHagDfaaNGjVpFDSHCAtgsevA+lSZ/wA5qrfWMd5A&#xd;&#xa;Y2LRuPuSIcMh9VPUfhVTw/JL9mms5pWnezl8lpnbLScBsnPT72Op6UAa9JS0lAGRZ/8AI0aj/wBc&#xd;&#xa;If5vWxWPZ/8AI0aj/wBcIf5vWxQAUUUUAFJS0lAGD4Y/4+NZ/wCv9/5Ct01heGP+PjWf+v8Af+Qr&#xd;&#xa;R1O+bT0SZog1uDiWTdymcAYGOck+1AFzoaT/ADzVQX27U/scce4om+Vi2NgOduPXOD9Kbe37wyC3&#xd;&#xa;tIftV0Rny920KPVjg7c84z1xQBcd1jQu5CooyWPQD1oV1dA6MGVhkEdCOxrLOqYtblL62WOeOJnM&#xd;&#xa;Bfcsi4/hOPmHQHjjNWUvoIdLguXQRI6LsiXkkkcKo7n0AoAtSypDG8kjKiIMszcACnDkZB4Pcd65&#xd;&#xa;rXrzVX0W9EmmRxxGFssLrJAx1xtrorcYt4+c/KOv0oAk9scUfrVW+lu4kU2dstw+eVeXZx9cGoLD&#xd;&#xa;U3nu3s7qAQXSp5hRX3jbnA5wKANE0wSp5rReYhkUZZcjIB74qhdajcGdodOtVumj/wBYzS7FU/3c&#xd;&#xa;4PPqO3FZltc6gdav5DYILkW0W2H7RkEbm53bePyoA6KOWOZN8Tq65Kkq2RkcEU7pzWJb6sI9GW6F&#xd;&#xa;kkDNc+S8SsMBjJtJzjnnnpWnqN39h064utnmeTGX25xnA9aALBpfasqTVpGhtFtrUS3F1F5oiMm0&#xd;&#xa;BcDPzY9x2qazvrmWXyLyxa2kI3AoxkTHu2AAfagC8CDyKa80cbKskiqXOEDNjcfQe9c3ZajrAvdT&#xd;&#xa;xp6zLHMPlN1gRjYOB8pz6/jVrQEGpr/bM7OxnO6K3diy2+Pl+XPfgnIA6kUAbIniM5g81DMF3eXu&#xd;&#xa;G7HrinnOODj61navpiXkLSRTPa3CjieL5WIHOCQQSParGmXf2/Tre62bPNQNt3btv40AGq/8gm7/&#xd;&#xa;AOuL/wAjSaN/yBrH/r3j/wDQRS6r/wAgm7/64v8AyNJo3/IGsf8Ar3j/APQRQBdooooAKKKKACii&#xd;&#xa;igAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAErI1/8A12k/9fyf&#xd;&#xa;+gPWvWTr3+u0n/r+X/0B6ANTkj/Gufn1dVkKX2h3k80fDSQW3mRn/dY4yK6LFGB6UAc74ftU/tC6&#xd;&#xa;vrWznsreUbWhnDKxlzksFJIAwQOPQ8UW95Jo9zcWsthfTma5eYSW8O5AHbI546d66IADtRgUAZOh&#xd;&#xa;RSRR3vmxum+9mcBhgkFuD9Kh0y3mTxNrUzxOkcog2OQcNhCDitzAowKAMnw9FJDpSJNGyP5sp2su&#xd;&#xa;CMyNg4+lU7jTri7bX4UXYbnyxG7ghT8gB5xzzXRYFFAHPp4gmnIgg0jUY5iMK9xblIwfcgnA/CrP&#xd;&#xa;hTnw5Y567P6mlPhrTP8AnlN/4Ey//FVqJGkaBUUKo4AHSgDK8Q20klvFcwo8k0D/ACxqpO7cNh6c&#xd;&#xa;8BifwrJ1HQJYWtobMmUzJHbu7ggIseGyceu3H411tGBnpQBla/FJLbWyxRtIVu4WIUEkAOMnj0qx&#xd;&#xa;q8bSaNeRorM7W7gKBkk7TV3FGKAOd1GKZNNsPNguJrVIwJ4IFPmMcDbjGDwc55H41U0SKI+IVltd&#xd;&#xa;N1C0hW3cMbtX+Ziy4wWJ9663AoxQBi6oZLHU4NSFvNcRrC0BjgQu+WIOceny/qKq6RqMUOqTW9xH&#xd;&#xa;Jby37faoklAUheE2kE/eypOBniukxUFzZW12hWeJXyMZ6MB7Ecj8KAFubiK0gee4dY40GWYkAfrW&#xd;&#xa;b4dPnw3F+nEN7MZowfvBdoXn8VPrWlPaQXBjM0e/yzlQScdMcjv+NSoiRqFRQqjoFGAKAHUlLSUA&#xd;&#xa;ZFn/AMjRqP8A1wh/m9bFY9n/AMjRqP8A1wh/m9bFABRRRQAUlLSUAYPhj/j41n/r/f8AkK1dRto7&#xd;&#xa;uylilTepXO3JHI5HT3ArK8Mf8fGs/wDX+/8AIVvYoA5/wkl5NZyXmqRSJfSNsYyJsJQfd+XAHc84&#xd;&#xa;qxfCTT76TU44ZbhZEWOSKJS0gwTgqO/3ua2MUYFAHOzRzapBcai1tNCBaywwwSIRIxI53L25HGOo&#xd;&#xa;NSXVtN/YmmyLG7PaGKaSMKS7BV5VR/e9uK3sCjAoA5XVdVudU0y6tbXSb+ORom3faICoIx0GM5b0&#xd;&#xa;FdLCCIEDDkKAQKlwKAAKAMHxArC4je4trq7stuBDaBt4k5+Y7SDtxx169qoeHIB/wkU9xb2F9aW5&#xd;&#xa;tgn+lK2d271Yn+ddbgUYFAHOJevotxdxSaffXPnztOr2sO9QG7EnHPFSaSbqfXbu7uLd4Elt4/LD&#xd;&#xa;KRxluDn+IZ5ArfwKq32nWuoKguUdgnK7ZGT/ANBIoAwbe2kufD0qxfMyX0kpA5J2zFiAO54puqar&#xd;&#xa;danpd3bWmk6hFI0TAm4gKgjHIXGct6Cumggjt4ViiQKijAFSYoA5u7j8vRbD7Vp9xcxJCiskAYTK&#xd;&#xa;20dgRx1zz6UuhpK10ZLWC6s9PCkSQ3gbzHfsw3Z+XHHX8K6PAowKAOdmnl0m+vg1ld3IvXEiNaxb&#xd;&#xa;wg2hcMeMHipfC7pbWZ0h5E+12XyyAEfNn5sr3I+YDJA5rdwKgeyt3nSYxASodwZSQc4xzjr+NAFf&#xd;&#xa;WNQt9OsWluHwD8qrkAsT2GaNJtpLDSrW1lKtJFGEZk5B+lTSWFrLc/aJIg8m3Z8xJGM56dPxxmrO&#xd;&#xa;BQBU1X/kE3f/AFxf+RpNG/5A1j/17x/+gil1X/kFXf8A1xf+RpNG/wCQNY/9e8f/AKCKALtFFFAB&#xd;&#xa;RRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAlZOvf67&#xd;&#xa;Sv8Ar+X/ANAetas7WrWaeO1lgTzHtpxN5YIBfCsMAngdaANEmiscalqnH/Ehm/8AAiLj/wAepRqe&#xd;&#xa;q/8AQCm/8CIv/iqANeisj+09V/6AU3/gRF/8VR/aeq/9AKb/AMCIv/iqANeisj+09V/6AU3/AIER&#xd;&#xa;f/FUf2nqv/QCm/8AAiL/AOKoA16M1kf2nqv/AEApv/AiL/4qj+09V/6AU3/gRF/8VQBr5orI/tPV&#xd;&#xa;f+gFN/4ERf8AxVH9p6r/ANAKb/wIi/8AiqANeisj+09V/wCgFN/4ERf/ABVH9p6r/wBAKb/wIi/+&#xd;&#xa;KoA16KyP7T1X/oBTf+BEX/xVH9p6r/0Apv8AwIi/+KoA16KyP7T1X/oBTf8AgRF/8VR/aeq/9AKb&#xd;&#xa;/wACIv8A4qgDXorI/tPVf+gFN/4ERf8AxVH9p6r/ANAKb/wIi/8AiqANeisj+09V/wCgFN/4ERf/&#xd;&#xa;ABVH9p6r/wBAKb/wIi/+KoA16KyP7T1X/oBTf+BEX/xVH9paof8AmBTf+BEX/wAVQAWf/I0aj/1w&#xd;&#xa;h/m9a9Y2lR3kmr3l5dWZtlkjjRQzqxO3d6E+tbNAC0UUUAFJS0h6UAYPhj/j41n/AK/3/kK3gRWB&#xd;&#xa;BDf6TdXnk2LXqXU7TBo5FTYD2O48nirH9p6p20KbH/XxF/8AFUAa9FZH9p6r/wBAKb/wIi/+Ko/t&#xd;&#xa;PVf+gFN/4ERf/FUAa9FZH9p6r/0Apv8AwIi/+Ko/tPVf+gFN/wCBEX/xVAGvRWR/aeq/9AKb/wAC&#xd;&#xa;Iv8A4qj+09V/6AU3/gRF/wDFUAa9FZH9p6r/ANAKb/wIi/8AiqP7T1X/AKAU3/gRF/8AFUAa9FZH&#xd;&#xa;9p6r/wBAKb/wIi/+Ko/tPVf+gFN/4ERf/FUAa9FZH9p6r/0Apv8AwIi/+Ko/tPVf+gFN/wCBEX/x&#xd;&#xa;VAGvRWR/aeq/9AKb/wACIv8A4qj+09V/6AU3/gRF/wDFUAa9FZH9p6r/ANAKb/wIi/8AiqP7T1X/&#xd;&#xa;AKAU3/gRF/8AFUAa9FZH9p6r/wBAKb/wIi/+Ko/tPVf+gFN/4ERf/FUAXNW/5BV3/wBcX/kaTRv+&#xd;&#xa;QNY/9e8f/oIrOu7zVbi0mhGiSqZEKZNxHgZGP71aemQvBptrDINrxxKrDPQgAUAW6KKKACiiigAo&#xd;&#xa;oooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigApOtLRQA0KB60t&#xd;&#xa;LRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUlLRQAmKKWigAooooAKSlooA&#xd;&#xa;TFFLRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAmKKWigAooooAKKKKACiii&#xd;&#xa;gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//Z</binary>
<binary id="image21.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCALTAnUBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKK5bRLa61aG6nm1e/jK3UkarE6hQAeOqmtH+w5f8AoN6p/wB/E/8AiKP7Dl/6Deqf9/E/&#xd;&#xa;+Io/sOX/AKDeqf8AfxP/AIij+w5f+g3qn/fxP/iKP7Dl/wCg3qn/AH8T/wCIo/sOX/oN6p/38T/4&#xd;&#xa;ij+w5f8AoN6p/wB/E/8AiKP7Dl/6Deqf9/E/+Io/sOX/AKDeqf8AfxP/AIij+w5f+g3qn/fxP/iK&#xd;&#xa;P7Dl/wCg3qn/AH8T/wCIo/sOX/oN6p/38T/4ij+w5f8AoN6p/wB/E/8AiKP7Dl/6Deqf9/E/+Io/&#xd;&#xa;sOX/AKDeqf8AfxP/AIij+w5f+g3qn/fxP/iKP7Dl/wCg3qn/AH8T/wCIo/sOX/oN6p/38T/4ij+w&#xd;&#xa;5f8AoN6p/wB/E/8AiKP7Dl/6Deqf9/E/+Io/sOX/AKDeqf8AfxP/AIij+w5f+g3qn/fxP/iKP7Dl&#xd;&#xa;/wCg3qn/AH8T/wCIo/sOX/oN6p/38T/4ij+w5f8AoN6p/wB/E/8AiKP7Dl/6Deqf9/E/+Io/sOX/&#xd;&#xa;AKDeqf8AfxP/AIij+w5f+g3qn/fxP/iKP7Dl/wCg3qn/AH8T/wCIo/sOX/oN6p/38T/4iqunfabT&#xd;&#xa;xZLYPfXNzB9iEoE7AkMXx2A7V0VFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFc/4&#xd;&#xa;O/5B95/1+zfzre3qHCbhuIyBnnFOoooooqJ7iFJBG80aueilgCfwqWiiiiiiiiiiiiiiiiiiiiis&#xd;&#xa;CP8A5H6X/sGj/wBGVv0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVz/g7/kH3n/X&#xd;&#xa;7N/OtKS4gXWobcwAztA7rLgZVQVBGevOR+VVp9cK6hcWFtZS3NzBtJRWCgqRnOTxxkDGc81NZam8&#xd;&#xa;9z9mu7R7OdlLojur71GATlcgYJHX1rJ03VdVN3qQ/sq4nC3OApuI/wB18i/Ly348etaU+rT/AGiS&#xd;&#xa;Kx06W88o7ZSsiJsfGdvzEZ4IORxzRLrkMOkTX7Rv/o7bJou6PkArnocZ7U6DU7q4ctHpcxtypaOY&#xd;&#xa;yIN/GR8pORn3HHesTSXmvLy4mutB+0yLeMonleJmgAI+UEnPy+34VsTarewO7S6PMtvGSWm86MgK&#xd;&#xa;OrYznpzjrV6S9t47MXbyYgZQ4bByQRkYHU/SqcGqXBnRLvTZrWOQ7UkLq4LHoMKSR9TxUY1m6nHm&#xd;&#xa;WGkzXVsfuTLKiB/XhiCOc9RWjZ3UN7apc27bo3HBwR3wevvTNSgNxp88QmmgJXiSFtrrjng1Q8Mh&#xd;&#xa;4vDlvPNcT3LyxiZmmfcQSOgPpUdtr9xf20dxp+kz3ETqCW8xE2t3X5iM/UcVd/te3/s37Zzjd5ez&#xd;&#xa;HPmZ27P++uM9PwqODVLnz0S90ua0SQhFkMiyAsegwpJH16VnW+p6muuapGmmXFwiGMKnnoAgweRk&#xd;&#xa;/wAXXj8auNr267uLO2spp7uBgDECBkbQSdx+XjOMZzVm11Jpb1LSa1eCZoDMVZg20btuMj86lvL1&#xd;&#xa;bSe0iZCxuZfLBH8J2k5/SqA155p7iCy0+a5lt5WjkUOqAY6HLYBzzwOeKjTxDPcXMlvaaVPPLCB5&#xd;&#xa;wEiKI27rkkAke2a0bTVLa6spblWKrAWWYEH92yjLD3x7VT/tq7KeeNImNpjeJ/Ojxs67tuc9OcYz&#xd;&#xa;T7vXYLeW0jjiknN5EZINgxuPGBz0zuHJwB3oi1e4WaNL/TZbOOVxGkjSI4LnouFJPPr0qnd6jqEP&#xd;&#xa;ikwwWM88QtciNZkVW+YfPgn8PWty1klmt0knga3kPWNmDFefUcVjR/8AI/S/9g0f+jK36KKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK5/wAHf8g+8/6/Zv51amRj4rtH2naLOUE44zuS&#xd;&#xa;jTUYa/rLFSFZocEjg/JROjHxXaPtO0WkoJxxnclUv7Ri0LUb9b2Oc/apvOjMUZcbdoXnHQ5U1QvR&#xd;&#xa;b2Oq3j302pxfaZBLELN3CldoHO3vkH9KsXFsE8IXXkQzBZpVlXzHLu4Lqdx4yCfSuqrE0lbhLTV/&#xd;&#xa;JXExu5zFvGAT2/DNc9fXdm1pcRS3Otm7MbKyK8nlmTHIA6bc/pW7c2t3NoekG1hWSW3aGUxu+zIV&#xd;&#xa;eRnt1qa08QxX9ylvaW07SZ/eeahQKvcgkcn271ztv9j0yEWd9c6zHcRE71tpJPLGTn5ccdCK63Rr&#xd;&#xa;cWmlQQCIxBQfkMm8jJJ64Gak1K4S00+eaQOVVeQi7jzx0/Gs3w3MJvC0CBJFaKHymDqVO4LzVnw2&#xd;&#xa;rJ4d09WUqwgQEEYI4rPsYyvh65EtqZQLqZipO0geYTuXjqByPcCqumXUc2oQrpdxqkkm4GUXruU8&#xd;&#xa;v+LG7jd0xVy4vo9E1q9uLuOZo7wR+UYoy/3Vwc46dataKD/aGruVYK9ypXIxkeWtQ6pcLpetpqVw&#xd;&#xa;kjW7W3kDykLtu3bug7YHWqk2qf2tqelPa20ot47k7pJFKkNsbjaR0wetaWgIynU9ykZv5CMjqMDm&#xd;&#xa;jQEZTqe5SM38hGR1GF5qhoVtLJo+tQhCry3dwEDDGcjArJiawS3Swln1trhUELRiWQRlsYIz025/&#xd;&#xa;St5IGh1vSEERRYrKRCM7gv3OM9+lT+IEZ107apbF/CTgdBk81Bqk66XrcepXCSNbtbG3HlIXbdu3&#xd;&#xa;dB2wOtatldx31pHcwhwkmcB12nrjpWRH/wAj9L/2DR/6Mrfooooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooooooooorn/AAd/yD7z/r9m/nXQUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVgR/wDI/S/9&#xd;&#xa;g0f+jK36KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK5/wd/yD7z/AK/Zv510FFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFYEf/I/S/8AYNH/AKMrfooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooooooorkPDei2V/bXk1wspf7ZKPkndBjPoCBWv/AMIzpf8AzzuP/AqX/wCKo/4RnS/+&#xd;&#xa;edx/4FS//FUf8Izpf/PO4/8AAqX/AOKo/wCEZ0v/AJ53H/gVL/8AFUf8Izpf/PO4/wDAqX/4qj/h&#xd;&#xa;GdL/AOedx/4FS/8AxVH/AAjOl/8APO4/8Cpf/iqP+EZ0v/nncf8AgVL/APFUf8Izpf8AzzuP/AqX&#xd;&#xa;/wCKo/4RnS/+edx/4FS//FUf8Izpf/PO4/8AAqX/AOKo/wCEZ0v/AJ53H/gVL/8AFUf8Izpf/PO4&#xd;&#xa;/wDAqX/4qj/hGdL/AOedx/4FS/8AxVH/AAjOl/8APO4/8Cpf/iqP+EZ0v/nncf8AgVL/APFUf8Iz&#xd;&#xa;pf8AzzuP/AqX/wCKo/4RnS/+edx/4FS//FUf8Izpf/PO4/8AAqX/AOKo/wCEZ0v/AJ53H/gVL/8A&#xd;&#xa;FUf8Izpf/PO4/wDAqX/4qj/hGdL/AOedx/4FS/8AxVH/AAjOl/8APO4/8Cpf/iqP+EZ0v/nncf8A&#xd;&#xa;gVL/APFUf8Izpf8AzzuP/AqX/wCKo/4RnS/+edx/4FS//FUf8Izpf/PO4/8AAqX/AOKo/wCEZ0v/&#xd;&#xa;AJ53H/gVL/8AFUf8Izpf/PO4/wDAqX/4qj/hGdL/AOedx/4FS/8AxVZ+nWMFh43mhtg4Q6eG+eRn&#xd;&#xa;OfM9WJPauooooooooooooooooooooooooooooooooooooooooooooooorn/B3/IPvP8Ar9m/nXQU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUVgR/8j9L/wBg0f8Aoyt+iiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiuf8Hf8g+8/6/Zv51rrextfPZsGSVV3LuHDjjJX6ZANFpex3jS+SGKRtt8z&#xd;&#xa;Hyue+PoeDVW51qKG4eCC2ubySM4kFsobyz2ByRSy3thPJp0m3zjPIwt3XorbWyevoCKsX19HYxqz&#xd;&#xa;q8judscUYBdz1wAcdsn8KxLrUWvNZ0dGsLy2xcMd06KoP7tuBgmulrHPiK3aaaG3tbu5lgkaORIU&#xd;&#xa;Ulcdzkjg84+hpj6vbatoGpPb71aKGVJI5AAyHBHIBPpVywlMOg2sojeUrbIdkYyzfKOB71FBrSST&#xd;&#xa;pFPZXloJDtR7hFVWY9FGCeatxXscl5LakMk0Y3YYY3r/AHh7Z4+optrfxXcMs0SuYkJAfAxJgclf&#xd;&#xa;UdvqKzNFtpb6Q6rdzvLFI5ls4mPESEcZGPvYJHUik1Qf2JdpqaSyrZFz9pgTB3O3AYD1yeee1a19&#xd;&#xa;ex2ECyyhirSJGNoycswA/U1ZooooooooooooorAj/wCR+l/7Bo/9GVv0UUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUVz/AIO/5B95/wBfs386b4snn0tYNWsovOuUzbhGUsu1uScDnOVH&#xd;&#xa;etPRLcW2lQgbsyAysG7M53EfTJNZ2n3sWgWcdhqIeMx5CSqjOJRnJI2gkYzjnFVltJ01WxuZYin2&#xd;&#xa;m+aby+pjHkleSOO361dvpk07xAL673LbNaiFXVC/z7ycYUE9O9V7nUBqWsaQ1rBK1sk7HzypUZ8t&#xd;&#xa;uNpwfxxiukrmNK1mwsJtShuZHWT7dKcLC7cZHcAinrHcSwa/ePbPFHdQDyQSCXAjIzgdM8cHnmrM&#xd;&#xa;0lzB4csvJ3IvlxrO6j54o9vzMo9Rx2P0rFklt577TVttV1G9YXkbGOeIhQOefuD+daPiae60y9tL&#xd;&#xa;7TokmvLki0Ecn3SMlvUc5961rKxFjpC2cW5tqMBuIzk5P8zVXwzPEdJhst4+02aCGePujgDI9/qO&#xd;&#xa;Kg8Wj7XYLptuQ95O6tHFnBIVgWPoOPWtTUb1LC3WZ0LhpEjwPVmAz+tW6KKKKKKKKKKKKKwI/wDk&#xd;&#xa;fpf+waP/AEZW/RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRXP+Dv+Qfef9fs3866&#xd;&#xa;Ciiiiiiq1lZR2Qn8tmPnzNM27sW649qs0UVUuNPhubyK4nLP5ODHGfuq2fveue1W6oJo9pFfm9t0&#xd;&#xa;ME7MWlZP+WuezZ7Z549KWLSrZL9r51Mt1k7ZX6op/hGO3X86lu7KO8eEzMxSJt3l/wALHqCfoRkV&#xd;&#xa;ZooooooooooooorAj/5H6X/sGj/0ZW/RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RXP+Dv8AkH3n/X7N/OtW91KzsF3XM23nGFUu35AE1DZ63p97P5NvMxcjIDROmfxYCrbXUK3aWpfE&#xd;&#xa;zoXVcHlQQCc/iKmqGaSZJYFjg8xHYiR9wHljBOcd+cD8amooooooqnpV9/aWnRXfl+X5mflznGCR&#xd;&#xa;1/CrlFQ3N1DaRiSd9iFlQHBPJOAOPc02+vbfT7Y3F3J5cQIBbaW5JwOBzUUV5cS6a90lmTLhjFCZ&#xd;&#xa;ADIP4TntkYPPTNGm6nBqAkWMlZ4cCaMg/u2PbJAz0PIq7RRRRRRRRRRWBH/yP0v/AGDR/wCjK36K&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK5/wd/yD7z/r9m/nUk2nXdnrNzqtnFDd&#xd;&#xa;vcBUMLARsoAAyJOeOOmP5U1tVmGoWltq2kCFZX/cyiTzVEnYfdGD15qvf6Ys/i2AG7vI/MtpH/dz&#xd;&#xa;lduGQYHoPany2tw+vJp0eoXSWy2QZ8yEu3znkNng9OfTipZ4H0290qGK7u5EmuW3+dMXJHltxz2y&#xd;&#xa;M4qC4W7vPF89kt9NDai0V3SNiD97+E5+U9OfTirKRPpes2NtHdXM8d2JN4uJTJjaMjGenWlRJNbm&#xd;&#xa;uWe5uLaG2maBUt5ShJXqxI65447fjRoaSW+q6pam5uJ44TFs8+UuRlcnk1p38ElzYzQQztBJIhVZ&#xd;&#xa;V6ofUVzE3iOS60+1uI43hMSyXLgS/wCsWJtpQ8fxZz+HQ1s6fcSX2r3c29kit1EHk7shmID7/Y4b&#xd;&#xa;H4Vl+HdKe80S3kmv7uNfmEaW8piCjceuDyc55q7ouoMYdSjvJ/3VlcNAkjt820AYyx6nnrWLfaiN&#xd;&#xa;NgFzZSa0Zg6qPtqyGLBODndx06Vs+L7YT6fATLNHtuYhiNyoOXUc+47elQzactprumQm6u7mKYyF&#xd;&#xa;47mYyLlVypwe4PNdJWPN+68VWoj+QTW0jSheN5UoFJ9cAnH1q/a28sM91JJcNKs0gZEPSMbQMDn1&#xd;&#xa;GfxqzRRRRRRRRRWBH/yP0v8A2DR/6Mrfoooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;oorn/B3/ACD7z/r9m/nV26sL37VJPYXy25lx5iyxeYMgYGORio00u+mnhbUr+O4jhcSokcHlkOOh&#xd;&#xa;J3Hjk8VPqGnyz3EV1aXC291GpjDvHvXacEjGRzkDmktdOmj1Fb65uVll+zeQ22PaCdxbPU464xUt&#xd;&#xa;7Y/aruyn8zb9llMmMZ3ZUrj261HHpmzXpdT83PmQCHy9vTBznOakubHz9SsrvzNv2YSfLjO7cAOv&#xd;&#xa;bpWJftc6XezR2E1wkczGZgunvONzdfmBHp0qx4Zs3hmv7oiby7lkZTOpVyQCG+U8gZ6D0rfrPttK&#xd;&#xa;igvbuYhGjnChYtgwgAwR+J5puh6Qmj2rxCZ5pJHLySN3PT8OAKm0mx/s3TYbTzPM8vPzYxnJJ6fj&#xd;&#xa;VKLQIxBqUM0xdL64M3A2lOhA688iq+oaJqupW32a61aAxFlYhbTB4Oeu72rX1GyW/tTCzFSGV1b0&#xd;&#xa;ZTkH35A4rKutP1dTHd/aYby6t2/coI/KGDw+Tk9R09K1Ir3dYNcyQTIUB3x7CWyOoAxk+3rVOwiu&#xd;&#xa;rvU31C9g8lUTZaruydjYLFh2PA47VJo6zNNfXMgkWKeYNEsgIIUKB0PTkGtOiiiiiiiiisCP/kfp&#xd;&#xa;f+waP/Rlb9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFc/4O/wCQfef9fs3866Ci&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiisCP/AJH6X/sGj/0ZW/RRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRXP8Ag7/kH3n/AF+zfzrXW9ia+ezIZJVXcu4cOOMlfXGQDRaXsV40vkhikbbf&#xd;&#xa;Mx8rHvg+x4NVbrWYoZ3hhtrm8kjOJBbIG8s9gckUst9ZTS6dIGeTz5GEDRt8uQpznnkYB9easX19&#xd;&#xa;HYxqzq8judscUYy7n0A+mT+FYtxqkl1rGkxizvrVTO24zIFVv3bccE5rpKz73U2tJ/KGnX1xxnfB&#xd;&#xa;GGX6ckVZtLqK8t1mhOVOQQeqkcEH3B4qjLriLKywWF7dIpK+bBGrISOoySOh4rO8MX8sXhaG4eG6&#xd;&#xa;u3MrjbGNz/ePqelaGjanZ3KQW1ok6hoTMvm8kLvK4JyTnOau3N7Faz20MgYtcyGNMDgHaTz+Aqpc&#xd;&#xa;a3FHO8Vva3V4YztkNsgYI3905I5p76qjaZJdwQzyMnytEigyI3cEZxkd+ax7XxJO+iW7y2l6LiaN&#xd;&#xa;UW5MSiMyNwG69Mkdvwra0yxltkMt3O095IoEsmcKcdgvQfUAZqpL5+k6nA/2hm0+5k8vySAWWVjk&#xd;&#xa;HJ5x97vxxgVovexR6hDZEN5ssbSKQOMKQD/MVZoooooooooorAj/AOR+l/7Bo/8ARlb9FFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFc/4O/5B95/1+zfzpniu8bRGg1mNBK6A2/lscDD&#xd;&#xa;fNnP/Af1rS0K3FvpMOGJ83Mx9i5LY/DNZ+l39rodhHYapKttLFkB34WXknKnuBn2qqsMi6vY3MiG&#xd;&#xa;NbvUHlRG4ZV8kjkduhq9e3MOn+JBd3siwWzWgjWRzhS+8nH1xVe71S31DWtHFpuliW4Y+eoHlk+W&#xd;&#xa;3yg+tdLXJ6jeM9/MLrXW0go5RIQAd6A8Pz6/0qbQkabwZdJE5nd/tAVx1kJZsH8asWOvabb2Fvbf&#xd;&#xa;aFkuo4lQ28ZzIXAwVA9c03wOc+GoTgjMknB/3zWXoNzDpxsry9kWC2azaISOcAv5rHH1xV+81W11&#xd;&#xa;DWNHWzczxrcMTKnKA+W3y59e9Qai1pBfzbNVm0Rmcs6Mi4nOf9YMk8dvwrX0maa50mTzCZMFkjm/&#xd;&#xa;57rjh/xrCN5b/wDCOWOm+cn222aEzQZ+ZAjAvkewBJ+ldfHIksayRsGRwGUjuDWVrv72fTYI/mlF&#xd;&#xa;2kpQddi/eb6DI/Or8l5EmoQ2ZVvNljaRTjjCkA/zFWaKKKKKKKKKKwI/+R+l/wCwaP8A0ZW/RRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRXP+Dv+Qfef9fs3863yAeozRQVB6gH60YoI&#xd;&#xa;B6gGgKB0ApaaVU9QD+FKAAMAYpNq5ztGfpVS+sJLsoYr65tAuciAqA31yDU9taw2tslvCgWNOi1K&#xd;&#xa;FA6AUFQeoBo6dKZJDHLG8ciBlcFWHqD1qtYabDpxdbZnWAgbYMjYnqR35+tJbaVbQXj3hDSXT5Bm&#xd;&#xa;c/NtJ+7xxgcD8KkFlH9va8dmeTbtQN0jHcD64Gc+lWqKKKKKKKKKKwI/+R+l/wCwaP8A0ZW/RRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRXP+Dv+Qfef9fs3866Ciiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiisCP/kfpf+waP/Rlb9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;c/4O/wCQfef9fs3866CiiiiiiiiiiiiiiiiiiiiiiiiiiiiisCP/AJH6X/sGj/0ZW/RRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWKnhq3iaQwXuoQrI5kKxXBVck88Cnf2An/QT1X/w&#xd;&#xa;Laj+wE/6Ceq/+BbUf2An/QT1X/wLaj+wE/6Ceq/+BbUf2An/AEE9V/8AAtqP7AT/AKCeq/8AgW1H&#xd;&#xa;9gJ/0E9V/wDAtqP7AT/oJ6r/AOBbUf2An/QT1X/wLaj+wE/6Ceq/+BbUf2An/QT1X/wLaj+wE/6C&#xd;&#xa;eq/+BbUf2An/AEE9V/8AAtqP7AT/AKCeq/8AgW1YfiPTtQtbixg0vUtQLzly4kum+6oBP6ZrWtNJ&#xd;&#xa;gvLSK5g1XVTFKodSbphwam/sBP8AoJ6r/wCBbUf2An/QT1X/AMC2o/sBP+gnqv8A4FtR/YCf9BPV&#xd;&#xa;f/AtqP7AT/oJ6r/4FtR/YCf9BPVf/AtqP7AT/oJ6r/4FtR/YCf8AQT1X/wAC2o/sBP8AoJ6r/wCB&#xd;&#xa;bUf2An/QT1X/AMC2o/sBP+gnqv8A4FtR/YCf9BPVf/AtqP7AT/oJ6r/4FtR/YCf9BPVf/AtqlsNE&#xd;&#xa;t7G+a8We5mnaPyi08pf5c5xz71p0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUVjWqi/1u8uD89vCv2dN38EgzvwO2QV570/w+xignsW+X7JKYokbhvKHCsfXPPPfF&#xd;&#xa;a1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FNk3eW2z72Dj61x39oa54f055rjS7dg8m6WT7Ry7sQM4HTJ7CtLS49aOvyXd9YwwxTRLGxSYMV27&#xd;&#xa;iPzJroaKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKwPG3/ACLsn/XWL/0MVv0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUVgeNv+Rdk/wCusX/oYrfooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooooooooooooooooooooooooooooooooooooorA8bf8i7J/11i/8AQxW/RRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWB42/5F&#xd;&#xa;2T/rrF/6GK36KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKwPG3/Iuyf8AXWL/ANDFb9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFRzSeVBJJjOxS2PXArGtdX1a7tYriHRFMcqB1Ju1GQRkdql/tDWv+gGv/gYv+FH9oa1/&#xd;&#xa;0A1/8DF/wo/tDWv+gGv/AIGL/hR/aGtf9ANf/Axf8KP7Q1r/AKAa/wDgYv8AhR/aGtf9ANf/AAMX&#xd;&#xa;/Cj+0Na/6Aa/+Bi/4Uf2hrX/AEA1/wDAxf8ACj+0Na/6Aa/+Bi/4Uf2hrX/QDX/wMX/Cj+0Na/6A&#xd;&#xa;a/8AgYv+FH9oa1/0A1/8DF/wo/tDWv8AoBr/AOBi/wCFH9oa1/0A1/8AAxf8KP7Q1r/oBr/4GL/h&#xd;&#xa;R/aGtf8AQDX/AMDF/wAKP7Q1r/oBr/4GL/hR/aGtf9ANf/Axf8KP7Q1r/oBr/wCBi/4Uf2hrX/QD&#xd;&#xa;X/wMX/Cj+0Na/wCgGv8A4GL/AIUf2hrX/QDX/wADF/wo/tDWv+gGv/gYv+FH9oa1/wBANf8AwMX/&#xd;&#xa;AArG8WXmpy6G63GlLBH5kfzi5Vudwxxitn+0Na/6Aa/+Bi/4Uf2hrX/QDX/wMX/Cj+0Na/6Aa/8A&#xd;&#xa;gYv+FH9oa1/0A1/8DF/wo/tDWv8AoBr/AOBi/wCFH9oa1/0A1/8AAxf8KP7Q1r/oBr/4GL/hR/aG&#xd;&#xa;tf8AQDX/AMDF/wAKP7Q1r/oBr/4GL/hR/aGtf9ANf/Axf8KP7Q1r/oBr/wCBi/4Uf2hrX/QDX/wM&#xd;&#xa;X/Cj+0Na/wCgGv8A4GL/AIUf2hrX/QDX/wADF/wo/tDWv+gGv/gYv+FH9oa1/wBANf8AwMX/AAo/&#xd;&#xa;tDWv+gGv/gYv+FH9oa1/0A1/8DF/wo/tDWv+gGv/AIGL/hR/aGtf9ANf/Axf8KP7Q1r/AKAa/wDg&#xd;&#xa;Yv8AhR/aGtf9ANf/AAMX/Cj+0Na/6Aa/+Bi/4Uf2hrX/AEA1/wDAxf8ACj+0Na/6Aa/+Bi/4Uf2h&#xd;&#xa;rX/QDX/wMX/Cmy6prEMTyvoihUUsf9MXoPwrTsbn7ZY290F2edEsm3OcZGcfrU9FFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFQXv/Hjcf8AXNv5VV8O/wDIu6b/ANe0f/oIrRooooooooooooooooooooooorA8bf8A&#xd;&#xa;Iuyf9dYv/QxW/RRRRRRRRRRRRRRRRRRRRRRRRRVbUv8AkGXf/XF//QTUOhf8gHTv+vWP/wBBFX6K&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKgvf+PG4/65t/Kqvh3/AJF3Tf8Ar2j/APQRWjRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRWB42/5F2T/rrF/6GK36KKKKKKKKKKKKKKKKKKKKKKKKKral/wAgy7/64v8A+gmodC/5AOnf&#xd;&#xa;9esf/oIq/RRRRRRRRRRRRRRRRUU83kqh8uSTc4XCDOMnGT7DvUtFFFV7+8j0+ymu5gxjhXcwUZOK&#xd;&#xa;nByM1De/8eNx/wBc2/lVXw7/AMi7pv8A17R/+gitGiiiio5J4opI45JFV5SVQE8sQM8fgKkooooo&#xd;&#xa;ooooqKebyUDeXJJlguIxkjJxn6CpaKKKKrWF5FqFnHdQhhHJnG4YPBI/pVmsDxt/yLsn/XWL/wBD&#xd;&#xa;Fb9FFFFRyTxRPGkkiq0rbUBP3jjOB+ANSUUUUUUUUUUUUVEk2+eWLy5F8vHzsPlbPoe+O9S0UUVW&#xd;&#xa;nvIoLu2tnDb7ksEwOPlGTn8Ks1W1L/kGXf8A1xf/ANBNQ6F/yAdO/wCvWP8A9BFX6KKKKjE8RuDb&#xd;&#xa;iRfOChymeQpOAf0NSUUUUUUUUUUVna1dTWkNq0DbTJdwxNwDlWYAj8qr6xdX6app9pYuiC5WXeWH&#xd;&#xa;3cBcMOOSMk471Ru59at9RttKhv0lluR5huHiVfLRT8wCgYJx61oWc15bauun3d19r8yBphIYwhXD&#xd;&#xa;AYwOvWoPO1W91nUbS3uktoLdo9sgQMwygO3BHQ5JzntWZq1xqEWn6zpuoypcbbXz4plAUlSduCAM&#xd;&#xa;dQa2Ne1I2EdpF9oS0Fy5Q3LAERYXOcHg5xj8ay11nE62q6zFqYuUkUhUVDHhGbPHXpik0OfU7qOC&#xd;&#xa;xtbhIII7G2fzNgZkJU9ARznHc8VaU63Nqr6dHqSqtugkluDCu5t+doC4xxtPfvV3SL64fUb7Tblx&#xd;&#xa;M9mIz5+0KZN4J+6OBjpWSNc+1NJI/iGHTiJGT7OY0YrtJGcnnnGfxqw2t3s+jaddWflNLPeeQdx+&#xd;&#xa;WQAuM5xxnaDxU1+NV0uymv5NV+0JApcwm3RQ+O2RyKj1+G6n1fR2gvDBukYKPLDbW2MS3PXjjFTX&#xd;&#xa;0t/ptmiz6huEkhD3jQqot1xxkdDkjHP96jSLye4udsOrW+qQj/WkBUaLrjAUc5Pr6Vu0UUUUUUVn&#xd;&#xa;a5dzWdpFJA21muIoycZ+VnAP6GoNYur6PUtOtbFkX7T5off2AA5HHUZzjvVC9n1q1v7XS4b9Jprv&#xd;&#xa;Lid4lXylX72ABg5HrV+0mvLTVo7C7uvtfnRNKHMYQptIGMDrnd+lQtNql5rWoWdvdJbwQeWRJsDM&#xd;&#xa;pK5xgjkH1zxin6XcajDrM+m6hMlyPK8+KYKFO3IXBAGOuaqadfHTfA8d2qhjGDwTgcyEf1qtLros&#xd;&#xa;089PEcF+ykYthEi+Zk46jnvn8Kg8aXd673dmmw2qJA5J+8jFzyOOeg6mtLOtyat/ZsepKFhjEstw&#xd;&#xa;YV3ENkKoXGOCp596uaVe3J1O80y6kE72qo3n7Qpfdk42jgYrLOt/aZZmfxBDpxSV4/s5jRiNpIzk&#xd;&#xa;884zUza3eTaNZ3NmY3lkvRb5J+WUAkZ6cZxnjpVi9TVdOs5r+TVfOWBDI0H2dFDY527uo+tRa/Hd&#xd;&#xa;XF7ozwXZt982ABGG2tsY7uevHGKnvZL/AE2yUTah5nmS4e7aFVFuuOpHQ8gDn1puk3k89ztg1e31&#xd;&#xa;SP8A5a4VUMQ7EbRzn3reoooooooooorOs7uaXW9StnbMUCxGMY6bgc/yrJ0WfWtZsmmN+lsqSuqs&#xd;&#xa;sSuXAOOQRxjHbrmn6Ydb1aBrz+0ltIXYrFGkKvwp2kkkdyCaln1i5bwhLqUWI7hVYA4yMh9ufxxT&#xd;&#xa;rm019rd5odTjimIyIPKUop9NxGSPfFQJenUbvw3eMgQzea5UHOP3Zp+s6t5Oq/YTqcemqsKy+a6q&#xd;&#xa;2/JI24Ppj9ahs9YN7Hqdj9qS9WC2Li5QAbsg8YHHFNszqlt4bg1A3iRxW9osgtljDB1VARliMgkD&#xd;&#xa;8KdFPrQ0d9Znv0CCM3K2qxKQUxuClsZ6cZrR1fVDZ6TBc7lh890QyN0i3fxc9cdazbTWvL1C1iXW&#xd;&#xa;4dT+0SeUY1RUKDBO7jr0xj3q9qFxqDa9FYWUqRxyWzSOzAEoQwG4DHJ5xjpzUb3N/pWoWMF1efbV&#xd;&#xa;vJDGMxLH5eBnPHWq8tpfy+LrkQamYSbRGB8hWwu9sLz+Jz71HJqd0srxX2sppckTGNVkiQmdR0l5&#xd;&#xa;6BueBxxXQadJNLZRvM8chI+WWM8SL2b2yOcVaoooooooorP1ezlvYrZYioMV1FK244+VWBP40XVn&#xd;&#xa;LNrNhdqV8u3SVXyefmC4x+RqK506aXxHZ6gpTyYYXRgTzk9MVK9nK2vxXwK+Uls8RGedxZSPw4NY&#xd;&#xa;27WF8Rav/ZUdm6b4t/2hmBz5Y6Yqa60K8vLG9mnnDX93b+Tsz+6j5zheM4+ua0NXsZrhLee1EbXV&#xd;&#xa;qxaJJT+7YkbTuxz0J/HFU44dYdJX1FbOCOOJyotcneSpGGyOnfik8K2csUEV4xXy57G2RQDzlVOc&#xd;&#xa;/mK0Lezli1u9vGK+VPFEigHnK7s5/MVFY6dNb6/ql85TyroRCMA8/KpBzVH7DrOns8GmQ6fLa72d&#xd;&#xa;XuS28ljuOccdSce1XJ9NuZbfTlMqvJBdLPKW44w2QMDtnA9hVnW7SS/0e7tISokmjKruOBmo9Usp&#xd;&#xa;5o7ee02G7tG3xLIcIxI2ndjnoT+NQbNclsC832NLxHykaEmKRcAYfIz6nj0FRWenajc6hBd6qttC&#xd;&#xa;1oSYVtCcPuGDuz+GMVvUUUUUUUVn6zZy31rFHCVDLPFIdxxwrgn9BRd2cs2r6fdIV8u3Eu/J5+ZQ&#xd;&#xa;Bj8qiu9Omm8Q2F+hTybeORXBPOWHGKlls5X122vQV8qOCSNhnnLFSP5Gsdm1dfEmq/2VHZuv7nf9&#xd;&#xa;oZgc7OMYrT03TrhLw6jfzbruSLymjQ/u0Gc4XjP5+tRW2isfDC6XcsA+DkoeM79w6j6VDFB4gnkW&#xd;&#xa;O6j063hJ+aS3LGRfpuGKoeMLOVIb29JXypRbxqM85WQk/wAxW/DZyprlzekr5UsEcajPOVLE/wAx&#xd;&#xa;UVnp00HiHUL5ynk3CRqgB5yo5zVJrHWbCWWLTIdPltmdpA1yW35Y5PTjGTxVqfTbqa0sEaRXlhuk&#xd;&#xa;nlzwABkkLgdBnAq3rFrJfaRd2sJUSTRMi7jgZIqHUrCea1tXtin2q0YPEHOEZtpU574wTUITXJrF&#xd;&#xa;mn+xx3aPmOOMkxyDHR8jPvx6CorTTtSur+C51VbWH7KS0QtCcOSMHdntW9RRRRRRRRRRWfaWcsOs&#xd;&#xa;ahdMV8u4WIJg8/KCDn86i8O6dNpmmG3uChfzXf5DkYJyKl0Ozl0/SoraYqZEZydpyOXJH6GsjUbO&#xd;&#xa;XT/AlzbTFTIgY/KcjmTI/nVlV8S3DCG6+wW8L8PLbsxkUf7O4Y/Opo9GNtLo6277oLDeGLn5iChA&#xd;&#xa;6D1NJqljfLf/AG7TEtpJnjEUi3JO0KCSCMd8k0iW98mmXs+oPGsrwOPJg/1a4B5GRnJogtnvPBcV&#xd;&#xa;rEQJJtPWNdx4yY8DNSvp8zeFjpoKef8AY/Izn5d2zb19M06+057nS4IVK+fblJIwT8rOnQH2z1qC&#xd;&#xa;wh1qW6Q6itlBDH8w+y5LOem07h05J454FWms5T4gS+yvlLatCRnncXB/LAqLVtOmvNQ0ueIoEtZi&#xd;&#xa;8m484xjimalaagl+L/ShbvO8QhkW4JChQSQRjnOSaglh8QxFTALG53jfIbkn9256ouB90ds81paT&#xd;&#xa;ZtZWe2Q5lkdpZADlVdjkhfYHpV2iiiiiiiiiiiikwASQBk9aWioL3/jxuP8Arm38qq+Hf+Rd03/r&#xd;&#xa;2j/9BFaNFFFFFFFFFFFFFFFFFFFJgAkgDJ60tFFYHjb/AJF2T/rrF/6GK36KKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKQgEYIBHvS0UVW1L/AJBl3/1xf/0E1DoX/IB07/r1j/8AQRV+iiiiiiiiiiiiiiiiiiiiiiio&#xd;&#xa;L3/jxuP+ubfyqr4d/wCRd03/AK9o/wD0EVo0UUUUUUUUUUUUUUUUUUUUUUVgeNv+Rdk/66xf+hit&#xd;&#xa;+iiiiiiiiiiiiiiiiiiiiiiiiiq2pf8AIMu/+uL/APoJqHQv+QDp3/XrH/6CKv0UUUUUUUUUUUVD&#xd;&#xa;c3MNpA01w4SNepxn9BWb/wAJRo//AD9n/vy/+FH/AAlGj/8AP2f+/L/4Uf8ACUaP/wA/Z/78v/hR&#xd;&#xa;/wAJRo//AD9n/vy/+FH/AAlGj/8AP2f+/L/4Uf8ACUaP/wA/Z/78v/hR/wAJRo//AD9n/vy/+FH/&#xd;&#xa;AAlGj/8AP2f+/L/4Uf8ACUaP/wA/Z/78v/hR/wAJRo//AD9n/vy/+FRXXiXSXtJkW6JZkYAeU/Jx&#xd;&#xa;9Kr6L4h0u20WxgmuWSWOBEdfKfghQCOlXf8AhKNH/wCfs/8Afl/8KP8AhKNH/wCfs/8Afl/8KP8A&#xd;&#xa;hKNH/wCfs/8Afl/8KP8AhKNH/wCfs/8Afl/8KP8AhKNH/wCfs/8Afl/8KP8AhKNH/wCfs/8Afl/8&#xd;&#xa;KP8AhKNH/wCfs/8Afl/8KP8AhKNH/wCfs/8Afl/8KP8AhKNH/wCfs/8Afl/8KP8AhKNH/wCfs/8A&#xd;&#xa;fl/8KuafqlnqQkNnN5nlkB/lK4z06irlFFZdx4h0u1uJLea62yxnDqI2OD17Co/+Eo0f/n7P/fl/&#xd;&#xa;8KP+Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/8KP+Eo0f/n7P&#xd;&#xa;/fl/8KP+Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/8KP+Eo0f/n7P/fl/8Kx/FWuaffaI8FrO0kpkjIUR&#xd;&#xa;OOAwJ6itj/hKNH/5+z/35f8Awo/4SjR/+fs/9+X/AMKP+Eo0f/n7P/fl/wDCj/hKNH/5+z/35f8A&#xd;&#xa;wo/4SjR/+fs/9+X/AMKP+Eo0f/n7P/fl/wDCj/hKNH/5+z/35f8Awo/4SjR/+fs/9+X/AMKP+Eo0&#xd;&#xa;f/n7P/fl/wDCj/hKNH/5+z/35f8Awo/4SjR/+fs/9+X/AMKnstc06/uBb2txvlKltpRl4HXqK0aK&#xd;&#xa;KSsubxFpUEzxSXWHQ4IEbn9QKZ/wlGj/APP2f+/L/wCFH/CUaP8A8/Z/78v/AIUf8JRo/wDz9n/v&#xd;&#xa;y/8AhR/wlGj/APP2f+/L/wCFH/CUaP8A8/Z/78v/AIUf8JRo/wDz9n/vy/8AhR/wlGj/APP2f+/L&#xd;&#xa;/wCFH/CUaP8A8/Z/78v/AIUf8JRo/wDz9n/vy/8AhUF94k0mWwuI0uiXeJlUeU/JIPtUek+ItLt9&#xd;&#xa;IsoZbkrJHAiMvlPwQoBHSrf/AAlGj/8AP2f+/L/4Uf8ACUaP/wA/Z/78v/hR/wAJRo//AD9n/vy/&#xd;&#xa;+FH/AAlGj/8AP2f+/L/4Uf8ACUaP/wA/Z/78v/hR/wAJRo//AD9n/vy/+FH/AAlGj/8AP2f+/L/4&#xd;&#xa;Uf8ACUaP/wA/Z/78v/hR/wAJRo//AD9n/vy/+FH/AAlGj/8AP2f+/L/4VqxyJLGskbBkYZBHen0V&#xd;&#xa;j6//AK7SP+wgn/oD1sUUUUUUUUUUUUUUUUUUUUUVj6Z/yMOtf70P/outiiisfRP+P/Wf+vz/ANpp&#xd;&#xa;WxRRRRRRRRRRRRRRRRRRRRWPd/8AI1ad/wBe0/8ANK2KKKZL/qn/AN01m+Fv+Ra07/rgtatFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFY/hX/AJAMX/XWb/0a9bFFY+v/AOu0j/sIJ/6A9bFFFFFFFMeRI9u91Xe21dxx&#xd;&#xa;k+g96JJEijaSV1RFGSzHAH404kBSxIAAySaijuopZhHGS2YxIHAyhUnjDdKmooqCzu4b2DzoGLJu&#xd;&#xa;ZckY5UkH9QanoooooorH0z/kYda/3of/AEXWxRRWPon/AB/6z/1+f+00rYooqo2qaejFWv7VWBwQ&#xd;&#xa;ZlBB/OrKsrqGUhlIyCDkEU6iiiiiiiopp1g8vcHO9wg2qTgn1x0HvUtFFFFFFY93/wAjVp3/AF7T&#xd;&#xa;/wA0rYoopkv+qf8A3TWb4W/5FrTv+uC1q0UUVFPcwWyB7iaOFScAyMFBP40yC+tLlylvdQTMBkrH&#xd;&#xa;IGIH4VL5ieb5W9fM27tmeceuPSn1FJOsc0URDlpSQpCkgYGeT2/GpaKKKKKrXN9b2k9tDMxD3LlI&#xd;&#xa;wATk4zVmiiiisfwr/wAgGL/rrN/6NetiisfX/wDXaR/2EE/9AetiiiiiiiqGs2cl5Zf6NtF1C3m2&#xd;&#xa;7MeFcAgE/maydSvxq8GmQ2wZ7a+fFxHt+byuRk4+6MjrTWvbi/8AD1naPIRqF24Q/wAO1lO9g2On&#xd;&#xa;yjpjv71qRXDp4gNgm1bZLNZFRVAwd5H8gOKo2cmsanJeBL1LWKC6kiRliVy4DYwQemPXvmrFrqE1&#xd;&#xa;pLqEF/Mbj7FCs7TBApYEMcbRxxt/WhIdWvkW6j1IWiSjcsKwLJtXtyeckc+2aTwmGXQkDtvYTTAt&#xd;&#xa;jGT5jc1tUUUUUUVj6Z/yMOtf70P/AKLrYoorH0T/AI/9Z/6/P/aaVsUUVy2hnRhZy/bTYef9pm3e&#xd;&#xa;ds3f6xsZzzVm3vJLDS9SvokLWUQL20chIPGd3P8AdJ6e2Kq3GpTWdo97/wAJDbXPlL5n2YJGC/fb&#xd;&#xa;kHNXbu81KXW47KyaNI5LQSMzdYyWxuHHJ9jxU0k15psMcE1z9turmXZCzRiNRxnnHsCaktbfVLe4&#xd;&#xa;QzXy3kTcOGiEZQeox19Me9O0e7muvt3nMG8m7kiTjGFGMCopL+4j1XUIlHmJb2iSxxgcljv49ecC&#xd;&#xa;qMN1dTBJR4gtllfDfZGSMEE/8syevt0zUl3e3cl7JBJqEWleSqfM6qwmJGTgtjoeOPWh769t4bT/&#xd;&#xa;AEyG6jlvI4hcRhf3inO4EDgY6cGruoX7/bo9MtDtu5Y/M8xh8qJnBPuR6VHFPd6ddwW9/cfa1uW2&#xd;&#xa;RyiMIVfBOCB2wDzVeOXVb/U9Rt4LtLaC3mCrIIw7fcU7cEdOc5zVrTbi6TUbjTruf7S8UayibYEy&#xd;&#xa;GJGMD029fetWiise7/5GrTv+vaf+aVsUUUyX/VP/ALprN8Lf8i1p3/XBa1aKKK5i9iaw1a7vdRs5&#xd;&#xa;L60nZVhSMGUodo/5ZngdDz7+9Sabf6PealHBFYy2Fyo8xPMiEG/tjg/N16e3tUdzaX8ni/EOp+UW&#xd;&#xa;tGZT5CttXePl56+uaneXVm1g6bFeIFW1SR7gxjcGLNyFxg5wBjPFTebf2Woabaz3v2kXEku9jEqc&#xd;&#xa;BMgce4qvYy6zqf2nbdx2sUVzLGkixh2YBiACpGBjHXPNXtKubn7beWF1L572wjbztoXdvycYHTGK&#xd;&#xa;i82+1WSVrG7+xwQSNFu8oO0jA4bIPQAjj1zVBtVvrIXsF1eLKyXUVutwyKgjDqDuI6HGe/pUsOoy&#xd;&#xa;2t9aRtrMGpC5l8ny0VFKcE7vl69MfjWlf3czXaadZsI7iSMymVhkIgOCQO5yRxWJqVtfQa5ohu9Q&#xd;&#xa;+1qbk7R5Kpt+X2rrKKKKKx/Cv/IBi/66zf8Ao162KKx9f/12kf8AYQT/ANAetiiiiiiiisnR9IGn&#xd;&#xa;zzOQML+6t8MTthHIB99xahNIC64bsAeQMzKNxz5xBVj9NuBUws5R4ge+yvlG1WHrzuDk/lg0aRZy&#xd;&#xa;2SXYlK/vrqSZdpz8rHI/GoZdKknvdVZ3VYr22SFSOSCA4Jx/wIVHENciiS1S3tEjVRGJvOJYAcbt&#xd;&#xa;u3BPfGas6DYz6dpaW9y6vKJJGLL0O5yc/rWjRRRRRRWPpn/Iw61/vQ/+i62KKKx9E/4/9Z/6/P8A&#xd;&#xa;2mlbFFFY+l6JBBbOt5a20srTSPuMYYkM5I5I9CKu6hYpe6ZPYhvKSWMxgqPujGOBWMNNvXAhOk6V&#xd;&#xa;Cp+Xzlw7L77SmCfbNaa2Uq68L3K+ULQQ++7dnp6YpdW06S+NtJBceRLbSeYjbA2TtIxz9aZatq81&#xd;&#xa;whu47e2iTkiKQyGT25Ax659qrrbapp09yLCC2uIp5mnLSylCpbqMAHjjrS2Gn6imo3l5dTRh7iBE&#xd;&#xa;TYM+UQW46cgZ6nrVaTTr+XfG2mablsqboNiTn+PG373fr171PdWF6giRLe01FEjVB9q+UoQACQcH&#xd;&#xa;OetQrot25ilZYYD9rima3jb93GqZzt4HJznoK0b/AE9pLpNQtMC9iTYu4/K65yVPpk98ZqOC0vLy&#xd;&#xa;5iuNTSKP7O26KKJyw3YxuJwOxIx0qXT7OW2vdRmkK7bmYOmDzgIo5/EURWcqa7c3pK+VJBHGvPOV&#xd;&#xa;LE/zFaFFFY93/wAjVp3/AF7T/wA0rYoopkv+qf8A3TWb4W/5FrTv+uC1q0UUVm3R1eG4c2kdvcxP&#xd;&#xa;ggSuYzHx04Bz6596qiyv7+/tZ9QtrW3+yv5ivFIXZuCNvIGBzn8KsX9pdpqKahYpFLKITAY5XKDa&#xd;&#xa;TuzkA85AGMUWlpdf2u9/crEnmWqRFUYthgzE9unIqS9s5Z9U025Qr5ds0hfJ5+ZCBj8aNHs5bKC4&#xd;&#xa;SYrmS5llG054ZiRRa2csOs392xXy7hYgmDz8obOfzrGm1B9BuZ7SObT2DytP/pFyY2G87sYweOai&#xd;&#xa;stPm1SK/maWO5DXUVxFIVHlz7FHy/TI2k+1aVlYXZu43l0/TrJYzu3wAOzf7PKjHXOR6VYv7S7XU&#xd;&#xa;Y9QsUilmERgMcrlF2khs5APOQBjHeqM+navf6np15dfZ4ktZSzQo24Yx94NgHPOMe1dFRRRRWP4V&#xd;&#xa;/wCQDF/11m/9GvWxRWPr/wDrtI/7CCf+gPWxRRRRRRRRRRRRRRRRRRRRRWPpn/Iw61/vQ/8Aouti&#xd;&#xa;iisfRP8Aj/1n/r8/9ppWxRRRRRRRRRRRRRRRRRRRRWPd/wDI1ad/17T/AM0rYoopkv8Aqn/3TWb4&#xd;&#xa;W/5FrTv+uC1q0UUUUUUUUUUxoo2OWRSfUinKoUYUAD0FLRRRRRRRWP4V/wCQDF/11m/9GvWxRWF4&#xd;&#xa;puYbNdLuLhwkUd8hZiOg2PS/8JfoP/QRT/vhv8KP+Ev0H/oIp/3w3+FH/CX6D/0EU/74b/Cj/hL9&#xd;&#xa;B/6CKf8AfDf4Uf8ACX6D/wBBFP8Avhv8KP8AhL9B/wCgin/fDf4Uf8JfoP8A0EU/74b/AAo/4S/Q&#xd;&#xa;f+gin/fDf4Uf8JfoP/QRT/vhv8KP+Ev0H/oIp/3w3+FH/CX6D/0EU/74b/Cj/hL9B/6CKf8AfDf4&#xd;&#xa;Uf8ACX6D/wBBFP8Avhv8KP8AhL9B/wCgin/fDf4Uf8JfoP8A0EU/74b/AAo/4S/Qf+gin/fDf4Uf&#xd;&#xa;8JfoP/QRT/vhv8KP+Ev0H/oIp/3w3+FH/CX6D/0EU/74b/Cj/hL9B/6CKf8AfDf4Uf8ACX6D/wBB&#xd;&#xa;FP8Avhv8KP8AhL9B/wCgin/fDf4Uzw/e2+oavrFzaSiWF2i2sARnCYPWt+iiuXtNc03S9V1eK+ul&#xd;&#xa;hka63AFScjYo7D2q5/wl+g/9BFP++G/wo/4S/Qf+gin/AHw3+FH/AAl+g/8AQRT/AL4b/Cj/AIS/&#xd;&#xa;Qf8AoIp/3w3+FH/CX6D/ANBFP++G/wAKP+Ev0H/oIp/3w3+FH/CX6D/0EU/74b/Cj/hL9B/6CKf9&#xd;&#xa;8N/hR/wl+g/9BFP++G/wo/4S/Qf+gin/AHw3+FH/AAl+g/8AQRT/AL4b/Cj/AIS/Qf8AoIp/3w3+&#xd;&#xa;FH/CX6D/ANBFP++G/wAKP+Ev0H/oIp/3w3+FH/CX6D/0EU/74b/Cj/hL9B/6CKf98N/hR/wl+g/9&#xd;&#xa;BFP++G/wo/4S/Qf+gin/AHw3+FH/AAl+g/8AQRT/AL4b/Cj/AIS/Qf8AoIp/3w3+FH/CX6D/ANBF&#xd;&#xa;P++G/wAKrQavYar4psjYXCzCO3m34BGMlMdR7V0tFFMl/wBU/wDumuW8P+J9GtNCsree+RJY4grK&#xd;&#xa;Vbg/lWh/wl+g/wDQRT/vhv8ACj/hL9B/6CKf98N/hR/wl+g/9BFP++G/wo/4S/Qf+gin/fDf4Uf8&#xd;&#xa;JfoP/QRT/vhv8KP+Ev0H/oIp/wB8N/hR/wAJfoP/AEEU/wC+G/wo/wCEv0H/AKCKf98N/hR/wl+g&#xd;&#xa;/wDQRT/vhv8ACj/hL9B/6CKf98N/hR/wl+g/9BFP++G/wo/4S/Qf+gin/fDf4Uf8JfoP/QRT/vhv&#xd;&#xa;8KP+Ev0H/oIp/wB8N/hR/wAJfoP/AEEU/wC+G/wo/wCEv0H/AKCKf98N/hR/wl+g/wDQRT/vhv8A&#xd;&#xa;Cj/hL9B/6CKf98N/hR/wl+g/9BFP++G/wo/4S/Qf+gin/fDf4Uf8JfoP/QRT/vhv8Kf4RdZPD0Do&#xd;&#xa;cq0kxB9R5rVs0Vj+IAGl0gEAg36cH/cetTyIf+eSf98ijyIf+eSf98ijyIf+eSf98ijyIf8Ankn/&#xd;&#xa;AHyKPIh/55J/3yKPIh/55J/3yKPIh/55J/3yKPIh/wCeSf8AfIo8iH/nkn/fIo8iH/nkn/fIo8iH&#xd;&#xa;/nkn/fIo8iH/AJ5J/wB8ijyIf+eSf98ijyIf+eSf98ijyIf+eSf98ijyIf8Ankn/AHyKPIh/55J/&#xd;&#xa;3yKPIh/55J/3yKPIh/55J/3yKPIh/wCeSf8AfIo8iH/nkn/fIo8iH/nkn/fIrK0pVXX9aCgAboeA&#xd;&#xa;P+mdbNFFYujRo+oayXRWP2zuM/8ALNK1vIh/55J/3yKPIh/55J/3yKPIh/55J/3yKPIh/wCeSf8A&#xd;&#xa;fIo8iH/nkn/fIo8iH/nkn/fIo8iH/nkn/fIo8iH/AJ5J/wB8ijyIf+eSf98ijyIf+eSf98ijyIf+&#xd;&#xa;eSf98ijyIf8Ankn/AHyKPIh/55J/3yKPIh/55J/3yKPIh/55J/3yKPIh/wCeSf8AfIo8iH/nkn/f&#xd;&#xa;Io8iH/nkn/fIo8iH/nkn/fIo8iH/AJ5J/wB8ijyIf+eSf98ism4RE8VafsVVzbTdBjulbVFFMl/1&#xd;&#xa;T/7prJ8MQxN4b08mNCTAvJUVq+RD/wA8k/75FHkQ/wDPJP8AvkUeRD/zyT/vkUeRD/zyT/vkUeRD&#xd;&#xa;/wA8k/75FHkQ/wDPJP8AvkUeRD/zyT/vkUeRD/zyT/vkUeRD/wA8k/75FHkQ/wDPJP8AvkUeRD/z&#xd;&#xa;yT/vkUeRD/zyT/vkUeRD/wA8k/75FHkQ/wDPJP8AvkUeRD/zyT/vkUeRD/zyT/vkUeRD/wA8k/75&#xd;&#xa;FHkQ/wDPJP8AvkUeRD/zyT/vkUeRD/zyT/vkUeRD/wA8k/75FZfhTjQYsf8APWb/ANGvWxRWPr/+&#xd;&#xa;u0j/ALCCf+gPWxRRRUSSM1xJGYnVUAIkOMNnPA78Y/Wpaq296lxeXdsqsGtWVWJ6Hcobj86tUVVu&#xd;&#xa;b1La7tLdlYtdOyKR0GFLc/lVqiio5pUghkmlbbHGpZm9ABkmqlvqi3drNc2kEs8Sj92VwPO9ducd&#xd;&#xa;Dxzin2GpW2oiT7O+XiIWRCCCh9DVyiiiiisfTP8AkYda/wB6H/0XWxRRWPon/H/rP/X5/wC00rYo&#xd;&#xa;opkrFIndULlVJCr1b2FEbF41ZkKFgCVPUe1Q6hdpYWE93IrMkKFyF6kCp0beisOhGadTXYIjOeig&#xd;&#xa;mobC7S/sYLuNWVJkDgN1ANWKKKoyarbrqAsY90tyCN8aj7in+Ik8Y/Wk1DVYdNdTdq8duVybjGVB&#xd;&#xa;/u8c5/DFXlYMoZTkEZFLRRRRWPd/8jVp3/XtP/NK2KKKZL/qn/3TWb4W/wCRa07/AK4LWrRRUU0j&#xd;&#xa;RBNkTy7nCnbj5Qf4jnsKlqreXqWktrG6sxuZfKXHY4Jyfyq1RUc8ogt5JmBIjUsQO+Bmm2dwt3Zw&#xd;&#xa;XKAqs0ayAHqARmpqKKonVbc6ibCHdNcIR5qqP9WpGdxJ4xyOnPND6rbxagLKfdFK5Ah3DIl4zxj8&#xd;&#xa;ucdKvUUUUUVj+Ff+QDF/11m/9GvWxRWPr/8ArtI/7CCf+gPWxXNPqN1a6fe2olL3UVwIrcSHMskZ&#xd;&#xa;KZbHU9W5Hp7Vq6jcnSdIMo3zGIJGC7ZJJYKCT365qncWlzpttLqX2+4mlhQyyxO2YmAGWCr/AA98&#xd;&#xa;cnHvRomoSahqV1ISyxPa20qRFshN4Yn+n5UlvFLrsZvGvLq1i3skcdvJtI2sVO498kZ7daTQLf7L&#xd;&#xa;q2sw+dLNtki+eZtzH92Dyat+JJpbfw/fTQSNHIkRKspwQaqz6JeXFsznWLyO7desblYgfZfT8aqw&#xd;&#xa;XkuoHw1dT7fNlkkLbRgf6t60NdmtlSOOa6vYXzuxZ5Lke4AJxVbw/eG5ur6zSa6kgiRGV7kMJctu&#xd;&#xa;z1A44GOKi/tG6Wyay80/aRefZhk/vTDu2+Z65xzu6d6u+IN0Wm20Qdir3MMT5PLqWAIPrkda1kRY&#xd;&#xa;0VEAVVGAB2FZLfuvFkax/Ks1o7yAfxsrIAT7gcVsUUUUUVj6Z/yMOtf70P8A6LrYoorH0T/j/wBZ&#xd;&#xa;/wCvz/2mlTa888Gnm6tS/mwMGCLkh8kA7h3GCT+FR21019rcvlTbrS3iUo0TZR2bIYE9DjA+maiR&#xd;&#xa;ZdbmuCbq4tYbaZoVW3fazMOpJ7jpgduaQ3s6WOrWruTPYwnEw4LZQlT9QMc9zUkmoTQaLpzIQ1xd&#xd;&#xa;eVErvyFZl+8R36Vn6/oxh0K+lOp6hIVhZijz5U8dCMdK6SD/AFEf+6P5Vi3y3d14lWzivJILc2e+&#xd;&#xa;QISG+/jKnsenPpVe6gu9J1G18vULi4trrdC8dwxcg7WbIPboBV7QZooPCtg80gjQW6AsTjHFYzah&#xd;&#xa;FZyQyWl5q8srTJHtvEfyyGYA5yoGcHjnrW9rcs1tDDdW7PujlVWUfdKswDFh7DJz2ptjcve6xdus&#xd;&#xa;pa1gVVhMZ+STcMsSehIIx7c0zw5+8trm4f5pnuZVZz1IV2Cgn2HFas0Uc8LxTIrxuNrKwyCPSs3w&#xd;&#xa;zLJPoNtJK7O53AsxyeGIH6Vq0UUUVj3f/I1ad/17T/zStiiimS/6p/8AdNZvhb/kWtO/64LRf3D2&#xd;&#xa;Wr2chlK20wZJi5+RMAlT6AknHvxTNOu5jZX2oTl2w8mxM4XYhO0r9RjnvUdvZ3WoW8eojUJ4ppUE&#xd;&#xa;sUSN+6UEZUMvftnkZ9qrtrMt9plhcxboC2oRwuA33gGwfwPpWhf3E8+oppdvJ5JeEzSSjrsztIX0&#xd;&#xa;bnIP6Vm32mfYtR0iT7de3GbwLtnl3AfI/OMda6aucsra71O61ETajcxQQ3bpGsLlWHC8E+nPTHrT&#xd;&#xa;IvtdnNq2mz3b3UItTPG8pJdQ24bSe/3f1rS02SOLwxZPNIY0+yRgsDgjKDp7+lYiahHaXdp9ku9V&#xd;&#xa;meW4jiZbxH2bWOD1A59K2bu5ex1qAyTFbS4jfzGlbCRsuNuD0Gcn64p+hST3Fibu5Z/NmdiUPCqA&#xd;&#xa;So2jsCAD+Oai8MfvNJFy/wA080knmSHq+HZRk+wAH4UeKvk0C5nXiWAeZE46o3TI9Dgn862KKKKK&#xd;&#xa;Kx/Cv/IBi/66zf8Ao162KKx9f/12kf8AYQT/ANAetisa60NrjxTZ6yJwq28RjMW3lshuc/8AAv0r&#xd;&#xa;TubeK7t2gmUMjdQfUHIP4Hms4abfykW93fJLYjjYEIkdR0DtnByOvHNWLLTVs9QubiMqsUsUUaRq&#xd;&#xa;uNgTd/j+lVE03U7MGHTr22jttxZVmhLsCxJOSGHcntU+k6W+n3F5NJctO1yysS3UELg8+np6Cm+J&#xd;&#xa;43l8OX6Rozu0RAVRkn8KYLPWpVEdxqNusTcMYIWRwPZtxwfwp8eixwHS0t5CIrBmID8lgVI6/jT7&#xd;&#xa;7T7l70XthPHDcGMRMZULqVBJ4AI5yabpen3dvf3V5e3MU0k6ImIoygAXd6k/3qq2unrc+KrnVWWR&#xd;&#xa;ViQQRE8ZI3B+D1HTB6VoavaNeWDLGMzRkSwjOAZF5UH2yBTLTUZPsUj31vJDPAo85FUvzj+Ej734&#xd;&#xa;Zx0qHTorm71STUby38gKnl2y7gSUOCS3vkD0xWvRRRRRWPpn/Iw61/vQ/wDoutiiisfRP+P/AFn/&#xd;&#xa;AK/P/aaVqyp5kTpnG5SM1l+GtGbQtMNm8wmPmF9wXHXH+FPuNPuop3l0u4itzKd0qSxl1J/vAAjB&#xd;&#xa;Pc9+KeNLA0+6h8zdcXUbLLMwySSCPyGeB6Uk+lmXTLS3WUCa02NE5HG9RgEjuPaqV7pGralZzWt5&#xd;&#xa;qUIjdCB5EJQ59/mOR7VuxrsjVc52gCsK+g1B/FCyWMkcP+hYaSWIup+fpwRzU40e4uZo7jUrzzZo&#xd;&#xa;SfKWFSkYyCMlSTk8nnNO/sOOXw/BpVxIzLEiDenGSuMH8xVe50vWL1Y47q/tDEsqSEJbkE7WBxnd&#xd;&#xa;7Vo6wf8AiVXKBWZpYzGoVSfmYYH4ZPWo9A01dJ0e3tF3AquXBOcMeT+uarWYuNKv5bY27Gwml3RT&#xd;&#xa;A7mDuSWBA7ZJ57Yqxqt7dQqbfTrYz3joWQMMIB6lunXtnNWNNs0sLCK2j3bUB+8cnJOT+pq1RRRR&#xd;&#xa;WPd/8jVp3/XtP/NK2KKKZL/qn/3TWb4W/wCRa07/AK4LT/EGltrOkTWKyiIyFTvK5xhgen4VZtLQ&#xd;&#xa;QabBZyYkWOFYm44bAweKonTb+M/Z7W+WOxPG0oTIinqFbOBjtxxUlxo8TW1rBbbYUguUnIC/e2nJ&#xd;&#xa;/E+tLf2E8l2l7Yzxw3Ij8omVC6lM56AjnIHOarHSL+5vLS5vr9Ha2l3hIoyqEYI6Ennnr6Vt1zdh&#xd;&#xa;bav9q1NrSeC3ia8chZoGYtwvIO4cf4Veh0Yr9qmnuXlu7qHynY/cUc/dXsOemakbSlk0OHTpJCTF&#xd;&#xa;HGocDGWTBBx6ZAqpNpmrXctt9svrVooZ0mKx25Unac4zuNO8T2X9qQW2nbHYSzq7lRgBFPzHPQHB&#xd;&#xa;49a2IoxFEka52ooUZ9qyNOFxpd09g9u32BpP9GmB3HLfMQwHTktycDgCjVxcanJ/ZkVuxtSwW6mJ&#xd;&#xa;24UjOFz1PTkZ7itqiiiiisfwr/yAYv8ArrN/6NetiisfX/8AXaR/2EE/9Aetiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiisfTP8AkYda/wB6H/0XWxRRWPon/H/rP/X5/wC00rYoooooooooooooooooooorHu/+Rq07&#xd;&#xa;/r2n/mlbFFFMl/1T/wC6azfC3/Itad/1wWtWiiiiiiiiiiiiiiiiiiiisfwr/wAgGL/rrN/6Neti&#xd;&#xa;isfX/wDXaR/2EE/9AetisSDV77UYVudKsFe2YcNcyGJifYAHI6c/WrlneXDGSO/tfs8ka7y6ndGR&#xd;&#xa;7MQOfwqppviXTr13ja6t45PPaKNPNBMgBwpH1q7Pq+nWwBnvYIwWZPmcD5l+8PqM0+1mWW4uNl0k&#xd;&#xa;ygqRGoH7sFQeT3z1/GoptZ0yBUaa/t0D52lpAM4OD+R4q1bXMF3As9tKksTZ2uhyDg4qpPrel20z&#xd;&#xa;Qz6hbRyIcMjSAEVcgniuYVmgkWSNxlXU5Bo86LzzB5i+aF37M87c4zj0zSJcQyJI6SoyxsVcg/dI&#xd;&#xa;6g/SqGq37RWVpcWcilZriFAwwQyMwBx+BqQa5pTTiAahbGUtsCeYM7s4xj1zVm7vLaxiEt3PHBGT&#xd;&#xa;tDSNgZ9P0ptnf2l+rNZ3MU4Q4YxsDis248S2Vrrx06eaCONYd7StIBtfONhHrjmnf2nNqN4INJaJ&#xd;&#xa;7baGkvFbcEbP3QMYJxjv0Oavaj9sSES2O1njOTE3AlHpnt6/hRpt59uso5ioSQjEsecmN+6n3FW6&#xd;&#xa;Kx9M/wCRh1r/AHof/RdbFFFY+if8f+s/9fn/ALTSrWpalHpwhDRSyyTvsjSJcknBP5cVV+164nzS&#xd;&#xa;6ba+WvLeXcFmx3wNvJ9qdqmuQ6dY21xKBGZ3QCOY7GAJG4kewOTU0OuaVO5WHULZ2CliFkBwAMk/&#xd;&#xa;lSDU7O8EZs9SgwJlVtpDb85+T2J/pVqe8trYkTzxxkIZMM2PlHU/QZFRWeqWF/IyWd5DO6jJEbgk&#xd;&#xa;CpLy+tbCNZLy4jgRjgNIwAJqOz1Swv5Gjs7yGd1GSsbgkD1q2SFBJOAOSah+2W32dLjz4/Jkxsfd&#xd;&#xa;w2eBg+9PeaJJY4nkVZJM7FJ5bHJxWWurJb6nqSX1xHDbQGIRlyFALKSefwq/Z6hZ34c2dzFOExu8&#xd;&#xa;tgcZqG41vS7Wdobi/t4pU+8jyAEUzW9Wi0nTWu2KMcgIrNjeT6fhk/hSprmmSxyvDf28nlLubbID&#xd;&#xa;gdOfxIo0qXULqE3N7GLYyKNtuOSnuSQDn29qjsb27jvzYagqBtgMM4OPP654xwQBkgZ61q0Vj3f/&#xd;&#xa;ACNWnf8AXtP/ADStiiimS/6p/wDdNZvhb/kWtO/64LTr3VHjvTYWds0935Yk+b5YwpJ+83OOh7Uy&#xd;&#xa;O81eORTd6dCISQGMExkcZ4HG0cevPSkvtfs7DVobK4nhjDxszu8gGwjGAR75P5VOuuaU0LzLqFsY&#xd;&#xa;kIDOJBgE9AfyNPt7uG6uke3vopYniLLEmDuw2N+fTtTrjVLC1Dm4u4YtjhG3uBhiMgfXHNOs760v&#xd;&#xa;0Z7O4inVTgmNgQDUd3q2n2Moiu72CCQjcFkcA49f0qa0vLa+iMtpPHPGDtLRtkZ9P1p800VvH5k0&#xd;&#xa;ixpkDcxwMk4H6mhpokmSFpFEsgJVCeWA64/MULNE80kKyKZIwC6g8rnpn8qx9N162GmQS6newRTS&#xd;&#xa;NJjewXIDso4+grXt7mG6gWe3lSWJs7XQ5B7daqQa5pdzMsMGoW0kjnCosgJJqvrGv2+lX1nbSvEP&#xd;&#xa;Pb94Wfb5a9m+mRin3Wtw/YfO0xor6ZnEccaSffPG7pnoDk+1WrSO8Fs/2qdTNISw2qMRZH3R/ewe&#xd;&#xa;561W0++uvtstjqCIkiKPJlDf8fA53MBjgjjIGcbq1KKx/Cv/ACAYv+us3/o162KKx9f/ANdpH/YQ&#xd;&#xa;T/0B62KwLLRzBbL/AGDqf2ezf5wvliYMemQxPTAHHtTtGv786rd6VqPlyvAvmLMvG9CcDK444p3h&#xd;&#xa;yGPyr4+WmRfz4O0cfPUXhuyt/M1S4KbpJb6ZW3cjAc4wO3WrGlDGva2B/wA9If8A0UKr+E7G3XTJ&#xd;&#xa;J/LDSTTyly3PSRgMenFV7m6lsD4lntiEeHymj4yAfLHatqO2sdNsAGWNIIV5eTnA9yaq+Ev+RZsP&#xd;&#xa;+uf9TTNaL2WoW1/CNu5WhmkIyAu1ig9vnIH44rBnv73SrB45f3El55Mm2RQC8jk+djP1HHbNbPiK&#xd;&#xa;ygTQ7OwVSLcXNvCBuOdu4Dr9KuatbQwaBeiONR5dq4U45GEOOag+2yra2FnbW8dxdSW6y7Zm2rtA&#xd;&#xa;AJzg85I7VXs2vP8AhKoVu7WC2/0OQhYZNwb505PApZI428fIGRSDpxJyO/mVZ0FQt3rAUAAXp4H/&#xd;&#xa;AFzStmsfw79zUf8AsITfzrYorH0z/kYda/3of/RdbFFFY+if8f8ArP8A1+f+00qfV7Gx1AW8N621&#xd;&#xa;/MzDhypL4PT14zxVDUItdsbOS7j1RLnyR5jRPbqgZRyRkZxxTNUuRqPh3Trt4lUzT277eu3Lrxmo&#xd;&#xa;tZsbe48XaPE8YCbJXwvy5IwR0q9r0aRnTNiKudQi6DH96o9StIrvxXpomUsI4JJFGcchk6+tM8Ro&#xd;&#xa;sV7onlqE3Xyg7RjIwasaeovNY1KW4AdreQQR56BNqt09ck81FbS20njGVbZ42MdlskCY+VvM6H3r&#xd;&#xa;cZQ6lT0Iwa5B1uyn9lRxuYrWSVkjC8qiKDCfXBYH64q1ol42ra9Ibh1kaxgjKbeNkjriQHHuMY7V&#xd;&#xa;YsrOCbxZqtxIm6SNIlXJ4wV54/CpplWPxVYqihQbaYkKMZ5Sokvb6/X7TY6ZaS27k7Hml2ucHByN&#xd;&#xa;p7g96zTl/h1ukALc9ecHza1vFMUaeHbwoiqcL0GP4hW1WPqf/Iw6L9Zv/QK2KKx7v/katO/69p/5&#xd;&#xa;pWxRRTJf9U/+6azfC3/Itad/1wWm3um291qn2m3ufI1OOIAOPm2oSeqZwc/MKpX0mt6RLb3Ml7He&#xd;&#xa;2hcJMjRCMjcQoxjOeTn8KtX0aN4q03cinNvPnI68pUNlY28nizU5mjG6KOFVH8PIOeOnYVPtVfF8&#xd;&#xa;aqAANPbgD/poKh0uzgk8Sa1cum6QSJGMnIx5aHp/WpSBF4sVYwFX+z2OAMDPmLS+HI459GhvJkV5&#xd;&#xa;roedKzDOWI5x6DjpTPC8sMyanJbsjxNfOVZOhG1elaGrWy3emzRFS5A3oB1LL8y/qBXOLeXs08Go&#xd;&#xa;Sg/6L5CPJtwqBh/pGfoVGfStXw5Il4L3UAwd5rho96nhkRiEx+B61D4SsbdNH87ywzzSyM5bno7D&#xd;&#xa;jPTgUW95Fp13r9xKG8mCWM7VHQeWvQfjVLxC2qrod2ZdNsoUCcyRzksvI6DaKueI0VtZ0LcoOblg&#xd;&#xa;cjqNtWNSRU13RAihR5s3AGP+WRrZrHvv+Ro0n/rjcf8AslbFFY/hX/kAxf8AXWb/ANGvWxRWPr/+&#xd;&#xa;u0j/ALCCf+gPWxWXP4d0q4maWW1y7nJIkYfoDVuysLawi8q1iEaZz1JP5nmoptHsJ71bySDM6kMG&#xd;&#xa;DsOQcjgHFWLe2hthIIUCCR2kbnqxOSaIraGKeaaNAsk5BkbP3iBgfpRbW0NpCIbdAkYJbAPckk/q&#xd;&#xa;TQlrAk08qxjfOQZD13YGB+lc1D4evoJ1litNLDqcgmWc/oTiuh0yyTTtPhs42ZliXaC3U1Jc20N3&#xd;&#xa;AYbhA8bEEqTjoQR+oFJLaQTzxTyxK8kO4Rsf4c4z/IUtxbQ3Sos6BwjrIoJ6MDkH86dNEk8EkMq7&#xd;&#xa;o5FKsvqCMEVXutMs7u2jt54Q0UeNo3EYwMDkHNR2Oiadp9wZ7W38uUqU3b2bg4OOT7Cpr7T7XUIx&#xd;&#xa;HdxCRQcjkg/mPrVJtFNtdR3OmSmFo4xF5LHMbrkk5PJzz69hVzUYLm5hENvMIFc4kkH3wP8AZ7Z+&#xd;&#xa;van2NqljZQ2yMWWJAu5urYGMn3qxRWPpn/Iw61/vQ/8AoutiiisfRP8Aj/1n/r8/9ppWjd2sF7A0&#xd;&#xa;FzGHjbqMkfqKoR+G9JjkWRLTDKQRmVzyPxrSlgimgaGRAY2G0r04qjaaDplldLc29tsmQEKxdjjP&#xd;&#xa;XqauT20Nz5fnIH8pxInPRh0NDW0LXSXLIDMilFbPQHGR+gpLmzt7p4XnjDtA4kjJJ+Vh3rJ1zRpd&#xd;&#xa;Quklht7KQBMEzPIpzn/ZOKl0jSprW5+03IgSRYfIRLcsV2Zzkluc5rYqFbaFbp7lUAmkUIzZ6gZw&#xd;&#xa;P1NJbWkForLbxKgZi7Y7knJ/U0sdtDFcTTogEs23zGz97AwKGtoXukuWQGaNSitnoDjI/QVSuPD+&#xd;&#xa;l3M7TTWuZH5JEjD9AcVbt7K3tbNbSCILAoICckcnPeq9romn2RkNtBsMi7GJdm4/Emk0qxuNNhNq&#xd;&#xa;bj7RbooETSffB9DgYx09+tJp+myw3ct9d3BluJUClRjZHjPC8Zxz3rSorHu/+Rq07/r2n/mlbFFF&#xd;&#xa;Ml/1T/7prN8Lf8i1p3/XBas3+l2eohftcPmbOnzFf5EVDa6BplpOs8FttkXoTIzfoTirN7YW2oQi&#xd;&#xa;K6i8xAcgZI/UVHp+lWWmGQ2cHlGXG87i2cdOp9zU/wBmh+1i62Dzwnl78/w5zj86IraGGWaWNArz&#xd;&#xa;MGkOfvEDA/QCg20JuxdbB5wTy9+f4c5x+Yrnr7w9cT3sssVppxRmyC8swP4gHH5VsaTYNYwS+YVM&#xd;&#xa;s8pmkCfdViAML7cVfqsLC1FrPbCIeTOXMi5PzFvvfnmpLeCK2gSCBAkcahVUdgKS2tobSAQ26BI1&#xd;&#xa;JIUH1JJ/UmkS0gSSeRYxunIMh67iBgfoBWcfC2jMMNZ5HoZX/wAa0rq1hvIGhuIw8bDBHT9RVGbQ&#xd;&#xa;bQ6Y9jbb7ZGcSB0YsysCDkFs/wB0VZtEvY7Z0uHiklUkRuM/MuOC3v644qHTdNktrie7ubhpri4C&#xd;&#xa;7hgbY8Z4XjOOe/PArRorH8K/8gGL/rrN/wCjXrYorH1//XaR/wBhBP8A0B62KKKKiS4ie4kgVsyR&#xd;&#xa;gF1x0Bzj+RqWoo7mGWeaGNw0kJAkX+6SMj9KlooqK5uYbSAzXDhI1IBY+5wP1IoeeKOeOFmxJKCU&#xd;&#xa;XHXHX+dS0UUhIGMkDPFIzKoyzAD3NQfb7X7ELzzR9nOMPg9zjp161OrK4yrAj2NOoorH0z/kYda/&#xd;&#xa;3of/AEXWxRRWPon/AB/6z/1+f+00rYoopksixRPJIcIilmPoBRHIssayIco4DKfUGm3E8VrbyTzu&#xd;&#xa;EijUszHsKkBDKCOQeRS0UVFBcw3HmeS4fynMb47MOooguIrlC8LblDFScY5Bwf1qWiikBBGQQR7V&#xd;&#xa;FJdQRSxxPIA8jbVXqScZ/kKIbqCdnWOQM0blGHQhh1FTUUVj3f8AyNWnf9e0/wDNK2KKKZL/AKp/&#xd;&#xa;901m+Fv+Ra07/rgtatFFRTXEVuEMrbd7hF46segqWoprmGB4llcK0z7EB/ibBOPyBqWiimyOsUbS&#xd;&#xa;OcKoLE+gFRfa4PsX2zzB9n8vzd+D93Gc/lUkUqTQpLG25HUMp9QeRT6KSgEEZBBHqKiS6he4aBJA&#xd;&#xa;0qoHKj0Jx1/Cm295b3LSLDKGMbmNh0IYdRzViiisfwr/AMgGL/rrN/6NetiisfX/APXaR/2EE/8A&#xd;&#xa;QHrYrGGttHpl1PPEPOtZhbyBPulyVAIzzj5x+tX5rr7FYC4vSisqrv2ZxuOBgfUnAqib7VLcfary&#xd;&#xa;3gWy+8yoT5sS+rduB1xnpxmprDUxfahcwx7WgjhhljcZywcMf6ComvdQvXZtJS2MCEr5lxuAcjg7&#xd;&#xa;cehBBz3FQaB9p/tbWftnlef5kW7yc7f9WMYzz0rerAuNS1Wwge7vP7Oe3iG6RYWcuR7Z4zWpfXy2&#xd;&#xa;kcYVTJPMdsMY6uep/IZP4Vg+IP7a/siT7YNP8jzIt3lF93+sXGM8da0jfahDrsFncJam3uPMMbR7&#xd;&#xa;t4C4xnPHcVZ0u9e+S6Lqq+TcyQjb3CnANVV1l11HWIZIgYtPiSQbPvPlCxH6VHHfawyrceXYyQMA&#xd;&#xa;4ijZvNKnoBnjdUPiVr1m0hrZIVzdoQs2ch9rYBx265qCdbrVNbg0fWYrVo0j+2DyNxDYO3ad3bk1&#xd;&#xa;05VWQqQCpGCPasXS4ItL1u5061jVIJYxdYAxtYnZge3y5rcoorH0z/kYda/3of8A0XWxRRWPon/H&#xd;&#xa;/rP/AF+f+00q1q16+nWwutqtCjASj+LBOBt7ZyR17ZoF68msNZRKu2GMSSs3Uhs7dv4g5zUE17e3&#xd;&#xa;U8kekpbsIWKSyXG4Lu7qMc5Hf6inDVD/AGfeO0YW7s42aSI9AQCR+Bxke1POprFpdtdyoTJOqbI0&#xd;&#xa;6u7DIUZ/rWPr5106FfGddPEJhbdsL7gMdu2a6SD/AFEf+6P5VBqD3iRKbE2ofd832gkDHtjvVWw1&#xd;&#xa;G4N49nf/AGfzli84NbklNmcYOec5pgvNUvh5+mR2gtW+41wWy4/vDb2PvzVXQvt/2DUvKFt9s+3y&#xd;&#xa;Z3bvLzxn3qSPW7n+xVu5YofO+1i3ZVzt/wBZsJHetLVrt7DSrq7jVWeGJnAboSBVKXVbmSGxjtUh&#xd;&#xa;W5uoPO3TZEajAyOOc/MMVJb3Oqt5kM0Ns0xQtHNExMQPZWz82foOlZnhZtVTR7ZiLL7IN5PL+Z95&#xd;&#xa;vw61a8LRx3ds2tvGq3V/8z4H3QPlwO+PlBpPEtpDB5euIg+1WXK8cOCcYPfAya36KKx7v/katO/6&#xd;&#xa;9p/5pWxRRTJf9U/+6azfC3/Itad/1wWp5r14NWt7V1Ux3IYRleoZQSc+2MYptjqJuku7hwsdtC7I&#xd;&#xa;pOd2UJDE+3HFVxe6pOPtVpbwNZfeVWJ82RfVe3I6Z9eadPrUbWtpcWZWVJ7pLds5+XJwfxFT39+0&#xd;&#xa;Mq2trH513IuVXsi9N7f7IOM45rIvv7V/tHSP7QFl5f2wY8gvnOx/Xt1rpqztQk1NJwLJrAR7eftD&#xd;&#xa;MGz+HbpUdrrKGwuJ7oKr20vkSbOVZ+MbfYlgOaq3769JYXL+XYRwtEx2OX8xVweDjjOPwzTftV/Z&#xd;&#xa;eFLK6sltmSGyWSUTbskBAflx+PWrVtq0s02ko0aAX1q0z4z8pAU4Ht8xqzqt69ilsyKredcxwnd2&#xd;&#xa;DHBNVbjUL+W+nt9PFogtiFkN0WG4kBvlx2wasQzahLZTK0UC3ScK+T5L98jvjt9a5vTr3WdO8IQX&#xd;&#xa;caWD20UIYBi+8jP5ZrptI0u30iwS0th8q8sxABc+p9+BVHxBBFbSW+spGpurV1QEj7yu2zB+m8ke&#xd;&#xa;9blFFY/hX/kAxf8AXWb/ANGvWxRWPr/+u0j/ALCCf+gPWxXO3mlXknii3eOMf2S677lNwCvL82GK&#xd;&#xa;9zkJz7D0rY1KyTULKS2kYqGKkEdipDD9QKz5Rqt9E+n3NmkUUimOW5EgIdejbVzlSRnGc496fpOm&#xd;&#xa;Pp+o3O1T9m+zwQxMWBJ2Bgc/mKgtBqekwmzg037XGru4mE6pu3MW6HnjOPwqfRbS9hvtRuL4IGuX&#xd;&#xa;RlKdMBAMdT06e9XtQgmubGaG3nMEzrhJR1U+tcpqGiyXNjNDb+FoIJnXCyiePKn1rodVtZ3ksru3&#xd;&#xa;j86SzcuIdwXzMqVxk8DGc/hWfqq6zqtg1uNPS1XejNvmVy4Dg4BB4xjPNWr5g/iXSChDAJPnBzjh&#xd;&#xa;ajhXUdKluY7fT/tkc07ziQTKmNxztwfT1pmk2Gpxarq93ciJHukj8lgMqCFIwRnPGQPeqkmlTysy&#xd;&#xa;xaFDaXLE4vkkTKN/fAHPvitbUrG4ls7IofOns5UmIJx5pVSMZPTOetZV5dTWGqQ67qVq1shT7GYg&#xd;&#xa;wkIBJbfle3GMV0zSosJlLDYBnPtWNo1zHq+q3Gq25YQpGLVQykFsHdu56fexj2rdoorH0z/kYda/&#xd;&#xa;3of/AEXWxRRWPon/AB/6z/1+f+00rRvLdLq0lhdFcMv3W6E9R+uKyvC1jfWti76sC1874aRmDMUH&#xd;&#xa;3RkfU1IYb3S5pjYWn2yG4kaVk8wIyOevJ6g8YHbFH9mzGw1KR8G8voiGQHCg7SFH5HBNJc6fcPpG&#xd;&#xa;nIigz2TRSmPI+cquNueg+tVtVOt6pplzaJpq2pkjI3PMr7v9kYIwT61vxKViRT1CgGsfW7CW4uo5&#xd;&#xa;jZLqMATb9ldwoVs535PHTiqukaVLFq0040qPTYHtTFtSRW3Nuznj2qeybVdNs4bCPSvPWBBGs/2h&#xd;&#xa;FDY43beo+lWNCtrmxguhqDRiWW6eQMvAYHHIGePpWfZWUl74elji++t9JKoP8W2Ytj8cdak1Q61q&#xd;&#xa;mmXNommramSNhueZX3cfdGCME+tTXNlcf2TY28lhDfJFEqyWzkA7gAMhjxxz+dN0bTp4L77Qtoum&#xd;&#xa;2wQq1ojhg7f38jj2p2mQ39hCmmGy3267h9qEqgcknO3r3xUfhmeKyVtBdibiyH39pAkB5yP++sY9&#xd;&#xa;qTxFfRXU0egx58+7xl8HEYBzk+udpFdDRRWPd/8AI1ad/wBe0/8ANK2KKKZL/qn/AN01m+Fv+Ra0&#xd;&#xa;7/rgtN8S2d1d6Yx04Yv4yDC4YKy5I3YJ6cZqxY2ITRktZl2PJFifaeS7D5zn1JzzVSP+1bKJLC3t&#xd;&#xa;EljQCOK6MgAReg3LnJwOuMZ9qZJohtrCytrPc4ivUuJCzDpuyx/+tU9/BdwaqmpWlv8Aam8gwGHe&#xd;&#xa;EIy27dk/TGPeqs8WrahfafNLZpbQ29xveMyK7H5WG7IPTnGMZroK5q+0yU3szz6PHq3mOWSWSRVM&#xd;&#xa;a9kw3Ycn8abZ6LcHRL22Nslm0l4LiKEMGAUFCBkcc7SKtXU+tXtrNbJpa2rSIy+a86uBx0wMHnp7&#xd;&#xa;ZovI2tvBctrLgTR6eUZcgncI8YqG3trlbDRL+2h897ezEZh3BCdypzk+m39adexaxqclmz2kdtFD&#xd;&#xa;dRSPEzh2YBslgwOBj0xT9Xs5Z7stLo1vqceP3bFlQxjuDu685PFWtEs5rWGbzIhbRyNmO1UgiAYw&#xd;&#xa;QCOOTlvxrLOn6j/Yn9g/Yx5Ij8r7Z5q4x13bOv4Vr6Jq8Os2IuYVZCDteNuqn09+vWqWu3UV5dW+&#xd;&#xa;hox8+4ZZC+CQgQ7+frsIreoorH8K/wDIBi/66zf+jXrYorH1/wD12kf9hBP/AEB62KKKKKKKKKKa&#xd;&#xa;yh1KsAVIwQe9VrLTbLT9/wBitYoN+N3lrjOOn86t0UUUVX+w2v2QWnkR/ZxjEePl4Oen1qxRRRWP&#xd;&#xa;pn/Iw61/vQ/+i62KKKx9E/4/9Z/6/P8A2mlbFFFFFFFFFFVb3TrPUAgvLaOcJkqHXOM1YjRYo1jj&#xd;&#xa;UKiAKqjoAO1OoooqOSCKV43kjVmibchI+6cYyPwJoigig3+VGqeY5dsD7zHqTUlFFY93/wAjVp3/&#xd;&#xa;AF7T/wA0rYoopkv+qf8A3TWb4W/5FrTv+uC1q0UUUUUUUUVTl0uwmvFu5bSJ7hSCspX5gR05q5RR&#xd;&#xa;RRUYgiFwZxGvnFQhfHJUHIH6mmwW0Ft5nkRLH5jmR9oxuY9SfepqKKx/Cv8AyAYv+us3/o162KKx&#xd;&#xa;9f8A9dpH/YQT/wBAetiiiiiiiiiiiiiiiiiiiiiisfTP+Rh1r/eh/wDRdbFFFY+if8f+s/8AX5/7&#xd;&#xa;TStiiiiiiiiiiiiiiiiiiiiise7/AORq07/r2n/mlbFFFMl/1T/7prN8Lf8AItad/wBcFrVooooo&#xd;&#xa;ooooooooooooooorH8K/8gGL/rrN/wCjXrYorH8Q/L/ZszcRQXiySueiLscZJ7DkVL/wkOjf9BS0&#xd;&#xa;/wC/y0f8JDo3/QUtP+/y0f8ACQ6N/wBBS0/7/LR/wkOjf9BS0/7/AC0f8JDo3/QUtP8Av8tH/CQ6&#xd;&#xa;N/0FLT/v8tH/AAkOjf8AQUtP+/y0f8JDo3/QUtP+/wAtH/CQ6N/0FLT/AL/LR/wkOjf9BS0/7/LR&#xd;&#xa;/wAJDo3/AEFLT/v8tH/CQ6N/0FLT/v8ALR/wkOjf9BS0/wC/y0f8JDo3/QUtP+/y0f8ACQ6N/wBB&#xd;&#xa;S0/7/LR/wkOjf9BS0/7/AC0f8JDo3/QUtP8Av8tH/CQ6N/0FLT/v8tH/AAkOjf8AQUtP+/y0f8JD&#xd;&#xa;o3/QUtP+/wAtH/CQ6N/0FLT/AL/LR/wkOjf9BS0/7/LVXQ7mC71rWZraVJomaHDocg/J61u0UVzm&#xd;&#xa;n6pYWOp6xHd3kEDtd7gsjhSR5a881of8JDo3/QUtP+/y0f8ACQ6N/wBBS0/7/LR/wkOjf9BS0/7/&#xd;&#xa;AC0f8JDo3/QUtP8Av8tH/CQ6N/0FLT/v8tH/AAkOjf8AQUtP+/y0f8JDo3/QUtP+/wAtH/CQ6N/0&#xd;&#xa;FLT/AL/LR/wkOjf9BS0/7/LR/wAJDo3/AEFLT/v8tH/CQ6N/0FLT/v8ALR/wkOjf9BS0/wC/y0f8&#xd;&#xa;JDo3/QUtP+/y0f8ACQ6N/wBBS0/7/LR/wkOjf9BS0/7/AC0f8JDo3/QUtP8Av8tH/CQ6N/0FLT/v&#xd;&#xa;8tH/AAkOjf8AQUtP+/y0f8JDo3/QUtP+/wAtH/CQ6N/0FLT/AL/LR/wkOjf9BS0/7/LVIahZ3/iq&#xd;&#xa;xNndRThLabd5bhsZKdcV0FFFNkGY2A64Nc/oWrafYaLZ2l5ewQXEMQWSKSQKyEdiD0q//wAJDo3/&#xd;&#xa;AEFLT/v8tH/CQ6N/0FLT/v8ALR/wkOjf9BS0/wC/y0f8JDo3/QUtP+/y0f8ACQ6N/wBBS0/7/LR/&#xd;&#xa;wkOjf9BS0/7/AC0f8JDo3/QUtP8Av8tH/CQ6N/0FLT/v8tH/AAkOjf8AQUtP+/y0f8JDo3/QUtP+&#xd;&#xa;/wAtH/CQ6N/0FLT/AL/LR/wkOjf9BS0/7/LR/wAJDo3/AEFLT/v8tH/CQ6N/0FLT/v8ALR/wkOjf&#xd;&#xa;9BS0/wC/y0f8JDo3/QUtP+/y0f8ACQ6N/wBBS0/7/LR/wkOjf9BS0/7/AC0f8JDo3/QUtP8Av8tH&#xd;&#xa;/CQ6N/0FLT/v8tH/AAkOjf8AQUtP+/y03wzG8WhwrIhVjJK2CMcGRiD+IINatFMljjmjaOVFdGGC&#xd;&#xa;rDIP4VV/sfTP+gdaf9+F/wAKP7H0z/oHWn/fhf8ACj+x9M/6B1p/34X/AAo/sfTP+gdaf9+F/wAK&#xd;&#xa;P7H0z/oHWn/fhf8ACj+x9M/6B1p/34X/AAo/sfTP+gdaf9+F/wAKP7H0z/oHWn/fhf8ACj+x9M/6&#xd;&#xa;B1p/34X/AAo/sfTP+gdaf9+F/wAKoa3Z6dY6VNOumWjEbUH7pRjcwXPTtnNU/Dei2VmLnTLq2guL&#xd;&#xa;i3ff5jxKdyNnb17/ACnitv8AsfTP+gdaf9+F/wAKP7H0z/oHWn/fhf8ACj+x9M/6B1p/34X/AAo/&#xd;&#xa;sfTP+gdaf9+F/wAKP7H0z/oHWn/fhf8ACj+x9M/6B1p/34X/AAo/sfTP+gdaf9+F/wAKP7H0z/oH&#xd;&#xa;Wn/fhf8ACj+x9M/6B1p/34X/AAo/sfTP+gdaf9+F/wAKnt7S2tQwtreKEN1EaBc/lU1FFVJdMsJp&#xd;&#xa;GkmsbaR26s8Skn8cU3+x9M/6B1p/34X/AAo/sfTP+gdaf9+F/wAKP7H0z/oHWn/fhf8ACj+x9M/6&#xd;&#xa;B1p/34X/AAo/sfTP+gdaf9+F/wAKP7H0z/oHWn/fhf8ACj+x9M/6B1p/34X/AAo/sfTP+gdaf9+F&#xd;&#xa;/wAKP7H0z/oHWn/fhf8ACj+x9M/6B1p/34X/AAo/sfTP+gdaf9+F/wAKP7H0z/oHWn/fhf8ACj+x&#xd;&#xa;9M/6B1p/34X/AAo/sfTP+gdaf9+F/wAKP7H0z/oHWn/fhf8ACj+x9M/6B1p/34X/AAo/sfTP+gda&#xd;&#xa;f9+F/wAKP7H0z/oHWn/fhf8ACj+x9M/6B1p/34X/AAo/sfTP+gdaf9+F/wAKP7H0z/oHWn/fhf8A&#xd;&#xa;CpINPsraTzLe0t4nxjdHGqnH1AqzRRRVSTS9PlkaSWxtndjks0Kkk/XFN/sfTP8AoHWn/fhf8KP7&#xd;&#xa;H0z/AKB1p/34X/Cj+x9M/wCgdaf9+F/wo/sfTP8AoHWn/fhf8KP7H0z/AKB1p/34X/Cj+x9M/wCg&#xd;&#xa;daf9+F/wo/sfTP8AoHWn/fhf8KP7H0z/AKB1p/34X/Cj+x9M/wCgdaf9+F/wo/sfTP8AoHWn/fhf&#xd;&#xa;8KP7H0z/AKB1p/34X/Cj+x9M/wCgdaf9+F/wo/sfTP8AoHWn/fhf8KP7H0z/AKB1p/34X/Cj+x9M&#xd;&#xa;/wCgdaf9+F/wo/sfTP8AoHWn/fhf8KP7H0z/AKB1p/34X/Cj+x9M/wCgdaf9+F/wo/sfTP8AoHWn&#xd;&#xa;/fhf8KP7H0z/AKB1p/34X/Cj+x9M/wCgdaf9+F/wq4oCqFUAADAA7UtFFFFFFFFFFFFY9/8A6Vr9&#xd;&#xa;hbJybYNcSg9ChDKPqd1JfstjrtpdZEME6slzI33SRjywSenJbHrWzRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWDe6NcrdXOpRatcxy+WQAEQ&#xd;&#xa;gKCWC8jpk/Wq1ro9zrWkWc19q9zIsqRzmPYgGcA9hmunoooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooooooooooooooooooooooooooooooooooooqC9/48bj/rm38qq+Hf8AkXdN/wCvaP8A&#xd;&#xa;9BFaNFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFQXv/Hjcf9c2/lVXw7/yLum/9e0f/oIrRooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooooooooooooooooooooooooooqC9/wCPG4/65t/Kqvh3/kXdN/69o/8A0EVo0UUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVBe/&#xd;&#xa;8eNx/wBc2/lVXw7/AMi7pv8A17R/+gitGiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiioL3/jxuP+ubfyrB0TQbebRLCVrm/UvboxCXbqBlR0AP&#xd;&#xa;Aq7/AMI7bf8AP3qP/gZJ/jR/wjtt/wA/eo/+Bkn+NH/CO23/AD96j/4GSf40f8I7bf8AP3qP/gZJ&#xd;&#xa;/jR/wjtt/wA/eo/+Bkn+NH/CO23/AD96j/4GSf40f8I7bf8AP3qP/gZJ/jR/wjtt/wA/eo/+Bkn+&#xd;&#xa;NH/CO23/AD96j/4GSf40f8I7bf8AP3qP/gZJ/jR/wjtt/wA/eo/+Bkn+NH/CO23/AD96j/4GSf40&#xd;&#xa;f8I7bf8AP3qP/gZJ/jR/wjtt/wA/eo/+Bkn+NH/CO23/AD96j/4GSf40f8I7bf8AP3qP/gZJ/jR/&#xd;&#xa;wjtt/wA/eo/+Bkn+NH/CO23/AD96j/4GSf40f8I7bf8AP3qP/gZJ/jR/wjtt/wA/eo/+Bkn+NH/C&#xd;&#xa;O23/AD96j/4GSf40f8I7bf8AP3qP/gZJ/jR/wjtt/wA/eo/+Bkn+NH/CO23/AD96j/4GSf40f8I7&#xd;&#xa;bf8AP3qP/gZJ/jR/wjtt/wA/eo/+Bkn+NVTYjTfEGmLBc3bpN5odZbhnBwvHBNdFRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUF7/wAeNx/1zb+VVfDv/Iu6b/17R/8AoIrRoooo&#xd;&#xa;ooooooooooooooooooooorH1L/kYtG/7b/8AoArYoooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooooqva3kV09wkW7NvL5T5H8WAePzFLe/wDHjcf9c2/lVXw7/wAi7pv/AF7R/wDoIrRo&#xd;&#xa;qlqN8bJrQCPf9ouFh6425BOf0q7RRRRRRRRRRRRRRRRRRRRVTUtQg0y0Nzc7vLDBflGTknAq3WPq&#xd;&#xa;X/IxaN/23/8AQBWxRRVOyvjdXV7D5e37LKI85zuyobPt1q5RRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRWP4nuJLfTY/LDsJJ44nRMbnRmwyj0JHHasy1gaC/tW03R76zJlAnkmcMpiwcjlz32&#xd;&#xa;9u1bOrp5MR1COdYJbdTl3J2MvdWHPGccgZ4qCx/4m1y13cEr9mk2x24ODGwAOWx1bnpkjGO9Z+i6&#xd;&#xa;Fp0l3qReByYbwqn75xgBEPrzye9Z8kv9oS6s17p15fNb3EsMUsLBVjQdFIDDOMk9D1qMPff8K/tv&#xd;&#xa;tLvG/nxLEwwCI8jb09vWt3UNEtLTTrq+Ake9hieYTmRuZACd23O3qM4xj2qSe5muRpVkzlVvoWeZ&#xd;&#xa;x1IVVJHtnJHHPpVTUtGsNPutKmtYWRzfIpJlduMN2JPpUmrWjSajI97YXOoQtjyBbvt8oYG4N8y5&#xd;&#xa;yee9aGhNF9kkSFpVWOTb5EuN0HAOwnnPXPU9a06KKKKKKKKKKKKKKK5G5ZL3VtQW70y9vxBKI42g&#xd;&#xa;faEXaDt+8ueST+Na3h9LgW91HNbzW9uJMW8UpBZU2jPIJ7571WubqXRXa0inR4igaPzc/wCjrnAy&#xd;&#xa;QOV7Z5OSO1U/F2mQQ+G8uXllWZGMjMQWZmUMcDjn06DtVrV7K30TSZJNPikVpZIo3USMxdS4BUbj&#xd;&#xa;xkEjt1rEuoZINb0k6Vpd5ZTGVgxmcPuTjdjLN2zW2tgmpeItVjupJGt0EP7kMVBO3rkc+vfvU1vb&#xd;&#xa;RaX4gt7SyDRwTwSPIhctuZSoByxJHU9KZYWNvr9mmoairSPISERZGQRgEjA2kZ6Z59ag0+ykhj12&#xd;&#xa;00thC63CiMsS2PkQnk596gWGytmEw0vUdNKn/j6kk3LH7kFzn06HrXXUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUVWvrOO+t/KkJBDB0cdUccqw+h554qpb6VOs6SXmpT3ixnciOqoFbsflAzx&#xd;&#xa;ng8c1aubJLq4ieZ2aKPkRfwluzHueMjHTmmy2Ctex3UMjQyDiTaBiRfQg/zHNQS6VILt5rO+ltFk&#xd;&#xa;bfLGiqwdu5O4EjgAcelV7/Rmjiu5bC9ls0lDyyxoqsJHI5YlgSM8Dj0qvpujW974R0+23PErJFOx&#xd;&#xa;ByS2Ae9bt5brd2c9szFVmjaMkdQCMVUuNKWWC2WKd4J7ZNkU6gFlGADweOcDtVf+wTLcW9xeX89z&#xd;&#xa;NbyiSNmCrgDPy4AA59evFT3emSy3DT2l/NZtJjzNiqwcgYH3gccelT6fYrYxON7SSytvllbgu2AM&#xd;&#xa;kDgcAdPSrdFFFFFFFFFFFFFFFZdxpMjXMk1lfzWXmndKsaKwdsYz8wOOABx6VZsrL7JC6mZ5ZpDu&#xd;&#xa;klbqxxjOOg4x0ptppsFtC6sDNJLzLI/Jc9z6D6DAqM6Rbyae1jcFprfdlFY/cA+6Mjk4x3pi6RLJ&#xd;&#xa;BLFe6hNdhtrIXRV8tgchhtAzzjr6Vl3WmSjxBpC31/NeoWlZQ6qm0hQc/KB7VvW9kkF/d3auxa52&#xd;&#xa;blPQbRjiiSySTUob0uweGN4wvYhiD/SqP9i3EPyWOq3Frbg/JCkaMF7nlgT1yaktNCtbW3u4FMjR&#xd;&#xa;3Th2BY5BwBwevbNRnRbib93e6rcXVufvwvGih/xUA9a2KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKgvf+PG4/wCubfyqr4d/5F3Tf+vaP/0EVo0UUUUUUUUUUUUUUUUUUUUUUUUVj6l/&#xd;&#xa;yMWjf9t//QBWxRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUF7/x43H/XNv5V&#xd;&#xa;V8O/8i7pv/XtH/6CK0aKKKKKKKKKKKKKKKKKKKKKKKKKx9S/5GLRv+2//oArYooooooooooooooo&#xd;&#xa;oooooooooooooooooooooooqhq2otp0duY7ZrmSeYQoiuF5IJ6njtVb+0tW/6AEn/gVH/jR/aWrf&#xd;&#xa;9ACT/wACo/8AGj+0tW/6AEn/AIFR/wCNH9pat/0AJP8AwKj/AMaP7S1b/oASf+BUf+NH9pat/wBA&#xd;&#xa;CT/wKj/xo/tLVv8AoASf+BUf+NH9pat/0AJP/AqP/Gj+0tW/6AEn/gVH/jR/aWrf9ACT/wACo/8A&#xd;&#xa;GmT32rywSRjQZAXUrn7VHxkfWodNuNYstNtbRtDdzBEsZYXMfOBjPWrP9pat/wBACT/wKj/xo/tL&#xd;&#xa;Vv8AoASf+BUf+NH9pat/0AJP/AqP/Gj+0tW/6AEn/gVH/jR/aWrf9ACT/wACo/8AGj+0tW/6AEn/&#xd;&#xa;AIFR/wCNH9pat/0AJP8AwKj/AMaP7S1b/oASf+BUf+NH9pat/wBACT/wKj/xo/tLVv8AoASf+BUf&#xd;&#xa;+NT6Xqcl9NdQT2jWs1sVDIzh/vDI5HtWjRRRRWKutXs81wtppEk8cEzQl/PRclevBp39pat/0AJP&#xd;&#xa;/AqP/Gj+0tW/6AEn/gVH/jR/aWrf9ACT/wACo/8AGj+0tW/6AEn/AIFR/wCNH9pat/0AJP8AwKj/&#xd;&#xa;AMaP7S1b/oASf+BUf+NH9pat/wBACT/wKj/xo/tLVv8AoASf+BUf+NH9pat/0AJP/AqP/GqV1JrE&#xd;&#xa;+p2N2NEcC28zK/aY/m3Lj1q7/aWrf9ACT/wKj/xo/tLVv+gBJ/4FR/40f2lq3/QAk/8AAqP/ABo/&#xd;&#xa;tLVv+gBJ/wCBUf8AjR/aWrf9ACT/AMCo/wDGj+0tW/6AEn/gVH/jR/aWrf8AQAk/8Co/8aP7S1b/&#xd;&#xa;AKAEn/gVH/jR/aWrf9ACT/wKj/xqK51rUrS2luJ9CkWKJS7t9pjOAOvetqJ/MiRwMblBxT6KKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKx9f/12kf8AYQT/ANAetiiiiiiiiiiiiiiiiiiiiiisfTP+Rh1r/eh/&#xd;&#xa;9F1sUUUUVj+Hfu6l/wBhCb+YrYoooooooooooooooooorM8Sf8i5qP8A17P/AOgmr1r/AMesP+4v&#xd;&#xa;8qlooooooooooooooooooooooooooorH1/8A12kf9hBP/QHrYooqG7leCznmiiM0kcbMsa9XIGQB&#xd;&#xa;9ahsr+O505buQrDhMzKW/wBSwGWVj2I759KbpWoDULYuUEcqsQ0W7JUZO0n6jBHsadp19/aCSTJH&#xd;&#xa;tgDlY2J5bBIbI7cgiltdTsLyUxWt7bzyAbiscgYgeuBU800cETSzSLHGgyzscAD3NMtby2vYzJaX&#xd;&#xa;EU6A7S0bhgD6cUl3e2tkivd3MUCscAyOFBP41Q07V477Vr+OG5hmtIIomV42BAJ3buR9BWj9qtxD&#xd;&#xa;HN58flSlQj7hhs9MHvmnNNEkqRNIqySZKKTy2OuB7VBb3EaWTTz3kUsaM26YYVQATweccdPwpk2s&#xd;&#xa;6ZA+ybUbWN8A7WmUHBGQevpV3r0rD1fxFZRafI1hqFpJc7kCosisTlgDxn0zW7RRRWPpn/Iw61/v&#xd;&#xa;Q/8Aoutiiiiisfw793Uv+whN/MVsUUUUUyRtkbPjO0E4rEs9W1m9s4bqHSLfy5UDrm8wcH/gFaWn&#xd;&#xa;X4vbeR2Ty5IXMcq5yFYdcHuPekOracrxob+2DygGNTKuXB6Ec85ouNW060mMNzf20Mg6pJKqkfgT&#xd;&#xa;VhriFbf7Q0qCELv8wsNu31z6VBa6pp95L5Vre288mM7Y5Qxx64FOutSsbJwl3eQQMwyFkkCkj15q&#xd;&#xa;aCeK5hWaCVJYm+66NkH8akoooorM8Sf8i5qP/Xs//oJq9a/8esP+4v8AKpaKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKx9f/12kf8AYQT/ANAetiiiiuXvBLb3Go6XFExivyoj45zKWErj1C5UkdvbNLcG40G4&#xd;&#xa;uhAjS/arcFJiuAsqRhETHcsQMD8OalvIPseg2VuA8VvLKPtbEkbFYMzkn+H5j17VY8QQxW2m+fax&#xd;&#xa;ol3Gwa2CAAvJg4XA+9349qS9Cz+ILaG9O22WJXhydoebcQV/2uMcU64VbbxBZCzUBpVK3CIOFjAY&#xd;&#xa;qxHb5uM/hUOin+077U7i8VZHt7p7WMEfKEU5HHryeaNOFtN4i1iKAxmPyYY3EeOD84I471mSm8aE&#xd;&#xa;adHE7LZNM0aBMsojAMBP1IOP72KuaLeHVteuHndZDYRRiIp/Czp+8B/FfwxUB/5EDUPrcf8Aoxq2&#xd;&#xa;dF020g0e0QQq+Y1bMg3HJGep+tY9tLI/hXR4Gdtt3OIJTn5ip3Zwex4FXPFUdnb6I42QRyO8Yj4A&#xd;&#xa;ZjvXp+Ga6CiiisfTP+Rh1r/eh/8ARdbFFFFFY/h37upf9hCb+YrYooooqK4/49pf9w/yrndAs9Xf&#xd;&#xa;QrFodXjijMKlUNoG2jHTO7mpdGfyJ9V083CXUiZnkmQBfnfIK7RnGNvr3qXwnp9tD4esnEYZ5I1k&#xd;&#xa;LP8AMQSB0z0FDXlzeySS2Ok21zCrmPzJpgjEqcHjae49ao2MclxoERkeOOZL92WF3+WRg7Yiz6Hp&#xd;&#xa;07dKtM8iXFr/AGjpcNohnQRyW8+4mTsCAo4606SG4i1G8e0trXURJIGcSzBTCdoG3GD2Ge3WreiP&#xd;&#xa;GxuwIfIuFlAniD7lVtoxtPHGMdutalFFFFZniT/kXNR/69n/APQTV61/49Yf9xf5VLRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRWPr/wDrtI/7CCf+gPWxRRRUMlrDJcw3DpmWEMI2yeA2M/yFFzaw3Sos6bwj&#xd;&#xa;rIvJGGU5B496kZVdSrKGU9QRkGqNnomn2M/nW8LCTGMtK74/BiatXVrDeQtFcRh0PuQR9CORUVjp&#xd;&#xa;1rpyMlrEUDHJLOzH8ySaivNE0++m824gJfGMpIyZ+oUj86mtNOtLJ2e2hEbOioxyTkLnGc/U81Il&#xd;&#xa;rDHdS3KpiaVVV2yeQucfzNNtLK3soyltEsasxY45JJJJ5+pNM/syz+wSWPk/6NJu3JuPO4knnOep&#xd;&#xa;NWIo1iiSOMYRFCqPQCq40yzGnixEOLZRgJuPH0Oc/rVVPDulIjqLYlXxkNK7dDkYyeOR2rVooorH&#xd;&#xa;0z/kYda/3of/AEXWxRRRRWP4d+7qX/YQm/mK2KKKKKRlDKVYZBGDWOvhbR1UKttIFHAAuJMD/wAe&#xd;&#xa;q7Y6XZ6fC8NrCI0kJLfMWLE+5OantreK0to7eBNkUahUXJOAPrVK60HTbudppoGLt1Kyug/IECpY&#xd;&#xa;tJsodPNjHBi3OTt3MTk9TnOc8+tR2eh6dZTiaCBhIBgFpXfH4MSKde6NYX8oluYWZwMZWRkz9dpG&#xd;&#xa;asWlpBZQCG3TYg9yT+JPJqeiiiiszxJ/yLmo/wDXs/8A6CavWv8Ax6w/7i/yqWiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiisfX/wDXaR/2EE/9AetiiiiiiiiiiiiiiiiiiiiiisfTP+Rh1r/eh/8ARdbFFFFF&#xd;&#xa;Y/h37upf9hCb+YrYoooooooooooooooooorM8Sf8i5qP/Xs//oJq9a/8esP+4v8AKpaKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKw/E/nAaX9mEZm+3psEhIXOx+uOak3eI/8AnlpX/f2T/wCJo3eI/wDnlpX/&#xd;&#xa;AH9k/wDiaN3iP/nlpX/f2T/4mjd4j/55aV/39k/+Jo3eI/8AnlpX/f2T/wCJo3eI/wDnlpX/AH9k&#xd;&#xa;/wDiaN3iP/nlpX/f2T/4mjd4j/55aV/39k/+Jo3eI/8AnlpX/f2T/wCJo3eI/wDnlpX/AH9k/wDi&#xd;&#xa;aN3iP/nlpX/f2T/4mjd4j/55aV/39k/+Jo3eI/8AnlpX/f2T/wCJo3eI/wDnlpX/AH9k/wDiaN3i&#xd;&#xa;P/nlpX/f2T/4mjd4j/55aV/39k/+Jo3eI/8AnlpX/f2T/wCJo3eI/wDnlpX/AH9k/wDiaN3iP/nl&#xd;&#xa;pX/f2T/4mjd4j/55aV/39k/+Jo3eI/8AnlpX/f2T/wCJo3eI/wDnlpX/AH9k/wDiah0E3J1jWPto&#xd;&#xa;hE+6HcISSv3OMZ5reoooormNKOriXUvsCWLQ/bpeZ3cNnI9Aav7vEf8Azy0r/v7J/wDE0bvEf/PL&#xd;&#xa;Sv8Av7J/8TRu8R/88tK/7+yf/E0bvEf/ADy0r/v7J/8AE0bvEf8Azy0r/v7J/wDE0bvEf/PLSv8A&#xd;&#xa;v7J/8TRu8R/88tK/7+yf/E0bvEf/ADy0r/v7J/8AE0bvEf8Azy0r/v7J/wDE0bvEf/PLSv8Av7J/&#xd;&#xa;8TRu8R/88tK/7+yf/E0bvEf/ADy0r/v7J/8AE0bvEf8Azy0r/v7J/wDE0bvEf/PLSv8Av7J/8TRu&#xd;&#xa;8R/88tK/7+yf/E0bvEf/ADy0r/v7J/8AE0bvEf8Azy0r/v7J/wDE0bvEf/PLSv8Av7J/8TRu8R/8&#xd;&#xa;8tK/7+yf/E1Q11te/sO+8+PTRF5D7ykkhbGOcZXrXRWv/HrD/uL/ACqWiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiisfX/9dpH/AGEE/wDQHrYooooooooooooooooooooorH0z/kYda/3of/RdbFFFFFY/h37u&#xd;&#xa;pf8AYQm/mK2KKKKKKKKKKKKKKKKKKKzPEn/Iuaj/ANez/wDoJq9a/wDHrD/uL/KpaKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKx9f/ANdpH/YQT/0B62KYsiPH5iurIRncDkY+tKrK6hlIZSMgg5BFMW5geUxJ&#xd;&#xa;NG0gzlA4JH4UkbSG6mVpIjGFXai/fU85zz0PGPxpZbmCAgTTRxk9A7AZ/Oqenaib3UNQhVo2ht3R&#xd;&#xa;Y2TnOUBOTn1q+7rGhd2CqOSScAVE97axuUe5hVh1DSAEVXvr2S31DTrdAhS6kdXJHIAQsMfiKtyz&#xd;&#xa;xQAGaVIweAXYDP50RzRSx+ZHIjp/eVgR+dL5ieX5m9fLxu3Z4x65qK8u0tbKW5PzhELKAfv8ZAHu&#xd;&#xa;arWk2o3dlJOYoraSRQYI5BuKcfx4POevGKNN1GW5nntrq3NvcQYBBYESAj7y+38s1o0UUUUVj6Z/&#xd;&#xa;yMOtf70P/outiiiiisfw793Uv+whN/MVrF1VlUsAzdATyaQyIJFjLqHbkKTyfwolmjhXdLIka5xl&#xd;&#xa;mAFRTTb7OSW1mhztO2RzlAffB6VOudoyQTjtWVrGsxWemzT2s9vJMhUKhcHOWAPAPvWtUUk8MW7z&#xd;&#xa;JY02gE7mAxnpRDcQTkiGaOTHXYwOPyqro17Jf2jyyhQyzyRjaMDCuQP0FWBeWpk8sXMJfONu8Zz6&#xd;&#xa;YqUuocIWAYjIXPJFJ5iCQRl13kZC55x64rOvNQuf7QFhYwB5Cm9pmOUi56EZBJ9h607Vr6704faY&#xd;&#xa;7b7TbAAOicOpz97k8j2AzWgjq6BkYMpGQQcg06iiszxJ/wAi5qP/AF7P/wCgmr1r/wAesP8AuL/K&#xd;&#xa;paKKKKKKKKKKKKKKKKKKKKKKKKKKKx9f/wBdpH/YQT/0B62K5K5ke3F5okbtHd3NyslpApwPIBXO&#xd;&#xa;COFGFk4478c1ta1JJY6JIbJQhTy0UIvCqWVTgDpgE/Sq2oWFlZ6TLd2kaJcxRmSKdceZK4GRlurb&#xd;&#xa;j19c1D4dmluNTuprgYmks7RnGMfMVcnjtzUukWtvq1mb3UYIrmaSSRf3qBwgVyoCg9OAM46nmjQY&#xd;&#xa;7eLV9ZS0SJIVliwsQAUfuxnpx1zU3iv/AJFnUP8AriaJtA0l7Fo7m3ibK4e4kAMn1LnnPvWTp0sk&#xd;&#xa;1v4XklkaR2eTLO2Sf3b961tXmhknSz/sxNSnVfNMT7RsUkjdluOox61U0AudX1K3exFlEsURFqGU&#xd;&#xa;qM78nC8c4/Sqhd1dtEDMLlr3zVgz8v2Xf09Nu3Py+nGK1PEaqljZqoCqt7bgADAA3itmseb/AJG6&#xd;&#xa;1/68pf8A0NK2KKKKKKx9M/5GHWv96H/0XWxRRRRWP4d+7qX/AGEJv5in+IInNnHcRDElvKkhkBwy&#xd;&#xa;RhgXwev3Qcgdah0Z49S1C71SPE1s+0WsrDlcLhwoPK89emaURx6hrl5BfossMATyYpBlGyuWbaeC&#xd;&#xa;Qe/bPvWZ4gVbKK+tLNQltJYyvJEg+WNhjGAOFzkn3rQ1u6mhi0u3ikZEu51hkZThtpHY9j71X8Ta&#xd;&#xa;bplroc0kdnaRTZQI4iUMTuHQ4znrXS1z5sYL3xbd/aU8xEtYv3bco2S/3l6HHbPSmSWVpp/ivTvs&#xd;&#xa;KrbmdJBNFEQqsFXKkqPcnmrHh6VINHuZpDtSO5uGY4zgCRiaydXfOmXd5a+HY4sxtJHeo0SsMjIk&#xd;&#xa;H8QPf1rQui40XSdQJO6DypJ5s/MItuXyepB4yO9T6Htvbi71MASxTSf6LMw58vaAQM8qNwPHHrTt&#xd;&#xa;G/5Cmtf9fS/+i1rUm/1En+6f5VneGP8AkW9O/wCuC/yrVoorM8Sf8i5qP/Xs/wD6CavWv/HrD/uL&#xd;&#xa;/KpaKKKKKKKKKKKKKKKKKKKKKKKKKKKx9f8A9dpH/YQT/wBAetiqE2kWk2sQao6t9qgQohDcY57f&#xd;&#xa;8CNXmUMpVgCCMEHvWdDolpDciUNO6q25IXlLRIe21DwMdsdKtR2kUV5PdKD5s6qrnPGFzj+ZqlNo&#xd;&#xa;NtJKzpcXluGOfLt7ho0B74UcDPU+5qzY6Za6e8zWsewzEF/QkDGfr6+pqPXbSW/0W7tYMGWWMquT&#xd;&#xa;gZqCPw/bKymS5vZ1HWOa5Z0b2Kngirh06132rLEIxaMWiVBtVcgg8D2Jpt9pkF8yu7zQyKMeZBIY&#xd;&#xa;2I9CRyR7U3TtJg06WaWKSeSSYKHaaUyHAzjk/U1Haacf7YutSuI4xI4EUQwGKqufm3dt2eR7d6tX&#xd;&#xa;9qt7ZywEhWZTsfbkxt2Ye4PIqvaLqNrZSRShLuaFQIpC2zzuO45246d89aTTdPnhuZ7y9nWeebG0&#xd;&#xa;bMeSuOVU56cDPTOM1pUUUUUVj6Z/yMOtf70P/outiiiiisfw793Uv+whN/MVqXEKXFvJBJkpIhRs&#xd;&#xa;ehGDUGmadb6VZJaWoYRISQGOTyc0X2nQ3wXzGkjdeksLlHA7jcOce3sKiXR7UWE9m3mOs6lZZHct&#xd;&#xa;I492PJx2qe6sYLuAQypkL9xhwyH1U9QfcVQbw3ZSRslxJdXKnGPPnaTaQc5XPQ+4rYrEudEa71ye&#xd;&#xa;7lnuIYWhRFME7RkkFs5x9RV2z0m1s3EgVppxnE858yQD03HnHtUttYwW1u9vGmYpGdmVucliSfw5&#xd;&#xa;NZ83hq0mR43ub7ynyDELpggHoFzjHtU+o2Dy6MdNtVGyRBAWZv8AVpjG73I9OM1dtreO1t44IUVE&#xd;&#xa;QYCou0flWfdWN1FqP2+wlUZTbLbFdomOfvFuxxjnB4GKfq1rfX6/Zba4+yRMMvOvzMefugZGPrn2&#xd;&#xa;xV+KOOGNY4kWONRhVUYAHsKfRRWZ4k/5FzUf+vZ//QTV61/49Yf9xf5VLRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRWPr/APrtI/7CCf8AoD1sUUUUVGk0bySRpIrPGQHUHJXIyMjtxUlFFFFFRyzRwgGWRUDM&#xd;&#xa;FBY4yTwB9TUlFFFRzTRwRmSaRY0GMs5wBk4HNDzRxuiPIitIcIpOCxxnA9eKkoorH0z/AJGHWv8A&#xd;&#xa;eh/9F1sUUUUVj+Hfu6l/2EJv5itiiimSyxwxNLK6xxoMszHAA9SacCCAQcg0yaaOCMyTSLHGvVnO&#xd;&#xa;APxqSiiio1mjeR40kVpI8b1ByVz0yO1EU0cylopEkUEqSpyMg4IqSiiio2mjSRI3kVXkzsUnBbHX&#xd;&#xa;A70CaMzNCJFMqgMUzyAehx+BqSszxJ/yLmo/9ez/APoJq9a/8esP+4v8qloooooooooooooooooo&#xd;&#xa;ooooooooorH1/wD12kf9hBP/AEB62K4+wNheWiS+Jrt47/GCtzIbUhe2FBXIznnHqO1belwQQwyS&#xd;&#xa;aXdie1KkRxCTzFD9zv5P4ZrI8P3WvNJMDaWzQm9kErGY5T5/mCjuB2q2us6reSXEenWETm3uJIna&#xd;&#xa;ZiikA4Xae54OfTitDTrx7i/v4JIY43tzGGK/xEoCc/TOKzbfWdY1CHzNP0+FgjujmZiikhiBtPfg&#xd;&#xa;c+9aGn6mXhuBqPlW1xakfaMN8iZGR8x9sVUe/wBfmcyWem2/2duU89yj4917VoaLfPqWk215Iio0&#xd;&#xa;q7iqngc0kl+YtXFpKqxwtDvSVjjc+TlR2OAM1XttbiktbqaV4YzFIwjBfG9f4G+jY49e1VNbuZH0&#xd;&#xa;DT7q4gdJTcW8jwqpLA7gSoHXPbFOfUtdhDXE2n2qWafO7eYd4jHJO31x2rRvLi8awin0qGKaSTDb&#xd;&#xa;Zm2jaRnP16VBpuoXr3hs9Ut4oLhkMkYiYsCoIByfqRWNfXOsp41KWkEMhFmdiPKQrJv+8ffPFXdJ&#xd;&#xa;ik1bUp7zU4lS4s2+ziFHJjzgNu9z82Oa2r6zhv7ZoJ1JVh1BIIPqCORVPw/KzWD27Et9jla2Dk8u&#xd;&#xa;E43H3NalFY+mf8jDrX+9D/6LrYoooorH8O/d1L/sITfzFWtQvWsZLd2QG3kfy5G/iUsQFwPqeaat&#xd;&#xa;9LLq7WkEatFAP9IdjgqSMrj1pmo39ykn2bTIY7i7Xl1dsKg9yOhPGB35qrNrE0GlXZv7eJL2CJpD&#xd;&#xa;CTlJAP7pP3h0z6E1p3F9BaWqSzNguBsReWc4+6o7n2Fczr9zr0mkTi6sbWO2JTcyyksBuGOK7CqG&#xd;&#xa;qS6nEsf9mW8E5JO/zXK49MVHpV/czyy2t/DHDeRAOVjbcuw5wc+vBqK81K9llMejW0dyYziSSViq&#xd;&#xa;fRWHBIOQR2rM0+bWft+rutpbG+LQBojIdgXaec/lVy01qY6daTSW0Ucs199mkRDwvzEEj8q1NVu2&#xd;&#xa;sNLurtFDtDEzhT0OBVO+1K7EkNtpsEU128QmZZWKqE6dfXOKl0271GRpItRtEhmC7kMRLRkdMFvX&#xd;&#xa;Pb0rA0q88RKL9orK0kAupN++Y/K2BkD2rX8OW0ctqNVcFri9/fHLEiMH+FfQVLr1hFcWbXR3JNaj&#xd;&#xa;zUdWIJ284OOoOMc+tXbGc3Vhb3DKFMsSuQO2QDVTxJ/yLmo/9ez/APoJq9a/8esP+4v8qloooooo&#xd;&#xa;ooooooooooooooooooooorH1/wD12kf9hBP/AEB62Kw5b+QNtvdCuLiZBhpIY0dD/uliDj8Kj0HT&#xd;&#xa;nh1W7v47eS0tbheLeU/MHzlmxkgA+xqSwefTLqe1exuZhcXTyiaIAxqrtkZJIPHfj86s6Hby28V6&#xd;&#xa;JkKF72aRc91LZBo0+3li1nVpXQrHM8RjY/xARgH9aPDtvLa6SsU6FHEsp2n0MjEfoRVG60u5vD4g&#xd;&#xa;hVQn2vyxE78KcRgHp7irA1e6lAig0i8jlbhXuFURg/7RDE4+gpfCX/Is2Gf+ef8AU07X7OWeGG4t&#xd;&#xa;0aSa3Y7Yx/FuGw/kGJ/CsfUvDlyPs1pYkSRyJEkskvAQQ/d6d2yfyrb163luLa2WFC5W7hdgOyhw&#xd;&#xa;SfyqfV4nm0e9iiUtI9vIqqO5KkAVk39rObSxW4tp7m0SALJbW7bZBJgYbII4A3Dr3HFQ6NZKniFb&#xd;&#xa;i20y9s4BbOjG5ctliykYyzdgauahBcWviFNXS3kuYha/ZzFCAZNxbdnBwMfjUWkXsdvq9za3KvBP&#xd;&#xa;fv8Aaoo3AyFwF2n/AGvkJ9Md62ry7hsbWS5uXCRRjLE1Q8OofsElzxsvJnuYx3CvyAfetaisfTP+&#xd;&#xa;Rh1r/eh/9F1sUUUUVj+Hfu6l/wBhCb+Yq3q9t9q02ZVQvKi+ZEB/z0XlT+YFU/DEF2unm61ONl1C&#xd;&#xa;c/vywALbSQvA4HHpTp0m0zULi+it5LqO62iSOIAupUYGASBjGc8+lUdUs7rVrO7vPs0kL/ZZIYIG&#xd;&#xa;A8xt2M7h0HK8YPQ1b1qxnni06eJN5splmeMfecAdF7Z+uKqazc3+raXLbWulXMRJUv8AaABkBh93&#xd;&#xa;BOT9ccZrpawNbt3kvQ93aXV7abAIo7VirRvzuLYZeCMY5PQ9Kj8O2nk6tezRWF1Z27xRqouW3MWB&#xd;&#xa;bPO4+o70+znuNGSW1fTby5JmkkEluqlCGYsByQc888VNosd5/amp3N5AIRP5RjwewU8H3HGfes+0&#xd;&#xa;tpZ9HSSFC5ttTknKD7zhZG4X3/KptXvb/U9Ju7S00m6ikkiYE3AVQRjoME/N6dqsatbh4rf7Tp01&#xd;&#xa;3CqAYtnKyq3vgr8uPfr2o0K3kiupHgtrizsimDDctudpMj5gSW4xx1/CmRvcaXLewGwurkXM7zLJ&#xd;&#xa;bqpVQ2AAckc8VL4ZuYRYjTN4Nzp4EMqjoSO49jU3iC/gtLBoZWxJdgwxKOpZuPyGcmrmnwNa6fbW&#xd;&#xa;7kF4olRivQkADiqniT/kXNR/69n/APQTV61/49Yf9xf5VLRRRRRRRRRRRRRRRRRRRRRRRRRRRWPr&#xd;&#xa;/wDrtI/7CCf+gPWxRRRRRRRWB/whfh8n/kH/APkaT/4qt4cDFLRRRRRRUN3aw3lu0Fwm+JiCVyR0&#xd;&#xa;II6e4FE1rDPNBLKm54GLRnJG0kEH9CamoorH0z/kYda/3of/AEXWxRRRRWP4d+7qX/YQm/mK2KKK&#xd;&#xa;KKKKKKKztU0PTtXaNtQtvOMYIT52XGevQj0q9DEkEKQxLtjjUKoznAHAp9FFFQy2sMtxDcSJmWDd&#xd;&#xa;5bZPy5GD+lC2sK3b3SpiZ0CM2TyoJIGOnc1NWZ4k/wCRc1H/AK9n/wDQTV61/wCPWH/cX+VS0UUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUVj6//AK7SP+wgn/oD1sUUUUUUUUUUUUUUUUUUUUUVj6Z/yMOtf70P&#xd;&#xa;/outiiiiisfw793Uv+whN/MVsUUUUUUUUUUUUUUUUUUVmeJP+Rc1H/r2f/0E1etf+PWH/cX+VS0U&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUVm61azXEdrLbp5j2twJ/LyAXwrDAJ4H3u9Q/wBp6r/0AJ//AAJi&#xd;&#xa;/wDiqP7T1X/oAT/+BMX/AMVR/aeq/wDQAn/8CYv/AIqj+09V/wCgBP8A+BMX/wAVR/aeq/8AQAn/&#xd;&#xa;APAmL/4qj+09V/6AE/8A4Exf/FUf2nqv/QAn/wDAmL/4qj+09V/6AE//AIExf/FUf2nqv/QAn/8A&#xd;&#xa;AmL/AOKo/tPVf+gBP/4Exf8AxVH9p6r/ANACf/wJi/8AiqP7T1X/AKAE/wD4Exf/ABVH9p6r/wBA&#xd;&#xa;Cf8A8CYv/iqP7T1X/oAT/wDgTF/8VR/aeq/9ACf/AMCYv/iqP7T1X/oAT/8AgTF/8VR/aeq/9ACf&#xd;&#xa;/wACYv8A4qj+09V/6AE//gTF/wDFUf2nqv8A0AJ//AmL/wCKo/tPVf8AoAT/APgTF/8AFUf2nqv/&#xd;&#xa;AEAJ/wDwJi/+Ko/tPVf+gBP/AOBMX/xVGixXh1DUru7tGtRcNHsRpFc/KuD90mtiiiiisKEahpU1&#xd;&#xa;0kGmveJPO84kSVEA3H7uGOeMVL/aeq/9ACf/AMCYv/iqP7T1X/oAT/8AgTF/8VR/aeq/9ACf/wAC&#xd;&#xa;Yv8A4qj+09V/6AE//gTF/wDFUf2nqv8A0AJ//AmL/wCKo/tPVf8AoAT/APgTF/8AFUf2nqv/AEAJ&#xd;&#xa;/wDwJi/+Ko/tPVf+gBP/AOBMX/xVH9p6r/0AJ/8AwJi/+Ko/tPVf+gBP/wCBMX/xVH9p6r/0AJ//&#xd;&#xa;AAJi/wDiqP7T1X/oAT/+BMX/AMVR/aeq/wDQAn/8CYv/AIqj+09V/wCgBP8A+BMX/wAVR/aeq/8A&#xd;&#xa;QAn/APAmL/4qj+09V/6AE/8A4Exf/FUf2nqv/QAn/wDAmL/4qj+09V/6AE//AIExf/FUf2nqv/QA&#xd;&#xa;n/8AAmL/AOKqrqlxq99pd1aLoUyNNEyBjcxYGRj+9W9bqUt41YYZUAI/CpKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKK//9k=</binary>
<binary id="image22.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAECAd8BAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK5azsdQ1SS9mG&#xd;&#xa;t3cCpdzRrGgBChWIFWv7A1D/AKGK+/75Wj+wNQ/6GK+/75Wj+wNQ/wChivv++Vo/sDUP+hivv++V&#xd;&#xa;o/sDUP8AoYr7/vlaP7A1D/oYr7/vlaP7A1D/AKGK+/75Wj+wNQ/6GK+/75Wj+wNQ/wChivv++Vo/&#xd;&#xa;sDUP+hivv++Vo/sDUP8AoYr7/vlaP7A1D/oYr7/vlaP7A1D/AKGK+/75Wj+wNQ/6GK+/75Wj+wNQ&#xd;&#xa;/wChivv++Vo/sDUP+hivv++Vqnqmn6lpdl9rGu3kuySMbGCgMGdVP866uiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiisfw5/qL/8A7CFx/wChmtiiiiiiiiiiiiiiiisfxV/yAZf+usP/AKNS&#xd;&#xa;tiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisfw5/qL//ALCFx/6Ga2KKK5zxR4gutKuL&#xd;&#xa;Wz0+CKS5uDkGY4THPHUYPTvU80viS2Mb+TY3iF8PHApjfbg8gs+PT86z9Z1mXT/G9hDJcSJYtblp&#xd;&#xa;I1UsCfnAOACeoH5VrweItLnuY7dLh1kkJCCSF0BIGerACrV/qNtpyI90zqrnA2xs/wD6CDUdhrNh&#xd;&#xa;qUskVrOWkjALI8bIcHOOGAz0qs/ifSEuJoPtLtLC5SRUgkbaQcY4X2NT6Zrmm6s8iWNyJHjxuUoy&#xd;&#xa;kZz/AHgM9Kde6xY2EoiuJXDkZwkTvj67QcVNYX9rqNsLizlEkZJGcEEEHHIPI6VZoorH8Vf8gGX/&#xd;&#xa;AK6w/wDo1K2KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKx/Dn+ov/wDsIXH/AKGa2KKK&#xd;&#xa;wfEdvol7JbWurnZI7funCkHvxvxgD2J7VheI1u9KNteaNq11c7X2vA1w02eCckZ6cY/Grmpf8lO0&#xd;&#xa;n/r1b+UtHj//AJhH/X0P6U3xBqOpSeJI9HiuvsdpMqkz8oRgbiA46Zxj8ar6dDFB8RAkFzJcJ9mJ&#xd;&#xa;3ySmQ9PU1N4Snhh8QeJfOlSPN1xvYDPzyVFodutz48vNQ0+Ef2eq7fMVdi7ioBwDjPzBun9aZpUW&#xd;&#xa;uW19qatqFvaSNMC32v5y4x8pBz0xgVseENO/s4X6G7juXeUOzRqQoJGeCeD17V0dFFY/ir/kAy/9&#xd;&#xa;dYf/AEalbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFY/hz/AFF//wBhC4/9DNbFFFQ3&#xd;&#xa;NpbXkYjureKdAdwWVAwB9cH61HbabY2chktbK2gcjaWiiVSR6ZA9qka0tnukumt4muEG1ZSgLqOe&#xd;&#xa;Aeo6n86Li0trrZ9pt4pth3L5iBtp9RnpSXVla3iqt3bQzqpyBLGGAP41Hb6Xp9pL5ttY20MmMb44&#xd;&#xa;VU4+oFZdh4Vs7fUNRurtYL37ZL5irLAD5WSxIBOc9R6dK24IIbaFYbeJIol+6kahVHfoKiutPsrx&#xd;&#xa;la7s7edlGAZYlYgfiKlgghtoVht4kiiX7qRqFUd+gqSiisfxV/yAZf8ArrD/AOjUrYoooooooooo&#xd;&#xa;ooooooooooooooooooooooooooooooorH8Of6i//AOwhcf8AoZrYooooooooooooooorH8Vf8gGX&#xd;&#xa;/rrD/wCjUrYooooooooooooooooooooooooooooooooooooooooorl9I0SwvjqE9xHK0hv5xlZ5E&#xd;&#xa;H3z2DAVof8IxpX/PGf8A8Cpf/iqP+EY0r/njP/4FS/8AxVH/AAjGlf8APGf/AMCpf/iqP+EY0r/n&#xd;&#xa;jP8A+BUv/wAVR/wjGlf88Z//AAKl/wDiqP8AhGNK/wCeM/8A4FS//FUf8IxpX/PGf/wKl/8AiqP+&#xd;&#xa;EY0r/njP/wCBUv8A8VR/wjGlf88Z/wDwKl/+Ko/4RjSv+eM//gVL/wDFUf8ACMaV/wA8Z/8AwKl/&#xd;&#xa;+Ko/4RjSv+eM/wD4FS//ABVH/CMaV/zxn/8AAqX/AOKo/wCEY0r/AJ4z/wDgVL/8VR/wjGlf88Z/&#xd;&#xa;/AqX/wCKo/4RjSv+eM//AIFS/wDxVZ2v6Fp9npTXEEcokSWLBa4kYcyKOhYjvXU0UUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUVj+HP9Rf/wDYQuP/AEM1sUUUUUUUUUUUUUUUVj+Kv+QDL/11&#xd;&#xa;h/8ARqVsUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVj+HP8AUX//AGELj/0M1oXt3FZQ&#xd;&#xa;GWXJ5Cqq/edj0Ue5PArn9X1R7o6fE2mX1uPt8B3zIoX749GNaU+v28V9cWUVvc3F1AV3RQqpJUqD&#xd;&#xa;uGSOBkD6mp31J0sI7oadesztt8hUXzF68kbsY49e4osdUS8mMD29xazBd4jnUBmXgEjBPGSKhl16&#xd;&#xa;1i8PjWWjmNsVVtoA34LBemcdT61cuL2O3u7W2dXL3TMqEAYBVSxz+ArK1KSXU9XTS7W4ktxAPNuS&#xd;&#xa;MYdGHCj1565xxWncadbT2K2bRKIYwBGv9zH3SPpVPQpJ4pLvTry4e5uLZg/mt/Ejk7fxwvP9a16K&#xd;&#xa;KKKKx/FX/IBl/wCusP8A6NStiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisfw5/qL/8A&#xd;&#xa;7CFx/wChmo9cnjsNU0/UrpvLtIElSSTGdpbbtGBzzg9qz9S16z1Y2KaaxuI0v7cyyYKiPLjaMMAT&#xd;&#xa;nB6enNamlf8AIe1z/rrF/wCilqHxFefZJIftl5LY6eRzcQcuZeydDwV3Hp2HPrnaBd2d34q3WWp3&#xd;&#xa;N+q2ThmnGCp3pwPlWrUFiyeKvL3gmOV78nHVXQxBfqCuaj8LWs0OozIyZisrdbIy5GHdWLHA69HF&#xd;&#xa;W40a18YzTTDbHeQrFAeu9lBZhx0wB3rerH0v99rmq3UfMDeXCG/2494cY68Ej+lbFFFFFFY/ir/k&#xd;&#xa;Ay/9dYf/AEalbFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFY/hz/AFF//wBhC4/9DNbF&#xd;&#xa;FFFFFFVL/TrXUURbqIPsO5CeqH1HvRPZefZJatczgKAGkDDe4HXPGOe/FPs7K2sIBBaQrDECTtXp&#xd;&#xa;mrFFFFFFY/ir/kAy/wDXWH/0albFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFY/hz/UX&#xd;&#xa;/wD2ELj/ANDNbFFFFFFFFFFFFFFFFY/ir/kAy/8AXWH/ANGpWxRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRWHFo+p2slx9k1aKOKad5tjWm4qWOcZ3c1J9h1z/oNQf8AgCP/AIuj7Drn/Qag&#xd;&#xa;/wDAEf8AxdH2HXP+g1B/4Aj/AOLo+w65/wBBqD/wBH/xdH2HXP8AoNQf+AI/+Lo+w65/0GoP/AEf&#xd;&#xa;/F0fYdc/6DUH/gCP/i6r6gusWFm9zJrMJVSAALHqSQAPv+pFQ6O2v6jbSSS6nbwSRzPCyC1DgFTg&#xd;&#xa;87hV77Drn/Qag/8AAEf/ABdH2HXP+g1B/wCAI/8Ai6PsOuf9BqD/AMAR/wDF0fYdc/6DUH/gCP8A&#xd;&#xa;4uj7Drn/AEGoP/AEf/F0fYdc/wCg1B/4Aj/4uj7Drn/Qag/8AR/8XUN1o+q3sPkXWsRPCXVmVbPa&#xd;&#xa;TtYMOd/qK3qKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKx9b/AH93p2nyf6i6&#xd;&#xa;lbzAOvyKXXB+qijTf9D1m/sz8kMhE8IfgyMxYyY9cHb06ZHrWxRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWHpiNea9e6iDm3TNsiN95XQkMQOgB9etHiOU2Mllqaje8&#xd;&#xa;MhhCHoRIVBP4Yrcooooooooooooooooooooooooooooooooooooooooooooooooooooooooprgsj&#xd;&#xa;BW2sRgNjOPesFIdZ0u3n8iHT5Igzys7yuHkJ5LEbcAnrgcDtTUk13VdLjkFtpYjuYg675XyoYZB+&#xd;&#xa;71Ga2dNgktdNtbeZg8sUKI7AkgsAATk1Zooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;oooooooooooooqvqH/IPuf8Ark38jVfQP+Rf03/r1i/9AFaFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFV9Q/wCQfc/9cm/kar6B/wAi/pv/AF6xf+gCtCiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiimu6xqWdgqjqScAVD9us/+fqD/AL+Cj7dZ/wDP1B/38FH26z/5&#xd;&#xa;+oP+/go+3Wf/AD9Qf9/BR9us/wDn6g/7+Cj7dZ/8/UH/AH8FH26z/wCfqD/v4KPt1n/z9Qf9/BR9&#xd;&#xa;us/+fqD/AL+Cj7dZ/wDP1B/38FH26z/5+oP+/go+3Wf/AD9Qf9/BR9us/wDn6g/7+Cj7dZ/8/UH/&#xd;&#xa;AH8FH26z/wCfqD/v4KPt1n/z9Qf9/BR9us/+fqD/AL+Cj7dZ/wDP1B/38FH26z/5+oP+/gqvf3to&#xd;&#xa;bC5AuoSTE3HmD0NQaFe2q6DpytcwhhaxAgyDIO0Vf+3Wf/P1B/38FH26z/5+oP8Av4KPt1n/AM/U&#xd;&#xa;H/fwUfbrP/n6g/7+Cj7dZ/8AP1B/38FH26z/AOfqD/v4KPt1n/z9Qf8AfwUfbrP/AJ+oP+/go+3W&#xd;&#xa;f/P1B/38FH26z/5+oP8Av4KPt1n/AM/UH/fwUfbrP/n6g/7+Cj7dZ/8AP1B/38FH26z/AOfqD/v4&#xd;&#xa;KPt1n/z9Qf8AfwUfbrP/AJ+oP+/go+3Wf/P1B/38FH26z/5+oP8Av4KPt1n/AM/UH/fwVNHIkqB4&#xd;&#xa;3V1PRlOQadRRRRRRRRRRRRRRRRRWP4t/5FjUP+uR/nVj+wtI/wCgVY/+A6f4Uf2FpH/QKsf/AAHT&#xd;&#xa;/Cj+wtI/6BVj/wCA6f4Uf2FpH/QKsf8AwHT/AAo/sLSP+gVY/wDgOn+FH9haR/0CrH/wHT/Cj+wt&#xd;&#xa;I/6BVj/4Dp/hR/YWkf8AQKsf/AdP8KP7C0j/AKBVj/4Dp/hR/YWkf9Aqx/8AAdP8KP7C0j/oFWP/&#xd;&#xa;AIDp/hR/YWkf9Aqx/wDAdP8ACj+wtI/6BVj/AOA6f4Uf2FpH/QKsf/AdP8KP7C0j/oFWP/gOn+FH&#xd;&#xa;9haR/wBAqx/8B0/wo/sLSP8AoFWP/gOn+FH9haR/0CrH/wAB0/wo/sLSP+gVY/8AgOn+FQX2iaSt&#xd;&#xa;jcMul2QYRMQRbpkHH0qDRNG0uXQ9Pkk02zd3to2ZmgUkkqMknFXv7C0j/oFWP/gOn+FH9haR/wBA&#xd;&#xa;qx/8B0/wo/sLSP8AoFWP/gOn+FH9haR/0CrH/wAB0/wo/sLSP+gVY/8AgOn+FH9haR/0CrH/AMB0&#xd;&#xa;/wAKP7C0j/oFWP8A4Dp/hR/YWkf9Aqx/8B0/wo/sLSP+gVY/+A6f4Uf2FpH/AECrH/wHT/Cj+wtI&#xd;&#xa;/wCgVY/+A6f4Uf2FpH/QKsf/AAHT/Cj+wtI/6BVj/wCA6f4Uf2FpH/QKsf8AwHT/AAo/sLSP+gVY&#xd;&#xa;/wDgOn+FH9haR/0CrH/wHT/Cj+wtI/6BVj/4Dp/hR/YWkf8AQKsf/AdP8KP7C0j/AKBVj/4Dp/hV&#xd;&#xa;bwmoXw/CqgBRLMAAOAPNetmiiiiiiiiiiiiiiiiisfxb/wAixqH/AFyP862KKKKKKKKKKKKKKKKK&#xd;&#xa;KKr6h/yD7n/rk38jVfQP+Rf03/r1i/8AQBWhRRRRRRRRRRRRRRRRRRWP4V/5AMX/AF1m/wDRr1sU&#xd;&#xa;UUUUUUUUUUUUUUUUVj+Lf+RY1D/rkf51sUUUUUUUUUUUUUUUUUUVX1D/AJB9z/1yb+RqvoH/ACL+&#xd;&#xa;m/8AXrF/6AK0KKKKKKKKKKKKKKKKKKKx/Cv/ACAYv+us3/o162KKKKKKKKKKKKKKKKKKx/Fv/Isa&#xd;&#xa;h/1yP862KKKKKKKKKKKKKKKKKKKr6h/yD7n/AK5N/I1X0D/kX9N/69Yv/QBWhRRRRRRRRRRRRRRR&#xd;&#xa;RRRWP4V/5AMX/XWb/wBGvWxRRRRRRRRRRRRRRRRRWP4t/wCRY1D/AK5H+dbFFFFFFFFFFFFFFFFF&#xd;&#xa;FFV9Q/5B9z/1yb+RqvoH/Iv6b/16xf8AoArQoooooooooooooooooorH8K/8gGL/AK6zf+jXrYoo&#xd;&#xa;ooooooorn9O1DXtRsIbyG201Y5l3KHlkBA98LVjf4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN/iP/&#xd;&#xa;AJ4aV/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN/iP/AJ4a&#xd;&#xa;V/3+k/8Aiaq6naeIdS06ezePTEWZdpYTSZH/AI7Vrf4j/wCeGlf9/pP/AImjf4j/AOeGlf8Af6T/&#xd;&#xa;AOJo3+I/+eGlf9/pP/iaN/iP/nhpX/f6T/4mjf4j/wCeGlf9/pP/AImjf4j/AOeGlf8Af6T/AOJo&#xd;&#xa;3+I/+eGlf9/pP/iaN/iP/nhpX/f6T/4mo3v9YtLqzW+gsfKuZxDmGRywJBOeVHpW5RWDBf61eyXL&#xd;&#xa;Wlvp/kw3EkIMsrhjtYjPCmpt/iP/AJ4aV/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/&#xd;&#xa;+Jo3+I/+eGlf9/pP/iaN/iP/AJ4aV/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jpk&#xd;&#xa;6+IpoJIjDpYDqVz50nGR/u1HYw+IbOxt7VYtLZYIljDGaTJAGM/d9qn3+I/+eGlf9/pP/iaN/iP/&#xd;&#xa;AJ4aV/3+k/8AiaN/iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN/iP/AJ4a&#xd;&#xa;V/3+k/8AiaN/iP8A54aV/wB/pP8A4moL3UNc0+3+03NvpxhV0VvLlct8zBeMqPWt+isR7/Vp9Uvb&#xd;&#xa;awgsjHasilp5HUksgbsD60/f4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN/iP/AJ4aV/3+k/8AiaN/&#xd;&#xa;iP8A54aV/wB/pP8A4mjf4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN/iP/AJ4aV/3+k/8AiaN/iP8A&#xd;&#xa;54aV/wB/pP8A4mqum2niHTrJbZI9MdVZ2yZpM/Mxb+771a3+I/8AnhpX/f6T/wCJo3+I/wDnhpX/&#xd;&#xa;AH+k/wDiaN/iP/nhpX/f6T/4mjf4j/54aV/3+k/+Jo3+I/8AnhpX/f6T/wCJo3+I/wDnhpX/AH+k&#xd;&#xa;/wDiaN/iP/nhpX/f6T/4moby88QWdnPdSW+mFIY2kYLNJkgDJx8vtWzbSma2ilIwXQNj0yKlrH8J&#xd;&#xa;f8ixp/8A1yH862KKKKKZLLHCu6WRI1JxlmAGacCCAQcg96WimySJEheR1RR1ZjgClVgyhlIKkZBB&#xd;&#xa;4IpaKKKKx9f/ANfo/wD2EE/9Aetiisfw5/qL/wD7CFx/6Ga2KKKKKKKKKKKKKKKKx/FX/IBl/wCu&#xd;&#xa;sP8A6NStiisfSv8AkPa5/wBdYv8A0UtbFFFFFMSWORmVJEZkOGCsCVPvT6KKKKQkAEk4A702KWOZ&#xd;&#xa;d0UiSKDjKsCM0+iis/X/APkX9S/69Zf/AEA1Y0//AJB9t/1yX+QqxWP4S/5FjT/+uQ/nWxRRWX4j&#xd;&#xa;1Y6LpEt4sfmOPlQHpuPQn2zUEGn3uoQR3N3qlxBJIoOyzIWMDHHDAnP41leL4IrTQo4tWlubq2W5&#xd;&#xa;XynjZRKTtY/OSMHv0A4xWrqmtwaDolpdNDJLG+yNVBGRlSRn8qgt/Fcd1qyWUNhdGN32rOUKr9cE&#xd;&#xa;ZFTrrlzcT3C2GlSXcUEpiMqTxqCQAeMn3FUvFl39r8F37NE8MiMiSRt1Vt6HGeh6jkcVf06+g0/w&#xd;&#xa;tp01w4UfZYQo7sSqgAfiRTP+Eha3v7W01LT5bI3bFIWaRXDNkDHy5xyR1rcooorH1/8A1+j/APYQ&#xd;&#xa;T/0B62KKx/Dn+ov/APsIXH/oZrYorA8ZaneaVovnWKgyO/ls20kopViWGOhGByeKzdPjkvtDjuE8&#xd;&#xa;UT/apFOCZFVAckcqV3V0st4un6d9o1SaJCg/eOinbn2HJrHm8UXMGmf2jNolwlqACXMqZGTgfLnP&#xd;&#xa;U+lS3HimCDTtOvDbSFb5gqqGGV+taOs6kmkaXNfSRtIsW3KqcE5YD+tJ/aEkmkQX1raPOZo0kEQd&#xd;&#xa;VIDDPUkDis6LxRGL+2tL21NsbltkbeckoLZAA+QnHJHWrGueIINEuLKKeJ3F05XcnOzBXJx1P3u1&#xd;&#xa;Q6R4mTU72aA2c9tHGhfzphtUgEDv9aLrxG8NrLe2+nS3NhHn/SVlRQcHB+Undwcjp2rYtLqG9tY7&#xd;&#xa;m2ffDINytgjI+hqaisfxV/yAZf8ArrD/AOjUrYorH0r/AJD2uf8AXWL/ANFLWxUVxEZ4HiEskRYY&#xd;&#xa;3xkBl+mQa4+7W9g8Y2WkLrGoG3uITIzF13g4foduP4R2reu5x4c0W4upprm9WNgxMrKW5IXAIAGO&#xd;&#xa;/wCdZ/8AwmcDyWy29hdTLOiFmCEBCe3I5x6jil8LGyOta/8AZUuFlFx++MrKVLbn+7gDA69c9q0t&#xd;&#xa;S1S5sZwiaeZoyMiT7RHGD6jDEGoLDxNaX2l3l3ErCSzjZ5oO643YGehztPSo7HxBe6jaJdWmhzyQ&#xd;&#xa;SZ2t58YzgkHgnPUGruiazBrNs8kStHJE5SWJuqHJ4z0PTPFVZPEXm6i9lpllLftGuZHjcIqnPIy2&#xd;&#xa;ATyOnrUVvr/9pHU7F7OS2mtoWLhnDdunFZ3w6mjt/DN1NM4SNLlizHoPkStO68Ry21qb59Lm/s/5&#xd;&#xa;Stz5qYKMQFbbndzkcYzW3bzx3NvFPC26KVA6NjGQRkHmpKz9f/5F/Uv+vWX/ANANWNP/AOQfbf8A&#xd;&#xa;XJf5CrFY/hL/AJFjT/8ArkP51sUUVj+KdKk1jQ5rWFsSj50GPvEcheSMZ6ZqGz12OytIrfVYJbO5&#xd;&#xa;jUKY1RphgDg7kUjn0rF8b3Euq+H0e3tZDALtPKcA5kGxsnaRlcHI569al8cQyy+EdPSOJ3YSx5VV&#xd;&#xa;JI/dtXZ1x/hqe08NQXum3k0xdLpirC2kIddqjPygjse9WPE1xLqXg7UHjtnVWdBD1JkTeh3bcZHf&#xd;&#xa;g88VBqejTal4T0cxl1ktIoXMYGGI2qG5yMEDJ/CkS30q81Cye2k1K/uYZldBcSSqIxuBLZcY4wDj&#xd;&#xa;viuwooorH1//AF+j/wDYQT/0B62KKx/Dn+ov/wDsIXH/AKGa2KKztduZ7TTZJIdPF+uCJYS4UbMH&#xd;&#xa;J5Bz6Y75rmNVg0LV9L+z6dYLFqDANEsdq0Xz4+6WKgY5PU44p3iXTtTn8D2UU0ckt3BIrz5cMwAV&#xd;&#xa;gTnPPUdM0niTxDa6l4QnjKSw3UoQmFonwpDqcbioHQVWvrWebwfoFxFEzx2zq8pXkqM4zjqfwrR8&#xd;&#xa;V6zZaj4durW0aeSeTZtX7NIM4dSeSuOgNU9dj1JPD3h9rZrmO3SBEuhC5U4KoMFRyejdqg1CPTX1&#xd;&#xa;jw8mi2zBYLhRM4tmQkbkwWJUZ6Hn61reL4pJNe8NskbsqXWWKqSFG6PrXQatY/2lpdxZeZ5XnJt3&#xd;&#xa;7c4/CuPs7DTbHTRpur3mpJMhYSQxmUxkFiRwoK8gg/j6112jQG10m2gNubYomPKMgcp7bh1q9RWP&#xd;&#xa;4q/5AMv/AF1h/wDRqVsUVj6V/wAh7XP+usX/AKKWtiiuT1GKQ/EnS5RG5jW1YFwpwDiTvV7xtG8v&#xd;&#xa;hS9SNGdjswqjJPzrV/QlK6DpysCGFrECCOQdorC8IRSR694kZ43VXusqWUgMN0nSqMKQxeI9SbxK&#xd;&#xa;s80aSlrNJUaeMIxbOAAwHAX0qr4ZgkXS/FO2B0WSE+WChXI2yYwPyrpvBMbxeFLJJEZGG/KsMEfO&#xd;&#xa;1UfAkUkX9q+ZG6brokblIyOazfB+ov4fFzpeqWk0AEjSecFaQbsKNuFB7AnOafocyXfiHxHNBuZJ&#xd;&#xa;ISVypBP4HmmeGdIm1DwNqFgweCSW4JXcnPAQjg464xUsdtpX9mRWF9dao9wkaxyW2+Yx+YAPlHBX&#xd;&#xa;AYcHpXYabEYNNtYjEYTHCi+WW3FMADGe+Omas1n6/wD8i/qX/XrL/wCgGrGn/wDIPtv+uS/yFWKx&#xd;&#xa;/CX/ACLGn/8AXIfzrYooooooooooooooorH1/wD1+j/9hBP/AEB62KKx/Dn+ov8A/sIXH/oZrYoo&#xd;&#xa;ooqrqVhBqljJZ3QYwyY3BTg8EEfqKdY2kVhZxWsAIiiXauTk4qxRRRRRRRRWP4q/5AMv/XWH/wBG&#xd;&#xa;pWxRWPpX/Ie1z/rrF/6KWtiiiiiiiiiisy40WO4neU32ooXOdsd06qPoAeKk03SLXTDK0Ad5Zm3P&#xd;&#xa;LK2+RunBY844q/RRRWfr/wDyL+pf9esv/oBqxp//ACD7b/rkv8hViuc0n+3NN0u3sv7Jgl8lNu/7&#xd;&#xa;YBn8NtW/t2uf9AWD/wADh/8AEUfbtc/6AsH/AIHD/wCIo+3a5/0BYP8AwOH/AMRR9u1z/oCwf+Bw&#xd;&#xa;/wDiKPt2uf8AQFg/8Dh/8RR9u1z/AKAsH/gcP/iKPt2uf9AWD/wOH/xFH27XP+gLB/4HD/4ij7dr&#xd;&#xa;n/QFg/8AA4f/ABFH27XP+gLB/wCBw/8AiKPt2uf9AWD/AMDh/wDEUfbtc/6AsH/gcP8A4ij7drn/&#xd;&#xa;AEBYP/A4f/EUfbtc/wCgLB/4HD/4ij7drn/QFg/8Dh/8RR9u1z/oCwf+Bw/+IqCdNX1C7sPP06G2&#xd;&#xa;it7kTM4ud5wFYYxtH96t+iufs11jTnu44tMhnjkupZlc3WwkMxI42mrH27XP+gLB/wCBw/8AiKPt&#xd;&#xa;2uf9AWD/AMDh/wDEUfbtc/6AsH/gcP8A4ij7drn/AEBYP/A4f/EUfbtc/wCgLB/4HD/4ij7drn/Q&#xd;&#xa;Fg/8Dh/8RR9u1z/oCwf+Bw/+IpH1DXERm/sSE7RnAvck/wDjlNh1LW5oUlGhxqHUNte82sM9iNnB&#xd;&#xa;p/27XP8AoCwf+Bw/+Io+3a5/0BYP/A4f/EUfbtc/6AsH/gcP/iKPt2uf9AWD/wADh/8AEUfbtc/6&#xd;&#xa;AsH/AIHD/wCIo+3a5/0BYP8AwOH/AMRR9u1z/oCwf+Bw/wDiKq6kNa1OzNo+lwwq0kbGT7WGwFcN&#xd;&#xa;02jPSuiorB8vVbLV9QntbCK5hunRlZrnyyMIFPG09xU327XP+gLB/wCBw/8AiKPt2uf9AWD/AMDh&#xd;&#xa;/wDEUfbtc/6AsH/gcP8A4ij7drn/AEBYP/A4f/EUfbtc/wCgLB/4HD/4ij7drn/QFg/8Dh/8RR9u&#xd;&#xa;1z/oCwf+Bw/+Io+3a5/0BYP/AAOH/wARR9u1z/oCwf8AgcP/AIij7drn/QFg/wDA4f8AxFH27XP+&#xd;&#xa;gLB/4HD/AOIo+3a5/wBAWD/wOH/xFH27XP8AoCwf+Bw/+Io+3a5/0BYP/A4f/EUfbtc/6AsH/gcP&#xd;&#xa;/iKPt2uf9AWD/wADh/8AEVBqEmuXun3Nr/ZECefE0e77YDt3AjONvvWzaRtFaQxv95I1U/UCpqKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK//Z</binary>
<binary id="image23.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCAK6AsIBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/APQKKKKKKKKKKKKKKKKK&#xd;&#xa;pTavpkErRTajaRyKcMjzqCD7gmrisGUMpBUjIIPBFLRUU9wkHl+Zn944jXA7mpaKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKZNLHBE0s0iRxqMs7sAAPcmq9vqmn3cvlW19bTSYzsjmVjj6A1booqKO4SSeW&#xd;&#xa;Fc74sbuPUZFS0UUUUUUUUUUUUUUUUUUUUUUUUUUUUUVms7y+IVgeL91BbiaNwWHzsWUg84PA6EU+&#xd;&#xa;30eytppZYUkDyqVcmZ2BB5PBOB+FI2iWDWS2Zjl8hX3gefJnP+9uz36Zqf7Db/b/ALbtfz9u3PmN&#xd;&#xa;jH+7nH6VAuiWC2TWYjl8hn3kefJnP+9uz26Zqc2NubmC4Kv5kClYz5jYAxjkZwfxpg0y0EdzHsfb&#xd;&#xa;csWl/evyT6HPH4YpTp1sTakq+bQYi/eNxwBzz83Qdc0+Czgt5554lYSTkGQl2IOPQE4HXtUP9k2f&#xd;&#xa;2Oa12SeTM+9x5z5J46HOR0HANSmxtzcwXBV/MgUrGfMbAGMcjOD+NMGmWgjuY9j7bli0v71+SfQ5&#xd;&#xa;4/DFEmmWkn2Tcj/6JjycSuMYx15+boOuajl03y7g3NjIYZpJUaZmYuGQH5lAJIGR6AVoUUVzUWo6&#xd;&#xa;RbXV9Hepmb7S5z9leTjjuFNOMl/BHotpBN5BuXkWQlQx2bWbjOcHHT3xkEcVcvZbm3n06wS7kJun&#xd;&#xa;dXuCqeYAqlhj5dvbH3envzVa81ObRbuVJ5pbyFLRrkmQIHBDquBtAGPm7ipLy2uo3sZbm/llY3Kb&#xd;&#xa;ogqCMHn7vy7sDtkn3zVrSLqa5l1JZn3CG8aKPgDChVOOPcmqdrq80fhn+0Lg+dL5rR9AOsxRenpx&#xd;&#xa;+VP1Ga70aya/lvZLlUIEkUiJtG44BXaoPDEdSeM98Gq9jrgN7bxC6nvGuDtkQ2zRrE3XKkqPl6jD&#xd;&#xa;En7vPXLzqKTapNazatcWUyuwSNYkCFRjnc6HJ59a6Cqd3ai8keCeTNs8YzErFWyGznIwe3rQdMtD&#xd;&#xa;JbSbH3WyhYv3r8Aeozz+OaaNJswLoBJMXZzL++fnknjn5ep6YoOk2ZFqCkmLQ5i/fPxyDzz83Qdc&#xd;&#xa;09NOto5551V/MuBiQmRiD9BnA/DFJ/Zlp/Z32DY/2b+75r7uufvZ3dfeg6ZaGS2k2PutlCxfvX4A&#xd;&#xa;9Rnn8c0R6ZaR/a9qP/pefOzK5znPTn5ep6YoOmWhjto9j7bZg0X71+CPU55/HNPFjbi5nuAr+ZOo&#xd;&#xa;WQ+Y2CMY4GcD8Ki/smz+xw2uyTyYX3oPOfIPPU5yep4JqZbOBb1rwK3nsmwne2Mf7ucduuKg/sey&#xd;&#xa;+wfYtknkbt2POfOf97Of1p50y0MdtHsfbbMGi/evwR6nPP45p4sbcXM9wFfzJ1CyHzGwRjHAzgfh&#xd;&#xa;VOWzsLGOxh82aBRdAxAOzb32t8pJycYyfwrVooooooorN8Qsq6Jcs/3QATxnjcO1UReadfXVrHpk&#xd;&#xa;ZEyzK7EWzR/IOvJUflUumvfX1/fmS9dILa7McccaJlgFUkMSp454xg8nnpgiN5caa2of2jcRttZx&#xd;&#xa;EiR7BjPHKE449ala9muri0sopDBJNb/aJJUAJCjAwoYEZyR1B4z3waz72W50y012aK7kkniSNllk&#xd;&#xa;VMg49AoH6Vqa3dTWsVo0D7DJeQxNwDlWYAjn2qOOa51O6ukhuXtIbWUwkxqpd3ABJywI24Yds5zV&#xd;&#xa;O/1iWzuotOvLowyeV5slxBAzsVLMFCjDAH5RkkY5OMU+HWpJdJvZYvMka1IVZmhKmQH+LbgcgdeM&#xd;&#xa;ZBwMcVa0a5huy0sGrT3ijKmOVEQqQeTgIre3pzWrRRRRRRRVPVvtn9l3H9nf8fez9106/jx+dM/s&#xd;&#xa;ey+wfYtknkbt2POfOf8Aezn9aedMtDHbR7H22zBov3r8Eepzz+OaeLG3FzPcBX8ydQsh8xsEYxwM&#xd;&#xa;4H4VC+j2UlhHZMknkRtuUCZwc8/xZyep6mpvsNv9v+27X8/btz5jYx/u5x+lQLolgtk1mI5fIZ95&#xd;&#xa;HnyZz/vbs9umal/s62+2Q3W1/OhTYh8xsAc9RnB6nkioxo9kLae3CSeXOwaQec+Sc54Ocj8KfcaZ&#xd;&#xa;aXNnFaTI5hixsAldSMDA5ByePU0/7Db/AG/7btfz9u3PmNjH+7nH6VAuiWC2TWYjl8hn3kefJnP+&#xd;&#xa;9uz26Zqc2NubmC4Kv5kClYz5jYAxjkZwfxosPJ+zt5EjyJ50uWbqG8xtw+gOQPYVZoooqoPtH9qv&#xd;&#xa;meP7N5C4i/iD7jlunTGB17VbrJ1q/v7Ka0WzhtpFuZRDmV2BDEEjoDxgGrWoajb6csLXDY86VYlw&#xd;&#xa;R1Jxnk9BnmrCTwyRtIkqMi9WDAgfjRHPDKpaOVHVepVgQKaLq3LhBPEXOMKHGTnkUSXVvE22WeJG&#xd;&#xa;9GcA1Bc6nbWl9b2kz7ZJ1ZlJIAAXHXJ754+hqyZohF5plQR/39wx+dEc8Mqlo5UdV6lWBApBcwF1&#xd;&#xa;QTx7mAKrvGSPapao6okTx2/nXBgAuYypH8bBuF/HpV6mSyxwrulkSNScZZgBmnKwZQykFSMgg8EV&#xd;&#xa;WsbZ7f7RvKnzZmkGPQ1Fe2UlxqenXKMgS1d2cEnJDIVGPxNJqllPPJbXVoY/tNqzNGkpIRty7Tkg&#xd;&#xa;E9CfxqhNot3qhnfVHhhd7drdRbMWG0sGJO4DnK06Ky1u4NmdQntQLaRGYQknzsDknKjB9AOOT7VI&#xd;&#xa;bHUrW5uRYPbiC7lMskkhPmRsQFO0YIOAARnvS6foxj8Prpt86ytvZi6E9fMLqe3fBx0pHstTv1+z&#xd;&#xa;akbUWo+bMLMXcj7uQQAOcNweoA6E1NbxawZ0S5mtxbxnPmR8yTY4wwK4XPU46EccVBqdnqWoGW2e&#xd;&#xa;DTzaSAxiRmYyorDBIG3Gfxraqrug/tTbsb7R5Od/bbu6dfX2q1WVcanPJeSWWm23mTxgFpZeIR14&#xd;&#xa;3DJzx0xTrS/u1vEstRtQs0qs6SW+Wi2jsScHd7Y9Kutd2yvsa4iDg42lxnNZsd7cNda4hk+W12+S&#xd;&#xa;No+XMQb8efWrmkTyXOj2M8zbpZbeN3bGMkqCTxU63EDyGNZo2kHVQwJH4Uss0UIBllSMHoWYDNVL&#xd;&#xa;jV7O3uLWF5lJuSwRgw2jAJyTnpwR9anScyXKiN4HgaMnIfLlsgcDpjrz61JLPDDjzpUjz03sBmjz&#xd;&#xa;4dobzU2sCwO4YIHU0kVxBMSIpo5COoVgcVLVa8uI4HthJC8hlmEaFVB2NgncfQcHn3qzUcs0UIBl&#xd;&#xa;lSMHoWYDNPBBAIOQe9LRRRRVXUrZ7uxkgjKhmxgt04INWqoaZZSWcl+0jIRcXTTJtJ4Uqo59+DVL&#xd;&#xa;7JrEMDWUC2LWp3KHeRw+05ycBcZ59adeaZex3dneaZLEZbeLyHjnyFdCPUAkHIU/hTf7Gubq11GL&#xd;&#xa;ULlSb4Lkxj/V8cqOBkDsTye9MurDWtQe1N1JZwpb3McpjhZmEgVgTklcgjHGOuTmrU1ne2lxLNpP&#xd;&#xa;2cidt8sU7MF393BAJyQAMdOKR9PvYzHeQTxyaiqbHMvypIuSQpwOAu44IGTgZqeFdTW1meV7d7p+&#xd;&#xa;UiBPlJ2xuxuOevI6moNPsrz+0DeX0VnE6xsii2JO/cVJLZA6bRj6mtaiiiiiiiqOspFJpNyk9wba&#xd;&#xa;Ip80w6oPWr1FFUdU1JNMihd4Jp2mlESJCAWLEE9yPQ1bhlSeFJomDxyKGVh0IPINU9P1aDUZpo4E&#xd;&#xa;k2xqriRgNsituAK89PlPXFX6KKKKKhtZUmiZo42jAkdcMMchiCfxIJ/GpqKKKz1a1/4SGRQsn2v7&#xd;&#xa;IhLfw7N7YH1zmtCsfX/9fo//AGEE/wDQHqLxTbQTw6eZoI5CL6FRvQH5WcZHPY96XUrRYGtLHT7S&#xd;&#xa;3SGaRnkhVvJSTAHDbVOQehGORxULWF5bCR4bOwsbbypBOlvKTv8AlOMLsUZzjn0p+hafYW2g2N69&#xd;&#xa;rHJOlqkpmZA0n3QeGPPA4HoABUcNmb+MXv8AY+n3SXP75JLuctJtbkA5jOMA9ASBWfp8EOoyeHJL&#xd;&#xa;+JLp5bWbe06hy+NuMk9cZP5mtd4IZ9cGmPEn2GC1WVbcKBGxLMPmXoQMAgdiM03U7S303yjYxJbr&#xd;&#xa;ceZDJHEoVGHlO2do4zlBz6ZFO8OaXZpo+nXLQJLcGCNxNKoZ1yo4DHkAdh2rcrN1y8jsbWGWSz+1&#xd;&#xa;5uI1WMYyGJ4K57jt0+orlfEnjTUbK5W3trF7M4Dg3ABZ1PH3R05B7npXFXmqX9+Ct3eTzJu3hHkZ&#xd;&#xa;lB9gTx1New6B/wAi/pv/AF6xf+gCrdvKZ4ElMUkRYZ2SABl+uCadFIZYw5R48/wuORTbeUzwiQxS&#xd;&#xa;REkjZIAGGDjse+M0QSmYOTFJHtcrhwBuweo56HtRBKZg5MUke1yuHAG7B6jnoe1OEhMzR7HAVQ28&#xd;&#xa;j5TnPA9xjn6imiU/aTD5UmAgbzMDaeSMdc549O9BlP2kQ+VJgoW8zA2jkDHXOefTtTjIRMsexyGU&#xd;&#xa;tvA+UYxwfc54+hprylZ44vKkYOGJcAbVxjrz3zx9Kc0hWRE2Od2fmA4XHrUeT9ux9nGPK/13fr93&#xd;&#xa;+tT1j+H/AN02o27/ACzLeSylD1CuxKn8QDVjWL9bGwuGSRVuRbyyxKeclFz+nFQ2uj6dcWcU01nB&#xd;&#xa;JPIgZpnjBkLEZzuxnNYnhq5lu7XxBNO2595TPqFTaP0ArRF3LYeBILqAgSxWMbLkZGdopjaTeLGD&#xd;&#xa;a6dp8F0vK3S3TeYzernygWyeoJ571PZwQ6teag+oRJcC3uDBHHIoZFUKpztPG75jz6YqtqOj6dHr&#xd;&#xa;ekILOAxySygxmMFQBETtAxgDI3Y9ST1NWY4IbbxXbw28SQxLp8m1I1CqP3iHoKTTraDVnvJ9Rgju&#xd;&#xa;mjupIY1lQOqKrEDaD0J4yR1wKyJrdJfHEGlnK2cELSJEhwPmA3KR/cOPu9Ota1xaW2n65pK2NvFb&#xd;&#xa;CaSRZBCgTeBGxAOOvPPNb1U9SkuoYo5bRPMCSBpYwMs6YOQvvnHp3rhNV8f6iJvJt7NLOSJmWVZG&#xd;&#xa;8wkjjHQYxg1yV1qF7eKq3d5cTqpyBLKzAH8TXtVk23TIG2lsQqcDqflqfzD5PmbHzt3bMfN9PrRD&#xd;&#xa;IZYUkKPGXUNscYZc9j7023lM8CSmKSIsM7JAAy/XBNFvKZ4ElMUkRYZ2SABl+uCaLeUzwiQxSREk&#xd;&#xa;jZIAGGDjse+M06KQyIWKOmGZcMOeCRn6HGR7GmwSmYOTFJHtcrhwBuweo56HtRDKZTIDFJHsfaC4&#xd;&#xa;A3cDkc9Of0oEp+0mHypMBA3mYG08kY65zx6d6DKftIh8qTBQt5mBtHIGOuc8+nagyn7SIfKkwULe&#xd;&#xa;ZgbRyBjrnPPp2oeUrPHF5UjBwxLgDauMdee+ePpTmkKyImxzuz8wHC49abJKUmijEUjiQkF1A2pg&#xd;&#xa;Z55/CiaUxGMCKSTe+0lADt4PJ56cfrRcSmCB5RFJKVGdkYBZvpkinTSGKF5AjyFFLbEGWbHYe9Ne&#xd;&#xa;UrbNN5UjEJu8sAbjxnHXGfxp3mHyfM2Pnbu2Y+b6fWiGQywpIUeMuobY4wy57H3ohkMsKSFHjLqG&#xd;&#xa;2OMMuex96bbymeBJTFJEWGdkgAZfrgmi3lM8IkMUkRJI2SABhg47HvjNEcpeaWMxSIIyAHYDa+Rn&#xd;&#xa;jn8Kqane29vZ3jXtpJJbQRhnyissgPYAnnHfPrWhRRWPr/8Ar9H/AOwgn/oD1TlS5gW40WOSSI3D&#xd;&#xa;5tZ1JGxCSSFHYRjaOCOo6VPPJFpt9fLCFgxZwRwLHGD85abaAvAJz2yKyZ7qexRbqOHXEmEiAtdS&#xd;&#xa;Zh+Zgpyu89icehxV3RbG51LTlubjU7vd5soiCSsu0CRh83Pz9Py4rX0e8e8tpPNA8yCZ4GYdHKHB&#xd;&#xa;bHbOM45x61fooqK3EwjP2hkL73wV6bdx2/jtxn3qWiiiqKkf224+xkH7Mv8ApXOD8zfJ0xx1696v&#xd;&#xa;VR1DTItQeF5ZZkMLb08t9uG5Gfryanu7WK8iEcy5AYMpBwVYdCPcVCdNie28iaSaYbxIryPlkYdC&#xd;&#xa;D7daYNIgLhppZ52AYKZX3bMggkfgSKswWsUFlHaIuYY4xEATn5QMfyqodEtmj8lpJ2tsbfs5k/d7&#xd;&#xa;ey49KVNGtY7W2gi8yP7MpWKRXw6g9Rn3wKlm06KaKJXeUyQ8xzbvnUngnPuOKbHpcCM7u8s0jxmL&#xd;&#xa;fK+WCnqB+VWbW3S0tYbaLIjhRY1ycnAGBUtVr37Vsh+x7N3nJ5m7/nnn5se+Kfd2sF7bPb3USywv&#xd;&#xa;jcjdDg5H6iud1DwJpF0srQK1tK4+Uqcqp/3f/r10Gn232LT7a137/IiWPdjG7aAM4/CrFFFFFFFF&#xd;&#xa;FFFReW/2rzfNPl7Nvl44znrmpao3Gk2s919q2tHdY2+dGcPj0zRb6XbQ3IujvmuQu0TStuYL6Z9O&#xd;&#xa;v5006RFyq3FykRz+6WTCYPUY9Kki022iN0UUj7UAJBnjAUKMenAqe1t0tLWG2iyI4UWNcnJwBgVS&#xd;&#xa;/saDy/J865+z42+R5nybem3HpjiprnToricTh5YZtuwyRNtJXJIB9sk1GdItigy0vmhzIJ9/7zcQ&#xd;&#xa;FJz/ALoA+lSQ6dFFcx3JeWSZImiDyNklSwY5/ECkn02Kadp0kmglcAO0L7S4HTP05/Oki0u2ingn&#xd;&#xa;G8yw78MzZLF8bifU8Cpp7SKe5trhwfMtmZo8HjJUqf0NWKqX0NrM9qblwrRzh4ctt3PggD34J4p9&#xd;&#xa;7ZW1/AYLuFZoiQdrdM1zepeAdMulc2jNaSs2cgblA9AuR/Ouot4vJt4os7tiBc4xnAxUlFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFVtR+1fYJvsGz7Vt/d7+mferNFFU7+x+2vZt5mz7NcCb7ud2FYY9vvVO9vE88&#xd;&#xa;c7oDLEGCN3UHGf5CqV9pC3lxLOZdjlYvL+XOx42dlY88jL9OOnvVW50XUL63aG91YSLuRlEdvsGV&#xd;&#xa;YNz8xz0ql4ftNTl0tGg1OOG3MsuI/s25gPMbPzbvr2rorS1is4jHCuAWLMSclmPUn3NT0UVV06FI&#xd;&#xa;Ld0jlWUGaV9y9i0jMR+BJH4VaoooqsIZxqTTmb/RzCEEXo+SS35ED8Ks0UUUUUUUUUUVR1T7P5dv&#xd;&#xa;9pnkhH2mPYU/ifd8qng8E8Gr1FFFFFFFFFFFFFVv3P8AaX+sfzvJ/wBX/Dtz1+uas0UUUUUUUUUU&#xd;&#xa;UUVTv9m+z32r3H+kDaVGfKO1vnPt2/GrlFFFFFFFFFFFFFFFFFFFFFFFFFFUNci8/R7qL7SlruTH&#xd;&#xa;nO20J7k1foooooopqIqLtRQq+gGBTqKKKr2W3yG2QNAPNk+VhjJ3tlv+BH5vxqxRRRVF7GQ6wl+l&#xd;&#xa;3IiCLy3gwCr8kg+xye3pSCzvRbTxnVJDJIwMcvkpmIZ6AYwfTmnm1u/Mtm/tB9sSgSr5afvj6njj&#xd;&#xa;8KUW9yDdE3zkSjEQ8tf3HB5HHPbrnpUS2V+LJoTq0pnL7hP5MeQP7uMY/wD11OYLg3MEgvHEcakS&#xd;&#xa;RbFxKcdScZHrxVa8W5tbC+lbUHLNloWMS/us9FHHPYc1U0S41HULWBruc21xau0dzCqqfNI4yeOO&#xd;&#xa;Qfu8VpC3uQbom+ciUYiHlr+44PI457dc9KQ2t35dsv8AaD7omBlby0/fD0PHH4Uv2e5+2TS/bn8l&#xd;&#xa;02pD5a4jPHzA4yeh6+tRw2d7HazRSapJLK/3JjCgMf0AGD+NPktbtvsm3UHTysediND5/Trx8vQ9&#xd;&#xa;MdaY2nNPcs93cvPCJFlihKhREynIIIwT+NX6KKKKKKKKKKKKKrSW8rX0U6XJSNFIeIIpD+nzYyMe&#xd;&#xa;1MFrd+Xcr/aD7pWJiby0/cj0HHP41SvbmaN7SG31ENOmRMCq7XxjLOcfL9BjOeOlP0hr6+01rqe5&#xd;&#xa;eN7qPMcflr/o556cc9jz6VYe0vGggRdSkSSM5kkESEy+xGMD8Kd9lu/7R+0f2g/2b/n28tNvTH3s&#xd;&#xa;buvPWgWt35dyv9oPulYmJvLT9yPQcc/jVbVftdppy3Ed8we1jLOpjT/SWAyAeOMkH7vrVbQP7Rub&#xd;&#xa;Gf7ZqbvdKDDInkoPIlxnggYbAI9RV82d6baCMapIJI2Jkl8lMyjPQjGB6cVJ9nuftk0v25/JdNqQ&#xd;&#xa;+WuIzx8wOMnoevrUTWV+bJYRq0onD7jP5MeSP7uMY/8A1VP5Fx9v877Y/kbcfZ9i4z67sZpgtbvz&#xd;&#xa;Llv7QfbKpES+Wn7k+o45/GmGzvTbQRjVJBJGxMkvkpmUZ6EYwPTinyWt21+syag6QDGbcRoQ3/As&#xd;&#xa;Zq5RRRRRRRRRRRRRRRRRRRRRRRRRRVTU7FdS06ezdyizLtLAcimG0vCLUDUpAYjmU+Un7/kcHjjv&#xd;&#xa;0x1pwtbvzLlv7QfbKpES+Wn7k+o45/Go5LK/aziiTVpUmQkvMIYyX9BjGBj2qQ2t35ls39oPtiUC&#xd;&#xa;VfLT98fU8cfhWRol7falNqkT3ciDKyWsnlphYnLFCBjnKgcNzWqbS8ItQNSkBiOZT5Sfv+RweOO/&#xd;&#xa;THWpRBcC5nkN45jkUCOLYuIjjqDjJ9earzw3cOmLnUZDLCTJJKIkzIoyduMYHbkelUvDd1e37TXd&#xd;&#xa;1dPsf547UomERvmQ7gMk7ff61f8Asd79g8n+1JPP3Z+0eSmcem3GKnuYZ5XhMN00Co4Z1CK3mD+6&#xd;&#xa;cjj8KQQXAuZ5DeOY5FAji2LiI46g4yfXmpoVdIUSSQyuqgM5ABY9zgcU+iiiiiiiiisvXpSIbW2x&#xd;&#xa;8t3crCx7qMFsj/vmo2/0PxOm35v7RiO7P8HlDjH13n8q2KKKKKKKKKKKKKKKKKKKKKy5bi8vp3hs&#xd;&#xa;QkdsjGOWdiQxIODsxnOCCDnHINQatptomnNZwQpD9ukWGWVR87Zz8xPVj15Pqa26KKKx9Y/0jU9M&#xd;&#xa;sTwryG43DrmIqQPxzToEaz8QzRINltdRCbHXfNkhjnr90Lx0rWoooooooooooooooooooooooooo&#xd;&#xa;ooooooooooorN1+6mtdKlNo+27k+S3GASz9QADx0BqCa0TTtQ02S2AitlU2zopOX4Ajz/eC4bqeM&#xd;&#xa;+9bNFZmvCSWzitIHKTXUyxq2SAAMuwJHYqjD8fSojjT9ehRFWGzng8sAABTKCNij0+UNwOOK2KKK&#xd;&#xa;KKKKKKKKKKK5qbV9Pt/FVw97dR2zWsIgVWOfMD7X3e2OmKbrPibSDZiaC+hmlt5FlWIHBkI7Z7da&#xd;&#xa;6eiiiiiiiiiiiiiiiiiiiise5TzdSlOmT+TeRgef8m5H4BCtyPmIxhucDNRRzy6lrdspieL7EjNd&#xd;&#xa;QucqHYDYR/extbB/xrdooorl4tc0xPEF/LeXsSiLbDCsp5jZSwkwOwPy9OuB6VJd+IdMlv8ATntL&#xd;&#xa;uK4l88ReWpwcOQufw610lFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFc/rV/a2+u2UWozpDbR&#xd;&#xa;xm4Qnj96DtHP0ZuKq+IfEelT6JcraahE1yFzFsJDBuxB7Gult7iK6gSeBxJE4yrDoRUtc3eazYwe&#xd;&#xa;Kdt3eJFHawFSkh4EjbSGA9dpYZ9yO9QeIPEOkS6cZbW/hkurZhNAoPVwCBx34Jrq6KKKKKKKKKKK&#xd;&#xa;KKjuCi28plGYwhLD1GOaj094JNPtntV227RKYlxjC4GB+VWKKKKKKKKKKKKKKKKKKKKjllRGWMyo&#xd;&#xa;ksmRGGP3iBngd/WnRhxGokZWcAbiq4BPfAycfmadRRRRRWfoE0VxolpNBbi3iePKxA5CD0zWhRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRWfo80U8V0YbcQBLuVGAOdzBiC349a0KKKp6bJayJc&#xd;&#xa;GzTaq3EiycYzIG+Y/nVyiiiiiiiiiiiiio59/kSeWod9p2qehOOBTLHzvsNv9ojSKbyl8yNPuq2O&#xd;&#xa;QPYGp6KKKKKKKKKKKKKKKKKKKrQRiZkup7YxTqCoDMG2jJ54OORz684qzRRRRRRVTTPtH9nQfbII&#xd;&#xa;4Ljb88cf3VPoOT/OrdFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFVLD7Rsn+0wRwnz32BP4k&#xd;&#xa;z8rHk8kcmrdFFVLD7Rsn+0wRwnz32BP4kz8rHk8kcmrdFFFFFFFFFFFFFRXSGS1mRWCsyMAxOADj&#xd;&#xa;rUWlxPBpdpDJIsjxworOpyGIUAkHvVqiiiiiiiiiiiiiiiiiiqJ8jUpcJMxW0nxIgyv7wAEAn2yD&#xd;&#xa;6Gr1FFFFFFFVNMt1tNOggSczrGuBKTkt71booooooooooooooooooooooooooooooooooooooqpY&#xd;&#xa;W62yThZzNvneQknO0k52/h0q3RRVDSbeS3juRLMkpe6lkUqxbapYkKfQj0q/RRRRRRRRRRRRRUN2&#xd;&#xa;UFpMZQTH5bbgOuMc1FpJhOk2RtVdYDAnlh/vBdoxn3xVuiiiiiiiiiiiiiiiiioroTG1mFqyLOUb&#xd;&#xa;yy/3Q2OM+2adHFHEXMcaIXbc+1QNzep9TwKfRRRRRRRWfoDWraJaGxWRbYx/u1k+8B71oUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUyaQQwvKwJVFLHHXAqppWpDU7YXCWtxBGwDIZlA3gjIIwTxTb3VHtZzEumX1w&#xd;&#xa;MA74UUr+rCiz1R7qcRNpl9bjBO+ZFC/oxqW/vGs0Rls7m63HGIFBI+uSKpf25L/0BNV/79p/8XWr&#xd;&#xa;DIZYUkKPGXUNscYZc9j71lf25L/0BNV/79p/8XV+xu2vITI1rcWxDbdk6gMenPBPHP6VWu9Vktrl&#xd;&#xa;4V0vUJwuP3kSKVPGeMsKfY6k95MY2069tgF3b50UKenHDHnn9Kff3zWXl7bG6ut+f+PdVO3GOuSP&#xd;&#xa;X9Kp/wBuS/8AQE1X/v2n/wAXWrNIYoXkCPIUUtsQZZsdh71lf25L/wBATVf+/af/ABdaVpObm2SZ&#xd;&#xa;oJYC2f3coAYc45wTWTFejTpLiGDR9TdWneRnVEKsxOSRluh7VoWF8175m6xurXZj/j4VRuznpgn0&#xd;&#xa;/WrKSpI8iowLRttcD+E4Bx+RB/Gn1n6O1q0V19kWRVF3KJN/d9x3Ee2elaFFFFFFFFFFFFFFMmcx&#xd;&#xa;wu6oXZVJCjqx9KZZzPcWcE0kTQvJGrtE3VCRkg/TpU1FFFFFFFFFFFFFFFFFZ+lIJlOpSW0ltc3c&#xd;&#xa;aebE5OV25wOQPU1oUUUVDeTPb2c80cTTPHGzrEvVyBkAfXpUMNsZLHa01yjS4ckv86E4O0HHFTG3&#xd;&#xa;zNFJ50v7sY27vlb3I7037L8ky+fP+9Oc7+U9l9KGtd3kfv5x5OOj/f6fe9en6mj7L88zefP+9GMb&#xd;&#xa;+E919KabLMMUf2m5/dnO7zPmb2J70/7N/pEkvnTfOu3Zv+VenIHY8VHFY+XFIn2q5fzABuaTJX6e&#xd;&#xa;lONpkQD7RcfuTn7/AN//AHvWo7m3KQXkgvZIDJE37x2ysPH3gOMY69aswf6iP955nyj5/wC9x1qS&#xd;&#xa;iiiiiiiiiiiiiiiiobuNpbSaNPvPGyj6kVFpNu9ppNlbS4EkMCRtg5GQoBq3RRRRRRRRRRRRRRRW&#xd;&#xa;fpv/AB+6t/19L/6JirQqjpc11NHcG7Qoy3MiR5XblA2FPvx3q9RRRRRRRRRRRRRUdxn7PLtcRnYc&#xd;&#xa;Oei8daj0/d/Z9tvnW4bylzMpyJDgfMPr1qxRRRRRRRRRRRRRRRRVDzvtt8Et53WK1bMpQcO/TZu6&#xd;&#xa;ED5tw6g7ene/RRRRVfUEnk0+5S1bbcNEwibOMNg4P51Jbh1t4hKcyBAGPqcc1JRRRRRRRVfUNv8A&#xd;&#xa;Z9zvga4XymzCoyZBg/KPr0qS3x9ni2oYxsGEPVeOlSUUUUUUUUUUUUUUUUUyWRYonkf7qKWP0FNt&#xd;&#xa;bhLu1huYsmOZFkXIwcEZFUL/AH3t/FYw3UsCrG0sr27AOpyoRTkEAEFj0528dDWXe6ibrQtNurwx&#xd;&#xa;wypfQfaF+6ImDgkEE/LgYPNbFpq9vd3HkhJ4mbOwzRlBJ/uE/e4547UXmsQWk5hENzcOv3xbQmXZ&#xd;&#xa;3AbHQ455qtq+uLaaDJqFohlccBShbY3cOByuOhz0PFIfEtosqxS219FI4JjSS2ZTJjqFB6nnoKtx&#xd;&#xa;6tA1k91JFcQKrbQk0RR3bHAVTySc4GOp4pLPWILucQmG5t3b7guYTFv7kLnqcc8UXmsQWk5hENzc&#xd;&#xa;Ov3xbQmXZ3AbHQ455qlL4kiW/hiitrqaJ4nZ/Kt2dlYFPl46EZIYdQcCqj6ldtql5eRPMltaxQyP&#xd;&#xa;bzLtxGdxkJXruAXitjVblkEFpC5Se7fy0Yfwjq5B7ELuI9wKo6PqfkeH4ZryWW4mMkqKAN8smJGH&#xd;&#xa;Cjk4AycdhVn+37MW088yXEHkpvaOaIo5XpkKeSMkc1Jb6zb3FyIVjuFVjhJniIik9Nr9DntjrWjU&#xd;&#xa;MFskEtxIpYm4kEjZ7Haq8fgoqaqem7wlxvukuf8ASJMFTnYN3CH3HSrlFFFFFFFFFFFFFR3Hl/Z5&#xd;&#xa;fO/1Ww7/AKY56VHp/wBn/s+2+x/8e3lL5PX7mBt689MdasUUUUUUUUUUUUUU1XVs7WB2nBweh9Kd&#xd;&#xa;Ve5llVo47dUaR253NjavdsdT2HHciplRUztULk5OBjJ9adRRRRVXVBGdLuxNK0MXkvvkUZKDackY&#xd;&#xa;9Kltdv2WHY5ddi4Y9SMdaloooooooqK6aZLWZ7eMSzKjGNCcBmxwM/WnRF2iQyLtcqCy5zg9xT6K&#xd;&#xa;KKKKKKKKKKKKKKKr6h/yD7n/AK5N/I1V0R1i8N6fI5wq2cbE+gCCqOlJqUr3OoRi2Iu33RySbsvC&#xd;&#xa;CTHwOB8rfX1rM1fdY3sMF95CJe3tvMqpkq7B8SE56fL5fXj071u6lPb3C2sFtIkk5uImQRnO1VdW&#xd;&#xa;fkdPlDfXp7VHOI4dUuJrO+jt58r58Mwwkp2gA5PPC4+73HPeq2qTm/8ACOpFINrjehCDiRgeWX1B&#xd;&#xa;6ipruWC48T6T5ckcu2K4PysGwcJirWsvITbQJcC1EjEmcqrbCoyPvDHNYxaRfFGkRSau9+d0jY8p&#xd;&#xa;VVf3bfxKMZ9s1o6FLHZ2b217IkV2krmUSMASCxZeejfKR0Jx0p32q1bWbaeN0SEQ3CM5GxS++Lue&#xd;&#xa;ucHnvSaeY5vEer4KyRvDb+4Iw9JoulTWtw0l0zt5CfZ4S5Db0HPmexO4j6CsvSmlk0+1gS9FiFae&#xd;&#xa;QTFEYk+c4x8w449Kz9ZZjc6ij6i9+yaY4LmJUC5kjOAVAB/Wuk16SK50We0sZI3uJFCQJGwyG7Y9&#xd;&#xa;PrW3Va1uTPcXkZUAW8wjBHcGNGz/AOPfpVmqem/Y9lx9h+79ok83r/rN3z9ff04q5RRRRRRRTZJE&#xd;&#xa;iQvI6oo6sxwBSebHvVPMTc4yq7hkj2pPPhw581MRnDncPlPv6U1rq3RVZ54lV/ukuAD9KeZIxIIy&#xd;&#xa;6+YRkLnnHrim/aYNjP58e1Dhm3jAPvTLieLyGAaORnQlIyw/ecdB65qLT7iM6dCXENu0cS+ZEpAE&#xd;&#xa;Jx932x0/CrH2iD5P30f7z7nzD5vp60vnw5ceamYxlxuHyj39KQ3MAiEpnjEbHAcuME/Wl8+HKDzU&#xd;&#xa;zIMoNw+Ye3rQJ4W8zEqHy/v4YfL9fSjz4cIfNTEhwh3D5j7etL5se9k8xNyDLLuGQPem/aIPLWTz&#xd;&#xa;o9jHCtuGCfQGnCSMyGMOvmAZK55x64pUdZFDIwZT0IOQa5gNCNCmu0vpzfpHI6D7ZIfnGdo2bsHk&#xd;&#xa;DjGD6VatNV1O7vJbWC2hJtxEZJZmKghkVjjA+9knjpUwv9UvZZm0yGzMEUrQk3EjKxZTg8KCMelN&#xd;&#xa;XV7rUHVdIhhJEMc0n2tivyyDK42554Ofw61R0C+uYtVuLO4ji8y5vJ2kMbEhSqRdM/71a1zq62mp&#xd;&#xa;TwTLiGG1WcuOSSWK4x+FVrWS7juW1G7tIDFLGSskMjPIi7dwBDYCgheQv8WPrVdvENzHbf2hJ9gN&#xd;&#xa;gVEuxZiZ9h5A24xuwRkZ/GrFlqeoX80UkCWK20hB2SysJ1TvlQCM/jW2zBVLMQFAySTwBUf2mDYr&#xd;&#xa;+fHtc4Vt4wT7UG4gEvlGaMSf3Nwz+VH2iD5/30f7v7/zD5fr6VBfXdpFYSyTlJYmjY+WMN5oA5UA&#xd;&#xa;/ez0x71Lb3EEkSiJkXagJTIBQY6Edqd9og8tZPOj2McK24YJ9AacJIzIYw6+YBkrnnHrikWeFkDr&#xd;&#xa;KhUnaGDDBPpUlMMsYlERkQSMMhCwyR9KTz4cOfNTEZw53D5T7+lHnRfJ+9T959z5h8309aBPC0pi&#xd;&#xa;WVDIOqBhkfhVe+mgfTbom7EMYjZWnR+YzjrnsRmpYJIljhj88OzINpZvmcY6+9P8+HDnzUxGcOdw&#xd;&#xa;+U+/pR50XyfvU/efc+YfN9PWjz4cuPNTMYy43D5R7+lJ9pg2K/nx7XOFbeME+1S0UUUUUUUUUUUU&#xd;&#xa;2RFljaNxlWBUj1BpkNvDBapbRoBDGgjVDyNoGAOevFPjjSKNY40VEQBVVRgADoAKhurGzvdv2u1g&#xd;&#xa;uNmdvmxh9ueuM/QUlrp9lZszWlnbwMwwTFEqkj8BRdafZXjK13Z287KMAyxKxA/EVPHGkUaxxoqI&#xd;&#xa;gCqqjAAHQAVWt9L0+0l822sbaGTGN8cKqcfUCpri2gu4vKuYI5o852SIGGfoajg0+yttn2ezt4tj&#xd;&#xa;Fl2RKu1iMEjA644outPsrxla7s7edlGAZYlYgfiKWaxs57dLea1gkgjxsjeMFVwMDAPA4p0FpbW2&#xd;&#xa;fs9vFDkBT5aBcgdBx6ZP51NVWXTbGaFYZbK2eJCWVGiUqCeSQMd6p6rosNxo9xaWNvbQSPEY4yEC&#xd;&#xa;hQTkjgcDPP1q3b6Xp9pL5ttY20MmMb44VU4+oFW6pWMTx3eos6kLJcBkJ/iHlRjP5gj8Ku1T03eU&#xd;&#xa;uN9qlt/pEmAoxvG7hz7nrVyiiiiiiis6W3gudWliuJlmja2TdZSLuXhyQ+Dx146fw1bNpbGaKY28&#xd;&#xa;XmxDbG+wbkHTAPam/YbPZMn2WDbOd0q+WMSH1b1/GmS6Xp80UcUtjbSRxAiNGhUhAeuBjipjbQG5&#xd;&#xa;FyYIzOq7RKUG4L6Z64qIabYiGWEWVt5Up3SJ5S7XPXJGOad9hs98L/ZYN0A2xN5YzGPRfT8KQafZ&#xd;&#xa;ATgWduBcHM37pf3h/wBrjnqevrQdPsiIAbO3ItzmH90v7s/7PHHQdPSl+w2e+Z/ssG6cbZW8sZkH&#xd;&#xa;o3r+NNbTbF7VLVrK2a3Q7liMSlFPPIGMDqfzp32Gz3wv9lg3QDbE3ljMY9F9PwoWxs08/ZawL9oz&#xd;&#xa;52IwPNznO716nr6mj7DZ7IU+ywbYDuiXyxiM+q+n4U4WlsJpZhbxebKNsj7BucdME96Z/Z9l9njt&#xd;&#xa;/sdv5Mbbkj8pdqtzyBjAPJ/OpBbQC5NyIIxOy7TKEG4r6Z64qpoEMVvolpDBcC4iSPCygYDj1xUO&#xd;&#xa;m6JZ28ETz2FqbpWLGXylLbtxIO7Gc9KmsbSWDVNTuHA8u5kjaPB5wECn9RVOKLU9LkuIrSxivIpp&#xd;&#xa;3n8xrjyiC5ztxg9PWmW+nX2iuGsYUv8Afbwwvvk8nb5akA9DnOT9Md6rWuj6nZXTXx8q7uUuJWCZ&#xd;&#xa;8oSK6xjOeduNh45p1nZXWranJqk8giiktjAiQy7lUhnUhum/qT0GCcds1et01OaIWU9tFbW6RlDK&#xd;&#xa;JfMMg27QNuBt6g9T0x3zWbDockcKWQ0LTQEUR/bnCOzY43lNvJOM43d+tWVsby7v4pn0u206QSrI&#xd;&#xa;9zDKHkcA5KHCg4boefwNbV8SLG4ItxckRN+5PSTj7v49Khj0+yktIEfT7dUj+dIjEpEbHk4GODmp&#xd;&#xa;G0+ya7+1tZ25ucg+cYl35Ax97GelA0+yAnAs7cC4OZv3S/vD/tcc9T19aDp9kRADZ25Fucw/ul/d&#xd;&#xa;n/Z446Dp6U5bK1SWWVLaFZJhiRxGAXHue9N/s+y+zx2/2O38mNtyR+Uu1W55AxgHk/nUgtoBcm5E&#xd;&#xa;EYnZdplCDcV9M9cVWuLLT4dNliaGK3tkBkJjUJ5ZAzvGOhHXI5qXUgDpt0DcG2Bhf98OsfB+b8Ot&#xd;&#xa;NgtLZjb3LRxTXCRhUuGQF8Y7HqM5P5mn/YbPZMn2WDbOd0q+WMSH1b1/GlNlakwE20JNuMQ/ux+7&#xd;&#xa;H+z6dB09KRLGzjumuktYFuG6yiMBz+PWk/s+y+zyW/2O38mRtzx+Uu1m45IxgngflTzaWxmimNvF&#xd;&#xa;5sQ2xvsG5B0wD2pv2Gz2TJ9lg2zndKvljEh9W9fxpTZWpMBNtCTbjEP7sfux/s+nQdPSk+w2e+Z/&#xd;&#xa;ssG6cbZW8sZkHo3r+NQ3FlYw2PNjbNFbBpI4/KXap68DHFWreXzreKXG3egbGc4yM1JRRRRRRRRR&#xd;&#xa;RRUF8xWxuGUkMImIIPIOKxNJ8T6Suk2S3Wpx+eIEEm9iW3bRnJ9c1tWd7bX8AntJlmiJI3L0zUF9&#xd;&#xa;rWnadMIb27jhkZdwVjyRyM/oaZaa/pV7cpb2t9FLM+dqKeTgZP6CrN9f2unQia9nSGNm2hm6E8nH&#xd;&#xa;6GqH/CU6H/0EoPzNadxcRWsDzzuI4kGWY9AKzP8AhKdD/wCglB+ZrStLqC9tkuLWVZYXztdehwcH&#xd;&#xa;9RVO71/SrK5e3ur6KKZMbkY8jIyP0NPsda07UZjDZXcc0iruKqeQOBn9RT7/AFSx0zy/t1ykHmZ2&#xd;&#xa;b++MZ/mKrQ+JNHnmSGLUIXkkYKqg8kngCr93dQWVs9xdSrFCmNzt0GTgfqazf+Ep0P8A6CUH5mtW&#xd;&#xa;GVJ4UmiYPHIoZWHQg8g1lf8ACU6H/wBBKD8zV+xv7XUYTNZTpNGrbSy9AeDj9RVmqOlw3UMdwLty&#xd;&#xa;7NcyPHlt2ELZUe3Har1FFFFFFFZ6ra/8JDIwaT7X9kQFf4dm9sH65zVy4l8m3llxu2IWxnGcDNR6&#xd;&#xa;fc/bdPtrrZs8+JZNuc7dwBxn8aejymeRXiCxKF2PvyWPOeMcY4+ualqvPdxQXNtbuT5lyzLHgcZC&#xd;&#xa;lj+gqk+p3S6+umrYo0bR+aJ/PwdowCduPU4xmrst3FFeQWrk+bOrsnHGFxn+YqxRRRVeW7iivILV&#xd;&#xa;yfNnV2TjjC4z/MVYoooqnpMlrLpdu9gmy1ZMxrjGBVyiiiq9yjTEW7wLJbSoyyktjAxjGO+cmpkR&#xd;&#xa;Y0VEGFUYA9BTqKKiuo3mtZoopTDI6MqyAZKEjg49qdErJEiu+9lUAt6n1qK+ufsdo8+zfsx8ucZy&#xd;&#xa;QP61YqKF5WMnmxCMK+EIfduXA56cd+Paparm7iF+tkSfOaIygY42ggHn6kVYqtqRA026JtzcgQv+&#xd;&#xa;5HWTg/L+PSm6tIkOk3sssQmjSB2aMnAcBTkZ96ltGV7SFkTYrRqQvoMdKmorJfU76Zi+m6fFdW3R&#xd;&#xa;Zjc7A30+U5HvmrtjcyXMJM9u9vKjbXRskZ4+6cDcOetWaijuEknlhXO+LG7j1GRUtFMlLiJzEAZN&#xd;&#xa;p2g9M9qIi5iQygCTaNwHTPen0UUUUUUUUUUUUVz3i7TW1uKz0yOTy3eUzs5GdqKNpPucuvFauk33&#xd;&#xa;9paXb3vl+V5ybtm7OPxq5RRRRRRRRRRRRRRRWfo62qxXX2RpGU3cpk39n3HcB7Z6VoUUUUUUUVUH&#xd;&#xa;2j+1XzBH9m8hcS/xF9xyvXpjB6d6fqH/ACD7n/rk38jVfQP+Rf03/r1i/wDQBUNi7HxLqqliVWK3&#xd;&#xa;wM8Dh6z4bYWyFNWhuElUY/tFGLBm/v8AGdmOuWAHFTavawXOr6Esn75WaRd277w8piDkfnUkcEdv&#xd;&#xa;4rt4oV2ounyYGc/8tENM1ayt7jxPpfmx7vMin3fMRnATH86ZqPnDUlsbfT5rq1ggV/LjmVBlmYfN&#xd;&#xa;uOT9zjHvntVaRdS+yzW8lvPY2jzW/lsZkeRGMyAhSCcDHTIPJPXpWxNBZaRay3XzodoQybiWJYgD&#xd;&#xa;2yTjtXPaobyz0me4XR7mCeNM/a3ukZgf7xAbk/QVq6tZW9x4n0vzY93mRT7vmIzgJj+dO0+2i1Ca&#xd;&#xa;8W4U+TaTm3iiViFAADbj33fMR1xgDis/XpHtI7zTbd3jg8uCZCGO6MtMFIU+nGfqT24rorXTra0f&#xd;&#xa;zIkPmFdpcsSTVuuVu/EOpaXYbJdDm89IN7PDGTBG2D1IzwO/NcXqXjDWNQY5nFuhTY0cGVUjnnkk&#xd;&#xa;55rq/hrNLNYXplleQiVcFmJxxXYq4Z2UBsrjOVIH4Hv+FMNwglMe2TcCBny2xznHOMdufTvUNrDH&#xd;&#xa;YqluHmleTLGRwWLEYyWYDAPT0zVh5VSREIfLkgYQkDAzyQMD8aVnCsgIbLnAwpPYnn06dT/WkklW&#xd;&#xa;MoGDne20bULc++BwOOp4oklWIKWDncwUbULcn1wOB79BVbVpII9MuPtTyxwNGyvJEjMyAg5PAOMe&#xd;&#xa;uOKnttn2aLy2LpsG1j1Ixwaqa7/yCJ/+A/8AoQrQrD04T3EOuxRTFJTdyJE5Odh8tMH8Cc1DBFbR&#xd;&#xa;BVvYbnTroMMThiVbpzv5RdxyMHnn3FOurC2uPGEfmx7t9i7N8xGSHQD9K3o0WKNY0GFUBQPQCo7y&#xd;&#xa;OWWznjgk8qZ42VJP7rEcH8DSX3nfYbj7PGks3lN5cb/dZscA+xNPg3+RH5ihH2jco6A45FSUViQ2&#xd;&#xa;9/FEq6Jc6ebAjMQkVnwPQFWAxS3mqSvos726n7WkqW0iIcFXZlUhSeM4fIPIBxnvVFU1OGSKSy0a&#xd;&#xa;4glDDe0l1GyuDwdw3ZPGSMY5x9KuQaXZzaxqJkh3HKN94jkgk963KKjnVWgkV22KVILZxgY65ogV&#xd;&#xa;VgjVG3qFADZzkY65qSiiiiiiiiiiiiisnT3a71q+uc74IgIIWP8ACwJ80Adeqp9ccU7SojaX+oWh&#xd;&#xa;OQXW5THRVfKhQPYxk/jWpRRRRRRRRRRRRRRRVayl85Jj9me32zOmGXG/B+8PY9c1ZoooooooqoPt&#xd;&#xa;H9qvmeP7N5C4i/iD7jlunTGB17VPPEJoJIicB1K59Mise30XUba3igh16dYokCIv2eI4AGAORV2w&#xd;&#xa;05rS6nuZbl55p0jR2ZQudu7nA/3qqtokxU241OYWDDYbUopBQ9V3kbuRnnOat3mmpcRQCGRrea2/&#xd;&#xa;1EqjcY+MHg8HIyOc9aqW+jXcepxX02rzTuiGMgwxqGQkEjgeoHPWreoaf9raKaKdre5hyI5lUMVD&#xd;&#xa;Y3DB4OcDtTJ9MllihYXsiXsS7ftQRcsD1yv3T+XHbrTE0h2Qm7vZbmfzI281lC4VHDhdowOoPOM8&#xd;&#xa;1cvbSK+tXt5hlGwevQggg/gQDWTd+Hp9QtZLfUdWnuI2Hyjy0Ta3975QM8Z4PHNaGoaf9raKaKdr&#xd;&#xa;e5hyI5lUMVDY3DB4OcDtUEmkz4SSDUZIbrbtlnWND5o91I2g+4GaJNFWfT5Le4uHlnldHkuCoDNt&#xd;&#xa;YEDA4AwoGB9epNatFZ+i2z2+i21tcSJOyx7XdW3K/wCJ61nan4M0jUBM6weRcSkHzUZuOey5x7dK&#xd;&#xa;k8M6AdAW7iEwlildWjJ+9jbzn8c1tu6xqWdgqjqScAVBbJdCad7mVCjNiKNBwqjPOcZyRjI6DHFW&#xd;&#xa;aKKKKralKbfTbqZYhK0cLuIyMhyATj8aktnMltE5XYWQHb6cdKj1C1+22Utv5hj3jAcAErznPNUP&#xd;&#xa;7M1X/oYJ/wDwGi/+Jq1b6bFCl8jMzpeStI4ztxuUKQCOe3Wqv9jTykR3mpS3NmCD9naNFBwcr8wG&#xd;&#xa;7ggHrzjmrN/pzXMyXFtcvaXSqU85VDEoeSuGyOoBzjPFXIVdIUSSQyuqgM5ABY9zgcVBqgjOl3Ym&#xd;&#xa;laGLyX3yKMlBtOSMelPvohcWNxC0piWSJkMgOCgIxn8KfAgjgjQNvCqBu9eOtSUVlTaVdCVjY6nJ&#xd;&#xa;Zwsc+UkKMAe5G4HH06VbSwt1sWtGTdG4w/JBYnqc9c+/aqaaRcl1S51Sae1Bz5HlquccqNygNwcd&#xd;&#xa;+cc1LeadcS3LT2eoSWbOAJNsavvx0PzA4/CtGiornZ9ml8xS6bDuUdSMcii22fZovLUomwbVPUDH&#xd;&#xa;AqWiiiiiiiiiiiimTBzC4iYLIVO0noD2rmWk1vQNJmne306RUzLMyyybpHJ+ZsbcDJ5xwKvwWmrS&#xd;&#xa;6xb3d6LOOOGN1Igkcl84xnKjpg/ma2qKKKKKKKr3t5BYwGe4ZljBAyqM5/IAmke+t47+OyZn8+Rd&#xd;&#xa;ygRsRjn+LGB0PU1CNYsjbT3AeTy4GCyHyXyDnHAxk/hTzqdoJLaPe+65UNF+6fkH1OOPxxTRq1mR&#xd;&#xa;dEPJi0OJf3L8ckccfN0PTNB1azAtSXkxdnEX7l+eQOePl6jripXvreO/jsmZ/PkXcoEbEY5/ixgd&#xd;&#xa;D1NQjWLI209wHk8uBgsh8l8g5xwMZP4VDZah5bJHeTmSS7kaS22wtjyicoD8owQPWrQ1G2JugGfN&#xd;&#xa;oMy/u244J44+boemaQ6naCO2k3vtuWCxfun5J9Rjj8cU8X1ubme3DP5kChpB5bYAxng4wfwqL+1r&#xd;&#xa;P7HDdb5PJmfYh8l8k89RjI6HkinSanaRX62Tu4nfGAInI5/2sY/WlGo2xN0Az5tBmX923HBPHHzd&#xd;&#xa;D0zSHU7QR20m99tywWL90/JPqMcfjirlZ6ta/wDCQyKFk+1/ZEJb+HZvbA+uc1oUUUUUUUUUUUUU&#xd;&#xa;UUVn6A1q2iWhsVkW2Mf7tZPvAe9aFFV5omnkMU0UMlo0ZDq/JLZGBjGCMZqxRRRRRUV0JjazC1ZF&#xd;&#xa;nKN5Zf7obHGfbNOiDiJBKQZNo3EdM96fRRRRRVTVpRb6TezNEkqxwO5jcZVwFJwfY0asYRpN6bpX&#xd;&#xa;aAQP5gT7xXac498VLaFDaQmIER+Wu0HrjHFTUUUUUUUVHcF1t5TEMyBCVHqccUW5dreIyjEhQFh6&#xd;&#xa;HHNSUUUUUUUUUUUUUVj+Lf8AkWNQ/wCuR/nWxRRRRRRRRVO32f2pd4unkfZHugJ4i+9gge/9KuUU&#xd;&#xa;UUUUUUUUUUUVX1Db/Z9zvna3XymzMpwYxg/MPp1qS3x9ni2uZBsGHPVuOtV3tJjqqXaTRLEI9jp5&#xd;&#xa;ALv1I+fOQMkcY9fWmC21H7NOh1CMzOwMUn2fiMZ6Ebvm478U8wX3mWx+2psRQJl8j/WnuQc/L9Oa&#xd;&#xa;f5V19v8AN+1J9l248jyuc+u7P6YqBbXUxZNGdSiNyXyJvs3AX027vrzmpzFdfaYHF0ghRSJY/K5k&#xd;&#xa;OOoOfl57c0wQX3l3I+2pvdiYW8j/AFQ7AjPzfXilMN5m1xdoBGP348n/AFxwOnPy9/XrQIbzN1m7&#xd;&#xa;QiQfuB5P+pOD15+bt6dKQwX3l2w+2pvRgZm8j/WjuAM/L9eaPIvv7R837an2T/n38j5umPv59een&#xd;&#xa;tQIL7y7kfbU3uxMLeR/qh2BGfm+vFEkF8fsmy9RfLx5+YM+d0zjn5e/r19qBBfeZcn7amx1IhXyP&#xd;&#xa;9UexJz8304phttR+zQINQjEyMTLJ9n4kGegG75eO/NSeTefbJpPtafZ2TEcXk8o3HJbPPfjHeomt&#xd;&#xa;dTNksY1KIXIfJm+zcFfTbu+nOa0KKrz3cUFzbW7k+Zcsyx4HGQpY/oKLS0is1lWEECWVpWyc/Mxy&#xd;&#xa;asUUUUUVX1C2+26fc2u/Z58TR7sZ27gRnH41Wjs9QisbWBNQjEkXEkht8iRewxu44780y6uvsV7K&#xd;&#xa;11qttFFJH+5t2QBw3HIJbLc54x3rN/tLV57D7PZR3D3+7Pm3Fk0Ee305yM/jS3F34huNQSCJYLIk&#xd;&#xa;KSgHn4XJy7Nxt46Dvg88VrJbaiLCSJ9Qja6ZspOLfAUccbd3PfnPf2qYxXX2mBxdIIUUiWPyuZDj&#xd;&#xa;qDn5ee3NKsdyL1pDcKbYpgQ+XyG9d2frxioPs2o/YPK/tCP7Vuz5/wBn4x6bd365q5MrtC6xOI5C&#xd;&#xa;pCuV3BT2OO/0qq0V6umFGvoxdAZNyYflAzn7ufTjr71l2mo6hda5b2qyRrai3Mpm2Z+07WCkgfwg&#xd;&#xa;kkg5ORg960xb6hi6zfxkyH9wfs/+pGT1+b5u3p0oNvqGLXF/GDGf35+z/wCuGR0+b5e/r1pwgvvM&#xd;&#xa;uT9tTY6kQr5H+qPYk5+b6cVma/Pqul+Hjcw3cctzCw3n7PxLuYAADPGMj1zirmjy3d3DDdTXUbK0&#xd;&#xa;CrLAseGjmwN2Tngg5G3HFSfZtR+weV/aEf2rdnz/ALPxj027v1zTzBfeXbD7am9GBmbyP9aO4Az8&#xd;&#xa;v15pWgummuc3YEMibYkWPDRnHXdnnnntViFDHCiM5dlUAserH1p9FFFFFFFFFFFFFY/i3/kWNQ/6&#xd;&#xa;5H+dbFFFFFFFFFULa5jk1i+t1t0SSJIi0oxmQNuwDx2we/ep765+yWrShN7ZVETONzMQqjPbJI5r&#xd;&#xa;P+y65/rP7Ug/veV9lH/fO7d+GcVfkvIrW1jm1CWG0LABhJKAoYjO0McZ7/lSpfWclq10l1A1uvWU&#xd;&#xa;SAoPx6U06lYiaSE3tsJYgWdDKu5AOSSM8YqppGvWWqRR7Z7dLh2cCATKz4UkZx15Az06Vcg1Cyup&#xd;&#xa;mht7y3mlUEskcqswA4OQDT7m7trOMSXVxFAhO0NK4UE+mT9Kwf7WLT+ILmzu0njtrRJItr70Vgsh&#xd;&#xa;OMHHUDNaml3cspntbsgXNu+3ONplXAxIF7AnI7jg81QOsXMviK2t4dv2F5Gi3gbhKRGWJVvZhtI5&#xd;&#xa;5B+lakuqafBcG3mvraOYEAxvMobJ6cZz3p1xqFlalhcXlvCVIDeZKq4JzjOT3wfyNTQyxzxLLDIk&#xd;&#xa;kbDKujAgj2IqO+khhsbiW6UNAkTNIpXcCoHIx34p8DI8EbRDEbKCoxjAxxUlFFFFFFFFFFFFFFFF&#xd;&#xa;FNeRI1DSOqAkLljjknAH4kgVBbwzx3d1JLNvikZTEn/PMBQCPxOTVmiiiiiiiisfWM2V5b6pFHJL&#xd;&#xa;IB9ndFQsPLJ3E8dMFRyeKu3F/FHHCYSs8k4zCiMP3g9QfTkc+4pml2LWUUzSuHnuJTNKVGF3EAfK&#xd;&#xa;OoHA65q9RRRRWRGBrjLMx/4l6MQsfQyurEEt7AjgdcrnpxSaV/yHtc/66xf+ilrYoorLvIjca/p4&#xd;&#xa;Bx9lV5mz/EGUpj9c0ulRi2vNQtkJKCbzsnrukyx/DPStOiiiiiiiiiiiiiiiiisfxb/yLGof9cj/&#xd;&#xa;ADrYooooooooqvE10bycSrGLYKnksPvE87s/pii/eBLKX7Uu63YbJOONp4JPoADknsMmsqWyfTrc&#xd;&#xa;3tvq1w6RgFIrh1MJB4C8AHocDnrjrRpEpudZu57mJ4pmijMEcow6xlELgD0D8H3rN8ZfL5/2b+O1&#xd;&#xa;k+17Oem3y93p1fHrzXVW9vFawJBAgjiQYVR0ArmIjcr4Fc2mfO85xwCePtB3Zx2xnPtmrNzb6s9t&#xd;&#xa;A017pcEEToySxo6lewwSxHIJX/gVaMAQ6/dGXHnCJRDnrs43Y9t2M+9ZF7Ikk/ivY6ttsUU4OcHZ&#xd;&#xa;JxWjrcE6ulzZK4uJV+zF0UkqGyFY+yk7qq30Sabd6GqqNsLTswXufKYk/icn8aikl1RtElu4ZNMt&#xd;&#xa;7KeJpwrxvuVXy3J3Yz8350zwlEhvWmKgyJp1mqt3AKEkf+Oj8q2LEIusagLfHklY2fbyPOJfdn/a&#xd;&#xa;2hMj0x61dujMLWY2qo04RvLD/dLY4z7Zp0RcxIZQBJtG4DpnvS7137Nw3Yztzzj1rLfxJpaOyNLN&#xd;&#xa;uU4P+iyn/wBlqex1iy1CYxWryM4XcQ0LoMcDqwA70+/1O003y/tTuvmZ27InfpjP3QcdarQ+ItMn&#xd;&#xa;mSKOWYvIwVQbaUDJ4HJXAq/d3UVnbPcTlhGmMlULHk46AE96zf8AhJ9K/wCe0/8A4Cy//E1qwypP&#xd;&#xa;CksZJSRQykgg4PI4PIrK/wCEn0r/AJ7T/wDgLL/8TVqw1az1F3S1eRmQZO6F0/8AQgKL/VrPTnRL&#xd;&#xa;p5FZxkbYXf8A9BBqK31/TrqdIIZJjI5woNvIo/MrgVbvbyCxgM9wzLGCBlUZz+QBNZ//AAk+lf8A&#xd;&#xa;Paf/AMBZf/ia1fNTyfNydm3dnBzjr061lf8ACT6V/wA9p/8AwFl/+JrQs7yC+gE9uzNGSRlkZD+R&#xd;&#xa;ANV73W7CxnMFxJKsgAOFgkcfmFIqhFrNtqmrixCu9qUSSNmhkQmVWLYyQOBtU/49K1L/AFG205Ee&#xd;&#xa;6Z1VzgbY2f8A9BBql/wk+lf89p//AAFl/wDia07ieO1geeYkRoMsQpY/kOTWZ/wk+lf89p//AAFl&#xd;&#xa;/wDia0rS6ivLZLiAsY3zgshU8HHQgHtVO713T7O5e3nklEiYyFt5GHIz1Ckd6fY6xZahMYrV5GcL&#xd;&#xa;uIaF0GOB1YAd6v1FcXEVrC00z7UUZJxn8h1J9hSfNP3U28kfTBDZP8uPxpsFlBb2X2SNW8jBXazs&#xd;&#xa;xwc55Jz3qnpGkf2fJNI8xlJwkKnGIYlyFUcZzggE5OcCtSiiiiq2oW73VlLDFKY2dSM9jx0PfB74&#xd;&#xa;wfQisu01Q6fm01GARCJhGJoI2MbsQGwByRgMMk8ZzzVnRUSU3l+Gy91cOGwflxGxjUj6qoJ961KK&#xd;&#xa;KwtKvLd9S1O7NxF5M0iiFmcA4VQrDB5HzA/XrS3V1BDr9ncxzxyrcKbUxxuCdxO4MfYBSPxrcooo&#xd;&#xa;oooooooooooooorH8W/8ixqH/XI/zrYooooooooqtDbxpf3M6zO0kqoGjLAhAM4IHbOT+VWGUMpV&#xd;&#xa;gCpGCCOCKzodB06C5FwkL7wSRumdl/75Jx+lT32nWuoIq3UZYKcgq7IfzUg49qjXRrBbCWyEBMEo&#xd;&#xa;w4aRiWH+8Tn9av1RXSLJb77YsTCbnpI23kY+7nb09veo4dB06C5FwkL7wSRumdl/75Jx+lT32nWu&#xd;&#xa;oIq3UZYKcgq7IfzUg49qih0XT4IbiKODCXMYily7EuoBGCSc/wAR561oVBNaQTzQzSx7ngJMZyeM&#xd;&#xa;gg8d+CetUj4e0xpmlMDlmJJHnSbef9ndjHtiqUfhu2k1W5ae3cWqQwxW+ydl4UMCPlbJx8vWtu1t&#xd;&#xa;YbOBYbdNiD3JJ+pPJ/GmalEbjTbqFZRE0kLoJCcBCQRn8KktkMdtEhbeVQDd68dazE/5HGb/ALB8&#xd;&#xa;f/ox62KKazqmNzBcnAycZPpTqKKKKKKKKKKbvXfs3DdjO3POPWhXV87WDYODg5wfSnUUUUUUUVFJ&#xd;&#xa;cQxSBJJFRipcBjjgEAn/AMeH51DPcymS3W0jEqytlpSfkVQRnkdyDx247VKbWE53p5mZBKBIS+1h&#xd;&#xa;0IznGMdqmoooooooprOqY3MFycDJxk+lV7GK5FkI9QdJpiX3FR8pUscDoP4cDpU0EENtCsNvEkUS&#xd;&#xa;/dSNQqjv0FSUUVnT6Lo5SR5tNs8EEu3kLn3OcZpLDStIjit57KxtQAitFKsQ3Yxwd3Xp361pUUUU&#xd;&#xa;UUUUUUUUUUUUUVj+Lf8AkWNQ/wCuR/nWxRRRRRRRRWfbzWX9t3sUaFbzy4jKxPDj5tuBntznjvVz&#xd;&#xa;z4cuPNTMYy43D5R7+lJ9pg2K/nx7XOFbeME+1OEsZlMQkQyKMlAwyB9Kb9pg8rzfPj8vON+8Yz9a&#xd;&#xa;cZIxIIy6+YRkLnnHrim/aIPLaTzo9inDNuGAfQmnebHvVPMTc4yq7hkj2oEkZkMYdfMAyVzzj1xT&#xd;&#xa;ftMHleb58fl5xv3jGfrTjJGJBGXXzCMhc849cU37TBsZ/Pj2ocM28YB96Xz4coPNTMgyg3D5h7et&#xd;&#xa;J9og+f8AfR/u/v8AzD5fr6UfaIPk/fR/vPufMPm+nrVbUbizNldRTkTL5T+ZCjfOy7TkAZznGas2&#xd;&#xa;2z7NF5alE2Dap6gY4FQLY41h9Q8z71usPl7emGLZz+NXK57UGuro311p8szSWnyQJG5CO4+8GXo2&#xd;&#xa;D607xDe2z6XYXqzKbb7bBJ5nbaHGTV+z1UXU4hksru0ZgSn2hVG/HXGCabd6wlvcvBDZ3V28ePM+&#xd;&#xa;zqp2EjIByR2Oapanr8kC6c9raXEi3E+yQBFJGAwaPr98EfTg81PN4gig+zLNZXkc1zv8uFkXexXH&#xd;&#xa;H3u+eKsLqyCya5ntbm3Ify0ilVQ8jHoFAJHJOBz1ptprCXFykE1ndWjyZ8v7QqjeQMkDBPYZqN9e&#xd;&#xa;jDt5NjeTwKcfaIkUx8deSwPByDx2NVrjX5I9ahht7S4urWS085TAiktkrhhkjjB/UUWzXWvyTSfa&#xd;&#xa;JrSxRvL8lf3c3mKSGyyngZ+ufartpp91ZXSCK9kmsyCXS4YySbuxDE9OnH+NRvr0YdvJsbyeBTj7&#xd;&#xa;REimPjryWB4OQeOxpm9ZPF1u6HKtp7kH1HmJS+HP9Rf/APYQuP8A0M0+HXreaZFEFwsErBY7llHl&#xd;&#xa;SE8AA5zyfapr7VEs5hAlvcXUxXeY4FBZV5AJyRxkGsu68Sut/YwwWV0S7uJ4Ni+YvyEgfexno3Xp&#xd;&#xa;+VXrTUI7rVI0aC9t52t3YRTYC7QyjJAJ5yRg+malvdWS2nMEVrc3cqgF1t1UmMHpnJHXnH0NRS6/&#xd;&#xa;ZwWAu5hJGgmWGRWA3RMcfe57ZBOM0ia9GXXzrG8ggY4+0Sooj56chieTgDjuKvXd0loiFkeRpHCI&#xd;&#xa;iAFmPXjPoAT9AaoXNuZvEcKXJjmtpLOYCFowQPnizn1zx27VqQxRwRLFDGkcajCoigAD2Ap9FFFF&#xd;&#xa;FFFFZ901re6gunyrJ5kAjuwRwvDHH6rWhRRRRUc/+ok/d+Z8p+T+9x0pliSbG3JtxbExL+5HSPj7&#xd;&#xa;v4dKnooooooooooooooooorH8W/8ixqH/XI/zrYooooooooqH7JbfavtX2eL7Rjb5uwb8emetN+w&#xd;&#xa;2e+Z/ssG6cbZW8sZkHo3r+NNOm2JhihNlbeVEd0aeUu1D1yBjipFtLZLp7pbeJbhxtaUIA7Djgnq&#xd;&#xa;eg/Ko/7Nsfsv2X7FbfZ87vK8pdmfXGMVKbaA3IuTBGZ1XaJSg3BfTPXFR/2fZfZ5Lf7Hb+TI254/&#xd;&#xa;KXazcckYwTwPyp5tLYzRTG3i82IbY32Dcg6YB7UotoBcm5EEYnZdplCDcV9M9cVF/Ztj9l+y/Yrb&#xd;&#xa;7Pnd5XlLsz64xipTbQG5FyYIzOq7RKUG4L6Z64rmdFW3nvJ2mt4Fs9TZilq0YK+ZGSp9jnYW6d/x&#xd;&#xa;ro/sNnvhf7LBugG2JvLGYx6L6fhSDT7ICcCztwLg5m/dL+8P+1xz1PX1oOn2REANnbkW5zD+6X92&#xd;&#xa;f9njjoOnpQun2S3f2tbO3FzknzhEu/JGPvYz0qzWet3KfEMlkSPJW0SUDHO4uwPP0AqTVbpbLTpp&#xd;&#xa;mYrgBVIHIZiFX9SKytP0nWra0RRqsETv88i/ZA3znliTu5Oe9Z87DT7KLT7mdN1lqFu7Pt2IsbPl&#xd;&#xa;e/A4PetXUbm31ZrODT7mG5eO6imfypAwVVYEk46e3rSX8tnBeXDJqCaZeErl58BJeBztJG/A4yDw&#xd;&#xa;fpUV7cPPY6RdTY2RX2ZJsYQookUS+gVuCO3zDk9alnuYLvxFpEttPHNH5VyN8bhhn5O4qbWbloby&#xd;&#xa;zjluDa2UiyGafdsCsNu0bjwM5P1rB1ZYb6+tLXT7ya9aWO4QSGTfEGMLgDcOM9Mj0IrftdYsILOK&#xd;&#xa;G4uooZ40CNBK4WTIGPunnnt6gj1qvNcxQ+ILW/uW+zWz2LKJJ/3YDF1IUk9GwDx14NN0+9g0y6uo&#xd;&#xa;J222s0huor1uIW8wltu7pxxjnnNS6hfpqltcafpw+1C4tpV+0RndEjFSApYZGeRxnuKltdYsILOK&#xd;&#xa;G4uooZ40CNBK4WTIGPunnnt6gj1rM0K2ltNZtIZ12v8AYp3x6Bpww/QilitJb/w7rVrAAZZby4Vc&#xd;&#xa;nAz5lPlk0qe0kin1W63SIVa0ecCVsjGzZ1yemOvNTaXLb6NJdxXsi2sc83nQvM2xSpVVAyf4vlOR&#xd;&#xa;1pt9f28+qaZdo/8AodtLJ5l0f9TzGQDv6YydvXrx1qSK5gu/FkMttPHNH9gkG+Nwwz5idxRp1zBp&#xd;&#xa;L3kGozx2rSXUk0bSuEV1ZiRtJ6kcZA6ZFUNYnimuF1BXAtPtNnGJmOFbZI7MwPQrhxz06+lW/FjX&#xd;&#xa;MmnZiKC0Dwsz53GQmVcAemODnnPStizsLWx8z7JAkXmtufb/ABH1qRrdGuo7k58yNGjXnjDFSf8A&#xd;&#xa;0EVLRRRRRRRRRVaxi8uEyNbpbzTN5kqK24buB178AVZrPeya+uJ01GGKW2SVJLYHqCF5J98k1YWy&#xd;&#xa;tlvWvRCouWTyzJ3K+n6CoP7F077B9h+yR/Zd27yscZ9ak/s2z+2Q3f2dPtEKeXHJ3VeRgfmfzqMa&#xd;&#xa;Lpwtp7cWkfk3DBpUxw5znJ/Gn3Gl2N1ZxWk9sklvFjZGei4GB+lP+wWv2/7d5Cfatu3ze+PSoF0P&#xd;&#xa;TFsmshZRC2Z/MMeOC3r+gqX+zbP7ZDd/Z0+0Qp5ccndV5GB+Z/OoxounC2ntxaR+TcMGlTHDnOcn&#xd;&#xa;8akOm2ZNqTbpm0GIP+mYwBx+QoGm2YN0Rbpm7GJ/+mgwRz+ZqObRdOuLWG1mtI3gh/1aEcL9KmNh&#xd;&#xa;am5guDAnnW6lYn7oMYwPwpg0uxEdzH9mTZdMWmH98nqTVPWrNINKE9laLJdWMf8AoihCxQ8DAH0A&#xd;&#xa;/Ktiiiiiiiisfxb/AMixqH/XI/zrYoooooooooooooooooorN8QyKNHuID9+6U20f++4Krn2yara&#xd;&#xa;rBLb6VaXUSFrux2bMDIGcI5I9Npb6da2Y5EljWSN1dHAZWU5BB6EGnUUUVlJFIPFcs3lv5RsUUPt&#xd;&#xa;O3dvY4z68itN0V12uoZfQjIp1RvBDJu8yJG3YzuUHOOlJFbwQkmKGOMnqVUDNEtvBMQZYY5COhZQ&#xd;&#xa;cU4xxmPyyimPGNuOMemKRIIY9vlxIu3ONqgYz1pZI45V2yorr6MMimpbwR48uGNMHI2qBg9M0j2t&#xd;&#xa;u8nmPBEz/wB4oCfzp8sUcy7ZY0kUHOGUEZpGhieMRtEjRjopUED8KWKKOFdsUaRqTnCqAM0x7W3e&#xd;&#xa;TzHgiZ/7xQE/nUmxd+/aN2Mbsc49KFRUztULk5OBjJ9ajNrbmTzDBEZM53bBnPrmnSwxTACWJJAO&#xd;&#xa;gZQcUeRD5Pk+Unlf3No2+vSiOCGIgxxImBgbVA4qGUwXQUrFFdBZDG3Kt5Z/i6+mOR1psOnxxtNv&#xd;&#xa;d5opCCsMgUpHjP3Rjjr71aaNGTYyKV4+UjjinVSllca1awhiI3t5mZexIaIA/wDjx/OrtFFFFFFF&#xd;&#xa;FUrswXcgsjPIH4Z1i/u+jHB2g89cE846Vdoqna7/ALffbrpJV3ptiByYfkHB9M9fxq5Wdd6lMkpj&#xd;&#xa;sbGS+ZDiQo6oEPYZbAJ68Dp36ipbC8muNy3NlLaSjnY5DAr67lyvrxnP51coqGS6hjuobZ3xNMGa&#xd;&#xa;NcHkLjPP4ipqKoa1eyafpj3MKozq8agOCRhnVT+hpb3UGhfybS2a8uBy8UbqpRfUk8D2HU846HCW&#xd;&#xa;V9czymO706a0YjKFmEgb15XIXt1xnPHQ1fqGW6hhnggkfbJOSsa4PzEDJ+nAqaqerbzpdx5d0lo+&#xd;&#xa;zidzgJ7k1cooooooorH8W/8AIsah/wBcj/OtiiiiiiiiiiiiiiiiiiisrWkuWks3gsmvEjkLvEJF&#xd;&#xa;XBH3T8xHQ1UOs314bqzXQ7gvGPLlAuIgV3Lkck46GtHQ454dItobiEwvEvlhCwYhFJC5I4J2gZx3&#xd;&#xa;9Kv0UUVFLcwQttlnjjYjOGcA4pI7u2lcJHcROx6Krgk0+WWOFd0siRqTjLMAM1F9us/+fqD/AL+C&#xd;&#xa;pkdZFDIwZT0IOQahN7aAkG6hBHbzBUkU0UwJilSQDqVYHFNkureJtss8SN6M4BojureVtsU8Tt6K&#xd;&#xa;4Jp0s0UIBllSMHoWYDNR/brP/n6g/wC/gqdWDKGUgqRkEHgioPt1n/z9Qf8AfwVLFLHMu6KRJFBx&#xd;&#xa;lWBGaZJd20TlJLiJGHVWcAiliuYJm2xTxyMBnCuCcUss8MOPOlSPPTewGaj+3Wf/AD9Qf9/BUxdQ&#xd;&#xa;hcsAoGd2eMetU7vV7G0tnme5iIXAwrgkknAHHuRUls73JiuRLtjMWGgBVgHOD94dxyODimwy2FnG&#xd;&#xa;LeOaGNY/l2mQZGPXJyT9eak+3Wf/AD9Qf9/BTpLq3iIEk8SEjIDOBketEd3bSuEjuInY9FVwSahl&#xd;&#xa;gkbWLacL+6S3lRmz0LNGQP8Ax0/lVyiiiiiiiiq1mZn857i3SF/NZVKkEugPyk/Udqs0Vn2Mlu2q&#xd;&#xa;amsMJSZJIxM5bIc7Bg47YGBWhWd9nuoZ5nsJYWjlbc8cucI3cgjnnuD0xxUUuryW9rfLPEq3lpA0&#xd;&#xa;4QHKyIAcMD2BIIweeKih0S2vIUvLp5pLuVQ5lErKAe3ygheBgdOcc1naTE2uX+pJqE0kkVpN5GxW&#xd;&#xa;Kb2XI8wlcEEjPA456cCptT0eyk8Q6VE6SFGglUgTODhAgXnOe/4980anvF9Fo1vp811axW6zFI7j&#xd;&#xa;Y3LMBlmYHjHrTUu9R0rTrn/iXvbWyFBB5syyMpd1UjIJJHJbn1x0xSa/odlaaU1yiymdZYjvadyC&#xd;&#xa;TIoJ2k47ntWzNaul9Jc2Dwi4dQs6SEkMB908cgj5vrk56CiC+lS8WzvkRJpFLRNGSVkA+9juMZHX&#xd;&#xa;rniuct5L/V4E1J9KupJ3G6CaO6RFiH8OE3ANg5PzA56HirF7aPqN5oP9rW7RXDvMkiLMRwEYjlTj&#xd;&#xa;JwDx9K6W0tYrO2S3gDCNM4DOWPJz1JJ71Dq32P8Asu4/tH/j02fvevT8Ofyq5RRRRRRRWP4t/wCR&#xd;&#xa;Y1D/AK5H+dbFFFFFFFFFFFFFFFFFFFFY+lf8h7XP+usX/opa2KKKKKq3Om2N5IJLqytp3A2hpYlY&#xd;&#xa;gemSPemwaTp1tMs1vp9rFKv3XjhVWHbqBU1zaW15GI7q3inQHcFlQMAfXB+tVf7C0j/oFWP/AIDp&#xd;&#xa;/hV2GKOCJYoY0jjUYVEUAAewFULjSNIjjlnk0uzbaC7H7OhJ7ntWR4XjSy1Bo4EUQ6lE9+igY8tS&#xd;&#xa;4CLgcfdYZ9COK3rjS9Pu5fNubG2mkxjfJCrHH1Iot9L0+0l822sbaGTGN8cKqcfUCpLqytbxVW7t&#xd;&#xa;oZ1U5AljDAH8arf2FpH/AECrH/wHT/Cr0caRRrHGioiAKqqMAAdABVH+wtI/6BVj/wCA6f4VatrS&#xd;&#xa;2s4zHa28UCE7isSBQT64H0qGfSdOuZmmuNPtZZW+88kKsx7dSKdbabY2chktbK2gcjaWiiVSR6ZA&#xd;&#xa;9qddWNne7ftdrBcbM7fNjD7c9cZ+gqv/AGFpH/QKsf8AwHT/AAp0pe4ghWzjtZbVzslWXIHl9CFA&#xd;&#xa;BB78Hiqln4W0a08zbYwy+Y24+civt9hkcCtS3toLSLyraCOGPOdkaBRn6Cq0mjaXLI0kmm2bu5LM&#xd;&#xa;zQKSSepJxVTUPDem3Fo622n2cU6/NE3kqo3jpuwOVz1HpWfbeHLC/wAXMnnG8g/dMt0RKsZ642HI&#xd;&#xa;xhsgdsg0+Sym0Z/tUdjowiiIxceX5cpzxgBVwDzgc810cMhlhSQo8ZdQ2xxhlz2PvT6KKKKKKKp3&#xd;&#xa;+y6STT0unt7iWIsrRnDqoIG4fiRVyiiqdrv+33261SJd6bZQMGb5ByfXHT8KuVQlsJBO8tpdNbmX&#xd;&#xa;l12hlJ9QD0Pqe/HpTrfToo1lM/8ApMs4KyPKoO5f7uOy9fl6cn1qJdOuYk8qDUJEg5AVlDMAewY8&#xd;&#xa;/T049Kl0/TYdPeZoM/vdpbPUkDBYnuT1JPWi9sPtM8FxHKYbiAMEfAYANjPB+gpJbB3Mcy3Gy7Rd&#xd;&#xa;pnEY+dfQjuOfwpF00yLIL64e68xQu0jCAA5BC9N2e/Xp6VWu9FmvoFgudRlaJXV1CqASVII3H+Lp&#xd;&#xa;3789quXNiXn+0W0v2acja7qgO8dsjvjse2T60ltYeXObi4lNxcYwrsAAg77R/DnvjrgelRrpstvl&#xd;&#xa;bG7NvCTkReWGVT6LnoPYe/rRJpQaO2K3Mv2i2Zmjmc7zlsg5z14JA9Pwq7AkkcKrNL5rjq+3bn8K&#xd;&#xa;r6tvGl3Hl2qXb7OIHGQ/sRVyiiiiiiisfxb/AMixqH/XI/zrYooooooooooooooooooorH0r/kPa&#xd;&#xa;5/11i/8ARS1sUUUUUUUUUVk+I5HOnC2gdhczyIsaKcFwGBcf98hs+2aTWoBHBp8kSKkFncpIyqMB&#xd;&#xa;UCsuAP8AgQ4rXooooooooqveTSwQ7oLczyk4VAdoz7nsPek+zSNf/aHuHMariOJcqAT1Lc/N2xxx&#xd;&#xa;z61ZoooorM1C3e3uv7Vt8NIkQjljY4Dxgk8HsRknoc4x71WubltUuVhtYFnitXSSVZG2iQsuVUjH&#xd;&#xa;YOHz6oB7jUgu4p55oUJEsJAdGGCAc4P0ODirFFFFFFFNd1jRnc4VRkn0FQWslveBbyKMElSqSlcF&#xd;&#xa;kPPB/ung1Zooqtb20kV3dTPcPIk7KUjOcRAKAQOe5Ge3WrNFFFFFFFFFFFFFUdZhurjSbmKxcpcu&#xd;&#xa;mI2DbSD9e1XqKKKKKKKx/Fv/ACLGof8AXI/zqx/YWkf9Aqx/8B0/wo/sLSP+gVY/+A6f4Uf2FpH/&#xd;&#xa;AECrH/wHT/CqNro2ltql+jabZlV8vapgXAyvOOKvf2FpH/QKsf8AwHT/AAo/sLSP+gVY/wDgOn+F&#xd;&#xa;ZaaRph8Vyw/2daeULFGCeQu3dvYZxjrwK1P7C0j/AKBVj/4Dp/hR/YWkf9Aqx/8AAdP8KP7C0j/o&#xd;&#xa;FWP/AIDp/hWX4Y0jTJ/DtjLNp1pJI0QLO8Ckk+5IrU/sLSP+gVY/+A6f4Uf2FpH/AECrH/wHT/Cj&#xd;&#xa;+wtI/wCgVY/+A6f4Uf2FpH/QKsf/AAHT/Cj+wtI/6BVj/wCA6f4VVuNNsbPUdKktbK2gc3LKWiiV&#xd;&#xa;SR5MnGQPatqiisfSv+Q9rn/XWL/0UtbFFFFFFFFFFZWpQXL6nZ3EVv5yWwZlAkCHcQV5z1GD+dRT&#xd;&#xa;3V9exXVqdIdSo27nlAUkjIIPfH860tPSePT7ZLpt1wsSiVs5y2Bk/nViiiiiimu2xGbBO0ZwBkmq&#xd;&#xa;zm9eeB7doVtiMyrKjeZ+HOB+IqaC3itw4hQIHcyNjuxOSalooooooqK3t4rWERQII4wSQo6ZJyf1&#xd;&#xa;JouIjPA8QlkiLDG+MgMv0yDUNuJ4GS2KySxKv/HxJICzH3AAqxDLHPEssMiSRsMq6MCCPYin0UUU&#xd;&#xa;VVv5Z4rcC18k3DuqxrKcBucsB6naGP4VaooorNFjcwarLdWskXlXLK1wsqktlVCjYRjHA75qQLqm&#xd;&#xa;LrMlnkn/AEbCNwMn7/PPGOmO9BXVMWuJLPIP+k5RuRkfc544z1z2pwGo+Zc5e18sqfs42NkN2388&#xd;&#xa;j6YqORdY+xxCOWxFzk+aWjfYR2wN2R26mqFlq97eayLNXtfLjU+b+6fczIQr7TuwBuPGe1aIXVMX&#xd;&#xa;WZLPJP8Ao2EbgZP3+eeMdMd6cRqPl22HtfMDD7QdjYK99nPB+uaeBe/aZyXt/IKjyRtbcGxzuOcE&#xd;&#xa;Z9MVFt1T7HCPMs/tO/8AenY2wrz90ZyD06n1qZRd/bWLND9k2fKoU+Zu9znGOvaoNurfYMeZZfbN&#xd;&#xa;33vLfy9v0znP41Pci7Lw/ZWhVd483zFJJXvtweD9aQC9+0zkvb+QVHkja24Njncc4Iz6YqLbqn2O&#xd;&#xa;EeZZ/ad/707G2FefujOQenU+tR6jY3Oo+daTSRLp80e1gikSg+xPH6VpUUUUUUUVj+Lf+RY1D/rk&#xd;&#xa;f51sUUVn2f8AyF9R/wC2X/oNaFFY6f8AI4zf9g+P/wBGPWxRRWP4S/5FjT/+uQ/nWxRRRRWfqX/H&#xd;&#xa;7pP/AF9N/wCiZa0KKKx9K/5D2uf9dYv/AEUtbFFFFFFFFFFFU7X7Z9vvvtH/AB7b0+z9OmwbunP3&#xd;&#xa;s9auUUUUUVUku2JhNpD9qR5NsjxyLiMepyefoOakS2RbuS5LO0jqF5bhVHYDp1ycnnnrjAE9FFFF&#xd;&#xa;FFFFFFFV5YplEItGSJUcbkK/KU7jjofT+tPjnjkmliQkvEQHBUgDIyOe/B7VLRRRVC1aK9umuxA4&#xd;&#xa;8rMcUrEgMP4iFPTBBGSM+nBq/RRRRRRRVXUrpbPT5p2fZgbVbGfmJwv6kViPatpFnYam6eTcKQ2o&#xd;&#xa;yZ3fKw3Sccjlwv3R9OK6Wiiiiiiiiiiiiiiiiisfxb/yLGof9cj/ADrYoorPs/8AkL6j/wBsv/Qa&#xd;&#xa;0KKx0/5HGb/sHx/+jHrYoorH8Jf8ixp//XIfzrYrGGr30jyfZtFmmiSV4xIJ41DFWKk4Jz1Bpf7T&#xd;&#xa;1X/oX5//AAJi/wDiqP7T1X/oX5//AAJi/wDiqP7T1X/oX5//AAJi/wDiqr3V1q89xZyDQZgLeYyE&#xd;&#xa;G5i5Bjdcfe/2v0qx/aeq/wDQvz/+BMX/AMVR/aeq/wDQvz/+BMX/AMVR/aeq/wDQvz/+BMX/AMVV&#xd;&#xa;Kzm1e31HULk6FMVunRlAuIsrtQL/AHvarv8Aaeq/9C/P/wCBMX/xVH9p6r/0L8//AIExf/FUf2nq&#xd;&#xa;v/Qvz/8AgTF/8VSNq99CplutFmgt0G6WUzxsEUdWwDk4HOBzWvG6yxrIhyrAMD6g06iiiiiqFkIR&#xd;&#xa;qeomO4eSQunmRkHER2DAH1HP41foooqOWXYjlEaZ0H+rQjcfzIH5moI4rl7tblrmSOFkGbVkT5Tj&#xd;&#xa;uwyc/Q4qxFFHCu2KNI1JzhVAGafRRRRRRRRRRRRRUVxBHcwmKUEoSDgMVPByOR7imJJcC7lSWJRA&#xd;&#xa;BujlVh6DIYHkHOemRgdaljkjlXdE6uvqpyKfUU7Hy2SN1SZ1Ij3HvinQhxCglYNIFG4joT3p9FFF&#xd;&#xa;FFFFYfiSdI5LCO6DmxklP2gKjNnau5PujI+YL0/lTLrX9CvreW1uJJpI3G10+zTDj8FyK1NJlmn0&#xd;&#xa;myluCTNJAjSEjB3FQTx25q3RRRRRRRRRRRRRRRRWP4t/5FjUP+uR/nWxRRWfZ/8AIX1H/tl/6DWh&#xd;&#xa;RWOn/I4zf9g+P/0Y9bFFFY/hL/kWNP8A+uQ/nWxWfon/AB5Sf9fVz/6OetCiiiiiiiiiis/X/wDk&#xd;&#xa;X9S/69Zf/QDVjT/+Qfbf9cl/kKsUUUUUVTtbi2lv76KGHZNC6CZ9oG8lAQc9TgEDmrlFMmlSCF5p&#xd;&#xa;WCRxqWZj0AHJNVRcHULOObTLiIpI3+uI3AKDzgdzkY7Yzntg21jRXZ1RQzY3MBycdM06iiiiiiii&#xd;&#xa;iiiiiiiikZQylWAKkYII4IqmLJrdoEsGhtLZGJkhSAYfOOmCNv5GpLG7a8hMjWtxbENt2TqAx6c8&#xd;&#xa;E8c/pUETWup3nnBZBJp07xgngbigyfcYatCiiiiiiiiis+z/AOQvqP8A2y/9BrQooooorybQl8Q6&#xd;&#xa;9NLFaazcI0Shj5t1IBj8M1t/8It4u/6Dv/k3L/hR/wAIt4u/6Dv/AJNy/wCFH/CLeLv+g7/5Ny/4&#xd;&#xa;Uf8ACLeLv+g7/wCTcv8AhR/wi3i7/oO/+Tcv+FH/AAi3i7/oO/8Ak3L/AIUf8It4u/6Dv/k3L/hR&#xd;&#xa;/wAIt4u/6Dv/AJNy/wCFH/CLeLv+g7/5Ny/4Uf8ACLeLv+g7/wCTcv8AhR/wi3i7/oO/+Tcv+FMm&#xd;&#xa;8I+Kp4mim1pJI2GGR7qUgj3BWn/8It4u/wCg7/5Ny/4VY8A6lfz3d9Y3ty9wIfmDSMWOc4PJ5xx0&#xd;&#xa;rtqz7P8A5C+o/wDbL/0GtCisdP8AkcZv+wfH/wCjHrYoorH8Jf8AIsaf/wBch/Otis/RP+PKT/r6&#xd;&#xa;uf8A0c9ZXiTTjbaVfX8GoaikyqZFC3ThQSegGentV8WMOjxTX7XeoTLBEzsklw0gIAyeCcZ4p9jr&#xd;&#xa;UeoTRi2tLp4JBlbnavldOec568dOtN/t6387HkXH2bdt+17R5OemM5z975enWrl9ex2MIkkV3Z22&#xd;&#xa;JGgBZ25OBnvwazrzVBc6HqjRLPa3MFs7GOTCyJ8rbTwTjocc9ql0yWS3vZ9LuJHleNRNE5YsfKJw&#xd;&#xa;AxPJbIb8Mc1mR3tzea9p12s8i2c80sccIYjISNgd6jgnepI68YrTm1tY5nVLC9miRirTxopjyOG5&#xd;&#xa;LA8EEHjsaZJ4itftJt7eC5u5RGkoWBVO5GGQwyRwOM/7wq/Y3sd9CZI1dGRtjxuAGRuDg478ioNf&#xd;&#xa;/wCRf1L/AK9Zf/QDVjT/APkH23/XJf5CqerTSi/06zSRo47qR1kZDhsKhYYPbkVpbP3ezc3TG7PP&#xd;&#xa;1qj/AGX/ANP99/3+/wDrVbt4fIi2ebJJzndI2TVebT/NlZ/tl2m452pLgD6cUsFh5Myyfa7qTH8M&#xd;&#xa;kmVP4Yqa5t/tEYTzpYsHO6Jtp+lVf7L/AOn++/7/AH/1qvSJ5kbJuZdwI3KcEe4qj/Zf/T/ff9/v&#xd;&#xa;/rVcgi8mFY/MeTH8Uhyx/Gqsmm+ZIz/bbxdxJ2rLgD2HFPt7HyJd/wBquZOMbZJMipLq2+0qo86a&#xd;&#xa;LBzmJ9pNV10zawP269ODnBl4P6Vcmj82Jk3um4Y3IcEfSqX9l/8AT/ff9/v/AK1S3U39m6VPP883&#xd;&#xa;2aFpPnbl9oJwT+FT28vnW8UuNu9A2M5xkZqSiiisnzJX8VtCZpBDHZrIIwflLF3BJ/AD8q0p4vOh&#xd;&#xa;aPzHjz/FGcMPxqn/AGX/ANP99/3+/wDrVdhj8qJU3u+0Y3Ock/WqX9l/9P8Aff8Af7/61WbW2+zK&#xd;&#xa;w86aXJzmV9xFRT2HnTNJ9ruo8/wxyYUfhilt7HyJd/2q5k4xtkkyKbqOmxaiIhNJMgicSL5b7fmB&#xd;&#xa;BB/DFQxaMkEYjivL1UHQCbp+laOz93s3N0xuzz9ao/2X/wBP99/3+/8ArVbt4fIi2ebJJzndI2TV&#xd;&#xa;ebT/ADZWf7ZdpuOdqS4A+nFSWtp9mZj9ouJcjGJX3AUXVp9pZT9ouIsDGIn2g1B/Zf8A0/33/f7/&#xd;&#xa;AOtUmpX32BLdvL8zzriOH72Mbmxn8KuUVn2f/IX1H/tl/wCg1oUUUUUV5z8MP+Qhff8AXJf516HL&#xd;&#xa;LHBGZJpEjQEAs7ADJOBz9TT6ZHLHMGMUiOFYq21gcMOoPuKfRVeC7inubm3QnzLZlWTI4yVDD9DU&#xd;&#xa;s0scETSzSJHGoyzuwAA9yaIZY54llhkSSNhlXRgQR7EU03MAuRbGeMTsu4RFxuK+uOuKlooorgfA&#xd;&#xa;H/Iwav8Aj/6Ga76s+z/5C+o/9sv/AEGtCisdP+Rxm/7B8f8A6Metiiisfwl/yLGn/wDXIfzrYrP0&#xd;&#xa;T/jyk/6+rn/0c9V/Fv8AyLGof9cj/OrGv/8AIv6l/wBesv8A6AadFG0uiJGn3ntgo+pWseFtOWyW&#xd;&#xa;C61a4hlCbHtpLgI+cYxtPPPb1BHrSz2kdvdaddb7m1sI7MW4cHY0fKkb8/dGF5J74qHUhps1leS2&#xd;&#xa;99LfzR2VwA6yiVIgU53EdM44z1wfStjW7B7+KJIgD8/lyZOP3TcPj329Kp6ypt7/AEZYAS0ZmCDG&#xd;&#xa;TkQtiqcl3ayaOz3OrS/bmgzLaxzjcJCvzLs6jByMdsVH4bvrOynb7XdQW+/T7Pb5sgTdhGzjP1Fb&#xd;&#xa;unyLd6nd3kPzW7RRQo/Zypckqe4+ccj39Kdr/wDyL+pf9esv/oBqxp//ACD7b/rkv8hSXFlHcXdr&#xd;&#xa;cuzh7VmZACMEspU5/A1ZqtdX1vaMqSs5kYZEcUbSPj12qCce+McikuL6GLTJr+NlmhjiaUGNgQwA&#xd;&#xa;J4P4VaopskiRIXkdUUdWY4Ap1FFFMkljiKCSRELttTcwG5vQep4NMjuoZLqa2R8zQhWkXB4DZxz+&#xd;&#xa;Bp8kqxBSwc7mCjahbk+uBwPfoKfSMwVSzEBQMkk8AUkciSxrJG6ujgMrKcgg9CDVHX/+Rf1L/r1l&#xd;&#xa;/wDQDVjT/wDkH23/AFyX+QqxRRRVYWUY1Jr/AHP5rQiEjI27QSfz5NWaqXGpWdrL5c0wVgMucEiM&#xd;&#xa;di5HCA9i2M80X98tikDMhfzp0hGD0LHGat0UySWOIoJJEQu21NzAbm9B6ng0+iiimebGJhD5ieaV&#xd;&#xa;3BNw3bemcenIqvcalbW0vlOZHkAyyQwvKVHbcFBxntnrg+lOtb63u2ZImcSKMmOWNo3x67WAOPfG&#xd;&#xa;ODVmmSSxxFBJIiF22puYDc3oPU8Gn1la/FJNDZCKN3K30DNtUnChxkn2FatFZ9n/AMhfUf8Atl/6&#xd;&#xa;DWhRRRRRXnPww/5CF9/1yX+ddb4tJXw9OVXcwkhIXOM/vU4pf7T1X/oX5/8AwJi/+Kqrol21vo2o&#xd;&#xa;3ckO11vJ2aJpFXad/ILE7fxzimRa/NFc26z6hpN2s0qxCOzY7wWOAeWPA78VPFf6pdzyi0n0392S&#xd;&#xa;WtnVjMoz0b5uCfcVXtpNSfXtXSxihjYvCzyT/Mq/ul+XCkHPv04NGt3FzJ4b1e3vfJM8MYy0KkKQ&#xd;&#xa;eRwSTV1btNK1C8juyI7aRTcxPgsWwMy9Ow+XHHfvVfT7Wa3u7GW7Ty7q6klmnQEFVcoBgY7YUdzU&#xd;&#xa;U+vzh5JF1DRoY0J/cSyhpeOoyr4ycccdxU7aze3N1ZRafbxkXdn9oBk/5ZZK4J5GRz0HNX7G5uxc&#xd;&#xa;G01FYhOUMkbwghJFBAbAJJGNy9eueOhrQrgfAH/Iwav+P/oZrvqz7P8A5C+o/wDbL/0GtCisdP8A&#xd;&#xa;kcZv+wfH/wCjHrYoorH8Jf8AIsaf/wBch/Otis/RP+PKT/r6uf8A0c9aFFFFFFFFFUbexaHVr28L&#xd;&#xa;grcJEoXHI27v/iqvVn6//wAi/qX/AF6y/wDoBqxp/wDyD7b/AK5L/IVDeXzW+o6fbBAVundWJPK7&#xd;&#xa;ULf0q9WJBc2lxrs94bmNBbo1qAzAZO4FuDzwVx6GqaPDD4V1XTIpVkaytZFyDnKFW2nI45wePar1&#xd;&#xa;wNSsIp9RmvhLHEjSPaiNQu0DJCtjdnjjNM1W+lxast5LYQzIGEqQiUlj/CRg4GOc1HqsN4/h+Rf7&#xd;&#xa;SEm11InRFJkGehGMDk9vT61LOmp2EUf/ABMjdSSzxovmxIoUc5Hyjvx+VWUW5020uJrzUjc4XKGW&#xd;&#xa;JVCkA9kGTnjjrxxWLDrLJdwMusXFyZJkj+zvYmNDuYKfm2DGM5HPOK0YXvtZhF3a372MO5kVFiRy&#xd;&#xa;drFSTuB7g9O1VNetb9m0hX1Aq4vFQMkanJ2thzkdcA8dOan0OGeDxBqyXF011J5dufMZFU/x8YAx&#xd;&#xa;V3W7qa1itGgfYZLyGJuAcqzAEc+1Vtbu7mG7jj+1yWNsyjbPHCJS75OVIwcADBzx1qWSO5bQ7pHv&#xd;&#xa;lnPlNsuFVckYOcgDb7cfzqHwva3cWl2Us2oPNC9rHsgMaKEyoI5AycDjmtqTZ5beZt2YO7d0x3zS&#xd;&#xa;rjaNuNuOMdMUtFFFUVvmOtvYbBtW2WbdnnJZhj9KuSOsUbSOcKoLE+gFc1HHa6tb6lNPdxQrqCrG&#xd;&#xa;mHX/AFak7GxngkNnB6Uuo3st/o2nzbY0uRfwqyBtyq4ccZHUdOlXGe90l4Xu7976OeZINrRIhQsc&#xd;&#xa;AjaBUeoXN2dVa2bUH02PjyWWFXWUbckliCFwcjBIzVfXbe8kGi41EhjdKodI1IY7XxJ0647dOanu&#xd;&#xa;v7Ugv9PsE1NmadJmkmaFM/LtxgAY4yfzqe6lm0vTWF1qbSSyPhZmgBZQQBwiDnHXkd+azLTXTDqE&#xd;&#xa;MP8AaM+oLKHLCW18nYFQtkHaM5xitNbbVLsJdJqrQLIA4gWFGUDHTJGee/1qld2t7P4rgEeoNbSG&#xd;&#xa;wYkxxqwGHXIG4dCefwqzBDf6OHWK2fVDM5d5Q6RuCTnnJAxzxjpzVkapCLG6vHgKXFrExmhON42j&#xd;&#xa;djPce44rFHiDLi7GpTHI3fY/sT7OnTfsznv1xn2qfXPtF/HoVzDcyWgmuIyI/LUlGZGOeR1HIx05&#xd;&#xa;res4Z4IAlxdNdSZJ8xkVT9MAYqZnVMbmC5OBk4yfSnUVn2f/ACF9R/7Zf+g1oUUUUUV5z8MP+Qhf&#xd;&#xa;f9cl/nXaeILWa80mSC3TfIZImC5A4Eik9fYGtKsCPT7uOwuQbfe/9oSXCw7l/eoXJAznHIPeoLm1&#xd;&#xa;vb5rQposdmIbuGRyXjLFQ2SRtPYDn68VJqEFzczFW0N2dWytzFcKgz2YjcCR7Gr2lWlzb6jqUtwM&#xd;&#xa;idoir5Hz4jVScDpyDVXWNOurqz1mOGLc1zGixDcBuIHPU8fjWlqFhHfrCHbb5UqyZAzkA5K/Q4wa&#xd;&#xa;r6zYz3xjSA7MxTIZM/cLJgH16+lZ5hvJLVrQaDGj+WU+0SPGVJA64Bzz/Xmq8JvNO1LSoksXubiP&#xd;&#xa;SvLkiWRVKkFMnJODyMcVt2aXV1eJe3dv9lMcbxJCWDH5ipJJBx/AMfU1o1wPgD/kYNX/AB/9DNd9&#xd;&#xa;WfZ/8hfUf+2X/oNaFFY6f8jjN/2D4/8A0Y9bFFFY/hL/AJFjT/8ArkP51sVk6Rd20VpKklxEjC6u&#xd;&#xa;MqzgEfvnq99us/8An6g/7+Cj7dZ/8/UH/fwUfbrP/n6g/wC/go+3Wf8Az9Qf9/BR9us/+fqD/v4K&#xd;&#xa;Pt1n/wA/UH/fwUfbrP8A5+oP+/go+3Wf/P1B/wB/BR9us/8An6g/7+Cj7dZ/8/UH/fwUfbrP/n6g&#xd;&#xa;/wC/gqjrd3bS6HqEcdxE7vbSKqq4JJKnAAq9YAiwtgRgiJePwFVNRt5ZdY0mVELRwySGRh0UGNgP&#xd;&#xa;1NaEwcwuImCyFTtJ6A9qy7Pw/YJbIb2xtJ7txvnlaIPvkPLEEjoTnjj6CoL3QNouE0mO2tYrq2ki&#xd;&#xa;nQDaHYriM4A4xls4x171K1vrF8pt78WUVrIMS+Q7Mzr3XlRgEcZByO1Wb2G+RI004WzxBPLaG4JC&#xd;&#xa;49cgEn05qrbaRMum3MMhiiacgrBAT5MJHZeBgHGTx1JqRYNUuvL+3LZp5UySL5Ls2QM5zkD2x+NW&#xd;&#xa;NVsmvrZFjYLLDKs0e77pZTkA+xPWqM1prV95S3T2cEcc0UpWFmbzArqxB3Lx0yMd/apPseo6eTFp&#xd;&#xa;ItWtWJYR3DsvlknJwQCTkknk9/SnXOn3txZ27STxveQT/aFB4j3YI2ZAztG484zxVOC08Qw6jdXg&#xd;&#xa;j0wtcLGpXzpMDbn/AGf9qpp7TWL8QLdrYxrFcxTAxSOSQrZI5X0q5qEepGTdYtbSRsmx4bjIXvyC&#xd;&#xa;ASc9MHjiotN0ySCzuIpzHF9oBHkW+fKhGMfICB16njqTTtJt9Qs1S0nW2NnBEI4nR2MjBcAFgRgc&#xd;&#xa;DnB60/X/APkX9S/69Zf/AEA1Y0//AJB9t/1yX+QqxRRRWOn/ACOM3/YPj/8ARj1d1SG4uLCSG0kS&#xd;&#xa;OVyo3P027huHQ9VyPxqCPw/o8caoul2ZCgAFoVY/iSMn6mqF3od2vmR6cLWK3S4huIITlVVlJL5w&#xd;&#xa;OM/L/wDWq3HaahezR/2slosMLiVFt3Y7nByCcgdDzRqVtqUzyJCljd2suCYbzICYxwMKc8jPPemS&#xd;&#xa;aTOdMs40eP7TazeeiEnyw3zfIDjIQBsDjoBT0s7+fUbC8vBbI1usyusTsQd23GMgf3TmpNTsrmW6&#xd;&#xa;tr2yMRuLcOqpMSEIbGckAn+GqbaZqd7qVndahJbLFAZA8ELEghkK5BKg5+bGOmB61MIdbtwLe3az&#xd;&#xa;kt1+VJZWZZAP90LjjoPXAzTrqwvUube9tJIZ7qOD7O/2glFYEglvlB5yo4xjk0NDrEGHtGtpTKN0&#xd;&#xa;sU8r7Y377Dgkgkng4AwMCnwaX5yzy6nsluLmIwyBCQqx/wBwdOOSc9efpUQh1u3At7drOS3X5Ull&#xd;&#xa;ZlkA/wB0LjjoPXAzU2oWE9xa2myZZLm0kWVWk+VZGCkfNgcZyTwKtWZuzAPtywrNk5ELFlx9SAaz&#xd;&#xa;/Ef+osP+whb/APoYrYorPs/+QvqP/bL/ANBrQooooorzn4Yf8hC+/wCuS/zr0aiiiiiiiiioTawm&#xd;&#xa;8W7Kfv1jMQbJ+6SCRjp1AqaiuB8Af8jBq/4/+hmu+rPs/wDkL6j/ANsv/Qa0KKx0/wCRxm/7B8f/&#xd;&#xa;AKMetiiisfwl/wAixp//AFyH862KoyaNpcsjSSabZu7kszNApJJ6knFN/sLSP+gVY/8AgOn+FH9h&#xd;&#xa;aR/0CrH/AMB0/wAKP7C0j/oFWP8A4Dp/hR/YWkf9Aqx/8B0/wo/sLSP+gVY/+A6f4Uf2FpH/AECr&#xd;&#xa;H/wHT/Cj+wtI/wCgVY/+A6f4Uf2FpH/QKsf/AAHT/Cj+wtI/6BVj/wCA6f4Uf2FpH/QKsf8AwHT/&#xd;&#xa;AAo/sLSP+gVY/wDgOn+FOj0bS4pFkj02zR0IZWWBQQR0IOKvVFJcRRTRRO4WSYkRqerEDJ/QVLRR&#xd;&#xa;RRRRRRRRRRRRRVfULb7bp9za79nnxNHuxnbuBGcfjUlvF5NvFFndsQLnGM4GKkoooqIXERuTbBx5&#xd;&#xa;wQSFO+0kgH8waloooooooooooooooqnqVj9vS3XzPL8m4jm+7nO1s4/GrlFZ9n/yF9R/7Zf+g1oU&#xd;&#xa;UUUUV5FoGsy+FL+6WeyMkrKEZDJsKkHPoa3/APhZf/UI/wDJn/7Gj/hZf/UI/wDJn/7Gj/hZf/UI&#xd;&#xa;/wDJn/7Gj/hZf/UI/wDJn/7Gj/hZf/UI/wDJn/7Gj/hZf/UI/wDJn/7Gj/hZf/UI/wDJn/7Gj/hZ&#xd;&#xa;f/UI/wDJn/7Gj/hZf/UI/wDJn/7Gj/hZf/UI/wDJn/7Gj/hZf/UI/wDJn/7Gj/hZf/UI/wDJn/7G&#xd;&#xa;j/hZf/UI/wDJn/7Gj4cpLNf6jfGIrDLwG6jdnJH5EV31Z9n/AMhfUf8Atl/6DWhRWOn/ACOM3/YP&#xd;&#xa;j/8ARj1sUUVj+Ev+RY0//rkP51sUUUUUUUUUUUUUUVk6zb3j3mn3dlAk7Wsjs0bSbMhkK9cH1oS9&#xd;&#xa;1ouofRoVUnk/bQcD/vitasf7drn/AEBYP/A4f/EVfsZbqaEte2qW0gbARZfMBHHOcD34rO1fWL7T&#xd;&#xa;ZTs02KeIkCM/atrvwM4XaTxyT7AmrOm3l/dsGuLGGGBk3JLHdCUN0xjCjgjnNS3899D5f2GyS6zn&#xd;&#xa;fvn8vb0x2Oe/5VWhvNYaZFl0iGOMsAzi83FR3ONvP0q/dvPHbO9rAs8wxtjZ9gPPPODjis37drn/&#xd;&#xa;AEBYP/A4f/EVoWclzLAGu7dbeXJ+RZN4x9cCqU15rCzOsWkQyRhiFc3m0sOxxt4+lT2FxqEzuL2w&#xd;&#xa;jtlA+UrceZk/98jFJfXOowzBbLT47mMrku1x5ZB54xtPtzUdvd6u86LPpUMURPzOLvcVH02jNWr6&#xd;&#xa;W6hhDWVqlzIWwUaXywBzznB9uKzpL3XzGwj0e2VyDtLXmQD2yNoz+YrXiLmJDKAJNo3AdM96fRRR&#xd;&#xa;WJexajBrzX1lZx3Mb2qwkNP5ZBDMfQ+oqzaXWqyXKJdaXFBCc7pFut5HHHG0Z5qzfS3UMIaytUuZ&#xd;&#xa;C2CjS+WAOec4PtxVD7drn/QFg/8AA4f/ABFaszOsLtEgkkCkqhbaGPYZ7fWsr7drn/QFg/8AA4f/&#xd;&#xa;ABFaVo88lsj3UCwTHO6NX3gc8c4GeKq3t1qcU5W002K4iwPna52HP02mok1HUIklm1DTY7e2ijaR&#xd;&#xa;5EufMIAGfu7RRFqd1d6XbXun2KT+cMlHn2bR2OcHNIl7rRdQ+jQqpPJ+2g4H/fFaNw8qQO0EQllA&#xd;&#xa;+VC+0Mfrg4rM+3a5/wBAWD/wOH/xFadu8rwI08QilI+ZA+4KfrgZrOe91oOwTRoWUHg/bQMj/vip&#xd;&#xa;7G51GaYre6fHbRhch1uPMJPHGNo9+affz30Pl/YbJLrOd++fy9vTHY57/lVMXeuySxL/AGXbQoZF&#xd;&#xa;8xzdb8Jn5sDaOcVsUVn2f/IX1H/tl/6DWhRRRRRRRRRRRVPVbpbLTppmYrgBVIHIZiFX9SKytKhf&#xd;&#xa;SdQhgmVU+2W4eeVuj3IwCAehJ+Y46nGa6Giiiiiiis+z/wCQvqP/AGy/9BrQorHT/kcZv+wfH/6M&#xd;&#xa;en3d3enWorC0kt4la3aYvLE0hyGAxgMvrUvk6v8A8/1j/wCAb/8Ax2jydX/5/rH/AMA3/wDjtVtO&#xd;&#xa;0zU9OsIbOHULRo4V2qXs2JI98SVZ8nV/+f6x/wDAN/8A47R5Or/8/wBY/wDgG/8A8do8nV/+f6x/&#xd;&#xa;8A3/APjtHk6v/wA/1j/4Bv8A/HaPJ1f/AJ/rH/wDf/47R5Or/wDP9Y/+Ab//AB2jydX/AOf6x/8A&#xd;&#xa;AN//AI7R5Or/APP9Y/8AgG//AMdo8nV/+f6x/wDAN/8A47R5Or/8/wBY/wDgG/8A8do8nV/+f6x/&#xd;&#xa;8A3/APjtHk6v/wA/1j/4Bv8A/HaPJ1f/AJ/rH/wDf/47VfUJNXstPubr7XYv5ETSbfsjjdtBOM+Z&#xd;&#xa;7Vp2shmtYZWADOiscdMkVLRRRRWTeW8eoazFDIx220TuCh5DOChB/wCAnNTaH8ulRwj7tu8lup7l&#xd;&#xa;Y3ZFJ98KM+9aFFFFFFFFFFFFFFFFFFFFFFFFZOvO0v2SwiOXuZRvj/vwgjzMnpjB6dTnimaSosNU&#xd;&#xa;vNNAyGxdR46Ih+QLj6oT+NbNFFFFFFFFFZ9n/wAhfUf+2X/oNaFFFFFFFFFFFFZmtIt2LSwY/JcT&#xd;&#xa;jzNv3lVQzgj/AIEij8aZ4lRl0z7XEpeeycXESAZDMARgjqR8x6VqI6yKGRgynoQcg06iiiiiis+z&#xd;&#xa;/wCQvqP/AGy/9BrQorHT/kcZv+wfH/6Meh/+Rxh/7B8n/oxK2KRmCqWYgKBkkngCloopodSxUMCy&#xd;&#xa;4yM8inUUUUU3eu/ZuG7GduecetOooorP1/8A5F/Uv+vWX/0A1Y0//kH23/XJf5CrFFFFFY/h7/SY&#xd;&#xa;7nUj8r3kp3IOi7CYxj6hc0tmTa+Ir63c5+1KLiIL0VVCq2fQljniteiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;istoxdeIlk3cWMPBHIZpCQQfoEX/AL6qPVP9C1S01IfJD/qbqTr8hzsGP99h0Hfnitiiiiiiiiii&#xd;&#xa;s+z/AOQvqP8A2y/9BrQoooooooooooqhf6PY6jMk11E7SIpVWWV0IHXHykVi6JoVhdRXbTpO5jvJ&#xd;&#xa;ol/0mUYVWIA4b0ro7S1hsrWO2tk2Qxjaq5JwPqamoooooorPs/8AkL6j/wBsv/Qa0KKx0/5HGb/s&#xd;&#xa;Hx/+jHof/kcYf+wfJ/6MSodLto4vFOrMm/iOJgDIxALli3BOOSo+naqmo3+qaj4dvLu2hsxYTW0j&#xd;&#xa;AySMJQm054AIz171cn1i6lu547A2Cpbv5T/a5ijFwASQAD8uCOfXNEOt3N+sS6dao7yxMwaVsIpV&#xd;&#xa;ypzjJwcHGAe2cVnanqOqTXdlbJHbJcW96iS4kYIzsjMoBxkrtPOR17d6TWL/AFFtL1qCaG1iuLeK&#xd;&#xa;JmkgduVbd3IByMfrWxJeatZ2slxfQWeyNlLmCRjtj53scgdByAM5qj4h1N30+7MA/wBFh8gmZSQ2&#xd;&#xa;8yIxXHX7jKfxxTNd8QWNzpjQ2s0wmaWLb+4kT/loueSoHTNa2qXV7BIgtG08KRz9qmZDn2wDWdHr&#xd;&#xa;93dM8Nstkk1uds7zylYnJ6eWwBLDg5yB2prvqY8SsIoLZrttPj35ciJf3j98Z/Sqes3NxqF3Z2Uz&#xd;&#xa;GC6tpnM3kMSjERGRQDwSMAA5HXNP1a9l1S1s1BMOyFLyQxsflfKr5Z/77PvxWxqN5qEN0Utm0wR4&#xd;&#xa;H/HxOyPn6AGoYdautRIGl2qsHgjnV7htoUMzjDYyc/JxgHvnFJd3zXvhrWFlQJPbxTQyhTldwjz8&#xd;&#xa;p6kcjritXT/+Qfbf9cl/kKsUUUUVy2t6PHpulSTWd7qEJEqYRLpgo3yANgA/7RrXsdFgsrw3az3U&#xd;&#xa;03lmPM87SYUkHjPuBWlRRRRRRRRRRRRRRRRRRRRRRRWTJ4ft3uJpkur6Fpn3usNyyKWxjOB9BVHT&#xd;&#xa;dDivtPhlur3UJstuKPdOykq3GQfoK6Siiiiiiiiis+z/AOQvqP8A2y/9BrQoooooooooooorH8Of&#xd;&#xa;6i//AOwhcf8AoZrYooooooorPs/+QvqP/bL/ANBrQorHT/kcZv8AsHx/+jHof/kcYf8AsHyf+jEp&#xd;&#xa;1hZ38Wu393cC2+z3CqqCN2LjYTtyCMchjnnrVL+yNVTR5dIhktFtRA0UcpZjI2QQNwxgde1F1oMq&#xd;&#xa;3txNBY6XeC4kMrPeqd6kgDaMKeOAfqTWjYaa1ncRuBCqLAY9sSbACW3cADGOap3Oi3Ml9dXcbxbz&#xd;&#xa;cx3ECsTglY9mG446npmmrot7e/2r/abW8X26KOMfZmZtoXdz8wHqKuYupdPvU1tbWK3aIhmt5GOF&#xd;&#xa;wdxOQMcVQt9NuL3w08eFjuLiZJDvOBtR1C9PVI1/GtTWrKTUNMe2hZFdnjYFyQMK6sf0FU9V0u4u&#xd;&#xa;LwzRWmnXisoGL3J8vH935TwaoxaLqKRGKTTNCljEjOiPuIj3YyFGzjoK09P0qez1ITyXBuEFosG+&#xd;&#xa;RiZGYOzZP4Ed6r/2Lc/8JL/aW+LyfO8zbk7seT5fpjr79KsPocMVtfJZ/LJeS+a5djjduyfpVO60&#xd;&#xa;W6N1M62el3yyOziS+yZFBOdo+U/KOg5qvplnq2m3C2dotlJJFYwLKZZHAzvlxtwvPfrVu5spLPw1&#xd;&#xa;rTzshmuYpppAhJVWMeMAnnHy1r6f/wAg+2/65L/IVYoooorH8Vf8gGX/AK6w/wDo1K2KKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKz9C/wCQRB/wL/0I1oUUUUUUUUUVn2f/ACF9R/7Zf+g1oVQ1jUH062jkitxP&#xd;&#xa;JJMkKoX2Aljgc4NVvt2uf9AWD/wOH/xFH27XP+gLB/4HD/4ij7drn/QFg/8AA4f/ABFH27XP+gLB&#xd;&#xa;/wCBw/8AiKPt2uf9AWD/AMDh/wDEUfbtc/6AsH/gcP8A4ij7drn/AEBYP/A4f/EUfbtc/wCgLB/4&#xd;&#xa;HD/4ij7drn/QFg/8Dh/8RR9u1z/oCwf+Bw/+Io+3a5/0BYP/AAOH/wARVTTf7csEuF/smCTzriSb&#xd;&#xa;/j8AxubOPu9qt/btc/6AsH/gcP8A4ij7drn/AEBYP/A4f/EUfbtc/wCgLB/4HD/4ij7drn/QFg/8&#xd;&#xa;Dh/8RR9u1z/oCwf+Bw/+Io+3a5/0BYP/AAOH/wARR9u1z/oCwf8AgcP/AIirWj37anpsd28PkszO&#xd;&#xa;pj3bsFWK9cDPSm2f/IX1H/tl/wCg1oUVjp/yOM3/AGD4/wD0Y9D/API4w/8AYPk/9GJWxRRRRRRR&#xd;&#xa;RRRRRRRRWfr/APyL+pf9esv/AKAasaf/AMg+2/65L/IVYoooorH8Vf8AIBl/66w/+jUrYooooooo&#xd;&#xa;ooooooooorOuNSlj1M2NvaGeQQiYnzAoALEd/pS/a9Q/6Bn/AJMLR9r1D/oGf+TC0fa9Q/6Bn/kw&#xd;&#xa;tH2vUP8AoGf+TC0fa9Q/6Bn/AJMLR9r1D/oGf+TC0fa9Q/6Bn/kwtH2vUP8AoGf+TC1W09tSs7KO&#xd;&#xa;BtODFM8ide5J/rVn7XqH/QM/8mFo+16h/wBAz/yYWj7XqH/QM/8AJhaPteof9Az/AMmFo+16h/0D&#xd;&#xa;P/JhaW21BpL37HcW5gnMZlVdwYFQQCcj3Iq/RRRWfZ/8hfUf+2X/AKDWhWP4j/1Fh/2ELf8A9DFb&#xd;&#xa;FFFFMjljlLiORHKNtfawO1vQ+h5FPopryJHt3uq7jtGTjJ9KdRRRTFljaV4lkQyIAWQMMqD0yO2c&#xd;&#xa;Gn0UUUUVj+Ff+QDF/wBdZv8A0a9WLP8A5C+o/wDbL/0GtCisdP8AkcZv+wfH/wCjHp15Bdx67FfW&#xd;&#xa;9uJ4xbNCR5gUgllPf6VN9r1D/oGf+TC0fa9Q/wCgZ/5MLR9r1D/oGf8AkwtH2vUP+gZ/5MLR9r1D&#xd;&#xa;/oGf+TC0fa9Q/wCgZ/5MLR9r1D/oGf8AkwtH2vUP+gZ/5MLR9r1D/oGf+TC0fa9Q/wCgZ/5MLR9r&#xd;&#xa;1D/oGf8AkwtH2vUP+gZ/5MLR9r1D/oGf+TC0fa9Q/wCgZ/5MLR9r1D/oGf8AkwtH2vUP+gZ/5MLV&#xd;&#xa;bUm1K8026tV04K08LxhjOuASCM/rWnaRtFaQxv8AeSNVP1AqaiiiisfxV/yAZf8ArrD/AOjUrYoo&#xd;&#xa;oooooooooooooorHT/kcZv8AsHx/+jHrYooooooooooooorHf/kcYf8AsHyf+jErYooorPs/+Qvq&#xd;&#xa;P/bL/wBBrQrH8R/6iw/7CFv/AOhitC/JFhckHBETc/gaLAk2FsSckxLz+ArIvtU+wT61PHAGktYI&#xd;&#xa;XyXOHzu4x0GMdqsSaje232eW7to44p5khEYbLoWOBkjg/hVTTbwQXOqQRAPdS6gwjj7fcTLH0AGT&#xd;&#xa;74wOa09R1FbCKJX2tcTHbGm7aGPU8ngADJ59PWq8WuRo00Ny0Rmij8wGFtyyLkDI9OWA5+vSorxt&#xd;&#xa;Qd7F7mOCKNrlDsBJdevBPT8qrWGt2ljearDeSzb/ALaxUCGRwF2r3UEDvxVrw1dLeDU5kd3jN82z&#xd;&#xa;cCCBsTseRSXGty2yG4lW2EQkCeQJQ0vLbQeDjqc/T3qzPfTtqElpbNbK0YXImY5YkZ4ArOtpNQXx&#xd;&#xa;LqKRQwtI0MBkkLYRMB+MdTn+lRa1cyappZtWZreVdRjtJHiJ6krkj/vqrR1GYaWtkYx/aTObYRbv&#xd;&#xa;QAk7umfLIfr7deKl0XfYeHSgcztbyzRhpHALbZWAJJ+lT2WoSSXy2sz20jPE0itbsSFClQQc+u4Y&#xd;&#xa;+hrNi17VJdDTVhp0Xkqu+SPzBuKDlmXnGMdjzxXQwSiaCOUDAdQ2PTIrL8K/8gGL/rrN/wCjXqxZ&#xd;&#xa;/wDIX1H/ALZf+g1oUVjp/wAjjN/2D4//AEY9bFFFFFFFFFFFFFFFFFFFFFFFFY/ir/kAy/8AXWH/&#xd;&#xa;ANGpWxRRRRRRRRRRRRRRRRWOn/I4zf8AYPj/APRj1sUUUUUUUUUUUUUVjv8A8jjD/wBg+T/0YlbF&#xd;&#xa;FFFZ9n/yF9R/7Zf+g1oVj+I/9RYf9hC3/wDQxWjeo0llOiDLNGwA9Tisuy1aaOCCB9G1MFVVC3lp&#xd;&#xa;gcYz97pVTWLC6n/4SDyoHb7RbwrFj+MjdkD8xWnrtvLcRWYhQuUvYZGx2UOCTWbBpUtvPq+pxQyr&#xd;&#xa;feezw4c4mQKpClc4IJ3DJGRnI5Aq9qunnUYLS4kgillt/wB4beVco+VwQevIyce4FUfsYubW6Ona&#xd;&#xa;JFYHysAyxLHI7ZBAG3Py8evXFS/atR1I2O7TZbYRSo9x5vHOP4ME5AOc5x2q7o1vLBLqZlQoJb1p&#xd;&#xa;Ez/EuxBn9DUenWtxGmsKVMTT3TtExOMgooB/MfpWJe2IuLJYLXw+YrqN4zJcPAilgHXcVYEkk9ec&#xd;&#xa;cZ+lamsx2b3qmXRLy5mTDLc2qhWBx03hlbv0pPDlhfWV5d/b2MrmCBfO3Fg7Dfnk8nqKgksLo+fi&#xd;&#xa;B/m1mOce8Y2Zb6cH8q2Rp0X9qm+PLbAAm0YDcguP9orhc+gArMuLK5OloDCzpHfzTTQDkzRGSQhc&#xd;&#xa;dDncpweKNLtca1HdQaSmn232eRMeWqOW3R/eC8djjk9+lUNDmnv/AAvbaXFZTxrLAY3uJABHsOQx&#xd;&#xa;Ugkk4PGRXVwRCGCOIHIRQufXArL8K/8AIBi/66zf+jXqxZ/8hfUf+2X/AKDWhRWOn/I4zf8AYPj/&#xd;&#xa;APRj1sUUUUUUUUUUUUUUUUUUUUUUUVj+Kv8AkAy/9dYf/RqVsUUUUUUUUUVxeqfECOx1Ge0i055R&#xd;&#xa;A5jZ2lCZYHBwMHjiqv8Awsv/AKhH/kz/APY0f8LL/wCoR/5M/wD2NH/Cy/8AqEf+TP8A9jR/wsv/&#xd;&#xa;AKhH/kz/APY0f8LL/wCoR/5M/wD2NH/Cy/8AqEf+TP8A9jVNfHuNYfUP7N+9brD5fn9MMWznb71c&#xd;&#xa;/wCFl/8AUI/8mf8A7Gj/AIWX/wBQj/yZ/wDsaP8AhZf/AFCP/Jn/AOxo/wCFl/8AUI/8mf8A7Gj/&#xd;&#xa;AIWX/wBQj/yZ/wDsaP8AhZf/AFCP/Jn/AOxrT8PeNP7c1RbL+z/Iyhbf527p7bRXV1jL4gMg3RaR&#xd;&#xa;qciZIDrGmDg44+al/tyX/oCar/37T/4uj+3Jf+gJqv8A37T/AOLo/tyX/oCar/37T/4uj+3Jf+gJ&#xd;&#xa;qv8A37T/AOLo/tyX/oCar/37T/4uqLX9ydejv/7G1LyltWhI8tN24sp/vdODV7+3Jf8AoCar/wB+&#xd;&#xa;0/8Ai6P7cl/6Amq/9+0/+Lo/tyX/AKAmq/8AftP/AIuj+3Jf+gJqv/ftP/i6gh1OWK7uJ/7H1U+d&#xd;&#xa;t+Xyk4wMf36sx65uniil0vUIBK4QPKiBQT64Y03xH/qLD/sIW/8A6GK2KKKKKKKKKKKKKKKKKr2N&#xd;&#xa;pFYWcVrACIol2rk5OKsVj+Ff+QDF/wBdZv8A0a9WLP8A5C+o/wDbL/0GtCisdP8AkcZv+wfH/wCj&#xd;&#xa;HrYooooooooooooooooooooooorH8Vf8gGX/AK6w/wDo1K2KKKKKKKKKK4Hwn/yUHWv+2/8A6NWu&#xd;&#xa;+oooooooooooorznw5/yUi//AOutx/6Ea9GrP0L/AJBEH/Av/QjWhRRRRRRRRRRWfq3/AC5f9fSf&#xd;&#xa;1qv4lEn2O1kjhlm8q8hkZYkLttVsngUf8JBF/wBA7Vf/AACf/Cj/AISCL/oHar/4BP8A4Uf8JBF/&#xd;&#xa;0DtV/wDAJ/8ACj/hIIv+gdqv/gE/+FH/AAkEX/QO1X/wCf8Awo/4SCL/AKB2q/8AgE/+FH/CQRf9&#xd;&#xa;A7Vf/AJ/8KP+Egi/6B2q/wDgE/8AhR/wkEX/AEDtV/8AAJ/8KP8AhIIv+gdqv/gE/wDhR/wkEX/Q&#xd;&#xa;O1X/AMAn/wAKP+Egi/6B2q/+AT/4Uf8ACQRf9A7Vf/AJ/wDCj/hIIv8AoHar/wCAT/4Uf8JBF/0D&#xd;&#xa;tV/8An/wo/4SCL/oHar/AOAT/wCFH/CQRf8AQO1X/wAAn/wo/wCEgi/6B2q/+AT/AOFH/CQRf9A7&#xd;&#xa;Vf8AwCf/AAp3hdJI9ChEsUkTmSVtkilWAMjEZB9jU1n/AMhfUf8Atl/6DWhWRrFlbX+oafBdwrNE&#xd;&#xa;TIdrdM7aT/hFtD/6BsH5Gj/hFtD/AOgbB+Ro/wCEW0P/AKBsH5Gj/hFtD/6BsH5Gmf8ACOeHzMYf&#xd;&#xa;sNt5oXcUz823pnGenBp//CLaH/0DYPyNH/CLaH/0DYPyNH/CLaH/ANA2D8jTIfDnh+eJZYbG2kjY&#xd;&#xa;ZV0OQR7EGj/hHPD5mMP2G280LuKZ+bb0zjPTg0//AIRbQ/8AoGwfkao6jounade6TNZWkcMjXyqW&#xd;&#xa;UckbHOP0FdNRRRRRRRRRRRRWP4q/5AMv/XWH/wBGpWxRRRRRRRRRXA+E/wDkoOtf9t//AEatd9WL&#xd;&#xa;PqkVn4leC7vYoLc2aOqyyBQW3sCRnvgCotb12z/s1vsGp2zXBkiCiKZWYgyKDgA+ma1rq+t7RlSV&#xd;&#xa;nMjDIjijaR8eu1QTj3xjkVGuq2bRO/mOChAaNomEgJ6fIRu5wccc4p1vqVtcy+UhkSQjKpNC8RYd&#xd;&#xa;9oYDOO+OmR61keH9Vgj0lEla4lkWWUMYoJJdv7xsAlQcHGODzgj1FaF9fg2MUlpNGEnk8vz2PyR9&#xd;&#xa;ck+hyNo/2iB7VD/Y91D+8t9XvZJV5VLhlaMn/aAUEj6GrtxqVtbS+U5keQDLJDC8pUdtwUHGe2eu&#xd;&#xa;D6VFqWppa6LcX9uyzBYmeNkUyKxAOM7e2ep6e9P03UEvoUISZX2Bm3wPGuT6FgAfwq7XnPhz/kpF&#xd;&#xa;/wD9dbj/ANCNejVn6F/yCIP+Bf8AoRqe+tGvIRGt1cWxDbt8DAMevHIPHP6VjwaXcS313A2tanth&#xd;&#xa;2bSJEycjJz8taB1Oys5PsMlzJLcwou5fLZ5GBH3sKOenOBx7VPJqFvFBHK/mgSfdQQuXP/AMbv0p&#xd;&#xa;8F3BcQtLG5CoSHDqUKHr8wbBHGDz2IPeoYdVs5pVjSRxvOEd4mVJD22uQFbPUYJyORxVe7Mt/qDW&#xd;&#xa;Czz2SRIJPMiIVpT0wpIIIGfm46leneWysLmynGL+a6hcHeLkhmBHTaQAB3znPanrqto0wjDScttE&#xd;&#xa;hhcRk9AN+NvJ4HPJ461X1TVjp+o6fBsdo7hnEhWF3IAUkY2jrkD14/OtC3uEuYvMjWQLnGJI2jP5&#xd;&#xa;MAaqat/y5f8AX0n9a0KKKKKKKKKKKKKKKKKKKKKz7P8A5C+o/wDbL/0GtCs+8/5C+nf9tf8A0Gq0&#xd;&#xa;GoxW2o6nHMty5FwpXy7eSQAeTHxlVIHOeKj0m883UdbmXzPLR4yqyqYyMRDPDYx+P1qG18QO17bp&#xd;&#xa;LdadMl1IESC2kDSxEgkbiGIIAGDgdSKmfUr661Ga2sLvTI2iYp5M4ZpTjqcBhx+FRXj3o8XSJYRx&#xd;&#xa;mR7BB5kvKR/vHOSAQTnpx3NTPe30+n6nbEwLfWihWkCt5bZXdwM5HynHXrTdHury18Lw3V6YJQtv&#xd;&#xa;G0YVthK7R95nOM+/Ao0zWpJtRjs57vT7tplZlaybiPbjO7LHrkY+hrK0m/1iz8LWl3b2sBs7eMGR&#xd;&#xa;HOZHQZLOp3YHHYjORWtDcI3iWS5b5UOmRyHvgb3NQweJozcJLNd2AtJW2LFHKGmQngMcMcgnsBkb&#xd;&#xa;hnoat6//AK/R/wDsIJ/6A9bFFFFFFFFFFFFFY/ir/kAy/wDXWH/0albFFFFFFFFFFcD4T/5KDrX/&#xd;&#xa;AG3/APRq131YjQxTeMJRLEkgFhHgMoOP3j0zxPaW0WiSPHbxIwlhwyoAR+9Sn3zTTanKqakNPEKq&#xd;&#xa;FPlxkyA8nlh/Ksmw8ubU9WE2pvK6m3CXTQhdrjfg4xgj36GtiwvJRfx2l08N2xVjDcw4JwPvb8AB&#xd;&#xa;ScjGOuDR4UUDQoyAAWmmJwOp81qr6NLBF4Yj+1Rs8DTSq5AztzK+CR164HHTOemSGT29npqrNokh&#xd;&#xa;e8ZtixCdpRL32ncSFHAO7jpjPNIIbhdRvh/bLWLGXcEMMZBU9CGYc9+M8e2actskPhjWYoLt7xmS&#xd;&#xa;bLGPb83ljhQBjHTpxzWvpk0UllAiSozLEu5QwJHHerlec+HP+SkX/wD11uP/AEI16NWfoX/IIg/4&#xd;&#xa;F/6Ea0Kz7P8A5C+o/wDbL/0Gq1iinxVqrFQWWK3wccjh6r6pb3R8RLOt+1jA1sEWTYjAuGYkfNnH&#xd;&#xa;BHPeqV9YzSwX3karLe3jxxElY1UKgkBJyoCk4B464x7VObfzraIyeImkhG1ljFvGrewwF3A/qK1N&#xd;&#xa;TSwu5VtdRR0UDfHIZDGG7EBlIPGRwcZ7ZxxmyRSLFe6fozNPA9tJx5mfJkKnbtdjltxz3OMDpmoB&#xd;&#xa;bSPpPlz+InSLysPEII9y4HIAA3Z9Mc+lX77bFqGguXPlRs+ZH4wPKIBOema2o5I5V3ROrr6qciqW&#xd;&#xa;rf8ALl/19J/WtCiq97eQafavc3T7IUxubaW6kAcDnqRWf/wk+lf89p//AAFl/wDiaP8AhJ9K/wCe&#xd;&#xa;0/8A4Cy//E0f8JPpX/Paf/wFl/8AiaP+En0r/ntP/wCAsv8A8TR/wk+lf89p/wDwFl/+Jo/4SfSv&#xd;&#xa;+e0//gLL/wDE0f8ACT6V/wA9p/8AwFl/+Jo/4SfSv+e0/wD4Cy//ABNH/CT6V/z2n/8AAWX/AOJo&#xd;&#xa;/wCEn0r/AJ7T/wDgLL/8TR/wk+lf89p//AWX/wCJo/4SfSv+e0//AICy/wDxNH/CT6V/z2n/APAW&#xd;&#xa;X/4mj/hJ9K/57T/+Asv/AMTR/wAJPpX/AD2n/wDAWX/4mj/hJ9K/57T/APgLL/8AE0f8JPpX/Paf&#xd;&#xa;/wABZf8A4mj/AISfSv8AntP/AOAsv/xNVLbxBp0eo3srSThJdmw/ZpecDB/hret7iK6hWaF9yMMg&#xd;&#xa;4x+Y6g+xqpef8hfTv+2v/oNSWUEkV1qDuuFmuA6HPUeVGufzU/lWfJp1082tFU2i5eJojuHzBUUH&#xd;&#xa;6cgjmorm1uLq9057fSPsscFyJJWcxhsbWHG1jkc89+mM84XW9OTUWkVdJuBchWWG7WVEVWYfeOHD&#xd;&#xa;EAgdQTx0q8trMPEkt2U/cNZpEGyPvB2JGOvQioobG4+2a0zKFS7K+UxIwf3QU9ORzVb7DeHSdNtj&#xd;&#xa;avnT3jEqFlxcKqFTt55BJB+bbSxWl1J4gs7tdOS0tYo5VPKB8nb94KSMccYJ75xUOn2uoHw5Fo8t&#xd;&#xa;hJAzRGGWaR0KhTkMV2sSTg8cYq4umSjVpSQfszaelsJMjO4M2ePoRTYLeeGKO2GkQmZMD7R8nlEA&#xd;&#xa;9eu/OP8AZ+97c0/X/wDX6P8A9hBP/QHrYoooooooooooorH8Vf8AIBl/66w/+jUrYooooooooorg&#xd;&#xa;fCf/ACUHWv8Atv8A+jVrvqZ5UYmM3lp5pXaX2jdt64z6cmiWKOeMxzRpIhIJV1BGQcjj6iobrT7K&#xd;&#xa;8ZWu7O3nZRgGWJWIH4il+w2flvH9lg2Oioy+WMMo6AjuB2FFrY2dlu+yWsFvvxu8qMJux0zj6mpY&#xd;&#xa;oo4IxHDGkaAkhUUAZJyePqaRIIY4TDHEiRHPyKoC88nj3yahttNsbOQyWtlbQORtLRRKpI9Mge1O&#xd;&#xa;urGzvdv2u1guNmdvmxh9ueuM/QVLDFHBEsUMaRxqMKiKAAPYCorexs7WR5La1ghd/vNHGFLfUjrV&#xd;&#xa;ivOfDn/JSL//AK63H/oRr0as/Qv+QRB/wL/0I1oU1Y0V2dUUM2NzAcnHTNIsUayvKsaCRwAzhRlg&#xd;&#xa;OmT3xk024toLuLyrmCOaPOdkiBhn6GktrS2s4zHa28UCE7isSBQT64H0qJdL09bn7StjbCfcW80Q&#xd;&#xa;ru3HvnGc1Lc2lteRiO6t4p0B3BZUDAH1wfrS29tBaReVbQRwx5zsjQKM/QVC2l6e1z9paxtjPuDe&#xd;&#xa;aYV3bh3zjOannghuYWhuIklib7ySKGU9+hpLe2gtIvKtoI4Y852RoFGfoKqat/y5f9fSf1rQorH8&#xd;&#xa;Vf8AIBl/66w/+jUrYoooooooooooooooooorH8Of6i//AOwhcf8AoZqxef8AIX07/tr/AOg1oVU/&#xd;&#xa;tCE3k1uNxMCbpXx8qdDg++Dn6VYhlSeFJomDxyKGVh0IPINPoooooqteXsdl5bTK4jdtpkAG1D23&#xd;&#xa;fU4A9zVmsfX/APX6P/2EE/8AQHrYoooooooooooorH8Vf8gGX/rrD/6NStiiiiiiiiiivMtK1e10&#xd;&#xa;Xxvq9zelxGzzRjauTkyA/wBDXTf8J7of/PSf/v0aP+E90P8A56T/APfo0f8ACe6H/wA9J/8Av0aP&#xd;&#xa;+E90P/npP/36NH/Ce6H/AM9J/wDv0aP+E90P/npP/wB+jR/wnuh/89J/+/Ro/wCE90P/AJ6T/wDf&#xd;&#xa;o0f8J7of/PSf/v0aP+E90P8A56T/APfo0f8ACe6H/wA9J/8Av0aP+E90P/npP/36NH/Ce6H/AM9J&#xd;&#xa;/wDv0a5vwlcJd+Pbm5iyY5mmkXIwcE5Fel1haRq+mQabFFNqNpHIpYMjzqCDuPUE1d/t3SP+grY/&#xd;&#xa;+BCf40f27pH/AEFbH/wIT/Gj+3dI/wCgrY/+BCf40f27pH/QVsf/AAIT/Gj+3dI/6Ctj/wCBCf40&#xd;&#xa;f27pH/QVsf8AwIT/ABo/t3SP+grY/wDgQn+NH9u6R/0FbH/wIT/Gj+3dI/6Ctj/4EJ/jR/bukf8A&#xd;&#xa;QVsf/AhP8aP7d0j/AKCtj/4EJ/jVS+1TT7uWyitr62mk+1Idkcyscc9ga26Kx/FX/IBl/wCusP8A&#xd;&#xa;6NStiqdxfeTqlpZeXu+0pI2/djbs29u+d36UxdTjbV2sRswEyJN45k5zHj+8AAxGc4PSnW+oCa9v&#xd;&#xa;7dkEa2bKC5bhgUDZ9sZqzBPDcwrNbypLE33XjYMp7dRUb31nHdLavdQLcN0iMgDn8OtMjuHbVri2&#xd;&#xa;OPLjgikXjnLNID/6CKZPqSR3lhBGqyreO6iRX4Xapb8emKmubnyJ7SPZu+0SmPOcbcIzZ9/u4/Gn&#xd;&#xa;XN3bWcYkuriKBCdoaVwoJ9Mn6Uq3MDW32lZ4zBtLeaHG3aO+emKy77XLcpbf2deW07PdQxuI5FfC&#xd;&#xa;swB6HitG3vrO6keO2uoJnT7yxyBiv1A6VT0rV/7Qury3eDyGgldI8vkzKrFS4GBxnjvzRBq/n69J&#xd;&#xa;pyQZiSJnFwHyrMrKGTGOo3c88VcmvrOC4S3muoI55MbI3kAZsnAwDyeaWe9tbbf9ouYYtihm3yBd&#xd;&#xa;qk4BOe2eKfBPDcwrNbypLE33XjYMp7dRUlY/hz/UX/8A2ELj/wBDNWLz/kL6d/21/wDQatXcjRWk&#xd;&#xa;0ifeSNmH1Aqhb26W3hoxx52mB5Dk92BY/qTUugf8i/pv/XrF/wCgCse+v5Li/uAf7UQ2zlIfssDt&#xd;&#xa;HuHd9vDjOPlPTn1qzHeXGszw2UiTaeGtluJlVisnLMAoPBXBUHPccYpNNk+wXGtRS3szRW7xiN7i&#xd;&#xa;UyFS0YOOT3J6d6owXzwajZFG1Uy3M4jmN3HIkRBBJ2K3CnIGAOgzWlFE+uSXEstzc28UE7wJHbzN&#xd;&#xa;GcqcFiR1zgYHbnrmp4JZrXV0t7y4MzXFuojKrtUshYuduTjh0+uPanabINQgvZS7tbXEzLECeQoV&#xd;&#xa;UYY7fMr/AJ570eHbh7nRoZJMbgzxjA7K7KP0AqLX/wDX6P8A9hBP/QHrYoooooooooooorH8Vf8A&#xd;&#xa;IBl/66w/+jUrYooooooooorPvdD0y/nM93ZRTSkAbmHOKr/8Itof/QNg/I0f8Itof/QNg/I0f8It&#xd;&#xa;of8A0DYPyNH/AAi2h/8AQNg/I0f8Itof/QNg/I0f8Itof/QNg/I1zsGj6V/aSXos4zp11O0X7wYS&#xd;&#xa;JVTAP+yTICOTzkY610X/AAi2h/8AQNg/I0f8Itof/QNg/I0f8Itof/QNg/I0f8Itof8A0DYPyNH/&#xd;&#xa;AAi2h/8AQNg/I0f8Itof/QNg/I1Ys9D0ywnE9pZRQygEblHOK0KKKKKKKKKKKKKKKKx/FX/IBl/6&#xd;&#xa;6w/+jUrYrI19TGLO7jBDw3CB5APuRFh5hJ7Lgcn2rPtrV4tOttYuEeK7+0i4mjcbVj37Y5CQeQAm&#xd;&#xa;TyeMZPFU3jvHsbGVgiNdXMjXMl0h8tgpbyi+MeibeRk7etatrFeWeqXN3fXNmWe3Z2gtwVZyu0By&#xd;&#xa;GJ6AYz71kaw98fC11dK2nwWV4nnCPYwkO/5sZ3YLc+laOqpcya9OiRNLZfZIjdLGfnZQ0vygdwRu&#xd;&#xa;BHU9sU7Vo47280JLaeSCN3k2yQkBlAiPAyD6Yp8mmvZ6ppcjaje3INwy7J3UqP3MnPCjnj9amuvt&#xd;&#xa;s+rSNpws0lt4xG0lwjMSG+bAwRxwKo2ttc6rpLtDc2rTpqHniVATExUg8c5x+NV9WvJ7xLTS9WtE&#xd;&#xa;Scz27yhGyjq0m3A79jWtqSLHrehIgwqySgD0HlNVM2szWH2yzytzFd3KsUGWaMzSZX89p/4DVuzs&#xd;&#xa;/sWp6fCSGl+yTtK4/jkLQ7m/E5NZF7c3kvhu9v4W061sr2J3KSK3mMSuMZ3YLHGBxV2wt4pfE1vK&#xd;&#xa;6BpIdLiMbHqpLOD+hqxoFvFDqOrtaoFtZJkMbJyjHYN2D3+bIPvmtysfw5/qL/8A7CFx/wChmrF5&#xd;&#xa;/wAhfTv+2v8A6DV2aMTQvExIV1KnHXBrMsZJJbKXTLnbFdpGybcYDJ0Vh6jBXJHfiq9nZ+ILOzgt&#xd;&#xa;Y7jTCkMaxqWhkyQBgZ+b2q3cWd/DO8ulzQIJjukS4VmUH1XaRgnvnPQdKrajCNPFvcJdMlyq+X9p&#xd;&#xa;ueY2Xk4lIxgcnHT5iPpVLSdOGp2Ooym5eWG8lR4piRljHj26blwPb86uvpepXl1Z3F9dw5tpxII4&#xd;&#xa;FKowwRyCSd3PXOMZqeaxvbaZ5NJlt41mYvLHcKzKG65XaRgnJznPbpVTxHYx3GjQ6XJNPNNM6rGx&#xd;&#xa;YFyc/fYY5UZBOB09K0Z5xpunxR53z7BHEijJkYDHA6kdz6DJp+lWYsNPitwSSNzNk5+ZiWP4ZJqn&#xd;&#xa;r/8Ar9H/AOwgn/oD1sUUUUUUUUUUUUVj+Kv+QDL/ANdYf/RqVsUUUUUUUUUUUUUUUVS1i4e10i8m&#xd;&#xa;hfbMsLmI4B+faduAepz2qhc6creFRbwjysKk5ByeQ4kb8zn862IJRNBHKBgOobHpkVJRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRWP4q/wCQDL/11h/9GpWxUdxBHc28sEy7opUKOucZBGCOKLiCO5t5YJl3RSoUdc4y&#xd;&#xa;CMEcUjW8LW32dkBi2hdp9BVex0uzsA4toiN/DF3Zzj0yxPFV5PDmlStKZLZmEudymZ9vPoM4H4dK&#xd;&#xa;0VgjW4ecL+9dFRmz1CkkD/x4/nUK6daq1syxYNsWaL5j8pYEHvzwT1qaSCOV4ndctC+9DnodpXP5&#xd;&#xa;MfzqpfaPZahIslzG5cDGUldPz2kZp0mlWUlq9sYSsLv5hVHZPm+oIxTIdE0+GJY0gJVZVmBaRmIZ&#xd;&#xa;SCOSc446dKtS2sM08E8ibpICWjbJ+UkYP14NOggjt0KRLtUuzkZzyzFifzJoaCNrhJyv71EZFbPQ&#xd;&#xa;MQSP/HR+VUH0DTJJJXe2J81SrL5j7cEYOFzgfgKqXOgxXeu+bPC5tI7NIoyszJ8wZuPlIPQjrW3D&#xd;&#xa;EkESxRKFRRgAU+sfw5/qL/8A7CFx/wChmptQkji1TTmldUX95yxwPu1a+3Wf/P1B/wB/BTftljv3&#xd;&#xa;/aLfdjG7eucelO+3Wf8Az9Qf9/BR9us/+fqD/v4KbJd2MqFJLi2dT1VnUg0R3djEgSO4tkUdFV1A&#xd;&#xa;FO+3Wf8Az9Qf9/BR9us/+fqD/v4KabyxLBjcW5Zc4O9cig3lizKxuLcsv3SXXIp326z/AOfqD/v4&#xd;&#xa;KytauYJrnSFinjkYX6nCuCcbHrdoooooooooooorH8Vf8gGX/rrD/wCjUrYooooooooooooooorJ&#xd;&#xa;1+zv71LVbAW37qdZm892XlSCAMA9ec1U+3682ovp5ttMMghExJlk2lSSuPu9eDWjodpcWOlRW92y&#xd;&#xa;NMrOWKMSvLkgAkA8AgVoUUUUUUUUUUUUUUUUUUUUUVj+Kv8AkAy/9dYf/RqVsUUUUUUUUUUUUUUU&#xd;&#xa;UUUVj+HP9Rf/APYQuP8A0M1qSwxTACWJJAOgZQcVH9hs/wDn1g/79ij7DZ/8+sH/AH7FH2Gz/wCf&#xd;&#xa;WD/v2KPsNn/z6wf9+xR9hs/+fWD/AL9ij7DZ/wDPrB/37FH2Gz/59YP+/Yo+w2f/AD6wf9+xR9hs&#xd;&#xa;/wDn1g/79ij7DZ/8+sH/AH7FH2Gz/wCfWD/v2KVLO2jYMlvCrDoQgBFT0UUUUUUUUUUUVj+Kv+QD&#xd;&#xa;L/11h/8ARqVsUUUUUUUUUUUUUUUUVjp/yOM3/YPj/wDRj1sUUUUUUUUUUUUUUUUUUUUUUVW1Cyh1&#xd;&#xa;Gze1n3iNyCSjbSCCCMH6gVQ/4R+L/oI6r/4Gv/jR/wAI/F/0EdV/8DX/AMaP+Efi/wCgjqv/AIGv&#xd;&#xa;/jR/wj8X/QR1X/wNf/Gj/hH4v+gjqv8A4Gv/AI0f8I/F/wBBHVf/AANf/Gj/AIR+L/oI6r/4Gv8A&#xd;&#xa;40f8I/F/0EdV/wDA1/8AGj/hH4v+gjqv/ga/+NH/AAj8X/QR1X/wNf8Axo/4R+L/AKCOq/8Aga/+&#xd;&#xa;NH/CPxf9BHVf/A1/8aP+Efi/6COq/wDga/8AjR/wj8X/AEEdV/8AA1/8aP8AhH4v+gjqv/ga/wDj&#xd;&#xa;R/wj8X/QR1X/AMDX/wAaP+Efi/6COq/+Br/40f8ACPxf9BHVf/A1/wDGj/hH4v8AoI6r/wCBr/41&#xd;&#xa;d07T4dNtzDAZGVnZ2aRyzFickkmrdFFFFFFFFFFFFFFFFFFFFFFFFFY/ir/kAy/9dYf/AEalbFFF&#xd;&#xa;FFFFZMniC3S4mhS1vpmhfY7Q2zOobGcZH1FN/wCEgi/6B2q/+AT/AOFH/CQRf9A7Vf8AwCf/AAo/&#xd;&#xa;4SCL/oHar/4BP/hR/wAJBF/0DtV/8An/AMKP+Egi/wCgdqv/AIBP/hR/wkEX/QO1X/wCf/Cj/hII&#xd;&#xa;v+gdqv8A4BP/AIUf8JBF/wBA7Vf/AACf/Cj/AISCL/oHar/4BP8A4VnrquPEMl6dN1PyWtEiB+xv&#xd;&#xa;ncHYnjHoRWh/wkEX/QO1X/wCf/Cj/hIIv+gdqv8A4BP/AIUf8JBF/wBA7Vf/AACf/Cj/AISCL/oH&#xd;&#xa;ar/4BP8A4Uf8JBF/0DtV/wDAJ/8ACj/hIIv+gdqv/gE/+FH/AAkEX/QO1X/wCf8Awo/4SCL/AKB2&#xd;&#xa;q/8AgE/+FH/CQRf9A7Vf/AJ/8KkttchuLqK3NrfQtKSqNPbMikgFsZPsDWpRRRRRVD+1E+wfa/sl&#xd;&#xa;7t3bfL+zt5n129cVJ9uX7ZDbfZ7nMqbw/knYvXhm6A8dPcVGNUQ20832S9xCwUp9nbc3OMqO4+lJ&#xd;&#xa;c6slskLGzvpPNQOBHbMxX2bHQ+1T/bF+3/ZPJuN23d5nlHy/pu6ZqBdWRrJrr7HfBVfZ5Ztm8w+4&#xd;&#xa;XrjnrUv25ftkNt9nucypvD+Sdi9eGboDx09xUY1RDbTzfZL3ELBSn2dtzc4yo7j6VIb5QbUfZ7n/&#xd;&#xa;AEkZGIT+74B+f+717+9AvlJuh9nuf9GGTmE/vOCfk/vdO3tSHUFEds/2a6/0hgoHktlM93H8I+tS&#xd;&#xa;SXSx3kVsYpmMoJDrGSi49W6CoxqCmO5f7Ndf6OxUjyWy+O6D+IfSlN8oNqPs9z/pIyMQn93wD8/9&#xd;&#xa;3r396BfKTdD7Pc/6MMnMJ/ecE/J/e6dvamPqSJBBKbW8ImOAqwMWT/eH8P40/wC3L9smtvs9zmJN&#xd;&#xa;5fyTsbpwrdCeensafZ3S3kAlWKaIEkbZoyjfkasUUUUUUUUUyaWOCJpZpEjjUZZ3YAAe5NRNdKt6&#xd;&#xa;tr5UxZk3+YIz5Y9i3TPHSof7ST7HNc/ZbzET7CnkNvbpyq9SOevsae98qTwRG3uSZhkMsJKp/vH+&#xd;&#xa;H8aYNSQi6P2W8/0Y4OYG/eckfJ/e6dvag6kgFqfst5/pJwMQN+75A+f+717+9OGoKZLlPs11/o6l&#xd;&#xa;ifJbD47If4j9KP7QX+zvtv2a62/88vJbzeuPudff6c0HUFElsn2a6/0hQwPkthM9nP8ACfrTRqSE&#xd;&#xa;XR+y3n+jHBzA37zkj5P73Tt7UHUkAtT9lvP9JOBiBv3fIHz/AN3r396lF4puZ4fJuMwqGL+UdrcZ&#xd;&#xa;wp7n6VF/aSfY4bn7LeYlfYE8ht69eWXqBx19xUy3Steta+VMGVN/mGM+WfYN0zz0qD+1E+wfa/sl&#xd;&#xa;7t3bfL+zt5n129cU86gojtn+zXX+kMFA8lspnu4/hH1p4vFNzPD5NxmFQxfyjtbjOFPc/Si1vYbp&#xd;&#xa;ExvikdSwhmXZJtBwSVPOM/zFWaKKKKKKKKx/FX/IBl/66w/+jUrYoooooorH0D/X6x/2EH/9ASti&#xd;&#xa;iiimxyJKgeN1dT0ZTkGnUUUyGWOeJZYZEkjYZV0YEEexFPooopkMsc8SywyJJGwyrowII9iKfRRR&#xd;&#xa;RWfqX/H7pP8A19N/6JlrQoooooqnpO8aXb+ZdJdvs5nQ5D+4NXKKKKKKKKKKKZ5sYmEPmJ5pXcE3&#xd;&#xa;Ddt6Zx6cin0yGWOeJZYZEkjYZV0YEEexFPoqjpa3ax3H23O43MhjyQf3e75entV6iiiiiiiiqGuJ&#xd;&#xa;ayaPdJfyvFalP3joOVHtwf5Vfoooooooooooooooqi0s/wDbaQiAGA2zMZthyG3KAu7p0yce1XqK&#xd;&#xa;KKKKKKKx/FX/ACAZf+usP/o1K2KKKKKKKx9A/wBfrH/YQf8A9ASnI7f8JdMm47fsCHbnjPmPzVzU&#xd;&#xa;pI4rGR5kZ0GMqrYJ5HeodR1QWNxBbiB5prhHMSp/EVK8Z6D73U8cU2z1OSS6W2vbJ7KaQFold1fz&#xd;&#xa;APvcqTjGR19ai066W00GFyN7ncscYPLsWIAH4456DqeKtXl+baONUt3mupR8lupAJ7n5ugwM8k84&#xd;&#xa;pbC9a53RzwNbXCctC7BiB2ORwfwqrJq1y8jfYNMlvIVJXzVlRASOuAxBP16HtWBpt/HYWvhqSeR1&#xd;&#xa;hNtOGCKzZPyY4UGte88S6Y1nOqTT7jGwH+jSjnHrtqz9vlgs7SO3tZLy4eFXMasF+XAy25uOuOM5&#xd;&#xa;5p0WtQrBcvfRtZyWqh5o2+copztOVyDnB6U2HVLsTIt7pU1rG7BBIZEkG48AYUk/j0rJ8N6ncjw/&#xd;&#xa;ZR2WmTXixx7XcSLGA3p8xGeMcjjmtG91E3OnwTWzNHaTOUnnC5aIA4wB1OWG3IHGc+9Jb6NpPmh7&#xd;&#xa;GZlnT5lZbp5Nv/ASxB/EVdvtQ+zMsNvA11cvyIUYA4HUkngfiee1U9Q1ecaDe3FtA6XcEbB4yVzC&#xd;&#xa;dpO7nhgOvGc9KsaPe3t3Chu7B7ceWrCRpEYOfop4p2pf8fuk/wDX03/omWtCiiiiiqGhmE6Pam2t&#xd;&#xa;3todnyxOSSg9Dmq2oPNe6smmRTNDEsQmuMAfvY2JXYD1HTqMHnikbQvsoD6PcyWku4b97GUOueR8&#xd;&#xa;5OO/Iqe61KdJ2isbB73ZxIUlRAh9PmIz+FNl122hs1uJldSJBFLHtJaJj1GAOcEHkZB7VEdbmhIS&#xd;&#xa;90ya2kk+WBN6v5r/AN35Sdv1OBU9vqxcTpdWr2tzDGZjAzBiU7NlcjkgjGc8VBDrplVLj7DMunuB&#xd;&#xa;/pRIwM8fc+997jOPfpzV+8vRbW6SRxtO8hCxIn8ZIyOeg4HU8VQbXHt45jf2ElpIsLzRRtIrmUIM&#xd;&#xa;tgrkDHHX1qe01K4u7lPL06UWb5K3LOoBGODsJ3DnjpUUmsXO5pLfS5prRSf9I8xUGB947WIbgg9u&#xd;&#xa;ccVSudRjXxFZ3Vuj3H2jT28hVGDJl0I6/d47nFa1jqH2lmhuIGtblOTC7AnB6EEcH8Dx3qj4buIr&#xd;&#xa;XwjYzTPtRYck4z69B1J9hVm31Z2nVLyzktEl/wBTI7qwfv2+7x649OtadUNJEIjufIuHnH2qXcWB&#xd;&#xa;G1txyoz2B4pb/WNP02JpLy6SNVIUgZYg/QZNUtF8S2ut31zb2iOUgAYSngOPYHkVt0UUUVleIdbj&#xd;&#xa;0GxS6lheVXlEe1SAckE5/SotL8U6Tqe1IbpUm8sO8bgrt6ZGSADgntWhfvKdOle0gS6kKZSNiNr/&#xd;&#xa;AInirVY6yXur+ZJZXv2S1WQrFKkYZpcYDZDDgBtw/D0qe0/tG3uRBdOlxbCIt9qOFYtkcFRx0J5A&#xd;&#xa;7U1df01rn7OJ337iuTC4XP8AvYxj3zirF5qNpYuiXM3ltIrOg2k7guM4wOvI46ntUC69prWr3Anb&#xd;&#xa;YhwQYnD9ui43Hr1A/lUg1ex+wG+M+LcEKWZGBBLbRlSMjk+nv0pLfWLG6u2toZiZVz1jZVODjhiM&#xd;&#xa;H8DS32rWWnsq3MrBm6BI2cj67QcfjSnVrEWkd0ZwIZHWNWKkfMTgAjGR+NFnqtneySJbyOxjGWLR&#xd;&#xa;Mox9SAD+FRQ69p09yLdJn3kkDdC6r/30Rj9agvvENvYa0tjcbgnkGQusTsQ2QAMAHjBPNTza7p0E&#xd;&#xa;UUkkz7ZRuULC7HHuAMj8cVKdWsRaR3RnAhkdY1YqR8xOACMZH40WWqWl/LJHbO7NH97MTqPwJAB/&#xd;&#xa;CpCJv7SUi4QQeScwYG4tkYbPXGMj8as0UUUUUUUVj+Kv+QDL/wBdYf8A0albFFFFFFFY+gf6/WP+&#xd;&#xa;wg//AKAlVbzUrPTfF0j3twkCvYIFLdz5j0+/1rTtR064hsruOaRVDFVPIG5Rn9RV+b/kYLP/AK9Z&#xd;&#xa;/wD0OGq9/wD8jPpH/XK4/klU9Nsp47C31BZXuJIXdlhKj7mSCq+jYLYPBJIBOKffTWc08GqTyzLY&#xd;&#xa;tEYzLFM8flsG/jKkcZ+Xvz+dS6Q+k3GoNNpzT3LrEUa4ad5VUZB2fMxwTwenamWOrW2m2NvptxvN&#xd;&#xa;9bxLD9nUDfKVGMpzyDjIzjj0rP0L/mWP+vW4/wDZK6fUP+Qfc/8AXJv5GucS8tYZmTWb2W2iEcX2&#xd;&#xa;ULO8QZfLXd9wjPzZ60aS9tJf62yWtzc2xigIjlPmtMvz4I3scg9Rk1Jb6nB9vgj0jVGvUeRVa1Zj&#xd;&#xa;IVUn5n3tluBzjOKv+Ev+RY0//rkP51U0aeS38OQyCATW4lnE6jltplcZA6H3z2zTEm0WeRU8Ppbi&#xd;&#xa;9LDD2qBNi55L4xlenHPJHHcSahBb2esXF9qMs0VrcIirLFO8YQrnIfaR13DHXoencC2N7pOrf2QZ&#xd;&#xa;rl5bUxGVpnlDttfCAsScjdnH+0K0NG1Kzu4Etre4SSaCNRIg6qQMc/jTtS/4/dJ/6+m/9Ey1oUUU&#xd;&#xa;UUVW06ae4sIZbuHyJ3XLx/3T6Vn6iW0/WItSETyQvF5NwwHEKKWbf9Mnn2FNl8RQToF0cf2hPuUM&#xd;&#xa;sfRFyMlvwz+NR2t9aaE91b6lcxwNNcyTxknhlZiRj3HeoNjT6idSUYt7q4t1iz1YLv8Am+h3Aj+l&#xd;&#xa;a15/yF9O/wC2v/oNUL3/AJGC/wD+wUP/AEN6bDrunXOlpZ2twtxdSQiNYY+WJ24PX05J9gaLgR6Z&#xd;&#xa;Z6VbandNBaRW3lySRStGDKoQKNy4PTzOOn5CsXVZrKactYPczQ/2fd/vpJ3kRjsHC7mOMd+nUda7&#xd;&#xa;LUmuF026a0z9pELmLABO/BxwffFczPe6RJYSIl5eXN8YjugivJdxbHzfLvAwOSR6A0ljf2unXWiz&#xd;&#xa;Xs6Qxto6qGboTlDj9DWrDKmr6xaX1kwe1tEkVpezl8cL64285x1HWs+ys5L3wVpYjDN5JjmZUYq7&#xd;&#xa;KrZIUj+I9uRz3FP8/QLorAk93dzFl/0X7XK7ZBB5UvjjGT9K6iuZvbG51iC6OkajNYeXO6eUiiNW&#xd;&#xa;lUkMxZfmIJyf6Vwev+H9W02V57/M6kjdcBiwJPuec1pfD+3ubi9uxa3z2jCMEssavu56fMDXcf2Z&#xd;&#xa;qv8A0ME//gNF/wDE0f2Zqv8A0ME//gNF/wDE0f2Zqv8A0ME//gNF/wDE0f2Zqv8A0ME//gNF/wDE&#xd;&#xa;0f2Zqv8A0ME//gNF/wDE1zPj2zvbfRYXutUku0NwoCNCiAHa3OVAP/6646w0jUNSR3srWSdUOGKj&#xd;&#xa;oa77SvD3iWwtJ4xraq4VVgTJkQYzwd6/KOnT+ldjWN4deO2jm0p5FN1aSO0ir0w7bwR7YcD6g03V&#xd;&#xa;tUhke70uBna6jh819vRVyuQfwbP0q9JJp40kSSCH+z/KBAKjy9mBjj0xisG0t5Xu/DaakhkuEgnZ&#xd;&#xa;vO+Zg42EHnuPWtARRv40eR40Z47BCjFQSpLuDg9uKytXUMviJWAKm6tAQRwR+6rW8SRpHoRht0VJ&#xd;&#xa;+Es1QYKvg4CehwD07VDbRXmp3F5dW9+bErO9uVjgjYsI2IBLMMn+lYtv5d1pku+db2OTXIgZGQYl&#xd;&#xa;B8vOQBiup1u5Nho8kkUaHBSMKRwAzBentnpWH4htLuy0pBcay8sbTRIsBgjQOd4OMqMjABP4Vqv/&#xd;&#xa;AMjjD/2D5P8A0YlTaWU+2agrY+0iXLZ+9sP3Mn0+9j8awNbjSfWQsaK9k1xbRzKB8jTeb824dC20&#xd;&#xa;rn2xXYKoVQqgBQMAAcAVVK2n9qo5x9t8hgvJz5e4Z46dcVboooooooorH8Vf8gGX/rrD/wCjUrYo&#xd;&#xa;ooooorH0D/X6x/2EH/8AQErYoooooooooooooooooorP1L/j90n/AK+m/wDRMtaFFFFFFUdGAGk2&#xd;&#xa;wF4b0bP+Pg5zJ78k1eooooqO4i863lizt3oVzjOMjFFvF5NvFFndsQLnGM4GKkooooooooqtZfat&#xd;&#xa;k32zZu85/L2/888/Ln3xVmoY7S2inknit4kmk+/IqAM31PepqKKKKintoLpVW4gjmVWDKJEDAMOh&#xd;&#xa;Ge9S1Q1z7L/Y919v3/Zdn7zZ1x7VfqC6srW8VVu7aGdVOQJYwwB/GnwQQ20Kw28SRRL91I1CqO/Q&#xd;&#xa;VAul6etz9pWxthPuLeaIV3bj3zjOasNFG0qStGhkQEK5UZUHrg9s4FHlRiYzeWnmldpfaN23rjPp&#xd;&#xa;yaztc0wXumXENvDF5s8kTOSAN4V1Jye/yjFWrbTbGzkMlrZW0DkbS0USqSPTIHtSXGl6fdy+bc2N&#xd;&#xa;tNJjG+SFWOPqRUptLY5zbxcyCU/IOXHRvrwOfapWUMpVgCpGCCOCKpx6RpkW7ytOtE3AA7YFGRkH&#xd;&#xa;09QD+Aqe5tLa8jEd1bxToDuCyoGAPrg/WopdL0+aKOKWxtpI4gRGjQqQgPXAxxUotLYQxwi3iEUR&#xd;&#xa;DIgQbUI5BA7YqaqhJ/tVB9jBHkN/pXGR8w+Tpnnr17VboooooooorH8Vf8gGX/rrD/6NStiiiiii&#xd;&#xa;iue0nUrGzu9Xjur22gc3zMFllVSRsTnBPtWj/bukf9BWx/8AAhP8aP7d0j/oK2P/AIEJ/jR/bukf&#xd;&#xa;9BWx/wDAhP8AGj+3dI/6Ctj/AOBCf40f27pH/QVsf/AhP8aP7d0j/oK2P/gQn+NH9u6R/wBBWx/8&#xd;&#xa;CE/xo/t3SP8AoK2P/gQn+NH9u6R/0FbH/wACE/xo/t3SP+grY/8AgQn+NH9u6R/0FbH/AMCE/wAa&#xd;&#xa;P7d0j/oK2P8A4EJ/jR/bukf9BWx/8CE/xo/t3SP+grY/+BCf40f27pH/AEFbH/wIT/Gj+3dI/wCg&#xd;&#xa;rY/+BCf40f27pH/QVsf/AAIT/Gj+3dI/6Ctj/wCBCf40f27pH/QVsf8AwIT/ABqrcalY3mo6VHa3&#xd;&#xa;ttO4uWYrFKrEDyZOcA+9bVFFFFFZGjXel23h+2eC7VbJF2LJO6qR7E8DNaH221+0R2/2mHzpF3JH&#xd;&#xa;5g3MvPIHUjg/lTBqViYZZhe23lRHbI/mrtQ9ME54p019ZwW6XE11BHBJjZI8gCtkZGCeDxTvtdt9&#xd;&#xa;q+y/aIvtGN3lbxvx6461ENU082xuRfWxgVtplEy7Q3pnOM1J9ttftEdv9ph86RdyR+YNzLzyB1I4&#xd;&#xa;P5UwalYmGWYXtt5UR2yP5q7UPTBOeKeb21BgBuYQbgZh/eD94P8AZ9eo6etAvbUmcC5hJtxmb94P&#xd;&#xa;3Y/2vToevpTJNSsYoI55b22SGT7kjSqFb6HPNSG7thNFCbiLzZRujTeNzjrkDvTft1nsmf7VBtgO&#xd;&#xa;2VvMGIz6N6fjSm9tQYAbmEG4GYf3g/eD/Z9eo6etAvbUmcC5hJtxmb94P3Y/2vToevpTW1CySKKV&#xd;&#xa;7y3WOY4jcyqA59jnmnfbbX7RJb/aYfOjXc8fmDcq8ckdQOR+dVdFigjt53truO6jmuJJt8ZBALNn&#xd;&#xa;bkE9K0aKKKKKKKKrajcyWlhNcQ273Mka5WJM5c+gwD/KmjVNPNsbkX1sYFbaZRMu0N6ZzjNSfbbX&#xd;&#xa;7RHb/aYfOkXckfmDcy88gdSOD+VNXULJ4pZUvLdo4TiRxKpCH3OeKSbUrG3jiknvbaJJhujZ5VUO&#xd;&#xa;OOQSeeo/OpPtdt9q+y/aIvtGN3lbxvx6461GupWL2r3S3ts1uh2tKJVKKeOCc4HUfnUhu7YTRQm4&#xd;&#xa;i82Ubo03jc465A7037dZ7Jn+1QbYDtlbzBiM+jen40pvbUGAG5hBuBmH94P3g/2fXqOnrQL21JnA&#xd;&#xa;uYSbcZm/eD92P9r06Hr6Uw6lYiGKY3tt5Up2xv5q7XPTAOeale5gS4S3eeNZpASkZcBmA64HU0z7&#xd;&#xa;dZ7Jn+1QbYDtlbzBiM+jen40h1CyAgJvLcC4OIf3q/vD/s889R09aX7dZ75k+1QboBulXzBmMere&#xd;&#xa;n4006lYiGKY3tt5Up2xv5q7XPTAOeajEiPrJRL+MtHCQ9mGBYEkEORnI446d6vUUUUUUUUVj+Kv+&#xd;&#xa;QDL/ANdYf/RqVsUUUUUUVA9nbSMWe3hZj1JQEmk+w2f/AD6wf9+xR9hs/wDn1g/79ij7DZ/8+sH/&#xd;&#xa;AH7FH2Gz/wCfWD/v2KPsNn/z6wf9+xR9hs/+fWD/AL9ij7DZ/wDPrB/37FH2Gz/59YP+/Yo+w2f/&#xd;&#xa;AD6wf9+xR9hs/wDn1g/79ij7DZ/8+sH/AH7FH2Gz/wCfWD/v2KPsNn/z6wf9+xR9hs/+fWD/AL9i&#xd;&#xa;j7DZ/wDPrB/37FH2Gz/59YP+/Yo+w2f/AD6wf9+xR9hs/wDn1g/79ij7DZ/8+sH/AH7FOjtLaJw8&#xd;&#xa;dvEjDoyoARU1FFFFFRfZoPK8ryI/LznZsGM/Sl8mLzFk8pN6jCttGQPQGk+zQbGTyI9rnLLsGCfe&#xd;&#xa;leCGSNY3iRkXopUED8KXyo/N83y08zGN+0Zx9aYLW3EZjEEXlk5K7BjPrineTF5iyeUm9RhW2jIH&#xd;&#xa;oDSfZoNjJ5Ee1zll2DBPvS+TF8n7pP3f3PlHy/T0o8mL5/3SfvPv/KPm+vrSNbQOio0EbIv3VKAg&#xd;&#xa;fSneVHvV/LTcgwrbRkD2pPIhw48pMSHLjaPmPv60eTF8n7pP3f3PlHy/T0o8mL5/3SfvPv8Ayj5v&#xd;&#xa;r60ht4CqqYYyqfdBUYX6UvkxeY0nlJvYYZtoyR6E0scccS7YkVF9FGBT6KKKKKKKKKhFrbiMxiCL&#xd;&#xa;yycldgxn1xTvJi8xZPKTeowrbRkD0BpBbwBWUQxhX+8Aow31oe2gkVVeCNlQYUMgIUe1O8qPzfN8&#xd;&#xa;tPMxjftGcfWmi2gERiEEYjY5KBBgn6U7yo96v5abkGFbaMge1J5EOHHlJiQ5cbR8x9/WjyYvk/dJ&#xd;&#xa;+7+58o+X6elHkxfP+6T959/5R8319aT7NBsVPIj2ocquwYB9qcY42kWQopdfusRyPxpPIhw48pMS&#xd;&#xa;HLjaPmPv60n2eD5P3Mf7v7nyj5fp6UvkQ5c+UmZBhztHzD39aT7NBsVPIj2ocquwYB9qcIoxKZRG&#xd;&#xa;gkYYLhRkj60+iiiiiiiisfxV/wAgGX/rrD/6NStiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisbxaGPh6cI21jJDg4zg+alL9h&#xd;&#xa;1z/oNQf+AI/+Lo+w65/0GoP/AABH/wAXR9h1z/oNQf8AgCP/AIuj7Drn/Qag/wDAEf8AxdH2HXP+&#xd;&#xa;g1B/4Aj/AOLo+w65/wBBqD/wBH/xdH2HXP8AoNQf+AI/+Lo+w65/0GoP/AEf/F0fYdc/6DUH/gCP&#xd;&#xa;/i6PsOuf9BqD/wAAR/8AF0fYdc/6DUH/AIAj/wCLo+w65/0GoP8AwBH/AMXR9h1z/oNQf+AI/wDi&#xd;&#xa;6PsOuf8AQag/8AR/8XR9h1z/AKDUH/gCP/i6PsOuf9BqD/wBH/xdVLD+3L17xf7WgT7NcGH/AI8w&#xd;&#xa;d2FU5+9x96rf2HXP+g1B/wCAI/8Ai6PsOuf9BqD/AMAR/wDF0fYdc/6DUH/gCP8A4uj7Drn/AEGo&#xd;&#xa;P/AEf/F0fYdc/wCg1B/4Aj/4uj7Drn/Qag/8AR/8XR9h1z/oNQf+AI/+Lo+w65/0GoP/AABH/wAX&#xd;&#xa;R9h1z/oNQf8AgCP/AIuj7Drn/Qag/wDAEf8AxdH2HXP+g1B/4Aj/AOLo+w65/wBBqD/wBH/xdH2H&#xd;&#xa;XP8AoNQf+AI/+Lo+w65/0GoP/AEf/F0fYdc/6DUH/gCP/i6PsOuf9BqD/wAAR/8AF0fYdc/6DUH/&#xd;&#xa;AIAj/wCLo+w65/0GoP8AwBH/AMXR9h1z/oNQf+AI/wDi6PsOuf8AQag/8AR/8XR9h1z/AKDUH/gC&#xd;&#xa;P/i6PsOuf9BqD/wBH/xdH2HXP+g1B/4Aj/4uj7Drn/Qag/8AAEf/ABdH2HXP+g1B/wCAI/8Ai6l0&#xd;&#xa;G6ubq0n+1yLJLDcyQ71TaGCtjOO1adFFFFFFFFFFFFFFFFFFFFFFFU1vs6w+n+X923WbzN3XLFcY&#xd;&#xa;/CjVb7+zbBrry/M2ui7d2PvOF6/jmnm9jGpLYbX81oTMDgbdoIH58iqutXt1Y6He3SLGk0Skx4O4&#xd;&#xa;EZ4JyBz7fqa0JDIAvlIjHcN25iuF7kcHJ9v1FQ3F7Hb3drbOrl7pmVCAMAqpY5/AVMhkMjh0QICN&#xd;&#xa;hDEkjHORjjn3NPooooooooooooorH8Vf8gGX/rrD/wCjUrYooooooooooooooorH0D/X6x/2EH/9&#xd;&#xa;AStiiiiiiiiiiiiiiiiiiiiiiiiisfw5/qL/AP7CFx/6Ga2KKKKKKKKKKKKKKKKKKKKjnnhtoWmu&#xd;&#xa;JUiiX7zyMFUduprMOszTkpp+m3EzjnM6mGMr6hyCD249OaT7drn/AEBYP/A4f/EVcsJ76bzPt1kl&#xd;&#xa;rjGzZP5m7rnsMdvzqmn/ACOM3/YPj/8ARj0eKv8AkAy/9dYf/RqVSvdI0+88YL9ptY5fMsmkfcOr&#xd;&#xa;B0UH8uKpPEkHgvXIYlCRx3E6qo6AB8AVteI/9RYf9hC3/wDQxVXX9Ns7zXtH+026S+Y0kb7u6iNm&#xd;&#xa;A/Pmk0qGLTbrX47ONYo4WRkQDgHygf51Rtbe+voLfUJNFimupY1kW6+27XGRnIG35evTtWle2GoX&#xd;&#xa;unWZvIYbuWNT59oW2JIxxg7ucYx6d6n0JdOTzEsIJbPu1tKhjP8Av7Tzz0z7e1Xb+a8hRDZWiXLE&#xd;&#xa;/MGm8vA/I5ql9u1z/oCwf+Bw/wDiKcmtNCwj1KymtW/ikALwqPUyYAFacMsc8SywyJJGwyrowII9&#xd;&#xa;iKfRRRRRRWP4q/5AMv8A11h/9GpWxRRRRRRRRRRRRRRRWPoH+v1j/sIP/wCgJWxRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRWP4c/1F//ANhC4/8AQzWxRRRRRRRRRRRRRRRRRRVa8u1tVT5GklkbbHGnVj/Qep7V&#xd;&#xa;XtdPka6W9vpTJcDJSMH93Fxj5R1zjryec1o0UVUv7CO+RNzyRSxnMc0RAdD0OMgjkcdOhqC00dLe&#xd;&#xa;5Sea8urt48+X9oZTsJGCRgDscVJf6al66SrPNbTqNomgIDbe68g8ZwfwFQLoNuNIuNNae4eO4Zmk&#xd;&#xa;kZhvJY5JzjHX2q5e2Ud8kKys4EUyTLtI5ZTkZ9qbf2Ed8ibnkiljOY5oiA6HocZBHI46dDUemaWm&#xd;&#xa;nPcOLi4uJLhgzvOwJJAwOgHYVDNoitM8lvf3tosjF2jgdQpY8k8qeTUs+j20kEEUDSWhtwVieAgM&#xd;&#xa;gPUDIPBwKdYaalk7ytPNczsNpmnILbey8AcZyfxNXqKKzZtPlguWu9PkKuzbpLdj+7lPc+u4gAA5&#xd;&#xa;xwOKt2l1HdxF4zgqdroeqN3BHY/41PWZ4juZ7TRpZbWXypt8aq+0NjdIqng8dCai/szVf+hgn/8A&#xd;&#xa;AaL/AOJo/szVf+hgn/8AAaL/AOJo/szVf+hgn/8AAaL/AOJo/szVf+hgn/8AAaL/AOJqG70K/vID&#xd;&#xa;Bca7O8ZKsV+zxDkEEdB6gVN/Zmq/9DBP/wCA0X/xNH9mar/0ME//AIDRf/E0f2Zqv/QwT/8AgNF/&#xd;&#xa;8TR/Zmq/9DBP/wCA0X/xNH9mar/0ME//AIDRf/E1HZtf23iFbO51F7uF7RpcNEiYYOo/hA7E1uUU&#xd;&#xa;Vxk/xEtIZ5IjYTEoxXO8c4NR/wDCyLP/AKB8/wD32KP+FkWf/QPn/wC+xR/wsiz/AOgfP/32KP8A&#xd;&#xa;hZFn/wBA+f8A77FH/CyLP/oHz/8AfYo/4WRZ/wDQPn/77FUtO8d21nJes1lM32m5Mwww4BVRj/x2&#xd;&#xa;rv8Awsiz/wCgfP8A99ij/hZFn/0D5/8AvsUf8LIs/wDoHz/99ij/AIWRZ/8AQPn/AO+xR/wsiz/6&#xd;&#xa;B8//AH2KP+FkWf8A0D5/++xW/wCHfEEWvwTSxQPCImCkMQc8VsUUVm3eu6fZ3L288kokTGQtvIw5&#xd;&#xa;GeoUjvSW+v6ddTpBDJMZHOFBt5FH5lcCrd7eQWMBnuGZYwQMqjOfyAJrP/4SfSv+e0//AICy/wDx&#xd;&#xa;Navmp5Pm5Ozbuzg5x16dayv+En0r/ntP/wCAsv8A8TWhZ3kF9AJ7dmaMkjLIyH8iAaqXGv6dazvB&#xd;&#xa;NJMJEOGAt5GH5hcGltNd0+8uUt4JJTI+cBreRRwM9SoHap7/AFG205Ee6Z1VzgbY2f8A9BBql/wk&#xd;&#xa;+lf89p//AAFl/wDia07ieO1geeYkRoMsQpY/kOTWZ/wk+lf89p//AAFl/wDia0rS6ivLZLiAsY3z&#xd;&#xa;gshU8HHQgHtWe/iTS0dkaWbcpwf9FlP/ALLVfwrcxzxX6pvB+2Sy/PGy5V2JU8gdq0r/AFO003y/&#xd;&#xa;tTuvmZ27InfpjP3QcdarQ+ItMnmSKOWYvIwVQbaUDJ4HJXAq/d3UVnbPcTlhGmMlULHk46AE96zf&#xd;&#xa;+En0r/ntP/4Cy/8AxNasMqTwpLGSUkUMpIIODyODyKyv+En0r/ntP/4Cy/8AxNX7G+t9QhMtqzsg&#xd;&#xa;baS0bIc8HowB71Wu9d0+zuXt55JRImMhbeRhyM9QpHekt9f066nSCGSYyOcKDbyKPzK4FW728gsY&#xd;&#xa;DPcMyxggZVGc/kATWf8A8JPpX/Paf/wFl/8Aia1fNTyfNydm3dnBzjr061lf8JPpX/Paf/wFl/8A&#xd;&#xa;ia0LO8gvoBPbszRkkZZGQ/kQDUKatZSaibBZW+0jPyGNgDjrgkYPX1q9RRRWTZu2o6rNdZ/0e1Jh&#xd;&#xa;iX1fqXB7gggfhWtRRRRRRRRRRRRRRRRRWQQdN1tAgxbX7Hco/hmwSXJPqAqgeta9Y/ir/kAy/wDX&#xd;&#xa;WH/0albFFZujyGKzkt552ka1co0krZZlHRmz/nisey1e8KKqNCt1cr9rdL2UokSt8oRTyeqk4x3q&#xd;&#xa;3Hr80rCxjjgfUjJ5YKuTATt3/e+993268dOararea2JdPjWGGGT7WqORKwjlJViADjJXHXI6joet&#xd;&#xa;aE1/qMP2a0aG1OoXG9lAdvKCrjOTjOfmHaoLnW72wjKXdrFJcrLCClsxYMkjFRjOPmyrcdOnPprW&#xd;&#xa;L3bwlr2OKNy2UWNicLxjOR161ZrHf/kcYf8AsHyf+jErYoorzPwbaW154t1CO6t4p0EcjBZUDAHz&#xd;&#xa;F5wfrXef2FpH/QKsf/AdP8KP7C0j/oFWP/gOn+FH9haR/wBAqx/8B0/wo/sLSP8AoFWP/gOn+FH9&#xd;&#xa;haR/0CrH/wAB0/wo/sLSP+gVY/8AgOn+FH9haR/0CrH/AMB0/wAKP7C0j/oFWP8A4Dp/hR/YWkf9&#xd;&#xa;Aqx/8B0/wo/sLSP+gVY/+A6f4Uf2FpH/AECrH/wHT/Cj+wtI/wCgVY/+A6f4VBfaJpK2Nwy6XZBh&#xd;&#xa;ExBFumQcfSuf+GH/ACD77/rqv8q7eiormUw20soGSiFseuBRbSma2ilIwXQNj0yKlooooooooooo&#xd;&#xa;ooooooooooooooooorJvkY+JdKYKSqxXGTjgcJWtRRRWP4S/5FjT/wDrkP51sViRX+rX6G402Cy+&#xd;&#xa;yszKn2iR1fKkqcgAjqDjnpin7/Ef/PDSv+/0n/xNG/xH/wA8NK/7/Sf/ABNG/wAR/wDPDSv+/wBJ&#xd;&#xa;/wDE0b/Ef/PDSv8Av9J/8TRv8R/88NK/7/Sf/E0b/Ef/ADw0r/v9J/8AE0b/ABH/AM8NK/7/AEn/&#xd;&#xa;AMTRv8R/88NK/wC/0n/xNG/xH/zw0r/v9J/8TRv8R/8APDSv+/0n/wATRv8AEf8Azw0r/v8ASf8A&#xd;&#xa;xNG/xH/zw0r/AL/Sf/E0b/Ef/PDSv+/0n/xNG/xH/wA8NK/7/Sf/ABNCX+o2lzAuqQ2ojuJBDGbZ&#xd;&#xa;2YhyCRncBxgH9K2Kz9b407efuxTQyuf7qrKrMfwAJ/CryOsiK6HKsMg+orJ8Vf8AIBl/66w/+jUr&#xd;&#xa;YorB1jTLyW+DWITyL0CK/wB55MY4G30OGf8ASl1fSml1MX66fbajmEQ+TOQoTDE7gSD1zjGKhTSb&#xd;&#xa;mIwX8FlaQTQSF1soQqKcqUOZAOeDuzt9verFzaajeQQ3MyxrPBcCeO1DZAwrLtMnvnOccdMd6LiL&#xd;&#xa;UZpbTUfsca3VsJE+zefkMH2878cY29Md6hn0/UL+ZLue3jt5RPbZiEu8BI3Zi27A5O8jGO3vXQ0V&#xd;&#xa;jv8A8jjD/wBg+T/0YlbFFFec+A/+Rx1H/rlJ/wCjFr0asKfUrqG7E+9Dam7Wz8jbzkkDfu/Hpj8a&#xd;&#xa;1bq9trML9pmWPcGI3dwoLH8gCar2+uaZdAeRexSZJAwe4G4/oCalsNSs9SR3srhJ1Q4Yr2NRWeua&#xd;&#xa;ZfziC0vYppSCdqnnFW4biKcyCJw5ify3x/C2AcfqKo3eosmr2FrC6lZJXjmGOQRFvA/UH8a0Jm2w&#xd;&#xa;u28JhSdxGQvvVdLuKLTI7ue5R4hErtOBtVhgfNjsDUdtrWnXcM81vdxyR267pWU8IOTk/kfyqtov&#xd;&#xa;iKx1iKERyol06bmgDbiv44FaGof8g+5/65N/I1yHww/5B99/11X+VdvRVfUP+Qfc/wDXJv5GjT/+&#xd;&#xa;Qfbf9cl/kKsVhabqV09zZfaHSSPUoWniVV2mAAA7Sf4/vgZ46dOabZ6vb2T6k2o3nloL944zIxIA&#xd;&#xa;CIcD0HJrc81PJ87cPL27t3bHXNUrTXNMvndLW9ilZEMjBT0UdT+tVNM8UadqMrQrPGkxmaONN2TI&#xd;&#xa;AeGHHcc1ZXX9KaaGFb6IyTbfLXPLZ4GKffa1p2nTCG9u44ZGXcFY8kcjP6Grnmp5Pnbh5e3du7Y6&#xd;&#xa;5rPh8Q6ROJDFfwuIk8x8H7q5Az+oqrb+LNKmsBcNcIJBCJZIVO5k4GR74zUv2bXJ/wB7/aEFpu58&#xd;&#xa;j7OJdntu3DP1wKufbPsmnfadTKW+ziRt2VHOAfx447Zqa0uoL22S4tZVlhfO116HBwf1FVb3XNMs&#xd;&#xa;JzBd3sUMoAO1jzip4b+1n8jyp0b7QpaLH8YGMkfmKkkuIopooncLJMSI1PViBk/oKgvNUsbGaOG7&#xd;&#xa;uUikl+4rdW7U+5v7W0ZluJ0jKxmUg9lBAJ/MimWGqWOp+Z9huUn8vG/Z2znH8jWfp/irTL24kg+0&#xd;&#xa;RI/n+VCN2fNGBgjjjJOPwrWtH8y2R/OWbOfnVcA8+lVbfXNMurwWkF7FJcEkCMHnI5P8jWV/aN1b&#xd;&#xa;eHtYu0lLzQXU4jMh3YAfAHPYeldLVazl817kfaEm2TFcKuPL4Hyn1POc+9QW+uaZdXgtIL2KS4JI&#xd;&#xa;EYPORyf5Gq154l0+x1g2FzNHHti3vIzfdbIwuMdwc/hWtDKk8KTRMHjkUMrDoQeQafRRRWV4nlkg&#xd;&#xa;8O30sMjxyLESroxBB9iK0oYo4IlihjSONRhURQAB7AU+sfwr/wAgGL/rrN/6NetiiiopLiKKaKJ3&#xd;&#xa;CyTEiNT1YgZP6CiO4ilmliRw0kJAkUdVJGR+hqWiiiiiiiisfX/9fo//AGEE/wDQHrYrP1//AJF/&#xd;&#xa;Uv8Ar1l/9ANWNP8A+Qfbf9cl/kKz/FX/ACAZf+usP/o1K12YKpZiAoGSSeAKx5Naki0i+1NrcGKB&#xd;&#xa;m8pMkeagOA4buG6jA/Otmqlvqmn3cvlW19bTSYzsjmVjj6A0k+radbTNDcahaxSr95JJlVh36E0s&#xd;&#xa;2qafbrG099bRLKu5C8ygOvqMnkVJJe2sNstzLcwpAwBWVpAFIPTB6c0sd3bS+V5dxE/nAtHtcHeB&#xd;&#xa;1I9cZqK7uitlcy2eyeW3BJjX5iWAyU46MRx7ZBwelS2lwl3axzxlSHGflbOD3GfY5H4Vmv8A8jjD&#xd;&#xa;/wBg+T/0YlbFFFec+A/+Rx1H/rlJ/wCjFrt9avZLDTJZrdUe5xiGNgT5j/3QByTjPA9KyIrfVYtE&#xd;&#xa;OlLo6GAwtDuN+N20gjrsxnn0qMMt7P4dS5RPMimkWSMHPlukZIB9xhTV7XbeK61jRIp0EkZmkJU9&#xd;&#xa;MiMkfqBVnXZQLaC1MUcgvZhb/vASq5BOSARn7vTI+tVNQN5FdafHd3tm++5UrGkBjdsdSMuemRnj&#xd;&#xa;vUs1zBpGqXLS5SG4gNwAozlk3GRj77TH+VZ9vFKl5oUlwd089xPK7ZyWBjbbn/gAUfhXQ6h/yD7n&#xd;&#xa;/rk38jWRa20dx4d0PdcJBLGkLwF8ENJ5eACMjPBPAIPFWYp3/taCDUbeIXIV/s08ZOHHG/5f4f4e&#xd;&#xa;Mmm+Ev8AkWNP/wCuQ/nWhqH/ACD7n/rk38jXIfDD/kH33/XVf5V29FIzBVLMQFAySTwBQrBlDKQV&#xd;&#xa;IyCDwRWJ4peWayj062iE8l04SSIPtYR4OWBwcDIUZII596ravJrVzZbjoyBrdxcJsu95LJyBt2Zb&#xd;&#xa;kdBgn1FTeGltZrvV72Dy5GkvGQSochlCoQMjtkmhba1uNO1G3adYbH7WphkDDYMeW3BPBHmbgffI&#xd;&#xa;61NLcTR3lrDqttDIhmAt7mMkbpcEj5OSvG4Z3Hp78L4c/wBRf/8AYQuP/QzTPB0SReGLHy1C703N&#xd;&#xa;juSetFobs20t9BcWNpDKzSuJLdmxjglm8wDovXArJ0w79I0ZZ2VrJ7mc3DdIz87lCT2+fbjnriup&#xd;&#xa;ultWaD7T5e4Sgw7zj58HGPU4zVPSJhb+F7CUpI4S0iO2NSzH5B0A61Xj0yGKAXVjq88Nqg3xqsiG&#xd;&#xa;3UDnnjlfX5h35FUobi+1HWbWZvKtP9HJhFxEzqX3upKfMvJQA9+CPrV5bW5t766ne+ge4ltmPkQQ&#xd;&#xa;lGdhgB8F2JxgD8am0SW3g0KGaWSONtge6ZmA2ykDfu9DuzkHvWLoX/Msf9etx/7JWpqksZ8SaJD5&#xd;&#xa;ieaHlYpuG7b5TDOPTg1V0aDUJ7e5JubRJ5JHE6TWzNJjJC7sSD+HGOBxj60yzsYl8RWMMskVz9mt&#xd;&#xa;JTG6LhUIlAAAycbQSvU9K0L/AP5GfSP+uVx/JKNA/wBfrH/YQf8A9ASoUu/sXhRZvKEvPl7ScA7p&#xd;&#xa;Nv8A7NVbxEl7b6MEuLyzMRlhRY0t2RmxIpABMh7DPQ8A1Xuf+RR1/wD6+rj/ANGV19YFhFDPa+IY&#xd;&#xa;bmTy4JLqVZHyBtUxoCcngcUtzLJZ2scV/DBd6Z8n79CVK8gINmTu528gjr045mf/AJHGH/sHyf8A&#xd;&#xa;oxK2Kx7/AP5GfSP+uVx/JK2KKKx/Fv8AyLGof9cj/Otiisfwr/yAYv8ArrN/6Nem3KDVtYmsZndL&#xd;&#xa;a0jUyRqRtuN/QNxwBtP1z2xy4eH7e2lik0uRrDbIrSpEMrMoP3W/UA+56059UvJ2LaXp6XduOPOa&#xd;&#xa;48sMf9n5TuHTkH19Kqz3iXms6IQCkiTSiSJuGQ+U3BHX3HqMGrGlf8h7XP8ArrF/6KWlbV7lmM1v&#xd;&#xa;pzzWKn/XK53sPVE2/MD2IPIqa51M4jXTYkvpZF3gJJhAvqWAIGeceuD6VBNqGo/2fd79O8m7jjLo&#xd;&#xa;ol3IV6Z37cZHJxjsPWoLO/vpZdMXUNMjRZG/dzi53kN5THO3aOoDDr3rTv777Ntihj8+6k+5CGwS&#xd;&#xa;P7x64XtnGMketULjXLmwtZ5tTsFttsbPFtn3q5AztLbRtJ4A6559KWTV7+ONrptK22KAu0kk22RU&#xd;&#xa;HJPllc5xnjNWLrUpw0SafaLdSSR+aVeXywFPQ5wfyqewuprhHFzatbTRnDLncvPI2tgbuMfQ8VS1&#xd;&#xa;/wD1+j/9hBP/AEB62Kz9f/5F/Uv+vWX/ANANWNP/AOQfbf8AXJf5Cs/xV/yAZf8ArrD/AOjUrQvw&#xd;&#xa;TYXIAyTE3H4GufvSP+Fc7c8rYxqw9CFGQfetPWb2BtFv1huYzKbeQIEkG4ttOMY71kvDcPcWnmXe&#xd;&#xa;koq3Mbf6HC29sMPl4J4PfPFLaS2UPhmZ74Rm4BmB3puk5dgvGM9Mfh7VFYXM9xp9nBENOiFvawqW&#xd;&#xa;voy2/MatleRxzj61FpTFr20+2PE8InvQ5H+qyGXGM8AdcVqX4thAl9pwCizuQ08iggLH8plxnqNo&#xd;&#xa;H3c5xxzWho8Yg00TSAI8xM0rE/eJ/iP4AVB4XUroUQYEHzZjyOxlakf/AJHGH/sHyf8AoxK2KKK8&#xd;&#xa;58B/8jjqP/XKT/0YtegzW8U5jMqBzE/mJn+FsEZ/U1LVZbC1WcTLAgkEhlDd9xXaT+XFSSW8Us0U&#xd;&#xa;roGkhJMbHqpIwf0NFxbxXMZjmQOvoarxaVYwsGS3XcrBgSSSCPTPSodUs5b29sYzGDaoxklkBG4F&#xd;&#xa;SpVef4W5yMdu1WrqwtbwRi4hV/KOU6jbxjjFRR6TYxPuSDBwR94ngjB7+hqZrK2a0S1MK+SihVT+&#xd;&#xa;6AMDH4U220+1tGLQQhWPfJJ/WiHT7WCczxQhJD3BOPy6U7UP+Qfc/wDXJv5GuQ+GH/IPvv8Arqv8&#xd;&#xa;q7eiq+of8g+5/wCuTfyNGn/8g+2/65L/ACFPNvEbkXJQecEMYfvtJBI/MCpazIvD+lQrtis0jUnO&#xd;&#xa;FYgZ/Or32aH7P5HlJ5WMbMcVBb6ZZ20gkigAcdCSTj86cdPtftIufJAlBzuBI59cdKlt7eK1gSCB&#xd;&#xa;BHEgwqjoBVdtJsWl8026lic9TjP06VLHZW0Vr9ljgRYOf3eOOTk/qc1Hb6ZZ20gkigAcdCSTj86d&#xd;&#xa;Dp1pbzmaGEJIc8gnHPt0qM6RYGTzPsy7s5xk4/LpVi4tYLmIRzRKyDoOmPp6Uy1sba0JMEQQnqck&#xd;&#xa;n8zTX0yykn857dC5OT6E+46GqWj6UF8P2VpqEA82GPBXPKn6g1ch0uxgljljt0EkZJRzkkEjB5Pt&#xd;&#xa;S3Om2l1J5k0IZ/UEgn8qfFZW0MiSRwqrpGY1YdQpOSPzGae9vE88c7oDLEGCN3UHGf5CopNPtZLl&#xd;&#xa;bhoR5qkEMCRyO/HWpBbQC3+z+Uvk/wBzHHXNVf7F07BBtVYcfeJPQgjqfUVO1hatbTW7QIYZmZpE&#xd;&#xa;7MSckn8ag/sXT/8An3/8fb/GrUdtBEJgkSgTMXkGPvEgAk/gBUEek2McokW3XcDkZJI/I8VLdWVv&#xd;&#xa;dgC4iD46HofzFTRosUaxoMKoCgegFQTWUc1/bXjM4kt1dVAIwQ2M5/75FWaKKx/Fv/Isah/1yP8A&#xd;&#xa;Otiisfwr/wAgGL/rrN/6Nei736Zqr36wvLb3EYW6cEHytn3CF6nO5sgA9undDrUl7LCmj27XC+ao&#xd;&#xa;uHkQxiJCeThtpJxnpnpzUGnX0GgWEOm6j5iSQLtVkieQSL/eG0HHORg88VWS1nPiSy1B4mRbq4d9&#xd;&#xa;h5KAQFQSR64B/HFaeloy65rTFSFaWLaSOD+6Wsq3XSNNt4rPUoJUuIUCEqkjhwBjeCuQM4zjqKux&#xd;&#xa;OujyJdS2b21rJbpEUT5zAVZyAQuSc7+3THNW0v11W2uVs4pHi8plErKUy5H3cNg9CDnpzVCHUbe6&#xd;&#xa;utHtITKZoJT5gMLqFxDIp5Ix1I71c1BGs9Vi1VlLwJA0EgUZKAsG346kfLjA55rJ8S3CeIdEuINO&#xd;&#xa;WR1hUzSO0bJt2gkKAwBJOD0zjHNbuuqW0HUVUEsbWUAAck7TVG7lsobKzGoxSqvkqEmRGYq2BxhQ&#xd;&#xa;T788VY0KaaWGXMkk1orD7PPMMSSD+LcOOjZA4HAHXrTNf/1+j/8AYQT/ANAetis/X/8AkX9S/wCv&#xd;&#xa;WX/0A1Y0/wD5B9t/1yX+QrP8Vf8AIBl/66w/+jUrYqpb2ENv9oVRmKeQyNGwyNx5Y8+p5qRbK1Vg&#xd;&#xa;y20IYHIIjGQaWO1t4m3RQRI3qqAGs+80ee5vXnW/MSPgGMW8ZOMYI3Ebuee/erqWFokEUIt4zHCg&#xd;&#xa;SMMu7aoGAMmpPs0HleV5Efl5zs2DGfpUV5ZLc2ZtQ3lQt8rqqjDJ/EvtkcZHNLc2aT2Bs8lIWUIw&#xd;&#xa;HOU7r+IyM9efWp40WKNY0GFUBQPQCsl/+Rxh/wCwfJ/6MStiiivNvBEscPi/UGlkSNTFIMswAz5i&#xd;&#xa;16D9us/+fqD/AL+Cj7dZ/wDP1B/38FH26z/5+oP+/go+3Wf/AD9Qf9/BR9us/wDn6g/7+Cj7dZ/8&#xd;&#xa;/UH/AH8FH26z/wCfqD/v4KPt1n/z9Qf9/BR9us/+fqD/AL+Cj7dZ/wDP1B/38FH26z/5+oP+/go+&#xd;&#xa;3Wf/AD9Qf9/BVe/vbQ2FyBdQkmJuPMHoa5j4Yf8AIPvv+uq/yrt6KjniE0EkROA6lc+mRRBEIYI4&#xd;&#xa;gchFC59cCpKKKKKKKKKKKKKKKKKKKKKKKKKKKKKo3F80OrWVmEBW4SVi2eRt2/8AxVXqKKx/Fv8A&#xd;&#xa;yLGof9cj/Otiisfwr/yAYv8ArrN/6NetiiiiiiiiiiiiiisfX/8AX6P/ANhBP/QHrYrP1/8A5F/U&#xd;&#xa;v+vWX/0A1Y0//kH23/XJf5Ck1Cyh1Gze1n3iNyCSjbSCCCMH6gVQ/wCEfi/6COq/+Br/AONH/CPx&#xd;&#xa;f9BHVf8AwNf/ABo/4R+L/oI6r/4Gv/jR/wAI/F/0EdV/8DX/AMaZNocMMLytqOrFUUscXr5wPxrP&#xd;&#xa;0Ozh1OKXOoasHQhubxwNjjeg69QjKD7569a0/wDhH4v+gjqv/ga/+NH/AAj8X/QR1X/wNf8Axo/4&#xd;&#xa;R+L/AKCOq/8Aga/+NH/CPxf9BHVf/A1/8amsdFgsrw3az3U03lmPM87SYUkHjPuBWlRRXH3nw9sb&#xd;&#xa;m7lmS7miEjbtmAcHvz9ag/4VvZ/9BCf/AL4FH/Ct7P8A6CE//fAo/wCFb2f/AEEJ/wDvgUf8K3s/&#xd;&#xa;+ghP/wB8Cj/hW9n/ANBCf/vgUf8ACt7P/oIT/wDfAo/4VvZ/9BCf/vgUf8K3s/8AoIT/APfAo/4V&#xd;&#xa;vZ/9BCf/AL4FH/Ct7P8A6CE//fAo/wCFb2f/AEEJ/wDvgUf8K3s/+ghP/wB8Cj/hW9n/ANBCf/vg&#xd;&#xa;V0Xh/QrfQbR4YHeQu253bue3HbitWimuu9GXJG4YyDgisn/hH4v+gjqv/ga/+NXbCxWxR1W4uZtx&#xd;&#xa;zmeYyEfTPSor3SUvJzK15fREgDbDcsi/kKLPSUs5xKt5fSkAjbNcs6/kalv7Fb5EVri5h2nOYJjG&#xd;&#xa;T9cdaqJoMaOrf2hqZ2nODeOQf1rRuIRcQPEXkQOMbo2KsPoR0rM/4R+L/oI6r/4Gv/jV+xs1sYTE&#xd;&#xa;s1xMC27dPKZGHTjJ7cVWu9Hjurl5mvdQiLY+SK6ZFGBjgA8U+x0tLGYyrd3sxK7ds9w0ijpzg9+K&#xd;&#xa;ff6et/5e65uodmf+PeZo85x1x16VWh0OOGZJRf6kxRg217t2U47EZ5FX7u3F1bPC0ksQbHzxOUYY&#xd;&#xa;OeCOlZU2hwwwvK2o6sVRSxxevnA/Gq/hWa8Ek0V3M8lvOi3NkZWLOY25IJPcBkB+taFxosdxO8pv&#xd;&#xa;tRQuc7Y7p1UfQA8VLYaali7st1eTbhjE87SAfTPSi/01L50Zrq8h2jGIJ2jB+uOtRW+ix286Si+1&#xd;&#xa;FyhztkunZT9QTzVu9tVvIDE0s0QJB3QyFG/MVn/8I/F/0EdV/wDA1/8AGtZF2Iq5J2jGSck1lvoM&#xd;&#xa;buzf2hqY3HOBeOAP1q3YWK2KOq3FzNuOczzGQj6Z6VFe6Sl5OZWvL6IkAbYblkX8hRZ6SlnOJVvL&#xd;&#xa;6UgEbZrlnX8jUt/YrfIitcXMO05zBMYyfrjrVRNBjR1b+0NTO05wbxyD+taNxCLiB4i8iBxjdGxV&#xd;&#xa;h9COlVbLSYLOUy+bcXEmMK9zKZCg77Seme+OuB6VfoorH8W/8ixqH/XI/wA62KK5bQNf0qy0pbe6&#xd;&#xa;voopkll3Ix5GZGI/Q1o/8JTof/QSg/M0f8JTof8A0EoPzNH/AAlOh/8AQSg/M0f8JTof/QSg/M0f&#xd;&#xa;8JTof/QSg/M0f8JTof8A0EoPzNH/AAlOh/8AQSg/M0f8JTof/QSg/M0f8JTof/QSg/M0f8JTof8A&#xd;&#xa;0EoPzNH/AAlOh/8AQSg/M0f8JTof/QSg/M0f8JTof/QSg/M0f8JTof8A0EoPzNUdR1rTtRvdJhsr&#xd;&#xa;uOaRb5WKqeQNjjP6iumrP1//AJF/Uv8Ar1l/9ANWNP8A+Qfbf9cl/kKsUUUUVk+IJHe2isYHZbm7&#xd;&#xa;kCx4OAQpDOCf90N9elRyxppuu2sqIsNrcRfZgkYwGl4K5A9FQjPbpW1RRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRWZr/myWKWtuxWe5lREwcZwd7An02q316VHquNPl064gVYoopPIkOMJFCwy&#xd;&#xa;c9lGUQZ7fjWvRRRRRRRRRRRRRRRRRWP4t/5FjUP+uR/nWxRRRRRRRRRRRRRRRRRRWfr/APyL+pf9&#xd;&#xa;esv/AKAasaf/AMg+2/65L/IVYoooorBv75YdeRpbG+mS3j+R4rZnUOepBA/unFQ32sQ6jbKLaw1B&#xd;&#xa;pUlBic2j4RwdpOccY+YH8a6Siiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiisq+ivf7Xt7iKA&#xd;&#xa;XFvFE2IzIF2yHgNz/slh+NVJrmfXdOu7X+zpBEXeCQrOoIKnBxkeorYsWums4jfLGlyV/eLH90H2&#xd;&#xa;qxRRRRRRRRRRRRRRRRWP4t/5FjUP+uR/nWxRWMviS2kBMVnqMqBiu+O0dlJBwcEe4pf+Egi/6B2q&#xd;&#xa;/wDgE/8AhR/wkEX/AEDtV/8AAJ/8KP8AhIIv+gdqv/gE/wDhR/wkEX/QO1X/AMAn/wAKP+Egi/6B&#xd;&#xa;2q/+AT/4Uf8ACQRf9A7Vf/AJ/wDCj/hIIv8AoHar/wCAT/4Uf8JBF/0DtV/8An/wo/4SCL/oHar/&#xd;&#xa;AOAT/wCFH/CQRf8AQO1X/wAAn/wo/wCEgi/6B2q/+AT/AOFH/CQRf9A7Vf8AwCf/AAo/4SCL/oHa&#xd;&#xa;r/4BP/hR/wAJBF/0DtV/8An/AMKdH4gt3uIYXtb6Fpn2I01syKWxnGT9DWtWfr//ACL+pf8AXrL/&#xd;&#xa;AOgGrGn/APIPtv8Arkv8hViiiiiis/RP+PKT/r6uf/Rz1oUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUVj+HP9Rf8A/YQuP/QzWxRRRRRRRRRRRRRRRRRWP4t/5FjUP+uR/nWxRWP4V/5AMX/X&#xd;&#xa;Wb/0a9bFFFFFFFFFFFFFFY+v/wCv0f8A7CCf+gPWxWfr/wDyL+pf9esv/oBqxp//ACD7b/rkv8hU&#xd;&#xa;Gt30mnaXJcwojyKyKquSASzhecfWq2/xH/zw0r/v9J/8TRv8R/8APDSv+/0n/wATRv8AEf8Azw0r&#xd;&#xa;/v8ASf8AxNG/xH/zw0r/AL/Sf/E0b/Ef/PDSv+/0n/xNQWcPiG0haNYtLYNLJJkzSdXctj7v+1Uz&#xd;&#xa;zeIY1LPFpKqOpM8gA/8AHaXf4j/54aV/3+k/+Jo3+I/+eGlf9/pP/iaN/iP/AJ4aV/3+k/8AiaLK&#xd;&#xa;/wBR/tgWGoQ2q7rdplaB2boyjByB61sUUUUUUUUUUUUUUUUUUUUUUUUUUUVj/wDCU6H/ANBKD8zR&#xd;&#xa;/wAJTof/AEEoPzNH/CU6H/0EoPzNH/CU6H/0EoPzNH/CU6H/ANBKD8zR/wAJTof/AEEoPzNH/CU6&#xd;&#xa;H/0EoPzNH/CU6H/0EoPzNZmheIdIt4rwTX8KF72aRcnqpckGtP8A4SnQ/wDoJQfmaP8AhKdD/wCg&#xd;&#xa;lB+Zo/4SnQ/+glB+Zo/4SnQ/+glB+Zo/4SnQ/wDoJQfmaP8AhKdD/wCglB+Zo/4SnQ/+glB+ZqzY&#xd;&#xa;61p2ozGGyu45pFXcVU8gcDP6ir9FFFFFFFFFY/i3/kWNQ/65H+dbFFY/hX/kAxf9dZv/AEa9bFFF&#xd;&#xa;Y96XvL+eGGWUi2hztikZMSnlQcEZ4xwcinw6p9m8OJqF7vkeKEfaAgG7eOHGOBkMCKZN4gjginnk&#xd;&#xa;0++FvEpfzii7XA6EfNnntkCrNrqYurryo7O6EeCVuGQCNvpzn9Khm1tY5WCaffSxKeZ0RdnueWB4&#xd;&#xa;57dqtW2oQ3VzPBHuDRbTlhgOCoOV9RyB9aG1G2jFy0j7I7bHmSH7o/H271Xt9Y82dY5dOvrUMcCS&#xd;&#xa;aNQuT0HDGtOiisfX/wDX6P8A9hBP/QHrYrP1/wD5F/Uv+vWX/wBANWNP/wCQfbf9cl/kKz/FX/IB&#xd;&#xa;l/66w/8Ao1K2KKxPEM3lS2q3FxJa2DB/PmjcoVYbdg3DkZ5qm8uzw/qVxpGpPeQLC4zLMxeNwuSw&#xd;&#xa;fk8DGF45781qWM2pvp6M9tbF/KUpm6Y7zxncfL4457/1qOTWJLWZ4L21RJhCZlEMpdSoYLySqkHL&#xd;&#xa;DseKpeJbi8/4R++iu7NEDwkq8EpkUYx97KrjrxjPfp32Yrz7ReSQwIHjh+WWQtja/wDdAxye56Yy&#xd;&#xa;OueLdFY7/wDI4w/9g+T/ANGJWxRRRRRRRRRRRRRRRRRRRRRRRRRRRXlvgfQLHXPt325XPk+Xs2Nj&#xd;&#xa;ruz/ACFdX/wgWh/885/+/po/4QLQ/wDnnP8A9/TR/wAIFof/ADzn/wC/po/4QLQ/+ec//f00f8IF&#xd;&#xa;of8Azzn/AO/po/4QLQ/+ec//AH9NH/CBaH/zzn/7+mj/AIQLQ/8AnnP/AN/TR/wgWh/885/+/po/&#xd;&#xa;4QLQ/wDnnP8A9/TR/wAIFof/ADzn/wC/po/4QLQ/+ec//f00f8IFof8Azzn/AO/po/4QLQ/+ec//&#xd;&#xa;AH9NH/CBaH/zzn/7+mud+H0axeLL6NPupBIo+gkWvSaKKKKKKKKKx/Fv/Isah/1yP862KKx/Cv8A&#xd;&#xa;yAYv+us3/o162KKhvLlLOznupAxSGNpGC9SAMnH5VhaZpmsLbecmqwRtOTIc2vmMQTldzlgTgYHt&#xd;&#xa;07VnaqtxYafrVjeXAneeA3MbRpsRVBUN8ueCWbPGc8k8mtzxb/yLGof9cj/OtDUHnj0+5e1XdcLE&#xd;&#xa;xiXGctg4H51yVxNpktnKE1bUbi9MZ3W0V25O7HzDaSBgckj0BrWk/wBAaw1U/MgtfszL027gGDZ9&#xd;&#xa;2VVxj+L2qextfs2izvdWrXBuXe4ktdgYgudxTBODjOM8ZxWfY6nFHewwaZqn9oxO4U27ktIoJ+Z9&#xd;&#xa;5PQdcYrqKKKx9f8A9fo//YQT/wBAetis/X/+Rf1L/r1l/wDQDVjT/wDkH23/AFyX+QrP8Vf8gGX/&#xd;&#xa;AK6w/wDo1K2KKqXz3sSq9lDFORw0TtsLehDdsc9jn2rN/s261Fr6e9RLOS5tDZiNW80Acnfnj+8e&#xd;&#xa;PbrzUNzaand2sdvPYQtb24AMBuMrdDoMnHy44bv0x71UtfD8/wBtmkTTLfTo2tTHiObzN7b1YZ4G&#xd;&#xa;Pu4q/qMOsatpN5bSWkFqXj2qvm+YXJ98DbjHoc57Y5v2dpJp8ot7dd1k2SAzYMB/ur6qf055OeNC&#xd;&#xa;isd/+Rxh/wCwfJ/6MStiiiiiiiiiiiiiiiiiiiiiiiiiiiiuB+Fv/MU/7Zf+z131U7W++0399a+X&#xd;&#xa;t+yOi7t2d25A3Tt1xU8zyqY/KiEgZ8OS+3auDz057ce9S1V1S5ez0u7uowpeGF5FDdCQpIz+VS2s&#xd;&#xa;hmtYZWADOiscdMkVLRVDVr2SxjtmiVCZbqKFtwPCswBx70+wvvtr3i+Xs+zXBh+9ndhVOfb71TyP&#xd;&#xa;Ks0SpEGjYnzGL4KDHHGOeeKlqvfXcVhZy3U5IiiXc2Bk4qxRXnPgP/kcdR/65Sf+jFr0aiiiiiii&#xd;&#xa;iisrxPFJP4dvooY3kkaIhURSST7AVpQyxzxLLDIkkbDKujAgj2Ip9Y/hX/kAxf8AXWb/ANGvWxRR&#xd;&#xa;RRRRRVW9s1vRCkjfukkDvGRkSAA4H4Ntb/gNWqKKKKx9f/1+j/8AYQT/ANAetis/X/8AkX9S/wCv&#xd;&#xa;WX/0A1Y0/wD5B9t/1yX+QrP8Vf8AIBl/66w/+jUrYqh/a1qILu5dittauUeXBPIOGGOvB4q/RRRR&#xd;&#xa;RUF7ciztJLl1LJENz4/hXPzN+AycdeOKljdZY1kQ5VgGB9QayX/5HGH/ALB8n/oxK2KKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKK4H4W/8xT/tl/7PXfVj6V/yHtc/66xf+ilp2uuyzaTtYjdfqDg9RsfiqyWi&#xd;&#xa;3vifUlnllMMUUP7kPhGJDcn6Y7VV1NRavrFnBlbf+yWl8vJI3neCefYD8qtWUwvns4Z3eG3ESmKJ&#xd;&#xa;lZDcMF5PI5Ax04Py5+6RUF5cXd3rd7b/ANnS3tvalFVI5ljXLKGy2SCTyQMcYNRi41WAJaTQS2dv&#xd;&#xa;c3KQxM0qvKisrlgpUkDG1QMjoT1qxrem2lqthJBFtf7fAM7if4x6mrWgf6/WP+wg/wD6AlO1R2XX&#xd;&#xa;NFUMQrSy7gDwf3TVXvraRdTllu7SW8tHKlWjY/uAFAI2g7myeeAetQa5HbP4Ov8AyJnnjVSV3nmM&#xd;&#xa;5+5jgjHTB5Het21srez3fZ49m/G75ic4+v1qxXnPgP8A5HHUf+uUn/oxa9GoooooooooorH8Jf8A&#xd;&#xa;Isaf/wBch/Otiuc8Oatp1to6Q3GoWsUqyzbkkmVWH71j0JrT/t3SP+grY/8AgQn+NH9u6R/0FbH/&#xd;&#xa;AMCE/wAaP7d0j/oK2P8A4EJ/jR/bukf9BWx/8CE/xo/t3SP+grY/+BCf40f27pH/AEFbH/wIT/Gj&#xd;&#xa;+3dI/wCgrY/+BCf40f27pH/QVsf/AAIT/Gj+3dI/6Ctj/wCBCf40f27pH/QVsf8AwIT/ABo/t3SP&#xd;&#xa;+grY/wDgQn+NH9u6R/0FbH/wIT/Gj+3dI/6Ctj/4EJ/jR/bukf8AQVsf/AhP8aztW1KxvLvSI7W9&#xd;&#xa;tp3F8rFYpVYgbH5wD710NZ+t86dsP3ZZoYnH95WlVWH4gkfjV5EWNFRBhVGAPQVk+Kv+QDL/ANdY&#xd;&#xa;f/RqVoX5IsLkg4Iibn8DXP3oH/Cud2OWsY2Y+pKjJPvW5q88lto99PC22WK3kdGxnBCkg81zsVpd&#xd;&#xa;Wt3ayWmj3FkxnRZJZb5ZB5ZYbhtLnkj0GfSnw2VrqOhzapftIbk+bmTz3jHysyrwCB0AHTmo4jFq&#xd;&#xa;OnWCLp1zqE0FrEJTHdGHYWRWAOWG7IOc80ljLNqMtnp155i25lukaHfhlEZUIpdTk4yRnPPfNaFz&#xd;&#xa;CdMks54Lh5oobjyPLLZEaOVByep24JyfWr2jRF7OaaUlvtcrSlG5CggLtHtxn8ai8LsW0KIsST5s&#xd;&#xa;w5PYStSP/wAjjD/2D5P/AEYlbFFFFFFFFFFFFFFFFFFFFFFFFFFFFcD8Lf8AmKf9sv8A2eu+rHm0&#xd;&#xa;e6/tC6u7TVZbX7SVZ0WFGGQoX+IH0p40meT7ObzUZLloLgToTGi9FIx8oH96rUFisOo3V4HJa4WN&#xd;&#xa;SuOBtz/8VUN5pEd3PdytKym5tDakAdBlufr81TS6fDNYpbSZIjUBXHDKRjBBH0qK7015WSa2u3tb&#xd;&#xa;sLtedEVi69wVPHUDnGeMdKbFpCNBKl9M95JNjfI3yHAzjAXAXGTyMGqz6DJcyQSX+pTXT28ySxEo&#xd;&#xa;qBcHJGFwDnA65xjinHRruO5uZbPV5rZLiUytGIY2AYgDqwJ7CpIdJn+1Wtxd6jJdPbOzpujReqlc&#xd;&#xa;fKB65p93ptxJcvNZajLZmTBkCorhiBgH5gccDtT49JtRpsllMpljnJackkGRjyzcdMnnAwKfYWt3&#xd;&#xa;beZ9q1B7zdjbvjRNvXP3QM5/pVyvOfAf/I46j/1yk/8ARi16NRRRRRRRRRRWTaKdM1Oa3bi1um82&#xd;&#xa;JycAOeDGB2GAD+Na1VzZWhJJtYST38sUfYbP/n1g/wC/Yo+w2f8Az6wf9+xR9hs/+fWD/v2KPsNn&#xd;&#xa;/wA+sH/fsUfYbP8A59YP+/Yo+w2f/PrB/wB+xR9hs/8An1g/79ij7DZ/8+sH/fsUfYbP/n1g/wC/&#xd;&#xa;Yo+w2f8Az6wf9+xR9hs/+fWD/v2KPsNn/wA+sH/fsUfYbP8A59YP+/Yo+w2f/PrB/wB+xSpZ20bB&#xd;&#xa;kt4VYdCEAIqesg51LWYnTP2SyJO8dHlIIK4PUAFSCOM/StesfxV/yAZf+usP/o1K12UMpVgCpGCC&#xd;&#xa;OCKzE0hWsbvT7hy9pKx2AMQUU87B6AdAB2pi+H4AwL3moSpn5o5bp3Rx6MDwQe4NSW+h28M6yvcX&#xd;&#xa;lzsO5UuJ2kUEdDg9x2NZt/oN5NfS/Z0tvsL8eQ87hORyfKC7c5y31561eXw9brBBGlxdQtFEsbPb&#xd;&#xa;ymIybVABbb1OBTk0CzS0ECPcKwdpBMJSJQWOW+frz39adcaXjSZbC02gXAKTSSsSxDDDMT/E2PX0&#xd;&#xa;FT3FrKdLNpbS7HMYiEmSCo6FhjuBkj3xU1rbx2tskESgKg7DGT3P1JyfxrNf/kcYf+wfJ/6MStii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiuB+Fv/ADFP+2X/ALPXfUUUUUUUUUUUUUUV5z4D/wCRx1H/AK5S&#xd;&#xa;f+jFr0aiiiiiiiiiiobq2iu4GimXIPII6qezKexHUHtVD+0V0yUWupTYDECGdukmf4T/ALQOfwwc&#xd;&#xa;5JrVooooooooooooooorIXU5dTYf2K9vJAp2zTuThSeyADlgOSDgcr740bS3W0tkgQkqg6nv3qaq&#xd;&#xa;OsWDanpslok3kszIwk27sFWDdMjPSqv2HXP+g1B/4Aj/AOLo+w65/wBBqD/wBH/xdH2HXP8AoNQf&#xd;&#xa;+AI/+Lo+w65/0GoP/AEf/F0fYdc/6DUH/gCP/i6PsOuf9BqD/wAAR/8AF0fYdc/6DUH/AIAj/wCL&#xd;&#xa;o+w65/0GoP8AwBH/AMXR9h1z/oNQf+AI/wDi6PsOuf8AQag/8AR/8XTrLS7yLVft97qCXLCBoVVb&#xd;&#xa;fy8AsDn7x9K1qKKKKKKKKKKKKKKKKKKKKKKKKKKK8xtfCHiiy3fZJ/s+/G7yrkpux0zj6mrH/CP+&#xd;&#xa;M/8AoIz/APga3+NH/CP+M/8AoIz/APga3+NH/CP+M/8AoIz/APga3+NH/CP+M/8AoIz/APga3+NH&#xd;&#xa;/CP+M/8AoIz/APga3+NH/CP+M/8AoIz/APga3+NH/CP+M/8AoIz/APga3+NH/CP+M/8AoIz/APga&#xd;&#xa;3+NH/CP+M/8AoIz/APga3+NH/CP+M/8AoIz/APga3+NH/CP+M/8AoIz/APga3+NH/CP+M/8AoIz/&#xd;&#xa;APga3+NH/CP+M/8AoIz/APga3+NH/CP+M/8AoIz/APga3+NH/CP+M/8AoIz/APga3+NaPg3w3qek&#xd;&#xa;axNd34TbJCyZEm4liyn+hrtaKKKKKKKKKKKRlDKVYAqRggjgisqTQYN5a2uLq0A5SKCZkiU+yDA6&#xd;&#xa;8n1yab9h1z/oNQf+AI/+Lo+w65/0GoP/AABH/wAXR9h1z/oNQf8AgCP/AIuj7Drn/Qag/wDAEf8A&#xd;&#xa;xdH2HXP+g1B/4Aj/AOLo+w65/wBBqD/wBH/xdH2HXP8AoNQf+AI/+Lo+w65/0GoP/AEf/F0fYdc/&#xd;&#xa;6DUH/gCP/i6PsOuf9BqD/wAAR/8AF0fYdc/6DUH/AIAj/wCLo+w65/0GoP8AwBH/AMXR9h1z/oNQ&#xd;&#xa;f+AI/wDi6PsGtNw+tRFTwdtntOPY7+KfFoFmrZuHuL1McR3kpmQH1AbIz7+5rVoooooooooooooo&#xd;&#xa;oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;or//2Q==</binary>
<binary id="image24.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkz&#xd;&#xa;ODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/wAALCACRAxQBAREA/8QAHwAAAQUBAQEB&#xd;&#xa;AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh&#xd;&#xa;ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ&#xd;&#xa;WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG&#xd;&#xa;x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEBAAA/AOuv9YSyvI7VbO6uZnjM&#xd;&#xa;gECqcKCBzkjuRUP9uyf9ATVf+/Sf/F0f27J/0BNV/wC/Sf8AxdH9uyf9ATVf+/Sf/F0f27J/0BNV&#xd;&#xa;/wC/Sf8AxdH9uyf9ATVf+/Sf/F1HP4kFuEM2kamgdwi5jTlicAffqT+3ZP8AoCar/wB+k/8Ai6P7&#xd;&#xa;dk/6Amq/9+k/+Lo/t2T/AKAmq/8AfpP/AIuj+3ZP+gJqv/fpP/i6P7dk/wCgJqv/AH6T/wCLo/t2&#xd;&#xa;T/oCar/36T/4uj+3ZP8AoCar/wB+k/8Ai6P7dk/6Amq/9+k/+Lo/t2T/AKAmq/8AfpP/AIuj+3ZP&#xd;&#xa;+gJqv/fpP/i6P7dk/wCgJqv/AH6T/wCLqO48SC2iMs+kanHGCAWMaYyTgfx+pFSf27J/0BNV/wC/&#xd;&#xa;Sf8AxdH9uyf9ATVf+/Sf/F0f27J/0BNV/wC/Sf8AxdH9uyf9ATVf+/Sf/F0f27J/0BNV/wC/Sf8A&#xd;&#xa;xdR3HiQWsDzz6RqccSDLMY0wB/33Un9uyf8AQE1X/v0n/wAXR/bsn/QE1X/v0n/xdH9uyf8AQE1X&#xd;&#xa;/v0n/wAXR/bsn/QE1X/v0n/xdH9uyf8AQE1X/v0n/wAXTJvERgheaXR9USONSzMYkwAOSfv05Nfd&#xd;&#xa;0V00XVCrDIIiTkf990v9uyf9ATVf+/Sf/F0f27J/0BNV/wC/Sf8AxdH9uyf9ATVf+/Sf/F0f27J/&#xd;&#xa;0BNV/wC/Sf8AxdH9uyf9ATVf+/Sf/F1HB4kFwHMOkam4RyjYjThgcEffqT+3ZP8AoCar/wB+k/8A&#xd;&#xa;i6P7dk/6Amq/9+k/+Lo/t2T/AKAmq/8AfpP/AIuj+3ZP+gJqv/fpP/i6P7dk/wCgJqv/AH6T/wCL&#xd;&#xa;qOHxIJzIItI1NzE+x8Rp8rYBx9/3FSf27J/0BNV/79J/8XR/bsn/AEBNV/79J/8AF0f27J/0BNV/&#xd;&#xa;79J/8XR/bsn/AEBNV/79J/8AF0f27J/0BNV/79J/8XUcfiQSyyxJpGptJCQJFEaZUkZGfn9DUn9u&#xd;&#xa;yf8AQE1X/v0n/wAXR/bsn/QE1X/v0n/xdH9uyf8AQE1X/v0n/wAXR/bsn/QE1X/v0n/xdH9uyf8A&#xd;&#xa;QE1X/v0n/wAXUaeJA88kC6RqZliCl18tMqDnH8fsak/t2T/oCar/AN+k/wDi6P7dk/6Amq/9+k/+&#xd;&#xa;Lo/t2T/oCar/AN+k/wDi6P7dk/6Amq/9+k/+Lo/t2T/oCar/AN+k/wDi6jHiQG5NuNI1Pzggcp5a&#xd;&#xa;Z2kkA/f9Qak/t2T/AKAmq/8AfpP/AIuj+3ZP+gJqv/fpP/i6P7dk/wCgJqv/AH6T/wCLo/t2T/oC&#xd;&#xa;ar/36T/4uj+3ZP8AoCar/wB+k/8Ai6jm8SCAxiXSNTQyvsTMafM2Ccff9jUn9uyf9ATVf+/Sf/F0&#xd;&#xa;f27J/wBATVf+/Sf/ABdH9uyf9ATVf+/Sf/F0f27J/wBATVf+/Sf/ABdH9uyf9ATVf+/Sf/F1DceJ&#xd;&#xa;0tfK8/SdTj82QRJmNPmY9B96pv7dk/6Amq/9+k/+Lo/t2T/oCar/AN+k/wDi6P7dk/6Amq/9+k/+&#xd;&#xa;Lo/t2T/oCar/AN+k/wDi6P7dk/6Amq/9+k/+LqOfxILcIZtI1NA7hFzGnLE4A+/Un9uyf9ATVf8A&#xd;&#xa;v0n/AMXR/bsn/QE1X/v0n/xdH9uyf9ATVf8Av0n/AMXR/bsn/QE1X/v0n/xdH9uyf9ATVf8Av0n/&#xd;&#xa;AMXUdx4kFtEZZ9I1OOMEAsY0xknA/j9SKk/t2T/oCar/AN+k/wDi6P7dk/6Amq/9+k/+Lo/t2T/o&#xd;&#xa;Car/AN+k/wDi6P7dk/6Amq/9+k/+Lo/t2T/oCar/AN+k/wDi6juPEgtYHnn0jU44kGWYxpgD/vup&#xd;&#xa;P7dk/wCgJqv/AH6T/wCLo/t2T/oCar/36T/4uj+3ZP8AoCar/wB+k/8Ai6P7dk/6Amq/9+k/+Lo/&#xd;&#xa;t2T/AKAmq/8AfpP/AIumTeIjBC80uj6okcalmYxJgAck/frYhkE0KSqCFdQwz1wayn/5HGH/ALB8&#xd;&#xa;n/oxK2KKKKKx/Ef+osP+whb/APoYrYoooooooooorH8Vf8gGX/rrD/6NStiiiiisfxb/AMixqH/X&#xd;&#xa;I/zrYoooorP1/wD5F/Uv+vWX/wBANWNP/wCQfbf9cl/kKsUUUUVj+HP9Rf8A/YQuP/QzWxRRRRWP&#xd;&#xa;oH+v1j/sIP8A+gJWxRRRRWPpX/Ie1z/rrF/6KWtiiiiisew/5GfV/wDrlb/yetiiiiisdP8AkcZv&#xd;&#xa;+wfH/wCjHrYoooorH1//AF+j/wDYQT/0B62KKKKKwPFn/MF/7CsH/s1b9FFFFY/iP/UWH/YQt/8A&#xd;&#xa;0MVsUUUUVj+Kv+QDL/11h/8ARqVsUUUUVj+Lf+RY1D/rkf51sUUUUVn6/wD8i/qX/XrL/wCgGrGn&#xd;&#xa;/wDIPtv+uS/yFZ7/API4w/8AYPk/9GJWxRXIaz4wmj1M6dotvHcXEZYSGUEL8oJYDkcjBrb8O6t/&#xd;&#xa;bWkRXhj8tz8rgdNw649s1qVj+I/9RYf9hC3/APQxWxRXJ674snt9Wj0vRoI7m7LbXEgIAP8AdHI5&#xd;&#xa;9+nNafhbWm13SvtTxCORHMbgdCQAcj25rZooormPEHiiaz1GPS9JhS41BmAZZAQoyM46jnkHrVvw&#xd;&#xa;trkutWcpuYViuLdzHKE+7nnpye1blY/ir/kAy/8AXWH/ANGpWxRXN+JPEzaZdQafp8ST6hMwARwd&#xd;&#xa;oyQBnkdc+vbmpPCfiCbW0uo7qBYri1YB9n3TnPTk/wB010FY/i3/AJFjUP8Arkf51sUVz3ijxKNG&#xd;&#xa;8u1tkWW/mwY0cHaATjJ6ehHWk8MeIZ9WnurK+tlhvLUkSbPu8HGOp5roqz9f/wCRf1L/AK9Zf/QD&#xd;&#xa;VjT/APkH23/XJf5CrFYPinxJHoNqoQCS7l/1aMDjHqfb8c81H4a1681K6u7HUrZILu2OWEf3cccd&#xd;&#xa;Tz1roqKx/Dn+ov8A/sIXH/oZrYrF8TeIIdBsg7DfcShhChBwSO59hkVT8NeIr3UdSn07UrWOG5ji&#xd;&#xa;Ew8rptO3GeTz8wNdNRWPoH+v1j/sIP8A+gJWxWR4h1+20Gz8yY7ppAfJjwfnIxnnpxkGsvw54nvt&#xd;&#xa;Q1IWOp2kUTywrNCYum0jOTyeoxXV0Vj6V/yHtc/66xf+ilrYrM17XLbQrIXFyGZmOEjUcue/PQcc&#xd;&#xa;81heH/FeoXuq21lqVpDGLuIyQNFnoAxyck/3SK7Cisew/wCRn1f/AK5W/wDJ62KK5/SvE8Or+IJb&#xd;&#xa;Gyw9tHAZPNIILNlRxnt8x7dq6CisdP8AkcZv+wfH/wCjHrYornbTxTFqHiUaZZqGiRXMkrAjJAHT&#xd;&#xa;6HIORXRUVj6//r9H/wCwgn/oD1sVW1G+g02xlvLltsUQyTgnqcAce5Fcbb+OL9ry2knsYl065ldI&#xd;&#xa;mX/WEDj+9jIyuePpXd0VgeLP+YL/ANhWD/2at+s/W9Xt9FsDd3OSN21FA5ZsE4/Q1z/h/wAV6he6&#xd;&#xa;rbWWpWkMYu4jJA0WegDHJyT/AHSK7CisfxH/AKiw/wCwhb/+hitiqWranb6TYSXlySEQcADlm7D8&#xd;&#xa;a5nRvF9/d6naxXtnElte7hbvH944bGTyfQ9q7OisfxV/yAZf+usP/o1K2KqanqNtpVm11dvsjXjo&#xd;&#xa;Tk9hxXJ6f40vrjUrUXFlEthezmGBl+/ncBzz23DPH0rt6Kx/Fv8AyLGof9cj/OtiisGTxJG3im20&#xd;&#xa;a2Acnd57kH5SFY4HvwPUc1vUVn6//wAi/qX/AF6y/wDoBqxp/wDyD7b/AK5L/IVnv/yOMP8A2D5P&#xd;&#xa;/RiVsUVxHhAf8Vj4g/66v/6MNWPBn/IweJh2F1/7PJXX1j+I/wDUWH/YQt//AEMVsUVyHh0f8Vxr&#xd;&#xa;v4fzo8OceNtdHbj+ddfRRRXIad/yU7Vf+vVf5RUabx8TdWA6fZV/lFXX1j+Kv+QDL/11h/8ARqVs&#xd;&#xa;UVyH/NTv+3X+lA4+J2BwPsv9K6+sfxb/AMixqH/XI/zrYorkNS5+J2lf9erfylqvccfFW1x3iP8A&#xd;&#xa;6Lau3rP1/wD5F/Uv+vWX/wBANWNP/wCQfbf9cl/kKsVyHiPnxvoOff8AnVfXuPiPpGOMxJ/6E9dv&#xd;&#xa;RWP4c/1F/wD9hC4/9DNbFch4z/5GDwz/ANfX/s8dHiHjxvoWOM5/nXX0Vj6B/r9Y/wCwg/8A6Alb&#xd;&#xa;FcR8Qv8AkIaF/wBdX/mlWPGXHiHwzjj/AEr/ANnjrr6Kx9K/5D2uf9dYv/RS1sVxHxP/AOQfY/8A&#xd;&#xa;XVv5VY8fcf2Rjj/Sh/SuvorHsP8AkZ9X/wCuVv8Ayetiq2o2Ueo2E1pKzqky7SUPI+lcnoVpBY/E&#xd;&#xa;XU7a1jEUKWo2oOgz5ZP6mu1orHT/AJHGb/sHx/8Aox62KhvLdbyzntpCypNG0bFeoBGOPzrh9Is4&#xd;&#xa;NP8AiTNa2ybIo4QAP+2akn8ya76isfX/APX6P/2EE/8AQHrYrA8df8ijff8AbP8A9GLWfrQH/CsY&#xd;&#xa;jj/l1t/5pW/oH/Iv6b/16xf+gCtCsDxZ/wAwX/sKwf8As1b9ch8TP+Rft/8Ar6X/ANAeq/xO40+x&#xd;&#xa;I4/et0+ldvRWP4j/ANRYf9hC3/8AQxWxXMfEP/kWH/66p/Os/wAd8eD9OI4Pmx/+i2rt6Kx/FX/I&#xd;&#xa;Bl/66w/+jUrYrmPiH/yLD/8AXVP51n+Ixj4cWBHXyrf/ANBFdfYf8g+2/wCuS/yFWKx/Fv8AyLGo&#xd;&#xa;f9cj/OtimTRiaF4mJAdSpI681w0WlW2j/EHSLW1B2/ZmZmY5LHbIMn34Fd5RWfr/APyL+pf9esv/&#xd;&#xa;AKAasaf/AMg+2/65L/IVnv8A8jjD/wBg+T/0YlbFFee2V+vhrxdqr6lE8cd07sjjkY3Fh09eB+Na&#xd;&#xa;fgRZprrWNSaFo4L2YSRbsZPzOT/6EK6+sfxH/qLD/sIW/wD6GK2KK4RdQXw540v5dRieOC9wUlHI&#xd;&#xa;C56nH0PHWrPgxpb/AFvVNXWB47a5ICFsZzwcV2VFFFcPdXY0Hx/c39/G6Wl3CsaSjkDhMk456qak&#xd;&#xa;8MSvqvjHUtYhhdbOSHyldscsNg/9lJrtKx/FX/IBl/66w/8Ao1K2KK4nWbg6L45h1O7icWcsQiEg&#xd;&#xa;5A6Ak9+M0mh3Ta542l1W2gcWkcPls7Y68gfniu3rH8W/8ixqH/XI/wA62KK4vxPK+leMdO1iaF2s&#xd;&#xa;44fKZ1xwx3j/ANmBqtptwdc+IKalZwubSBWVpDwCNrKCPqSK72s/X/8AkX9S/wCvWX/0A1Y0/wD5&#xd;&#xa;B9t/1yX+QqxXG+M2lsNb0vV2geS2tiQ5XGc8nFU/tB8ReOrS906J5LWzVUeU8AgFjkZ/3h7131FY&#xd;&#xa;/hz/AFF//wBhC4/9DNbFch47WaG60fUlhaSCymMku3GR8yEf+gmqZ1BfEfjLTptOid4bNd0kh4GD&#xd;&#xa;jPX0JxXd0Vj6B/r9Y/7CD/8AoCVsVxvxBtbl/wCzr6KFpIbN2aUqRlQSmOPwqnfaonifxDof9mwy&#xd;&#xa;OLSRZpieAoJQkc9xtP8ASu+orH0r/kPa5/11i/8ARS1sVx/xHs7i50q3kgiaRYZCZMdgeBx9TWbr&#xd;&#xa;Osx+KLvSrbTIJHlSQTODxs65BPqAM16FRWPYf8jPq/8A1yt/5PWxRXIab/yU7Vv+vVf5RV19FY6f&#xd;&#xa;8jjN/wBg+P8A9GPWxRXEW3/JVbv/AK5D/wBFrXb0Vj6//r9H/wCwgn/oD1sVi+L7Wa98M3kFtGZJ&#xd;&#xa;WCkKCBkBwT+gNcjfeIre+8I2+iQQytePHHCUx90oV5P1wfy5rvNHhkttGsYJl2yRW8aOuc4IUAir&#xd;&#xa;lYHiz/mC/wDYVg/9mrfrlviFaT3fh9Ps8RkMU4kcDsoVhn9RWB4l1ZfFosbLSbeSSfmRlOBtOD8p&#xd;&#xa;J4zgZ9Oa9IorH8R/6iw/7CFv/wChitiue8c2k954bmS3jMjIwkYD+6OSa5fW9YTxFo+naVp8Ej3Y&#xd;&#xa;cMyHjbtDLgnpzkGvSaKx/FX/ACAZf+usP/o1K2K5/wAbWVxf+HpIbWIySB1cqCBwOvWuV1DW4tV8&#xd;&#xa;MafolpBK17+7iKYxtKADn6n8sc16JZo0dnAjjDLGoI9CBU1Y/i3/AJFjUP8Arkf51sUVyGpf8lO0&#xd;&#xa;n/r1b+UtdfRWfr//ACL+pf8AXrL/AOgGrGn/APIPtv8Arkv8hWe//I4w/wDYPk/9GJWxRVe7sbS+&#xd;&#xa;VVvLaKdVOVEiBsH8aljjSGJI4kCRoAqqowAB0Ap9Y/iP/UWH/YQt/wD0MVsUVXu7G0vlVby2inVT&#xd;&#xa;lRIgbB/GpIYYreFYoI1jjQYVFGAB9KkoooqC7s7a9iEd3bxzxg7gsihgD68/U063t4bWBYbeJIol&#xd;&#xa;ztRFwBznpUtY/ir/AJAMv/XWH/0albFFQ3Vrb3kPlXUMc0ZOdkihhn6Gi1tbezh8q1hjhjBzsjUK&#xd;&#xa;M/QVNWP4t/5FjUP+uR/nWxRUVxbw3UDQ3ESSxNjcjrkHnPSktbW3s4fKtYY4Ywc7I1CjP0FTVn6/&#xd;&#xa;/wAi/qX/AF6y/wDoBqxp/wDyD7b/AK5L/IVYqOaGK4haKeNZI3GGRhkEfSmWlnbWURjtLeOCMncV&#xd;&#xa;jUKCfXj6Cp6Kx/Dn+ov/APsIXH/oZrYpkkaTRPHKgeNwVZWGQQeoNRWljaWKstnbRQKxywjQLk/h&#xd;&#xa;ViisfQP9frH/AGEH/wDQErYprKrqVYAqRgg9xUFnp9nYb/sdrDb78bvLQLux0zj6mrNFY+lf8h7X&#xd;&#xa;P+usX/opa2KKq2mm2NizNZ2kEDMMMY0C5H4VaorHsP8AkZ9X/wCuVv8AyetiioEs7ZLt7tLeNbiQ&#xd;&#xa;bWlCjcw44J/AflU9FY6f8jjN/wBg+P8A9GPWxRVcWNot414LaIXLDBl2DcRjHX6CrFFY+v8A+v0f&#xd;&#xa;/sIJ/wCgPWxRVOPS7CK7N3HZQLcElvNEYDZPU598mrlFYHiz/mC/9hWD/wBmrfoqraabY2LM1naQ&#xd;&#xa;QMwwxjQLkfhVqisfxH/qLD/sIW//AKGK2KKq22m2NpO09taQQyuCGdEAJBOTk/WrVFY/ir/kAy/9&#xd;&#xa;dYf/AEalbFFVYtNsYbprqK0gS4YktKqAMSevPvVqisfxb/yLGof9cj/OtiioHs7Z7tLt7eNriMbV&#xd;&#xa;lKjco54B/E/nU9FZ+v8A/Iv6l/16y/8AoBqxp/8AyD7b/rkv8hWe/wDyOMP/AGD5P/RiVsUUUUVj&#xd;&#xa;+I/9RYf9hC3/APQxWxRRRRRRRRRRWP4q/wCQDL/11h/9GpWxRRRRWP4t/wCRY1D/AK5H+dbFFFFF&#xd;&#xa;Z+v/APIv6l/16y/+gGrGn/8AIPtv+uS/yFWKKKKKx/Dn+ov/APsIXH/oZrYoooorH0D/AF+sf9hB&#xd;&#xa;/wD0BK2KKKKKx9K/5D2uf9dYv/RS1sUUUUVj2H/Iz6v/ANcrf+T1sUUUUVjp/wAjjN/2D4//AEY9&#xd;&#xa;bFFFFFY+v/6/R/8AsIJ/6A9bFFFFFYHiz/mC/wDYVg/9mrfoooorH8R/6iw/7CFv/wChitiiiiis&#xd;&#xa;fxV/yAZf+usP/o1K2KKKKKx/Fv8AyLGof9cj/Otiiiiis/X/APkX9S/69Zf/AEA1Y0//AJB9t/1y&#xd;&#xa;X+QqhqlvexX0WpafAtzOsRgMLuEG0kNuz9VAx71W/tDxL/0BLf8A8CxR/aHiX/oCW/8A4Fij+0PE&#xd;&#xa;v/QEt/8AwLFH9oeJf+gJb/8AgWKP7Q8S/wDQEt//AALFVdQbxJfJAp0eBPJnjm4ugc7TnFWv7Q8S&#xd;&#xa;/wDQEt//AALFH9oeJf8AoCW//gWKP7Q8S/8AQEt//AsUf2h4l/6Alv8A+BYo/tDxL/0BLf8A8CxR&#xd;&#xa;/aHiX/oCW/8A4Fij+0PEv/QEt/8AwLFH9oeJf+gJb/8AgWKP7Q8S/wDQEt//AALFH9oeJf8AoCW/&#xd;&#xa;/gWKP7Q8S/8AQEt//AsVV1RvEmo2LWzaPBGGZG3C6B+6wb+lWv7Q8S/9AS3/APAsUf2h4l/6Alv/&#xd;&#xa;AOBYo/tDxL/0BLf/AMCxR/aHiX/oCW//AIFij+0PEv8A0BLf/wACxVXVW8Salps9m2jwRiZdpYXQ&#xd;&#xa;OKtf2h4l/wCgJb/+BYo/tDxL/wBAS3/8CxR/aHiX/oCW/wD4Fij+0PEv/QEt/wDwLFH9oeJf+gJb&#xd;&#xa;/wDgWKgvpvEl7YXFqdGgQTxNGWF0DjIIz+tSQXfiSG3jiGi252KFz9qHOBT/AO0PEv8A0BLf/wAC&#xd;&#xa;xR/aHiX/AKAlv/4Fij+0PEv/AEBLf/wLFH9oeJf+gJb/APgWKP7Q8S/9AS3/APAsVV09vElik6jR&#xd;&#xa;4H86eSbm6AxuOcVa/tDxL/0BLf8A8CxR/aHiX/oCW/8A4Fij+0PEv/QEt/8AwLFH9oeJf+gJb/8A&#xd;&#xa;gWKP7Q8S/wDQEt//AALFVbFvElk92w0eB/tM5mOboDbkAY/8dq1/aHiX/oCW/wD4Fij+0PEv/QEt&#xd;&#xa;/wDwLFH9oeJf+gJb/wDgWKP7Q8S/9AS3/wDAsUf2h4l/6Alv/wCBYqrat4kt769uRo8DG6ZWK/ah&#xd;&#xa;8u1Qv9Ktf2h4l/6Alv8A+BYo/tDxL/0BLf8A8CxR/aHiX/oCW/8A4Fij+0PEv/QEt/8AwLFH9oeJ&#xd;&#xa;f+gJb/8AgWKqwN4kh1K7vBo8BNysalftQ+Xbu/8Aiqtf2h4l/wCgJb/+BYo/tDxL/wBAS3/8CxR/&#xd;&#xa;aHiX/oCW/wD4Fij+0PEv/QEt/wDwLFH9oeJf+gJb/wDgWKqhvEg1d7/+x4MtAsOz7UOzE5z+NWv7&#xd;&#xa;Q8S/9AS3/wDAsUf2h4l/6Alv/wCBYo/tDxL/ANAS3/8AAsUf2h4l/wCgJb/+BYo/tDxL/wBAS3/8&#xd;&#xa;CxVW+bxJevaMdHgT7NOJhi6B3YBGP/Hqtf2h4l/6Alv/AOBYo/tDxL/0BLf/AMCxR/aHiX/oCW//&#xd;&#xa;AIFij+0PEv8A0BLf/wACxR/aHiX/AKAlv/4FiqOqJ4j1L7Hu0iCP7LdJcDFyDuK54/Wr39oeJf8A&#xd;&#xa;oCW//gWKP7Q8S/8AQEt//AsUf2h4l/6Alv8A+BYo/tDxL/0BLf8A8CxR/aHiX/oCW/8A4FiquoN4&#xd;&#xa;kvkgU6PAnkzxzcXQOdpzirX9oeJf+gJb/wDgWKP7Q8S/9AS3/wDAsUf2h4l/6Alv/wCBYo/tDxL/&#xd;&#xa;ANAS3/8AAsUf2h4l/wCgJb/+BYqrqjeJNRsWtm0eCMMyNuF0D91g39Ktf2h4l/6Alv8A+BYo/tDx&#xd;&#xa;L/0BLf8A8CxR/aHiX/oCW/8A4Fij+0PEv/QEt/8AwLFH9oeJf+gJb/8AgWKq6q3iTUtNns20eCMT&#xd;&#xa;LtLC6BxVr+0PEv8A0BLf/wACxR/aHiX/AKAlv/4Fij+0PEv/AEBLf/wLFH9oeJf+gJb/APgWKP7Q&#xd;&#xa;8S/9AS3/APAsVBfTeJL2wuLU6NAgniaMsLoHGQRn9a6G0jaKzgjcYZI1U/UCpqKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKrX1hbajCIbuPzEVtwG4rzyOx9zVD/AIRfR/8An0P/AH9f&#xd;&#xa;/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/&#xd;&#xa;AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8A&#xd;&#xa;n0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRf&#xd;&#xa;R/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/&#xd;&#xa;AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f&#xd;&#xa;/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/&#xd;&#xa;AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8A&#xd;&#xa;n0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRf&#xd;&#xa;R/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/&#xd;&#xa;AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f&#xd;&#xa;/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/&#xd;&#xa;AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8An0P/AH9f/Gj/AIRfR/8A&#xd;&#xa;n0P/AH9f/Gj/AIRfR/8An0P/AH9f/GtK0tYbK2S3t02RJnauScZOep+tTUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU&#xd;&#xa;UUVm3ep3FvcvFHpN5cKuMSR7NrcdssDUP9s3f/QC1D/yH/8AFUf2zd/9ALUP/If/AMVR/bN3/wBA&#xd;&#xa;LUP/ACH/APFUf2zd/wDQC1D/AMh//FUf2zd/9ALUP/If/wAVR/bN3/0AtQ/8h/8AxVH9s3f/AEAt&#xd;&#xa;Q/8AIf8A8VR/bN3/ANALUP8AyH/8VR/bN3/0AtQ/8h//ABVH9s3f/QC1D/yH/wDFUf2zd/8AQC1D&#xd;&#xa;/wAh/wDxVH9s3f8A0AtQ/wDIf/xVH9s3f/QC1D/yH/8AFUf2zd/9ALUP/If/AMVR/bN3/wBALUP/&#xd;&#xa;ACH/APFUf2zd/wDQC1D/AMh//FUf2zd/9ALUP/If/wAVR/bN3/0AtQ/8h/8AxVH9s3f/AEAtQ/8A&#xd;&#xa;If8A8VR/bN3/ANALUP8AyH/8VR/bN3/0AtQ/8h//ABVH9s3f/QC1D/yH/wDFUf2zd/8AQC1D/wAh&#xd;&#xa;/wDxVH9s3f8A0AtQ/wDIf/xVH9s3f/QC1D/yH/8AFUf2zd/9ALUP/If/AMVR/bN3/wBALUP/ACH/&#xd;&#xa;APFUf2zd/wDQC1D/AMh//FUf2zd/9ALUP/If/wAVR/bN3/0AtQ/8h/8AxVH9s3f/AEAtQ/8AIf8A&#xd;&#xa;8VR/bN3/ANALUP8AyH/8VR/bN3/0AtQ/8h//ABVH9s3f/QC1D/yH/wDFUf2zd/8AQC1D/wAh/wDx&#xd;&#xa;VH9s3f8A0AtQ/wDIf/xVH9s3f/QC1D/yH/8AFUf2zd/9ALUP/If/AMVR/bN3/wBALUP/ACH/APFU&#xd;&#xa;f2zd/wDQC1D/AMh//FUf2zd/9ALUP/If/wAVR/bN3/0AtQ/8h/8AxVH9s3f/AEAtQ/8AIf8A8VR/&#xd;&#xa;bN3/ANALUP8AyH/8VR/bN3/0AtQ/8h//ABVH9s3f/QC1D/yH/wDFUf2zd/8AQC1D/wAh/wDxVH9s&#xd;&#xa;3f8A0AtQ/wDIf/xVayMWRWKlSRnB6inUUUUUUUUUUUUUUVy9jf3L/EDUrOS4c2sdsGWMn5VOI+f1&#xd;&#xa;P510wdWOAwP0NR3VzDZ27z3EgjiQZZj2rkIfER1Px5ZwWNxL9h8tlZc4WRgrncB+X5V2tFFFFFFF&#xd;&#xa;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#xd;&#xa;FFFFFFFFFFFed6hp82qfES+tI2kWF0T7QUYKfL2Jnr77am1PSYfBdzaatYzTvCZPJliZhlwQT1x0&#xd;&#xa;+Wut1vRrbXLNLa7aRUSQSAxkA5AI7g+prnbqCK2+JGjwwRrHElowVVHAGJa7Oiiiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiqWtSvBol/LExSRLaRlYdQQpINUfCF3Ld+GbOe6mMkr79zueT&#xd;&#xa;h2H8q2gQRkHIrmdZ1PULzWzomjyxo4i3XErKd0Q4wQcjPDDpnrVG8g8S+HrWTUBqSagqDDxzA4Vf&#xd;&#xa;73Uc8AfjXXWd1DfWsdzbtvilG5WwRkfQ1PRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRXHWDonxP1TeyrutlC5OMnEXFN+JM6Pp1rYpua5ecSLGqkkqFYH9SK7OuQ1L/kp2k/9erfylrr6&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKz9f8A+Rf1L/r1l/8AQDXEeFfDL65pavqk&#xd;&#xa;lwtnHn7GI5Fxyx38YOOQK2fCTyaXrF94dkkaZbdfNicnhVO04x/wOulSxtY76S9SBFuZF2vKB8zD&#xd;&#xa;jj9B+VYvje/S30OS1VTLPdERLGp+YZBO7HUj5cVraNYtpuk21mzh2hTaWAwDV2iiiiiiiiiiiiii&#xd;&#xa;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiuU1PwhJf65eakt55TyoPI2ZDRuAozkewP51Lo/hR7a6S71&#xd;&#xa;S+lvrmFswu0jYQenJrpqxbrRJJ/FdnrAmUJbwmMx45OQ/Of+BfpW1RRRRRRRRRRRRRRRRRRRRRRR&#xd;&#xa;RRRRRRRRRRRRRRRRRRRRWfr/APyL+pf9esv/AKAazfAkiN4Us0V1Lpv3KDyuXbGaztCnjvfiHqt1&#xd;&#xa;blngNvs37SBuHlgjn3BrotZ1i30i182XMkjHbHCnLOfQY+h5rP0HRJlmOqa1ibUnzjJ3CFeMADkA&#xd;&#xa;5zyPWuhooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo&#xd;&#xa;ooooooooooooooooooooooooqvf2323T7m137PPiaPdjO3cCM4/GuWi8Cva20aWGs3NrNz50kYIE&#xd;&#xa;vPy8BhjAz69a39G0W20aGRLYuxlIaRnbJZvWsjWvCM+qaw2oJrEtuRjy0VCfKwAODuGM4zx61D/w&#xd;&#xa;h+q/9DVffk3/AMXXTadbSWdhDbzXD3Eka4aV+r+55NWaKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK&#xd;&#xa;KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK//9k=</binary></FictionBook>